
==================== Pre unarise: ====================
2018-03-16 15:56:22.967349788 UTC

Data.Bits.$p1FiniteBits
  :: forall b. Data.Bits.FiniteBits b => Data.Bits.Bits b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_s1CEn]
        case v_s1CEn of {
          Data.Bits.C:FiniteBits v_s1CEp [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s1CEp;
        };

Data.Bits.finiteBitSize
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_s1CEt]
        case v_s1CEt of {
          Data.Bits.C:FiniteBits _ [Occ=Dead]
                                 v_s1CEw [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s1CEw;
        };

Data.Bits.countLeadingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_s1CEz]
        case v_s1CEz of {
          Data.Bits.C:FiniteBits _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s1CED [Occ=Once]
                                 _ [Occ=Dead] ->
              v_s1CED;
        };

Data.Bits.countTrailingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_s1CEF]
        case v_s1CEF of {
          Data.Bits.C:FiniteBits _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s1CEK [Occ=Once] ->
              v_s1CEK;
        };

Data.Bits.$p1Bits :: forall a. Data.Bits.Bits a => GHC.Classes.Eq a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLLLLLLLLLLLLLLLL),U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CEL]
        case v_s1CEL of {
          Data.Bits.C:Bits v_s1CEN [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CEN;
        };

Data.Bits..&. :: forall a. Data.Bits.Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLLLLLLLLLLLLLLLL),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CFa]
        case v_s1CFa of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           v_s1CFd [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CFd;
        };

Data.Bits..|. :: forall a. Data.Bits.Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLLLLLLLLLLLLLLLL),U(A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CFz]
        case v_s1CFz of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CFD [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CFD;
        };

Data.Bits.xor :: forall a. Data.Bits.Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLLLLLLLLLLLLLLLL),U(A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CFY]
        case v_s1CFY of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CG3 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CG3;
        };

Data.Bits.complement :: forall a. Data.Bits.Bits a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLLLLLLLLLLLLLLLL),U(A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CGn]
        case v_s1CGn of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CGt [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CGt;
        };

Data.Bits.shift
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLLLLLLLLLLLLLLLL),U(A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CGM]
        case v_s1CGM of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CGT [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CGT;
        };

Data.Bits.rotate
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLLLLLLLLLLLLLLLL),U(A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CHb]
        case v_s1CHb of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CHj [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CHj;
        };

Data.Bits.zeroBits :: forall a. Data.Bits.Bits a => a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSLLLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CHA]
        case v_s1CHA of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CHJ [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CHJ;
        };

Data.Bits.bit :: forall a. Data.Bits.Bits a => GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLSLLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CHZ]
        case v_s1CHZ of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CI9 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CI9;
        };

Data.Bits.setBit
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLSLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CIo]
        case v_s1CIo of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CIz [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CIz;
        };

Data.Bits.clearBit
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLSLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CIN]
        case v_s1CIN of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CIZ [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CIZ;
        };

Data.Bits.complementBit
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLSLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CJc]
        case v_s1CJc of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CJp [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CJp;
        };

Data.Bits.testBit
  :: forall a.
     Data.Bits.Bits a =>
     a -> GHC.Types.Int -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLSLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CJB]
        case v_s1CJB of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CJP [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CJP;
        };

Data.Bits.bitSizeMaybe
  :: forall a. Data.Bits.Bits a => a -> GHC.Base.Maybe GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLSLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CK0]
        case v_s1CK0 of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CKf [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CKf;
        };

Data.Bits.bitSize
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLSLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CKp]
        case v_s1CKp of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CKF [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CKF;
        };

Data.Bits.isSigned
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLSLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CKO]
        case v_s1CKO of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CL5 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CL5;
        };

Data.Bits.shiftL
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLSLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A)>] =
    [] \r [v_s1CLd]
        case v_s1CLd of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CLv [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CLv;
        };

Data.Bits.unsafeShiftL
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLSLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A)>] =
    [] \r [v_s1CLC]
        case v_s1CLC of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CLV [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CLV;
        };

Data.Bits.shiftR
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLSLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A)>] =
    [] \r [v_s1CM1]
        case v_s1CM1 of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CMl [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CMl;
        };

Data.Bits.unsafeShiftR
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLSLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A)>] =
    [] \r [v_s1CMq]
        case v_s1CMq of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CML [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CML;
        };

Data.Bits.rotateL
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLSLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A)>] =
    [] \r [v_s1CMP]
        case v_s1CMP of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CNb [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CNb;
        };

Data.Bits.rotateR
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A)>] =
    [] \r [v_s1CNe]
        case v_s1CNe of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CNB [Occ=Once]
                           _ [Occ=Dead] ->
              v_s1CNB;
        };

Data.Bits.popCount
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLLLS),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U)>] =
    [] \r [v_s1CND]
        case v_s1CND of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CO1 [Occ=Once] ->
              v_s1CO1;
        };

Data.Bits.$fBitsBool2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Bits.$fBitsBool1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Bits.$fBitsBool_$cpopCount :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_s1CO2]
        case ds_s1CO2 of {
          GHC.Types.False -> Data.Bits.$fBitsBool2;
          GHC.Types.True -> Data.Bits.$fBitsBool1;
        };

Data.Bits.$fBitsBool_$cisSigned :: GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1CO4] GHC.Types.False [];

Data.Bits.$fBitsBool_$cbitSize :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s1CO5] Data.Bits.$fBitsBool1;

Data.Bits.$fBitsBool3 :: GHC.Base.Maybe GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [Data.Bits.$fBitsBool1];

Data.Bits.$fBitsBool_$cbitSizeMaybe
  :: GHC.Types.Bool -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m2, Unf=OtherCon []] =
    [] \r [ds_s1CO6] Data.Bits.$fBitsBool3;

Data.Bits.$fBitsBool_$ctestBit
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [x_s1CO7 ds_s1CO8]
        case ds_s1CO8 of {
          GHC.Types.I# ds1_s1COa [Occ=Once!] ->
              case ds1_s1COa of {
                __DEFAULT -> GHC.Types.False [];
                0# -> x_s1CO7;
              };
        };

Data.Bits.$fBitsBool_$cbit :: GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1COc]
        case ds_s1COc of {
          GHC.Types.I# ds1_s1COe [Occ=Once!] ->
              case ds1_s1COe of {
                __DEFAULT -> GHC.Types.False [];
                0# -> GHC.Types.True [];
              };
        };

Data.Bits.$fBitsBool_$crotate
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s1COg ds_s1COh] x_s1COg;

Data.Bits.$fBitsInteger_$cisSigned
  :: GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1COi] GHC.Types.True [];

Data.Bits.$fBitsInteger2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bits.bitSize(Integer)"#;

Data.Bits.$fBitsInteger1 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Bits.$fBitsInteger2;

Data.Bits.$fBitsInteger_$cbitSize
  :: GHC.Integer.Type.Integer -> GHC.Types.Int
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [ds_s1COj]
        GHC.Err.errorWithoutStackTrace Data.Bits.$fBitsInteger1;

Data.Bits.$fBitsInteger_$cbitSizeMaybe
  :: GHC.Integer.Type.Integer -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1COk] GHC.Base.Nothing [];

Data.Bits.$fBitsInteger_$ctestBit
  :: GHC.Integer.Type.Integer -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1COl ds_s1COm]
        case ds_s1COm of {
          GHC.Types.I# i_s1COo [Occ=Once] ->
              GHC.Integer.Type.testBitInteger x_s1COl i_s1COo;
        };

Data.Bits.$fBitsInteger_$czeroBits :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Bits.$w$cshift [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Prim.Int# -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [w_s1COp ww_s1COq]
        case >=# [ww_s1COq 0#] of {
          __DEFAULT ->
              case negateInt# [ww_s1COq] of sat_s1COs {
                __DEFAULT -> GHC.Integer.Type.shiftRInteger w_s1COp sat_s1COs;
              };
          1# -> GHC.Integer.Type.shiftLInteger w_s1COp ww_s1COq;
        };

Data.Bits.$fBitsInteger_$cshift [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [w_s1COt w1_s1COu]
        case w1_s1COu of {
          GHC.Types.I# ww1_s1COw [Occ=Once] ->
              Data.Bits.$w$cshift w_s1COt ww1_s1COw;
        };

sat_s1COx :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s1COy :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1COx GHC.Types.[]];

Data.Bits.$fBitsInteger3 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s1COy;

Data.Bits.$fBitsInteger_$cbit
  :: GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [i_s1COz]
        case i_s1COz of {
          GHC.Types.I# ww1_s1COB ->
              case >=# [ww1_s1COB 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1COB] of sat_s1COD {
                      __DEFAULT ->
                          GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1COD;
                    };
                1# ->
                    GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1COB;
              };
        };

Data.Bits.$fBitsInteger_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1COE eta1_s1COF]
        case eta1_s1COF of {
          GHC.Types.I# ww1_s1COH ->
              case >=# [ww1_s1COH 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1COH] of sat_s1COJ {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1COJ
                          of
                          sat_s1COK
                          { __DEFAULT ->
                                case GHC.Integer.Type.complementInteger sat_s1COK of sat_s1COL {
                                  __DEFAULT -> GHC.Integer.Type.andInteger eta_s1COE sat_s1COL;
                                };
                          };
                    };
                1# ->
                    case
                        GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1COH
                    of
                    sat_s1COM
                    { __DEFAULT ->
                          case GHC.Integer.Type.complementInteger sat_s1COM of sat_s1CON {
                            __DEFAULT -> GHC.Integer.Type.andInteger eta_s1COE sat_s1CON;
                          };
                    };
              };
        };

Data.Bits.$fBitsInteger_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1COO eta1_s1COP]
        case eta1_s1COP of {
          GHC.Types.I# ww1_s1COR ->
              case >=# [ww1_s1COR 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1COR] of sat_s1COT {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1COT
                          of
                          sat_s1COU
                          { __DEFAULT -> GHC.Integer.Type.xorInteger eta_s1COO sat_s1COU;
                          };
                    };
                1# ->
                    case
                        GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1COR
                    of
                    sat_s1COV
                    { __DEFAULT -> GHC.Integer.Type.xorInteger eta_s1COO sat_s1COV;
                    };
              };
        };

Data.Bits.$fBitsInteger_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1COW eta1_s1COX]
        case eta1_s1COX of {
          GHC.Types.I# ww1_s1COZ ->
              case >=# [ww1_s1COZ 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1COZ] of sat_s1CP1 {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1CP1
                          of
                          sat_s1CP2
                          { __DEFAULT -> GHC.Integer.Type.orInteger eta_s1COW sat_s1CP2;
                          };
                    };
                1# ->
                    case
                        GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1COZ
                    of
                    sat_s1CP3
                    { __DEFAULT -> GHC.Integer.Type.orInteger eta_s1COW sat_s1CP3;
                    };
              };
        };

Data.Bits.$fBitsInteger_$cunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshift eta_B2 eta_B1;

Data.Bits.$fBitsInteger_$cshiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshift eta_B2 eta_B1;

Data.Bits.$fBitsInteger_$cshiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1CP4 eta1_s1CP5]
        case eta1_s1CP5 of {
          GHC.Types.I# x_s1CP7 [Occ=Once] ->
              case negateInt# [x_s1CP7] of i#_s1CP8 [Dmd=<S,U>] {
                __DEFAULT ->
                    case >=# [i#_s1CP8 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1CP8] of sat_s1CPa {
                            __DEFAULT -> GHC.Integer.Type.shiftRInteger eta_s1CP4 sat_s1CPa;
                          };
                      1# -> GHC.Integer.Type.shiftLInteger eta_s1CP4 i#_s1CP8;
                    };
              };
        };

Data.Bits.$fBitsInteger_$cunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshiftR eta_B2 eta_B1;

Data.Bits.$fBitsInteger_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1CPb eta1_s1CPc]
        case eta1_s1CPc of {
          GHC.Types.I# x_s1CPe [Occ=Once] ->
              case negateInt# [x_s1CPe] of i#_s1CPf [Dmd=<S,U>] {
                __DEFAULT ->
                    case >=# [i#_s1CPf 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1CPf] of sat_s1CPh {
                            __DEFAULT -> GHC.Integer.Type.shiftRInteger eta_s1CPb sat_s1CPh;
                          };
                      1# -> GHC.Integer.Type.shiftLInteger eta_s1CPb i#_s1CPf;
                    };
              };
        };

Data.Bits.$fBitsInteger_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshift eta_B2 eta_B1;

Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros
  :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [x_s1CPi]
        case x_s1CPi of {
          GHC.Types.False -> Data.Bits.$fBitsBool1;
          GHC.Types.True -> Data.Bits.$fBitsBool2;
        };

Data.Bits.$fBitsInt_$cpopCount :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CPk]
        case ds_s1CPk of {
          GHC.Types.I# x#_s1CPm [Occ=Once] ->
              case int2Word# [x#_s1CPm] of sat_s1CPn {
                __DEFAULT ->
                    case popCnt# [sat_s1CPn] of sat_s1CPo {
                      __DEFAULT ->
                          case word2Int# [sat_s1CPo] of sat_s1CPp {
                            __DEFAULT -> GHC.Types.I# [sat_s1CPp];
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cunsafeShiftR
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CPq ds1_s1CPr]
        case ds_s1CPq of {
          GHC.Types.I# x#_s1CPt [Occ=Once] ->
              case ds1_s1CPr of {
                GHC.Types.I# i#_s1CPv [Occ=Once] ->
                    case uncheckedIShiftRA# [x#_s1CPt i#_s1CPv] of sat_s1CPw {
                      __DEFAULT -> GHC.Types.I# [sat_s1CPw];
                    };
              };
        };

lvl_r1CDD :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [-1#];

Data.Bits.$fBitsInt_$cshiftR [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1CPx w1_s1CPy]
        case w_s1CPx of {
          GHC.Types.I# ww1_s1CPA [Occ=Once*] ->
              case w1_s1CPy of {
                GHC.Types.I# ww3_s1CPC ->
                    case >=# [ww3_s1CPC 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftRA# [ww1_s1CPA ww3_s1CPC] of sat_s1CPE {
                            __DEFAULT -> GHC.Types.I# [sat_s1CPE];
                          };
                      1# ->
                          case <# [ww1_s1CPA 0#] of {
                            __DEFAULT -> Data.Bits.$fBitsBool2;
                            1# -> lvl_r1CDD;
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cunsafeShiftL
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CPG ds1_s1CPH]
        case ds_s1CPG of {
          GHC.Types.I# x#_s1CPJ [Occ=Once] ->
              case ds1_s1CPH of {
                GHC.Types.I# i#_s1CPL [Occ=Once] ->
                    case uncheckedIShiftL# [x#_s1CPJ i#_s1CPL] of sat_s1CPM {
                      __DEFAULT -> GHC.Types.I# [sat_s1CPM];
                    };
              };
        };

Data.Bits.$fBitsInt_$cshiftL
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CPN ds1_s1CPO]
        case ds_s1CPN of {
          GHC.Types.I# x#_s1CPQ [Occ=Once] ->
              case ds1_s1CPO of {
                GHC.Types.I# i#_s1CPS ->
                    case >=# [i#_s1CPS 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [x#_s1CPQ i#_s1CPS] of sat_s1CPU {
                            __DEFAULT -> GHC.Types.I# [sat_s1CPU];
                          };
                      1# -> Data.Bits.$fBitsBool2;
                    };
              };
        };

Data.Bits.$fBitsInt_$cisSigned :: GHC.Types.Int -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1CPV] GHC.Types.True [];

Data.Bits.$fBitsInt_$crotate [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CPW ds1_s1CPX]
        case ds_s1CPW of {
          GHC.Types.I# x#_s1CPZ ->
              case ds1_s1CPX of {
                GHC.Types.I# i#_s1CQ1 [Occ=Once] ->
                    case andI# [i#_s1CQ1 63#] of i'#_s1CQ2 [Dmd=<S,U>] {
                      __DEFAULT ->
                          case -# [64# i'#_s1CQ2] of sat_s1CQ4 {
                            __DEFAULT ->
                                case uncheckedIShiftRL# [x#_s1CPZ sat_s1CQ4] of sat_s1CQ5 {
                                  __DEFAULT ->
                                      case uncheckedIShiftL# [x#_s1CPZ i'#_s1CQ2] of sat_s1CQ3 {
                                        __DEFAULT ->
                                            case orI# [sat_s1CQ3 sat_s1CQ5] of sat_s1CQ6 {
                                              __DEFAULT -> GHC.Types.I# [sat_s1CQ6];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cshift [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQ7 ds1_s1CQ8]
        case ds_s1CQ7 of {
          GHC.Types.I# x#_s1CQa [Occ=Once*] ->
              case ds1_s1CQ8 of {
                GHC.Types.I# i#_s1CQc ->
                    case >=# [i#_s1CQc 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1CQc] of b_s1CQe [Dmd=<S,U>] {
                            __DEFAULT ->
                                case >=# [b_s1CQe 64#] of {
                                  __DEFAULT ->
                                      case uncheckedIShiftRA# [x#_s1CQa b_s1CQe] of sat_s1CQg {
                                        __DEFAULT -> GHC.Types.I# [sat_s1CQg];
                                      };
                                  1# ->
                                      case <# [x#_s1CQa 0#] of {
                                        __DEFAULT -> Data.Bits.$fBitsBool2;
                                        1# -> lvl_r1CDD;
                                      };
                                };
                          };
                      1# ->
                          case >=# [i#_s1CQc 64#] of {
                            __DEFAULT ->
                                case uncheckedIShiftL# [x#_s1CQa i#_s1CQc] of sat_s1CQj {
                                  __DEFAULT -> GHC.Types.I# [sat_s1CQj];
                                };
                            1# -> Data.Bits.$fBitsBool2;
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$ccomplement :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQk]
        case ds_s1CQk of {
          GHC.Types.I# x#_s1CQm [Occ=Once] ->
              case notI# [x#_s1CQm] of sat_s1CQn {
                __DEFAULT -> GHC.Types.I# [sat_s1CQn];
              };
        };

Data.Bits.$fBitsInt_$cxor
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQo ds1_s1CQp]
        case ds_s1CQo of {
          GHC.Types.I# x#_s1CQr [Occ=Once] ->
              case ds1_s1CQp of {
                GHC.Types.I# y#_s1CQt [Occ=Once] ->
                    case xorI# [x#_s1CQr y#_s1CQt] of sat_s1CQu {
                      __DEFAULT -> GHC.Types.I# [sat_s1CQu];
                    };
              };
        };

Data.Bits.$fBitsInt_$c.|.
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQv ds1_s1CQw]
        case ds_s1CQv of {
          GHC.Types.I# x#_s1CQy [Occ=Once] ->
              case ds1_s1CQw of {
                GHC.Types.I# y#_s1CQA [Occ=Once] ->
                    case orI# [x#_s1CQy y#_s1CQA] of sat_s1CQB {
                      __DEFAULT -> GHC.Types.I# [sat_s1CQB];
                    };
              };
        };

Data.Bits.$fBitsInt_$c.&.
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQC ds1_s1CQD]
        case ds_s1CQC of {
          GHC.Types.I# x#_s1CQF [Occ=Once] ->
              case ds1_s1CQD of {
                GHC.Types.I# y#_s1CQH [Occ=Once] ->
                    case andI# [x#_s1CQF y#_s1CQH] of sat_s1CQI {
                      __DEFAULT -> GHC.Types.I# [sat_s1CQI];
                    };
              };
        };

Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros
  :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQJ]
        case ds_s1CQJ of {
          GHC.Types.I# x#_s1CQL [Occ=Once] ->
              case int2Word# [x#_s1CQL] of sat_s1CQM {
                __DEFAULT ->
                    case ctz# [sat_s1CQM] of sat_s1CQN {
                      __DEFAULT ->
                          case word2Int# [sat_s1CQN] of sat_s1CQO {
                            __DEFAULT -> GHC.Types.I# [sat_s1CQO];
                          };
                    };
              };
        };

Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros
  :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQP]
        case ds_s1CQP of {
          GHC.Types.I# x#_s1CQR [Occ=Once] ->
              case int2Word# [x#_s1CQR] of sat_s1CQS {
                __DEFAULT ->
                    case clz# [sat_s1CQS] of sat_s1CQT {
                      __DEFAULT ->
                          case word2Int# [sat_s1CQT] of sat_s1CQU {
                            __DEFAULT -> GHC.Types.I# [sat_s1CQU];
                          };
                    };
              };
        };

Data.Bits.$fBitsInt1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [64#];

Data.Bits.$fBitsInt_$cfiniteBitSize
  :: GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s1CQV] Data.Bits.$fBitsInt1;

Data.Bits.$fBitsWord_$cpopCount :: GHC.Types.Word -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQW]
        case ds_s1CQW of {
          GHC.Types.W# x#_s1CQY [Occ=Once] ->
              case popCnt# [x#_s1CQY] of sat_s1CQZ {
                __DEFAULT ->
                    case word2Int# [sat_s1CQZ] of sat_s1CR0 {
                      __DEFAULT -> GHC.Types.I# [sat_s1CR0];
                    };
              };
        };

Data.Bits.$fBitsWord_$cunsafeShiftR
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CR1 ds1_s1CR2]
        case ds_s1CR1 of {
          GHC.Types.W# x#_s1CR4 [Occ=Once] ->
              case ds1_s1CR2 of {
                GHC.Types.I# i#_s1CR6 [Occ=Once] ->
                    case uncheckedShiftRL# [x#_s1CR4 i#_s1CR6] of sat_s1CR7 {
                      __DEFAULT -> GHC.Types.W# [sat_s1CR7];
                    };
              };
        };

Data.Bits.$fBitsWord1 :: GHC.Types.Word
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.W#! [0##];

Data.Bits.$fBitsWord_$cshiftR
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CR8 ds1_s1CR9]
        case ds_s1CR8 of {
          GHC.Types.W# x#_s1CRb [Occ=Once] ->
              case ds1_s1CR9 of {
                GHC.Types.I# i#_s1CRd ->
                    case >=# [i#_s1CRd 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftRL# [x#_s1CRb i#_s1CRd] of sat_s1CRf {
                            __DEFAULT -> GHC.Types.W# [sat_s1CRf];
                          };
                      1# -> Data.Bits.$fBitsWord1;
                    };
              };
        };

Data.Bits.$fBitsWord_$cunsafeShiftL
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CRg ds1_s1CRh]
        case ds_s1CRg of {
          GHC.Types.W# x#_s1CRj [Occ=Once] ->
              case ds1_s1CRh of {
                GHC.Types.I# i#_s1CRl [Occ=Once] ->
                    case uncheckedShiftL# [x#_s1CRj i#_s1CRl] of sat_s1CRm {
                      __DEFAULT -> GHC.Types.W# [sat_s1CRm];
                    };
              };
        };

Data.Bits.$fBitsWord_$cshiftL
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CRn ds1_s1CRo]
        case ds_s1CRn of {
          GHC.Types.W# x#_s1CRq [Occ=Once] ->
              case ds1_s1CRo of {
                GHC.Types.I# i#_s1CRs ->
                    case >=# [i#_s1CRs 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [x#_s1CRq i#_s1CRs] of sat_s1CRu {
                            __DEFAULT -> GHC.Types.W# [sat_s1CRu];
                          };
                      1# -> Data.Bits.$fBitsWord1;
                    };
              };
        };

Data.Bits.$fBitsWord_$cisSigned :: GHC.Types.Word -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1CRv] GHC.Types.False [];

Data.Bits.$fBitsWord_$crotate
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CRw ds1_s1CRx]
        case ds_s1CRw of wild_s1CRy {
          GHC.Types.W# x#_s1CRz ->
              case ds1_s1CRx of {
                GHC.Types.I# i#_s1CRB [Occ=Once] ->
                    case andI# [i#_s1CRB 63#] of wild2_s1CRC {
                      __DEFAULT ->
                          case -# [64# wild2_s1CRC] of sat_s1CRE {
                            __DEFAULT ->
                                case uncheckedShiftRL# [x#_s1CRz sat_s1CRE] of sat_s1CRF {
                                  __DEFAULT ->
                                      case uncheckedShiftL# [x#_s1CRz wild2_s1CRC] of sat_s1CRD {
                                        __DEFAULT ->
                                            case or# [sat_s1CRD sat_s1CRF] of sat_s1CRG {
                                              __DEFAULT -> GHC.Types.W# [sat_s1CRG];
                                            };
                                      };
                                };
                          };
                      0# -> wild_s1CRy;
                    };
              };
        };

Data.Bits.$fBitsWord_$cshift [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CRH ds1_s1CRI]
        case ds_s1CRH of {
          GHC.Types.W# x#_s1CRK [Occ=Once*] ->
              case ds1_s1CRI of {
                GHC.Types.I# i#_s1CRM ->
                    case >=# [i#_s1CRM 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1CRM] of b_s1CRO [Dmd=<S,U>] {
                            __DEFAULT ->
                                case >=# [b_s1CRO 64#] of {
                                  __DEFAULT ->
                                      case uncheckedShiftRL# [x#_s1CRK b_s1CRO] of sat_s1CRQ {
                                        __DEFAULT -> GHC.Types.W# [sat_s1CRQ];
                                      };
                                  1# -> Data.Bits.$fBitsWord1;
                                };
                          };
                      1# ->
                          case >=# [i#_s1CRM 64#] of {
                            __DEFAULT ->
                                case uncheckedShiftL# [x#_s1CRK i#_s1CRM] of sat_s1CRS {
                                  __DEFAULT -> GHC.Types.W# [sat_s1CRS];
                                };
                            1# -> Data.Bits.$fBitsWord1;
                          };
                    };
              };
        };

Data.Bits.$fBitsWord_$ccomplement
  :: GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CRT]
        case ds_s1CRT of {
          GHC.Types.W# x#_s1CRV [Occ=Once] ->
              case xor# [x#_s1CRV 18446744073709551615##] of sat_s1CRW {
                __DEFAULT -> GHC.Types.W# [sat_s1CRW];
              };
        };

Data.Bits.$fBitsWord_$cxor
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CRX ds1_s1CRY]
        case ds_s1CRX of {
          GHC.Types.W# x#_s1CS0 [Occ=Once] ->
              case ds1_s1CRY of {
                GHC.Types.W# y#_s1CS2 [Occ=Once] ->
                    case xor# [x#_s1CS0 y#_s1CS2] of sat_s1CS3 {
                      __DEFAULT -> GHC.Types.W# [sat_s1CS3];
                    };
              };
        };

Data.Bits.$fBitsWord_$c.|.
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CS4 ds1_s1CS5]
        case ds_s1CS4 of {
          GHC.Types.W# x#_s1CS7 [Occ=Once] ->
              case ds1_s1CS5 of {
                GHC.Types.W# y#_s1CS9 [Occ=Once] ->
                    case or# [x#_s1CS7 y#_s1CS9] of sat_s1CSa {
                      __DEFAULT -> GHC.Types.W# [sat_s1CSa];
                    };
              };
        };

Data.Bits.$fBitsWord_$c.&.
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CSb ds1_s1CSc]
        case ds_s1CSb of {
          GHC.Types.W# x#_s1CSe [Occ=Once] ->
              case ds1_s1CSc of {
                GHC.Types.W# y#_s1CSg [Occ=Once] ->
                    case and# [x#_s1CSe y#_s1CSg] of sat_s1CSh {
                      __DEFAULT -> GHC.Types.W# [sat_s1CSh];
                    };
              };
        };

Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros
  :: GHC.Types.Word -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CSi]
        case ds_s1CSi of {
          GHC.Types.W# x#_s1CSk [Occ=Once] ->
              case ctz# [x#_s1CSk] of sat_s1CSl {
                __DEFAULT ->
                    case word2Int# [sat_s1CSl] of sat_s1CSm {
                      __DEFAULT -> GHC.Types.I# [sat_s1CSm];
                    };
              };
        };

Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros
  :: GHC.Types.Word -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CSn]
        case ds_s1CSn of {
          GHC.Types.W# x#_s1CSp [Occ=Once] ->
              case clz# [x#_s1CSp] of sat_s1CSq {
                __DEFAULT ->
                    case word2Int# [sat_s1CSq] of sat_s1CSr {
                      __DEFAULT -> GHC.Types.I# [sat_s1CSr];
                    };
              };
        };

Data.Bits.$fBitsWord_$cfiniteBitSize
  :: GHC.Types.Word -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s1CSs] Data.Bits.$fBitsInt1;

Data.Bits.$dmcountTrailingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S(S))LL),U(1*U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A),1*C1(U(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFiniteBits_s1CSt eta_s1CSu]
        case Data.Bits.finiteBitSize $dFiniteBits_s1CSt eta_s1CSu of {
          GHC.Types.I# ww1_s1CSw [Occ=OnceL] ->
              let {
                $dBits_s1CSx [Occ=OnceL,
                              Dmd=<L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A)>]
                  :: Data.Bits.Bits b_a1A4A
                [LclId] =
                    [$dFiniteBits_s1CSt] \u []
                        Data.Bits.$p1FiniteBits $dFiniteBits_s1CSt;
              } in 
                let-no-escape {
                  $wgo_s1CSy [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[1]]
                    :: GHC.Prim.Int# -> GHC.Types.Int
                  [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                      sat-only [eta_s1CSu
                                ww1_s1CSw
                                $dBits_s1CSx
                                $wgo_s1CSy] \r [ww2_s1CSz]
                          let {
                            wild_s1CSA [Dmd=<L,U(U)>] :: GHC.Types.Int
                            [LclId, Unf=OtherCon []] =
                                CCCS GHC.Types.I#! [ww2_s1CSz];
                          } in 
                            case >=# [ww2_s1CSz ww1_s1CSw] of {
                              __DEFAULT ->
                                  case Data.Bits.testBit $dBits_s1CSx eta_s1CSu wild_s1CSA of {
                                    GHC.Types.False ->
                                        case +# [ww2_s1CSz 1#] of sat_s1CSD {
                                          __DEFAULT -> $wgo_s1CSy sat_s1CSD;
                                        };
                                    GHC.Types.True -> wild_s1CSA;
                                  };
                              1# -> wild_s1CSA;
                            };
                } in  $wgo_s1CSy 0#;
        };

Data.Bits.$dmcountLeadingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S(S))LL),U(1*U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A),1*C1(U(U)),A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFiniteBits_s1CSE eta_s1CSF]
        case Data.Bits.finiteBitSize $dFiniteBits_s1CSE eta_s1CSF of {
          GHC.Types.I# x_s1CSH ->
              let {
                $dBits_s1CSI [Occ=OnceL,
                              Dmd=<L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A)>]
                  :: Data.Bits.Bits b_a1A4A
                [LclId] =
                    [$dFiniteBits_s1CSE] \u []
                        Data.Bits.$p1FiniteBits $dFiniteBits_s1CSE;
              } in 
                case -# [x_s1CSH 1#] of sat_s1CSX {
                  __DEFAULT ->
                      let-no-escape {
                        exit_s1CSJ [Occ=OnceL!T[1], Dmd=<L,C(U(U))>]
                          :: GHC.Prim.Int# -> GHC.Types.Int
                        [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []] =
                            sat-only [x_s1CSH] \r [ww_s1CSK]
                                case -# [x_s1CSH 1#] of sat_s1CSL {
                                  __DEFAULT ->
                                      case -# [sat_s1CSL ww_s1CSK] of sat_s1CSM {
                                        __DEFAULT -> GHC.Types.I# [sat_s1CSM];
                                      };
                                };
                      } in 
                        let-no-escape {
                          exit1_s1CSN [Occ=OnceL!T[1], Dmd=<L,C(U(U))>]
                            :: GHC.Prim.Int# -> GHC.Types.Int
                          [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []] =
                              sat-only [x_s1CSH] \r [ww_s1CSO]
                                  case -# [x_s1CSH 1#] of sat_s1CSP {
                                    __DEFAULT ->
                                        case -# [sat_s1CSP ww_s1CSO] of sat_s1CSQ {
                                          __DEFAULT -> GHC.Types.I# [sat_s1CSQ];
                                        };
                                  };
                        } in 
                          let-no-escape {
                            $wgo_s1CSR [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[1]]
                              :: GHC.Prim.Int# -> GHC.Types.Int
                            [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []] =
                                sat-only [eta_s1CSF
                                          $dBits_s1CSI
                                          exit_s1CSJ
                                          exit1_s1CSN
                                          $wgo_s1CSR] \r [ww_s1CSS]
                                    case <# [ww_s1CSS 0#] of {
                                      __DEFAULT ->
                                          let {
                                            sat_s1CSU [Occ=Once] :: GHC.Types.Int
                                            [LclId] =
                                                CCCS GHC.Types.I#! [ww_s1CSS];
                                          } in 
                                            case
                                                Data.Bits.testBit $dBits_s1CSI eta_s1CSF sat_s1CSU
                                            of
                                            { GHC.Types.False ->
                                                  case -# [ww_s1CSS 1#] of sat_s1CSW {
                                                    __DEFAULT -> $wgo_s1CSR sat_s1CSW;
                                                  };
                                              GHC.Types.True -> exit_s1CSJ ww_s1CSS;
                                            };
                                      1# -> exit1_s1CSN ww_s1CSS;
                                    };
                          } in  $wgo_s1CSR sat_s1CSX;
                };
        };

Data.Bits.$dmrotateR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CSY x_s1CSZ i_s1CT0]
        let {
          sat_s1CT4 [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [i_s1CT0] \u []
                  case i_s1CT0 of {
                    GHC.Types.I# x1_s1CT2 [Occ=Once] ->
                        case negateInt# [x1_s1CT2] of sat_s1CT3 {
                          __DEFAULT -> GHC.Types.I# [sat_s1CT3];
                        };
                  };
        } in  Data.Bits.rotate $dBits_s1CSY x_s1CSZ sat_s1CT4;

Data.Bits.$dmrotateL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CT5 x_s1CT6 i_s1CT7]
        Data.Bits.rotate $dBits_s1CT5 x_s1CT6 i_s1CT7;

Data.Bits.$dmunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLC(C(S))LLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CT8 x_s1CT9 i_s1CTa]
        Data.Bits.shiftR $dBits_s1CT8 x_s1CT9 i_s1CTa;

Data.Bits.$dmshiftR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTb x_s1CTc i_s1CTd]
        let {
          sat_s1CTh [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [i_s1CTd] \u []
                  case i_s1CTd of {
                    GHC.Types.I# x1_s1CTf [Occ=Once] ->
                        case negateInt# [x1_s1CTf] of sat_s1CTg {
                          __DEFAULT -> GHC.Types.I# [sat_s1CTg];
                        };
                  };
        } in  Data.Bits.shift $dBits_s1CTb x_s1CTc sat_s1CTh;

Data.Bits.$dmunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLC(C(S))LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTi x_s1CTj i_s1CTk]
        Data.Bits.shiftL $dBits_s1CTi x_s1CTj i_s1CTk;

Data.Bits.$dmshiftL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTl x_s1CTm i_s1CTn]
        Data.Bits.shift $dBits_s1CTl x_s1CTm i_s1CTn;

Data.Bits.$dmcomplementBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLLLLLLLLLLLLLLLLL),U(A,A,A,1*C1(C1(U)),A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTo x_s1CTp i_s1CTq]
        let {
          sat_s1CTr [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1CTo i_s1CTq] \u [] Data.Bits.bit $dBits_s1CTo i_s1CTq;
        } in  Data.Bits.xor $dBits_s1CTo x_s1CTp sat_s1CTr;

Data.Bits.$dmclearBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLLLLLLLLLLLLLLLLL),U(A,1*C1(C1(U)),A,A,1*C1(U),A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTs x_s1CTt i_s1CTu]
        let {
          sat_s1CTw [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1CTs i_s1CTu] \u []
                  let {
                    sat_s1CTv [Occ=Once] :: a_a1A4J
                    [LclId] =
                        [$dBits_s1CTs i_s1CTu] \u [] Data.Bits.bit $dBits_s1CTs i_s1CTu;
                  } in  Data.Bits.complement $dBits_s1CTs sat_s1CTv;
        } in  Data.Bits..&. $dBits_s1CTs x_s1CTt sat_s1CTw;

Data.Bits.$dmsetBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLLLLLLLLL),U(A,A,1*C1(C1(U)),A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTx x_s1CTy i_s1CTz]
        let {
          sat_s1CTA [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1CTx i_s1CTz] \u [] Data.Bits.bit $dBits_s1CTx i_s1CTz;
        } in  Data.Bits..|. $dBits_s1CTx x_s1CTy sat_s1CTA;

Data.Bits.$dmzeroBits :: forall a. Data.Bits.Bits a => a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLC(C(S))LLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,1*C1(U),A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTB]
        let {
          sat_s1CTC [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1CTB] \u []
                  Data.Bits.bit $dBits_s1CTB Data.Bits.$fBitsBool2;
        } in 
          Data.Bits.clearBit $dBits_s1CTB sat_s1CTC Data.Bits.$fBitsBool2;

Data.Bits.$fBitsBool_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cshiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$ctestBit eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$cshiftR eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cshiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$ctestBit eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$cshiftL eta_B2 eta_B1;

Data.Bits.$fBitsBool_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1CTD eta1_s1CTE]
        case eta_s1CTD of {
          GHC.Types.False ->
              case eta1_s1CTE of {
                GHC.Types.I# ds_s1CTH [Occ=Once!] ->
                    case ds_s1CTH of {
                      __DEFAULT -> GHC.Types.False [];
                      0# -> GHC.Types.True [];
                    };
              };
          GHC.Types.True ->
              case eta1_s1CTE of {
                GHC.Types.I# ds_s1CTK [Occ=Once!] ->
                    case ds_s1CTK of {
                      __DEFAULT -> GHC.Types.True [];
                      0# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsBool_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1CTM eta1_s1CTN]
        case eta_s1CTM of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True ->
              case eta1_s1CTN of {
                GHC.Types.I# ds_s1CTQ [Occ=Once!] ->
                    case ds_s1CTQ of {
                      __DEFAULT -> GHC.Types.True [];
                      0# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsBool_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1CTS eta1_s1CTT]
        case eta_s1CTS of {
          GHC.Types.False -> Data.Bits.$fBitsBool_$cbit eta1_s1CTT;
          GHC.Types.True -> GHC.Types.True [];
        };

Data.Bits.$fBitsBool_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Types.Bool
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Classes.$fEqBool
                                     GHC.Classes.&&
                                     GHC.Classes.||
                                     GHC.Classes.$fEqBool_$c/=
                                     GHC.Classes.not
                                     Data.Bits.$fBitsBool_$ctestBit
                                     Data.Bits.$fBitsBool_$crotate
                                     GHC.Types.False
                                     Data.Bits.$fBitsBool_$cbit
                                     Data.Bits.$fBitsBool_$csetBit
                                     Data.Bits.$fBitsBool_$cclearBit
                                     Data.Bits.$fBitsBool_$ccomplementBit
                                     Data.Bits.$fBitsBool_$ctestBit
                                     Data.Bits.$fBitsBool_$cbitSizeMaybe
                                     Data.Bits.$fBitsBool_$cbitSize
                                     Data.Bits.$fBitsBool_$cisSigned
                                     Data.Bits.$fBitsBool_$cshiftL
                                     Data.Bits.$fBitsBool_$cunsafeShiftL
                                     Data.Bits.$fBitsBool_$cshiftR
                                     Data.Bits.$fBitsBool_$cunsafeShiftR
                                     Data.Bits.$fBitsBool_$crotateL
                                     Data.Bits.$fBitsBool_$crotateR
                                     Data.Bits.$fBitsBool_$cpopCount];

Data.Bits.$fFiniteBitsBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.FiniteBits GHC.Types.Bool
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bits.C:FiniteBits! [Data.Bits.$fBitsBool
                                           Data.Bits.$fBitsBool_$cbitSize
                                           Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros
                                           Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros];

Data.Bits.$dmrotate
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),1*C1(C1(U)),A)><L,U><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTV x_s1CTW i_s1CTX]
        case i_s1CTX of wild_s1CTY {
          GHC.Types.I# x1_s1CTZ ->
              case <# [x1_s1CTZ 0#] of {
                __DEFAULT ->
                    case ># [x1_s1CTZ 0#] of {
                      __DEFAULT -> x_s1CTW;
                      1# -> Data.Bits.rotateL $dBits_s1CTV x_s1CTW wild_s1CTY;
                    };
                1# ->
                    case negateInt# [x1_s1CTZ] of sat_s1CU2 {
                      __DEFAULT ->
                          let {
                            sat_s1CU3 [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [sat_s1CU2];
                          } in  Data.Bits.rotateR $dBits_s1CTV x_s1CTW sat_s1CU3;
                    };
              };
        };

Data.Bits.$dmshift
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,1*C1(C1(U)),A,A,A,A)><L,U><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CU4 x_s1CU5 i_s1CU6]
        case i_s1CU6 of wild_s1CU7 {
          GHC.Types.I# x1_s1CU8 ->
              case <# [x1_s1CU8 0#] of {
                __DEFAULT ->
                    case ># [x1_s1CU8 0#] of {
                      __DEFAULT -> x_s1CU5;
                      1# -> Data.Bits.shiftL $dBits_s1CU4 x_s1CU5 wild_s1CU7;
                    };
                1# ->
                    case negateInt# [x1_s1CU8] of sat_s1CUb {
                      __DEFAULT ->
                          let {
                            sat_s1CUc [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [sat_s1CUb];
                          } in  Data.Bits.shiftR $dBits_s1CU4 x_s1CU5 sat_s1CUc;
                    };
              };
        };

Data.Bits.bitDefault [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     GHC.Types.Int -> a
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLLLLLLLLLC(C(S))LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CUd $dNum_s1CUe i_s1CUf]
        let {
          sat_s1CUg [Occ=Once] :: a_a1AlX
          [LclId] =
              [$dNum_s1CUe] \u []
                  GHC.Num.fromInteger $dNum_s1CUe Data.Bits.$fBitsInteger3;
        } in  Data.Bits.shiftL $dBits_s1CUd sat_s1CUg i_s1CUf;

Data.Bits.testBitDefault [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     a -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<S(S(LC(C(S)))LLLLLLLLLLLLLLLLLLLLLL),U(1*U(A,1*C1(C1(U))),1*C1(C1(U)),A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CUh $dNum_s1CUi eta_s1CUj eta1_s1CUk]
        let {
          sat_s1CUo [Occ=Once] :: a_a1AlK
          [LclId] =
              [$dNum_s1CUi] \u []
                  GHC.Num.fromInteger
                      $dNum_s1CUi Data.Bits.$fBitsInteger_$czeroBits; } in
        let {
          sat_s1CUn [Occ=Once] :: a_a1AlK
          [LclId] =
              [$dBits_s1CUh eta_s1CUj eta1_s1CUk] \u []
                  let {
                    sat_s1CUm [Occ=Once] :: a_a1AlK
                    [LclId] =
                        [$dBits_s1CUh eta1_s1CUk] \u []
                            Data.Bits.bit $dBits_s1CUh eta1_s1CUk;
                  } in  Data.Bits..&. $dBits_s1CUh eta_s1CUj sat_s1CUm;
        } in 
          case Data.Bits.$p1Bits $dBits_s1CUh of sat_s1CUl {
            __DEFAULT -> GHC.Classes./= sat_s1CUl sat_s1CUn sat_s1CUo;
          };

Data.Bits.$fBitsInt2 :: GHC.Base.Maybe GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [Data.Bits.$fBitsInt1];

Data.Bits.$fBitsWord_$cbitSizeMaybe
  :: GHC.Types.Word -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m2, Unf=OtherCon []] =
    [] \r [i_s1CUp] Data.Bits.$fBitsInt2;

Data.Bits.$fBitsWord_$cbit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [i_s1CUq]
        case i_s1CUq of {
          GHC.Types.I# i#_s1CUs ->
              case >=# [i#_s1CUs 64#] of {
                __DEFAULT ->
                    case uncheckedShiftL# [1## i#_s1CUs] of sat_s1CUu {
                      __DEFAULT -> GHC.Types.W# [sat_s1CUu];
                    };
                1# -> Data.Bits.$fBitsWord1;
              };
        };

Data.Bits.$fBitsWord_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1CUv i_s1CUw]
        case x_s1CUv of {
          GHC.Types.W# x#_s1CUy [Occ=Once] ->
              case i_s1CUw of {
                GHC.Types.I# i#_s1CUA ->
                    case >=# [i#_s1CUA 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1CUA] of sat_s1CUC {
                            __DEFAULT ->
                                case and# [x#_s1CUy sat_s1CUC] of {
                                  __DEFAULT -> GHC.Types.True [];
                                  0## -> GHC.Types.False [];
                                };
                          };
                      1# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsWord_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CUE eta1_s1CUF]
        case eta_s1CUE of wild_s1CUG {
          GHC.Types.W# x#_s1CUH ->
              case eta1_s1CUF of {
                GHC.Types.I# x_s1CUJ [Occ=Once] ->
                    case negateInt# [x_s1CUJ] of sat_s1CUK {
                      __DEFAULT ->
                          case andI# [sat_s1CUK 63#] of wild2_s1CUL {
                            __DEFAULT ->
                                case -# [64# wild2_s1CUL] of sat_s1CUN {
                                  __DEFAULT ->
                                      case uncheckedShiftRL# [x#_s1CUH sat_s1CUN] of sat_s1CUO {
                                        __DEFAULT ->
                                            case
                                                uncheckedShiftL# [x#_s1CUH wild2_s1CUL]
                                            of
                                            sat_s1CUM
                                            { __DEFAULT ->
                                                  case or# [sat_s1CUM sat_s1CUO] of sat_s1CUP {
                                                    __DEFAULT -> GHC.Types.W# [sat_s1CUP];
                                                  };
                                            };
                                      };
                                };
                            0# -> wild_s1CUG;
                          };
                    };
              };
        };

Data.Bits.$fBitsWord_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CUQ eta1_s1CUR]
        case eta_s1CUQ of wild_s1CUS {
          GHC.Types.W# x#_s1CUT [Occ=Once] ->
              case eta1_s1CUR of {
                GHC.Types.I# i#_s1CUV ->
                    case >=# [i#_s1CUV 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1CUV] of sat_s1CUX {
                            __DEFAULT ->
                                case xor# [x#_s1CUT sat_s1CUX] of sat_s1CUY {
                                  __DEFAULT -> GHC.Types.W# [sat_s1CUY];
                                };
                          };
                      1# -> wild_s1CUS;
                    };
              };
        };

Data.Bits.$fBitsWord_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CUZ eta1_s1CV0]
        case eta_s1CUZ of {
          GHC.Types.W# x#_s1CV2 [Occ=Once*] ->
              case eta1_s1CV0 of {
                GHC.Types.I# i#_s1CV4 ->
                    case >=# [i#_s1CV4 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1CV4] of sat_s1CV6 {
                            __DEFAULT ->
                                case xor# [sat_s1CV6 18446744073709551615##] of sat_s1CV7 {
                                  __DEFAULT ->
                                      case and# [x#_s1CV2 sat_s1CV7] of sat_s1CV8 {
                                        __DEFAULT -> GHC.Types.W# [sat_s1CV8];
                                      };
                                };
                          };
                      1# ->
                          case and# [x#_s1CV2 18446744073709551615##] of sat_s1CV9 {
                            __DEFAULT -> GHC.Types.W# [sat_s1CV9];
                          };
                    };
              };
        };

Data.Bits.$fBitsWord_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CVa eta1_s1CVb]
        case eta_s1CVa of wild_s1CVc {
          GHC.Types.W# x#_s1CVd [Occ=Once] ->
              case eta1_s1CVb of {
                GHC.Types.I# i#_s1CVf ->
                    case >=# [i#_s1CVf 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1CVf] of sat_s1CVh {
                            __DEFAULT ->
                                case or# [x#_s1CVd sat_s1CVh] of sat_s1CVi {
                                  __DEFAULT -> GHC.Types.W# [sat_s1CVi];
                                };
                          };
                      1# -> wild_s1CVc;
                    };
              };
        };

Data.Bits.$fBitsWord_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsWord_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Types.Word
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Classes.$fEqWord
                                     Data.Bits.$fBitsWord_$c.&.
                                     Data.Bits.$fBitsWord_$c.|.
                                     Data.Bits.$fBitsWord_$cxor
                                     Data.Bits.$fBitsWord_$ccomplement
                                     Data.Bits.$fBitsWord_$cshift
                                     Data.Bits.$fBitsWord_$crotate
                                     Data.Bits.$fBitsWord1
                                     Data.Bits.$fBitsWord_$cbit
                                     Data.Bits.$fBitsWord_$csetBit
                                     Data.Bits.$fBitsWord_$cclearBit
                                     Data.Bits.$fBitsWord_$ccomplementBit
                                     Data.Bits.$fBitsWord_$ctestBit
                                     Data.Bits.$fBitsWord_$cbitSizeMaybe
                                     Data.Bits.$fBitsWord_$cfiniteBitSize
                                     Data.Bits.$fBitsWord_$cisSigned
                                     Data.Bits.$fBitsWord_$cshiftL
                                     Data.Bits.$fBitsWord_$cunsafeShiftL
                                     Data.Bits.$fBitsWord_$cshiftR
                                     Data.Bits.$fBitsWord_$cunsafeShiftR
                                     Data.Bits.$fBitsWord_$crotateL
                                     Data.Bits.$fBitsWord_$crotateR
                                     Data.Bits.$fBitsWord_$cpopCount];

Data.Bits.$fFiniteBitsWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.FiniteBits GHC.Types.Word
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bits.C:FiniteBits! [Data.Bits.$fBitsWord
                                           Data.Bits.$fBitsWord_$cfiniteBitSize
                                           Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros
                                           Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros];

Data.Bits.$fBitsInt_$cbitSizeMaybe
  :: GHC.Types.Int -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m2, Unf=OtherCon []] =
    [] \r [i_s1CVj] Data.Bits.$fBitsInt2;

Data.Bits.$fBitsInt_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsInt_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsInt_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CVk eta1_s1CVl]
        case eta_s1CVk of {
          GHC.Types.I# x#_s1CVn ->
              case eta1_s1CVl of {
                GHC.Types.I# x_s1CVp [Occ=Once] ->
                    case negateInt# [x_s1CVp] of sat_s1CVr {
                      __DEFAULT ->
                          case andI# [sat_s1CVr 63#] of i'#_s1CVq [Dmd=<S,U>] {
                            __DEFAULT ->
                                case -# [64# i'#_s1CVq] of sat_s1CVt {
                                  __DEFAULT ->
                                      case uncheckedIShiftRL# [x#_s1CVn sat_s1CVt] of sat_s1CVu {
                                        __DEFAULT ->
                                            case
                                                uncheckedIShiftL# [x#_s1CVn i'#_s1CVq]
                                            of
                                            sat_s1CVs
                                            { __DEFAULT ->
                                                  case orI# [sat_s1CVs sat_s1CVu] of sat_s1CVv {
                                                    __DEFAULT -> GHC.Types.I# [sat_s1CVv];
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cbit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [i_s1CVw]
        case i_s1CVw of {
          GHC.Types.I# i#_s1CVy ->
              case >=# [i#_s1CVy 64#] of {
                __DEFAULT ->
                    case uncheckedIShiftL# [1# i#_s1CVy] of sat_s1CVA {
                      __DEFAULT -> GHC.Types.I# [sat_s1CVA];
                    };
                1# -> Data.Bits.$fBitsBool2;
              };
        };

Data.Bits.$fBitsInt_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1CVB i_s1CVC]
        case x_s1CVB of {
          GHC.Types.I# x#_s1CVE [Occ=Once] ->
              case i_s1CVC of {
                GHC.Types.I# i#_s1CVG ->
                    case >=# [i#_s1CVG 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1CVG] of sat_s1CVI {
                            __DEFAULT ->
                                case andI# [x#_s1CVE sat_s1CVI] of {
                                  __DEFAULT -> GHC.Types.True [];
                                  0# -> GHC.Types.False [];
                                };
                          };
                      1# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsInt_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CVK eta1_s1CVL]
        case eta_s1CVK of wild_s1CVM {
          GHC.Types.I# x#_s1CVN [Occ=Once] ->
              case eta1_s1CVL of {
                GHC.Types.I# i#_s1CVP ->
                    case >=# [i#_s1CVP 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1CVP] of sat_s1CVR {
                            __DEFAULT ->
                                case orI# [x#_s1CVN sat_s1CVR] of sat_s1CVS {
                                  __DEFAULT -> GHC.Types.I# [sat_s1CVS];
                                };
                          };
                      1# -> wild_s1CVM;
                    };
              };
        };

Data.Bits.$fBitsInt_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CVT eta1_s1CVU]
        case eta_s1CVT of {
          GHC.Types.I# x#_s1CVW [Occ=Once*] ->
              case eta1_s1CVU of {
                GHC.Types.I# i#_s1CVY ->
                    case >=# [i#_s1CVY 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1CVY] of sat_s1CW0 {
                            __DEFAULT ->
                                case notI# [sat_s1CW0] of sat_s1CW1 {
                                  __DEFAULT ->
                                      case andI# [x#_s1CVW sat_s1CW1] of sat_s1CW2 {
                                        __DEFAULT -> GHC.Types.I# [sat_s1CW2];
                                      };
                                };
                          };
                      1# ->
                          case andI# [x#_s1CVW -1#] of sat_s1CW3 {
                            __DEFAULT -> GHC.Types.I# [sat_s1CW3];
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CW4 eta1_s1CW5]
        case eta_s1CW4 of wild_s1CW6 {
          GHC.Types.I# x#_s1CW7 [Occ=Once] ->
              case eta1_s1CW5 of {
                GHC.Types.I# i#_s1CW9 ->
                    case >=# [i#_s1CW9 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1CW9] of sat_s1CWb {
                            __DEFAULT ->
                                case xorI# [x#_s1CW7 sat_s1CWb] of sat_s1CWc {
                                  __DEFAULT -> GHC.Types.I# [sat_s1CWc];
                                };
                          };
                      1# -> wild_s1CW6;
                    };
              };
        };

Data.Bits.$fBitsInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Types.Int
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Classes.$fEqInt
                                     Data.Bits.$fBitsInt_$c.&.
                                     Data.Bits.$fBitsInt_$c.|.
                                     Data.Bits.$fBitsInt_$cxor
                                     Data.Bits.$fBitsInt_$ccomplement
                                     Data.Bits.$fBitsInt_$cshift
                                     Data.Bits.$fBitsInt_$crotate
                                     Data.Bits.$fBitsBool2
                                     Data.Bits.$fBitsInt_$cbit
                                     Data.Bits.$fBitsInt_$csetBit
                                     Data.Bits.$fBitsInt_$cclearBit
                                     Data.Bits.$fBitsInt_$ccomplementBit
                                     Data.Bits.$fBitsInt_$ctestBit
                                     Data.Bits.$fBitsInt_$cbitSizeMaybe
                                     Data.Bits.$fBitsInt_$cfiniteBitSize
                                     Data.Bits.$fBitsInt_$cisSigned
                                     Data.Bits.$fBitsInt_$cshiftL
                                     Data.Bits.$fBitsInt_$cunsafeShiftL
                                     Data.Bits.$fBitsInt_$cshiftR
                                     Data.Bits.$fBitsInt_$cunsafeShiftR
                                     Data.Bits.$fBitsInt_$crotateL
                                     Data.Bits.$fBitsInt_$crotateR
                                     Data.Bits.$fBitsInt_$cpopCount];

Data.Bits.$fFiniteBitsInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.FiniteBits GHC.Types.Int
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bits.C:FiniteBits! [Data.Bits.$fBitsInt
                                           Data.Bits.$fBitsInt_$cfiniteBitSize
                                           Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros
                                           Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros];

Data.Bits.$wpopCountDefault [InlPrag=INLINABLE[0]]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     a -> GHC.Prim.Int#
[GblId,
 Arity=3,
 Str=<S(S(C(C(S))L)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1CWd w1_s1CWe w2_s1CWf]
        let {
          lvl1_s1CWg [Occ=OnceL] :: a_s1C1X
          [LclId] =
              [w1_s1CWe] \u []
                  GHC.Num.fromInteger w1_s1CWe Data.Bits.$fBitsInteger3; } in
        let {
          lvl2_s1CWh [Occ=OnceL] :: a_s1C1X
          [LclId] =
              [w1_s1CWe] \u []
                  GHC.Num.fromInteger w1_s1CWe Data.Bits.$fBitsInteger_$czeroBits;
        } in 
          case
              Data.Bits.$p1Bits w_s1CWd
          of
          $dEq_s1CWi [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
          { __DEFAULT ->
                let-no-escape {
                  $wgo_s1CWj [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[2]]
                    :: GHC.Prim.Int# -> a_s1C1X -> GHC.Prim.Int#
                  [LclId[JoinId(2)], Arity=2, Str=<S,U><L,U>, Unf=OtherCon []] =
                      sat-only [w_s1CWd
                                w1_s1CWe
                                lvl1_s1CWg
                                lvl2_s1CWh
                                $dEq_s1CWi
                                $wgo_s1CWj] \r [ww_s1CWk w3_s1CWl]
                          case GHC.Classes.== $dEq_s1CWi w3_s1CWl lvl2_s1CWh of {
                            GHC.Types.False ->
                                let {
                                  sat_s1CWp [Occ=Once] :: a_s1C1X
                                  [LclId] =
                                      [w_s1CWd w1_s1CWe lvl1_s1CWg w3_s1CWl] \u []
                                          let {
                                            sat_s1CWo [Occ=Once] :: a_s1C1X
                                            [LclId] =
                                                [w1_s1CWe lvl1_s1CWg w3_s1CWl] \u []
                                                    GHC.Num.- w1_s1CWe w3_s1CWl lvl1_s1CWg;
                                          } in  Data.Bits..&. w_s1CWd w3_s1CWl sat_s1CWo;
                                } in 
                                  case +# [ww_s1CWk 1#] of sat_s1CWn {
                                    __DEFAULT -> $wgo_s1CWj sat_s1CWn sat_s1CWp;
                                  };
                            GHC.Types.True -> ww_s1CWk;
                          };
                } in  $wgo_s1CWj 0# w2_s1CWf;
          };

Data.Bits.popCountDefault [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<S(S(C(C(S))L)LLLLLLLLLLLLLLLLLLLLLL),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,C(U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1CWq w1_s1CWr w2_s1CWs]
        case
            Data.Bits.$wpopCountDefault w_s1CWq w1_s1CWr w2_s1CWs
        of
        ww_s1CWt
        { __DEFAULT -> GHC.Types.I# [ww_s1CWt];
        };

Data.Bits.$fBitsInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Integer.Type.Integer
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Integer.Type.$fEqInteger
                                     GHC.Integer.Type.andInteger
                                     GHC.Integer.Type.orInteger
                                     GHC.Integer.Type.xorInteger
                                     GHC.Integer.Type.complementInteger
                                     Data.Bits.$fBitsInteger_$cshift
                                     Data.Bits.$fBitsInteger_$cshift
                                     Data.Bits.$fBitsInteger_$czeroBits
                                     Data.Bits.$fBitsInteger_$cbit
                                     Data.Bits.$fBitsInteger_$csetBit
                                     Data.Bits.$fBitsInteger_$cclearBit
                                     Data.Bits.$fBitsInteger_$ccomplementBit
                                     Data.Bits.$fBitsInteger_$ctestBit
                                     Data.Bits.$fBitsInteger_$cbitSizeMaybe
                                     Data.Bits.$fBitsInteger_$cbitSize
                                     Data.Bits.$fBitsInteger_$cisSigned
                                     Data.Bits.$fBitsInteger_$cshiftL
                                     Data.Bits.$fBitsInteger_$cunsafeShiftL
                                     Data.Bits.$fBitsInteger_$cshiftR
                                     Data.Bits.$fBitsInteger_$cunsafeShiftR
                                     Data.Bits.$fBitsInteger_$crotateL
                                     Data.Bits.$fBitsInteger_$crotateR
                                     Data.Bits.$fBitsInteger_$cpopCount];
Data.Bits.$fBitsInteger_$cpopCount [Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer -> GHC.Types.Int
[GblId, Arity=1, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_s1CWu]
        case
            Data.Bits.$wpopCountDefault
                Data.Bits.$fBitsInteger GHC.Num.$fNumInteger w_s1CWu
        of
        ww_s1CWv
        { __DEFAULT -> GHC.Types.I# [ww_s1CWv];
        };

Data.Bits.toIntegralSized [InlPrag=INLINABLE]
  :: forall a b.
     (GHC.Real.Integral a, GHC.Real.Integral b, Data.Bits.Bits a,
      Data.Bits.Bits b) =>
     a -> GHC.Base.Maybe b
[GblId,
 Arity=5,
 Str=<L,U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U)),1*U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,1*C1(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(LLLLLLLLLLLLLC(S)LLLLLLLLL),U(A,A,A,A,A,A,A,A,C(U),A,A,A,A,1*C1(U),A,1*C1(U),A,A,A,A,A,A,A)><S(LLLLLLLLLLLLLC(S)LC(S)LLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,1*C1(U),A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1CWw
           $dIntegral1_s1CWx
           $dBits_s1CWy
           $dBits1_s1CWz
           eta_s1CWA]
        case
            Data.Bits.bitSizeMaybe $dBits_s1CWy eta_s1CWA
        of
        xWidth_s1CWB [Dmd=<S,U>]
        { __DEFAULT ->
              let {
                y_s1CWC :: b_a1AhY
                [LclId] =
                    [$dIntegral_s1CWw $dIntegral1_s1CWx eta_s1CWA] \u []
                        let {
                          sat_s1CWF [Occ=Once] :: GHC.Integer.Type.Integer
                          [LclId] =
                              [$dIntegral_s1CWw eta_s1CWA] \u []
                                  GHC.Real.toInteger $dIntegral_s1CWw eta_s1CWA;
                        } in 
                          case GHC.Real.$p1Integral $dIntegral1_s1CWx of sat_s1CWD {
                            __DEFAULT ->
                                case GHC.Real.$p1Real sat_s1CWD of sat_s1CWE {
                                  __DEFAULT -> GHC.Num.fromInteger sat_s1CWE sat_s1CWF;
                                };
                          };
              } in 
                case
                    Data.Bits.isSigned $dBits1_s1CWz y_s1CWC
                of
                ySigned_s1CWG [Dmd=<S,U>]
                { __DEFAULT ->
                      case
                          Data.Bits.bitSizeMaybe $dBits1_s1CWz y_s1CWC
                      of
                      yWidth_s1CWH [Dmd=<S,U>]
                      { __DEFAULT ->
                            let {
                              xSigned_s1CWI :: GHC.Types.Bool
                              [LclId] =
                                  [$dBits_s1CWy eta_s1CWA] \u []
                                      Data.Bits.isSigned $dBits_s1CWy eta_s1CWA; } in
                            let {
                              $dReal_s1CWJ [Dmd=<L,U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U)),1*U(A,A,A,C(C1(U)),A,A,A,A),A)>]
                                :: GHC.Real.Real a_a1AhX
                              [LclId] =
                                  [$dIntegral_s1CWw] \u []
                                      GHC.Real.$p1Integral $dIntegral_s1CWw; } in
                            let {
                              $dNum_s1CWK [Dmd=<L,U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U))>]
                                :: GHC.Num.Num a_a1AhX
                              [LclId] =
                                  [$dReal_s1CWJ] \u [] GHC.Real.$p1Real $dReal_s1CWJ; } in
                            let {
                              $dOrd_s1CWL [Dmd=<L,U(A,A,A,C(C1(U)),A,A,A,A)>]
                                :: GHC.Classes.Ord a_a1AhX
                              [LclId] =
                                  [$dReal_s1CWJ] \u [] GHC.Real.$p2Real $dReal_s1CWJ;
                            } in 
                              let-no-escape {
                                $j_s1CWM [Dmd=<L,1*U>] :: GHC.Base.Maybe b_a1AhY
                                [LclId[JoinId(0)], Unf=OtherCon []] =
                                    [$dBits_s1CWy
                                     eta_s1CWA
                                     xWidth_s1CWB
                                     y_s1CWC
                                     ySigned_s1CWG
                                     yWidth_s1CWH
                                     xSigned_s1CWI
                                     $dNum_s1CWK
                                     $dOrd_s1CWL] \r []
                                        let-no-escape {
                                          fail_s1CWN [Dmd=<L,1*C1(U)>]
                                            :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                              sat-only [$dBits_s1CWy
                                                        eta_s1CWA
                                                        xWidth_s1CWB
                                                        y_s1CWC
                                                        ySigned_s1CWG
                                                        yWidth_s1CWH
                                                        xSigned_s1CWI
                                                        $dNum_s1CWK
                                                        $dOrd_s1CWL] \r [ds_s1CWO]
                                                  let-no-escape {
                                                    fail1_s1CWP [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                                      :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                                    [LclId[JoinId(1)],
                                                     Arity=1,
                                                     Str=<L,A>,
                                                     Unf=OtherCon []] =
                                                        sat-only [$dBits_s1CWy
                                                                  eta_s1CWA
                                                                  xWidth_s1CWB
                                                                  y_s1CWC
                                                                  ySigned_s1CWG
                                                                  yWidth_s1CWH
                                                                  xSigned_s1CWI
                                                                  $dNum_s1CWK
                                                                  $dOrd_s1CWL] \r [ds1_s1CWQ]
                                                            let-no-escape {
                                                              fail2_s1CWR [Occ=Once*!T[1],
                                                                           Dmd=<L,1*C1(U)>]
                                                                :: GHC.Prim.Void#
                                                                   -> GHC.Base.Maybe b_a1AhY
                                                              [LclId[JoinId(1)],
                                                               Arity=1,
                                                               Str=<L,A>,
                                                               Unf=OtherCon []] =
                                                                  sat-only [$dBits_s1CWy
                                                                            eta_s1CWA
                                                                            xWidth_s1CWB
                                                                            y_s1CWC
                                                                            ySigned_s1CWG
                                                                            yWidth_s1CWH
                                                                            xSigned_s1CWI
                                                                            $dNum_s1CWK
                                                                            $dOrd_s1CWL] \r [ds2_s1CWS]
                                                                      let-no-escape {
                                                                        $j1_s1CWT [Dmd=<L,1*U>]
                                                                          :: GHC.Base.Maybe b_a1AhY
                                                                        [LclId[JoinId(0)],
                                                                         Unf=OtherCon []] =
                                                                            [$dBits_s1CWy
                                                                             eta_s1CWA
                                                                             xWidth_s1CWB
                                                                             y_s1CWC
                                                                             ySigned_s1CWG
                                                                             yWidth_s1CWH
                                                                             xSigned_s1CWI
                                                                             $dNum_s1CWK
                                                                             $dOrd_s1CWL] \r []
                                                                                let-no-escape {
                                                                                  fail3_s1CWU [Occ=Once*!T[1],
                                                                                               Dmd=<L,1*C1(U)>]
                                                                                    :: GHC.Prim.Void#
                                                                                       -> GHC.Base.Maybe
                                                                                            b_a1AhY
                                                                                  [LclId[JoinId(1)],
                                                                                   Arity=1,
                                                                                   Str=<L,A>,
                                                                                   Unf=OtherCon []] =
                                                                                      sat-only [$dBits_s1CWy
                                                                                                eta_s1CWA
                                                                                                y_s1CWC
                                                                                                ySigned_s1CWG
                                                                                                yWidth_s1CWH
                                                                                                $dNum_s1CWK
                                                                                                $dOrd_s1CWL] \r [ds3_s1CWV]
                                                                                          case
                                                                                              yWidth_s1CWH
                                                                                          of
                                                                                          { GHC.Base.Nothing ->
                                                                                                GHC.Base.Just [y_s1CWC];
                                                                                            GHC.Base.Just yW_s1CWX [Occ=Once*] ->
                                                                                                case
                                                                                                    ySigned_s1CWG
                                                                                                of
                                                                                                { GHC.Types.False ->
                                                                                                      let {
                                                                                                        sat_s1CX1 [Occ=Once]
                                                                                                          :: a_a1AhX
                                                                                                        [LclId] =
                                                                                                            [$dBits_s1CWy
                                                                                                             $dNum_s1CWK
                                                                                                             yW_s1CWX] \u []
                                                                                                                let {
                                                                                                                  sat_s1CX0 [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dNum_s1CWK] \u []
                                                                                                                          GHC.Num.fromInteger
                                                                                                                              $dNum_s1CWK
                                                                                                                              Data.Bits.$fBitsInteger3; } in
                                                                                                                let {
                                                                                                                  sat_s1CWZ [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dBits_s1CWy
                                                                                                                       yW_s1CWX] \u []
                                                                                                                          Data.Bits.bit
                                                                                                                              $dBits_s1CWy
                                                                                                                              yW_s1CWX;
                                                                                                                } in 
                                                                                                                  GHC.Num.-
                                                                                                                      $dNum_s1CWK
                                                                                                                      sat_s1CWZ
                                                                                                                      sat_s1CX0;
                                                                                                      } in 
                                                                                                        case
                                                                                                            GHC.Classes.<=
                                                                                                                $dOrd_s1CWL
                                                                                                                eta_s1CWA
                                                                                                                sat_s1CX1
                                                                                                        of
                                                                                                        { GHC.Types.False ->
                                                                                                              GHC.Base.Nothing [];
                                                                                                          GHC.Types.True ->
                                                                                                              GHC.Base.Just [y_s1CWC];
                                                                                                        };
                                                                                                  GHC.Types.True ->
                                                                                                      let {
                                                                                                        sat_s1CX9 [Occ=Once]
                                                                                                          :: a_a1AhX
                                                                                                        [LclId] =
                                                                                                            [$dBits_s1CWy
                                                                                                             $dNum_s1CWK
                                                                                                             yW_s1CWX] \u []
                                                                                                                let {
                                                                                                                  sat_s1CX8 [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dNum_s1CWK] \u []
                                                                                                                          GHC.Num.fromInteger
                                                                                                                              $dNum_s1CWK
                                                                                                                              Data.Bits.$fBitsInteger3; } in
                                                                                                                let {
                                                                                                                  sat_s1CX7 [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dBits_s1CWy
                                                                                                                       yW_s1CWX] \u []
                                                                                                                          let {
                                                                                                                            sat_s1CX6 [Occ=Once]
                                                                                                                              :: GHC.Types.Int
                                                                                                                            [LclId] =
                                                                                                                                [yW_s1CWX] \u []
                                                                                                                                    case
                                                                                                                                        yW_s1CWX
                                                                                                                                    of
                                                                                                                                    { GHC.Types.I# x_s1CX4 [Occ=Once] ->
                                                                                                                                          case
                                                                                                                                              -# [x_s1CX4
                                                                                                                                                  1#]
                                                                                                                                          of
                                                                                                                                          sat_s1CX5
                                                                                                                                          { __DEFAULT ->
                                                                                                                                                GHC.Types.I# [sat_s1CX5];
                                                                                                                                          };
                                                                                                                                    };
                                                                                                                          } in 
                                                                                                                            Data.Bits.bit
                                                                                                                                $dBits_s1CWy
                                                                                                                                sat_s1CX6;
                                                                                                                } in 
                                                                                                                  GHC.Num.-
                                                                                                                      $dNum_s1CWK
                                                                                                                      sat_s1CX7
                                                                                                                      sat_s1CX8;
                                                                                                      } in 
                                                                                                        case
                                                                                                            GHC.Classes.<=
                                                                                                                $dOrd_s1CWL
                                                                                                                eta_s1CWA
                                                                                                                sat_s1CX9
                                                                                                        of
                                                                                                        { GHC.Types.False ->
                                                                                                              GHC.Base.Nothing [];
                                                                                                          GHC.Types.True ->
                                                                                                              GHC.Base.Just [y_s1CWC];
                                                                                                        };
                                                                                                };
                                                                                          };
                                                                                } in 
                                                                                  case
                                                                                      xSigned_s1CWI
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        fail3_s1CWU
                                                                                            GHC.Prim.void#;
                                                                                    GHC.Types.True ->
                                                                                        case
                                                                                            ySigned_s1CWG
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              case
                                                                                                  xWidth_s1CWB
                                                                                              of
                                                                                              { GHC.Base.Nothing ->
                                                                                                    fail3_s1CWU
                                                                                                        GHC.Prim.void#;
                                                                                                GHC.Base.Just xW_s1CXe [Occ=Once!] ->
                                                                                                    case
                                                                                                        yWidth_s1CWH
                                                                                                    of
                                                                                                    { GHC.Base.Nothing ->
                                                                                                          fail3_s1CWU
                                                                                                              GHC.Prim.void#;
                                                                                                      GHC.Base.Just yW_s1CXg [Occ=Once!] ->
                                                                                                          case
                                                                                                              yW_s1CXg
                                                                                                          of
                                                                                                          { GHC.Types.I# x_s1CXi [Occ=Once] ->
                                                                                                                case
                                                                                                                    xW_s1CXe
                                                                                                                of
                                                                                                                { GHC.Types.I# x1_s1CXk [Occ=Once] ->
                                                                                                                      case
                                                                                                                          +# [x_s1CXi
                                                                                                                              1#]
                                                                                                                      of
                                                                                                                      sat_s1CXl
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                <=# [x1_s1CXk
                                                                                                                                     sat_s1CXl]
                                                                                                                            of
                                                                                                                            { __DEFAULT ->
                                                                                                                                  fail3_s1CWU
                                                                                                                                      GHC.Prim.void#;
                                                                                                                              1# ->
                                                                                                                                  GHC.Base.Just [y_s1CWC];
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                          GHC.Types.True ->
                                                                                              fail3_s1CWU
                                                                                                  GHC.Prim.void#;
                                                                                        };
                                                                                  };
                                                                      } in 
                                                                        let-no-escape {
                                                                          fail3_s1CXn [Dmd=<L,1*C1(U)>]
                                                                            :: GHC.Prim.Void#
                                                                               -> GHC.Base.Maybe
                                                                                    b_a1AhY
                                                                          [LclId[JoinId(1)],
                                                                           Arity=1,
                                                                           Str=<L,A>,
                                                                           Unf=OtherCon []] =
                                                                              sat-only [xWidth_s1CWB
                                                                                        y_s1CWC
                                                                                        ySigned_s1CWG
                                                                                        yWidth_s1CWH
                                                                                        xSigned_s1CWI
                                                                                        $j1_s1CWT] \r [ds3_s1CXo]
                                                                                  case
                                                                                      xSigned_s1CWI
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        case
                                                                                            ySigned_s1CWG
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              $j1_s1CWT;
                                                                                          GHC.Types.True ->
                                                                                              case
                                                                                                  xWidth_s1CWB
                                                                                              of
                                                                                              { GHC.Base.Nothing ->
                                                                                                    $j1_s1CWT;
                                                                                                GHC.Base.Just xW_s1CXs [Occ=Once!] ->
                                                                                                    case
                                                                                                        yWidth_s1CWH
                                                                                                    of
                                                                                                    { GHC.Base.Nothing ->
                                                                                                          $j1_s1CWT;
                                                                                                      GHC.Base.Just yW_s1CXu [Occ=Once!] ->
                                                                                                          case
                                                                                                              xW_s1CXs
                                                                                                          of
                                                                                                          { GHC.Types.I# x_s1CXw [Occ=Once] ->
                                                                                                                case
                                                                                                                    yW_s1CXu
                                                                                                                of
                                                                                                                { GHC.Types.I# y1_s1CXy [Occ=Once] ->
                                                                                                                      case
                                                                                                                          <# [x_s1CXw
                                                                                                                              y1_s1CXy]
                                                                                                                      of
                                                                                                                      { __DEFAULT ->
                                                                                                                            $j1_s1CWT;
                                                                                                                        1# ->
                                                                                                                            GHC.Base.Just [y_s1CWC];
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                    GHC.Types.True ->
                                                                                        $j1_s1CWT;
                                                                                  };
                                                                        } in 
                                                                          let-no-escape {
                                                                            $j2_s1CXA [Occ=Once*T[0],
                                                                                       Dmd=<L,1*U>]
                                                                              :: GHC.Base.Maybe
                                                                                   b_a1AhY
                                                                            [LclId[JoinId(0)],
                                                                             Unf=OtherCon []] =
                                                                                [xWidth_s1CWB
                                                                                 y_s1CWC
                                                                                 yWidth_s1CWH
                                                                                 $j1_s1CWT
                                                                                 fail3_s1CXn] \r []
                                                                                    case
                                                                                        xWidth_s1CWB
                                                                                    of
                                                                                    { GHC.Base.Nothing ->
                                                                                          fail3_s1CXn
                                                                                              GHC.Prim.void#;
                                                                                      GHC.Base.Just xW_s1CXC [Occ=Once!] ->
                                                                                          case
                                                                                              yWidth_s1CWH
                                                                                          of
                                                                                          { GHC.Base.Nothing ->
                                                                                                fail3_s1CXn
                                                                                                    GHC.Prim.void#;
                                                                                            GHC.Base.Just yW_s1CXE [Occ=Once!] ->
                                                                                                case
                                                                                                    xW_s1CXC
                                                                                                of
                                                                                                { GHC.Types.I# x_s1CXG [Occ=Once] ->
                                                                                                      case
                                                                                                          yW_s1CXE
                                                                                                      of
                                                                                                      { GHC.Types.I# y1_s1CXI [Occ=Once] ->
                                                                                                            case
                                                                                                                <=# [x_s1CXG
                                                                                                                     y1_s1CXI]
                                                                                                            of
                                                                                                            { __DEFAULT ->
                                                                                                                  $j1_s1CWT;
                                                                                                              1# ->
                                                                                                                  GHC.Base.Just [y_s1CWC];
                                                                                                            };
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                          } in 
                                                                            case xSigned_s1CWI of {
                                                                              GHC.Types.False ->
                                                                                  case
                                                                                      ySigned_s1CWG
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        $j2_s1CXA;
                                                                                    GHC.Types.True ->
                                                                                        fail3_s1CXn
                                                                                            GHC.Prim.void#;
                                                                                  };
                                                                              GHC.Types.True ->
                                                                                  case
                                                                                      ySigned_s1CWG
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        fail3_s1CXn
                                                                                            GHC.Prim.void#;
                                                                                    GHC.Types.True ->
                                                                                        $j2_s1CXA;
                                                                                  };
                                                                            };
                                                            } in 
                                                              case xSigned_s1CWI of {
                                                                GHC.Types.False ->
                                                                    case ySigned_s1CWG of {
                                                                      GHC.Types.False ->
                                                                          case yWidth_s1CWH of {
                                                                            GHC.Base.Nothing ->
                                                                                GHC.Base.Just [y_s1CWC];
                                                                            GHC.Base.Just _ [Occ=Dead] ->
                                                                                fail2_s1CWR
                                                                                    GHC.Prim.void#;
                                                                          };
                                                                      GHC.Types.True ->
                                                                          fail2_s1CWR
                                                                              GHC.Prim.void#;
                                                                    };
                                                                GHC.Types.True ->
                                                                    fail2_s1CWR GHC.Prim.void#;
                                                              };
                                                  } in 
                                                    case ySigned_s1CWG of {
                                                      GHC.Types.False -> fail1_s1CWP GHC.Prim.void#;
                                                      GHC.Types.True ->
                                                          case yWidth_s1CWH of {
                                                            GHC.Base.Nothing ->
                                                                GHC.Base.Just [y_s1CWC];
                                                            GHC.Base.Just _ [Occ=Dead] ->
                                                                fail1_s1CWP GHC.Prim.void#;
                                                          };
                                                    };
                                        } in 
                                          let-no-escape {
                                            $j1_s1CXU [Occ=Once*T[0], Dmd=<L,1*U>]
                                              :: GHC.Base.Maybe b_a1AhY
                                            [LclId[JoinId(0)], Unf=OtherCon []] =
                                                [y_s1CWC
                                                 ySigned_s1CWG
                                                 xSigned_s1CWI
                                                 fail_s1CWN] \r []
                                                    case xSigned_s1CWI of {
                                                      GHC.Types.False ->
                                                          case ySigned_s1CWG of {
                                                            GHC.Types.False ->
                                                                GHC.Base.Just [y_s1CWC];
                                                            GHC.Types.True ->
                                                                fail_s1CWN GHC.Prim.void#;
                                                          };
                                                      GHC.Types.True ->
                                                          case ySigned_s1CWG of {
                                                            GHC.Types.False ->
                                                                fail_s1CWN GHC.Prim.void#;
                                                            GHC.Types.True ->
                                                                GHC.Base.Just [y_s1CWC];
                                                          };
                                                    };
                                          } in 
                                            case xWidth_s1CWB of {
                                              GHC.Base.Nothing ->
                                                  case yWidth_s1CWH of {
                                                    GHC.Base.Nothing -> $j1_s1CXU;
                                                    GHC.Base.Just _ [Occ=Dead] ->
                                                        fail_s1CWN GHC.Prim.void#;
                                                  };
                                              GHC.Base.Just a1_s1CY1 [Occ=Once!] ->
                                                  case yWidth_s1CWH of {
                                                    GHC.Base.Nothing -> fail_s1CWN GHC.Prim.void#;
                                                    GHC.Base.Just b1_s1CY3 [Occ=Once!] ->
                                                        case a1_s1CY1 of {
                                                          GHC.Types.I# x_s1CY5 [Occ=Once] ->
                                                              case b1_s1CY3 of {
                                                                GHC.Types.I# y1_s1CY7 [Occ=Once] ->
                                                                    case ==# [x_s1CY5 y1_s1CY7] of {
                                                                      __DEFAULT ->
                                                                          fail_s1CWN GHC.Prim.void#;
                                                                      1# -> $j1_s1CXU;
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                              } in 
                                let-no-escape {
                                  fail_s1CY9 [Dmd=<L,1*C1(U)>]
                                    :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                  [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                      sat-only [$dBits_s1CWy
                                                eta_s1CWA
                                                xWidth_s1CWB
                                                ySigned_s1CWG
                                                yWidth_s1CWH
                                                xSigned_s1CWI
                                                $dNum_s1CWK
                                                $dOrd_s1CWL
                                                $j_s1CWM] \r [ds_s1CYa]
                                          let-no-escape {
                                            fail1_s1CYb [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                              :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                            [LclId[JoinId(1)],
                                             Arity=1,
                                             Str=<L,A>,
                                             Unf=OtherCon []] =
                                                sat-only [$dBits_s1CWy
                                                          eta_s1CWA
                                                          xWidth_s1CWB
                                                          ySigned_s1CWG
                                                          yWidth_s1CWH
                                                          xSigned_s1CWI
                                                          $dNum_s1CWK
                                                          $dOrd_s1CWL
                                                          $j_s1CWM] \r [ds1_s1CYc]
                                                    let-no-escape {
                                                      fail2_s1CYd [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                                        :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                                      [LclId[JoinId(1)],
                                                       Arity=1,
                                                       Str=<L,A>,
                                                       Unf=OtherCon []] =
                                                          sat-only [$dBits_s1CWy
                                                                    eta_s1CWA
                                                                    xWidth_s1CWB
                                                                    ySigned_s1CWG
                                                                    yWidth_s1CWH
                                                                    xSigned_s1CWI
                                                                    $dNum_s1CWK
                                                                    $dOrd_s1CWL
                                                                    $j_s1CWM] \r [ds2_s1CYe]
                                                              let-no-escape {
                                                                $j1_s1CYf [Dmd=<L,1*U>]
                                                                  :: GHC.Base.Maybe b_a1AhY
                                                                [LclId[JoinId(0)],
                                                                 Unf=OtherCon []] =
                                                                    [$dBits_s1CWy
                                                                     eta_s1CWA
                                                                     ySigned_s1CWG
                                                                     yWidth_s1CWH
                                                                     xSigned_s1CWI
                                                                     $dNum_s1CWK
                                                                     $dOrd_s1CWL
                                                                     $j_s1CWM] \r []
                                                                        let-no-escape {
                                                                          fail3_s1CYg [Occ=Once*!T[1],
                                                                                       Dmd=<L,1*C1(U)>]
                                                                            :: GHC.Prim.Void#
                                                                               -> GHC.Base.Maybe
                                                                                    b_a1AhY
                                                                          [LclId[JoinId(1)],
                                                                           Arity=1,
                                                                           Str=<L,A>,
                                                                           Unf=OtherCon []] =
                                                                              sat-only [$dBits_s1CWy
                                                                                        eta_s1CWA
                                                                                        ySigned_s1CWG
                                                                                        yWidth_s1CWH
                                                                                        xSigned_s1CWI
                                                                                        $dNum_s1CWK
                                                                                        $dOrd_s1CWL
                                                                                        $j_s1CWM] \r [ds3_s1CYh]
                                                                                  case
                                                                                      xSigned_s1CWI
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        $j_s1CWM;
                                                                                    GHC.Types.True ->
                                                                                        case
                                                                                            ySigned_s1CWG
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              $j_s1CWM;
                                                                                          GHC.Types.True ->
                                                                                              case
                                                                                                  yWidth_s1CWH
                                                                                              of
                                                                                              { GHC.Base.Nothing ->
                                                                                                    $j_s1CWM;
                                                                                                GHC.Base.Just yW_s1CYl [Occ=Once!] ->
                                                                                                    let {
                                                                                                      sat_s1CYr [Occ=Once]
                                                                                                        :: a_a1AhX
                                                                                                      [LclId] =
                                                                                                          [$dBits_s1CWy
                                                                                                           $dNum_s1CWK
                                                                                                           yW_s1CYl] \u []
                                                                                                              let {
                                                                                                                sat_s1CYq [Occ=Once]
                                                                                                                  :: a_a1AhX
                                                                                                                [LclId] =
                                                                                                                    [$dBits_s1CWy
                                                                                                                     yW_s1CYl] \u []
                                                                                                                        let {
                                                                                                                          sat_s1CYp [Occ=Once]
                                                                                                                            :: GHC.Types.Int
                                                                                                                          [LclId] =
                                                                                                                              [yW_s1CYl] \u []
                                                                                                                                  case
                                                                                                                                      yW_s1CYl
                                                                                                                                  of
                                                                                                                                  { GHC.Types.I# x_s1CYn [Occ=Once] ->
                                                                                                                                        case
                                                                                                                                            -# [x_s1CYn
                                                                                                                                                1#]
                                                                                                                                        of
                                                                                                                                        sat_s1CYo
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              GHC.Types.I# [sat_s1CYo];
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                        } in 
                                                                                                                          Data.Bits.bit
                                                                                                                              $dBits_s1CWy
                                                                                                                              sat_s1CYp;
                                                                                                              } in 
                                                                                                                GHC.Num.negate
                                                                                                                    $dNum_s1CWK
                                                                                                                    sat_s1CYq;
                                                                                                    } in 
                                                                                                      case
                                                                                                          GHC.Classes.<=
                                                                                                              $dOrd_s1CWL
                                                                                                              sat_s1CYr
                                                                                                              eta_s1CWA
                                                                                                      of
                                                                                                      { GHC.Types.False ->
                                                                                                            GHC.Base.Nothing [];
                                                                                                        GHC.Types.True ->
                                                                                                            $j_s1CWM;
                                                                                                      };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                        } in 
                                                                          case xSigned_s1CWI of {
                                                                            GHC.Types.False ->
                                                                                fail3_s1CYg
                                                                                    GHC.Prim.void#;
                                                                            GHC.Types.True ->
                                                                                case
                                                                                    ySigned_s1CWG
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      let {
                                                                                        sat_s1CYv [Occ=Once]
                                                                                          :: a_a1AhX
                                                                                        [LclId] =
                                                                                            [$dNum_s1CWK] \u []
                                                                                                GHC.Num.fromInteger
                                                                                                    $dNum_s1CWK
                                                                                                    Data.Bits.$fBitsInteger_$czeroBits;
                                                                                      } in 
                                                                                        case
                                                                                            GHC.Classes.<=
                                                                                                $dOrd_s1CWL
                                                                                                sat_s1CYv
                                                                                                eta_s1CWA
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              GHC.Base.Nothing [];
                                                                                          GHC.Types.True ->
                                                                                              $j_s1CWM;
                                                                                        };
                                                                                  GHC.Types.True ->
                                                                                      fail3_s1CYg
                                                                                          GHC.Prim.void#;
                                                                                };
                                                                          };
                                                              } in 
                                                                let-no-escape {
                                                                  fail3_s1CYx [Dmd=<L,1*C1(U)>]
                                                                    :: GHC.Prim.Void#
                                                                       -> GHC.Base.Maybe b_a1AhY
                                                                  [LclId[JoinId(1)],
                                                                   Arity=1,
                                                                   Str=<L,A>,
                                                                   Unf=OtherCon []] =
                                                                      sat-only [xWidth_s1CWB
                                                                                ySigned_s1CWG
                                                                                yWidth_s1CWH
                                                                                xSigned_s1CWI
                                                                                $j_s1CWM
                                                                                $j1_s1CYf] \r [ds3_s1CYy]
                                                                          case xSigned_s1CWI of {
                                                                            GHC.Types.False ->
                                                                                case
                                                                                    ySigned_s1CWG
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      $j1_s1CYf;
                                                                                  GHC.Types.True ->
                                                                                      case
                                                                                          xWidth_s1CWB
                                                                                      of
                                                                                      { GHC.Base.Nothing ->
                                                                                            $j1_s1CYf;
                                                                                        GHC.Base.Just xW_s1CYC [Occ=Once!] ->
                                                                                            case
                                                                                                yWidth_s1CWH
                                                                                            of
                                                                                            { GHC.Base.Nothing ->
                                                                                                  $j1_s1CYf;
                                                                                              GHC.Base.Just yW_s1CYE [Occ=Once!] ->
                                                                                                  case
                                                                                                      xW_s1CYC
                                                                                                  of
                                                                                                  { GHC.Types.I# x_s1CYG [Occ=Once] ->
                                                                                                        case
                                                                                                            yW_s1CYE
                                                                                                        of
                                                                                                        { GHC.Types.I# y1_s1CYI [Occ=Once] ->
                                                                                                              case
                                                                                                                  <# [x_s1CYG
                                                                                                                      y1_s1CYI]
                                                                                                              of
                                                                                                              { __DEFAULT ->
                                                                                                                    $j1_s1CYf;
                                                                                                                1# ->
                                                                                                                    $j_s1CWM;
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                            GHC.Types.True ->
                                                                                $j1_s1CYf;
                                                                          };
                                                                } in 
                                                                  let-no-escape {
                                                                    $j2_s1CYK [Occ=Once*T[0],
                                                                               Dmd=<L,1*U>]
                                                                      :: GHC.Base.Maybe b_a1AhY
                                                                    [LclId[JoinId(0)],
                                                                     Unf=OtherCon []] =
                                                                        [xWidth_s1CWB
                                                                         yWidth_s1CWH
                                                                         $j_s1CWM
                                                                         $j1_s1CYf
                                                                         fail3_s1CYx] \r []
                                                                            case xWidth_s1CWB of {
                                                                              GHC.Base.Nothing ->
                                                                                  fail3_s1CYx
                                                                                      GHC.Prim.void#;
                                                                              GHC.Base.Just xW_s1CYM [Occ=Once!] ->
                                                                                  case
                                                                                      yWidth_s1CWH
                                                                                  of
                                                                                  { GHC.Base.Nothing ->
                                                                                        fail3_s1CYx
                                                                                            GHC.Prim.void#;
                                                                                    GHC.Base.Just yW_s1CYO [Occ=Once!] ->
                                                                                        case
                                                                                            xW_s1CYM
                                                                                        of
                                                                                        { GHC.Types.I# x_s1CYQ [Occ=Once] ->
                                                                                              case
                                                                                                  yW_s1CYO
                                                                                              of
                                                                                              { GHC.Types.I# y1_s1CYS [Occ=Once] ->
                                                                                                    case
                                                                                                        <=# [x_s1CYQ
                                                                                                             y1_s1CYS]
                                                                                                    of
                                                                                                    { __DEFAULT ->
                                                                                                          $j1_s1CYf;
                                                                                                      1# ->
                                                                                                          $j_s1CWM;
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                  } in 
                                                                    case xSigned_s1CWI of {
                                                                      GHC.Types.False ->
                                                                          case ySigned_s1CWG of {
                                                                            GHC.Types.False ->
                                                                                $j2_s1CYK;
                                                                            GHC.Types.True ->
                                                                                fail3_s1CYx
                                                                                    GHC.Prim.void#;
                                                                          };
                                                                      GHC.Types.True ->
                                                                          case ySigned_s1CWG of {
                                                                            GHC.Types.False ->
                                                                                fail3_s1CYx
                                                                                    GHC.Prim.void#;
                                                                            GHC.Types.True ->
                                                                                $j2_s1CYK;
                                                                          };
                                                                    };
                                                    } in 
                                                      case xSigned_s1CWI of {
                                                        GHC.Types.False ->
                                                            case ySigned_s1CWG of {
                                                              GHC.Types.False ->
                                                                  case yWidth_s1CWH of {
                                                                    GHC.Base.Nothing -> $j_s1CWM;
                                                                    GHC.Base.Just _ [Occ=Dead] ->
                                                                        fail2_s1CYd GHC.Prim.void#;
                                                                  };
                                                              GHC.Types.True ->
                                                                  fail2_s1CYd GHC.Prim.void#;
                                                            };
                                                        GHC.Types.True ->
                                                            fail2_s1CYd GHC.Prim.void#;
                                                      };
                                          } in 
                                            case ySigned_s1CWG of {
                                              GHC.Types.False -> fail1_s1CYb GHC.Prim.void#;
                                              GHC.Types.True ->
                                                  case yWidth_s1CWH of {
                                                    GHC.Base.Nothing -> $j_s1CWM;
                                                    GHC.Base.Just _ [Occ=Dead] ->
                                                        fail1_s1CYb GHC.Prim.void#;
                                                  };
                                            };
                                } in 
                                  let-no-escape {
                                    $j1_s1CZ4 [Occ=Once*T[0], Dmd=<L,1*U>] :: GHC.Base.Maybe b_a1AhY
                                    [LclId[JoinId(0)], Unf=OtherCon []] =
                                        [ySigned_s1CWG xSigned_s1CWI $j_s1CWM fail_s1CY9] \r []
                                            case xSigned_s1CWI of {
                                              GHC.Types.False ->
                                                  case ySigned_s1CWG of {
                                                    GHC.Types.False -> $j_s1CWM;
                                                    GHC.Types.True -> fail_s1CY9 GHC.Prim.void#;
                                                  };
                                              GHC.Types.True ->
                                                  case ySigned_s1CWG of {
                                                    GHC.Types.False -> fail_s1CY9 GHC.Prim.void#;
                                                    GHC.Types.True -> $j_s1CWM;
                                                  };
                                            };
                                  } in 
                                    case xWidth_s1CWB of {
                                      GHC.Base.Nothing ->
                                          case yWidth_s1CWH of {
                                            GHC.Base.Nothing -> $j1_s1CZ4;
                                            GHC.Base.Just _ [Occ=Dead] -> fail_s1CY9 GHC.Prim.void#;
                                          };
                                      GHC.Base.Just a1_s1CZb [Occ=Once!] ->
                                          case yWidth_s1CWH of {
                                            GHC.Base.Nothing -> fail_s1CY9 GHC.Prim.void#;
                                            GHC.Base.Just b1_s1CZd [Occ=Once!] ->
                                                case a1_s1CZb of {
                                                  GHC.Types.I# x_s1CZf [Occ=Once] ->
                                                      case b1_s1CZd of {
                                                        GHC.Types.I# y1_s1CZh [Occ=Once] ->
                                                            case ==# [x_s1CZf y1_s1CZh] of {
                                                              __DEFAULT ->
                                                                  fail_s1CY9 GHC.Prim.void#;
                                                              1# -> $j1_s1CZ4;
                                                            };
                                                      };
                                                };
                                          };
                                    };
                      };
                };
        };

Data.Bits.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Bits.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$trModule4];

Data.Bits.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bits"#;

Data.Bits.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$trModule2];

Data.Bits.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bits.$trModule3
                                     Data.Bits.$trModule1];

$krep_r1CDE :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcBool
                                              GHC.Types.[]];

$krep1_r1CDF :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcInt
                                              GHC.Types.[]];

$krep2_r1CDG :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

$krep3_r1CDH :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r1CDF GHC.Types.[]];

$krep4_r1CDI :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep3_r1CDH];

$krep5_r1CDJ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r1CDF $krep_r1CDE];

Data.Bits.$tcBits1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*
                                         $krep2_r1CDG];

$krep6_r1CDK :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep7_r1CDL :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep6_r1CDK];

$krep8_r1CDM :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep7_r1CDL];

$krep9_r1CDN :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep5_r1CDJ];

$krep10_r1CDO :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep4_r1CDI];

$krep11_r1CDP :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep1_r1CDF];

$krep12_r1CDQ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep_r1CDE];

$krep13_r1CDR :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r1CDF $krep6_r1CDK];

$krep14_r1CDS :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep13_r1CDR];

$krep15_r1CDT :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_r1CDK GHC.Types.[]];

$krep16_r1CDU :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Classes.$tcEq
                                              $krep15_r1CDT];

Data.Bits.$tcBits3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bits"#;

Data.Bits.$tcBits2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tcBits3];

Data.Bits.$tcBits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7088815172979416363##
                                    4990916430057605838##
                                    Data.Bits.$trModule
                                    Data.Bits.$tcBits2
                                    0#
                                    Data.Bits.$tcBits1];

$krep17_r1CDV :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Bits.$tcBits
                                              $krep15_r1CDT];

$krep18_r1CDW :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep17_r1CDV];

$krep19_r1CDX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep18_r1CDW];

$krep20_r1CDY :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep19_r1CDX];

$krep21_r1CDZ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep20_r1CDY];

$krep22_r1CE0 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep21_r1CDZ];

$krep23_r1CE1 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep22_r1CE0];

$krep24_r1CE2 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep23_r1CE1];

$krep25_r1CE3 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep12_r1CDQ $krep24_r1CE2];

$krep26_r1CE4 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep25_r1CE3];

$krep27_r1CE5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_r1CDO $krep26_r1CE4];

$krep28_r1CE6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep9_r1CDN $krep27_r1CE5];

$krep29_r1CE7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep28_r1CE6];

$krep30_r1CE8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep29_r1CE7];

$krep31_r1CE9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep30_r1CE8];

$krep32_r1CEa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep13_r1CDR $krep31_r1CE9];

$krep33_r1CEb :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep32_r1CEa];

$krep34_r1CEc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep33_r1CEb];

$krep35_r1CEd :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep34_r1CEc];

$krep36_r1CEe :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_r1CDL $krep35_r1CEd];

$krep37_r1CEf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r1CDM $krep36_r1CEe];

$krep38_r1CEg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r1CDM $krep37_r1CEf];

$krep39_r1CEh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r1CDM $krep38_r1CEg];

Data.Bits.$tc'C:Bits1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep16_r1CDU $krep39_r1CEh];

Data.Bits.$tc'C:Bits3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Bits"#;

Data.Bits.$tc'C:Bits2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tc'C:Bits3];

Data.Bits.$tc'C:Bits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [744071653035646959##
                                    2574978498160477882##
                                    Data.Bits.$trModule
                                    Data.Bits.$tc'C:Bits2
                                    1#
                                    Data.Bits.$tc'C:Bits1];

Data.Bits.$tcFiniteBits2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "FiniteBits"#;

Data.Bits.$tcFiniteBits1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tcFiniteBits2];

Data.Bits.$tcFiniteBits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2363162769622202131##
                                    10110405838341883172##
                                    Data.Bits.$trModule
                                    Data.Bits.$tcFiniteBits1
                                    0#
                                    Data.Bits.$tcBits1];

$krep40_r1CEi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Bits.$tcFiniteBits
                                              $krep15_r1CDT];

$krep41_r1CEj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep40_r1CEi];

$krep42_r1CEk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep41_r1CEj];

$krep43_r1CEl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep42_r1CEk];

Data.Bits.$tc'C:FiniteBits1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep17_r1CDV $krep43_r1CEl];

Data.Bits.$tc'C:FiniteBits3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:FiniteBits"#;

Data.Bits.$tc'C:FiniteBits2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tc'C:FiniteBits3];

Data.Bits.$tc'C:FiniteBits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7500562306525175158##
                                    16051895206261500648##
                                    Data.Bits.$trModule
                                    Data.Bits.$tc'C:FiniteBits2
                                    1#
                                    Data.Bits.$tc'C:FiniteBits1];

Data.Bits.C:FiniteBits
  :: forall b.
     Data.Bits.Bits b =>
     (b -> GHC.Types.Int)
     -> (b -> GHC.Types.Int)
     -> (b -> GHC.Types.Int)
     -> Data.Bits.FiniteBits b
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bits.C:FiniteBits [eta_B4 eta_B3 eta_B2 eta_B1];

Data.Bits.C:Bits
  :: forall a.
     GHC.Classes.Eq a =>
     (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> a
     -> (GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> GHC.Types.Bool)
     -> (a -> GHC.Base.Maybe GHC.Types.Int)
     -> (a -> GHC.Types.Int)
     -> (a -> GHC.Types.Bool)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int)
     -> Data.Bits.Bits a
[GblId[DataCon],
 Arity=23,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_Bn
           eta_Bm
           eta_Bl
           eta_Bk
           eta_Bj
           eta_Bi
           eta_Bh
           eta_Bg
           eta_Bf
           eta_Be
           eta_Bd
           eta_Bc
           eta_Bb
           eta_Ba
           eta_B9
           eta_B8
           eta_B7
           eta_B6
           eta_B5
           eta_B4
           eta_B3
           eta_B2
           eta_B1]
        Data.Bits.C:Bits [eta_Bn
                          eta_Bm
                          eta_Bl
                          eta_Bk
                          eta_Bj
                          eta_Bi
                          eta_Bh
                          eta_Bg
                          eta_Bf
                          eta_Be
                          eta_Bd
                          eta_Bc
                          eta_Bb
                          eta_Ba
                          eta_B9
                          eta_B8
                          eta_B7
                          eta_B6
                          eta_B5
                          eta_B4
                          eta_B3
                          eta_B2
                          eta_B1];


==================== STG syntax: ====================
2018-03-16 15:56:23.043765027 UTC

Data.Bits.$p1FiniteBits
  :: forall b. Data.Bits.FiniteBits b => Data.Bits.Bits b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_s1CEn]
        case v_s1CEn of {
          Data.Bits.C:FiniteBits v_s1CEp [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s1CEp;
        };

Data.Bits.finiteBitSize
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_s1CEt]
        case v_s1CEt of {
          Data.Bits.C:FiniteBits _ [Occ=Dead]
                                 v_s1CEw [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s1CEw;
        };

Data.Bits.countLeadingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_s1CEz]
        case v_s1CEz of {
          Data.Bits.C:FiniteBits _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s1CED [Occ=Once]
                                 _ [Occ=Dead] ->
              v_s1CED;
        };

Data.Bits.countTrailingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_s1CEF]
        case v_s1CEF of {
          Data.Bits.C:FiniteBits _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s1CEK [Occ=Once] ->
              v_s1CEK;
        };

Data.Bits.$p1Bits :: forall a. Data.Bits.Bits a => GHC.Classes.Eq a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLLLLLLLLLLLLLLLL),U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CEL]
        case v_s1CEL of {
          Data.Bits.C:Bits v_s1CEN [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CEN;
        };

Data.Bits..&. :: forall a. Data.Bits.Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLLLLLLLLLLLLLLLL),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CFa]
        case v_s1CFa of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           v_s1CFd [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CFd;
        };

Data.Bits..|. :: forall a. Data.Bits.Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLLLLLLLLLLLLLLLL),U(A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CFz]
        case v_s1CFz of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CFD [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CFD;
        };

Data.Bits.xor :: forall a. Data.Bits.Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLLLLLLLLLLLLLLLL),U(A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CFY]
        case v_s1CFY of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CG3 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CG3;
        };

Data.Bits.complement :: forall a. Data.Bits.Bits a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLLLLLLLLLLLLLLLL),U(A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CGn]
        case v_s1CGn of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CGt [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CGt;
        };

Data.Bits.shift
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLLLLLLLLLLLLLLLL),U(A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CGM]
        case v_s1CGM of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CGT [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CGT;
        };

Data.Bits.rotate
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLLLLLLLLLLLLLLLL),U(A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CHb]
        case v_s1CHb of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CHj [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CHj;
        };

Data.Bits.zeroBits :: forall a. Data.Bits.Bits a => a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSLLLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CHA]
        case v_s1CHA of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CHJ [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CHJ;
        };

Data.Bits.bit :: forall a. Data.Bits.Bits a => GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLSLLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CHZ]
        case v_s1CHZ of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CI9 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CI9;
        };

Data.Bits.setBit
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLSLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CIo]
        case v_s1CIo of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CIz [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CIz;
        };

Data.Bits.clearBit
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLSLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CIN]
        case v_s1CIN of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CIZ [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CIZ;
        };

Data.Bits.complementBit
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLSLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CJc]
        case v_s1CJc of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CJp [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CJp;
        };

Data.Bits.testBit
  :: forall a.
     Data.Bits.Bits a =>
     a -> GHC.Types.Int -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLSLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CJB]
        case v_s1CJB of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CJP [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CJP;
        };

Data.Bits.bitSizeMaybe
  :: forall a. Data.Bits.Bits a => a -> GHC.Base.Maybe GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLSLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CK0]
        case v_s1CK0 of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CKf [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CKf;
        };

Data.Bits.bitSize
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLSLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CKp]
        case v_s1CKp of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CKF [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CKF;
        };

Data.Bits.isSigned
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLSLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A)>] =
    [] \r [v_s1CKO]
        case v_s1CKO of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CL5 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CL5;
        };

Data.Bits.shiftL
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLSLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A)>] =
    [] \r [v_s1CLd]
        case v_s1CLd of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CLv [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CLv;
        };

Data.Bits.unsafeShiftL
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLSLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A)>] =
    [] \r [v_s1CLC]
        case v_s1CLC of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CLV [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CLV;
        };

Data.Bits.shiftR
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLSLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A)>] =
    [] \r [v_s1CM1]
        case v_s1CM1 of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CMl [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CMl;
        };

Data.Bits.unsafeShiftR
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLSLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A)>] =
    [] \r [v_s1CMq]
        case v_s1CMq of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CML [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CML;
        };

Data.Bits.rotateL
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLSLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A)>] =
    [] \r [v_s1CMP]
        case v_s1CMP of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CNb [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1CNb;
        };

Data.Bits.rotateR
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A)>] =
    [] \r [v_s1CNe]
        case v_s1CNe of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CNB [Occ=Once]
                           _ [Occ=Dead] ->
              v_s1CNB;
        };

Data.Bits.popCount
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLLLS),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U)>] =
    [] \r [v_s1CND]
        case v_s1CND of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1CO1 [Occ=Once] ->
              v_s1CO1;
        };

Data.Bits.$fBitsBool2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Bits.$fBitsBool1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Bits.$fBitsBool_$cpopCount :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_s1CO2]
        case ds_s1CO2 of {
          GHC.Types.False -> Data.Bits.$fBitsBool2;
          GHC.Types.True -> Data.Bits.$fBitsBool1;
        };

Data.Bits.$fBitsBool_$cisSigned :: GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1CO4] GHC.Types.False [];

Data.Bits.$fBitsBool_$cbitSize :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s1CO5] Data.Bits.$fBitsBool1;

Data.Bits.$fBitsBool3 :: GHC.Base.Maybe GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [Data.Bits.$fBitsBool1];

Data.Bits.$fBitsBool_$cbitSizeMaybe
  :: GHC.Types.Bool -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m2, Unf=OtherCon []] =
    [] \r [ds_s1CO6] Data.Bits.$fBitsBool3;

Data.Bits.$fBitsBool_$ctestBit
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [x_s1CO7 ds_s1CO8]
        case ds_s1CO8 of {
          GHC.Types.I# ds1_s1COa [Occ=Once!] ->
              case ds1_s1COa of {
                __DEFAULT -> GHC.Types.False [];
                0# -> x_s1CO7;
              };
        };

Data.Bits.$fBitsBool_$cbit :: GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1COc]
        case ds_s1COc of {
          GHC.Types.I# ds1_s1COe [Occ=Once!] ->
              case ds1_s1COe of {
                __DEFAULT -> GHC.Types.False [];
                0# -> GHC.Types.True [];
              };
        };

Data.Bits.$fBitsBool_$crotate
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s1COg ds_s1COh] x_s1COg;

Data.Bits.$fBitsInteger_$cisSigned
  :: GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1COi] GHC.Types.True [];

Data.Bits.$fBitsInteger2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bits.bitSize(Integer)"#;

Data.Bits.$fBitsInteger1 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Bits.$fBitsInteger2;

Data.Bits.$fBitsInteger_$cbitSize
  :: GHC.Integer.Type.Integer -> GHC.Types.Int
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [ds_s1COj]
        GHC.Err.errorWithoutStackTrace Data.Bits.$fBitsInteger1;

Data.Bits.$fBitsInteger_$cbitSizeMaybe
  :: GHC.Integer.Type.Integer -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1COk] GHC.Base.Nothing [];

Data.Bits.$fBitsInteger_$ctestBit
  :: GHC.Integer.Type.Integer -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1COl ds_s1COm]
        case ds_s1COm of {
          GHC.Types.I# i_s1COo [Occ=Once] ->
              GHC.Integer.Type.testBitInteger x_s1COl i_s1COo;
        };

Data.Bits.$fBitsInteger_$czeroBits :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Bits.$w$cshift [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Prim.Int# -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [w_s1COp ww_s1COq]
        case >=# [ww_s1COq 0#] of {
          __DEFAULT ->
              case negateInt# [ww_s1COq] of sat_s1COs {
                __DEFAULT -> GHC.Integer.Type.shiftRInteger w_s1COp sat_s1COs;
              };
          1# -> GHC.Integer.Type.shiftLInteger w_s1COp ww_s1COq;
        };

Data.Bits.$fBitsInteger_$cshift [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [w_s1COt w1_s1COu]
        case w1_s1COu of {
          GHC.Types.I# ww1_s1COw [Occ=Once] ->
              Data.Bits.$w$cshift w_s1COt ww1_s1COw;
        };

sat_s1COx :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s1COy :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1COx GHC.Types.[]];

Data.Bits.$fBitsInteger3 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s1COy;

Data.Bits.$fBitsInteger_$cbit
  :: GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [i_s1COz]
        case i_s1COz of {
          GHC.Types.I# ww1_s1COB ->
              case >=# [ww1_s1COB 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1COB] of sat_s1COD {
                      __DEFAULT ->
                          GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1COD;
                    };
                1# ->
                    GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1COB;
              };
        };

Data.Bits.$fBitsInteger_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1COE eta1_s1COF]
        case eta1_s1COF of {
          GHC.Types.I# ww1_s1COH ->
              case >=# [ww1_s1COH 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1COH] of sat_s1COJ {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1COJ
                          of
                          sat_s1COK
                          { __DEFAULT ->
                                case GHC.Integer.Type.complementInteger sat_s1COK of sat_s1COL {
                                  __DEFAULT -> GHC.Integer.Type.andInteger eta_s1COE sat_s1COL;
                                };
                          };
                    };
                1# ->
                    case
                        GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1COH
                    of
                    sat_s1COM
                    { __DEFAULT ->
                          case GHC.Integer.Type.complementInteger sat_s1COM of sat_s1CON {
                            __DEFAULT -> GHC.Integer.Type.andInteger eta_s1COE sat_s1CON;
                          };
                    };
              };
        };

Data.Bits.$fBitsInteger_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1COO eta1_s1COP]
        case eta1_s1COP of {
          GHC.Types.I# ww1_s1COR ->
              case >=# [ww1_s1COR 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1COR] of sat_s1COT {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1COT
                          of
                          sat_s1COU
                          { __DEFAULT -> GHC.Integer.Type.xorInteger eta_s1COO sat_s1COU;
                          };
                    };
                1# ->
                    case
                        GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1COR
                    of
                    sat_s1COV
                    { __DEFAULT -> GHC.Integer.Type.xorInteger eta_s1COO sat_s1COV;
                    };
              };
        };

Data.Bits.$fBitsInteger_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1COW eta1_s1COX]
        case eta1_s1COX of {
          GHC.Types.I# ww1_s1COZ ->
              case >=# [ww1_s1COZ 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1COZ] of sat_s1CP1 {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1CP1
                          of
                          sat_s1CP2
                          { __DEFAULT -> GHC.Integer.Type.orInteger eta_s1COW sat_s1CP2;
                          };
                    };
                1# ->
                    case
                        GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1COZ
                    of
                    sat_s1CP3
                    { __DEFAULT -> GHC.Integer.Type.orInteger eta_s1COW sat_s1CP3;
                    };
              };
        };

Data.Bits.$fBitsInteger_$cunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshift eta_B2 eta_B1;

Data.Bits.$fBitsInteger_$cshiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshift eta_B2 eta_B1;

Data.Bits.$fBitsInteger_$cshiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1CP4 eta1_s1CP5]
        case eta1_s1CP5 of {
          GHC.Types.I# x_s1CP7 [Occ=Once] ->
              case negateInt# [x_s1CP7] of i#_s1CP8 [Dmd=<S,U>] {
                __DEFAULT ->
                    case >=# [i#_s1CP8 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1CP8] of sat_s1CPa {
                            __DEFAULT -> GHC.Integer.Type.shiftRInteger eta_s1CP4 sat_s1CPa;
                          };
                      1# -> GHC.Integer.Type.shiftLInteger eta_s1CP4 i#_s1CP8;
                    };
              };
        };

Data.Bits.$fBitsInteger_$cunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshiftR eta_B2 eta_B1;

Data.Bits.$fBitsInteger_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1CPb eta1_s1CPc]
        case eta1_s1CPc of {
          GHC.Types.I# x_s1CPe [Occ=Once] ->
              case negateInt# [x_s1CPe] of i#_s1CPf [Dmd=<S,U>] {
                __DEFAULT ->
                    case >=# [i#_s1CPf 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1CPf] of sat_s1CPh {
                            __DEFAULT -> GHC.Integer.Type.shiftRInteger eta_s1CPb sat_s1CPh;
                          };
                      1# -> GHC.Integer.Type.shiftLInteger eta_s1CPb i#_s1CPf;
                    };
              };
        };

Data.Bits.$fBitsInteger_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshift eta_B2 eta_B1;

Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros
  :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [x_s1CPi]
        case x_s1CPi of {
          GHC.Types.False -> Data.Bits.$fBitsBool1;
          GHC.Types.True -> Data.Bits.$fBitsBool2;
        };

Data.Bits.$fBitsInt_$cpopCount :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CPk]
        case ds_s1CPk of {
          GHC.Types.I# x#_s1CPm [Occ=Once] ->
              case int2Word# [x#_s1CPm] of sat_s1CPn {
                __DEFAULT ->
                    case popCnt# [sat_s1CPn] of sat_s1CPo {
                      __DEFAULT ->
                          case word2Int# [sat_s1CPo] of sat_s1CPp {
                            __DEFAULT -> GHC.Types.I# [sat_s1CPp];
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cunsafeShiftR
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CPq ds1_s1CPr]
        case ds_s1CPq of {
          GHC.Types.I# x#_s1CPt [Occ=Once] ->
              case ds1_s1CPr of {
                GHC.Types.I# i#_s1CPv [Occ=Once] ->
                    case uncheckedIShiftRA# [x#_s1CPt i#_s1CPv] of sat_s1CPw {
                      __DEFAULT -> GHC.Types.I# [sat_s1CPw];
                    };
              };
        };

lvl_r1CDD :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [-1#];

Data.Bits.$fBitsInt_$cshiftR [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1CPx w1_s1CPy]
        case w_s1CPx of {
          GHC.Types.I# ww1_s1CPA [Occ=Once*] ->
              case w1_s1CPy of {
                GHC.Types.I# ww3_s1CPC ->
                    case >=# [ww3_s1CPC 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftRA# [ww1_s1CPA ww3_s1CPC] of sat_s1CPE {
                            __DEFAULT -> GHC.Types.I# [sat_s1CPE];
                          };
                      1# ->
                          case <# [ww1_s1CPA 0#] of {
                            __DEFAULT -> Data.Bits.$fBitsBool2;
                            1# -> lvl_r1CDD;
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cunsafeShiftL
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CPG ds1_s1CPH]
        case ds_s1CPG of {
          GHC.Types.I# x#_s1CPJ [Occ=Once] ->
              case ds1_s1CPH of {
                GHC.Types.I# i#_s1CPL [Occ=Once] ->
                    case uncheckedIShiftL# [x#_s1CPJ i#_s1CPL] of sat_s1CPM {
                      __DEFAULT -> GHC.Types.I# [sat_s1CPM];
                    };
              };
        };

Data.Bits.$fBitsInt_$cshiftL
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CPN ds1_s1CPO]
        case ds_s1CPN of {
          GHC.Types.I# x#_s1CPQ [Occ=Once] ->
              case ds1_s1CPO of {
                GHC.Types.I# i#_s1CPS ->
                    case >=# [i#_s1CPS 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [x#_s1CPQ i#_s1CPS] of sat_s1CPU {
                            __DEFAULT -> GHC.Types.I# [sat_s1CPU];
                          };
                      1# -> Data.Bits.$fBitsBool2;
                    };
              };
        };

Data.Bits.$fBitsInt_$cisSigned :: GHC.Types.Int -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1CPV] GHC.Types.True [];

Data.Bits.$fBitsInt_$crotate [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CPW ds1_s1CPX]
        case ds_s1CPW of {
          GHC.Types.I# x#_s1CPZ ->
              case ds1_s1CPX of {
                GHC.Types.I# i#_s1CQ1 [Occ=Once] ->
                    case andI# [i#_s1CQ1 63#] of i'#_s1CQ2 [Dmd=<S,U>] {
                      __DEFAULT ->
                          case -# [64# i'#_s1CQ2] of sat_s1CQ4 {
                            __DEFAULT ->
                                case uncheckedIShiftRL# [x#_s1CPZ sat_s1CQ4] of sat_s1CQ5 {
                                  __DEFAULT ->
                                      case uncheckedIShiftL# [x#_s1CPZ i'#_s1CQ2] of sat_s1CQ3 {
                                        __DEFAULT ->
                                            case orI# [sat_s1CQ3 sat_s1CQ5] of sat_s1CQ6 {
                                              __DEFAULT -> GHC.Types.I# [sat_s1CQ6];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cshift [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQ7 ds1_s1CQ8]
        case ds_s1CQ7 of {
          GHC.Types.I# x#_s1CQa [Occ=Once*] ->
              case ds1_s1CQ8 of {
                GHC.Types.I# i#_s1CQc ->
                    case >=# [i#_s1CQc 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1CQc] of b_s1CQe [Dmd=<S,U>] {
                            __DEFAULT ->
                                case >=# [b_s1CQe 64#] of {
                                  __DEFAULT ->
                                      case uncheckedIShiftRA# [x#_s1CQa b_s1CQe] of sat_s1CQg {
                                        __DEFAULT -> GHC.Types.I# [sat_s1CQg];
                                      };
                                  1# ->
                                      case <# [x#_s1CQa 0#] of {
                                        __DEFAULT -> Data.Bits.$fBitsBool2;
                                        1# -> lvl_r1CDD;
                                      };
                                };
                          };
                      1# ->
                          case >=# [i#_s1CQc 64#] of {
                            __DEFAULT ->
                                case uncheckedIShiftL# [x#_s1CQa i#_s1CQc] of sat_s1CQj {
                                  __DEFAULT -> GHC.Types.I# [sat_s1CQj];
                                };
                            1# -> Data.Bits.$fBitsBool2;
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$ccomplement :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQk]
        case ds_s1CQk of {
          GHC.Types.I# x#_s1CQm [Occ=Once] ->
              case notI# [x#_s1CQm] of sat_s1CQn {
                __DEFAULT -> GHC.Types.I# [sat_s1CQn];
              };
        };

Data.Bits.$fBitsInt_$cxor
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQo ds1_s1CQp]
        case ds_s1CQo of {
          GHC.Types.I# x#_s1CQr [Occ=Once] ->
              case ds1_s1CQp of {
                GHC.Types.I# y#_s1CQt [Occ=Once] ->
                    case xorI# [x#_s1CQr y#_s1CQt] of sat_s1CQu {
                      __DEFAULT -> GHC.Types.I# [sat_s1CQu];
                    };
              };
        };

Data.Bits.$fBitsInt_$c.|.
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQv ds1_s1CQw]
        case ds_s1CQv of {
          GHC.Types.I# x#_s1CQy [Occ=Once] ->
              case ds1_s1CQw of {
                GHC.Types.I# y#_s1CQA [Occ=Once] ->
                    case orI# [x#_s1CQy y#_s1CQA] of sat_s1CQB {
                      __DEFAULT -> GHC.Types.I# [sat_s1CQB];
                    };
              };
        };

Data.Bits.$fBitsInt_$c.&.
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQC ds1_s1CQD]
        case ds_s1CQC of {
          GHC.Types.I# x#_s1CQF [Occ=Once] ->
              case ds1_s1CQD of {
                GHC.Types.I# y#_s1CQH [Occ=Once] ->
                    case andI# [x#_s1CQF y#_s1CQH] of sat_s1CQI {
                      __DEFAULT -> GHC.Types.I# [sat_s1CQI];
                    };
              };
        };

Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros
  :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQJ]
        case ds_s1CQJ of {
          GHC.Types.I# x#_s1CQL [Occ=Once] ->
              case int2Word# [x#_s1CQL] of sat_s1CQM {
                __DEFAULT ->
                    case ctz# [sat_s1CQM] of sat_s1CQN {
                      __DEFAULT ->
                          case word2Int# [sat_s1CQN] of sat_s1CQO {
                            __DEFAULT -> GHC.Types.I# [sat_s1CQO];
                          };
                    };
              };
        };

Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros
  :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQP]
        case ds_s1CQP of {
          GHC.Types.I# x#_s1CQR [Occ=Once] ->
              case int2Word# [x#_s1CQR] of sat_s1CQS {
                __DEFAULT ->
                    case clz# [sat_s1CQS] of sat_s1CQT {
                      __DEFAULT ->
                          case word2Int# [sat_s1CQT] of sat_s1CQU {
                            __DEFAULT -> GHC.Types.I# [sat_s1CQU];
                          };
                    };
              };
        };

Data.Bits.$fBitsInt1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [64#];

Data.Bits.$fBitsInt_$cfiniteBitSize
  :: GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s1CQV] Data.Bits.$fBitsInt1;

Data.Bits.$fBitsWord_$cpopCount :: GHC.Types.Word -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CQW]
        case ds_s1CQW of {
          GHC.Types.W# x#_s1CQY [Occ=Once] ->
              case popCnt# [x#_s1CQY] of sat_s1CQZ {
                __DEFAULT ->
                    case word2Int# [sat_s1CQZ] of sat_s1CR0 {
                      __DEFAULT -> GHC.Types.I# [sat_s1CR0];
                    };
              };
        };

Data.Bits.$fBitsWord_$cunsafeShiftR
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CR1 ds1_s1CR2]
        case ds_s1CR1 of {
          GHC.Types.W# x#_s1CR4 [Occ=Once] ->
              case ds1_s1CR2 of {
                GHC.Types.I# i#_s1CR6 [Occ=Once] ->
                    case uncheckedShiftRL# [x#_s1CR4 i#_s1CR6] of sat_s1CR7 {
                      __DEFAULT -> GHC.Types.W# [sat_s1CR7];
                    };
              };
        };

Data.Bits.$fBitsWord1 :: GHC.Types.Word
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.W#! [0##];

Data.Bits.$fBitsWord_$cshiftR
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CR8 ds1_s1CR9]
        case ds_s1CR8 of {
          GHC.Types.W# x#_s1CRb [Occ=Once] ->
              case ds1_s1CR9 of {
                GHC.Types.I# i#_s1CRd ->
                    case >=# [i#_s1CRd 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftRL# [x#_s1CRb i#_s1CRd] of sat_s1CRf {
                            __DEFAULT -> GHC.Types.W# [sat_s1CRf];
                          };
                      1# -> Data.Bits.$fBitsWord1;
                    };
              };
        };

Data.Bits.$fBitsWord_$cunsafeShiftL
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CRg ds1_s1CRh]
        case ds_s1CRg of {
          GHC.Types.W# x#_s1CRj [Occ=Once] ->
              case ds1_s1CRh of {
                GHC.Types.I# i#_s1CRl [Occ=Once] ->
                    case uncheckedShiftL# [x#_s1CRj i#_s1CRl] of sat_s1CRm {
                      __DEFAULT -> GHC.Types.W# [sat_s1CRm];
                    };
              };
        };

Data.Bits.$fBitsWord_$cshiftL
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CRn ds1_s1CRo]
        case ds_s1CRn of {
          GHC.Types.W# x#_s1CRq [Occ=Once] ->
              case ds1_s1CRo of {
                GHC.Types.I# i#_s1CRs ->
                    case >=# [i#_s1CRs 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [x#_s1CRq i#_s1CRs] of sat_s1CRu {
                            __DEFAULT -> GHC.Types.W# [sat_s1CRu];
                          };
                      1# -> Data.Bits.$fBitsWord1;
                    };
              };
        };

Data.Bits.$fBitsWord_$cisSigned :: GHC.Types.Word -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1CRv] GHC.Types.False [];

Data.Bits.$fBitsWord_$crotate
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CRw ds1_s1CRx]
        case ds_s1CRw of wild_s1CRy {
          GHC.Types.W# x#_s1CRz ->
              case ds1_s1CRx of {
                GHC.Types.I# i#_s1CRB [Occ=Once] ->
                    case andI# [i#_s1CRB 63#] of wild2_s1CRC {
                      __DEFAULT ->
                          case -# [64# wild2_s1CRC] of sat_s1CRE {
                            __DEFAULT ->
                                case uncheckedShiftRL# [x#_s1CRz sat_s1CRE] of sat_s1CRF {
                                  __DEFAULT ->
                                      case uncheckedShiftL# [x#_s1CRz wild2_s1CRC] of sat_s1CRD {
                                        __DEFAULT ->
                                            case or# [sat_s1CRD sat_s1CRF] of sat_s1CRG {
                                              __DEFAULT -> GHC.Types.W# [sat_s1CRG];
                                            };
                                      };
                                };
                          };
                      0# -> wild_s1CRy;
                    };
              };
        };

Data.Bits.$fBitsWord_$cshift [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CRH ds1_s1CRI]
        case ds_s1CRH of {
          GHC.Types.W# x#_s1CRK [Occ=Once*] ->
              case ds1_s1CRI of {
                GHC.Types.I# i#_s1CRM ->
                    case >=# [i#_s1CRM 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1CRM] of b_s1CRO [Dmd=<S,U>] {
                            __DEFAULT ->
                                case >=# [b_s1CRO 64#] of {
                                  __DEFAULT ->
                                      case uncheckedShiftRL# [x#_s1CRK b_s1CRO] of sat_s1CRQ {
                                        __DEFAULT -> GHC.Types.W# [sat_s1CRQ];
                                      };
                                  1# -> Data.Bits.$fBitsWord1;
                                };
                          };
                      1# ->
                          case >=# [i#_s1CRM 64#] of {
                            __DEFAULT ->
                                case uncheckedShiftL# [x#_s1CRK i#_s1CRM] of sat_s1CRS {
                                  __DEFAULT -> GHC.Types.W# [sat_s1CRS];
                                };
                            1# -> Data.Bits.$fBitsWord1;
                          };
                    };
              };
        };

Data.Bits.$fBitsWord_$ccomplement
  :: GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CRT]
        case ds_s1CRT of {
          GHC.Types.W# x#_s1CRV [Occ=Once] ->
              case xor# [x#_s1CRV 18446744073709551615##] of sat_s1CRW {
                __DEFAULT -> GHC.Types.W# [sat_s1CRW];
              };
        };

Data.Bits.$fBitsWord_$cxor
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CRX ds1_s1CRY]
        case ds_s1CRX of {
          GHC.Types.W# x#_s1CS0 [Occ=Once] ->
              case ds1_s1CRY of {
                GHC.Types.W# y#_s1CS2 [Occ=Once] ->
                    case xor# [x#_s1CS0 y#_s1CS2] of sat_s1CS3 {
                      __DEFAULT -> GHC.Types.W# [sat_s1CS3];
                    };
              };
        };

Data.Bits.$fBitsWord_$c.|.
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CS4 ds1_s1CS5]
        case ds_s1CS4 of {
          GHC.Types.W# x#_s1CS7 [Occ=Once] ->
              case ds1_s1CS5 of {
                GHC.Types.W# y#_s1CS9 [Occ=Once] ->
                    case or# [x#_s1CS7 y#_s1CS9] of sat_s1CSa {
                      __DEFAULT -> GHC.Types.W# [sat_s1CSa];
                    };
              };
        };

Data.Bits.$fBitsWord_$c.&.
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CSb ds1_s1CSc]
        case ds_s1CSb of {
          GHC.Types.W# x#_s1CSe [Occ=Once] ->
              case ds1_s1CSc of {
                GHC.Types.W# y#_s1CSg [Occ=Once] ->
                    case and# [x#_s1CSe y#_s1CSg] of sat_s1CSh {
                      __DEFAULT -> GHC.Types.W# [sat_s1CSh];
                    };
              };
        };

Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros
  :: GHC.Types.Word -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CSi]
        case ds_s1CSi of {
          GHC.Types.W# x#_s1CSk [Occ=Once] ->
              case ctz# [x#_s1CSk] of sat_s1CSl {
                __DEFAULT ->
                    case word2Int# [sat_s1CSl] of sat_s1CSm {
                      __DEFAULT -> GHC.Types.I# [sat_s1CSm];
                    };
              };
        };

Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros
  :: GHC.Types.Word -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1CSn]
        case ds_s1CSn of {
          GHC.Types.W# x#_s1CSp [Occ=Once] ->
              case clz# [x#_s1CSp] of sat_s1CSq {
                __DEFAULT ->
                    case word2Int# [sat_s1CSq] of sat_s1CSr {
                      __DEFAULT -> GHC.Types.I# [sat_s1CSr];
                    };
              };
        };

Data.Bits.$fBitsWord_$cfiniteBitSize
  :: GHC.Types.Word -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s1CSs] Data.Bits.$fBitsInt1;

Data.Bits.$dmcountTrailingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S(S))LL),U(1*U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A),1*C1(U(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFiniteBits_s1CSt eta_s1CSu]
        case Data.Bits.finiteBitSize $dFiniteBits_s1CSt eta_s1CSu of {
          GHC.Types.I# ww1_s1CSw [Occ=OnceL] ->
              let {
                $dBits_s1CSx [Occ=OnceL,
                              Dmd=<L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A)>]
                  :: Data.Bits.Bits b_a1A4A
                [LclId] =
                    [$dFiniteBits_s1CSt] \u []
                        Data.Bits.$p1FiniteBits $dFiniteBits_s1CSt;
              } in 
                let-no-escape {
                  $wgo_s1CSy [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[1]]
                    :: GHC.Prim.Int# -> GHC.Types.Int
                  [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                      sat-only [eta_s1CSu
                                ww1_s1CSw
                                $dBits_s1CSx
                                $wgo_s1CSy] \r [ww2_s1CSz]
                          let {
                            wild_s1CSA [Dmd=<L,U(U)>] :: GHC.Types.Int
                            [LclId, Unf=OtherCon []] =
                                CCCS GHC.Types.I#! [ww2_s1CSz];
                          } in 
                            case >=# [ww2_s1CSz ww1_s1CSw] of {
                              __DEFAULT ->
                                  case Data.Bits.testBit $dBits_s1CSx eta_s1CSu wild_s1CSA of {
                                    GHC.Types.False ->
                                        case +# [ww2_s1CSz 1#] of sat_s1CSD {
                                          __DEFAULT -> $wgo_s1CSy sat_s1CSD;
                                        };
                                    GHC.Types.True -> wild_s1CSA;
                                  };
                              1# -> wild_s1CSA;
                            };
                } in  $wgo_s1CSy 0#;
        };

Data.Bits.$dmcountLeadingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S(S))LL),U(1*U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A),1*C1(U(U)),A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFiniteBits_s1CSE eta_s1CSF]
        case Data.Bits.finiteBitSize $dFiniteBits_s1CSE eta_s1CSF of {
          GHC.Types.I# x_s1CSH ->
              let {
                $dBits_s1CSI [Occ=OnceL,
                              Dmd=<L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A)>]
                  :: Data.Bits.Bits b_a1A4A
                [LclId] =
                    [$dFiniteBits_s1CSE] \u []
                        Data.Bits.$p1FiniteBits $dFiniteBits_s1CSE;
              } in 
                case -# [x_s1CSH 1#] of sat_s1CSX {
                  __DEFAULT ->
                      let-no-escape {
                        exit_s1CSJ [Occ=OnceL!T[1], Dmd=<L,C(U(U))>]
                          :: GHC.Prim.Int# -> GHC.Types.Int
                        [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []] =
                            sat-only [x_s1CSH] \r [ww_s1CSK]
                                case -# [x_s1CSH 1#] of sat_s1CSL {
                                  __DEFAULT ->
                                      case -# [sat_s1CSL ww_s1CSK] of sat_s1CSM {
                                        __DEFAULT -> GHC.Types.I# [sat_s1CSM];
                                      };
                                };
                      } in 
                        let-no-escape {
                          exit1_s1CSN [Occ=OnceL!T[1], Dmd=<L,C(U(U))>]
                            :: GHC.Prim.Int# -> GHC.Types.Int
                          [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []] =
                              sat-only [x_s1CSH] \r [ww_s1CSO]
                                  case -# [x_s1CSH 1#] of sat_s1CSP {
                                    __DEFAULT ->
                                        case -# [sat_s1CSP ww_s1CSO] of sat_s1CSQ {
                                          __DEFAULT -> GHC.Types.I# [sat_s1CSQ];
                                        };
                                  };
                        } in 
                          let-no-escape {
                            $wgo_s1CSR [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[1]]
                              :: GHC.Prim.Int# -> GHC.Types.Int
                            [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []] =
                                sat-only [eta_s1CSF
                                          $dBits_s1CSI
                                          exit_s1CSJ
                                          exit1_s1CSN
                                          $wgo_s1CSR] \r [ww_s1CSS]
                                    case <# [ww_s1CSS 0#] of {
                                      __DEFAULT ->
                                          let {
                                            sat_s1CSU [Occ=Once] :: GHC.Types.Int
                                            [LclId] =
                                                CCCS GHC.Types.I#! [ww_s1CSS];
                                          } in 
                                            case
                                                Data.Bits.testBit $dBits_s1CSI eta_s1CSF sat_s1CSU
                                            of
                                            { GHC.Types.False ->
                                                  case -# [ww_s1CSS 1#] of sat_s1CSW {
                                                    __DEFAULT -> $wgo_s1CSR sat_s1CSW;
                                                  };
                                              GHC.Types.True -> exit_s1CSJ ww_s1CSS;
                                            };
                                      1# -> exit1_s1CSN ww_s1CSS;
                                    };
                          } in  $wgo_s1CSR sat_s1CSX;
                };
        };

Data.Bits.$dmrotateR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CSY x_s1CSZ i_s1CT0]
        let {
          sat_s1CT4 [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [i_s1CT0] \u []
                  case i_s1CT0 of {
                    GHC.Types.I# x1_s1CT2 [Occ=Once] ->
                        case negateInt# [x1_s1CT2] of sat_s1CT3 {
                          __DEFAULT -> GHC.Types.I# [sat_s1CT3];
                        };
                  };
        } in  Data.Bits.rotate $dBits_s1CSY x_s1CSZ sat_s1CT4;

Data.Bits.$dmrotateL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CT5 x_s1CT6 i_s1CT7]
        Data.Bits.rotate $dBits_s1CT5 x_s1CT6 i_s1CT7;

Data.Bits.$dmunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLC(C(S))LLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CT8 x_s1CT9 i_s1CTa]
        Data.Bits.shiftR $dBits_s1CT8 x_s1CT9 i_s1CTa;

Data.Bits.$dmshiftR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTb x_s1CTc i_s1CTd]
        let {
          sat_s1CTh [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [i_s1CTd] \u []
                  case i_s1CTd of {
                    GHC.Types.I# x1_s1CTf [Occ=Once] ->
                        case negateInt# [x1_s1CTf] of sat_s1CTg {
                          __DEFAULT -> GHC.Types.I# [sat_s1CTg];
                        };
                  };
        } in  Data.Bits.shift $dBits_s1CTb x_s1CTc sat_s1CTh;

Data.Bits.$dmunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLC(C(S))LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTi x_s1CTj i_s1CTk]
        Data.Bits.shiftL $dBits_s1CTi x_s1CTj i_s1CTk;

Data.Bits.$dmshiftL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTl x_s1CTm i_s1CTn]
        Data.Bits.shift $dBits_s1CTl x_s1CTm i_s1CTn;

Data.Bits.$dmcomplementBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLLLLLLLLLLLLLLLLL),U(A,A,A,1*C1(C1(U)),A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTo x_s1CTp i_s1CTq]
        let {
          sat_s1CTr [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1CTo i_s1CTq] \u [] Data.Bits.bit $dBits_s1CTo i_s1CTq;
        } in  Data.Bits.xor $dBits_s1CTo x_s1CTp sat_s1CTr;

Data.Bits.$dmclearBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLLLLLLLLLLLLLLLLL),U(A,1*C1(C1(U)),A,A,1*C1(U),A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTs x_s1CTt i_s1CTu]
        let {
          sat_s1CTw [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1CTs i_s1CTu] \u []
                  let {
                    sat_s1CTv [Occ=Once] :: a_a1A4J
                    [LclId] =
                        [$dBits_s1CTs i_s1CTu] \u [] Data.Bits.bit $dBits_s1CTs i_s1CTu;
                  } in  Data.Bits.complement $dBits_s1CTs sat_s1CTv;
        } in  Data.Bits..&. $dBits_s1CTs x_s1CTt sat_s1CTw;

Data.Bits.$dmsetBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLLLLLLLLL),U(A,A,1*C1(C1(U)),A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTx x_s1CTy i_s1CTz]
        let {
          sat_s1CTA [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1CTx i_s1CTz] \u [] Data.Bits.bit $dBits_s1CTx i_s1CTz;
        } in  Data.Bits..|. $dBits_s1CTx x_s1CTy sat_s1CTA;

Data.Bits.$dmzeroBits :: forall a. Data.Bits.Bits a => a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLC(C(S))LLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,1*C1(U),A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTB]
        let {
          sat_s1CTC [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1CTB] \u []
                  Data.Bits.bit $dBits_s1CTB Data.Bits.$fBitsBool2;
        } in 
          Data.Bits.clearBit $dBits_s1CTB sat_s1CTC Data.Bits.$fBitsBool2;

Data.Bits.$fBitsBool_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cshiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$ctestBit eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$cshiftR eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cshiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$ctestBit eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$cshiftL eta_B2 eta_B1;

Data.Bits.$fBitsBool_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1CTD eta1_s1CTE]
        case eta_s1CTD of {
          GHC.Types.False ->
              case eta1_s1CTE of {
                GHC.Types.I# ds_s1CTH [Occ=Once!] ->
                    case ds_s1CTH of {
                      __DEFAULT -> GHC.Types.False [];
                      0# -> GHC.Types.True [];
                    };
              };
          GHC.Types.True ->
              case eta1_s1CTE of {
                GHC.Types.I# ds_s1CTK [Occ=Once!] ->
                    case ds_s1CTK of {
                      __DEFAULT -> GHC.Types.True [];
                      0# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsBool_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1CTM eta1_s1CTN]
        case eta_s1CTM of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True ->
              case eta1_s1CTN of {
                GHC.Types.I# ds_s1CTQ [Occ=Once!] ->
                    case ds_s1CTQ of {
                      __DEFAULT -> GHC.Types.True [];
                      0# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsBool_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1CTS eta1_s1CTT]
        case eta_s1CTS of {
          GHC.Types.False -> Data.Bits.$fBitsBool_$cbit eta1_s1CTT;
          GHC.Types.True -> GHC.Types.True [];
        };

Data.Bits.$fBitsBool_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Types.Bool
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Classes.$fEqBool
                                     GHC.Classes.&&
                                     GHC.Classes.||
                                     GHC.Classes.$fEqBool_$c/=
                                     GHC.Classes.not
                                     Data.Bits.$fBitsBool_$ctestBit
                                     Data.Bits.$fBitsBool_$crotate
                                     GHC.Types.False
                                     Data.Bits.$fBitsBool_$cbit
                                     Data.Bits.$fBitsBool_$csetBit
                                     Data.Bits.$fBitsBool_$cclearBit
                                     Data.Bits.$fBitsBool_$ccomplementBit
                                     Data.Bits.$fBitsBool_$ctestBit
                                     Data.Bits.$fBitsBool_$cbitSizeMaybe
                                     Data.Bits.$fBitsBool_$cbitSize
                                     Data.Bits.$fBitsBool_$cisSigned
                                     Data.Bits.$fBitsBool_$cshiftL
                                     Data.Bits.$fBitsBool_$cunsafeShiftL
                                     Data.Bits.$fBitsBool_$cshiftR
                                     Data.Bits.$fBitsBool_$cunsafeShiftR
                                     Data.Bits.$fBitsBool_$crotateL
                                     Data.Bits.$fBitsBool_$crotateR
                                     Data.Bits.$fBitsBool_$cpopCount];

Data.Bits.$fFiniteBitsBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.FiniteBits GHC.Types.Bool
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bits.C:FiniteBits! [Data.Bits.$fBitsBool
                                           Data.Bits.$fBitsBool_$cbitSize
                                           Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros
                                           Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros];

Data.Bits.$dmrotate
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),1*C1(C1(U)),A)><L,U><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CTV x_s1CTW i_s1CTX]
        case i_s1CTX of wild_s1CTY {
          GHC.Types.I# x1_s1CTZ ->
              case <# [x1_s1CTZ 0#] of {
                __DEFAULT ->
                    case ># [x1_s1CTZ 0#] of {
                      __DEFAULT -> x_s1CTW;
                      1# -> Data.Bits.rotateL $dBits_s1CTV x_s1CTW wild_s1CTY;
                    };
                1# ->
                    case negateInt# [x1_s1CTZ] of sat_s1CU2 {
                      __DEFAULT ->
                          let {
                            sat_s1CU3 [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [sat_s1CU2];
                          } in  Data.Bits.rotateR $dBits_s1CTV x_s1CTW sat_s1CU3;
                    };
              };
        };

Data.Bits.$dmshift
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,1*C1(C1(U)),A,A,A,A)><L,U><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CU4 x_s1CU5 i_s1CU6]
        case i_s1CU6 of wild_s1CU7 {
          GHC.Types.I# x1_s1CU8 ->
              case <# [x1_s1CU8 0#] of {
                __DEFAULT ->
                    case ># [x1_s1CU8 0#] of {
                      __DEFAULT -> x_s1CU5;
                      1# -> Data.Bits.shiftL $dBits_s1CU4 x_s1CU5 wild_s1CU7;
                    };
                1# ->
                    case negateInt# [x1_s1CU8] of sat_s1CUb {
                      __DEFAULT ->
                          let {
                            sat_s1CUc [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [sat_s1CUb];
                          } in  Data.Bits.shiftR $dBits_s1CU4 x_s1CU5 sat_s1CUc;
                    };
              };
        };

Data.Bits.bitDefault [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     GHC.Types.Int -> a
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLLLLLLLLLC(C(S))LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CUd $dNum_s1CUe i_s1CUf]
        let {
          sat_s1CUg [Occ=Once] :: a_a1AlX
          [LclId] =
              [$dNum_s1CUe] \u []
                  GHC.Num.fromInteger $dNum_s1CUe Data.Bits.$fBitsInteger3;
        } in  Data.Bits.shiftL $dBits_s1CUd sat_s1CUg i_s1CUf;

Data.Bits.testBitDefault [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     a -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<S(S(LC(C(S)))LLLLLLLLLLLLLLLLLLLLLL),U(1*U(A,1*C1(C1(U))),1*C1(C1(U)),A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1CUh $dNum_s1CUi eta_s1CUj eta1_s1CUk]
        let {
          sat_s1CUo [Occ=Once] :: a_a1AlK
          [LclId] =
              [$dNum_s1CUi] \u []
                  GHC.Num.fromInteger
                      $dNum_s1CUi Data.Bits.$fBitsInteger_$czeroBits; } in
        let {
          sat_s1CUn [Occ=Once] :: a_a1AlK
          [LclId] =
              [$dBits_s1CUh eta_s1CUj eta1_s1CUk] \u []
                  let {
                    sat_s1CUm [Occ=Once] :: a_a1AlK
                    [LclId] =
                        [$dBits_s1CUh eta1_s1CUk] \u []
                            Data.Bits.bit $dBits_s1CUh eta1_s1CUk;
                  } in  Data.Bits..&. $dBits_s1CUh eta_s1CUj sat_s1CUm;
        } in 
          case Data.Bits.$p1Bits $dBits_s1CUh of sat_s1CUl {
            __DEFAULT -> GHC.Classes./= sat_s1CUl sat_s1CUn sat_s1CUo;
          };

Data.Bits.$fBitsInt2 :: GHC.Base.Maybe GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [Data.Bits.$fBitsInt1];

Data.Bits.$fBitsWord_$cbitSizeMaybe
  :: GHC.Types.Word -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m2, Unf=OtherCon []] =
    [] \r [i_s1CUp] Data.Bits.$fBitsInt2;

Data.Bits.$fBitsWord_$cbit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [i_s1CUq]
        case i_s1CUq of {
          GHC.Types.I# i#_s1CUs ->
              case >=# [i#_s1CUs 64#] of {
                __DEFAULT ->
                    case uncheckedShiftL# [1## i#_s1CUs] of sat_s1CUu {
                      __DEFAULT -> GHC.Types.W# [sat_s1CUu];
                    };
                1# -> Data.Bits.$fBitsWord1;
              };
        };

Data.Bits.$fBitsWord_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1CUv i_s1CUw]
        case x_s1CUv of {
          GHC.Types.W# x#_s1CUy [Occ=Once] ->
              case i_s1CUw of {
                GHC.Types.I# i#_s1CUA ->
                    case >=# [i#_s1CUA 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1CUA] of sat_s1CUC {
                            __DEFAULT ->
                                case and# [x#_s1CUy sat_s1CUC] of {
                                  __DEFAULT -> GHC.Types.True [];
                                  0## -> GHC.Types.False [];
                                };
                          };
                      1# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsWord_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CUE eta1_s1CUF]
        case eta_s1CUE of wild_s1CUG {
          GHC.Types.W# x#_s1CUH ->
              case eta1_s1CUF of {
                GHC.Types.I# x_s1CUJ [Occ=Once] ->
                    case negateInt# [x_s1CUJ] of sat_s1CUK {
                      __DEFAULT ->
                          case andI# [sat_s1CUK 63#] of wild2_s1CUL {
                            __DEFAULT ->
                                case -# [64# wild2_s1CUL] of sat_s1CUN {
                                  __DEFAULT ->
                                      case uncheckedShiftRL# [x#_s1CUH sat_s1CUN] of sat_s1CUO {
                                        __DEFAULT ->
                                            case
                                                uncheckedShiftL# [x#_s1CUH wild2_s1CUL]
                                            of
                                            sat_s1CUM
                                            { __DEFAULT ->
                                                  case or# [sat_s1CUM sat_s1CUO] of sat_s1CUP {
                                                    __DEFAULT -> GHC.Types.W# [sat_s1CUP];
                                                  };
                                            };
                                      };
                                };
                            0# -> wild_s1CUG;
                          };
                    };
              };
        };

Data.Bits.$fBitsWord_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CUQ eta1_s1CUR]
        case eta_s1CUQ of wild_s1CUS {
          GHC.Types.W# x#_s1CUT [Occ=Once] ->
              case eta1_s1CUR of {
                GHC.Types.I# i#_s1CUV ->
                    case >=# [i#_s1CUV 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1CUV] of sat_s1CUX {
                            __DEFAULT ->
                                case xor# [x#_s1CUT sat_s1CUX] of sat_s1CUY {
                                  __DEFAULT -> GHC.Types.W# [sat_s1CUY];
                                };
                          };
                      1# -> wild_s1CUS;
                    };
              };
        };

Data.Bits.$fBitsWord_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CUZ eta1_s1CV0]
        case eta_s1CUZ of {
          GHC.Types.W# x#_s1CV2 [Occ=Once*] ->
              case eta1_s1CV0 of {
                GHC.Types.I# i#_s1CV4 ->
                    case >=# [i#_s1CV4 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1CV4] of sat_s1CV6 {
                            __DEFAULT ->
                                case xor# [sat_s1CV6 18446744073709551615##] of sat_s1CV7 {
                                  __DEFAULT ->
                                      case and# [x#_s1CV2 sat_s1CV7] of sat_s1CV8 {
                                        __DEFAULT -> GHC.Types.W# [sat_s1CV8];
                                      };
                                };
                          };
                      1# ->
                          case and# [x#_s1CV2 18446744073709551615##] of sat_s1CV9 {
                            __DEFAULT -> GHC.Types.W# [sat_s1CV9];
                          };
                    };
              };
        };

Data.Bits.$fBitsWord_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CVa eta1_s1CVb]
        case eta_s1CVa of wild_s1CVc {
          GHC.Types.W# x#_s1CVd [Occ=Once] ->
              case eta1_s1CVb of {
                GHC.Types.I# i#_s1CVf ->
                    case >=# [i#_s1CVf 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1CVf] of sat_s1CVh {
                            __DEFAULT ->
                                case or# [x#_s1CVd sat_s1CVh] of sat_s1CVi {
                                  __DEFAULT -> GHC.Types.W# [sat_s1CVi];
                                };
                          };
                      1# -> wild_s1CVc;
                    };
              };
        };

Data.Bits.$fBitsWord_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsWord_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Types.Word
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Classes.$fEqWord
                                     Data.Bits.$fBitsWord_$c.&.
                                     Data.Bits.$fBitsWord_$c.|.
                                     Data.Bits.$fBitsWord_$cxor
                                     Data.Bits.$fBitsWord_$ccomplement
                                     Data.Bits.$fBitsWord_$cshift
                                     Data.Bits.$fBitsWord_$crotate
                                     Data.Bits.$fBitsWord1
                                     Data.Bits.$fBitsWord_$cbit
                                     Data.Bits.$fBitsWord_$csetBit
                                     Data.Bits.$fBitsWord_$cclearBit
                                     Data.Bits.$fBitsWord_$ccomplementBit
                                     Data.Bits.$fBitsWord_$ctestBit
                                     Data.Bits.$fBitsWord_$cbitSizeMaybe
                                     Data.Bits.$fBitsWord_$cfiniteBitSize
                                     Data.Bits.$fBitsWord_$cisSigned
                                     Data.Bits.$fBitsWord_$cshiftL
                                     Data.Bits.$fBitsWord_$cunsafeShiftL
                                     Data.Bits.$fBitsWord_$cshiftR
                                     Data.Bits.$fBitsWord_$cunsafeShiftR
                                     Data.Bits.$fBitsWord_$crotateL
                                     Data.Bits.$fBitsWord_$crotateR
                                     Data.Bits.$fBitsWord_$cpopCount];

Data.Bits.$fFiniteBitsWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.FiniteBits GHC.Types.Word
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bits.C:FiniteBits! [Data.Bits.$fBitsWord
                                           Data.Bits.$fBitsWord_$cfiniteBitSize
                                           Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros
                                           Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros];

Data.Bits.$fBitsInt_$cbitSizeMaybe
  :: GHC.Types.Int -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m2, Unf=OtherCon []] =
    [] \r [i_s1CVj] Data.Bits.$fBitsInt2;

Data.Bits.$fBitsInt_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsInt_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsInt_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CVk eta1_s1CVl]
        case eta_s1CVk of {
          GHC.Types.I# x#_s1CVn ->
              case eta1_s1CVl of {
                GHC.Types.I# x_s1CVp [Occ=Once] ->
                    case negateInt# [x_s1CVp] of sat_s1CVr {
                      __DEFAULT ->
                          case andI# [sat_s1CVr 63#] of i'#_s1CVq [Dmd=<S,U>] {
                            __DEFAULT ->
                                case -# [64# i'#_s1CVq] of sat_s1CVt {
                                  __DEFAULT ->
                                      case uncheckedIShiftRL# [x#_s1CVn sat_s1CVt] of sat_s1CVu {
                                        __DEFAULT ->
                                            case
                                                uncheckedIShiftL# [x#_s1CVn i'#_s1CVq]
                                            of
                                            sat_s1CVs
                                            { __DEFAULT ->
                                                  case orI# [sat_s1CVs sat_s1CVu] of sat_s1CVv {
                                                    __DEFAULT -> GHC.Types.I# [sat_s1CVv];
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cbit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [i_s1CVw]
        case i_s1CVw of {
          GHC.Types.I# i#_s1CVy ->
              case >=# [i#_s1CVy 64#] of {
                __DEFAULT ->
                    case uncheckedIShiftL# [1# i#_s1CVy] of sat_s1CVA {
                      __DEFAULT -> GHC.Types.I# [sat_s1CVA];
                    };
                1# -> Data.Bits.$fBitsBool2;
              };
        };

Data.Bits.$fBitsInt_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1CVB i_s1CVC]
        case x_s1CVB of {
          GHC.Types.I# x#_s1CVE [Occ=Once] ->
              case i_s1CVC of {
                GHC.Types.I# i#_s1CVG ->
                    case >=# [i#_s1CVG 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1CVG] of sat_s1CVI {
                            __DEFAULT ->
                                case andI# [x#_s1CVE sat_s1CVI] of {
                                  __DEFAULT -> GHC.Types.True [];
                                  0# -> GHC.Types.False [];
                                };
                          };
                      1# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsInt_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CVK eta1_s1CVL]
        case eta_s1CVK of wild_s1CVM {
          GHC.Types.I# x#_s1CVN [Occ=Once] ->
              case eta1_s1CVL of {
                GHC.Types.I# i#_s1CVP ->
                    case >=# [i#_s1CVP 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1CVP] of sat_s1CVR {
                            __DEFAULT ->
                                case orI# [x#_s1CVN sat_s1CVR] of sat_s1CVS {
                                  __DEFAULT -> GHC.Types.I# [sat_s1CVS];
                                };
                          };
                      1# -> wild_s1CVM;
                    };
              };
        };

Data.Bits.$fBitsInt_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CVT eta1_s1CVU]
        case eta_s1CVT of {
          GHC.Types.I# x#_s1CVW [Occ=Once*] ->
              case eta1_s1CVU of {
                GHC.Types.I# i#_s1CVY ->
                    case >=# [i#_s1CVY 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1CVY] of sat_s1CW0 {
                            __DEFAULT ->
                                case notI# [sat_s1CW0] of sat_s1CW1 {
                                  __DEFAULT ->
                                      case andI# [x#_s1CVW sat_s1CW1] of sat_s1CW2 {
                                        __DEFAULT -> GHC.Types.I# [sat_s1CW2];
                                      };
                                };
                          };
                      1# ->
                          case andI# [x#_s1CVW -1#] of sat_s1CW3 {
                            __DEFAULT -> GHC.Types.I# [sat_s1CW3];
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1CW4 eta1_s1CW5]
        case eta_s1CW4 of wild_s1CW6 {
          GHC.Types.I# x#_s1CW7 [Occ=Once] ->
              case eta1_s1CW5 of {
                GHC.Types.I# i#_s1CW9 ->
                    case >=# [i#_s1CW9 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1CW9] of sat_s1CWb {
                            __DEFAULT ->
                                case xorI# [x#_s1CW7 sat_s1CWb] of sat_s1CWc {
                                  __DEFAULT -> GHC.Types.I# [sat_s1CWc];
                                };
                          };
                      1# -> wild_s1CW6;
                    };
              };
        };

Data.Bits.$fBitsInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Types.Int
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Classes.$fEqInt
                                     Data.Bits.$fBitsInt_$c.&.
                                     Data.Bits.$fBitsInt_$c.|.
                                     Data.Bits.$fBitsInt_$cxor
                                     Data.Bits.$fBitsInt_$ccomplement
                                     Data.Bits.$fBitsInt_$cshift
                                     Data.Bits.$fBitsInt_$crotate
                                     Data.Bits.$fBitsBool2
                                     Data.Bits.$fBitsInt_$cbit
                                     Data.Bits.$fBitsInt_$csetBit
                                     Data.Bits.$fBitsInt_$cclearBit
                                     Data.Bits.$fBitsInt_$ccomplementBit
                                     Data.Bits.$fBitsInt_$ctestBit
                                     Data.Bits.$fBitsInt_$cbitSizeMaybe
                                     Data.Bits.$fBitsInt_$cfiniteBitSize
                                     Data.Bits.$fBitsInt_$cisSigned
                                     Data.Bits.$fBitsInt_$cshiftL
                                     Data.Bits.$fBitsInt_$cunsafeShiftL
                                     Data.Bits.$fBitsInt_$cshiftR
                                     Data.Bits.$fBitsInt_$cunsafeShiftR
                                     Data.Bits.$fBitsInt_$crotateL
                                     Data.Bits.$fBitsInt_$crotateR
                                     Data.Bits.$fBitsInt_$cpopCount];

Data.Bits.$fFiniteBitsInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.FiniteBits GHC.Types.Int
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bits.C:FiniteBits! [Data.Bits.$fBitsInt
                                           Data.Bits.$fBitsInt_$cfiniteBitSize
                                           Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros
                                           Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros];

Data.Bits.$wpopCountDefault [InlPrag=INLINABLE[0]]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     a -> GHC.Prim.Int#
[GblId,
 Arity=3,
 Str=<S(S(C(C(S))L)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1CWd w1_s1CWe w2_s1CWf]
        let {
          lvl1_s1CWg [Occ=OnceL] :: a_s1C1X
          [LclId] =
              [w1_s1CWe] \u []
                  GHC.Num.fromInteger w1_s1CWe Data.Bits.$fBitsInteger3; } in
        let {
          lvl2_s1CWh [Occ=OnceL] :: a_s1C1X
          [LclId] =
              [w1_s1CWe] \u []
                  GHC.Num.fromInteger w1_s1CWe Data.Bits.$fBitsInteger_$czeroBits;
        } in 
          case
              Data.Bits.$p1Bits w_s1CWd
          of
          $dEq_s1CWi [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
          { __DEFAULT ->
                let-no-escape {
                  $wgo_s1CWj [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[2]]
                    :: GHC.Prim.Int# -> a_s1C1X -> GHC.Prim.Int#
                  [LclId[JoinId(2)], Arity=2, Str=<S,U><L,U>, Unf=OtherCon []] =
                      sat-only [w_s1CWd
                                w1_s1CWe
                                lvl1_s1CWg
                                lvl2_s1CWh
                                $dEq_s1CWi
                                $wgo_s1CWj] \r [ww_s1CWk w3_s1CWl]
                          case GHC.Classes.== $dEq_s1CWi w3_s1CWl lvl2_s1CWh of {
                            GHC.Types.False ->
                                let {
                                  sat_s1CWp [Occ=Once] :: a_s1C1X
                                  [LclId] =
                                      [w_s1CWd w1_s1CWe lvl1_s1CWg w3_s1CWl] \u []
                                          let {
                                            sat_s1CWo [Occ=Once] :: a_s1C1X
                                            [LclId] =
                                                [w1_s1CWe lvl1_s1CWg w3_s1CWl] \u []
                                                    GHC.Num.- w1_s1CWe w3_s1CWl lvl1_s1CWg;
                                          } in  Data.Bits..&. w_s1CWd w3_s1CWl sat_s1CWo;
                                } in 
                                  case +# [ww_s1CWk 1#] of sat_s1CWn {
                                    __DEFAULT -> $wgo_s1CWj sat_s1CWn sat_s1CWp;
                                  };
                            GHC.Types.True -> ww_s1CWk;
                          };
                } in  $wgo_s1CWj 0# w2_s1CWf;
          };

Data.Bits.popCountDefault [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<S(S(C(C(S))L)LLLLLLLLLLLLLLLLLLLLLL),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,C(U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1CWq w1_s1CWr w2_s1CWs]
        case
            Data.Bits.$wpopCountDefault w_s1CWq w1_s1CWr w2_s1CWs
        of
        ww_s1CWt
        { __DEFAULT -> GHC.Types.I# [ww_s1CWt];
        };

Data.Bits.$fBitsInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Integer.Type.Integer
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Integer.Type.$fEqInteger
                                     GHC.Integer.Type.andInteger
                                     GHC.Integer.Type.orInteger
                                     GHC.Integer.Type.xorInteger
                                     GHC.Integer.Type.complementInteger
                                     Data.Bits.$fBitsInteger_$cshift
                                     Data.Bits.$fBitsInteger_$cshift
                                     Data.Bits.$fBitsInteger_$czeroBits
                                     Data.Bits.$fBitsInteger_$cbit
                                     Data.Bits.$fBitsInteger_$csetBit
                                     Data.Bits.$fBitsInteger_$cclearBit
                                     Data.Bits.$fBitsInteger_$ccomplementBit
                                     Data.Bits.$fBitsInteger_$ctestBit
                                     Data.Bits.$fBitsInteger_$cbitSizeMaybe
                                     Data.Bits.$fBitsInteger_$cbitSize
                                     Data.Bits.$fBitsInteger_$cisSigned
                                     Data.Bits.$fBitsInteger_$cshiftL
                                     Data.Bits.$fBitsInteger_$cunsafeShiftL
                                     Data.Bits.$fBitsInteger_$cshiftR
                                     Data.Bits.$fBitsInteger_$cunsafeShiftR
                                     Data.Bits.$fBitsInteger_$crotateL
                                     Data.Bits.$fBitsInteger_$crotateR
                                     Data.Bits.$fBitsInteger_$cpopCount];
Data.Bits.$fBitsInteger_$cpopCount [Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer -> GHC.Types.Int
[GblId, Arity=1, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_s1CWu]
        case
            Data.Bits.$wpopCountDefault
                Data.Bits.$fBitsInteger GHC.Num.$fNumInteger w_s1CWu
        of
        ww_s1CWv
        { __DEFAULT -> GHC.Types.I# [ww_s1CWv];
        };

Data.Bits.toIntegralSized [InlPrag=INLINABLE]
  :: forall a b.
     (GHC.Real.Integral a, GHC.Real.Integral b, Data.Bits.Bits a,
      Data.Bits.Bits b) =>
     a -> GHC.Base.Maybe b
[GblId,
 Arity=5,
 Str=<L,U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U)),1*U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,1*C1(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(LLLLLLLLLLLLLC(S)LLLLLLLLL),U(A,A,A,A,A,A,A,A,C(U),A,A,A,A,1*C1(U),A,1*C1(U),A,A,A,A,A,A,A)><S(LLLLLLLLLLLLLC(S)LC(S)LLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,1*C1(U),A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1CWw
           $dIntegral1_s1CWx
           $dBits_s1CWy
           $dBits1_s1CWz
           eta_s1CWA]
        case
            Data.Bits.bitSizeMaybe $dBits_s1CWy eta_s1CWA
        of
        xWidth_s1CWB [Dmd=<S,U>]
        { __DEFAULT ->
              let {
                y_s1CWC :: b_a1AhY
                [LclId] =
                    [$dIntegral_s1CWw $dIntegral1_s1CWx eta_s1CWA] \u []
                        let {
                          sat_s1CWF [Occ=Once] :: GHC.Integer.Type.Integer
                          [LclId] =
                              [$dIntegral_s1CWw eta_s1CWA] \u []
                                  GHC.Real.toInteger $dIntegral_s1CWw eta_s1CWA;
                        } in 
                          case GHC.Real.$p1Integral $dIntegral1_s1CWx of sat_s1CWD {
                            __DEFAULT ->
                                case GHC.Real.$p1Real sat_s1CWD of sat_s1CWE {
                                  __DEFAULT -> GHC.Num.fromInteger sat_s1CWE sat_s1CWF;
                                };
                          };
              } in 
                case
                    Data.Bits.isSigned $dBits1_s1CWz y_s1CWC
                of
                ySigned_s1CWG [Dmd=<S,U>]
                { __DEFAULT ->
                      case
                          Data.Bits.bitSizeMaybe $dBits1_s1CWz y_s1CWC
                      of
                      yWidth_s1CWH [Dmd=<S,U>]
                      { __DEFAULT ->
                            let {
                              xSigned_s1CWI :: GHC.Types.Bool
                              [LclId] =
                                  [$dBits_s1CWy eta_s1CWA] \u []
                                      Data.Bits.isSigned $dBits_s1CWy eta_s1CWA; } in
                            let {
                              $dReal_s1CWJ [Dmd=<L,U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U)),1*U(A,A,A,C(C1(U)),A,A,A,A),A)>]
                                :: GHC.Real.Real a_a1AhX
                              [LclId] =
                                  [$dIntegral_s1CWw] \u []
                                      GHC.Real.$p1Integral $dIntegral_s1CWw; } in
                            let {
                              $dNum_s1CWK [Dmd=<L,U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U))>]
                                :: GHC.Num.Num a_a1AhX
                              [LclId] =
                                  [$dReal_s1CWJ] \u [] GHC.Real.$p1Real $dReal_s1CWJ; } in
                            let {
                              $dOrd_s1CWL [Dmd=<L,U(A,A,A,C(C1(U)),A,A,A,A)>]
                                :: GHC.Classes.Ord a_a1AhX
                              [LclId] =
                                  [$dReal_s1CWJ] \u [] GHC.Real.$p2Real $dReal_s1CWJ;
                            } in 
                              let-no-escape {
                                $j_s1CWM [Dmd=<L,1*U>] :: GHC.Base.Maybe b_a1AhY
                                [LclId[JoinId(0)], Unf=OtherCon []] =
                                    [$dBits_s1CWy
                                     eta_s1CWA
                                     xWidth_s1CWB
                                     y_s1CWC
                                     ySigned_s1CWG
                                     yWidth_s1CWH
                                     xSigned_s1CWI
                                     $dNum_s1CWK
                                     $dOrd_s1CWL] \r []
                                        let-no-escape {
                                          fail_s1CWN [Dmd=<L,1*C1(U)>]
                                            :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                              sat-only [$dBits_s1CWy
                                                        eta_s1CWA
                                                        xWidth_s1CWB
                                                        y_s1CWC
                                                        ySigned_s1CWG
                                                        yWidth_s1CWH
                                                        xSigned_s1CWI
                                                        $dNum_s1CWK
                                                        $dOrd_s1CWL] \r [void_0E]
                                                  let-no-escape {
                                                    fail1_s1CWP [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                                      :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                                    [LclId[JoinId(1)],
                                                     Arity=1,
                                                     Str=<L,A>,
                                                     Unf=OtherCon []] =
                                                        sat-only [$dBits_s1CWy
                                                                  eta_s1CWA
                                                                  xWidth_s1CWB
                                                                  y_s1CWC
                                                                  ySigned_s1CWG
                                                                  yWidth_s1CWH
                                                                  xSigned_s1CWI
                                                                  $dNum_s1CWK
                                                                  $dOrd_s1CWL] \r [void_0E]
                                                            let-no-escape {
                                                              fail2_s1CWR [Occ=Once*!T[1],
                                                                           Dmd=<L,1*C1(U)>]
                                                                :: GHC.Prim.Void#
                                                                   -> GHC.Base.Maybe b_a1AhY
                                                              [LclId[JoinId(1)],
                                                               Arity=1,
                                                               Str=<L,A>,
                                                               Unf=OtherCon []] =
                                                                  sat-only [$dBits_s1CWy
                                                                            eta_s1CWA
                                                                            xWidth_s1CWB
                                                                            y_s1CWC
                                                                            ySigned_s1CWG
                                                                            yWidth_s1CWH
                                                                            xSigned_s1CWI
                                                                            $dNum_s1CWK
                                                                            $dOrd_s1CWL] \r [void_0E]
                                                                      let-no-escape {
                                                                        $j1_s1CWT [Dmd=<L,1*U>]
                                                                          :: GHC.Base.Maybe b_a1AhY
                                                                        [LclId[JoinId(0)],
                                                                         Unf=OtherCon []] =
                                                                            [$dBits_s1CWy
                                                                             eta_s1CWA
                                                                             xWidth_s1CWB
                                                                             y_s1CWC
                                                                             ySigned_s1CWG
                                                                             yWidth_s1CWH
                                                                             xSigned_s1CWI
                                                                             $dNum_s1CWK
                                                                             $dOrd_s1CWL] \r []
                                                                                let-no-escape {
                                                                                  fail3_s1CWU [Occ=Once*!T[1],
                                                                                               Dmd=<L,1*C1(U)>]
                                                                                    :: GHC.Prim.Void#
                                                                                       -> GHC.Base.Maybe
                                                                                            b_a1AhY
                                                                                  [LclId[JoinId(1)],
                                                                                   Arity=1,
                                                                                   Str=<L,A>,
                                                                                   Unf=OtherCon []] =
                                                                                      sat-only [$dBits_s1CWy
                                                                                                eta_s1CWA
                                                                                                y_s1CWC
                                                                                                ySigned_s1CWG
                                                                                                yWidth_s1CWH
                                                                                                $dNum_s1CWK
                                                                                                $dOrd_s1CWL] \r [void_0E]
                                                                                          case
                                                                                              yWidth_s1CWH
                                                                                          of
                                                                                          { GHC.Base.Nothing ->
                                                                                                GHC.Base.Just [y_s1CWC];
                                                                                            GHC.Base.Just yW_s1CWX [Occ=Once*] ->
                                                                                                case
                                                                                                    ySigned_s1CWG
                                                                                                of
                                                                                                { GHC.Types.False ->
                                                                                                      let {
                                                                                                        sat_s1CX1 [Occ=Once]
                                                                                                          :: a_a1AhX
                                                                                                        [LclId] =
                                                                                                            [$dBits_s1CWy
                                                                                                             $dNum_s1CWK
                                                                                                             yW_s1CWX] \u []
                                                                                                                let {
                                                                                                                  sat_s1CX0 [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dNum_s1CWK] \u []
                                                                                                                          GHC.Num.fromInteger
                                                                                                                              $dNum_s1CWK
                                                                                                                              Data.Bits.$fBitsInteger3; } in
                                                                                                                let {
                                                                                                                  sat_s1CWZ [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dBits_s1CWy
                                                                                                                       yW_s1CWX] \u []
                                                                                                                          Data.Bits.bit
                                                                                                                              $dBits_s1CWy
                                                                                                                              yW_s1CWX;
                                                                                                                } in 
                                                                                                                  GHC.Num.-
                                                                                                                      $dNum_s1CWK
                                                                                                                      sat_s1CWZ
                                                                                                                      sat_s1CX0;
                                                                                                      } in 
                                                                                                        case
                                                                                                            GHC.Classes.<=
                                                                                                                $dOrd_s1CWL
                                                                                                                eta_s1CWA
                                                                                                                sat_s1CX1
                                                                                                        of
                                                                                                        { GHC.Types.False ->
                                                                                                              GHC.Base.Nothing [];
                                                                                                          GHC.Types.True ->
                                                                                                              GHC.Base.Just [y_s1CWC];
                                                                                                        };
                                                                                                  GHC.Types.True ->
                                                                                                      let {
                                                                                                        sat_s1CX9 [Occ=Once]
                                                                                                          :: a_a1AhX
                                                                                                        [LclId] =
                                                                                                            [$dBits_s1CWy
                                                                                                             $dNum_s1CWK
                                                                                                             yW_s1CWX] \u []
                                                                                                                let {
                                                                                                                  sat_s1CX8 [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dNum_s1CWK] \u []
                                                                                                                          GHC.Num.fromInteger
                                                                                                                              $dNum_s1CWK
                                                                                                                              Data.Bits.$fBitsInteger3; } in
                                                                                                                let {
                                                                                                                  sat_s1CX7 [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dBits_s1CWy
                                                                                                                       yW_s1CWX] \u []
                                                                                                                          let {
                                                                                                                            sat_s1CX6 [Occ=Once]
                                                                                                                              :: GHC.Types.Int
                                                                                                                            [LclId] =
                                                                                                                                [yW_s1CWX] \u []
                                                                                                                                    case
                                                                                                                                        yW_s1CWX
                                                                                                                                    of
                                                                                                                                    { GHC.Types.I# x_s1CX4 [Occ=Once] ->
                                                                                                                                          case
                                                                                                                                              -# [x_s1CX4
                                                                                                                                                  1#]
                                                                                                                                          of
                                                                                                                                          sat_s1CX5
                                                                                                                                          { __DEFAULT ->
                                                                                                                                                GHC.Types.I# [sat_s1CX5];
                                                                                                                                          };
                                                                                                                                    };
                                                                                                                          } in 
                                                                                                                            Data.Bits.bit
                                                                                                                                $dBits_s1CWy
                                                                                                                                sat_s1CX6;
                                                                                                                } in 
                                                                                                                  GHC.Num.-
                                                                                                                      $dNum_s1CWK
                                                                                                                      sat_s1CX7
                                                                                                                      sat_s1CX8;
                                                                                                      } in 
                                                                                                        case
                                                                                                            GHC.Classes.<=
                                                                                                                $dOrd_s1CWL
                                                                                                                eta_s1CWA
                                                                                                                sat_s1CX9
                                                                                                        of
                                                                                                        { GHC.Types.False ->
                                                                                                              GHC.Base.Nothing [];
                                                                                                          GHC.Types.True ->
                                                                                                              GHC.Base.Just [y_s1CWC];
                                                                                                        };
                                                                                                };
                                                                                          };
                                                                                } in 
                                                                                  case
                                                                                      xSigned_s1CWI
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        fail3_s1CWU
                                                                                            GHC.Prim.void#;
                                                                                    GHC.Types.True ->
                                                                                        case
                                                                                            ySigned_s1CWG
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              case
                                                                                                  xWidth_s1CWB
                                                                                              of
                                                                                              { GHC.Base.Nothing ->
                                                                                                    fail3_s1CWU
                                                                                                        GHC.Prim.void#;
                                                                                                GHC.Base.Just xW_s1CXe [Occ=Once!] ->
                                                                                                    case
                                                                                                        yWidth_s1CWH
                                                                                                    of
                                                                                                    { GHC.Base.Nothing ->
                                                                                                          fail3_s1CWU
                                                                                                              GHC.Prim.void#;
                                                                                                      GHC.Base.Just yW_s1CXg [Occ=Once!] ->
                                                                                                          case
                                                                                                              yW_s1CXg
                                                                                                          of
                                                                                                          { GHC.Types.I# x_s1CXi [Occ=Once] ->
                                                                                                                case
                                                                                                                    xW_s1CXe
                                                                                                                of
                                                                                                                { GHC.Types.I# x1_s1CXk [Occ=Once] ->
                                                                                                                      case
                                                                                                                          +# [x_s1CXi
                                                                                                                              1#]
                                                                                                                      of
                                                                                                                      sat_s1CXl
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                <=# [x1_s1CXk
                                                                                                                                     sat_s1CXl]
                                                                                                                            of
                                                                                                                            { __DEFAULT ->
                                                                                                                                  fail3_s1CWU
                                                                                                                                      GHC.Prim.void#;
                                                                                                                              1# ->
                                                                                                                                  GHC.Base.Just [y_s1CWC];
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                          GHC.Types.True ->
                                                                                              fail3_s1CWU
                                                                                                  GHC.Prim.void#;
                                                                                        };
                                                                                  };
                                                                      } in 
                                                                        let-no-escape {
                                                                          fail3_s1CXn [Dmd=<L,1*C1(U)>]
                                                                            :: GHC.Prim.Void#
                                                                               -> GHC.Base.Maybe
                                                                                    b_a1AhY
                                                                          [LclId[JoinId(1)],
                                                                           Arity=1,
                                                                           Str=<L,A>,
                                                                           Unf=OtherCon []] =
                                                                              sat-only [xWidth_s1CWB
                                                                                        y_s1CWC
                                                                                        ySigned_s1CWG
                                                                                        yWidth_s1CWH
                                                                                        xSigned_s1CWI
                                                                                        $j1_s1CWT] \r [void_0E]
                                                                                  case
                                                                                      xSigned_s1CWI
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        case
                                                                                            ySigned_s1CWG
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              $j1_s1CWT;
                                                                                          GHC.Types.True ->
                                                                                              case
                                                                                                  xWidth_s1CWB
                                                                                              of
                                                                                              { GHC.Base.Nothing ->
                                                                                                    $j1_s1CWT;
                                                                                                GHC.Base.Just xW_s1CXs [Occ=Once!] ->
                                                                                                    case
                                                                                                        yWidth_s1CWH
                                                                                                    of
                                                                                                    { GHC.Base.Nothing ->
                                                                                                          $j1_s1CWT;
                                                                                                      GHC.Base.Just yW_s1CXu [Occ=Once!] ->
                                                                                                          case
                                                                                                              xW_s1CXs
                                                                                                          of
                                                                                                          { GHC.Types.I# x_s1CXw [Occ=Once] ->
                                                                                                                case
                                                                                                                    yW_s1CXu
                                                                                                                of
                                                                                                                { GHC.Types.I# y1_s1CXy [Occ=Once] ->
                                                                                                                      case
                                                                                                                          <# [x_s1CXw
                                                                                                                              y1_s1CXy]
                                                                                                                      of
                                                                                                                      { __DEFAULT ->
                                                                                                                            $j1_s1CWT;
                                                                                                                        1# ->
                                                                                                                            GHC.Base.Just [y_s1CWC];
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                    GHC.Types.True ->
                                                                                        $j1_s1CWT;
                                                                                  };
                                                                        } in 
                                                                          let-no-escape {
                                                                            $j2_s1CXA [Occ=Once*T[0],
                                                                                       Dmd=<L,1*U>]
                                                                              :: GHC.Base.Maybe
                                                                                   b_a1AhY
                                                                            [LclId[JoinId(0)],
                                                                             Unf=OtherCon []] =
                                                                                [xWidth_s1CWB
                                                                                 y_s1CWC
                                                                                 yWidth_s1CWH
                                                                                 $j1_s1CWT
                                                                                 fail3_s1CXn] \r []
                                                                                    case
                                                                                        xWidth_s1CWB
                                                                                    of
                                                                                    { GHC.Base.Nothing ->
                                                                                          fail3_s1CXn
                                                                                              GHC.Prim.void#;
                                                                                      GHC.Base.Just xW_s1CXC [Occ=Once!] ->
                                                                                          case
                                                                                              yWidth_s1CWH
                                                                                          of
                                                                                          { GHC.Base.Nothing ->
                                                                                                fail3_s1CXn
                                                                                                    GHC.Prim.void#;
                                                                                            GHC.Base.Just yW_s1CXE [Occ=Once!] ->
                                                                                                case
                                                                                                    xW_s1CXC
                                                                                                of
                                                                                                { GHC.Types.I# x_s1CXG [Occ=Once] ->
                                                                                                      case
                                                                                                          yW_s1CXE
                                                                                                      of
                                                                                                      { GHC.Types.I# y1_s1CXI [Occ=Once] ->
                                                                                                            case
                                                                                                                <=# [x_s1CXG
                                                                                                                     y1_s1CXI]
                                                                                                            of
                                                                                                            { __DEFAULT ->
                                                                                                                  $j1_s1CWT;
                                                                                                              1# ->
                                                                                                                  GHC.Base.Just [y_s1CWC];
                                                                                                            };
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                          } in 
                                                                            case xSigned_s1CWI of {
                                                                              GHC.Types.False ->
                                                                                  case
                                                                                      ySigned_s1CWG
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        $j2_s1CXA;
                                                                                    GHC.Types.True ->
                                                                                        fail3_s1CXn
                                                                                            GHC.Prim.void#;
                                                                                  };
                                                                              GHC.Types.True ->
                                                                                  case
                                                                                      ySigned_s1CWG
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        fail3_s1CXn
                                                                                            GHC.Prim.void#;
                                                                                    GHC.Types.True ->
                                                                                        $j2_s1CXA;
                                                                                  };
                                                                            };
                                                            } in 
                                                              case xSigned_s1CWI of {
                                                                GHC.Types.False ->
                                                                    case ySigned_s1CWG of {
                                                                      GHC.Types.False ->
                                                                          case yWidth_s1CWH of {
                                                                            GHC.Base.Nothing ->
                                                                                GHC.Base.Just [y_s1CWC];
                                                                            GHC.Base.Just _ [Occ=Dead] ->
                                                                                fail2_s1CWR
                                                                                    GHC.Prim.void#;
                                                                          };
                                                                      GHC.Types.True ->
                                                                          fail2_s1CWR
                                                                              GHC.Prim.void#;
                                                                    };
                                                                GHC.Types.True ->
                                                                    fail2_s1CWR GHC.Prim.void#;
                                                              };
                                                  } in 
                                                    case ySigned_s1CWG of {
                                                      GHC.Types.False -> fail1_s1CWP GHC.Prim.void#;
                                                      GHC.Types.True ->
                                                          case yWidth_s1CWH of {
                                                            GHC.Base.Nothing ->
                                                                GHC.Base.Just [y_s1CWC];
                                                            GHC.Base.Just _ [Occ=Dead] ->
                                                                fail1_s1CWP GHC.Prim.void#;
                                                          };
                                                    };
                                        } in 
                                          let-no-escape {
                                            $j1_s1CXU [Occ=Once*T[0], Dmd=<L,1*U>]
                                              :: GHC.Base.Maybe b_a1AhY
                                            [LclId[JoinId(0)], Unf=OtherCon []] =
                                                [y_s1CWC
                                                 ySigned_s1CWG
                                                 xSigned_s1CWI
                                                 fail_s1CWN] \r []
                                                    case xSigned_s1CWI of {
                                                      GHC.Types.False ->
                                                          case ySigned_s1CWG of {
                                                            GHC.Types.False ->
                                                                GHC.Base.Just [y_s1CWC];
                                                            GHC.Types.True ->
                                                                fail_s1CWN GHC.Prim.void#;
                                                          };
                                                      GHC.Types.True ->
                                                          case ySigned_s1CWG of {
                                                            GHC.Types.False ->
                                                                fail_s1CWN GHC.Prim.void#;
                                                            GHC.Types.True ->
                                                                GHC.Base.Just [y_s1CWC];
                                                          };
                                                    };
                                          } in 
                                            case xWidth_s1CWB of {
                                              GHC.Base.Nothing ->
                                                  case yWidth_s1CWH of {
                                                    GHC.Base.Nothing -> $j1_s1CXU;
                                                    GHC.Base.Just _ [Occ=Dead] ->
                                                        fail_s1CWN GHC.Prim.void#;
                                                  };
                                              GHC.Base.Just a1_s1CY1 [Occ=Once!] ->
                                                  case yWidth_s1CWH of {
                                                    GHC.Base.Nothing -> fail_s1CWN GHC.Prim.void#;
                                                    GHC.Base.Just b1_s1CY3 [Occ=Once!] ->
                                                        case a1_s1CY1 of {
                                                          GHC.Types.I# x_s1CY5 [Occ=Once] ->
                                                              case b1_s1CY3 of {
                                                                GHC.Types.I# y1_s1CY7 [Occ=Once] ->
                                                                    case ==# [x_s1CY5 y1_s1CY7] of {
                                                                      __DEFAULT ->
                                                                          fail_s1CWN GHC.Prim.void#;
                                                                      1# -> $j1_s1CXU;
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                              } in 
                                let-no-escape {
                                  fail_s1CY9 [Dmd=<L,1*C1(U)>]
                                    :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                  [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                      sat-only [$dBits_s1CWy
                                                eta_s1CWA
                                                xWidth_s1CWB
                                                ySigned_s1CWG
                                                yWidth_s1CWH
                                                xSigned_s1CWI
                                                $dNum_s1CWK
                                                $dOrd_s1CWL
                                                $j_s1CWM] \r [void_0E]
                                          let-no-escape {
                                            fail1_s1CYb [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                              :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                            [LclId[JoinId(1)],
                                             Arity=1,
                                             Str=<L,A>,
                                             Unf=OtherCon []] =
                                                sat-only [$dBits_s1CWy
                                                          eta_s1CWA
                                                          xWidth_s1CWB
                                                          ySigned_s1CWG
                                                          yWidth_s1CWH
                                                          xSigned_s1CWI
                                                          $dNum_s1CWK
                                                          $dOrd_s1CWL
                                                          $j_s1CWM] \r [void_0E]
                                                    let-no-escape {
                                                      fail2_s1CYd [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                                        :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                                      [LclId[JoinId(1)],
                                                       Arity=1,
                                                       Str=<L,A>,
                                                       Unf=OtherCon []] =
                                                          sat-only [$dBits_s1CWy
                                                                    eta_s1CWA
                                                                    xWidth_s1CWB
                                                                    ySigned_s1CWG
                                                                    yWidth_s1CWH
                                                                    xSigned_s1CWI
                                                                    $dNum_s1CWK
                                                                    $dOrd_s1CWL
                                                                    $j_s1CWM] \r [void_0E]
                                                              let-no-escape {
                                                                $j1_s1CYf [Dmd=<L,1*U>]
                                                                  :: GHC.Base.Maybe b_a1AhY
                                                                [LclId[JoinId(0)],
                                                                 Unf=OtherCon []] =
                                                                    [$dBits_s1CWy
                                                                     eta_s1CWA
                                                                     ySigned_s1CWG
                                                                     yWidth_s1CWH
                                                                     xSigned_s1CWI
                                                                     $dNum_s1CWK
                                                                     $dOrd_s1CWL
                                                                     $j_s1CWM] \r []
                                                                        let-no-escape {
                                                                          fail3_s1CYg [Occ=Once*!T[1],
                                                                                       Dmd=<L,1*C1(U)>]
                                                                            :: GHC.Prim.Void#
                                                                               -> GHC.Base.Maybe
                                                                                    b_a1AhY
                                                                          [LclId[JoinId(1)],
                                                                           Arity=1,
                                                                           Str=<L,A>,
                                                                           Unf=OtherCon []] =
                                                                              sat-only [$dBits_s1CWy
                                                                                        eta_s1CWA
                                                                                        ySigned_s1CWG
                                                                                        yWidth_s1CWH
                                                                                        xSigned_s1CWI
                                                                                        $dNum_s1CWK
                                                                                        $dOrd_s1CWL
                                                                                        $j_s1CWM] \r [void_0E]
                                                                                  case
                                                                                      xSigned_s1CWI
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        $j_s1CWM;
                                                                                    GHC.Types.True ->
                                                                                        case
                                                                                            ySigned_s1CWG
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              $j_s1CWM;
                                                                                          GHC.Types.True ->
                                                                                              case
                                                                                                  yWidth_s1CWH
                                                                                              of
                                                                                              { GHC.Base.Nothing ->
                                                                                                    $j_s1CWM;
                                                                                                GHC.Base.Just yW_s1CYl [Occ=Once!] ->
                                                                                                    let {
                                                                                                      sat_s1CYr [Occ=Once]
                                                                                                        :: a_a1AhX
                                                                                                      [LclId] =
                                                                                                          [$dBits_s1CWy
                                                                                                           $dNum_s1CWK
                                                                                                           yW_s1CYl] \u []
                                                                                                              let {
                                                                                                                sat_s1CYq [Occ=Once]
                                                                                                                  :: a_a1AhX
                                                                                                                [LclId] =
                                                                                                                    [$dBits_s1CWy
                                                                                                                     yW_s1CYl] \u []
                                                                                                                        let {
                                                                                                                          sat_s1CYp [Occ=Once]
                                                                                                                            :: GHC.Types.Int
                                                                                                                          [LclId] =
                                                                                                                              [yW_s1CYl] \u []
                                                                                                                                  case
                                                                                                                                      yW_s1CYl
                                                                                                                                  of
                                                                                                                                  { GHC.Types.I# x_s1CYn [Occ=Once] ->
                                                                                                                                        case
                                                                                                                                            -# [x_s1CYn
                                                                                                                                                1#]
                                                                                                                                        of
                                                                                                                                        sat_s1CYo
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              GHC.Types.I# [sat_s1CYo];
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                        } in 
                                                                                                                          Data.Bits.bit
                                                                                                                              $dBits_s1CWy
                                                                                                                              sat_s1CYp;
                                                                                                              } in 
                                                                                                                GHC.Num.negate
                                                                                                                    $dNum_s1CWK
                                                                                                                    sat_s1CYq;
                                                                                                    } in 
                                                                                                      case
                                                                                                          GHC.Classes.<=
                                                                                                              $dOrd_s1CWL
                                                                                                              sat_s1CYr
                                                                                                              eta_s1CWA
                                                                                                      of
                                                                                                      { GHC.Types.False ->
                                                                                                            GHC.Base.Nothing [];
                                                                                                        GHC.Types.True ->
                                                                                                            $j_s1CWM;
                                                                                                      };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                        } in 
                                                                          case xSigned_s1CWI of {
                                                                            GHC.Types.False ->
                                                                                fail3_s1CYg
                                                                                    GHC.Prim.void#;
                                                                            GHC.Types.True ->
                                                                                case
                                                                                    ySigned_s1CWG
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      let {
                                                                                        sat_s1CYv [Occ=Once]
                                                                                          :: a_a1AhX
                                                                                        [LclId] =
                                                                                            [$dNum_s1CWK] \u []
                                                                                                GHC.Num.fromInteger
                                                                                                    $dNum_s1CWK
                                                                                                    Data.Bits.$fBitsInteger_$czeroBits;
                                                                                      } in 
                                                                                        case
                                                                                            GHC.Classes.<=
                                                                                                $dOrd_s1CWL
                                                                                                sat_s1CYv
                                                                                                eta_s1CWA
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              GHC.Base.Nothing [];
                                                                                          GHC.Types.True ->
                                                                                              $j_s1CWM;
                                                                                        };
                                                                                  GHC.Types.True ->
                                                                                      fail3_s1CYg
                                                                                          GHC.Prim.void#;
                                                                                };
                                                                          };
                                                              } in 
                                                                let-no-escape {
                                                                  fail3_s1CYx [Dmd=<L,1*C1(U)>]
                                                                    :: GHC.Prim.Void#
                                                                       -> GHC.Base.Maybe b_a1AhY
                                                                  [LclId[JoinId(1)],
                                                                   Arity=1,
                                                                   Str=<L,A>,
                                                                   Unf=OtherCon []] =
                                                                      sat-only [xWidth_s1CWB
                                                                                ySigned_s1CWG
                                                                                yWidth_s1CWH
                                                                                xSigned_s1CWI
                                                                                $j_s1CWM
                                                                                $j1_s1CYf] \r [void_0E]
                                                                          case xSigned_s1CWI of {
                                                                            GHC.Types.False ->
                                                                                case
                                                                                    ySigned_s1CWG
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      $j1_s1CYf;
                                                                                  GHC.Types.True ->
                                                                                      case
                                                                                          xWidth_s1CWB
                                                                                      of
                                                                                      { GHC.Base.Nothing ->
                                                                                            $j1_s1CYf;
                                                                                        GHC.Base.Just xW_s1CYC [Occ=Once!] ->
                                                                                            case
                                                                                                yWidth_s1CWH
                                                                                            of
                                                                                            { GHC.Base.Nothing ->
                                                                                                  $j1_s1CYf;
                                                                                              GHC.Base.Just yW_s1CYE [Occ=Once!] ->
                                                                                                  case
                                                                                                      xW_s1CYC
                                                                                                  of
                                                                                                  { GHC.Types.I# x_s1CYG [Occ=Once] ->
                                                                                                        case
                                                                                                            yW_s1CYE
                                                                                                        of
                                                                                                        { GHC.Types.I# y1_s1CYI [Occ=Once] ->
                                                                                                              case
                                                                                                                  <# [x_s1CYG
                                                                                                                      y1_s1CYI]
                                                                                                              of
                                                                                                              { __DEFAULT ->
                                                                                                                    $j1_s1CYf;
                                                                                                                1# ->
                                                                                                                    $j_s1CWM;
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                            GHC.Types.True ->
                                                                                $j1_s1CYf;
                                                                          };
                                                                } in 
                                                                  let-no-escape {
                                                                    $j2_s1CYK [Occ=Once*T[0],
                                                                               Dmd=<L,1*U>]
                                                                      :: GHC.Base.Maybe b_a1AhY
                                                                    [LclId[JoinId(0)],
                                                                     Unf=OtherCon []] =
                                                                        [xWidth_s1CWB
                                                                         yWidth_s1CWH
                                                                         $j_s1CWM
                                                                         $j1_s1CYf
                                                                         fail3_s1CYx] \r []
                                                                            case xWidth_s1CWB of {
                                                                              GHC.Base.Nothing ->
                                                                                  fail3_s1CYx
                                                                                      GHC.Prim.void#;
                                                                              GHC.Base.Just xW_s1CYM [Occ=Once!] ->
                                                                                  case
                                                                                      yWidth_s1CWH
                                                                                  of
                                                                                  { GHC.Base.Nothing ->
                                                                                        fail3_s1CYx
                                                                                            GHC.Prim.void#;
                                                                                    GHC.Base.Just yW_s1CYO [Occ=Once!] ->
                                                                                        case
                                                                                            xW_s1CYM
                                                                                        of
                                                                                        { GHC.Types.I# x_s1CYQ [Occ=Once] ->
                                                                                              case
                                                                                                  yW_s1CYO
                                                                                              of
                                                                                              { GHC.Types.I# y1_s1CYS [Occ=Once] ->
                                                                                                    case
                                                                                                        <=# [x_s1CYQ
                                                                                                             y1_s1CYS]
                                                                                                    of
                                                                                                    { __DEFAULT ->
                                                                                                          $j1_s1CYf;
                                                                                                      1# ->
                                                                                                          $j_s1CWM;
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                  } in 
                                                                    case xSigned_s1CWI of {
                                                                      GHC.Types.False ->
                                                                          case ySigned_s1CWG of {
                                                                            GHC.Types.False ->
                                                                                $j2_s1CYK;
                                                                            GHC.Types.True ->
                                                                                fail3_s1CYx
                                                                                    GHC.Prim.void#;
                                                                          };
                                                                      GHC.Types.True ->
                                                                          case ySigned_s1CWG of {
                                                                            GHC.Types.False ->
                                                                                fail3_s1CYx
                                                                                    GHC.Prim.void#;
                                                                            GHC.Types.True ->
                                                                                $j2_s1CYK;
                                                                          };
                                                                    };
                                                    } in 
                                                      case xSigned_s1CWI of {
                                                        GHC.Types.False ->
                                                            case ySigned_s1CWG of {
                                                              GHC.Types.False ->
                                                                  case yWidth_s1CWH of {
                                                                    GHC.Base.Nothing -> $j_s1CWM;
                                                                    GHC.Base.Just _ [Occ=Dead] ->
                                                                        fail2_s1CYd GHC.Prim.void#;
                                                                  };
                                                              GHC.Types.True ->
                                                                  fail2_s1CYd GHC.Prim.void#;
                                                            };
                                                        GHC.Types.True ->
                                                            fail2_s1CYd GHC.Prim.void#;
                                                      };
                                          } in 
                                            case ySigned_s1CWG of {
                                              GHC.Types.False -> fail1_s1CYb GHC.Prim.void#;
                                              GHC.Types.True ->
                                                  case yWidth_s1CWH of {
                                                    GHC.Base.Nothing -> $j_s1CWM;
                                                    GHC.Base.Just _ [Occ=Dead] ->
                                                        fail1_s1CYb GHC.Prim.void#;
                                                  };
                                            };
                                } in 
                                  let-no-escape {
                                    $j1_s1CZ4 [Occ=Once*T[0], Dmd=<L,1*U>] :: GHC.Base.Maybe b_a1AhY
                                    [LclId[JoinId(0)], Unf=OtherCon []] =
                                        [ySigned_s1CWG xSigned_s1CWI $j_s1CWM fail_s1CY9] \r []
                                            case xSigned_s1CWI of {
                                              GHC.Types.False ->
                                                  case ySigned_s1CWG of {
                                                    GHC.Types.False -> $j_s1CWM;
                                                    GHC.Types.True -> fail_s1CY9 GHC.Prim.void#;
                                                  };
                                              GHC.Types.True ->
                                                  case ySigned_s1CWG of {
                                                    GHC.Types.False -> fail_s1CY9 GHC.Prim.void#;
                                                    GHC.Types.True -> $j_s1CWM;
                                                  };
                                            };
                                  } in 
                                    case xWidth_s1CWB of {
                                      GHC.Base.Nothing ->
                                          case yWidth_s1CWH of {
                                            GHC.Base.Nothing -> $j1_s1CZ4;
                                            GHC.Base.Just _ [Occ=Dead] -> fail_s1CY9 GHC.Prim.void#;
                                          };
                                      GHC.Base.Just a1_s1CZb [Occ=Once!] ->
                                          case yWidth_s1CWH of {
                                            GHC.Base.Nothing -> fail_s1CY9 GHC.Prim.void#;
                                            GHC.Base.Just b1_s1CZd [Occ=Once!] ->
                                                case a1_s1CZb of {
                                                  GHC.Types.I# x_s1CZf [Occ=Once] ->
                                                      case b1_s1CZd of {
                                                        GHC.Types.I# y1_s1CZh [Occ=Once] ->
                                                            case ==# [x_s1CZf y1_s1CZh] of {
                                                              __DEFAULT ->
                                                                  fail_s1CY9 GHC.Prim.void#;
                                                              1# -> $j1_s1CZ4;
                                                            };
                                                      };
                                                };
                                          };
                                    };
                      };
                };
        };

Data.Bits.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Bits.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$trModule4];

Data.Bits.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bits"#;

Data.Bits.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$trModule2];

Data.Bits.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bits.$trModule3
                                     Data.Bits.$trModule1];

$krep_r1CDE :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcBool
                                              GHC.Types.[]];

$krep1_r1CDF :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcInt
                                              GHC.Types.[]];

$krep2_r1CDG :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

$krep3_r1CDH :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r1CDF GHC.Types.[]];

$krep4_r1CDI :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep3_r1CDH];

$krep5_r1CDJ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r1CDF $krep_r1CDE];

Data.Bits.$tcBits1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*
                                         $krep2_r1CDG];

$krep6_r1CDK :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep7_r1CDL :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep6_r1CDK];

$krep8_r1CDM :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep7_r1CDL];

$krep9_r1CDN :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep5_r1CDJ];

$krep10_r1CDO :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep4_r1CDI];

$krep11_r1CDP :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep1_r1CDF];

$krep12_r1CDQ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep_r1CDE];

$krep13_r1CDR :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r1CDF $krep6_r1CDK];

$krep14_r1CDS :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep13_r1CDR];

$krep15_r1CDT :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_r1CDK GHC.Types.[]];

$krep16_r1CDU :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Classes.$tcEq
                                              $krep15_r1CDT];

Data.Bits.$tcBits3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bits"#;

Data.Bits.$tcBits2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tcBits3];

Data.Bits.$tcBits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7088815172979416363##
                                    4990916430057605838##
                                    Data.Bits.$trModule
                                    Data.Bits.$tcBits2
                                    0#
                                    Data.Bits.$tcBits1];

$krep17_r1CDV :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Bits.$tcBits
                                              $krep15_r1CDT];

$krep18_r1CDW :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep17_r1CDV];

$krep19_r1CDX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep18_r1CDW];

$krep20_r1CDY :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep19_r1CDX];

$krep21_r1CDZ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep20_r1CDY];

$krep22_r1CE0 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep21_r1CDZ];

$krep23_r1CE1 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep22_r1CE0];

$krep24_r1CE2 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep23_r1CE1];

$krep25_r1CE3 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep12_r1CDQ $krep24_r1CE2];

$krep26_r1CE4 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep25_r1CE3];

$krep27_r1CE5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_r1CDO $krep26_r1CE4];

$krep28_r1CE6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep9_r1CDN $krep27_r1CE5];

$krep29_r1CE7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep28_r1CE6];

$krep30_r1CE8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep29_r1CE7];

$krep31_r1CE9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep30_r1CE8];

$krep32_r1CEa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep13_r1CDR $krep31_r1CE9];

$krep33_r1CEb :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep32_r1CEa];

$krep34_r1CEc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep33_r1CEb];

$krep35_r1CEd :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep34_r1CEc];

$krep36_r1CEe :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_r1CDL $krep35_r1CEd];

$krep37_r1CEf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r1CDM $krep36_r1CEe];

$krep38_r1CEg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r1CDM $krep37_r1CEf];

$krep39_r1CEh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r1CDM $krep38_r1CEg];

Data.Bits.$tc'C:Bits1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep16_r1CDU $krep39_r1CEh];

Data.Bits.$tc'C:Bits3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Bits"#;

Data.Bits.$tc'C:Bits2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tc'C:Bits3];

Data.Bits.$tc'C:Bits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [744071653035646959##
                                    2574978498160477882##
                                    Data.Bits.$trModule
                                    Data.Bits.$tc'C:Bits2
                                    1#
                                    Data.Bits.$tc'C:Bits1];

Data.Bits.$tcFiniteBits2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "FiniteBits"#;

Data.Bits.$tcFiniteBits1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tcFiniteBits2];

Data.Bits.$tcFiniteBits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2363162769622202131##
                                    10110405838341883172##
                                    Data.Bits.$trModule
                                    Data.Bits.$tcFiniteBits1
                                    0#
                                    Data.Bits.$tcBits1];

$krep40_r1CEi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Bits.$tcFiniteBits
                                              $krep15_r1CDT];

$krep41_r1CEj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep40_r1CEi];

$krep42_r1CEk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep41_r1CEj];

$krep43_r1CEl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep42_r1CEk];

Data.Bits.$tc'C:FiniteBits1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep17_r1CDV $krep43_r1CEl];

Data.Bits.$tc'C:FiniteBits3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:FiniteBits"#;

Data.Bits.$tc'C:FiniteBits2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tc'C:FiniteBits3];

Data.Bits.$tc'C:FiniteBits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7500562306525175158##
                                    16051895206261500648##
                                    Data.Bits.$trModule
                                    Data.Bits.$tc'C:FiniteBits2
                                    1#
                                    Data.Bits.$tc'C:FiniteBits1];

Data.Bits.C:FiniteBits
  :: forall b.
     Data.Bits.Bits b =>
     (b -> GHC.Types.Int)
     -> (b -> GHC.Types.Int)
     -> (b -> GHC.Types.Int)
     -> Data.Bits.FiniteBits b
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bits.C:FiniteBits [eta_B4 eta_B3 eta_B2 eta_B1];

Data.Bits.C:Bits
  :: forall a.
     GHC.Classes.Eq a =>
     (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> a
     -> (GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> GHC.Types.Bool)
     -> (a -> GHC.Base.Maybe GHC.Types.Int)
     -> (a -> GHC.Types.Int)
     -> (a -> GHC.Types.Bool)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int)
     -> Data.Bits.Bits a
[GblId[DataCon],
 Arity=23,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_Bn
           eta_Bm
           eta_Bl
           eta_Bk
           eta_Bj
           eta_Bi
           eta_Bh
           eta_Bg
           eta_Bf
           eta_Be
           eta_Bd
           eta_Bc
           eta_Bb
           eta_Ba
           eta_B9
           eta_B8
           eta_B7
           eta_B6
           eta_B5
           eta_B4
           eta_B3
           eta_B2
           eta_B1]
        Data.Bits.C:Bits [eta_Bn
                          eta_Bm
                          eta_Bl
                          eta_Bk
                          eta_Bj
                          eta_Bi
                          eta_Bh
                          eta_Bg
                          eta_Bf
                          eta_Be
                          eta_Bd
                          eta_Bc
                          eta_Bb
                          eta_Ba
                          eta_B9
                          eta_B8
                          eta_B7
                          eta_B6
                          eta_B5
                          eta_B4
                          eta_B3
                          eta_B2
                          eta_B1];


==================== Pre unarise: ====================
2018-03-16 15:56:28.585320954 UTC

Data.Bits.$p1FiniteBits
  :: forall b. Data.Bits.FiniteBits b => Data.Bits.Bits b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_s1GQa]
        case v_s1GQa of {
          Data.Bits.C:FiniteBits v_s1GQc [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s1GQc;
        };

Data.Bits.finiteBitSize
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_s1GQg]
        case v_s1GQg of {
          Data.Bits.C:FiniteBits _ [Occ=Dead]
                                 v_s1GQj [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s1GQj;
        };

Data.Bits.countLeadingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_s1GQm]
        case v_s1GQm of {
          Data.Bits.C:FiniteBits _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s1GQq [Occ=Once]
                                 _ [Occ=Dead] ->
              v_s1GQq;
        };

Data.Bits.countTrailingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_s1GQs]
        case v_s1GQs of {
          Data.Bits.C:FiniteBits _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s1GQx [Occ=Once] ->
              v_s1GQx;
        };

Data.Bits.$p1Bits :: forall a. Data.Bits.Bits a => GHC.Classes.Eq a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLLLLLLLLLLLLLLLL),U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GQy]
        case v_s1GQy of {
          Data.Bits.C:Bits v_s1GQA [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GQA;
        };

Data.Bits..&. :: forall a. Data.Bits.Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLLLLLLLLLLLLLLLL),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GQX]
        case v_s1GQX of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           v_s1GR0 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GR0;
        };

Data.Bits..|. :: forall a. Data.Bits.Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLLLLLLLLLLLLLLLL),U(A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GRm]
        case v_s1GRm of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GRq [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GRq;
        };

Data.Bits.xor :: forall a. Data.Bits.Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLLLLLLLLLLLLLLLL),U(A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GRL]
        case v_s1GRL of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GRQ [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GRQ;
        };

Data.Bits.complement :: forall a. Data.Bits.Bits a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLLLLLLLLLLLLLLLL),U(A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GSa]
        case v_s1GSa of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GSg [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GSg;
        };

Data.Bits.shift
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLLLLLLLLLLLLLLLL),U(A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GSz]
        case v_s1GSz of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GSG [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GSG;
        };

Data.Bits.rotate
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLLLLLLLLLLLLLLLL),U(A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GSY]
        case v_s1GSY of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GT6 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GT6;
        };

Data.Bits.zeroBits :: forall a. Data.Bits.Bits a => a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSLLLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GTn]
        case v_s1GTn of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GTw [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GTw;
        };

Data.Bits.bit :: forall a. Data.Bits.Bits a => GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLSLLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GTM]
        case v_s1GTM of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GTW [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GTW;
        };

Data.Bits.setBit
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLSLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GUb]
        case v_s1GUb of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GUm [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GUm;
        };

Data.Bits.clearBit
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLSLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GUA]
        case v_s1GUA of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GUM [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GUM;
        };

Data.Bits.complementBit
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLSLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GUZ]
        case v_s1GUZ of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GVc [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GVc;
        };

Data.Bits.testBit
  :: forall a.
     Data.Bits.Bits a =>
     a -> GHC.Types.Int -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLSLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GVo]
        case v_s1GVo of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GVC [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GVC;
        };

Data.Bits.bitSizeMaybe
  :: forall a. Data.Bits.Bits a => a -> GHC.Base.Maybe GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLSLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GVN]
        case v_s1GVN of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GW2 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GW2;
        };

Data.Bits.bitSize
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLSLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GWc]
        case v_s1GWc of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GWs [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GWs;
        };

Data.Bits.isSigned
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLSLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GWB]
        case v_s1GWB of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GWS [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GWS;
        };

Data.Bits.shiftL
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLSLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A)>] =
    [] \r [v_s1GX0]
        case v_s1GX0 of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GXi [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GXi;
        };

Data.Bits.unsafeShiftL
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLSLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A)>] =
    [] \r [v_s1GXp]
        case v_s1GXp of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GXI [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GXI;
        };

Data.Bits.shiftR
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLSLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A)>] =
    [] \r [v_s1GXO]
        case v_s1GXO of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GY8 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GY8;
        };

Data.Bits.unsafeShiftR
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLSLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A)>] =
    [] \r [v_s1GYd]
        case v_s1GYd of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GYy [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GYy;
        };

Data.Bits.rotateL
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLSLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A)>] =
    [] \r [v_s1GYC]
        case v_s1GYC of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GYY [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GYY;
        };

Data.Bits.rotateR
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A)>] =
    [] \r [v_s1GZ1]
        case v_s1GZ1 of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GZo [Occ=Once]
                           _ [Occ=Dead] ->
              v_s1GZo;
        };

Data.Bits.popCount
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLLLS),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U)>] =
    [] \r [v_s1GZq]
        case v_s1GZq of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GZO [Occ=Once] ->
              v_s1GZO;
        };

Data.Bits.$fBitsBool2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Bits.$fBitsBool1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Bits.$fBitsBool_$cpopCount :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_s1GZP]
        case ds_s1GZP of {
          GHC.Types.False -> Data.Bits.$fBitsBool2;
          GHC.Types.True -> Data.Bits.$fBitsBool1;
        };

Data.Bits.$fBitsBool_$cisSigned :: GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1GZR] GHC.Types.False [];

Data.Bits.$fBitsBool_$cbitSize :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s1GZS] Data.Bits.$fBitsBool1;

Data.Bits.$fBitsBool3 :: GHC.Base.Maybe GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [Data.Bits.$fBitsBool1];

Data.Bits.$fBitsBool_$cbitSizeMaybe
  :: GHC.Types.Bool -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m2, Unf=OtherCon []] =
    [] \r [ds_s1GZT] Data.Bits.$fBitsBool3;

Data.Bits.$fBitsBool_$ctestBit
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [x_s1GZU ds_s1GZV]
        case ds_s1GZV of {
          GHC.Types.I# ds1_s1GZX [Occ=Once!] ->
              case ds1_s1GZX of {
                __DEFAULT -> GHC.Types.False [];
                0# -> x_s1GZU;
              };
        };

Data.Bits.$fBitsBool_$cbit :: GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1GZZ]
        case ds_s1GZZ of {
          GHC.Types.I# ds1_s1H01 [Occ=Once!] ->
              case ds1_s1H01 of {
                __DEFAULT -> GHC.Types.False [];
                0# -> GHC.Types.True [];
              };
        };

Data.Bits.$fBitsBool_$crotate
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s1H03 ds_s1H04] x_s1H03;

Data.Bits.$fBitsInteger_$cisSigned
  :: GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1H05] GHC.Types.True [];

Data.Bits.$fBitsInteger2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bits.bitSize(Integer)"#;

Data.Bits.$fBitsInteger1 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Bits.$fBitsInteger2;

Data.Bits.$fBitsInteger_$cbitSize
  :: GHC.Integer.Type.Integer -> GHC.Types.Int
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [ds_s1H06]
        GHC.Err.errorWithoutStackTrace Data.Bits.$fBitsInteger1;

Data.Bits.$fBitsInteger_$cbitSizeMaybe
  :: GHC.Integer.Type.Integer -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1H07] GHC.Base.Nothing [];

Data.Bits.$fBitsInteger_$ctestBit
  :: GHC.Integer.Type.Integer -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1H08 ds_s1H09]
        case ds_s1H09 of {
          GHC.Types.I# i_s1H0b [Occ=Once] ->
              GHC.Integer.Type.testBitInteger x_s1H08 i_s1H0b;
        };

Data.Bits.$fBitsInteger_$czeroBits :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Bits.$w$cshift [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Prim.Int# -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [w_s1H0c ww_s1H0d]
        case >=# [ww_s1H0d 0#] of {
          __DEFAULT ->
              case negateInt# [ww_s1H0d] of sat_s1H0f {
                __DEFAULT -> GHC.Integer.Type.shiftRInteger w_s1H0c sat_s1H0f;
              };
          1# -> GHC.Integer.Type.shiftLInteger w_s1H0c ww_s1H0d;
        };

Data.Bits.$fBitsInteger_$cshift [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [w_s1H0g w1_s1H0h]
        case w1_s1H0h of {
          GHC.Types.I# ww1_s1H0j [Occ=Once] ->
              Data.Bits.$w$cshift w_s1H0g ww1_s1H0j;
        };

sat_s1H0k :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s1H0l :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1H0k GHC.Types.[]];

Data.Bits.$fBitsInteger3 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s1H0l;

Data.Bits.$fBitsInteger_$cbit
  :: GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [i_s1H0m]
        case i_s1H0m of {
          GHC.Types.I# ww1_s1H0o ->
              case >=# [ww1_s1H0o 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1H0o] of sat_s1H0q {
                      __DEFAULT ->
                          GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1H0q;
                    };
                1# ->
                    GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1H0o;
              };
        };

Data.Bits.$fBitsInteger_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1H0r eta1_s1H0s]
        case eta1_s1H0s of {
          GHC.Types.I# ww1_s1H0u ->
              case >=# [ww1_s1H0u 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1H0u] of sat_s1H0w {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1H0w
                          of
                          sat_s1H0x
                          { __DEFAULT ->
                                case GHC.Integer.Type.complementInteger sat_s1H0x of sat_s1H0y {
                                  __DEFAULT -> GHC.Integer.Type.andInteger eta_s1H0r sat_s1H0y;
                                };
                          };
                    };
                1# ->
                    case
                        GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1H0u
                    of
                    sat_s1H0z
                    { __DEFAULT ->
                          case GHC.Integer.Type.complementInteger sat_s1H0z of sat_s1H0A {
                            __DEFAULT -> GHC.Integer.Type.andInteger eta_s1H0r sat_s1H0A;
                          };
                    };
              };
        };

Data.Bits.$fBitsInteger_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1H0B eta1_s1H0C]
        case eta1_s1H0C of {
          GHC.Types.I# ww1_s1H0E ->
              case >=# [ww1_s1H0E 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1H0E] of sat_s1H0G {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1H0G
                          of
                          sat_s1H0H
                          { __DEFAULT -> GHC.Integer.Type.xorInteger eta_s1H0B sat_s1H0H;
                          };
                    };
                1# ->
                    case
                        GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1H0E
                    of
                    sat_s1H0I
                    { __DEFAULT -> GHC.Integer.Type.xorInteger eta_s1H0B sat_s1H0I;
                    };
              };
        };

Data.Bits.$fBitsInteger_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1H0J eta1_s1H0K]
        case eta1_s1H0K of {
          GHC.Types.I# ww1_s1H0M ->
              case >=# [ww1_s1H0M 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1H0M] of sat_s1H0O {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1H0O
                          of
                          sat_s1H0P
                          { __DEFAULT -> GHC.Integer.Type.orInteger eta_s1H0J sat_s1H0P;
                          };
                    };
                1# ->
                    case
                        GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1H0M
                    of
                    sat_s1H0Q
                    { __DEFAULT -> GHC.Integer.Type.orInteger eta_s1H0J sat_s1H0Q;
                    };
              };
        };

Data.Bits.$fBitsInteger_$cunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshift eta_B2 eta_B1;

Data.Bits.$fBitsInteger_$cshiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshift eta_B2 eta_B1;

Data.Bits.$fBitsInteger_$cshiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1H0R eta1_s1H0S]
        case eta1_s1H0S of {
          GHC.Types.I# x_s1H0U [Occ=Once] ->
              case negateInt# [x_s1H0U] of i#_s1H0V [Dmd=<S,U>] {
                __DEFAULT ->
                    case >=# [i#_s1H0V 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1H0V] of sat_s1H0X {
                            __DEFAULT -> GHC.Integer.Type.shiftRInteger eta_s1H0R sat_s1H0X;
                          };
                      1# -> GHC.Integer.Type.shiftLInteger eta_s1H0R i#_s1H0V;
                    };
              };
        };

Data.Bits.$fBitsInteger_$cunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshiftR eta_B2 eta_B1;

Data.Bits.$fBitsInteger_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1H0Y eta1_s1H0Z]
        case eta1_s1H0Z of {
          GHC.Types.I# x_s1H11 [Occ=Once] ->
              case negateInt# [x_s1H11] of i#_s1H12 [Dmd=<S,U>] {
                __DEFAULT ->
                    case >=# [i#_s1H12 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1H12] of sat_s1H14 {
                            __DEFAULT -> GHC.Integer.Type.shiftRInteger eta_s1H0Y sat_s1H14;
                          };
                      1# -> GHC.Integer.Type.shiftLInteger eta_s1H0Y i#_s1H12;
                    };
              };
        };

Data.Bits.$fBitsInteger_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshift eta_B2 eta_B1;

Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros
  :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [x_s1H15]
        case x_s1H15 of {
          GHC.Types.False -> Data.Bits.$fBitsBool1;
          GHC.Types.True -> Data.Bits.$fBitsBool2;
        };

Data.Bits.$fBitsInt_$cpopCount :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H17]
        case ds_s1H17 of {
          GHC.Types.I# x#_s1H19 [Occ=Once] ->
              case int2Word# [x#_s1H19] of sat_s1H1a {
                __DEFAULT ->
                    case popCnt# [sat_s1H1a] of sat_s1H1b {
                      __DEFAULT ->
                          case word2Int# [sat_s1H1b] of sat_s1H1c {
                            __DEFAULT -> GHC.Types.I# [sat_s1H1c];
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cunsafeShiftR
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H1d ds1_s1H1e]
        case ds_s1H1d of {
          GHC.Types.I# x#_s1H1g [Occ=Once] ->
              case ds1_s1H1e of {
                GHC.Types.I# i#_s1H1i [Occ=Once] ->
                    case uncheckedIShiftRA# [x#_s1H1g i#_s1H1i] of sat_s1H1j {
                      __DEFAULT -> GHC.Types.I# [sat_s1H1j];
                    };
              };
        };

lvl_r1CDD :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [-1#];

Data.Bits.$fBitsInt_$cshiftR [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1H1k w1_s1H1l]
        case w_s1H1k of {
          GHC.Types.I# ww1_s1H1n [Occ=Once*] ->
              case w1_s1H1l of {
                GHC.Types.I# ww3_s1H1p ->
                    case >=# [ww3_s1H1p 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftRA# [ww1_s1H1n ww3_s1H1p] of sat_s1H1r {
                            __DEFAULT -> GHC.Types.I# [sat_s1H1r];
                          };
                      1# ->
                          case <# [ww1_s1H1n 0#] of {
                            __DEFAULT -> Data.Bits.$fBitsBool2;
                            1# -> lvl_r1CDD;
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cunsafeShiftL
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H1t ds1_s1H1u]
        case ds_s1H1t of {
          GHC.Types.I# x#_s1H1w [Occ=Once] ->
              case ds1_s1H1u of {
                GHC.Types.I# i#_s1H1y [Occ=Once] ->
                    case uncheckedIShiftL# [x#_s1H1w i#_s1H1y] of sat_s1H1z {
                      __DEFAULT -> GHC.Types.I# [sat_s1H1z];
                    };
              };
        };

Data.Bits.$fBitsInt_$cshiftL
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H1A ds1_s1H1B]
        case ds_s1H1A of {
          GHC.Types.I# x#_s1H1D [Occ=Once] ->
              case ds1_s1H1B of {
                GHC.Types.I# i#_s1H1F ->
                    case >=# [i#_s1H1F 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [x#_s1H1D i#_s1H1F] of sat_s1H1H {
                            __DEFAULT -> GHC.Types.I# [sat_s1H1H];
                          };
                      1# -> Data.Bits.$fBitsBool2;
                    };
              };
        };

Data.Bits.$fBitsInt_$cisSigned :: GHC.Types.Int -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1H1I] GHC.Types.True [];

Data.Bits.$fBitsInt_$crotate [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H1J ds1_s1H1K]
        case ds_s1H1J of {
          GHC.Types.I# x#_s1H1M ->
              case ds1_s1H1K of {
                GHC.Types.I# i#_s1H1O [Occ=Once] ->
                    case andI# [i#_s1H1O 63#] of i'#_s1H1P [Dmd=<S,U>] {
                      __DEFAULT ->
                          case -# [64# i'#_s1H1P] of sat_s1H1R {
                            __DEFAULT ->
                                case uncheckedIShiftRL# [x#_s1H1M sat_s1H1R] of sat_s1H1S {
                                  __DEFAULT ->
                                      case uncheckedIShiftL# [x#_s1H1M i'#_s1H1P] of sat_s1H1Q {
                                        __DEFAULT ->
                                            case orI# [sat_s1H1Q sat_s1H1S] of sat_s1H1T {
                                              __DEFAULT -> GHC.Types.I# [sat_s1H1T];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cshift [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H1U ds1_s1H1V]
        case ds_s1H1U of {
          GHC.Types.I# x#_s1H1X [Occ=Once*] ->
              case ds1_s1H1V of {
                GHC.Types.I# i#_s1H1Z ->
                    case >=# [i#_s1H1Z 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1H1Z] of b_s1H21 [Dmd=<S,U>] {
                            __DEFAULT ->
                                case >=# [b_s1H21 64#] of {
                                  __DEFAULT ->
                                      case uncheckedIShiftRA# [x#_s1H1X b_s1H21] of sat_s1H23 {
                                        __DEFAULT -> GHC.Types.I# [sat_s1H23];
                                      };
                                  1# ->
                                      case <# [x#_s1H1X 0#] of {
                                        __DEFAULT -> Data.Bits.$fBitsBool2;
                                        1# -> lvl_r1CDD;
                                      };
                                };
                          };
                      1# ->
                          case >=# [i#_s1H1Z 64#] of {
                            __DEFAULT ->
                                case uncheckedIShiftL# [x#_s1H1X i#_s1H1Z] of sat_s1H26 {
                                  __DEFAULT -> GHC.Types.I# [sat_s1H26];
                                };
                            1# -> Data.Bits.$fBitsBool2;
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$ccomplement :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H27]
        case ds_s1H27 of {
          GHC.Types.I# x#_s1H29 [Occ=Once] ->
              case notI# [x#_s1H29] of sat_s1H2a {
                __DEFAULT -> GHC.Types.I# [sat_s1H2a];
              };
        };

Data.Bits.$fBitsInt_$cxor
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2b ds1_s1H2c]
        case ds_s1H2b of {
          GHC.Types.I# x#_s1H2e [Occ=Once] ->
              case ds1_s1H2c of {
                GHC.Types.I# y#_s1H2g [Occ=Once] ->
                    case xorI# [x#_s1H2e y#_s1H2g] of sat_s1H2h {
                      __DEFAULT -> GHC.Types.I# [sat_s1H2h];
                    };
              };
        };

Data.Bits.$fBitsInt_$c.|.
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2i ds1_s1H2j]
        case ds_s1H2i of {
          GHC.Types.I# x#_s1H2l [Occ=Once] ->
              case ds1_s1H2j of {
                GHC.Types.I# y#_s1H2n [Occ=Once] ->
                    case orI# [x#_s1H2l y#_s1H2n] of sat_s1H2o {
                      __DEFAULT -> GHC.Types.I# [sat_s1H2o];
                    };
              };
        };

Data.Bits.$fBitsInt_$c.&.
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2p ds1_s1H2q]
        case ds_s1H2p of {
          GHC.Types.I# x#_s1H2s [Occ=Once] ->
              case ds1_s1H2q of {
                GHC.Types.I# y#_s1H2u [Occ=Once] ->
                    case andI# [x#_s1H2s y#_s1H2u] of sat_s1H2v {
                      __DEFAULT -> GHC.Types.I# [sat_s1H2v];
                    };
              };
        };

Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros
  :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2w]
        case ds_s1H2w of {
          GHC.Types.I# x#_s1H2y [Occ=Once] ->
              case int2Word# [x#_s1H2y] of sat_s1H2z {
                __DEFAULT ->
                    case ctz# [sat_s1H2z] of sat_s1H2A {
                      __DEFAULT ->
                          case word2Int# [sat_s1H2A] of sat_s1H2B {
                            __DEFAULT -> GHC.Types.I# [sat_s1H2B];
                          };
                    };
              };
        };

Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros
  :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2C]
        case ds_s1H2C of {
          GHC.Types.I# x#_s1H2E [Occ=Once] ->
              case int2Word# [x#_s1H2E] of sat_s1H2F {
                __DEFAULT ->
                    case clz# [sat_s1H2F] of sat_s1H2G {
                      __DEFAULT ->
                          case word2Int# [sat_s1H2G] of sat_s1H2H {
                            __DEFAULT -> GHC.Types.I# [sat_s1H2H];
                          };
                    };
              };
        };

Data.Bits.$fBitsInt1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [64#];

Data.Bits.$fBitsInt_$cfiniteBitSize
  :: GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s1H2I] Data.Bits.$fBitsInt1;

Data.Bits.$fBitsWord_$cpopCount :: GHC.Types.Word -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2J]
        case ds_s1H2J of {
          GHC.Types.W# x#_s1H2L [Occ=Once] ->
              case popCnt# [x#_s1H2L] of sat_s1H2M {
                __DEFAULT ->
                    case word2Int# [sat_s1H2M] of sat_s1H2N {
                      __DEFAULT -> GHC.Types.I# [sat_s1H2N];
                    };
              };
        };

Data.Bits.$fBitsWord_$cunsafeShiftR
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2O ds1_s1H2P]
        case ds_s1H2O of {
          GHC.Types.W# x#_s1H2R [Occ=Once] ->
              case ds1_s1H2P of {
                GHC.Types.I# i#_s1H2T [Occ=Once] ->
                    case uncheckedShiftRL# [x#_s1H2R i#_s1H2T] of sat_s1H2U {
                      __DEFAULT -> GHC.Types.W# [sat_s1H2U];
                    };
              };
        };

Data.Bits.$fBitsWord1 :: GHC.Types.Word
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.W#! [0##];

Data.Bits.$fBitsWord_$cshiftR
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2V ds1_s1H2W]
        case ds_s1H2V of {
          GHC.Types.W# x#_s1H2Y [Occ=Once] ->
              case ds1_s1H2W of {
                GHC.Types.I# i#_s1H30 ->
                    case >=# [i#_s1H30 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftRL# [x#_s1H2Y i#_s1H30] of sat_s1H32 {
                            __DEFAULT -> GHC.Types.W# [sat_s1H32];
                          };
                      1# -> Data.Bits.$fBitsWord1;
                    };
              };
        };

Data.Bits.$fBitsWord_$cunsafeShiftL
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H33 ds1_s1H34]
        case ds_s1H33 of {
          GHC.Types.W# x#_s1H36 [Occ=Once] ->
              case ds1_s1H34 of {
                GHC.Types.I# i#_s1H38 [Occ=Once] ->
                    case uncheckedShiftL# [x#_s1H36 i#_s1H38] of sat_s1H39 {
                      __DEFAULT -> GHC.Types.W# [sat_s1H39];
                    };
              };
        };

Data.Bits.$fBitsWord_$cshiftL
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3a ds1_s1H3b]
        case ds_s1H3a of {
          GHC.Types.W# x#_s1H3d [Occ=Once] ->
              case ds1_s1H3b of {
                GHC.Types.I# i#_s1H3f ->
                    case >=# [i#_s1H3f 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [x#_s1H3d i#_s1H3f] of sat_s1H3h {
                            __DEFAULT -> GHC.Types.W# [sat_s1H3h];
                          };
                      1# -> Data.Bits.$fBitsWord1;
                    };
              };
        };

Data.Bits.$fBitsWord_$cisSigned :: GHC.Types.Word -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1H3i] GHC.Types.False [];

Data.Bits.$fBitsWord_$crotate
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3j ds1_s1H3k]
        case ds_s1H3j of wild_s1H3l {
          GHC.Types.W# x#_s1H3m ->
              case ds1_s1H3k of {
                GHC.Types.I# i#_s1H3o [Occ=Once] ->
                    case andI# [i#_s1H3o 63#] of wild2_s1H3p {
                      __DEFAULT ->
                          case -# [64# wild2_s1H3p] of sat_s1H3r {
                            __DEFAULT ->
                                case uncheckedShiftRL# [x#_s1H3m sat_s1H3r] of sat_s1H3s {
                                  __DEFAULT ->
                                      case uncheckedShiftL# [x#_s1H3m wild2_s1H3p] of sat_s1H3q {
                                        __DEFAULT ->
                                            case or# [sat_s1H3q sat_s1H3s] of sat_s1H3t {
                                              __DEFAULT -> GHC.Types.W# [sat_s1H3t];
                                            };
                                      };
                                };
                          };
                      0# -> wild_s1H3l;
                    };
              };
        };

Data.Bits.$fBitsWord_$cshift [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3u ds1_s1H3v]
        case ds_s1H3u of {
          GHC.Types.W# x#_s1H3x [Occ=Once*] ->
              case ds1_s1H3v of {
                GHC.Types.I# i#_s1H3z ->
                    case >=# [i#_s1H3z 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1H3z] of b_s1H3B [Dmd=<S,U>] {
                            __DEFAULT ->
                                case >=# [b_s1H3B 64#] of {
                                  __DEFAULT ->
                                      case uncheckedShiftRL# [x#_s1H3x b_s1H3B] of sat_s1H3D {
                                        __DEFAULT -> GHC.Types.W# [sat_s1H3D];
                                      };
                                  1# -> Data.Bits.$fBitsWord1;
                                };
                          };
                      1# ->
                          case >=# [i#_s1H3z 64#] of {
                            __DEFAULT ->
                                case uncheckedShiftL# [x#_s1H3x i#_s1H3z] of sat_s1H3F {
                                  __DEFAULT -> GHC.Types.W# [sat_s1H3F];
                                };
                            1# -> Data.Bits.$fBitsWord1;
                          };
                    };
              };
        };

Data.Bits.$fBitsWord_$ccomplement
  :: GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3G]
        case ds_s1H3G of {
          GHC.Types.W# x#_s1H3I [Occ=Once] ->
              case xor# [x#_s1H3I 18446744073709551615##] of sat_s1H3J {
                __DEFAULT -> GHC.Types.W# [sat_s1H3J];
              };
        };

Data.Bits.$fBitsWord_$cxor
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3K ds1_s1H3L]
        case ds_s1H3K of {
          GHC.Types.W# x#_s1H3N [Occ=Once] ->
              case ds1_s1H3L of {
                GHC.Types.W# y#_s1H3P [Occ=Once] ->
                    case xor# [x#_s1H3N y#_s1H3P] of sat_s1H3Q {
                      __DEFAULT -> GHC.Types.W# [sat_s1H3Q];
                    };
              };
        };

Data.Bits.$fBitsWord_$c.|.
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3R ds1_s1H3S]
        case ds_s1H3R of {
          GHC.Types.W# x#_s1H3U [Occ=Once] ->
              case ds1_s1H3S of {
                GHC.Types.W# y#_s1H3W [Occ=Once] ->
                    case or# [x#_s1H3U y#_s1H3W] of sat_s1H3X {
                      __DEFAULT -> GHC.Types.W# [sat_s1H3X];
                    };
              };
        };

Data.Bits.$fBitsWord_$c.&.
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3Y ds1_s1H3Z]
        case ds_s1H3Y of {
          GHC.Types.W# x#_s1H41 [Occ=Once] ->
              case ds1_s1H3Z of {
                GHC.Types.W# y#_s1H43 [Occ=Once] ->
                    case and# [x#_s1H41 y#_s1H43] of sat_s1H44 {
                      __DEFAULT -> GHC.Types.W# [sat_s1H44];
                    };
              };
        };

Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros
  :: GHC.Types.Word -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H45]
        case ds_s1H45 of {
          GHC.Types.W# x#_s1H47 [Occ=Once] ->
              case ctz# [x#_s1H47] of sat_s1H48 {
                __DEFAULT ->
                    case word2Int# [sat_s1H48] of sat_s1H49 {
                      __DEFAULT -> GHC.Types.I# [sat_s1H49];
                    };
              };
        };

Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros
  :: GHC.Types.Word -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H4a]
        case ds_s1H4a of {
          GHC.Types.W# x#_s1H4c [Occ=Once] ->
              case clz# [x#_s1H4c] of sat_s1H4d {
                __DEFAULT ->
                    case word2Int# [sat_s1H4d] of sat_s1H4e {
                      __DEFAULT -> GHC.Types.I# [sat_s1H4e];
                    };
              };
        };

Data.Bits.$fBitsWord_$cfiniteBitSize
  :: GHC.Types.Word -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s1H4f] Data.Bits.$fBitsInt1;

Data.Bits.$dmcountTrailingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S(S))LL),U(1*U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A),1*C1(U(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFiniteBits_s1H4g eta_s1H4h]
        case Data.Bits.finiteBitSize $dFiniteBits_s1H4g eta_s1H4h of {
          GHC.Types.I# ww1_s1H4j [Occ=OnceL] ->
              let {
                $dBits_s1H4k [Occ=OnceL,
                              Dmd=<L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A)>]
                  :: Data.Bits.Bits b_a1A4A
                [LclId] =
                    [$dFiniteBits_s1H4g] \u []
                        Data.Bits.$p1FiniteBits $dFiniteBits_s1H4g;
              } in 
                let-no-escape {
                  $wgo_s1H4l [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[1]]
                    :: GHC.Prim.Int# -> GHC.Types.Int
                  [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                      sat-only [eta_s1H4h
                                ww1_s1H4j
                                $dBits_s1H4k
                                $wgo_s1H4l] \r [ww2_s1H4m]
                          let {
                            wild_s1H4n [Dmd=<L,U(U)>] :: GHC.Types.Int
                            [LclId, Unf=OtherCon []] =
                                CCCS GHC.Types.I#! [ww2_s1H4m];
                          } in 
                            case >=# [ww2_s1H4m ww1_s1H4j] of {
                              __DEFAULT ->
                                  case Data.Bits.testBit $dBits_s1H4k eta_s1H4h wild_s1H4n of {
                                    GHC.Types.False ->
                                        case +# [ww2_s1H4m 1#] of sat_s1H4q {
                                          __DEFAULT -> $wgo_s1H4l sat_s1H4q;
                                        };
                                    GHC.Types.True -> wild_s1H4n;
                                  };
                              1# -> wild_s1H4n;
                            };
                } in  $wgo_s1H4l 0#;
        };

Data.Bits.$dmcountLeadingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S(S))LL),U(1*U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A),1*C1(U(U)),A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFiniteBits_s1H4r eta_s1H4s]
        case Data.Bits.finiteBitSize $dFiniteBits_s1H4r eta_s1H4s of {
          GHC.Types.I# x_s1H4u ->
              let {
                $dBits_s1H4v [Occ=OnceL,
                              Dmd=<L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A)>]
                  :: Data.Bits.Bits b_a1A4A
                [LclId] =
                    [$dFiniteBits_s1H4r] \u []
                        Data.Bits.$p1FiniteBits $dFiniteBits_s1H4r;
              } in 
                case -# [x_s1H4u 1#] of sat_s1H4K {
                  __DEFAULT ->
                      let-no-escape {
                        exit_s1H4w [Occ=OnceL!T[1], Dmd=<L,C(U(U))>]
                          :: GHC.Prim.Int# -> GHC.Types.Int
                        [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []] =
                            sat-only [x_s1H4u] \r [ww_s1H4x]
                                case -# [x_s1H4u 1#] of sat_s1H4y {
                                  __DEFAULT ->
                                      case -# [sat_s1H4y ww_s1H4x] of sat_s1H4z {
                                        __DEFAULT -> GHC.Types.I# [sat_s1H4z];
                                      };
                                };
                      } in 
                        let-no-escape {
                          exit1_s1H4A [Occ=OnceL!T[1], Dmd=<L,C(U(U))>]
                            :: GHC.Prim.Int# -> GHC.Types.Int
                          [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []] =
                              sat-only [x_s1H4u] \r [ww_s1H4B]
                                  case -# [x_s1H4u 1#] of sat_s1H4C {
                                    __DEFAULT ->
                                        case -# [sat_s1H4C ww_s1H4B] of sat_s1H4D {
                                          __DEFAULT -> GHC.Types.I# [sat_s1H4D];
                                        };
                                  };
                        } in 
                          let-no-escape {
                            $wgo_s1H4E [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[1]]
                              :: GHC.Prim.Int# -> GHC.Types.Int
                            [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []] =
                                sat-only [eta_s1H4s
                                          $dBits_s1H4v
                                          exit_s1H4w
                                          exit1_s1H4A
                                          $wgo_s1H4E] \r [ww_s1H4F]
                                    case <# [ww_s1H4F 0#] of {
                                      __DEFAULT ->
                                          let {
                                            sat_s1H4H [Occ=Once] :: GHC.Types.Int
                                            [LclId] =
                                                CCCS GHC.Types.I#! [ww_s1H4F];
                                          } in 
                                            case
                                                Data.Bits.testBit $dBits_s1H4v eta_s1H4s sat_s1H4H
                                            of
                                            { GHC.Types.False ->
                                                  case -# [ww_s1H4F 1#] of sat_s1H4J {
                                                    __DEFAULT -> $wgo_s1H4E sat_s1H4J;
                                                  };
                                              GHC.Types.True -> exit_s1H4w ww_s1H4F;
                                            };
                                      1# -> exit1_s1H4A ww_s1H4F;
                                    };
                          } in  $wgo_s1H4E sat_s1H4K;
                };
        };

Data.Bits.$dmrotateR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H4L x_s1H4M i_s1H4N]
        let {
          sat_s1H4R [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [i_s1H4N] \u []
                  case i_s1H4N of {
                    GHC.Types.I# x1_s1H4P [Occ=Once] ->
                        case negateInt# [x1_s1H4P] of sat_s1H4Q {
                          __DEFAULT -> GHC.Types.I# [sat_s1H4Q];
                        };
                  };
        } in  Data.Bits.rotate $dBits_s1H4L x_s1H4M sat_s1H4R;

Data.Bits.$dmrotateL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H4S x_s1H4T i_s1H4U]
        Data.Bits.rotate $dBits_s1H4S x_s1H4T i_s1H4U;

Data.Bits.$dmunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLC(C(S))LLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H4V x_s1H4W i_s1H4X]
        Data.Bits.shiftR $dBits_s1H4V x_s1H4W i_s1H4X;

Data.Bits.$dmshiftR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H4Y x_s1H4Z i_s1H50]
        let {
          sat_s1H54 [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [i_s1H50] \u []
                  case i_s1H50 of {
                    GHC.Types.I# x1_s1H52 [Occ=Once] ->
                        case negateInt# [x1_s1H52] of sat_s1H53 {
                          __DEFAULT -> GHC.Types.I# [sat_s1H53];
                        };
                  };
        } in  Data.Bits.shift $dBits_s1H4Y x_s1H4Z sat_s1H54;

Data.Bits.$dmunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLC(C(S))LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H55 x_s1H56 i_s1H57]
        Data.Bits.shiftL $dBits_s1H55 x_s1H56 i_s1H57;

Data.Bits.$dmshiftL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H58 x_s1H59 i_s1H5a]
        Data.Bits.shift $dBits_s1H58 x_s1H59 i_s1H5a;

Data.Bits.$dmcomplementBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLLLLLLLLLLLLLLLLL),U(A,A,A,1*C1(C1(U)),A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H5b x_s1H5c i_s1H5d]
        let {
          sat_s1H5e [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1H5b i_s1H5d] \u [] Data.Bits.bit $dBits_s1H5b i_s1H5d;
        } in  Data.Bits.xor $dBits_s1H5b x_s1H5c sat_s1H5e;

Data.Bits.$dmclearBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLLLLLLLLLLLLLLLLL),U(A,1*C1(C1(U)),A,A,1*C1(U),A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H5f x_s1H5g i_s1H5h]
        let {
          sat_s1H5j [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1H5f i_s1H5h] \u []
                  let {
                    sat_s1H5i [Occ=Once] :: a_a1A4J
                    [LclId] =
                        [$dBits_s1H5f i_s1H5h] \u [] Data.Bits.bit $dBits_s1H5f i_s1H5h;
                  } in  Data.Bits.complement $dBits_s1H5f sat_s1H5i;
        } in  Data.Bits..&. $dBits_s1H5f x_s1H5g sat_s1H5j;

Data.Bits.$dmsetBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLLLLLLLLL),U(A,A,1*C1(C1(U)),A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H5k x_s1H5l i_s1H5m]
        let {
          sat_s1H5n [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1H5k i_s1H5m] \u [] Data.Bits.bit $dBits_s1H5k i_s1H5m;
        } in  Data.Bits..|. $dBits_s1H5k x_s1H5l sat_s1H5n;

Data.Bits.$dmzeroBits :: forall a. Data.Bits.Bits a => a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLC(C(S))LLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,1*C1(U),A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H5o]
        let {
          sat_s1H5p [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1H5o] \u []
                  Data.Bits.bit $dBits_s1H5o Data.Bits.$fBitsBool2;
        } in 
          Data.Bits.clearBit $dBits_s1H5o sat_s1H5p Data.Bits.$fBitsBool2;

Data.Bits.$fBitsBool_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cshiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$ctestBit eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$cshiftR eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cshiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$ctestBit eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$cshiftL eta_B2 eta_B1;

Data.Bits.$fBitsBool_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1H5q eta1_s1H5r]
        case eta_s1H5q of {
          GHC.Types.False ->
              case eta1_s1H5r of {
                GHC.Types.I# ds_s1H5u [Occ=Once!] ->
                    case ds_s1H5u of {
                      __DEFAULT -> GHC.Types.False [];
                      0# -> GHC.Types.True [];
                    };
              };
          GHC.Types.True ->
              case eta1_s1H5r of {
                GHC.Types.I# ds_s1H5x [Occ=Once!] ->
                    case ds_s1H5x of {
                      __DEFAULT -> GHC.Types.True [];
                      0# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsBool_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1H5z eta1_s1H5A]
        case eta_s1H5z of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True ->
              case eta1_s1H5A of {
                GHC.Types.I# ds_s1H5D [Occ=Once!] ->
                    case ds_s1H5D of {
                      __DEFAULT -> GHC.Types.True [];
                      0# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsBool_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1H5F eta1_s1H5G]
        case eta_s1H5F of {
          GHC.Types.False -> Data.Bits.$fBitsBool_$cbit eta1_s1H5G;
          GHC.Types.True -> GHC.Types.True [];
        };

Data.Bits.$fBitsBool_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Types.Bool
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Classes.$fEqBool
                                     GHC.Classes.&&
                                     GHC.Classes.||
                                     GHC.Classes.$fEqBool_$c/=
                                     GHC.Classes.not
                                     Data.Bits.$fBitsBool_$ctestBit
                                     Data.Bits.$fBitsBool_$crotate
                                     GHC.Types.False
                                     Data.Bits.$fBitsBool_$cbit
                                     Data.Bits.$fBitsBool_$csetBit
                                     Data.Bits.$fBitsBool_$cclearBit
                                     Data.Bits.$fBitsBool_$ccomplementBit
                                     Data.Bits.$fBitsBool_$ctestBit
                                     Data.Bits.$fBitsBool_$cbitSizeMaybe
                                     Data.Bits.$fBitsBool_$cbitSize
                                     Data.Bits.$fBitsBool_$cisSigned
                                     Data.Bits.$fBitsBool_$cshiftL
                                     Data.Bits.$fBitsBool_$cunsafeShiftL
                                     Data.Bits.$fBitsBool_$cshiftR
                                     Data.Bits.$fBitsBool_$cunsafeShiftR
                                     Data.Bits.$fBitsBool_$crotateL
                                     Data.Bits.$fBitsBool_$crotateR
                                     Data.Bits.$fBitsBool_$cpopCount];

Data.Bits.$fFiniteBitsBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.FiniteBits GHC.Types.Bool
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bits.C:FiniteBits! [Data.Bits.$fBitsBool
                                           Data.Bits.$fBitsBool_$cbitSize
                                           Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros
                                           Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros];

Data.Bits.$dmrotate
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),1*C1(C1(U)),A)><L,U><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H5I x_s1H5J i_s1H5K]
        case i_s1H5K of wild_s1H5L {
          GHC.Types.I# x1_s1H5M ->
              case <# [x1_s1H5M 0#] of {
                __DEFAULT ->
                    case ># [x1_s1H5M 0#] of {
                      __DEFAULT -> x_s1H5J;
                      1# -> Data.Bits.rotateL $dBits_s1H5I x_s1H5J wild_s1H5L;
                    };
                1# ->
                    case negateInt# [x1_s1H5M] of sat_s1H5P {
                      __DEFAULT ->
                          let {
                            sat_s1H5Q [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [sat_s1H5P];
                          } in  Data.Bits.rotateR $dBits_s1H5I x_s1H5J sat_s1H5Q;
                    };
              };
        };

Data.Bits.$dmshift
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,1*C1(C1(U)),A,A,A,A)><L,U><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H5R x_s1H5S i_s1H5T]
        case i_s1H5T of wild_s1H5U {
          GHC.Types.I# x1_s1H5V ->
              case <# [x1_s1H5V 0#] of {
                __DEFAULT ->
                    case ># [x1_s1H5V 0#] of {
                      __DEFAULT -> x_s1H5S;
                      1# -> Data.Bits.shiftL $dBits_s1H5R x_s1H5S wild_s1H5U;
                    };
                1# ->
                    case negateInt# [x1_s1H5V] of sat_s1H5Y {
                      __DEFAULT ->
                          let {
                            sat_s1H5Z [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [sat_s1H5Y];
                          } in  Data.Bits.shiftR $dBits_s1H5R x_s1H5S sat_s1H5Z;
                    };
              };
        };

Data.Bits.bitDefault [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     GHC.Types.Int -> a
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLLLLLLLLLC(C(S))LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H60 $dNum_s1H61 i_s1H62]
        let {
          sat_s1H63 [Occ=Once] :: a_a1AlX
          [LclId] =
              [$dNum_s1H61] \u []
                  GHC.Num.fromInteger $dNum_s1H61 Data.Bits.$fBitsInteger3;
        } in  Data.Bits.shiftL $dBits_s1H60 sat_s1H63 i_s1H62;

Data.Bits.testBitDefault [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     a -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<S(S(LC(C(S)))LLLLLLLLLLLLLLLLLLLLLL),U(1*U(A,1*C1(C1(U))),1*C1(C1(U)),A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H64 $dNum_s1H65 eta_s1H66 eta1_s1H67]
        let {
          sat_s1H6b [Occ=Once] :: a_a1AlK
          [LclId] =
              [$dNum_s1H65] \u []
                  GHC.Num.fromInteger
                      $dNum_s1H65 Data.Bits.$fBitsInteger_$czeroBits; } in
        let {
          sat_s1H6a [Occ=Once] :: a_a1AlK
          [LclId] =
              [$dBits_s1H64 eta_s1H66 eta1_s1H67] \u []
                  let {
                    sat_s1H69 [Occ=Once] :: a_a1AlK
                    [LclId] =
                        [$dBits_s1H64 eta1_s1H67] \u []
                            Data.Bits.bit $dBits_s1H64 eta1_s1H67;
                  } in  Data.Bits..&. $dBits_s1H64 eta_s1H66 sat_s1H69;
        } in 
          case Data.Bits.$p1Bits $dBits_s1H64 of sat_s1H68 {
            __DEFAULT -> GHC.Classes./= sat_s1H68 sat_s1H6a sat_s1H6b;
          };

Data.Bits.$fBitsInt2 :: GHC.Base.Maybe GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [Data.Bits.$fBitsInt1];

Data.Bits.$fBitsWord_$cbitSizeMaybe
  :: GHC.Types.Word -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m2, Unf=OtherCon []] =
    [] \r [i_s1H6c] Data.Bits.$fBitsInt2;

Data.Bits.$fBitsWord_$cbit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [i_s1H6d]
        case i_s1H6d of {
          GHC.Types.I# i#_s1H6f ->
              case >=# [i#_s1H6f 64#] of {
                __DEFAULT ->
                    case uncheckedShiftL# [1## i#_s1H6f] of sat_s1H6h {
                      __DEFAULT -> GHC.Types.W# [sat_s1H6h];
                    };
                1# -> Data.Bits.$fBitsWord1;
              };
        };

Data.Bits.$fBitsWord_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1H6i i_s1H6j]
        case x_s1H6i of {
          GHC.Types.W# x#_s1H6l [Occ=Once] ->
              case i_s1H6j of {
                GHC.Types.I# i#_s1H6n ->
                    case >=# [i#_s1H6n 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1H6n] of sat_s1H6p {
                            __DEFAULT ->
                                case and# [x#_s1H6l sat_s1H6p] of {
                                  __DEFAULT -> GHC.Types.True [];
                                  0## -> GHC.Types.False [];
                                };
                          };
                      1# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsWord_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H6r eta1_s1H6s]
        case eta_s1H6r of wild_s1H6t {
          GHC.Types.W# x#_s1H6u ->
              case eta1_s1H6s of {
                GHC.Types.I# x_s1H6w [Occ=Once] ->
                    case negateInt# [x_s1H6w] of sat_s1H6x {
                      __DEFAULT ->
                          case andI# [sat_s1H6x 63#] of wild2_s1H6y {
                            __DEFAULT ->
                                case -# [64# wild2_s1H6y] of sat_s1H6A {
                                  __DEFAULT ->
                                      case uncheckedShiftRL# [x#_s1H6u sat_s1H6A] of sat_s1H6B {
                                        __DEFAULT ->
                                            case
                                                uncheckedShiftL# [x#_s1H6u wild2_s1H6y]
                                            of
                                            sat_s1H6z
                                            { __DEFAULT ->
                                                  case or# [sat_s1H6z sat_s1H6B] of sat_s1H6C {
                                                    __DEFAULT -> GHC.Types.W# [sat_s1H6C];
                                                  };
                                            };
                                      };
                                };
                            0# -> wild_s1H6t;
                          };
                    };
              };
        };

Data.Bits.$fBitsWord_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H6D eta1_s1H6E]
        case eta_s1H6D of wild_s1H6F {
          GHC.Types.W# x#_s1H6G [Occ=Once] ->
              case eta1_s1H6E of {
                GHC.Types.I# i#_s1H6I ->
                    case >=# [i#_s1H6I 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1H6I] of sat_s1H6K {
                            __DEFAULT ->
                                case xor# [x#_s1H6G sat_s1H6K] of sat_s1H6L {
                                  __DEFAULT -> GHC.Types.W# [sat_s1H6L];
                                };
                          };
                      1# -> wild_s1H6F;
                    };
              };
        };

Data.Bits.$fBitsWord_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H6M eta1_s1H6N]
        case eta_s1H6M of {
          GHC.Types.W# x#_s1H6P [Occ=Once*] ->
              case eta1_s1H6N of {
                GHC.Types.I# i#_s1H6R ->
                    case >=# [i#_s1H6R 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1H6R] of sat_s1H6T {
                            __DEFAULT ->
                                case xor# [sat_s1H6T 18446744073709551615##] of sat_s1H6U {
                                  __DEFAULT ->
                                      case and# [x#_s1H6P sat_s1H6U] of sat_s1H6V {
                                        __DEFAULT -> GHC.Types.W# [sat_s1H6V];
                                      };
                                };
                          };
                      1# ->
                          case and# [x#_s1H6P 18446744073709551615##] of sat_s1H6W {
                            __DEFAULT -> GHC.Types.W# [sat_s1H6W];
                          };
                    };
              };
        };

Data.Bits.$fBitsWord_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H6X eta1_s1H6Y]
        case eta_s1H6X of wild_s1H6Z {
          GHC.Types.W# x#_s1H70 [Occ=Once] ->
              case eta1_s1H6Y of {
                GHC.Types.I# i#_s1H72 ->
                    case >=# [i#_s1H72 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1H72] of sat_s1H74 {
                            __DEFAULT ->
                                case or# [x#_s1H70 sat_s1H74] of sat_s1H75 {
                                  __DEFAULT -> GHC.Types.W# [sat_s1H75];
                                };
                          };
                      1# -> wild_s1H6Z;
                    };
              };
        };

Data.Bits.$fBitsWord_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsWord_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Types.Word
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Classes.$fEqWord
                                     Data.Bits.$fBitsWord_$c.&.
                                     Data.Bits.$fBitsWord_$c.|.
                                     Data.Bits.$fBitsWord_$cxor
                                     Data.Bits.$fBitsWord_$ccomplement
                                     Data.Bits.$fBitsWord_$cshift
                                     Data.Bits.$fBitsWord_$crotate
                                     Data.Bits.$fBitsWord1
                                     Data.Bits.$fBitsWord_$cbit
                                     Data.Bits.$fBitsWord_$csetBit
                                     Data.Bits.$fBitsWord_$cclearBit
                                     Data.Bits.$fBitsWord_$ccomplementBit
                                     Data.Bits.$fBitsWord_$ctestBit
                                     Data.Bits.$fBitsWord_$cbitSizeMaybe
                                     Data.Bits.$fBitsWord_$cfiniteBitSize
                                     Data.Bits.$fBitsWord_$cisSigned
                                     Data.Bits.$fBitsWord_$cshiftL
                                     Data.Bits.$fBitsWord_$cunsafeShiftL
                                     Data.Bits.$fBitsWord_$cshiftR
                                     Data.Bits.$fBitsWord_$cunsafeShiftR
                                     Data.Bits.$fBitsWord_$crotateL
                                     Data.Bits.$fBitsWord_$crotateR
                                     Data.Bits.$fBitsWord_$cpopCount];

Data.Bits.$fFiniteBitsWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.FiniteBits GHC.Types.Word
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bits.C:FiniteBits! [Data.Bits.$fBitsWord
                                           Data.Bits.$fBitsWord_$cfiniteBitSize
                                           Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros
                                           Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros];

Data.Bits.$fBitsInt_$cbitSizeMaybe
  :: GHC.Types.Int -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m2, Unf=OtherCon []] =
    [] \r [i_s1H76] Data.Bits.$fBitsInt2;

Data.Bits.$fBitsInt_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsInt_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsInt_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H77 eta1_s1H78]
        case eta_s1H77 of {
          GHC.Types.I# x#_s1H7a ->
              case eta1_s1H78 of {
                GHC.Types.I# x_s1H7c [Occ=Once] ->
                    case negateInt# [x_s1H7c] of sat_s1H7e {
                      __DEFAULT ->
                          case andI# [sat_s1H7e 63#] of i'#_s1H7d [Dmd=<S,U>] {
                            __DEFAULT ->
                                case -# [64# i'#_s1H7d] of sat_s1H7g {
                                  __DEFAULT ->
                                      case uncheckedIShiftRL# [x#_s1H7a sat_s1H7g] of sat_s1H7h {
                                        __DEFAULT ->
                                            case
                                                uncheckedIShiftL# [x#_s1H7a i'#_s1H7d]
                                            of
                                            sat_s1H7f
                                            { __DEFAULT ->
                                                  case orI# [sat_s1H7f sat_s1H7h] of sat_s1H7i {
                                                    __DEFAULT -> GHC.Types.I# [sat_s1H7i];
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cbit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [i_s1H7j]
        case i_s1H7j of {
          GHC.Types.I# i#_s1H7l ->
              case >=# [i#_s1H7l 64#] of {
                __DEFAULT ->
                    case uncheckedIShiftL# [1# i#_s1H7l] of sat_s1H7n {
                      __DEFAULT -> GHC.Types.I# [sat_s1H7n];
                    };
                1# -> Data.Bits.$fBitsBool2;
              };
        };

Data.Bits.$fBitsInt_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1H7o i_s1H7p]
        case x_s1H7o of {
          GHC.Types.I# x#_s1H7r [Occ=Once] ->
              case i_s1H7p of {
                GHC.Types.I# i#_s1H7t ->
                    case >=# [i#_s1H7t 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1H7t] of sat_s1H7v {
                            __DEFAULT ->
                                case andI# [x#_s1H7r sat_s1H7v] of {
                                  __DEFAULT -> GHC.Types.True [];
                                  0# -> GHC.Types.False [];
                                };
                          };
                      1# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsInt_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H7x eta1_s1H7y]
        case eta_s1H7x of wild_s1H7z {
          GHC.Types.I# x#_s1H7A [Occ=Once] ->
              case eta1_s1H7y of {
                GHC.Types.I# i#_s1H7C ->
                    case >=# [i#_s1H7C 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1H7C] of sat_s1H7E {
                            __DEFAULT ->
                                case orI# [x#_s1H7A sat_s1H7E] of sat_s1H7F {
                                  __DEFAULT -> GHC.Types.I# [sat_s1H7F];
                                };
                          };
                      1# -> wild_s1H7z;
                    };
              };
        };

Data.Bits.$fBitsInt_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H7G eta1_s1H7H]
        case eta_s1H7G of {
          GHC.Types.I# x#_s1H7J [Occ=Once*] ->
              case eta1_s1H7H of {
                GHC.Types.I# i#_s1H7L ->
                    case >=# [i#_s1H7L 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1H7L] of sat_s1H7N {
                            __DEFAULT ->
                                case notI# [sat_s1H7N] of sat_s1H7O {
                                  __DEFAULT ->
                                      case andI# [x#_s1H7J sat_s1H7O] of sat_s1H7P {
                                        __DEFAULT -> GHC.Types.I# [sat_s1H7P];
                                      };
                                };
                          };
                      1# ->
                          case andI# [x#_s1H7J -1#] of sat_s1H7Q {
                            __DEFAULT -> GHC.Types.I# [sat_s1H7Q];
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H7R eta1_s1H7S]
        case eta_s1H7R of wild_s1H7T {
          GHC.Types.I# x#_s1H7U [Occ=Once] ->
              case eta1_s1H7S of {
                GHC.Types.I# i#_s1H7W ->
                    case >=# [i#_s1H7W 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1H7W] of sat_s1H7Y {
                            __DEFAULT ->
                                case xorI# [x#_s1H7U sat_s1H7Y] of sat_s1H7Z {
                                  __DEFAULT -> GHC.Types.I# [sat_s1H7Z];
                                };
                          };
                      1# -> wild_s1H7T;
                    };
              };
        };

Data.Bits.$fBitsInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Types.Int
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Classes.$fEqInt
                                     Data.Bits.$fBitsInt_$c.&.
                                     Data.Bits.$fBitsInt_$c.|.
                                     Data.Bits.$fBitsInt_$cxor
                                     Data.Bits.$fBitsInt_$ccomplement
                                     Data.Bits.$fBitsInt_$cshift
                                     Data.Bits.$fBitsInt_$crotate
                                     Data.Bits.$fBitsBool2
                                     Data.Bits.$fBitsInt_$cbit
                                     Data.Bits.$fBitsInt_$csetBit
                                     Data.Bits.$fBitsInt_$cclearBit
                                     Data.Bits.$fBitsInt_$ccomplementBit
                                     Data.Bits.$fBitsInt_$ctestBit
                                     Data.Bits.$fBitsInt_$cbitSizeMaybe
                                     Data.Bits.$fBitsInt_$cfiniteBitSize
                                     Data.Bits.$fBitsInt_$cisSigned
                                     Data.Bits.$fBitsInt_$cshiftL
                                     Data.Bits.$fBitsInt_$cunsafeShiftL
                                     Data.Bits.$fBitsInt_$cshiftR
                                     Data.Bits.$fBitsInt_$cunsafeShiftR
                                     Data.Bits.$fBitsInt_$crotateL
                                     Data.Bits.$fBitsInt_$crotateR
                                     Data.Bits.$fBitsInt_$cpopCount];

Data.Bits.$fFiniteBitsInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.FiniteBits GHC.Types.Int
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bits.C:FiniteBits! [Data.Bits.$fBitsInt
                                           Data.Bits.$fBitsInt_$cfiniteBitSize
                                           Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros
                                           Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros];

Data.Bits.$wpopCountDefault [InlPrag=INLINABLE[0]]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     a -> GHC.Prim.Int#
[GblId,
 Arity=3,
 Str=<S(S(C(C(S))L)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1H80 w1_s1H81 w2_s1H82]
        let {
          lvl1_s1H83 [Occ=OnceL] :: a_s1C1X
          [LclId] =
              [w1_s1H81] \u []
                  GHC.Num.fromInteger w1_s1H81 Data.Bits.$fBitsInteger3; } in
        let {
          lvl2_s1H84 [Occ=OnceL] :: a_s1C1X
          [LclId] =
              [w1_s1H81] \u []
                  GHC.Num.fromInteger w1_s1H81 Data.Bits.$fBitsInteger_$czeroBits;
        } in 
          case
              Data.Bits.$p1Bits w_s1H80
          of
          $dEq_s1H85 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
          { __DEFAULT ->
                let-no-escape {
                  $wgo_s1H86 [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[2]]
                    :: GHC.Prim.Int# -> a_s1C1X -> GHC.Prim.Int#
                  [LclId[JoinId(2)], Arity=2, Str=<S,U><L,U>, Unf=OtherCon []] =
                      sat-only [w_s1H80
                                w1_s1H81
                                lvl1_s1H83
                                lvl2_s1H84
                                $dEq_s1H85
                                $wgo_s1H86] \r [ww_s1H87 w3_s1H88]
                          case GHC.Classes.== $dEq_s1H85 w3_s1H88 lvl2_s1H84 of {
                            GHC.Types.False ->
                                let {
                                  sat_s1H8c [Occ=Once] :: a_s1C1X
                                  [LclId] =
                                      [w_s1H80 w1_s1H81 lvl1_s1H83 w3_s1H88] \u []
                                          let {
                                            sat_s1H8b [Occ=Once] :: a_s1C1X
                                            [LclId] =
                                                [w1_s1H81 lvl1_s1H83 w3_s1H88] \u []
                                                    GHC.Num.- w1_s1H81 w3_s1H88 lvl1_s1H83;
                                          } in  Data.Bits..&. w_s1H80 w3_s1H88 sat_s1H8b;
                                } in 
                                  case +# [ww_s1H87 1#] of sat_s1H8a {
                                    __DEFAULT -> $wgo_s1H86 sat_s1H8a sat_s1H8c;
                                  };
                            GHC.Types.True -> ww_s1H87;
                          };
                } in  $wgo_s1H86 0# w2_s1H82;
          };

Data.Bits.popCountDefault [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<S(S(C(C(S))L)LLLLLLLLLLLLLLLLLLLLLL),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,C(U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1H8d w1_s1H8e w2_s1H8f]
        case
            Data.Bits.$wpopCountDefault w_s1H8d w1_s1H8e w2_s1H8f
        of
        ww_s1H8g
        { __DEFAULT -> GHC.Types.I# [ww_s1H8g];
        };

Data.Bits.$fBitsInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Integer.Type.Integer
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Integer.Type.$fEqInteger
                                     GHC.Integer.Type.andInteger
                                     GHC.Integer.Type.orInteger
                                     GHC.Integer.Type.xorInteger
                                     GHC.Integer.Type.complementInteger
                                     Data.Bits.$fBitsInteger_$cshift
                                     Data.Bits.$fBitsInteger_$cshift
                                     Data.Bits.$fBitsInteger_$czeroBits
                                     Data.Bits.$fBitsInteger_$cbit
                                     Data.Bits.$fBitsInteger_$csetBit
                                     Data.Bits.$fBitsInteger_$cclearBit
                                     Data.Bits.$fBitsInteger_$ccomplementBit
                                     Data.Bits.$fBitsInteger_$ctestBit
                                     Data.Bits.$fBitsInteger_$cbitSizeMaybe
                                     Data.Bits.$fBitsInteger_$cbitSize
                                     Data.Bits.$fBitsInteger_$cisSigned
                                     Data.Bits.$fBitsInteger_$cshiftL
                                     Data.Bits.$fBitsInteger_$cunsafeShiftL
                                     Data.Bits.$fBitsInteger_$cshiftR
                                     Data.Bits.$fBitsInteger_$cunsafeShiftR
                                     Data.Bits.$fBitsInteger_$crotateL
                                     Data.Bits.$fBitsInteger_$crotateR
                                     Data.Bits.$fBitsInteger_$cpopCount];
Data.Bits.$fBitsInteger_$cpopCount [Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer -> GHC.Types.Int
[GblId, Arity=1, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_s1H8h]
        case
            Data.Bits.$wpopCountDefault
                Data.Bits.$fBitsInteger GHC.Num.$fNumInteger w_s1H8h
        of
        ww_s1H8i
        { __DEFAULT -> GHC.Types.I# [ww_s1H8i];
        };

Data.Bits.toIntegralSized [InlPrag=INLINABLE]
  :: forall a b.
     (GHC.Real.Integral a, GHC.Real.Integral b, Data.Bits.Bits a,
      Data.Bits.Bits b) =>
     a -> GHC.Base.Maybe b
[GblId,
 Arity=5,
 Str=<L,U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U)),1*U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,1*C1(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(LLLLLLLLLLLLLC(S)LLLLLLLLL),U(A,A,A,A,A,A,A,A,C(U),A,A,A,A,1*C1(U),A,1*C1(U),A,A,A,A,A,A,A)><S(LLLLLLLLLLLLLC(S)LC(S)LLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,1*C1(U),A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1H8j
           $dIntegral1_s1H8k
           $dBits_s1H8l
           $dBits1_s1H8m
           eta_s1H8n]
        case
            Data.Bits.bitSizeMaybe $dBits_s1H8l eta_s1H8n
        of
        xWidth_s1H8o [Dmd=<S,U>]
        { __DEFAULT ->
              let {
                y_s1H8p :: b_a1AhY
                [LclId] =
                    [$dIntegral_s1H8j $dIntegral1_s1H8k eta_s1H8n] \u []
                        let {
                          sat_s1H8s [Occ=Once] :: GHC.Integer.Type.Integer
                          [LclId] =
                              [$dIntegral_s1H8j eta_s1H8n] \u []
                                  GHC.Real.toInteger $dIntegral_s1H8j eta_s1H8n;
                        } in 
                          case GHC.Real.$p1Integral $dIntegral1_s1H8k of sat_s1H8q {
                            __DEFAULT ->
                                case GHC.Real.$p1Real sat_s1H8q of sat_s1H8r {
                                  __DEFAULT -> GHC.Num.fromInteger sat_s1H8r sat_s1H8s;
                                };
                          };
              } in 
                case
                    Data.Bits.isSigned $dBits1_s1H8m y_s1H8p
                of
                ySigned_s1H8t [Dmd=<S,U>]
                { __DEFAULT ->
                      case
                          Data.Bits.bitSizeMaybe $dBits1_s1H8m y_s1H8p
                      of
                      yWidth_s1H8u [Dmd=<S,U>]
                      { __DEFAULT ->
                            let {
                              xSigned_s1H8v :: GHC.Types.Bool
                              [LclId] =
                                  [$dBits_s1H8l eta_s1H8n] \u []
                                      Data.Bits.isSigned $dBits_s1H8l eta_s1H8n; } in
                            let {
                              $dReal_s1H8w [Dmd=<L,U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U)),1*U(A,A,A,C(C1(U)),A,A,A,A),A)>]
                                :: GHC.Real.Real a_a1AhX
                              [LclId] =
                                  [$dIntegral_s1H8j] \u []
                                      GHC.Real.$p1Integral $dIntegral_s1H8j; } in
                            let {
                              $dNum_s1H8x [Dmd=<L,U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U))>]
                                :: GHC.Num.Num a_a1AhX
                              [LclId] =
                                  [$dReal_s1H8w] \u [] GHC.Real.$p1Real $dReal_s1H8w; } in
                            let {
                              $dOrd_s1H8y [Dmd=<L,U(A,A,A,C(C1(U)),A,A,A,A)>]
                                :: GHC.Classes.Ord a_a1AhX
                              [LclId] =
                                  [$dReal_s1H8w] \u [] GHC.Real.$p2Real $dReal_s1H8w;
                            } in 
                              let-no-escape {
                                $j_s1H8z [Dmd=<L,1*U>] :: GHC.Base.Maybe b_a1AhY
                                [LclId[JoinId(0)], Unf=OtherCon []] =
                                    [$dBits_s1H8l
                                     eta_s1H8n
                                     xWidth_s1H8o
                                     y_s1H8p
                                     ySigned_s1H8t
                                     yWidth_s1H8u
                                     xSigned_s1H8v
                                     $dNum_s1H8x
                                     $dOrd_s1H8y] \r []
                                        let-no-escape {
                                          fail_s1H8A [Dmd=<L,1*C1(U)>]
                                            :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                              sat-only [$dBits_s1H8l
                                                        eta_s1H8n
                                                        xWidth_s1H8o
                                                        y_s1H8p
                                                        ySigned_s1H8t
                                                        yWidth_s1H8u
                                                        xSigned_s1H8v
                                                        $dNum_s1H8x
                                                        $dOrd_s1H8y] \r [ds_s1H8B]
                                                  let-no-escape {
                                                    fail1_s1H8C [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                                      :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                                    [LclId[JoinId(1)],
                                                     Arity=1,
                                                     Str=<L,A>,
                                                     Unf=OtherCon []] =
                                                        sat-only [$dBits_s1H8l
                                                                  eta_s1H8n
                                                                  xWidth_s1H8o
                                                                  y_s1H8p
                                                                  ySigned_s1H8t
                                                                  yWidth_s1H8u
                                                                  xSigned_s1H8v
                                                                  $dNum_s1H8x
                                                                  $dOrd_s1H8y] \r [ds1_s1H8D]
                                                            let-no-escape {
                                                              fail2_s1H8E [Occ=Once*!T[1],
                                                                           Dmd=<L,1*C1(U)>]
                                                                :: GHC.Prim.Void#
                                                                   -> GHC.Base.Maybe b_a1AhY
                                                              [LclId[JoinId(1)],
                                                               Arity=1,
                                                               Str=<L,A>,
                                                               Unf=OtherCon []] =
                                                                  sat-only [$dBits_s1H8l
                                                                            eta_s1H8n
                                                                            xWidth_s1H8o
                                                                            y_s1H8p
                                                                            ySigned_s1H8t
                                                                            yWidth_s1H8u
                                                                            xSigned_s1H8v
                                                                            $dNum_s1H8x
                                                                            $dOrd_s1H8y] \r [ds2_s1H8F]
                                                                      let-no-escape {
                                                                        $j1_s1H8G [Dmd=<L,1*U>]
                                                                          :: GHC.Base.Maybe b_a1AhY
                                                                        [LclId[JoinId(0)],
                                                                         Unf=OtherCon []] =
                                                                            [$dBits_s1H8l
                                                                             eta_s1H8n
                                                                             xWidth_s1H8o
                                                                             y_s1H8p
                                                                             ySigned_s1H8t
                                                                             yWidth_s1H8u
                                                                             xSigned_s1H8v
                                                                             $dNum_s1H8x
                                                                             $dOrd_s1H8y] \r []
                                                                                let-no-escape {
                                                                                  fail3_s1H8H [Occ=Once*!T[1],
                                                                                               Dmd=<L,1*C1(U)>]
                                                                                    :: GHC.Prim.Void#
                                                                                       -> GHC.Base.Maybe
                                                                                            b_a1AhY
                                                                                  [LclId[JoinId(1)],
                                                                                   Arity=1,
                                                                                   Str=<L,A>,
                                                                                   Unf=OtherCon []] =
                                                                                      sat-only [$dBits_s1H8l
                                                                                                eta_s1H8n
                                                                                                y_s1H8p
                                                                                                ySigned_s1H8t
                                                                                                yWidth_s1H8u
                                                                                                $dNum_s1H8x
                                                                                                $dOrd_s1H8y] \r [ds3_s1H8I]
                                                                                          case
                                                                                              yWidth_s1H8u
                                                                                          of
                                                                                          { GHC.Base.Nothing ->
                                                                                                GHC.Base.Just [y_s1H8p];
                                                                                            GHC.Base.Just yW_s1H8K [Occ=Once*] ->
                                                                                                case
                                                                                                    ySigned_s1H8t
                                                                                                of
                                                                                                { GHC.Types.False ->
                                                                                                      let {
                                                                                                        sat_s1H8O [Occ=Once]
                                                                                                          :: a_a1AhX
                                                                                                        [LclId] =
                                                                                                            [$dBits_s1H8l
                                                                                                             $dNum_s1H8x
                                                                                                             yW_s1H8K] \u []
                                                                                                                let {
                                                                                                                  sat_s1H8N [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dNum_s1H8x] \u []
                                                                                                                          GHC.Num.fromInteger
                                                                                                                              $dNum_s1H8x
                                                                                                                              Data.Bits.$fBitsInteger3; } in
                                                                                                                let {
                                                                                                                  sat_s1H8M [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dBits_s1H8l
                                                                                                                       yW_s1H8K] \u []
                                                                                                                          Data.Bits.bit
                                                                                                                              $dBits_s1H8l
                                                                                                                              yW_s1H8K;
                                                                                                                } in 
                                                                                                                  GHC.Num.-
                                                                                                                      $dNum_s1H8x
                                                                                                                      sat_s1H8M
                                                                                                                      sat_s1H8N;
                                                                                                      } in 
                                                                                                        case
                                                                                                            GHC.Classes.<=
                                                                                                                $dOrd_s1H8y
                                                                                                                eta_s1H8n
                                                                                                                sat_s1H8O
                                                                                                        of
                                                                                                        { GHC.Types.False ->
                                                                                                              GHC.Base.Nothing [];
                                                                                                          GHC.Types.True ->
                                                                                                              GHC.Base.Just [y_s1H8p];
                                                                                                        };
                                                                                                  GHC.Types.True ->
                                                                                                      let {
                                                                                                        sat_s1H8W [Occ=Once]
                                                                                                          :: a_a1AhX
                                                                                                        [LclId] =
                                                                                                            [$dBits_s1H8l
                                                                                                             $dNum_s1H8x
                                                                                                             yW_s1H8K] \u []
                                                                                                                let {
                                                                                                                  sat_s1H8V [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dNum_s1H8x] \u []
                                                                                                                          GHC.Num.fromInteger
                                                                                                                              $dNum_s1H8x
                                                                                                                              Data.Bits.$fBitsInteger3; } in
                                                                                                                let {
                                                                                                                  sat_s1H8U [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dBits_s1H8l
                                                                                                                       yW_s1H8K] \u []
                                                                                                                          let {
                                                                                                                            sat_s1H8T [Occ=Once]
                                                                                                                              :: GHC.Types.Int
                                                                                                                            [LclId] =
                                                                                                                                [yW_s1H8K] \u []
                                                                                                                                    case
                                                                                                                                        yW_s1H8K
                                                                                                                                    of
                                                                                                                                    { GHC.Types.I# x_s1H8R [Occ=Once] ->
                                                                                                                                          case
                                                                                                                                              -# [x_s1H8R
                                                                                                                                                  1#]
                                                                                                                                          of
                                                                                                                                          sat_s1H8S
                                                                                                                                          { __DEFAULT ->
                                                                                                                                                GHC.Types.I# [sat_s1H8S];
                                                                                                                                          };
                                                                                                                                    };
                                                                                                                          } in 
                                                                                                                            Data.Bits.bit
                                                                                                                                $dBits_s1H8l
                                                                                                                                sat_s1H8T;
                                                                                                                } in 
                                                                                                                  GHC.Num.-
                                                                                                                      $dNum_s1H8x
                                                                                                                      sat_s1H8U
                                                                                                                      sat_s1H8V;
                                                                                                      } in 
                                                                                                        case
                                                                                                            GHC.Classes.<=
                                                                                                                $dOrd_s1H8y
                                                                                                                eta_s1H8n
                                                                                                                sat_s1H8W
                                                                                                        of
                                                                                                        { GHC.Types.False ->
                                                                                                              GHC.Base.Nothing [];
                                                                                                          GHC.Types.True ->
                                                                                                              GHC.Base.Just [y_s1H8p];
                                                                                                        };
                                                                                                };
                                                                                          };
                                                                                } in 
                                                                                  case
                                                                                      xSigned_s1H8v
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        fail3_s1H8H
                                                                                            GHC.Prim.void#;
                                                                                    GHC.Types.True ->
                                                                                        case
                                                                                            ySigned_s1H8t
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              case
                                                                                                  xWidth_s1H8o
                                                                                              of
                                                                                              { GHC.Base.Nothing ->
                                                                                                    fail3_s1H8H
                                                                                                        GHC.Prim.void#;
                                                                                                GHC.Base.Just xW_s1H91 [Occ=Once!] ->
                                                                                                    case
                                                                                                        yWidth_s1H8u
                                                                                                    of
                                                                                                    { GHC.Base.Nothing ->
                                                                                                          fail3_s1H8H
                                                                                                              GHC.Prim.void#;
                                                                                                      GHC.Base.Just yW_s1H93 [Occ=Once!] ->
                                                                                                          case
                                                                                                              yW_s1H93
                                                                                                          of
                                                                                                          { GHC.Types.I# x_s1H95 [Occ=Once] ->
                                                                                                                case
                                                                                                                    xW_s1H91
                                                                                                                of
                                                                                                                { GHC.Types.I# x1_s1H97 [Occ=Once] ->
                                                                                                                      case
                                                                                                                          +# [x_s1H95
                                                                                                                              1#]
                                                                                                                      of
                                                                                                                      sat_s1H98
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                <=# [x1_s1H97
                                                                                                                                     sat_s1H98]
                                                                                                                            of
                                                                                                                            { __DEFAULT ->
                                                                                                                                  fail3_s1H8H
                                                                                                                                      GHC.Prim.void#;
                                                                                                                              1# ->
                                                                                                                                  GHC.Base.Just [y_s1H8p];
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                          GHC.Types.True ->
                                                                                              fail3_s1H8H
                                                                                                  GHC.Prim.void#;
                                                                                        };
                                                                                  };
                                                                      } in 
                                                                        let-no-escape {
                                                                          fail3_s1H9a [Dmd=<L,1*C1(U)>]
                                                                            :: GHC.Prim.Void#
                                                                               -> GHC.Base.Maybe
                                                                                    b_a1AhY
                                                                          [LclId[JoinId(1)],
                                                                           Arity=1,
                                                                           Str=<L,A>,
                                                                           Unf=OtherCon []] =
                                                                              sat-only [xWidth_s1H8o
                                                                                        y_s1H8p
                                                                                        ySigned_s1H8t
                                                                                        yWidth_s1H8u
                                                                                        xSigned_s1H8v
                                                                                        $j1_s1H8G] \r [ds3_s1H9b]
                                                                                  case
                                                                                      xSigned_s1H8v
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        case
                                                                                            ySigned_s1H8t
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              $j1_s1H8G;
                                                                                          GHC.Types.True ->
                                                                                              case
                                                                                                  xWidth_s1H8o
                                                                                              of
                                                                                              { GHC.Base.Nothing ->
                                                                                                    $j1_s1H8G;
                                                                                                GHC.Base.Just xW_s1H9f [Occ=Once!] ->
                                                                                                    case
                                                                                                        yWidth_s1H8u
                                                                                                    of
                                                                                                    { GHC.Base.Nothing ->
                                                                                                          $j1_s1H8G;
                                                                                                      GHC.Base.Just yW_s1H9h [Occ=Once!] ->
                                                                                                          case
                                                                                                              xW_s1H9f
                                                                                                          of
                                                                                                          { GHC.Types.I# x_s1H9j [Occ=Once] ->
                                                                                                                case
                                                                                                                    yW_s1H9h
                                                                                                                of
                                                                                                                { GHC.Types.I# y1_s1H9l [Occ=Once] ->
                                                                                                                      case
                                                                                                                          <# [x_s1H9j
                                                                                                                              y1_s1H9l]
                                                                                                                      of
                                                                                                                      { __DEFAULT ->
                                                                                                                            $j1_s1H8G;
                                                                                                                        1# ->
                                                                                                                            GHC.Base.Just [y_s1H8p];
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                    GHC.Types.True ->
                                                                                        $j1_s1H8G;
                                                                                  };
                                                                        } in 
                                                                          let-no-escape {
                                                                            $j2_s1H9n [Occ=Once*T[0],
                                                                                       Dmd=<L,1*U>]
                                                                              :: GHC.Base.Maybe
                                                                                   b_a1AhY
                                                                            [LclId[JoinId(0)],
                                                                             Unf=OtherCon []] =
                                                                                [xWidth_s1H8o
                                                                                 y_s1H8p
                                                                                 yWidth_s1H8u
                                                                                 $j1_s1H8G
                                                                                 fail3_s1H9a] \r []
                                                                                    case
                                                                                        xWidth_s1H8o
                                                                                    of
                                                                                    { GHC.Base.Nothing ->
                                                                                          fail3_s1H9a
                                                                                              GHC.Prim.void#;
                                                                                      GHC.Base.Just xW_s1H9p [Occ=Once!] ->
                                                                                          case
                                                                                              yWidth_s1H8u
                                                                                          of
                                                                                          { GHC.Base.Nothing ->
                                                                                                fail3_s1H9a
                                                                                                    GHC.Prim.void#;
                                                                                            GHC.Base.Just yW_s1H9r [Occ=Once!] ->
                                                                                                case
                                                                                                    xW_s1H9p
                                                                                                of
                                                                                                { GHC.Types.I# x_s1H9t [Occ=Once] ->
                                                                                                      case
                                                                                                          yW_s1H9r
                                                                                                      of
                                                                                                      { GHC.Types.I# y1_s1H9v [Occ=Once] ->
                                                                                                            case
                                                                                                                <=# [x_s1H9t
                                                                                                                     y1_s1H9v]
                                                                                                            of
                                                                                                            { __DEFAULT ->
                                                                                                                  $j1_s1H8G;
                                                                                                              1# ->
                                                                                                                  GHC.Base.Just [y_s1H8p];
                                                                                                            };
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                          } in 
                                                                            case xSigned_s1H8v of {
                                                                              GHC.Types.False ->
                                                                                  case
                                                                                      ySigned_s1H8t
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        $j2_s1H9n;
                                                                                    GHC.Types.True ->
                                                                                        fail3_s1H9a
                                                                                            GHC.Prim.void#;
                                                                                  };
                                                                              GHC.Types.True ->
                                                                                  case
                                                                                      ySigned_s1H8t
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        fail3_s1H9a
                                                                                            GHC.Prim.void#;
                                                                                    GHC.Types.True ->
                                                                                        $j2_s1H9n;
                                                                                  };
                                                                            };
                                                            } in 
                                                              case xSigned_s1H8v of {
                                                                GHC.Types.False ->
                                                                    case ySigned_s1H8t of {
                                                                      GHC.Types.False ->
                                                                          case yWidth_s1H8u of {
                                                                            GHC.Base.Nothing ->
                                                                                GHC.Base.Just [y_s1H8p];
                                                                            GHC.Base.Just _ [Occ=Dead] ->
                                                                                fail2_s1H8E
                                                                                    GHC.Prim.void#;
                                                                          };
                                                                      GHC.Types.True ->
                                                                          fail2_s1H8E
                                                                              GHC.Prim.void#;
                                                                    };
                                                                GHC.Types.True ->
                                                                    fail2_s1H8E GHC.Prim.void#;
                                                              };
                                                  } in 
                                                    case ySigned_s1H8t of {
                                                      GHC.Types.False -> fail1_s1H8C GHC.Prim.void#;
                                                      GHC.Types.True ->
                                                          case yWidth_s1H8u of {
                                                            GHC.Base.Nothing ->
                                                                GHC.Base.Just [y_s1H8p];
                                                            GHC.Base.Just _ [Occ=Dead] ->
                                                                fail1_s1H8C GHC.Prim.void#;
                                                          };
                                                    };
                                        } in 
                                          let-no-escape {
                                            $j1_s1H9H [Occ=Once*T[0], Dmd=<L,1*U>]
                                              :: GHC.Base.Maybe b_a1AhY
                                            [LclId[JoinId(0)], Unf=OtherCon []] =
                                                [y_s1H8p
                                                 ySigned_s1H8t
                                                 xSigned_s1H8v
                                                 fail_s1H8A] \r []
                                                    case xSigned_s1H8v of {
                                                      GHC.Types.False ->
                                                          case ySigned_s1H8t of {
                                                            GHC.Types.False ->
                                                                GHC.Base.Just [y_s1H8p];
                                                            GHC.Types.True ->
                                                                fail_s1H8A GHC.Prim.void#;
                                                          };
                                                      GHC.Types.True ->
                                                          case ySigned_s1H8t of {
                                                            GHC.Types.False ->
                                                                fail_s1H8A GHC.Prim.void#;
                                                            GHC.Types.True ->
                                                                GHC.Base.Just [y_s1H8p];
                                                          };
                                                    };
                                          } in 
                                            case xWidth_s1H8o of {
                                              GHC.Base.Nothing ->
                                                  case yWidth_s1H8u of {
                                                    GHC.Base.Nothing -> $j1_s1H9H;
                                                    GHC.Base.Just _ [Occ=Dead] ->
                                                        fail_s1H8A GHC.Prim.void#;
                                                  };
                                              GHC.Base.Just a1_s1H9O [Occ=Once!] ->
                                                  case yWidth_s1H8u of {
                                                    GHC.Base.Nothing -> fail_s1H8A GHC.Prim.void#;
                                                    GHC.Base.Just b1_s1H9Q [Occ=Once!] ->
                                                        case a1_s1H9O of {
                                                          GHC.Types.I# x_s1H9S [Occ=Once] ->
                                                              case b1_s1H9Q of {
                                                                GHC.Types.I# y1_s1H9U [Occ=Once] ->
                                                                    case ==# [x_s1H9S y1_s1H9U] of {
                                                                      __DEFAULT ->
                                                                          fail_s1H8A GHC.Prim.void#;
                                                                      1# -> $j1_s1H9H;
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                              } in 
                                let-no-escape {
                                  fail_s1H9W [Dmd=<L,1*C1(U)>]
                                    :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                  [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                      sat-only [$dBits_s1H8l
                                                eta_s1H8n
                                                xWidth_s1H8o
                                                ySigned_s1H8t
                                                yWidth_s1H8u
                                                xSigned_s1H8v
                                                $dNum_s1H8x
                                                $dOrd_s1H8y
                                                $j_s1H8z] \r [ds_s1H9X]
                                          let-no-escape {
                                            fail1_s1H9Y [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                              :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                            [LclId[JoinId(1)],
                                             Arity=1,
                                             Str=<L,A>,
                                             Unf=OtherCon []] =
                                                sat-only [$dBits_s1H8l
                                                          eta_s1H8n
                                                          xWidth_s1H8o
                                                          ySigned_s1H8t
                                                          yWidth_s1H8u
                                                          xSigned_s1H8v
                                                          $dNum_s1H8x
                                                          $dOrd_s1H8y
                                                          $j_s1H8z] \r [ds1_s1H9Z]
                                                    let-no-escape {
                                                      fail2_s1Ha0 [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                                        :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                                      [LclId[JoinId(1)],
                                                       Arity=1,
                                                       Str=<L,A>,
                                                       Unf=OtherCon []] =
                                                          sat-only [$dBits_s1H8l
                                                                    eta_s1H8n
                                                                    xWidth_s1H8o
                                                                    ySigned_s1H8t
                                                                    yWidth_s1H8u
                                                                    xSigned_s1H8v
                                                                    $dNum_s1H8x
                                                                    $dOrd_s1H8y
                                                                    $j_s1H8z] \r [ds2_s1Ha1]
                                                              let-no-escape {
                                                                $j1_s1Ha2 [Dmd=<L,1*U>]
                                                                  :: GHC.Base.Maybe b_a1AhY
                                                                [LclId[JoinId(0)],
                                                                 Unf=OtherCon []] =
                                                                    [$dBits_s1H8l
                                                                     eta_s1H8n
                                                                     ySigned_s1H8t
                                                                     yWidth_s1H8u
                                                                     xSigned_s1H8v
                                                                     $dNum_s1H8x
                                                                     $dOrd_s1H8y
                                                                     $j_s1H8z] \r []
                                                                        let-no-escape {
                                                                          fail3_s1Ha3 [Occ=Once*!T[1],
                                                                                       Dmd=<L,1*C1(U)>]
                                                                            :: GHC.Prim.Void#
                                                                               -> GHC.Base.Maybe
                                                                                    b_a1AhY
                                                                          [LclId[JoinId(1)],
                                                                           Arity=1,
                                                                           Str=<L,A>,
                                                                           Unf=OtherCon []] =
                                                                              sat-only [$dBits_s1H8l
                                                                                        eta_s1H8n
                                                                                        ySigned_s1H8t
                                                                                        yWidth_s1H8u
                                                                                        xSigned_s1H8v
                                                                                        $dNum_s1H8x
                                                                                        $dOrd_s1H8y
                                                                                        $j_s1H8z] \r [ds3_s1Ha4]
                                                                                  case
                                                                                      xSigned_s1H8v
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        $j_s1H8z;
                                                                                    GHC.Types.True ->
                                                                                        case
                                                                                            ySigned_s1H8t
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              $j_s1H8z;
                                                                                          GHC.Types.True ->
                                                                                              case
                                                                                                  yWidth_s1H8u
                                                                                              of
                                                                                              { GHC.Base.Nothing ->
                                                                                                    $j_s1H8z;
                                                                                                GHC.Base.Just yW_s1Ha8 [Occ=Once!] ->
                                                                                                    let {
                                                                                                      sat_s1Hae [Occ=Once]
                                                                                                        :: a_a1AhX
                                                                                                      [LclId] =
                                                                                                          [$dBits_s1H8l
                                                                                                           $dNum_s1H8x
                                                                                                           yW_s1Ha8] \u []
                                                                                                              let {
                                                                                                                sat_s1Had [Occ=Once]
                                                                                                                  :: a_a1AhX
                                                                                                                [LclId] =
                                                                                                                    [$dBits_s1H8l
                                                                                                                     yW_s1Ha8] \u []
                                                                                                                        let {
                                                                                                                          sat_s1Hac [Occ=Once]
                                                                                                                            :: GHC.Types.Int
                                                                                                                          [LclId] =
                                                                                                                              [yW_s1Ha8] \u []
                                                                                                                                  case
                                                                                                                                      yW_s1Ha8
                                                                                                                                  of
                                                                                                                                  { GHC.Types.I# x_s1Haa [Occ=Once] ->
                                                                                                                                        case
                                                                                                                                            -# [x_s1Haa
                                                                                                                                                1#]
                                                                                                                                        of
                                                                                                                                        sat_s1Hab
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              GHC.Types.I# [sat_s1Hab];
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                        } in 
                                                                                                                          Data.Bits.bit
                                                                                                                              $dBits_s1H8l
                                                                                                                              sat_s1Hac;
                                                                                                              } in 
                                                                                                                GHC.Num.negate
                                                                                                                    $dNum_s1H8x
                                                                                                                    sat_s1Had;
                                                                                                    } in 
                                                                                                      case
                                                                                                          GHC.Classes.<=
                                                                                                              $dOrd_s1H8y
                                                                                                              sat_s1Hae
                                                                                                              eta_s1H8n
                                                                                                      of
                                                                                                      { GHC.Types.False ->
                                                                                                            GHC.Base.Nothing [];
                                                                                                        GHC.Types.True ->
                                                                                                            $j_s1H8z;
                                                                                                      };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                        } in 
                                                                          case xSigned_s1H8v of {
                                                                            GHC.Types.False ->
                                                                                fail3_s1Ha3
                                                                                    GHC.Prim.void#;
                                                                            GHC.Types.True ->
                                                                                case
                                                                                    ySigned_s1H8t
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      let {
                                                                                        sat_s1Hai [Occ=Once]
                                                                                          :: a_a1AhX
                                                                                        [LclId] =
                                                                                            [$dNum_s1H8x] \u []
                                                                                                GHC.Num.fromInteger
                                                                                                    $dNum_s1H8x
                                                                                                    Data.Bits.$fBitsInteger_$czeroBits;
                                                                                      } in 
                                                                                        case
                                                                                            GHC.Classes.<=
                                                                                                $dOrd_s1H8y
                                                                                                sat_s1Hai
                                                                                                eta_s1H8n
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              GHC.Base.Nothing [];
                                                                                          GHC.Types.True ->
                                                                                              $j_s1H8z;
                                                                                        };
                                                                                  GHC.Types.True ->
                                                                                      fail3_s1Ha3
                                                                                          GHC.Prim.void#;
                                                                                };
                                                                          };
                                                              } in 
                                                                let-no-escape {
                                                                  fail3_s1Hak [Dmd=<L,1*C1(U)>]
                                                                    :: GHC.Prim.Void#
                                                                       -> GHC.Base.Maybe b_a1AhY
                                                                  [LclId[JoinId(1)],
                                                                   Arity=1,
                                                                   Str=<L,A>,
                                                                   Unf=OtherCon []] =
                                                                      sat-only [xWidth_s1H8o
                                                                                ySigned_s1H8t
                                                                                yWidth_s1H8u
                                                                                xSigned_s1H8v
                                                                                $j_s1H8z
                                                                                $j1_s1Ha2] \r [ds3_s1Hal]
                                                                          case xSigned_s1H8v of {
                                                                            GHC.Types.False ->
                                                                                case
                                                                                    ySigned_s1H8t
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      $j1_s1Ha2;
                                                                                  GHC.Types.True ->
                                                                                      case
                                                                                          xWidth_s1H8o
                                                                                      of
                                                                                      { GHC.Base.Nothing ->
                                                                                            $j1_s1Ha2;
                                                                                        GHC.Base.Just xW_s1Hap [Occ=Once!] ->
                                                                                            case
                                                                                                yWidth_s1H8u
                                                                                            of
                                                                                            { GHC.Base.Nothing ->
                                                                                                  $j1_s1Ha2;
                                                                                              GHC.Base.Just yW_s1Har [Occ=Once!] ->
                                                                                                  case
                                                                                                      xW_s1Hap
                                                                                                  of
                                                                                                  { GHC.Types.I# x_s1Hat [Occ=Once] ->
                                                                                                        case
                                                                                                            yW_s1Har
                                                                                                        of
                                                                                                        { GHC.Types.I# y1_s1Hav [Occ=Once] ->
                                                                                                              case
                                                                                                                  <# [x_s1Hat
                                                                                                                      y1_s1Hav]
                                                                                                              of
                                                                                                              { __DEFAULT ->
                                                                                                                    $j1_s1Ha2;
                                                                                                                1# ->
                                                                                                                    $j_s1H8z;
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                            GHC.Types.True ->
                                                                                $j1_s1Ha2;
                                                                          };
                                                                } in 
                                                                  let-no-escape {
                                                                    $j2_s1Hax [Occ=Once*T[0],
                                                                               Dmd=<L,1*U>]
                                                                      :: GHC.Base.Maybe b_a1AhY
                                                                    [LclId[JoinId(0)],
                                                                     Unf=OtherCon []] =
                                                                        [xWidth_s1H8o
                                                                         yWidth_s1H8u
                                                                         $j_s1H8z
                                                                         $j1_s1Ha2
                                                                         fail3_s1Hak] \r []
                                                                            case xWidth_s1H8o of {
                                                                              GHC.Base.Nothing ->
                                                                                  fail3_s1Hak
                                                                                      GHC.Prim.void#;
                                                                              GHC.Base.Just xW_s1Haz [Occ=Once!] ->
                                                                                  case
                                                                                      yWidth_s1H8u
                                                                                  of
                                                                                  { GHC.Base.Nothing ->
                                                                                        fail3_s1Hak
                                                                                            GHC.Prim.void#;
                                                                                    GHC.Base.Just yW_s1HaB [Occ=Once!] ->
                                                                                        case
                                                                                            xW_s1Haz
                                                                                        of
                                                                                        { GHC.Types.I# x_s1HaD [Occ=Once] ->
                                                                                              case
                                                                                                  yW_s1HaB
                                                                                              of
                                                                                              { GHC.Types.I# y1_s1HaF [Occ=Once] ->
                                                                                                    case
                                                                                                        <=# [x_s1HaD
                                                                                                             y1_s1HaF]
                                                                                                    of
                                                                                                    { __DEFAULT ->
                                                                                                          $j1_s1Ha2;
                                                                                                      1# ->
                                                                                                          $j_s1H8z;
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                  } in 
                                                                    case xSigned_s1H8v of {
                                                                      GHC.Types.False ->
                                                                          case ySigned_s1H8t of {
                                                                            GHC.Types.False ->
                                                                                $j2_s1Hax;
                                                                            GHC.Types.True ->
                                                                                fail3_s1Hak
                                                                                    GHC.Prim.void#;
                                                                          };
                                                                      GHC.Types.True ->
                                                                          case ySigned_s1H8t of {
                                                                            GHC.Types.False ->
                                                                                fail3_s1Hak
                                                                                    GHC.Prim.void#;
                                                                            GHC.Types.True ->
                                                                                $j2_s1Hax;
                                                                          };
                                                                    };
                                                    } in 
                                                      case xSigned_s1H8v of {
                                                        GHC.Types.False ->
                                                            case ySigned_s1H8t of {
                                                              GHC.Types.False ->
                                                                  case yWidth_s1H8u of {
                                                                    GHC.Base.Nothing -> $j_s1H8z;
                                                                    GHC.Base.Just _ [Occ=Dead] ->
                                                                        fail2_s1Ha0 GHC.Prim.void#;
                                                                  };
                                                              GHC.Types.True ->
                                                                  fail2_s1Ha0 GHC.Prim.void#;
                                                            };
                                                        GHC.Types.True ->
                                                            fail2_s1Ha0 GHC.Prim.void#;
                                                      };
                                          } in 
                                            case ySigned_s1H8t of {
                                              GHC.Types.False -> fail1_s1H9Y GHC.Prim.void#;
                                              GHC.Types.True ->
                                                  case yWidth_s1H8u of {
                                                    GHC.Base.Nothing -> $j_s1H8z;
                                                    GHC.Base.Just _ [Occ=Dead] ->
                                                        fail1_s1H9Y GHC.Prim.void#;
                                                  };
                                            };
                                } in 
                                  let-no-escape {
                                    $j1_s1HaR [Occ=Once*T[0], Dmd=<L,1*U>] :: GHC.Base.Maybe b_a1AhY
                                    [LclId[JoinId(0)], Unf=OtherCon []] =
                                        [ySigned_s1H8t xSigned_s1H8v $j_s1H8z fail_s1H9W] \r []
                                            case xSigned_s1H8v of {
                                              GHC.Types.False ->
                                                  case ySigned_s1H8t of {
                                                    GHC.Types.False -> $j_s1H8z;
                                                    GHC.Types.True -> fail_s1H9W GHC.Prim.void#;
                                                  };
                                              GHC.Types.True ->
                                                  case ySigned_s1H8t of {
                                                    GHC.Types.False -> fail_s1H9W GHC.Prim.void#;
                                                    GHC.Types.True -> $j_s1H8z;
                                                  };
                                            };
                                  } in 
                                    case xWidth_s1H8o of {
                                      GHC.Base.Nothing ->
                                          case yWidth_s1H8u of {
                                            GHC.Base.Nothing -> $j1_s1HaR;
                                            GHC.Base.Just _ [Occ=Dead] -> fail_s1H9W GHC.Prim.void#;
                                          };
                                      GHC.Base.Just a1_s1HaY [Occ=Once!] ->
                                          case yWidth_s1H8u of {
                                            GHC.Base.Nothing -> fail_s1H9W GHC.Prim.void#;
                                            GHC.Base.Just b1_s1Hb0 [Occ=Once!] ->
                                                case a1_s1HaY of {
                                                  GHC.Types.I# x_s1Hb2 [Occ=Once] ->
                                                      case b1_s1Hb0 of {
                                                        GHC.Types.I# y1_s1Hb4 [Occ=Once] ->
                                                            case ==# [x_s1Hb2 y1_s1Hb4] of {
                                                              __DEFAULT ->
                                                                  fail_s1H9W GHC.Prim.void#;
                                                              1# -> $j1_s1HaR;
                                                            };
                                                      };
                                                };
                                          };
                                    };
                      };
                };
        };

Data.Bits.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Bits.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$trModule4];

Data.Bits.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bits"#;

Data.Bits.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$trModule2];

Data.Bits.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bits.$trModule3
                                     Data.Bits.$trModule1];

$krep_r1CDE :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcBool
                                              GHC.Types.[]];

$krep1_r1CDF :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcInt
                                              GHC.Types.[]];

$krep2_r1CDG :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

$krep3_r1CDH :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r1CDF GHC.Types.[]];

$krep4_r1CDI :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep3_r1CDH];

$krep5_r1CDJ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r1CDF $krep_r1CDE];

Data.Bits.$tcBits1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*
                                         $krep2_r1CDG];

$krep6_r1CDK :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep7_r1CDL :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep6_r1CDK];

$krep8_r1CDM :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep7_r1CDL];

$krep9_r1CDN :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep5_r1CDJ];

$krep10_r1CDO :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep4_r1CDI];

$krep11_r1CDP :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep1_r1CDF];

$krep12_r1CDQ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep_r1CDE];

$krep13_r1CDR :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r1CDF $krep6_r1CDK];

$krep14_r1CDS :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep13_r1CDR];

$krep15_r1CDT :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_r1CDK GHC.Types.[]];

$krep16_r1CDU :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Classes.$tcEq
                                              $krep15_r1CDT];

Data.Bits.$tcBits3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bits"#;

Data.Bits.$tcBits2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tcBits3];

Data.Bits.$tcBits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7088815172979416363##
                                    4990916430057605838##
                                    Data.Bits.$trModule
                                    Data.Bits.$tcBits2
                                    0#
                                    Data.Bits.$tcBits1];

$krep17_r1CDV :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Bits.$tcBits
                                              $krep15_r1CDT];

$krep18_r1CDW :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep17_r1CDV];

$krep19_r1CDX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep18_r1CDW];

$krep20_r1CDY :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep19_r1CDX];

$krep21_r1CDZ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep20_r1CDY];

$krep22_r1CE0 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep21_r1CDZ];

$krep23_r1CE1 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep22_r1CE0];

$krep24_r1CE2 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep23_r1CE1];

$krep25_r1CE3 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep12_r1CDQ $krep24_r1CE2];

$krep26_r1CE4 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep25_r1CE3];

$krep27_r1CE5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_r1CDO $krep26_r1CE4];

$krep28_r1CE6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep9_r1CDN $krep27_r1CE5];

$krep29_r1CE7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep28_r1CE6];

$krep30_r1CE8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep29_r1CE7];

$krep31_r1CE9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep30_r1CE8];

$krep32_r1CEa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep13_r1CDR $krep31_r1CE9];

$krep33_r1CEb :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep32_r1CEa];

$krep34_r1CEc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep33_r1CEb];

$krep35_r1CEd :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep34_r1CEc];

$krep36_r1CEe :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_r1CDL $krep35_r1CEd];

$krep37_r1CEf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r1CDM $krep36_r1CEe];

$krep38_r1CEg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r1CDM $krep37_r1CEf];

$krep39_r1CEh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r1CDM $krep38_r1CEg];

Data.Bits.$tc'C:Bits1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep16_r1CDU $krep39_r1CEh];

Data.Bits.$tc'C:Bits3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Bits"#;

Data.Bits.$tc'C:Bits2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tc'C:Bits3];

Data.Bits.$tc'C:Bits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [744071653035646959##
                                    2574978498160477882##
                                    Data.Bits.$trModule
                                    Data.Bits.$tc'C:Bits2
                                    1#
                                    Data.Bits.$tc'C:Bits1];

Data.Bits.$tcFiniteBits2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "FiniteBits"#;

Data.Bits.$tcFiniteBits1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tcFiniteBits2];

Data.Bits.$tcFiniteBits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2363162769622202131##
                                    10110405838341883172##
                                    Data.Bits.$trModule
                                    Data.Bits.$tcFiniteBits1
                                    0#
                                    Data.Bits.$tcBits1];

$krep40_r1CEi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Bits.$tcFiniteBits
                                              $krep15_r1CDT];

$krep41_r1CEj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep40_r1CEi];

$krep42_r1CEk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep41_r1CEj];

$krep43_r1CEl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep42_r1CEk];

Data.Bits.$tc'C:FiniteBits1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep17_r1CDV $krep43_r1CEl];

Data.Bits.$tc'C:FiniteBits3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:FiniteBits"#;

Data.Bits.$tc'C:FiniteBits2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tc'C:FiniteBits3];

Data.Bits.$tc'C:FiniteBits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7500562306525175158##
                                    16051895206261500648##
                                    Data.Bits.$trModule
                                    Data.Bits.$tc'C:FiniteBits2
                                    1#
                                    Data.Bits.$tc'C:FiniteBits1];

Data.Bits.C:FiniteBits
  :: forall b.
     Data.Bits.Bits b =>
     (b -> GHC.Types.Int)
     -> (b -> GHC.Types.Int)
     -> (b -> GHC.Types.Int)
     -> Data.Bits.FiniteBits b
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bits.C:FiniteBits [eta_B4 eta_B3 eta_B2 eta_B1];

Data.Bits.C:Bits
  :: forall a.
     GHC.Classes.Eq a =>
     (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> a
     -> (GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> GHC.Types.Bool)
     -> (a -> GHC.Base.Maybe GHC.Types.Int)
     -> (a -> GHC.Types.Int)
     -> (a -> GHC.Types.Bool)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int)
     -> Data.Bits.Bits a
[GblId[DataCon],
 Arity=23,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_Bn
           eta_Bm
           eta_Bl
           eta_Bk
           eta_Bj
           eta_Bi
           eta_Bh
           eta_Bg
           eta_Bf
           eta_Be
           eta_Bd
           eta_Bc
           eta_Bb
           eta_Ba
           eta_B9
           eta_B8
           eta_B7
           eta_B6
           eta_B5
           eta_B4
           eta_B3
           eta_B2
           eta_B1]
        Data.Bits.C:Bits [eta_Bn
                          eta_Bm
                          eta_Bl
                          eta_Bk
                          eta_Bj
                          eta_Bi
                          eta_Bh
                          eta_Bg
                          eta_Bf
                          eta_Be
                          eta_Bd
                          eta_Bc
                          eta_Bb
                          eta_Ba
                          eta_B9
                          eta_B8
                          eta_B7
                          eta_B6
                          eta_B5
                          eta_B4
                          eta_B3
                          eta_B2
                          eta_B1];


==================== STG syntax: ====================
2018-03-16 15:56:28.659065581 UTC

Data.Bits.$p1FiniteBits
  :: forall b. Data.Bits.FiniteBits b => Data.Bits.Bits b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_s1GQa]
        case v_s1GQa of {
          Data.Bits.C:FiniteBits v_s1GQc [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s1GQc;
        };

Data.Bits.finiteBitSize
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_s1GQg]
        case v_s1GQg of {
          Data.Bits.C:FiniteBits _ [Occ=Dead]
                                 v_s1GQj [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s1GQj;
        };

Data.Bits.countLeadingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_s1GQm]
        case v_s1GQm of {
          Data.Bits.C:FiniteBits _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s1GQq [Occ=Once]
                                 _ [Occ=Dead] ->
              v_s1GQq;
        };

Data.Bits.countTrailingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_s1GQs]
        case v_s1GQs of {
          Data.Bits.C:FiniteBits _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s1GQx [Occ=Once] ->
              v_s1GQx;
        };

Data.Bits.$p1Bits :: forall a. Data.Bits.Bits a => GHC.Classes.Eq a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLLLLLLLLLLLLLLLL),U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GQy]
        case v_s1GQy of {
          Data.Bits.C:Bits v_s1GQA [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GQA;
        };

Data.Bits..&. :: forall a. Data.Bits.Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLLLLLLLLLLLLLLLL),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GQX]
        case v_s1GQX of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           v_s1GR0 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GR0;
        };

Data.Bits..|. :: forall a. Data.Bits.Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLLLLLLLLLLLLLLLL),U(A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GRm]
        case v_s1GRm of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GRq [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GRq;
        };

Data.Bits.xor :: forall a. Data.Bits.Bits a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLLLLLLLLLLLLLLLL),U(A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GRL]
        case v_s1GRL of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GRQ [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GRQ;
        };

Data.Bits.complement :: forall a. Data.Bits.Bits a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLLLLLLLLLLLLLLLL),U(A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GSa]
        case v_s1GSa of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GSg [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GSg;
        };

Data.Bits.shift
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLLLLLLLLLLLLLLLL),U(A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GSz]
        case v_s1GSz of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GSG [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GSG;
        };

Data.Bits.rotate
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLLLLLLLLLLLLLLLL),U(A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GSY]
        case v_s1GSY of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GT6 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GT6;
        };

Data.Bits.zeroBits :: forall a. Data.Bits.Bits a => a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSLLLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GTn]
        case v_s1GTn of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GTw [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GTw;
        };

Data.Bits.bit :: forall a. Data.Bits.Bits a => GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLSLLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GTM]
        case v_s1GTM of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GTW [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GTW;
        };

Data.Bits.setBit
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLSLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GUb]
        case v_s1GUb of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GUm [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GUm;
        };

Data.Bits.clearBit
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLSLLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GUA]
        case v_s1GUA of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GUM [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GUM;
        };

Data.Bits.complementBit
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLSLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GUZ]
        case v_s1GUZ of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GVc [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GVc;
        };

Data.Bits.testBit
  :: forall a.
     Data.Bits.Bits a =>
     a -> GHC.Types.Int -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLSLLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GVo]
        case v_s1GVo of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GVC [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GVC;
        };

Data.Bits.bitSizeMaybe
  :: forall a. Data.Bits.Bits a => a -> GHC.Base.Maybe GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLSLLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GVN]
        case v_s1GVN of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GW2 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GW2;
        };

Data.Bits.bitSize
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLSLLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GWc]
        case v_s1GWc of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GWs [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GWs;
        };

Data.Bits.isSigned
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLSLLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A)>] =
    [] \r [v_s1GWB]
        case v_s1GWB of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GWS [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GWS;
        };

Data.Bits.shiftL
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLSLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A)>] =
    [] \r [v_s1GX0]
        case v_s1GX0 of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GXi [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GXi;
        };

Data.Bits.unsafeShiftL
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLSLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A)>] =
    [] \r [v_s1GXp]
        case v_s1GXp of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GXI [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GXI;
        };

Data.Bits.shiftR
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLSLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A)>] =
    [] \r [v_s1GXO]
        case v_s1GXO of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GY8 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GY8;
        };

Data.Bits.unsafeShiftR
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLSLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A)>] =
    [] \r [v_s1GYd]
        case v_s1GYd of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GYy [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GYy;
        };

Data.Bits.rotateL
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLSLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A)>] =
    [] \r [v_s1GYC]
        case v_s1GYC of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GYY [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s1GYY;
        };

Data.Bits.rotateR
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A)>] =
    [] \r [v_s1GZ1]
        case v_s1GZ1 of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GZo [Occ=Once]
                           _ [Occ=Dead] ->
              v_s1GZo;
        };

Data.Bits.popCount
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLLLLLS),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U)>] =
    [] \r [v_s1GZq]
        case v_s1GZq of {
          Data.Bits.C:Bits _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s1GZO [Occ=Once] ->
              v_s1GZO;
        };

Data.Bits.$fBitsBool2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Bits.$fBitsBool1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Bits.$fBitsBool_$cpopCount :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_s1GZP]
        case ds_s1GZP of {
          GHC.Types.False -> Data.Bits.$fBitsBool2;
          GHC.Types.True -> Data.Bits.$fBitsBool1;
        };

Data.Bits.$fBitsBool_$cisSigned :: GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1GZR] GHC.Types.False [];

Data.Bits.$fBitsBool_$cbitSize :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s1GZS] Data.Bits.$fBitsBool1;

Data.Bits.$fBitsBool3 :: GHC.Base.Maybe GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [Data.Bits.$fBitsBool1];

Data.Bits.$fBitsBool_$cbitSizeMaybe
  :: GHC.Types.Bool -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m2, Unf=OtherCon []] =
    [] \r [ds_s1GZT] Data.Bits.$fBitsBool3;

Data.Bits.$fBitsBool_$ctestBit
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [x_s1GZU ds_s1GZV]
        case ds_s1GZV of {
          GHC.Types.I# ds1_s1GZX [Occ=Once!] ->
              case ds1_s1GZX of {
                __DEFAULT -> GHC.Types.False [];
                0# -> x_s1GZU;
              };
        };

Data.Bits.$fBitsBool_$cbit :: GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s1GZZ]
        case ds_s1GZZ of {
          GHC.Types.I# ds1_s1H01 [Occ=Once!] ->
              case ds1_s1H01 of {
                __DEFAULT -> GHC.Types.False [];
                0# -> GHC.Types.True [];
              };
        };

Data.Bits.$fBitsBool_$crotate
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s1H03 ds_s1H04] x_s1H03;

Data.Bits.$fBitsInteger_$cisSigned
  :: GHC.Integer.Type.Integer -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1H05] GHC.Types.True [];

Data.Bits.$fBitsInteger2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bits.bitSize(Integer)"#;

Data.Bits.$fBitsInteger1 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Bits.$fBitsInteger2;

Data.Bits.$fBitsInteger_$cbitSize
  :: GHC.Integer.Type.Integer -> GHC.Types.Int
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [ds_s1H06]
        GHC.Err.errorWithoutStackTrace Data.Bits.$fBitsInteger1;

Data.Bits.$fBitsInteger_$cbitSizeMaybe
  :: GHC.Integer.Type.Integer -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1H07] GHC.Base.Nothing [];

Data.Bits.$fBitsInteger_$ctestBit
  :: GHC.Integer.Type.Integer -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1H08 ds_s1H09]
        case ds_s1H09 of {
          GHC.Types.I# i_s1H0b [Occ=Once] ->
              GHC.Integer.Type.testBitInteger x_s1H08 i_s1H0b;
        };

Data.Bits.$fBitsInteger_$czeroBits :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Bits.$w$cshift [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Prim.Int# -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [w_s1H0c ww_s1H0d]
        case >=# [ww_s1H0d 0#] of {
          __DEFAULT ->
              case negateInt# [ww_s1H0d] of sat_s1H0f {
                __DEFAULT -> GHC.Integer.Type.shiftRInteger w_s1H0c sat_s1H0f;
              };
          1# -> GHC.Integer.Type.shiftLInteger w_s1H0c ww_s1H0d;
        };

Data.Bits.$fBitsInteger_$cshift [InlPrag=NOUSERINLINE[0]]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [w_s1H0g w1_s1H0h]
        case w1_s1H0h of {
          GHC.Types.I# ww1_s1H0j [Occ=Once] ->
              Data.Bits.$w$cshift w_s1H0g ww1_s1H0j;
        };

sat_s1H0k :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s1H0l :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s1H0k GHC.Types.[]];

Data.Bits.$fBitsInteger3 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s1H0l;

Data.Bits.$fBitsInteger_$cbit
  :: GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [i_s1H0m]
        case i_s1H0m of {
          GHC.Types.I# ww1_s1H0o ->
              case >=# [ww1_s1H0o 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1H0o] of sat_s1H0q {
                      __DEFAULT ->
                          GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1H0q;
                    };
                1# ->
                    GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1H0o;
              };
        };

Data.Bits.$fBitsInteger_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1H0r eta1_s1H0s]
        case eta1_s1H0s of {
          GHC.Types.I# ww1_s1H0u ->
              case >=# [ww1_s1H0u 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1H0u] of sat_s1H0w {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1H0w
                          of
                          sat_s1H0x
                          { __DEFAULT ->
                                case GHC.Integer.Type.complementInteger sat_s1H0x of sat_s1H0y {
                                  __DEFAULT -> GHC.Integer.Type.andInteger eta_s1H0r sat_s1H0y;
                                };
                          };
                    };
                1# ->
                    case
                        GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1H0u
                    of
                    sat_s1H0z
                    { __DEFAULT ->
                          case GHC.Integer.Type.complementInteger sat_s1H0z of sat_s1H0A {
                            __DEFAULT -> GHC.Integer.Type.andInteger eta_s1H0r sat_s1H0A;
                          };
                    };
              };
        };

Data.Bits.$fBitsInteger_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1H0B eta1_s1H0C]
        case eta1_s1H0C of {
          GHC.Types.I# ww1_s1H0E ->
              case >=# [ww1_s1H0E 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1H0E] of sat_s1H0G {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1H0G
                          of
                          sat_s1H0H
                          { __DEFAULT -> GHC.Integer.Type.xorInteger eta_s1H0B sat_s1H0H;
                          };
                    };
                1# ->
                    case
                        GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1H0E
                    of
                    sat_s1H0I
                    { __DEFAULT -> GHC.Integer.Type.xorInteger eta_s1H0B sat_s1H0I;
                    };
              };
        };

Data.Bits.$fBitsInteger_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1H0J eta1_s1H0K]
        case eta1_s1H0K of {
          GHC.Types.I# ww1_s1H0M ->
              case >=# [ww1_s1H0M 0#] of {
                __DEFAULT ->
                    case negateInt# [ww1_s1H0M] of sat_s1H0O {
                      __DEFAULT ->
                          case
                              GHC.Integer.Type.shiftRInteger Data.Bits.$fBitsInteger3 sat_s1H0O
                          of
                          sat_s1H0P
                          { __DEFAULT -> GHC.Integer.Type.orInteger eta_s1H0J sat_s1H0P;
                          };
                    };
                1# ->
                    case
                        GHC.Integer.Type.shiftLInteger Data.Bits.$fBitsInteger3 ww1_s1H0M
                    of
                    sat_s1H0Q
                    { __DEFAULT -> GHC.Integer.Type.orInteger eta_s1H0J sat_s1H0Q;
                    };
              };
        };

Data.Bits.$fBitsInteger_$cunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshift eta_B2 eta_B1;

Data.Bits.$fBitsInteger_$cshiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshift eta_B2 eta_B1;

Data.Bits.$fBitsInteger_$cshiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1H0R eta1_s1H0S]
        case eta1_s1H0S of {
          GHC.Types.I# x_s1H0U [Occ=Once] ->
              case negateInt# [x_s1H0U] of i#_s1H0V [Dmd=<S,U>] {
                __DEFAULT ->
                    case >=# [i#_s1H0V 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1H0V] of sat_s1H0X {
                            __DEFAULT -> GHC.Integer.Type.shiftRInteger eta_s1H0R sat_s1H0X;
                          };
                      1# -> GHC.Integer.Type.shiftLInteger eta_s1H0R i#_s1H0V;
                    };
              };
        };

Data.Bits.$fBitsInteger_$cunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshiftR eta_B2 eta_B1;

Data.Bits.$fBitsInteger_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_s1H0Y eta1_s1H0Z]
        case eta1_s1H0Z of {
          GHC.Types.I# x_s1H11 [Occ=Once] ->
              case negateInt# [x_s1H11] of i#_s1H12 [Dmd=<S,U>] {
                __DEFAULT ->
                    case >=# [i#_s1H12 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1H12] of sat_s1H14 {
                            __DEFAULT -> GHC.Integer.Type.shiftRInteger eta_s1H0Y sat_s1H14;
                          };
                      1# -> GHC.Integer.Type.shiftLInteger eta_s1H0Y i#_s1H12;
                    };
              };
        };

Data.Bits.$fBitsInteger_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Integer.Type.Integer
     -> GHC.Types.Int -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Bits.$fBitsInteger_$cshift eta_B2 eta_B1;

Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros
  :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [x_s1H15]
        case x_s1H15 of {
          GHC.Types.False -> Data.Bits.$fBitsBool1;
          GHC.Types.True -> Data.Bits.$fBitsBool2;
        };

Data.Bits.$fBitsInt_$cpopCount :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H17]
        case ds_s1H17 of {
          GHC.Types.I# x#_s1H19 [Occ=Once] ->
              case int2Word# [x#_s1H19] of sat_s1H1a {
                __DEFAULT ->
                    case popCnt# [sat_s1H1a] of sat_s1H1b {
                      __DEFAULT ->
                          case word2Int# [sat_s1H1b] of sat_s1H1c {
                            __DEFAULT -> GHC.Types.I# [sat_s1H1c];
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cunsafeShiftR
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H1d ds1_s1H1e]
        case ds_s1H1d of {
          GHC.Types.I# x#_s1H1g [Occ=Once] ->
              case ds1_s1H1e of {
                GHC.Types.I# i#_s1H1i [Occ=Once] ->
                    case uncheckedIShiftRA# [x#_s1H1g i#_s1H1i] of sat_s1H1j {
                      __DEFAULT -> GHC.Types.I# [sat_s1H1j];
                    };
              };
        };

lvl_r1CDD :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [-1#];

Data.Bits.$fBitsInt_$cshiftR [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s1H1k w1_s1H1l]
        case w_s1H1k of {
          GHC.Types.I# ww1_s1H1n [Occ=Once*] ->
              case w1_s1H1l of {
                GHC.Types.I# ww3_s1H1p ->
                    case >=# [ww3_s1H1p 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftRA# [ww1_s1H1n ww3_s1H1p] of sat_s1H1r {
                            __DEFAULT -> GHC.Types.I# [sat_s1H1r];
                          };
                      1# ->
                          case <# [ww1_s1H1n 0#] of {
                            __DEFAULT -> Data.Bits.$fBitsBool2;
                            1# -> lvl_r1CDD;
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cunsafeShiftL
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H1t ds1_s1H1u]
        case ds_s1H1t of {
          GHC.Types.I# x#_s1H1w [Occ=Once] ->
              case ds1_s1H1u of {
                GHC.Types.I# i#_s1H1y [Occ=Once] ->
                    case uncheckedIShiftL# [x#_s1H1w i#_s1H1y] of sat_s1H1z {
                      __DEFAULT -> GHC.Types.I# [sat_s1H1z];
                    };
              };
        };

Data.Bits.$fBitsInt_$cshiftL
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H1A ds1_s1H1B]
        case ds_s1H1A of {
          GHC.Types.I# x#_s1H1D [Occ=Once] ->
              case ds1_s1H1B of {
                GHC.Types.I# i#_s1H1F ->
                    case >=# [i#_s1H1F 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [x#_s1H1D i#_s1H1F] of sat_s1H1H {
                            __DEFAULT -> GHC.Types.I# [sat_s1H1H];
                          };
                      1# -> Data.Bits.$fBitsBool2;
                    };
              };
        };

Data.Bits.$fBitsInt_$cisSigned :: GHC.Types.Int -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1H1I] GHC.Types.True [];

Data.Bits.$fBitsInt_$crotate [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H1J ds1_s1H1K]
        case ds_s1H1J of {
          GHC.Types.I# x#_s1H1M ->
              case ds1_s1H1K of {
                GHC.Types.I# i#_s1H1O [Occ=Once] ->
                    case andI# [i#_s1H1O 63#] of i'#_s1H1P [Dmd=<S,U>] {
                      __DEFAULT ->
                          case -# [64# i'#_s1H1P] of sat_s1H1R {
                            __DEFAULT ->
                                case uncheckedIShiftRL# [x#_s1H1M sat_s1H1R] of sat_s1H1S {
                                  __DEFAULT ->
                                      case uncheckedIShiftL# [x#_s1H1M i'#_s1H1P] of sat_s1H1Q {
                                        __DEFAULT ->
                                            case orI# [sat_s1H1Q sat_s1H1S] of sat_s1H1T {
                                              __DEFAULT -> GHC.Types.I# [sat_s1H1T];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cshift [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H1U ds1_s1H1V]
        case ds_s1H1U of {
          GHC.Types.I# x#_s1H1X [Occ=Once*] ->
              case ds1_s1H1V of {
                GHC.Types.I# i#_s1H1Z ->
                    case >=# [i#_s1H1Z 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1H1Z] of b_s1H21 [Dmd=<S,U>] {
                            __DEFAULT ->
                                case >=# [b_s1H21 64#] of {
                                  __DEFAULT ->
                                      case uncheckedIShiftRA# [x#_s1H1X b_s1H21] of sat_s1H23 {
                                        __DEFAULT -> GHC.Types.I# [sat_s1H23];
                                      };
                                  1# ->
                                      case <# [x#_s1H1X 0#] of {
                                        __DEFAULT -> Data.Bits.$fBitsBool2;
                                        1# -> lvl_r1CDD;
                                      };
                                };
                          };
                      1# ->
                          case >=# [i#_s1H1Z 64#] of {
                            __DEFAULT ->
                                case uncheckedIShiftL# [x#_s1H1X i#_s1H1Z] of sat_s1H26 {
                                  __DEFAULT -> GHC.Types.I# [sat_s1H26];
                                };
                            1# -> Data.Bits.$fBitsBool2;
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$ccomplement :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H27]
        case ds_s1H27 of {
          GHC.Types.I# x#_s1H29 [Occ=Once] ->
              case notI# [x#_s1H29] of sat_s1H2a {
                __DEFAULT -> GHC.Types.I# [sat_s1H2a];
              };
        };

Data.Bits.$fBitsInt_$cxor
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2b ds1_s1H2c]
        case ds_s1H2b of {
          GHC.Types.I# x#_s1H2e [Occ=Once] ->
              case ds1_s1H2c of {
                GHC.Types.I# y#_s1H2g [Occ=Once] ->
                    case xorI# [x#_s1H2e y#_s1H2g] of sat_s1H2h {
                      __DEFAULT -> GHC.Types.I# [sat_s1H2h];
                    };
              };
        };

Data.Bits.$fBitsInt_$c.|.
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2i ds1_s1H2j]
        case ds_s1H2i of {
          GHC.Types.I# x#_s1H2l [Occ=Once] ->
              case ds1_s1H2j of {
                GHC.Types.I# y#_s1H2n [Occ=Once] ->
                    case orI# [x#_s1H2l y#_s1H2n] of sat_s1H2o {
                      __DEFAULT -> GHC.Types.I# [sat_s1H2o];
                    };
              };
        };

Data.Bits.$fBitsInt_$c.&.
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2p ds1_s1H2q]
        case ds_s1H2p of {
          GHC.Types.I# x#_s1H2s [Occ=Once] ->
              case ds1_s1H2q of {
                GHC.Types.I# y#_s1H2u [Occ=Once] ->
                    case andI# [x#_s1H2s y#_s1H2u] of sat_s1H2v {
                      __DEFAULT -> GHC.Types.I# [sat_s1H2v];
                    };
              };
        };

Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros
  :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2w]
        case ds_s1H2w of {
          GHC.Types.I# x#_s1H2y [Occ=Once] ->
              case int2Word# [x#_s1H2y] of sat_s1H2z {
                __DEFAULT ->
                    case ctz# [sat_s1H2z] of sat_s1H2A {
                      __DEFAULT ->
                          case word2Int# [sat_s1H2A] of sat_s1H2B {
                            __DEFAULT -> GHC.Types.I# [sat_s1H2B];
                          };
                    };
              };
        };

Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros
  :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2C]
        case ds_s1H2C of {
          GHC.Types.I# x#_s1H2E [Occ=Once] ->
              case int2Word# [x#_s1H2E] of sat_s1H2F {
                __DEFAULT ->
                    case clz# [sat_s1H2F] of sat_s1H2G {
                      __DEFAULT ->
                          case word2Int# [sat_s1H2G] of sat_s1H2H {
                            __DEFAULT -> GHC.Types.I# [sat_s1H2H];
                          };
                    };
              };
        };

Data.Bits.$fBitsInt1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [64#];

Data.Bits.$fBitsInt_$cfiniteBitSize
  :: GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s1H2I] Data.Bits.$fBitsInt1;

Data.Bits.$fBitsWord_$cpopCount :: GHC.Types.Word -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2J]
        case ds_s1H2J of {
          GHC.Types.W# x#_s1H2L [Occ=Once] ->
              case popCnt# [x#_s1H2L] of sat_s1H2M {
                __DEFAULT ->
                    case word2Int# [sat_s1H2M] of sat_s1H2N {
                      __DEFAULT -> GHC.Types.I# [sat_s1H2N];
                    };
              };
        };

Data.Bits.$fBitsWord_$cunsafeShiftR
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2O ds1_s1H2P]
        case ds_s1H2O of {
          GHC.Types.W# x#_s1H2R [Occ=Once] ->
              case ds1_s1H2P of {
                GHC.Types.I# i#_s1H2T [Occ=Once] ->
                    case uncheckedShiftRL# [x#_s1H2R i#_s1H2T] of sat_s1H2U {
                      __DEFAULT -> GHC.Types.W# [sat_s1H2U];
                    };
              };
        };

Data.Bits.$fBitsWord1 :: GHC.Types.Word
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.W#! [0##];

Data.Bits.$fBitsWord_$cshiftR
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H2V ds1_s1H2W]
        case ds_s1H2V of {
          GHC.Types.W# x#_s1H2Y [Occ=Once] ->
              case ds1_s1H2W of {
                GHC.Types.I# i#_s1H30 ->
                    case >=# [i#_s1H30 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftRL# [x#_s1H2Y i#_s1H30] of sat_s1H32 {
                            __DEFAULT -> GHC.Types.W# [sat_s1H32];
                          };
                      1# -> Data.Bits.$fBitsWord1;
                    };
              };
        };

Data.Bits.$fBitsWord_$cunsafeShiftL
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H33 ds1_s1H34]
        case ds_s1H33 of {
          GHC.Types.W# x#_s1H36 [Occ=Once] ->
              case ds1_s1H34 of {
                GHC.Types.I# i#_s1H38 [Occ=Once] ->
                    case uncheckedShiftL# [x#_s1H36 i#_s1H38] of sat_s1H39 {
                      __DEFAULT -> GHC.Types.W# [sat_s1H39];
                    };
              };
        };

Data.Bits.$fBitsWord_$cshiftL
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3a ds1_s1H3b]
        case ds_s1H3a of {
          GHC.Types.W# x#_s1H3d [Occ=Once] ->
              case ds1_s1H3b of {
                GHC.Types.I# i#_s1H3f ->
                    case >=# [i#_s1H3f 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [x#_s1H3d i#_s1H3f] of sat_s1H3h {
                            __DEFAULT -> GHC.Types.W# [sat_s1H3h];
                          };
                      1# -> Data.Bits.$fBitsWord1;
                    };
              };
        };

Data.Bits.$fBitsWord_$cisSigned :: GHC.Types.Word -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s1H3i] GHC.Types.False [];

Data.Bits.$fBitsWord_$crotate
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3j ds1_s1H3k]
        case ds_s1H3j of wild_s1H3l {
          GHC.Types.W# x#_s1H3m ->
              case ds1_s1H3k of {
                GHC.Types.I# i#_s1H3o [Occ=Once] ->
                    case andI# [i#_s1H3o 63#] of wild2_s1H3p {
                      __DEFAULT ->
                          case -# [64# wild2_s1H3p] of sat_s1H3r {
                            __DEFAULT ->
                                case uncheckedShiftRL# [x#_s1H3m sat_s1H3r] of sat_s1H3s {
                                  __DEFAULT ->
                                      case uncheckedShiftL# [x#_s1H3m wild2_s1H3p] of sat_s1H3q {
                                        __DEFAULT ->
                                            case or# [sat_s1H3q sat_s1H3s] of sat_s1H3t {
                                              __DEFAULT -> GHC.Types.W# [sat_s1H3t];
                                            };
                                      };
                                };
                          };
                      0# -> wild_s1H3l;
                    };
              };
        };

Data.Bits.$fBitsWord_$cshift [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3u ds1_s1H3v]
        case ds_s1H3u of {
          GHC.Types.W# x#_s1H3x [Occ=Once*] ->
              case ds1_s1H3v of {
                GHC.Types.I# i#_s1H3z ->
                    case >=# [i#_s1H3z 0#] of {
                      __DEFAULT ->
                          case negateInt# [i#_s1H3z] of b_s1H3B [Dmd=<S,U>] {
                            __DEFAULT ->
                                case >=# [b_s1H3B 64#] of {
                                  __DEFAULT ->
                                      case uncheckedShiftRL# [x#_s1H3x b_s1H3B] of sat_s1H3D {
                                        __DEFAULT -> GHC.Types.W# [sat_s1H3D];
                                      };
                                  1# -> Data.Bits.$fBitsWord1;
                                };
                          };
                      1# ->
                          case >=# [i#_s1H3z 64#] of {
                            __DEFAULT ->
                                case uncheckedShiftL# [x#_s1H3x i#_s1H3z] of sat_s1H3F {
                                  __DEFAULT -> GHC.Types.W# [sat_s1H3F];
                                };
                            1# -> Data.Bits.$fBitsWord1;
                          };
                    };
              };
        };

Data.Bits.$fBitsWord_$ccomplement
  :: GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3G]
        case ds_s1H3G of {
          GHC.Types.W# x#_s1H3I [Occ=Once] ->
              case xor# [x#_s1H3I 18446744073709551615##] of sat_s1H3J {
                __DEFAULT -> GHC.Types.W# [sat_s1H3J];
              };
        };

Data.Bits.$fBitsWord_$cxor
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3K ds1_s1H3L]
        case ds_s1H3K of {
          GHC.Types.W# x#_s1H3N [Occ=Once] ->
              case ds1_s1H3L of {
                GHC.Types.W# y#_s1H3P [Occ=Once] ->
                    case xor# [x#_s1H3N y#_s1H3P] of sat_s1H3Q {
                      __DEFAULT -> GHC.Types.W# [sat_s1H3Q];
                    };
              };
        };

Data.Bits.$fBitsWord_$c.|.
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3R ds1_s1H3S]
        case ds_s1H3R of {
          GHC.Types.W# x#_s1H3U [Occ=Once] ->
              case ds1_s1H3S of {
                GHC.Types.W# y#_s1H3W [Occ=Once] ->
                    case or# [x#_s1H3U y#_s1H3W] of sat_s1H3X {
                      __DEFAULT -> GHC.Types.W# [sat_s1H3X];
                    };
              };
        };

Data.Bits.$fBitsWord_$c.&.
  :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H3Y ds1_s1H3Z]
        case ds_s1H3Y of {
          GHC.Types.W# x#_s1H41 [Occ=Once] ->
              case ds1_s1H3Z of {
                GHC.Types.W# y#_s1H43 [Occ=Once] ->
                    case and# [x#_s1H41 y#_s1H43] of sat_s1H44 {
                      __DEFAULT -> GHC.Types.W# [sat_s1H44];
                    };
              };
        };

Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros
  :: GHC.Types.Word -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H45]
        case ds_s1H45 of {
          GHC.Types.W# x#_s1H47 [Occ=Once] ->
              case ctz# [x#_s1H47] of sat_s1H48 {
                __DEFAULT ->
                    case word2Int# [sat_s1H48] of sat_s1H49 {
                      __DEFAULT -> GHC.Types.I# [sat_s1H49];
                    };
              };
        };

Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros
  :: GHC.Types.Word -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s1H4a]
        case ds_s1H4a of {
          GHC.Types.W# x#_s1H4c [Occ=Once] ->
              case clz# [x#_s1H4c] of sat_s1H4d {
                __DEFAULT ->
                    case word2Int# [sat_s1H4d] of sat_s1H4e {
                      __DEFAULT -> GHC.Types.I# [sat_s1H4e];
                    };
              };
        };

Data.Bits.$fBitsWord_$cfiniteBitSize
  :: GHC.Types.Word -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s1H4f] Data.Bits.$fBitsInt1;

Data.Bits.$dmcountTrailingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S(S))LL),U(1*U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A),1*C1(U(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFiniteBits_s1H4g eta_s1H4h]
        case Data.Bits.finiteBitSize $dFiniteBits_s1H4g eta_s1H4h of {
          GHC.Types.I# ww1_s1H4j [Occ=OnceL] ->
              let {
                $dBits_s1H4k [Occ=OnceL,
                              Dmd=<L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A)>]
                  :: Data.Bits.Bits b_a1A4A
                [LclId] =
                    [$dFiniteBits_s1H4g] \u []
                        Data.Bits.$p1FiniteBits $dFiniteBits_s1H4g;
              } in 
                let-no-escape {
                  $wgo_s1H4l [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[1]]
                    :: GHC.Prim.Int# -> GHC.Types.Int
                  [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                      sat-only [eta_s1H4h
                                ww1_s1H4j
                                $dBits_s1H4k
                                $wgo_s1H4l] \r [ww2_s1H4m]
                          let {
                            wild_s1H4n [Dmd=<L,U(U)>] :: GHC.Types.Int
                            [LclId, Unf=OtherCon []] =
                                CCCS GHC.Types.I#! [ww2_s1H4m];
                          } in 
                            case >=# [ww2_s1H4m ww1_s1H4j] of {
                              __DEFAULT ->
                                  case Data.Bits.testBit $dBits_s1H4k eta_s1H4h wild_s1H4n of {
                                    GHC.Types.False ->
                                        case +# [ww2_s1H4m 1#] of sat_s1H4q {
                                          __DEFAULT -> $wgo_s1H4l sat_s1H4q;
                                        };
                                    GHC.Types.True -> wild_s1H4n;
                                  };
                              1# -> wild_s1H4n;
                            };
                } in  $wgo_s1H4l 0#;
        };

Data.Bits.$dmcountLeadingZeros
  :: forall b. Data.Bits.FiniteBits b => b -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S(S))LL),U(1*U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A),1*C1(U(U)),A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFiniteBits_s1H4r eta_s1H4s]
        case Data.Bits.finiteBitSize $dFiniteBits_s1H4r eta_s1H4s of {
          GHC.Types.I# x_s1H4u ->
              let {
                $dBits_s1H4v [Occ=OnceL,
                              Dmd=<L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A)>]
                  :: Data.Bits.Bits b_a1A4A
                [LclId] =
                    [$dFiniteBits_s1H4r] \u []
                        Data.Bits.$p1FiniteBits $dFiniteBits_s1H4r;
              } in 
                case -# [x_s1H4u 1#] of sat_s1H4K {
                  __DEFAULT ->
                      let-no-escape {
                        exit_s1H4w [Occ=OnceL!T[1], Dmd=<L,C(U(U))>]
                          :: GHC.Prim.Int# -> GHC.Types.Int
                        [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []] =
                            sat-only [x_s1H4u] \r [ww_s1H4x]
                                case -# [x_s1H4u 1#] of sat_s1H4y {
                                  __DEFAULT ->
                                      case -# [sat_s1H4y ww_s1H4x] of sat_s1H4z {
                                        __DEFAULT -> GHC.Types.I# [sat_s1H4z];
                                      };
                                };
                      } in 
                        let-no-escape {
                          exit1_s1H4A [Occ=OnceL!T[1], Dmd=<L,C(U(U))>]
                            :: GHC.Prim.Int# -> GHC.Types.Int
                          [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []] =
                              sat-only [x_s1H4u] \r [ww_s1H4B]
                                  case -# [x_s1H4u 1#] of sat_s1H4C {
                                    __DEFAULT ->
                                        case -# [sat_s1H4C ww_s1H4B] of sat_s1H4D {
                                          __DEFAULT -> GHC.Types.I# [sat_s1H4D];
                                        };
                                  };
                        } in 
                          let-no-escape {
                            $wgo_s1H4E [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[1]]
                              :: GHC.Prim.Int# -> GHC.Types.Int
                            [LclId[JoinId(1)], Arity=1, Str=<S,U>m, Unf=OtherCon []] =
                                sat-only [eta_s1H4s
                                          $dBits_s1H4v
                                          exit_s1H4w
                                          exit1_s1H4A
                                          $wgo_s1H4E] \r [ww_s1H4F]
                                    case <# [ww_s1H4F 0#] of {
                                      __DEFAULT ->
                                          let {
                                            sat_s1H4H [Occ=Once] :: GHC.Types.Int
                                            [LclId] =
                                                CCCS GHC.Types.I#! [ww_s1H4F];
                                          } in 
                                            case
                                                Data.Bits.testBit $dBits_s1H4v eta_s1H4s sat_s1H4H
                                            of
                                            { GHC.Types.False ->
                                                  case -# [ww_s1H4F 1#] of sat_s1H4J {
                                                    __DEFAULT -> $wgo_s1H4E sat_s1H4J;
                                                  };
                                              GHC.Types.True -> exit_s1H4w ww_s1H4F;
                                            };
                                      1# -> exit1_s1H4A ww_s1H4F;
                                    };
                          } in  $wgo_s1H4E sat_s1H4K;
                };
        };

Data.Bits.$dmrotateR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H4L x_s1H4M i_s1H4N]
        let {
          sat_s1H4R [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [i_s1H4N] \u []
                  case i_s1H4N of {
                    GHC.Types.I# x1_s1H4P [Occ=Once] ->
                        case negateInt# [x1_s1H4P] of sat_s1H4Q {
                          __DEFAULT -> GHC.Types.I# [sat_s1H4Q];
                        };
                  };
        } in  Data.Bits.rotate $dBits_s1H4L x_s1H4M sat_s1H4R;

Data.Bits.$dmrotateL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S))LLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H4S x_s1H4T i_s1H4U]
        Data.Bits.rotate $dBits_s1H4S x_s1H4T i_s1H4U;

Data.Bits.$dmunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLLLC(C(S))LLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H4V x_s1H4W i_s1H4X]
        Data.Bits.shiftR $dBits_s1H4V x_s1H4W i_s1H4X;

Data.Bits.$dmshiftR [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H4Y x_s1H4Z i_s1H50]
        let {
          sat_s1H54 [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [i_s1H50] \u []
                  case i_s1H50 of {
                    GHC.Types.I# x1_s1H52 [Occ=Once] ->
                        case negateInt# [x1_s1H52] of sat_s1H53 {
                          __DEFAULT -> GHC.Types.I# [sat_s1H53];
                        };
                  };
        } in  Data.Bits.shift $dBits_s1H4Y x_s1H4Z sat_s1H54;

Data.Bits.$dmunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLLC(C(S))LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H55 x_s1H56 i_s1H57]
        Data.Bits.shiftL $dBits_s1H55 x_s1H56 i_s1H57;

Data.Bits.$dmshiftL [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H58 x_s1H59 i_s1H5a]
        Data.Bits.shift $dBits_s1H58 x_s1H59 i_s1H5a;

Data.Bits.$dmcomplementBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLLLLLLLLLLLLLLLLL),U(A,A,A,1*C1(C1(U)),A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H5b x_s1H5c i_s1H5d]
        let {
          sat_s1H5e [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1H5b i_s1H5d] \u [] Data.Bits.bit $dBits_s1H5b i_s1H5d;
        } in  Data.Bits.xor $dBits_s1H5b x_s1H5c sat_s1H5e;

Data.Bits.$dmclearBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLLLLLLLLLLLLLLLLL),U(A,1*C1(C1(U)),A,A,1*C1(U),A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H5f x_s1H5g i_s1H5h]
        let {
          sat_s1H5j [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1H5f i_s1H5h] \u []
                  let {
                    sat_s1H5i [Occ=Once] :: a_a1A4J
                    [LclId] =
                        [$dBits_s1H5f i_s1H5h] \u [] Data.Bits.bit $dBits_s1H5f i_s1H5h;
                  } in  Data.Bits.complement $dBits_s1H5f sat_s1H5i;
        } in  Data.Bits..&. $dBits_s1H5f x_s1H5g sat_s1H5j;

Data.Bits.$dmsetBit [InlPrag=INLINE (sat-args=2)]
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLLLLLLLLL),U(A,A,1*C1(C1(U)),A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H5k x_s1H5l i_s1H5m]
        let {
          sat_s1H5n [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1H5k i_s1H5m] \u [] Data.Bits.bit $dBits_s1H5k i_s1H5m;
        } in  Data.Bits..|. $dBits_s1H5k x_s1H5l sat_s1H5n;

Data.Bits.$dmzeroBits :: forall a. Data.Bits.Bits a => a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLC(C(S))LLLLLLLLLLLL),U(A,A,A,A,A,A,A,A,1*C1(U),A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H5o]
        let {
          sat_s1H5p [Occ=Once] :: a_a1A4J
          [LclId] =
              [$dBits_s1H5o] \u []
                  Data.Bits.bit $dBits_s1H5o Data.Bits.$fBitsBool2;
        } in 
          Data.Bits.clearBit $dBits_s1H5o sat_s1H5p Data.Bits.$fBitsBool2;

Data.Bits.$fBitsBool_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cshiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$ctestBit eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cunsafeShiftR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$cshiftR eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cshiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$ctestBit eta_B2 eta_B1;

Data.Bits.$fBitsBool_$cunsafeShiftL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$cshiftL eta_B2 eta_B1;

Data.Bits.$fBitsBool_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1H5q eta1_s1H5r]
        case eta_s1H5q of {
          GHC.Types.False ->
              case eta1_s1H5r of {
                GHC.Types.I# ds_s1H5u [Occ=Once!] ->
                    case ds_s1H5u of {
                      __DEFAULT -> GHC.Types.False [];
                      0# -> GHC.Types.True [];
                    };
              };
          GHC.Types.True ->
              case eta1_s1H5r of {
                GHC.Types.I# ds_s1H5x [Occ=Once!] ->
                    case ds_s1H5x of {
                      __DEFAULT -> GHC.Types.True [];
                      0# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsBool_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1H5z eta1_s1H5A]
        case eta_s1H5z of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True ->
              case eta1_s1H5A of {
                GHC.Types.I# ds_s1H5D [Occ=Once!] ->
                    case ds_s1H5D of {
                      __DEFAULT -> GHC.Types.True [];
                      0# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsBool_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_s1H5F eta1_s1H5G]
        case eta_s1H5F of {
          GHC.Types.False -> Data.Bits.$fBitsBool_$cbit eta1_s1H5G;
          GHC.Types.True -> GHC.Types.True [];
        };

Data.Bits.$fBitsBool_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsBool_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Types.Bool
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Classes.$fEqBool
                                     GHC.Classes.&&
                                     GHC.Classes.||
                                     GHC.Classes.$fEqBool_$c/=
                                     GHC.Classes.not
                                     Data.Bits.$fBitsBool_$ctestBit
                                     Data.Bits.$fBitsBool_$crotate
                                     GHC.Types.False
                                     Data.Bits.$fBitsBool_$cbit
                                     Data.Bits.$fBitsBool_$csetBit
                                     Data.Bits.$fBitsBool_$cclearBit
                                     Data.Bits.$fBitsBool_$ccomplementBit
                                     Data.Bits.$fBitsBool_$ctestBit
                                     Data.Bits.$fBitsBool_$cbitSizeMaybe
                                     Data.Bits.$fBitsBool_$cbitSize
                                     Data.Bits.$fBitsBool_$cisSigned
                                     Data.Bits.$fBitsBool_$cshiftL
                                     Data.Bits.$fBitsBool_$cunsafeShiftL
                                     Data.Bits.$fBitsBool_$cshiftR
                                     Data.Bits.$fBitsBool_$cunsafeShiftR
                                     Data.Bits.$fBitsBool_$crotateL
                                     Data.Bits.$fBitsBool_$crotateR
                                     Data.Bits.$fBitsBool_$cpopCount];

Data.Bits.$fFiniteBitsBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.FiniteBits GHC.Types.Bool
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bits.C:FiniteBits! [Data.Bits.$fBitsBool
                                           Data.Bits.$fBitsBool_$cbitSize
                                           Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros
                                           Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros];

Data.Bits.$dmrotate
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),1*C1(C1(U)),A)><L,U><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H5I x_s1H5J i_s1H5K]
        case i_s1H5K of wild_s1H5L {
          GHC.Types.I# x1_s1H5M ->
              case <# [x1_s1H5M 0#] of {
                __DEFAULT ->
                    case ># [x1_s1H5M 0#] of {
                      __DEFAULT -> x_s1H5J;
                      1# -> Data.Bits.rotateL $dBits_s1H5I x_s1H5J wild_s1H5L;
                    };
                1# ->
                    case negateInt# [x1_s1H5M] of sat_s1H5P {
                      __DEFAULT ->
                          let {
                            sat_s1H5Q [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [sat_s1H5P];
                          } in  Data.Bits.rotateR $dBits_s1H5I x_s1H5J sat_s1H5Q;
                    };
              };
        };

Data.Bits.$dmshift
  :: forall a. Data.Bits.Bits a => a -> GHC.Types.Int -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,1*C1(C1(U)),A,A,A,A)><L,U><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H5R x_s1H5S i_s1H5T]
        case i_s1H5T of wild_s1H5U {
          GHC.Types.I# x1_s1H5V ->
              case <# [x1_s1H5V 0#] of {
                __DEFAULT ->
                    case ># [x1_s1H5V 0#] of {
                      __DEFAULT -> x_s1H5S;
                      1# -> Data.Bits.shiftL $dBits_s1H5R x_s1H5S wild_s1H5U;
                    };
                1# ->
                    case negateInt# [x1_s1H5V] of sat_s1H5Y {
                      __DEFAULT ->
                          let {
                            sat_s1H5Z [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [sat_s1H5Y];
                          } in  Data.Bits.shiftR $dBits_s1H5R x_s1H5S sat_s1H5Z;
                    };
              };
        };

Data.Bits.bitDefault [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     GHC.Types.Int -> a
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLLLLLLLLLC(C(S))LLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H60 $dNum_s1H61 i_s1H62]
        let {
          sat_s1H63 [Occ=Once] :: a_a1AlX
          [LclId] =
              [$dNum_s1H61] \u []
                  GHC.Num.fromInteger $dNum_s1H61 Data.Bits.$fBitsInteger3;
        } in  Data.Bits.shiftL $dBits_s1H60 sat_s1H63 i_s1H62;

Data.Bits.testBitDefault [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     a -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=4,
 Str=<S(S(LC(C(S)))LLLLLLLLLLLLLLLLLLLLLL),U(1*U(A,1*C1(C1(U))),1*C1(C1(U)),A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBits_s1H64 $dNum_s1H65 eta_s1H66 eta1_s1H67]
        let {
          sat_s1H6b [Occ=Once] :: a_a1AlK
          [LclId] =
              [$dNum_s1H65] \u []
                  GHC.Num.fromInteger
                      $dNum_s1H65 Data.Bits.$fBitsInteger_$czeroBits; } in
        let {
          sat_s1H6a [Occ=Once] :: a_a1AlK
          [LclId] =
              [$dBits_s1H64 eta_s1H66 eta1_s1H67] \u []
                  let {
                    sat_s1H69 [Occ=Once] :: a_a1AlK
                    [LclId] =
                        [$dBits_s1H64 eta1_s1H67] \u []
                            Data.Bits.bit $dBits_s1H64 eta1_s1H67;
                  } in  Data.Bits..&. $dBits_s1H64 eta_s1H66 sat_s1H69;
        } in 
          case Data.Bits.$p1Bits $dBits_s1H64 of sat_s1H68 {
            __DEFAULT -> GHC.Classes./= sat_s1H68 sat_s1H6a sat_s1H6b;
          };

Data.Bits.$fBitsInt2 :: GHC.Base.Maybe GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [Data.Bits.$fBitsInt1];

Data.Bits.$fBitsWord_$cbitSizeMaybe
  :: GHC.Types.Word -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m2, Unf=OtherCon []] =
    [] \r [i_s1H6c] Data.Bits.$fBitsInt2;

Data.Bits.$fBitsWord_$cbit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [i_s1H6d]
        case i_s1H6d of {
          GHC.Types.I# i#_s1H6f ->
              case >=# [i#_s1H6f 64#] of {
                __DEFAULT ->
                    case uncheckedShiftL# [1## i#_s1H6f] of sat_s1H6h {
                      __DEFAULT -> GHC.Types.W# [sat_s1H6h];
                    };
                1# -> Data.Bits.$fBitsWord1;
              };
        };

Data.Bits.$fBitsWord_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1H6i i_s1H6j]
        case x_s1H6i of {
          GHC.Types.W# x#_s1H6l [Occ=Once] ->
              case i_s1H6j of {
                GHC.Types.I# i#_s1H6n ->
                    case >=# [i#_s1H6n 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1H6n] of sat_s1H6p {
                            __DEFAULT ->
                                case and# [x#_s1H6l sat_s1H6p] of {
                                  __DEFAULT -> GHC.Types.True [];
                                  0## -> GHC.Types.False [];
                                };
                          };
                      1# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsWord_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H6r eta1_s1H6s]
        case eta_s1H6r of wild_s1H6t {
          GHC.Types.W# x#_s1H6u ->
              case eta1_s1H6s of {
                GHC.Types.I# x_s1H6w [Occ=Once] ->
                    case negateInt# [x_s1H6w] of sat_s1H6x {
                      __DEFAULT ->
                          case andI# [sat_s1H6x 63#] of wild2_s1H6y {
                            __DEFAULT ->
                                case -# [64# wild2_s1H6y] of sat_s1H6A {
                                  __DEFAULT ->
                                      case uncheckedShiftRL# [x#_s1H6u sat_s1H6A] of sat_s1H6B {
                                        __DEFAULT ->
                                            case
                                                uncheckedShiftL# [x#_s1H6u wild2_s1H6y]
                                            of
                                            sat_s1H6z
                                            { __DEFAULT ->
                                                  case or# [sat_s1H6z sat_s1H6B] of sat_s1H6C {
                                                    __DEFAULT -> GHC.Types.W# [sat_s1H6C];
                                                  };
                                            };
                                      };
                                };
                            0# -> wild_s1H6t;
                          };
                    };
              };
        };

Data.Bits.$fBitsWord_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H6D eta1_s1H6E]
        case eta_s1H6D of wild_s1H6F {
          GHC.Types.W# x#_s1H6G [Occ=Once] ->
              case eta1_s1H6E of {
                GHC.Types.I# i#_s1H6I ->
                    case >=# [i#_s1H6I 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1H6I] of sat_s1H6K {
                            __DEFAULT ->
                                case xor# [x#_s1H6G sat_s1H6K] of sat_s1H6L {
                                  __DEFAULT -> GHC.Types.W# [sat_s1H6L];
                                };
                          };
                      1# -> wild_s1H6F;
                    };
              };
        };

Data.Bits.$fBitsWord_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H6M eta1_s1H6N]
        case eta_s1H6M of {
          GHC.Types.W# x#_s1H6P [Occ=Once*] ->
              case eta1_s1H6N of {
                GHC.Types.I# i#_s1H6R ->
                    case >=# [i#_s1H6R 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1H6R] of sat_s1H6T {
                            __DEFAULT ->
                                case xor# [sat_s1H6T 18446744073709551615##] of sat_s1H6U {
                                  __DEFAULT ->
                                      case and# [x#_s1H6P sat_s1H6U] of sat_s1H6V {
                                        __DEFAULT -> GHC.Types.W# [sat_s1H6V];
                                      };
                                };
                          };
                      1# ->
                          case and# [x#_s1H6P 18446744073709551615##] of sat_s1H6W {
                            __DEFAULT -> GHC.Types.W# [sat_s1H6W];
                          };
                    };
              };
        };

Data.Bits.$fBitsWord_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H6X eta1_s1H6Y]
        case eta_s1H6X of wild_s1H6Z {
          GHC.Types.W# x#_s1H70 [Occ=Once] ->
              case eta1_s1H6Y of {
                GHC.Types.I# i#_s1H72 ->
                    case >=# [i#_s1H72 64#] of {
                      __DEFAULT ->
                          case uncheckedShiftL# [1## i#_s1H72] of sat_s1H74 {
                            __DEFAULT ->
                                case or# [x#_s1H70 sat_s1H74] of sat_s1H75 {
                                  __DEFAULT -> GHC.Types.W# [sat_s1H75];
                                };
                          };
                      1# -> wild_s1H6Z;
                    };
              };
        };

Data.Bits.$fBitsWord_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsWord_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Types.Word
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Classes.$fEqWord
                                     Data.Bits.$fBitsWord_$c.&.
                                     Data.Bits.$fBitsWord_$c.|.
                                     Data.Bits.$fBitsWord_$cxor
                                     Data.Bits.$fBitsWord_$ccomplement
                                     Data.Bits.$fBitsWord_$cshift
                                     Data.Bits.$fBitsWord_$crotate
                                     Data.Bits.$fBitsWord1
                                     Data.Bits.$fBitsWord_$cbit
                                     Data.Bits.$fBitsWord_$csetBit
                                     Data.Bits.$fBitsWord_$cclearBit
                                     Data.Bits.$fBitsWord_$ccomplementBit
                                     Data.Bits.$fBitsWord_$ctestBit
                                     Data.Bits.$fBitsWord_$cbitSizeMaybe
                                     Data.Bits.$fBitsWord_$cfiniteBitSize
                                     Data.Bits.$fBitsWord_$cisSigned
                                     Data.Bits.$fBitsWord_$cshiftL
                                     Data.Bits.$fBitsWord_$cunsafeShiftL
                                     Data.Bits.$fBitsWord_$cshiftR
                                     Data.Bits.$fBitsWord_$cunsafeShiftR
                                     Data.Bits.$fBitsWord_$crotateL
                                     Data.Bits.$fBitsWord_$crotateR
                                     Data.Bits.$fBitsWord_$cpopCount];

Data.Bits.$fFiniteBitsWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.FiniteBits GHC.Types.Word
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bits.C:FiniteBits! [Data.Bits.$fBitsWord
                                           Data.Bits.$fBitsWord_$cfiniteBitSize
                                           Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros
                                           Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros];

Data.Bits.$fBitsInt_$cbitSizeMaybe
  :: GHC.Types.Int -> GHC.Base.Maybe GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m2, Unf=OtherCon []] =
    [] \r [i_s1H76] Data.Bits.$fBitsInt2;

Data.Bits.$fBitsInt_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bits.$fBitsInt_$crotate eta_B2 eta_B1;

Data.Bits.$fBitsInt_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H77 eta1_s1H78]
        case eta_s1H77 of {
          GHC.Types.I# x#_s1H7a ->
              case eta1_s1H78 of {
                GHC.Types.I# x_s1H7c [Occ=Once] ->
                    case negateInt# [x_s1H7c] of sat_s1H7e {
                      __DEFAULT ->
                          case andI# [sat_s1H7e 63#] of i'#_s1H7d [Dmd=<S,U>] {
                            __DEFAULT ->
                                case -# [64# i'#_s1H7d] of sat_s1H7g {
                                  __DEFAULT ->
                                      case uncheckedIShiftRL# [x#_s1H7a sat_s1H7g] of sat_s1H7h {
                                        __DEFAULT ->
                                            case
                                                uncheckedIShiftL# [x#_s1H7a i'#_s1H7d]
                                            of
                                            sat_s1H7f
                                            { __DEFAULT ->
                                                  case orI# [sat_s1H7f sat_s1H7h] of sat_s1H7i {
                                                    __DEFAULT -> GHC.Types.I# [sat_s1H7i];
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$cbit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [i_s1H7j]
        case i_s1H7j of {
          GHC.Types.I# i#_s1H7l ->
              case >=# [i#_s1H7l 64#] of {
                __DEFAULT ->
                    case uncheckedIShiftL# [1# i#_s1H7l] of sat_s1H7n {
                      __DEFAULT -> GHC.Types.I# [sat_s1H7n];
                    };
                1# -> Data.Bits.$fBitsBool2;
              };
        };

Data.Bits.$fBitsInt_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_s1H7o i_s1H7p]
        case x_s1H7o of {
          GHC.Types.I# x#_s1H7r [Occ=Once] ->
              case i_s1H7p of {
                GHC.Types.I# i#_s1H7t ->
                    case >=# [i#_s1H7t 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1H7t] of sat_s1H7v {
                            __DEFAULT ->
                                case andI# [x#_s1H7r sat_s1H7v] of {
                                  __DEFAULT -> GHC.Types.True [];
                                  0# -> GHC.Types.False [];
                                };
                          };
                      1# -> GHC.Types.False [];
                    };
              };
        };

Data.Bits.$fBitsInt_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H7x eta1_s1H7y]
        case eta_s1H7x of wild_s1H7z {
          GHC.Types.I# x#_s1H7A [Occ=Once] ->
              case eta1_s1H7y of {
                GHC.Types.I# i#_s1H7C ->
                    case >=# [i#_s1H7C 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1H7C] of sat_s1H7E {
                            __DEFAULT ->
                                case orI# [x#_s1H7A sat_s1H7E] of sat_s1H7F {
                                  __DEFAULT -> GHC.Types.I# [sat_s1H7F];
                                };
                          };
                      1# -> wild_s1H7z;
                    };
              };
        };

Data.Bits.$fBitsInt_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H7G eta1_s1H7H]
        case eta_s1H7G of {
          GHC.Types.I# x#_s1H7J [Occ=Once*] ->
              case eta1_s1H7H of {
                GHC.Types.I# i#_s1H7L ->
                    case >=# [i#_s1H7L 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1H7L] of sat_s1H7N {
                            __DEFAULT ->
                                case notI# [sat_s1H7N] of sat_s1H7O {
                                  __DEFAULT ->
                                      case andI# [x#_s1H7J sat_s1H7O] of sat_s1H7P {
                                        __DEFAULT -> GHC.Types.I# [sat_s1H7P];
                                      };
                                };
                          };
                      1# ->
                          case andI# [x#_s1H7J -1#] of sat_s1H7Q {
                            __DEFAULT -> GHC.Types.I# [sat_s1H7Q];
                          };
                    };
              };
        };

Data.Bits.$fBitsInt_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s1H7R eta1_s1H7S]
        case eta_s1H7R of wild_s1H7T {
          GHC.Types.I# x#_s1H7U [Occ=Once] ->
              case eta1_s1H7S of {
                GHC.Types.I# i#_s1H7W ->
                    case >=# [i#_s1H7W 64#] of {
                      __DEFAULT ->
                          case uncheckedIShiftL# [1# i#_s1H7W] of sat_s1H7Y {
                            __DEFAULT ->
                                case xorI# [x#_s1H7U sat_s1H7Y] of sat_s1H7Z {
                                  __DEFAULT -> GHC.Types.I# [sat_s1H7Z];
                                };
                          };
                      1# -> wild_s1H7T;
                    };
              };
        };

Data.Bits.$fBitsInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Types.Int
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Classes.$fEqInt
                                     Data.Bits.$fBitsInt_$c.&.
                                     Data.Bits.$fBitsInt_$c.|.
                                     Data.Bits.$fBitsInt_$cxor
                                     Data.Bits.$fBitsInt_$ccomplement
                                     Data.Bits.$fBitsInt_$cshift
                                     Data.Bits.$fBitsInt_$crotate
                                     Data.Bits.$fBitsBool2
                                     Data.Bits.$fBitsInt_$cbit
                                     Data.Bits.$fBitsInt_$csetBit
                                     Data.Bits.$fBitsInt_$cclearBit
                                     Data.Bits.$fBitsInt_$ccomplementBit
                                     Data.Bits.$fBitsInt_$ctestBit
                                     Data.Bits.$fBitsInt_$cbitSizeMaybe
                                     Data.Bits.$fBitsInt_$cfiniteBitSize
                                     Data.Bits.$fBitsInt_$cisSigned
                                     Data.Bits.$fBitsInt_$cshiftL
                                     Data.Bits.$fBitsInt_$cunsafeShiftL
                                     Data.Bits.$fBitsInt_$cshiftR
                                     Data.Bits.$fBitsInt_$cunsafeShiftR
                                     Data.Bits.$fBitsInt_$crotateL
                                     Data.Bits.$fBitsInt_$crotateR
                                     Data.Bits.$fBitsInt_$cpopCount];

Data.Bits.$fFiniteBitsInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.FiniteBits GHC.Types.Int
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bits.C:FiniteBits! [Data.Bits.$fBitsInt
                                           Data.Bits.$fBitsInt_$cfiniteBitSize
                                           Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros
                                           Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros];

Data.Bits.$wpopCountDefault [InlPrag=INLINABLE[0]]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     a -> GHC.Prim.Int#
[GblId,
 Arity=3,
 Str=<S(S(C(C(S))L)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s1H80 w1_s1H81 w2_s1H82]
        let {
          lvl1_s1H83 [Occ=OnceL] :: a_s1C1X
          [LclId] =
              [w1_s1H81] \u []
                  GHC.Num.fromInteger w1_s1H81 Data.Bits.$fBitsInteger3; } in
        let {
          lvl2_s1H84 [Occ=OnceL] :: a_s1C1X
          [LclId] =
              [w1_s1H81] \u []
                  GHC.Num.fromInteger w1_s1H81 Data.Bits.$fBitsInteger_$czeroBits;
        } in 
          case
              Data.Bits.$p1Bits w_s1H80
          of
          $dEq_s1H85 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
          { __DEFAULT ->
                let-no-escape {
                  $wgo_s1H86 [InlPrag=NOUSERINLINE[0], Occ=LoopBreakerT[2]]
                    :: GHC.Prim.Int# -> a_s1C1X -> GHC.Prim.Int#
                  [LclId[JoinId(2)], Arity=2, Str=<S,U><L,U>, Unf=OtherCon []] =
                      sat-only [w_s1H80
                                w1_s1H81
                                lvl1_s1H83
                                lvl2_s1H84
                                $dEq_s1H85
                                $wgo_s1H86] \r [ww_s1H87 w3_s1H88]
                          case GHC.Classes.== $dEq_s1H85 w3_s1H88 lvl2_s1H84 of {
                            GHC.Types.False ->
                                let {
                                  sat_s1H8c [Occ=Once] :: a_s1C1X
                                  [LclId] =
                                      [w_s1H80 w1_s1H81 lvl1_s1H83 w3_s1H88] \u []
                                          let {
                                            sat_s1H8b [Occ=Once] :: a_s1C1X
                                            [LclId] =
                                                [w1_s1H81 lvl1_s1H83 w3_s1H88] \u []
                                                    GHC.Num.- w1_s1H81 w3_s1H88 lvl1_s1H83;
                                          } in  Data.Bits..&. w_s1H80 w3_s1H88 sat_s1H8b;
                                } in 
                                  case +# [ww_s1H87 1#] of sat_s1H8a {
                                    __DEFAULT -> $wgo_s1H86 sat_s1H8a sat_s1H8c;
                                  };
                            GHC.Types.True -> ww_s1H87;
                          };
                } in  $wgo_s1H86 0# w2_s1H82;
          };

Data.Bits.popCountDefault [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Data.Bits.Bits a, GHC.Num.Num a) =>
     a -> GHC.Types.Int
[GblId,
 Arity=3,
 Str=<S(S(C(C(S))L)LLLLLLLLLLLLLLLLLLLLLL),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,C(U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_s1H8d w1_s1H8e w2_s1H8f]
        case
            Data.Bits.$wpopCountDefault w_s1H8d w1_s1H8e w2_s1H8f
        of
        ww_s1H8g
        { __DEFAULT -> GHC.Types.I# [ww_s1H8g];
        };

Data.Bits.$fBitsInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bits.Bits GHC.Integer.Type.Integer
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Bits.C:Bits! [GHC.Integer.Type.$fEqInteger
                                     GHC.Integer.Type.andInteger
                                     GHC.Integer.Type.orInteger
                                     GHC.Integer.Type.xorInteger
                                     GHC.Integer.Type.complementInteger
                                     Data.Bits.$fBitsInteger_$cshift
                                     Data.Bits.$fBitsInteger_$cshift
                                     Data.Bits.$fBitsInteger_$czeroBits
                                     Data.Bits.$fBitsInteger_$cbit
                                     Data.Bits.$fBitsInteger_$csetBit
                                     Data.Bits.$fBitsInteger_$cclearBit
                                     Data.Bits.$fBitsInteger_$ccomplementBit
                                     Data.Bits.$fBitsInteger_$ctestBit
                                     Data.Bits.$fBitsInteger_$cbitSizeMaybe
                                     Data.Bits.$fBitsInteger_$cbitSize
                                     Data.Bits.$fBitsInteger_$cisSigned
                                     Data.Bits.$fBitsInteger_$cshiftL
                                     Data.Bits.$fBitsInteger_$cunsafeShiftL
                                     Data.Bits.$fBitsInteger_$cshiftR
                                     Data.Bits.$fBitsInteger_$cunsafeShiftR
                                     Data.Bits.$fBitsInteger_$crotateL
                                     Data.Bits.$fBitsInteger_$crotateR
                                     Data.Bits.$fBitsInteger_$cpopCount];
Data.Bits.$fBitsInteger_$cpopCount [Occ=LoopBreaker]
  :: GHC.Integer.Type.Integer -> GHC.Types.Int
[GblId, Arity=1, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [w_s1H8h]
        case
            Data.Bits.$wpopCountDefault
                Data.Bits.$fBitsInteger GHC.Num.$fNumInteger w_s1H8h
        of
        ww_s1H8i
        { __DEFAULT -> GHC.Types.I# [ww_s1H8i];
        };

Data.Bits.toIntegralSized [InlPrag=INLINABLE]
  :: forall a b.
     (GHC.Real.Integral a, GHC.Real.Integral b, Data.Bits.Bits a,
      Data.Bits.Bits b) =>
     a -> GHC.Base.Maybe b
[GblId,
 Arity=5,
 Str=<L,U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U)),1*U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,1*C1(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(LLLLLLLLLLLLLC(S)LLLLLLLLL),U(A,A,A,A,A,A,A,A,C(U),A,A,A,A,1*C1(U),A,1*C1(U),A,A,A,A,A,A,A)><S(LLLLLLLLLLLLLC(S)LC(S)LLLLLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,1*C1(U),A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s1H8j
           $dIntegral1_s1H8k
           $dBits_s1H8l
           $dBits1_s1H8m
           eta_s1H8n]
        case
            Data.Bits.bitSizeMaybe $dBits_s1H8l eta_s1H8n
        of
        xWidth_s1H8o [Dmd=<S,U>]
        { __DEFAULT ->
              let {
                y_s1H8p :: b_a1AhY
                [LclId] =
                    [$dIntegral_s1H8j $dIntegral1_s1H8k eta_s1H8n] \u []
                        let {
                          sat_s1H8s [Occ=Once] :: GHC.Integer.Type.Integer
                          [LclId] =
                              [$dIntegral_s1H8j eta_s1H8n] \u []
                                  GHC.Real.toInteger $dIntegral_s1H8j eta_s1H8n;
                        } in 
                          case GHC.Real.$p1Integral $dIntegral1_s1H8k of sat_s1H8q {
                            __DEFAULT ->
                                case GHC.Real.$p1Real sat_s1H8q of sat_s1H8r {
                                  __DEFAULT -> GHC.Num.fromInteger sat_s1H8r sat_s1H8s;
                                };
                          };
              } in 
                case
                    Data.Bits.isSigned $dBits1_s1H8m y_s1H8p
                of
                ySigned_s1H8t [Dmd=<S,U>]
                { __DEFAULT ->
                      case
                          Data.Bits.bitSizeMaybe $dBits1_s1H8m y_s1H8p
                      of
                      yWidth_s1H8u [Dmd=<S,U>]
                      { __DEFAULT ->
                            let {
                              xSigned_s1H8v :: GHC.Types.Bool
                              [LclId] =
                                  [$dBits_s1H8l eta_s1H8n] \u []
                                      Data.Bits.isSigned $dBits_s1H8l eta_s1H8n; } in
                            let {
                              $dReal_s1H8w [Dmd=<L,U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U)),1*U(A,A,A,C(C1(U)),A,A,A,A),A)>]
                                :: GHC.Real.Real a_a1AhX
                              [LclId] =
                                  [$dIntegral_s1H8j] \u []
                                      GHC.Real.$p1Integral $dIntegral_s1H8j; } in
                            let {
                              $dNum_s1H8x [Dmd=<L,U(A,1*C1(C1(U)),A,1*C1(U),A,A,C(U))>]
                                :: GHC.Num.Num a_a1AhX
                              [LclId] =
                                  [$dReal_s1H8w] \u [] GHC.Real.$p1Real $dReal_s1H8w; } in
                            let {
                              $dOrd_s1H8y [Dmd=<L,U(A,A,A,C(C1(U)),A,A,A,A)>]
                                :: GHC.Classes.Ord a_a1AhX
                              [LclId] =
                                  [$dReal_s1H8w] \u [] GHC.Real.$p2Real $dReal_s1H8w;
                            } in 
                              let-no-escape {
                                $j_s1H8z [Dmd=<L,1*U>] :: GHC.Base.Maybe b_a1AhY
                                [LclId[JoinId(0)], Unf=OtherCon []] =
                                    [$dBits_s1H8l
                                     eta_s1H8n
                                     xWidth_s1H8o
                                     y_s1H8p
                                     ySigned_s1H8t
                                     yWidth_s1H8u
                                     xSigned_s1H8v
                                     $dNum_s1H8x
                                     $dOrd_s1H8y] \r []
                                        let-no-escape {
                                          fail_s1H8A [Dmd=<L,1*C1(U)>]
                                            :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                              sat-only [$dBits_s1H8l
                                                        eta_s1H8n
                                                        xWidth_s1H8o
                                                        y_s1H8p
                                                        ySigned_s1H8t
                                                        yWidth_s1H8u
                                                        xSigned_s1H8v
                                                        $dNum_s1H8x
                                                        $dOrd_s1H8y] \r [void_0E]
                                                  let-no-escape {
                                                    fail1_s1H8C [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                                      :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                                    [LclId[JoinId(1)],
                                                     Arity=1,
                                                     Str=<L,A>,
                                                     Unf=OtherCon []] =
                                                        sat-only [$dBits_s1H8l
                                                                  eta_s1H8n
                                                                  xWidth_s1H8o
                                                                  y_s1H8p
                                                                  ySigned_s1H8t
                                                                  yWidth_s1H8u
                                                                  xSigned_s1H8v
                                                                  $dNum_s1H8x
                                                                  $dOrd_s1H8y] \r [void_0E]
                                                            let-no-escape {
                                                              fail2_s1H8E [Occ=Once*!T[1],
                                                                           Dmd=<L,1*C1(U)>]
                                                                :: GHC.Prim.Void#
                                                                   -> GHC.Base.Maybe b_a1AhY
                                                              [LclId[JoinId(1)],
                                                               Arity=1,
                                                               Str=<L,A>,
                                                               Unf=OtherCon []] =
                                                                  sat-only [$dBits_s1H8l
                                                                            eta_s1H8n
                                                                            xWidth_s1H8o
                                                                            y_s1H8p
                                                                            ySigned_s1H8t
                                                                            yWidth_s1H8u
                                                                            xSigned_s1H8v
                                                                            $dNum_s1H8x
                                                                            $dOrd_s1H8y] \r [void_0E]
                                                                      let-no-escape {
                                                                        $j1_s1H8G [Dmd=<L,1*U>]
                                                                          :: GHC.Base.Maybe b_a1AhY
                                                                        [LclId[JoinId(0)],
                                                                         Unf=OtherCon []] =
                                                                            [$dBits_s1H8l
                                                                             eta_s1H8n
                                                                             xWidth_s1H8o
                                                                             y_s1H8p
                                                                             ySigned_s1H8t
                                                                             yWidth_s1H8u
                                                                             xSigned_s1H8v
                                                                             $dNum_s1H8x
                                                                             $dOrd_s1H8y] \r []
                                                                                let-no-escape {
                                                                                  fail3_s1H8H [Occ=Once*!T[1],
                                                                                               Dmd=<L,1*C1(U)>]
                                                                                    :: GHC.Prim.Void#
                                                                                       -> GHC.Base.Maybe
                                                                                            b_a1AhY
                                                                                  [LclId[JoinId(1)],
                                                                                   Arity=1,
                                                                                   Str=<L,A>,
                                                                                   Unf=OtherCon []] =
                                                                                      sat-only [$dBits_s1H8l
                                                                                                eta_s1H8n
                                                                                                y_s1H8p
                                                                                                ySigned_s1H8t
                                                                                                yWidth_s1H8u
                                                                                                $dNum_s1H8x
                                                                                                $dOrd_s1H8y] \r [void_0E]
                                                                                          case
                                                                                              yWidth_s1H8u
                                                                                          of
                                                                                          { GHC.Base.Nothing ->
                                                                                                GHC.Base.Just [y_s1H8p];
                                                                                            GHC.Base.Just yW_s1H8K [Occ=Once*] ->
                                                                                                case
                                                                                                    ySigned_s1H8t
                                                                                                of
                                                                                                { GHC.Types.False ->
                                                                                                      let {
                                                                                                        sat_s1H8O [Occ=Once]
                                                                                                          :: a_a1AhX
                                                                                                        [LclId] =
                                                                                                            [$dBits_s1H8l
                                                                                                             $dNum_s1H8x
                                                                                                             yW_s1H8K] \u []
                                                                                                                let {
                                                                                                                  sat_s1H8N [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dNum_s1H8x] \u []
                                                                                                                          GHC.Num.fromInteger
                                                                                                                              $dNum_s1H8x
                                                                                                                              Data.Bits.$fBitsInteger3; } in
                                                                                                                let {
                                                                                                                  sat_s1H8M [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dBits_s1H8l
                                                                                                                       yW_s1H8K] \u []
                                                                                                                          Data.Bits.bit
                                                                                                                              $dBits_s1H8l
                                                                                                                              yW_s1H8K;
                                                                                                                } in 
                                                                                                                  GHC.Num.-
                                                                                                                      $dNum_s1H8x
                                                                                                                      sat_s1H8M
                                                                                                                      sat_s1H8N;
                                                                                                      } in 
                                                                                                        case
                                                                                                            GHC.Classes.<=
                                                                                                                $dOrd_s1H8y
                                                                                                                eta_s1H8n
                                                                                                                sat_s1H8O
                                                                                                        of
                                                                                                        { GHC.Types.False ->
                                                                                                              GHC.Base.Nothing [];
                                                                                                          GHC.Types.True ->
                                                                                                              GHC.Base.Just [y_s1H8p];
                                                                                                        };
                                                                                                  GHC.Types.True ->
                                                                                                      let {
                                                                                                        sat_s1H8W [Occ=Once]
                                                                                                          :: a_a1AhX
                                                                                                        [LclId] =
                                                                                                            [$dBits_s1H8l
                                                                                                             $dNum_s1H8x
                                                                                                             yW_s1H8K] \u []
                                                                                                                let {
                                                                                                                  sat_s1H8V [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dNum_s1H8x] \u []
                                                                                                                          GHC.Num.fromInteger
                                                                                                                              $dNum_s1H8x
                                                                                                                              Data.Bits.$fBitsInteger3; } in
                                                                                                                let {
                                                                                                                  sat_s1H8U [Occ=Once]
                                                                                                                    :: a_a1AhX
                                                                                                                  [LclId] =
                                                                                                                      [$dBits_s1H8l
                                                                                                                       yW_s1H8K] \u []
                                                                                                                          let {
                                                                                                                            sat_s1H8T [Occ=Once]
                                                                                                                              :: GHC.Types.Int
                                                                                                                            [LclId] =
                                                                                                                                [yW_s1H8K] \u []
                                                                                                                                    case
                                                                                                                                        yW_s1H8K
                                                                                                                                    of
                                                                                                                                    { GHC.Types.I# x_s1H8R [Occ=Once] ->
                                                                                                                                          case
                                                                                                                                              -# [x_s1H8R
                                                                                                                                                  1#]
                                                                                                                                          of
                                                                                                                                          sat_s1H8S
                                                                                                                                          { __DEFAULT ->
                                                                                                                                                GHC.Types.I# [sat_s1H8S];
                                                                                                                                          };
                                                                                                                                    };
                                                                                                                          } in 
                                                                                                                            Data.Bits.bit
                                                                                                                                $dBits_s1H8l
                                                                                                                                sat_s1H8T;
                                                                                                                } in 
                                                                                                                  GHC.Num.-
                                                                                                                      $dNum_s1H8x
                                                                                                                      sat_s1H8U
                                                                                                                      sat_s1H8V;
                                                                                                      } in 
                                                                                                        case
                                                                                                            GHC.Classes.<=
                                                                                                                $dOrd_s1H8y
                                                                                                                eta_s1H8n
                                                                                                                sat_s1H8W
                                                                                                        of
                                                                                                        { GHC.Types.False ->
                                                                                                              GHC.Base.Nothing [];
                                                                                                          GHC.Types.True ->
                                                                                                              GHC.Base.Just [y_s1H8p];
                                                                                                        };
                                                                                                };
                                                                                          };
                                                                                } in 
                                                                                  case
                                                                                      xSigned_s1H8v
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        fail3_s1H8H
                                                                                            GHC.Prim.void#;
                                                                                    GHC.Types.True ->
                                                                                        case
                                                                                            ySigned_s1H8t
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              case
                                                                                                  xWidth_s1H8o
                                                                                              of
                                                                                              { GHC.Base.Nothing ->
                                                                                                    fail3_s1H8H
                                                                                                        GHC.Prim.void#;
                                                                                                GHC.Base.Just xW_s1H91 [Occ=Once!] ->
                                                                                                    case
                                                                                                        yWidth_s1H8u
                                                                                                    of
                                                                                                    { GHC.Base.Nothing ->
                                                                                                          fail3_s1H8H
                                                                                                              GHC.Prim.void#;
                                                                                                      GHC.Base.Just yW_s1H93 [Occ=Once!] ->
                                                                                                          case
                                                                                                              yW_s1H93
                                                                                                          of
                                                                                                          { GHC.Types.I# x_s1H95 [Occ=Once] ->
                                                                                                                case
                                                                                                                    xW_s1H91
                                                                                                                of
                                                                                                                { GHC.Types.I# x1_s1H97 [Occ=Once] ->
                                                                                                                      case
                                                                                                                          +# [x_s1H95
                                                                                                                              1#]
                                                                                                                      of
                                                                                                                      sat_s1H98
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                <=# [x1_s1H97
                                                                                                                                     sat_s1H98]
                                                                                                                            of
                                                                                                                            { __DEFAULT ->
                                                                                                                                  fail3_s1H8H
                                                                                                                                      GHC.Prim.void#;
                                                                                                                              1# ->
                                                                                                                                  GHC.Base.Just [y_s1H8p];
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                          GHC.Types.True ->
                                                                                              fail3_s1H8H
                                                                                                  GHC.Prim.void#;
                                                                                        };
                                                                                  };
                                                                      } in 
                                                                        let-no-escape {
                                                                          fail3_s1H9a [Dmd=<L,1*C1(U)>]
                                                                            :: GHC.Prim.Void#
                                                                               -> GHC.Base.Maybe
                                                                                    b_a1AhY
                                                                          [LclId[JoinId(1)],
                                                                           Arity=1,
                                                                           Str=<L,A>,
                                                                           Unf=OtherCon []] =
                                                                              sat-only [xWidth_s1H8o
                                                                                        y_s1H8p
                                                                                        ySigned_s1H8t
                                                                                        yWidth_s1H8u
                                                                                        xSigned_s1H8v
                                                                                        $j1_s1H8G] \r [void_0E]
                                                                                  case
                                                                                      xSigned_s1H8v
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        case
                                                                                            ySigned_s1H8t
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              $j1_s1H8G;
                                                                                          GHC.Types.True ->
                                                                                              case
                                                                                                  xWidth_s1H8o
                                                                                              of
                                                                                              { GHC.Base.Nothing ->
                                                                                                    $j1_s1H8G;
                                                                                                GHC.Base.Just xW_s1H9f [Occ=Once!] ->
                                                                                                    case
                                                                                                        yWidth_s1H8u
                                                                                                    of
                                                                                                    { GHC.Base.Nothing ->
                                                                                                          $j1_s1H8G;
                                                                                                      GHC.Base.Just yW_s1H9h [Occ=Once!] ->
                                                                                                          case
                                                                                                              xW_s1H9f
                                                                                                          of
                                                                                                          { GHC.Types.I# x_s1H9j [Occ=Once] ->
                                                                                                                case
                                                                                                                    yW_s1H9h
                                                                                                                of
                                                                                                                { GHC.Types.I# y1_s1H9l [Occ=Once] ->
                                                                                                                      case
                                                                                                                          <# [x_s1H9j
                                                                                                                              y1_s1H9l]
                                                                                                                      of
                                                                                                                      { __DEFAULT ->
                                                                                                                            $j1_s1H8G;
                                                                                                                        1# ->
                                                                                                                            GHC.Base.Just [y_s1H8p];
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                    GHC.Types.True ->
                                                                                        $j1_s1H8G;
                                                                                  };
                                                                        } in 
                                                                          let-no-escape {
                                                                            $j2_s1H9n [Occ=Once*T[0],
                                                                                       Dmd=<L,1*U>]
                                                                              :: GHC.Base.Maybe
                                                                                   b_a1AhY
                                                                            [LclId[JoinId(0)],
                                                                             Unf=OtherCon []] =
                                                                                [xWidth_s1H8o
                                                                                 y_s1H8p
                                                                                 yWidth_s1H8u
                                                                                 $j1_s1H8G
                                                                                 fail3_s1H9a] \r []
                                                                                    case
                                                                                        xWidth_s1H8o
                                                                                    of
                                                                                    { GHC.Base.Nothing ->
                                                                                          fail3_s1H9a
                                                                                              GHC.Prim.void#;
                                                                                      GHC.Base.Just xW_s1H9p [Occ=Once!] ->
                                                                                          case
                                                                                              yWidth_s1H8u
                                                                                          of
                                                                                          { GHC.Base.Nothing ->
                                                                                                fail3_s1H9a
                                                                                                    GHC.Prim.void#;
                                                                                            GHC.Base.Just yW_s1H9r [Occ=Once!] ->
                                                                                                case
                                                                                                    xW_s1H9p
                                                                                                of
                                                                                                { GHC.Types.I# x_s1H9t [Occ=Once] ->
                                                                                                      case
                                                                                                          yW_s1H9r
                                                                                                      of
                                                                                                      { GHC.Types.I# y1_s1H9v [Occ=Once] ->
                                                                                                            case
                                                                                                                <=# [x_s1H9t
                                                                                                                     y1_s1H9v]
                                                                                                            of
                                                                                                            { __DEFAULT ->
                                                                                                                  $j1_s1H8G;
                                                                                                              1# ->
                                                                                                                  GHC.Base.Just [y_s1H8p];
                                                                                                            };
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                          } in 
                                                                            case xSigned_s1H8v of {
                                                                              GHC.Types.False ->
                                                                                  case
                                                                                      ySigned_s1H8t
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        $j2_s1H9n;
                                                                                    GHC.Types.True ->
                                                                                        fail3_s1H9a
                                                                                            GHC.Prim.void#;
                                                                                  };
                                                                              GHC.Types.True ->
                                                                                  case
                                                                                      ySigned_s1H8t
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        fail3_s1H9a
                                                                                            GHC.Prim.void#;
                                                                                    GHC.Types.True ->
                                                                                        $j2_s1H9n;
                                                                                  };
                                                                            };
                                                            } in 
                                                              case xSigned_s1H8v of {
                                                                GHC.Types.False ->
                                                                    case ySigned_s1H8t of {
                                                                      GHC.Types.False ->
                                                                          case yWidth_s1H8u of {
                                                                            GHC.Base.Nothing ->
                                                                                GHC.Base.Just [y_s1H8p];
                                                                            GHC.Base.Just _ [Occ=Dead] ->
                                                                                fail2_s1H8E
                                                                                    GHC.Prim.void#;
                                                                          };
                                                                      GHC.Types.True ->
                                                                          fail2_s1H8E
                                                                              GHC.Prim.void#;
                                                                    };
                                                                GHC.Types.True ->
                                                                    fail2_s1H8E GHC.Prim.void#;
                                                              };
                                                  } in 
                                                    case ySigned_s1H8t of {
                                                      GHC.Types.False -> fail1_s1H8C GHC.Prim.void#;
                                                      GHC.Types.True ->
                                                          case yWidth_s1H8u of {
                                                            GHC.Base.Nothing ->
                                                                GHC.Base.Just [y_s1H8p];
                                                            GHC.Base.Just _ [Occ=Dead] ->
                                                                fail1_s1H8C GHC.Prim.void#;
                                                          };
                                                    };
                                        } in 
                                          let-no-escape {
                                            $j1_s1H9H [Occ=Once*T[0], Dmd=<L,1*U>]
                                              :: GHC.Base.Maybe b_a1AhY
                                            [LclId[JoinId(0)], Unf=OtherCon []] =
                                                [y_s1H8p
                                                 ySigned_s1H8t
                                                 xSigned_s1H8v
                                                 fail_s1H8A] \r []
                                                    case xSigned_s1H8v of {
                                                      GHC.Types.False ->
                                                          case ySigned_s1H8t of {
                                                            GHC.Types.False ->
                                                                GHC.Base.Just [y_s1H8p];
                                                            GHC.Types.True ->
                                                                fail_s1H8A GHC.Prim.void#;
                                                          };
                                                      GHC.Types.True ->
                                                          case ySigned_s1H8t of {
                                                            GHC.Types.False ->
                                                                fail_s1H8A GHC.Prim.void#;
                                                            GHC.Types.True ->
                                                                GHC.Base.Just [y_s1H8p];
                                                          };
                                                    };
                                          } in 
                                            case xWidth_s1H8o of {
                                              GHC.Base.Nothing ->
                                                  case yWidth_s1H8u of {
                                                    GHC.Base.Nothing -> $j1_s1H9H;
                                                    GHC.Base.Just _ [Occ=Dead] ->
                                                        fail_s1H8A GHC.Prim.void#;
                                                  };
                                              GHC.Base.Just a1_s1H9O [Occ=Once!] ->
                                                  case yWidth_s1H8u of {
                                                    GHC.Base.Nothing -> fail_s1H8A GHC.Prim.void#;
                                                    GHC.Base.Just b1_s1H9Q [Occ=Once!] ->
                                                        case a1_s1H9O of {
                                                          GHC.Types.I# x_s1H9S [Occ=Once] ->
                                                              case b1_s1H9Q of {
                                                                GHC.Types.I# y1_s1H9U [Occ=Once] ->
                                                                    case ==# [x_s1H9S y1_s1H9U] of {
                                                                      __DEFAULT ->
                                                                          fail_s1H8A GHC.Prim.void#;
                                                                      1# -> $j1_s1H9H;
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                              } in 
                                let-no-escape {
                                  fail_s1H9W [Dmd=<L,1*C1(U)>]
                                    :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                  [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                      sat-only [$dBits_s1H8l
                                                eta_s1H8n
                                                xWidth_s1H8o
                                                ySigned_s1H8t
                                                yWidth_s1H8u
                                                xSigned_s1H8v
                                                $dNum_s1H8x
                                                $dOrd_s1H8y
                                                $j_s1H8z] \r [void_0E]
                                          let-no-escape {
                                            fail1_s1H9Y [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                              :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                            [LclId[JoinId(1)],
                                             Arity=1,
                                             Str=<L,A>,
                                             Unf=OtherCon []] =
                                                sat-only [$dBits_s1H8l
                                                          eta_s1H8n
                                                          xWidth_s1H8o
                                                          ySigned_s1H8t
                                                          yWidth_s1H8u
                                                          xSigned_s1H8v
                                                          $dNum_s1H8x
                                                          $dOrd_s1H8y
                                                          $j_s1H8z] \r [void_0E]
                                                    let-no-escape {
                                                      fail2_s1Ha0 [Occ=Once*!T[1], Dmd=<L,1*C1(U)>]
                                                        :: GHC.Prim.Void# -> GHC.Base.Maybe b_a1AhY
                                                      [LclId[JoinId(1)],
                                                       Arity=1,
                                                       Str=<L,A>,
                                                       Unf=OtherCon []] =
                                                          sat-only [$dBits_s1H8l
                                                                    eta_s1H8n
                                                                    xWidth_s1H8o
                                                                    ySigned_s1H8t
                                                                    yWidth_s1H8u
                                                                    xSigned_s1H8v
                                                                    $dNum_s1H8x
                                                                    $dOrd_s1H8y
                                                                    $j_s1H8z] \r [void_0E]
                                                              let-no-escape {
                                                                $j1_s1Ha2 [Dmd=<L,1*U>]
                                                                  :: GHC.Base.Maybe b_a1AhY
                                                                [LclId[JoinId(0)],
                                                                 Unf=OtherCon []] =
                                                                    [$dBits_s1H8l
                                                                     eta_s1H8n
                                                                     ySigned_s1H8t
                                                                     yWidth_s1H8u
                                                                     xSigned_s1H8v
                                                                     $dNum_s1H8x
                                                                     $dOrd_s1H8y
                                                                     $j_s1H8z] \r []
                                                                        let-no-escape {
                                                                          fail3_s1Ha3 [Occ=Once*!T[1],
                                                                                       Dmd=<L,1*C1(U)>]
                                                                            :: GHC.Prim.Void#
                                                                               -> GHC.Base.Maybe
                                                                                    b_a1AhY
                                                                          [LclId[JoinId(1)],
                                                                           Arity=1,
                                                                           Str=<L,A>,
                                                                           Unf=OtherCon []] =
                                                                              sat-only [$dBits_s1H8l
                                                                                        eta_s1H8n
                                                                                        ySigned_s1H8t
                                                                                        yWidth_s1H8u
                                                                                        xSigned_s1H8v
                                                                                        $dNum_s1H8x
                                                                                        $dOrd_s1H8y
                                                                                        $j_s1H8z] \r [void_0E]
                                                                                  case
                                                                                      xSigned_s1H8v
                                                                                  of
                                                                                  { GHC.Types.False ->
                                                                                        $j_s1H8z;
                                                                                    GHC.Types.True ->
                                                                                        case
                                                                                            ySigned_s1H8t
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              $j_s1H8z;
                                                                                          GHC.Types.True ->
                                                                                              case
                                                                                                  yWidth_s1H8u
                                                                                              of
                                                                                              { GHC.Base.Nothing ->
                                                                                                    $j_s1H8z;
                                                                                                GHC.Base.Just yW_s1Ha8 [Occ=Once!] ->
                                                                                                    let {
                                                                                                      sat_s1Hae [Occ=Once]
                                                                                                        :: a_a1AhX
                                                                                                      [LclId] =
                                                                                                          [$dBits_s1H8l
                                                                                                           $dNum_s1H8x
                                                                                                           yW_s1Ha8] \u []
                                                                                                              let {
                                                                                                                sat_s1Had [Occ=Once]
                                                                                                                  :: a_a1AhX
                                                                                                                [LclId] =
                                                                                                                    [$dBits_s1H8l
                                                                                                                     yW_s1Ha8] \u []
                                                                                                                        let {
                                                                                                                          sat_s1Hac [Occ=Once]
                                                                                                                            :: GHC.Types.Int
                                                                                                                          [LclId] =
                                                                                                                              [yW_s1Ha8] \u []
                                                                                                                                  case
                                                                                                                                      yW_s1Ha8
                                                                                                                                  of
                                                                                                                                  { GHC.Types.I# x_s1Haa [Occ=Once] ->
                                                                                                                                        case
                                                                                                                                            -# [x_s1Haa
                                                                                                                                                1#]
                                                                                                                                        of
                                                                                                                                        sat_s1Hab
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              GHC.Types.I# [sat_s1Hab];
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                        } in 
                                                                                                                          Data.Bits.bit
                                                                                                                              $dBits_s1H8l
                                                                                                                              sat_s1Hac;
                                                                                                              } in 
                                                                                                                GHC.Num.negate
                                                                                                                    $dNum_s1H8x
                                                                                                                    sat_s1Had;
                                                                                                    } in 
                                                                                                      case
                                                                                                          GHC.Classes.<=
                                                                                                              $dOrd_s1H8y
                                                                                                              sat_s1Hae
                                                                                                              eta_s1H8n
                                                                                                      of
                                                                                                      { GHC.Types.False ->
                                                                                                            GHC.Base.Nothing [];
                                                                                                        GHC.Types.True ->
                                                                                                            $j_s1H8z;
                                                                                                      };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                        } in 
                                                                          case xSigned_s1H8v of {
                                                                            GHC.Types.False ->
                                                                                fail3_s1Ha3
                                                                                    GHC.Prim.void#;
                                                                            GHC.Types.True ->
                                                                                case
                                                                                    ySigned_s1H8t
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      let {
                                                                                        sat_s1Hai [Occ=Once]
                                                                                          :: a_a1AhX
                                                                                        [LclId] =
                                                                                            [$dNum_s1H8x] \u []
                                                                                                GHC.Num.fromInteger
                                                                                                    $dNum_s1H8x
                                                                                                    Data.Bits.$fBitsInteger_$czeroBits;
                                                                                      } in 
                                                                                        case
                                                                                            GHC.Classes.<=
                                                                                                $dOrd_s1H8y
                                                                                                sat_s1Hai
                                                                                                eta_s1H8n
                                                                                        of
                                                                                        { GHC.Types.False ->
                                                                                              GHC.Base.Nothing [];
                                                                                          GHC.Types.True ->
                                                                                              $j_s1H8z;
                                                                                        };
                                                                                  GHC.Types.True ->
                                                                                      fail3_s1Ha3
                                                                                          GHC.Prim.void#;
                                                                                };
                                                                          };
                                                              } in 
                                                                let-no-escape {
                                                                  fail3_s1Hak [Dmd=<L,1*C1(U)>]
                                                                    :: GHC.Prim.Void#
                                                                       -> GHC.Base.Maybe b_a1AhY
                                                                  [LclId[JoinId(1)],
                                                                   Arity=1,
                                                                   Str=<L,A>,
                                                                   Unf=OtherCon []] =
                                                                      sat-only [xWidth_s1H8o
                                                                                ySigned_s1H8t
                                                                                yWidth_s1H8u
                                                                                xSigned_s1H8v
                                                                                $j_s1H8z
                                                                                $j1_s1Ha2] \r [void_0E]
                                                                          case xSigned_s1H8v of {
                                                                            GHC.Types.False ->
                                                                                case
                                                                                    ySigned_s1H8t
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      $j1_s1Ha2;
                                                                                  GHC.Types.True ->
                                                                                      case
                                                                                          xWidth_s1H8o
                                                                                      of
                                                                                      { GHC.Base.Nothing ->
                                                                                            $j1_s1Ha2;
                                                                                        GHC.Base.Just xW_s1Hap [Occ=Once!] ->
                                                                                            case
                                                                                                yWidth_s1H8u
                                                                                            of
                                                                                            { GHC.Base.Nothing ->
                                                                                                  $j1_s1Ha2;
                                                                                              GHC.Base.Just yW_s1Har [Occ=Once!] ->
                                                                                                  case
                                                                                                      xW_s1Hap
                                                                                                  of
                                                                                                  { GHC.Types.I# x_s1Hat [Occ=Once] ->
                                                                                                        case
                                                                                                            yW_s1Har
                                                                                                        of
                                                                                                        { GHC.Types.I# y1_s1Hav [Occ=Once] ->
                                                                                                              case
                                                                                                                  <# [x_s1Hat
                                                                                                                      y1_s1Hav]
                                                                                                              of
                                                                                                              { __DEFAULT ->
                                                                                                                    $j1_s1Ha2;
                                                                                                                1# ->
                                                                                                                    $j_s1H8z;
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                            GHC.Types.True ->
                                                                                $j1_s1Ha2;
                                                                          };
                                                                } in 
                                                                  let-no-escape {
                                                                    $j2_s1Hax [Occ=Once*T[0],
                                                                               Dmd=<L,1*U>]
                                                                      :: GHC.Base.Maybe b_a1AhY
                                                                    [LclId[JoinId(0)],
                                                                     Unf=OtherCon []] =
                                                                        [xWidth_s1H8o
                                                                         yWidth_s1H8u
                                                                         $j_s1H8z
                                                                         $j1_s1Ha2
                                                                         fail3_s1Hak] \r []
                                                                            case xWidth_s1H8o of {
                                                                              GHC.Base.Nothing ->
                                                                                  fail3_s1Hak
                                                                                      GHC.Prim.void#;
                                                                              GHC.Base.Just xW_s1Haz [Occ=Once!] ->
                                                                                  case
                                                                                      yWidth_s1H8u
                                                                                  of
                                                                                  { GHC.Base.Nothing ->
                                                                                        fail3_s1Hak
                                                                                            GHC.Prim.void#;
                                                                                    GHC.Base.Just yW_s1HaB [Occ=Once!] ->
                                                                                        case
                                                                                            xW_s1Haz
                                                                                        of
                                                                                        { GHC.Types.I# x_s1HaD [Occ=Once] ->
                                                                                              case
                                                                                                  yW_s1HaB
                                                                                              of
                                                                                              { GHC.Types.I# y1_s1HaF [Occ=Once] ->
                                                                                                    case
                                                                                                        <=# [x_s1HaD
                                                                                                             y1_s1HaF]
                                                                                                    of
                                                                                                    { __DEFAULT ->
                                                                                                          $j1_s1Ha2;
                                                                                                      1# ->
                                                                                                          $j_s1H8z;
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                  } in 
                                                                    case xSigned_s1H8v of {
                                                                      GHC.Types.False ->
                                                                          case ySigned_s1H8t of {
                                                                            GHC.Types.False ->
                                                                                $j2_s1Hax;
                                                                            GHC.Types.True ->
                                                                                fail3_s1Hak
                                                                                    GHC.Prim.void#;
                                                                          };
                                                                      GHC.Types.True ->
                                                                          case ySigned_s1H8t of {
                                                                            GHC.Types.False ->
                                                                                fail3_s1Hak
                                                                                    GHC.Prim.void#;
                                                                            GHC.Types.True ->
                                                                                $j2_s1Hax;
                                                                          };
                                                                    };
                                                    } in 
                                                      case xSigned_s1H8v of {
                                                        GHC.Types.False ->
                                                            case ySigned_s1H8t of {
                                                              GHC.Types.False ->
                                                                  case yWidth_s1H8u of {
                                                                    GHC.Base.Nothing -> $j_s1H8z;
                                                                    GHC.Base.Just _ [Occ=Dead] ->
                                                                        fail2_s1Ha0 GHC.Prim.void#;
                                                                  };
                                                              GHC.Types.True ->
                                                                  fail2_s1Ha0 GHC.Prim.void#;
                                                            };
                                                        GHC.Types.True ->
                                                            fail2_s1Ha0 GHC.Prim.void#;
                                                      };
                                          } in 
                                            case ySigned_s1H8t of {
                                              GHC.Types.False -> fail1_s1H9Y GHC.Prim.void#;
                                              GHC.Types.True ->
                                                  case yWidth_s1H8u of {
                                                    GHC.Base.Nothing -> $j_s1H8z;
                                                    GHC.Base.Just _ [Occ=Dead] ->
                                                        fail1_s1H9Y GHC.Prim.void#;
                                                  };
                                            };
                                } in 
                                  let-no-escape {
                                    $j1_s1HaR [Occ=Once*T[0], Dmd=<L,1*U>] :: GHC.Base.Maybe b_a1AhY
                                    [LclId[JoinId(0)], Unf=OtherCon []] =
                                        [ySigned_s1H8t xSigned_s1H8v $j_s1H8z fail_s1H9W] \r []
                                            case xSigned_s1H8v of {
                                              GHC.Types.False ->
                                                  case ySigned_s1H8t of {
                                                    GHC.Types.False -> $j_s1H8z;
                                                    GHC.Types.True -> fail_s1H9W GHC.Prim.void#;
                                                  };
                                              GHC.Types.True ->
                                                  case ySigned_s1H8t of {
                                                    GHC.Types.False -> fail_s1H9W GHC.Prim.void#;
                                                    GHC.Types.True -> $j_s1H8z;
                                                  };
                                            };
                                  } in 
                                    case xWidth_s1H8o of {
                                      GHC.Base.Nothing ->
                                          case yWidth_s1H8u of {
                                            GHC.Base.Nothing -> $j1_s1HaR;
                                            GHC.Base.Just _ [Occ=Dead] -> fail_s1H9W GHC.Prim.void#;
                                          };
                                      GHC.Base.Just a1_s1HaY [Occ=Once!] ->
                                          case yWidth_s1H8u of {
                                            GHC.Base.Nothing -> fail_s1H9W GHC.Prim.void#;
                                            GHC.Base.Just b1_s1Hb0 [Occ=Once!] ->
                                                case a1_s1HaY of {
                                                  GHC.Types.I# x_s1Hb2 [Occ=Once] ->
                                                      case b1_s1Hb0 of {
                                                        GHC.Types.I# y1_s1Hb4 [Occ=Once] ->
                                                            case ==# [x_s1Hb2 y1_s1Hb4] of {
                                                              __DEFAULT ->
                                                                  fail_s1H9W GHC.Prim.void#;
                                                              1# -> $j1_s1HaR;
                                                            };
                                                      };
                                                };
                                          };
                                    };
                      };
                };
        };

Data.Bits.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Bits.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$trModule4];

Data.Bits.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bits"#;

Data.Bits.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$trModule2];

Data.Bits.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bits.$trModule3
                                     Data.Bits.$trModule1];

$krep_r1CDE :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcBool
                                              GHC.Types.[]];

$krep1_r1CDF :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcInt
                                              GHC.Types.[]];

$krep2_r1CDG :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

$krep3_r1CDH :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r1CDF GHC.Types.[]];

$krep4_r1CDI :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep3_r1CDH];

$krep5_r1CDJ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r1CDF $krep_r1CDE];

Data.Bits.$tcBits1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*
                                         $krep2_r1CDG];

$krep6_r1CDK :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep7_r1CDL :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep6_r1CDK];

$krep8_r1CDM :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep7_r1CDL];

$krep9_r1CDN :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep5_r1CDJ];

$krep10_r1CDO :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep4_r1CDI];

$krep11_r1CDP :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep1_r1CDF];

$krep12_r1CDQ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep_r1CDE];

$krep13_r1CDR :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r1CDF $krep6_r1CDK];

$krep14_r1CDS :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep13_r1CDR];

$krep15_r1CDT :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_r1CDK GHC.Types.[]];

$krep16_r1CDU :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Classes.$tcEq
                                              $krep15_r1CDT];

Data.Bits.$tcBits3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bits"#;

Data.Bits.$tcBits2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tcBits3];

Data.Bits.$tcBits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7088815172979416363##
                                    4990916430057605838##
                                    Data.Bits.$trModule
                                    Data.Bits.$tcBits2
                                    0#
                                    Data.Bits.$tcBits1];

$krep17_r1CDV :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Bits.$tcBits
                                              $krep15_r1CDT];

$krep18_r1CDW :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep17_r1CDV];

$krep19_r1CDX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep18_r1CDW];

$krep20_r1CDY :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep19_r1CDX];

$krep21_r1CDZ :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep20_r1CDY];

$krep22_r1CE0 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep21_r1CDZ];

$krep23_r1CE1 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep22_r1CE0];

$krep24_r1CE2 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep23_r1CE1];

$krep25_r1CE3 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep12_r1CDQ $krep24_r1CE2];

$krep26_r1CE4 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep25_r1CE3];

$krep27_r1CE5 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep10_r1CDO $krep26_r1CE4];

$krep28_r1CE6 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep9_r1CDN $krep27_r1CE5];

$krep29_r1CE7 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep28_r1CE6];

$krep30_r1CE8 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep29_r1CE7];

$krep31_r1CE9 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep30_r1CE8];

$krep32_r1CEa :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep13_r1CDR $krep31_r1CE9];

$krep33_r1CEb :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r1CDK $krep32_r1CEa];

$krep34_r1CEc :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep33_r1CEb];

$krep35_r1CEd :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep14_r1CDS $krep34_r1CEc];

$krep36_r1CEe :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep7_r1CDL $krep35_r1CEd];

$krep37_r1CEf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r1CDM $krep36_r1CEe];

$krep38_r1CEg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r1CDM $krep37_r1CEf];

$krep39_r1CEh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r1CDM $krep38_r1CEg];

Data.Bits.$tc'C:Bits1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep16_r1CDU $krep39_r1CEh];

Data.Bits.$tc'C:Bits3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Bits"#;

Data.Bits.$tc'C:Bits2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tc'C:Bits3];

Data.Bits.$tc'C:Bits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [744071653035646959##
                                    2574978498160477882##
                                    Data.Bits.$trModule
                                    Data.Bits.$tc'C:Bits2
                                    1#
                                    Data.Bits.$tc'C:Bits1];

Data.Bits.$tcFiniteBits2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "FiniteBits"#;

Data.Bits.$tcFiniteBits1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tcFiniteBits2];

Data.Bits.$tcFiniteBits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2363162769622202131##
                                    10110405838341883172##
                                    Data.Bits.$trModule
                                    Data.Bits.$tcFiniteBits1
                                    0#
                                    Data.Bits.$tcBits1];

$krep40_r1CEi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Bits.$tcFiniteBits
                                              $krep15_r1CDT];

$krep41_r1CEj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep40_r1CEi];

$krep42_r1CEk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep41_r1CEj];

$krep43_r1CEl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r1CDP $krep42_r1CEk];

Data.Bits.$tc'C:FiniteBits1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep17_r1CDV $krep43_r1CEl];

Data.Bits.$tc'C:FiniteBits3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:FiniteBits"#;

Data.Bits.$tc'C:FiniteBits2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bits.$tc'C:FiniteBits3];

Data.Bits.$tc'C:FiniteBits :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7500562306525175158##
                                    16051895206261500648##
                                    Data.Bits.$trModule
                                    Data.Bits.$tc'C:FiniteBits2
                                    1#
                                    Data.Bits.$tc'C:FiniteBits1];

Data.Bits.C:FiniteBits
  :: forall b.
     Data.Bits.Bits b =>
     (b -> GHC.Types.Int)
     -> (b -> GHC.Types.Int)
     -> (b -> GHC.Types.Int)
     -> Data.Bits.FiniteBits b
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bits.C:FiniteBits [eta_B4 eta_B3 eta_B2 eta_B1];

Data.Bits.C:Bits
  :: forall a.
     GHC.Classes.Eq a =>
     (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a -> a)
     -> (a -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> a
     -> (GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> GHC.Types.Bool)
     -> (a -> GHC.Base.Maybe GHC.Types.Int)
     -> (a -> GHC.Types.Int)
     -> (a -> GHC.Types.Bool)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int -> a)
     -> (a -> GHC.Types.Int)
     -> Data.Bits.Bits a
[GblId[DataCon],
 Arity=23,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_Bn
           eta_Bm
           eta_Bl
           eta_Bk
           eta_Bj
           eta_Bi
           eta_Bh
           eta_Bg
           eta_Bf
           eta_Be
           eta_Bd
           eta_Bc
           eta_Bb
           eta_Ba
           eta_B9
           eta_B8
           eta_B7
           eta_B6
           eta_B5
           eta_B4
           eta_B3
           eta_B2
           eta_B1]
        Data.Bits.C:Bits [eta_Bn
                          eta_Bm
                          eta_Bl
                          eta_Bk
                          eta_Bj
                          eta_Bi
                          eta_Bh
                          eta_Bg
                          eta_Bf
                          eta_Be
                          eta_Bd
                          eta_Bc
                          eta_Bb
                          eta_Ba
                          eta_B9
                          eta_B8
                          eta_B7
                          eta_B6
                          eta_B5
                          eta_B4
                          eta_B3
                          eta_B2
                          eta_B1];

