
==================== Output Cmm ====================
2018-03-16 16:09:03.391692092 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:03.393235573 UTC

[section ""data" . Data.Bitraversable.$p1Bitraversable_closure" {
     Data.Bitraversable.$p1Bitraversable_closure:
         const Data.Bitraversable.$p1Bitraversable_info;
 },
 Data.Bitraversable.$p1Bitraversable_entry() //  [R2]
         { info_tbl: [(cdOCP,
                       label: Data.Bitraversable.$p1Bitraversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOCP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdOCQ; else goto cdOCR;
       cdOCQ: // global
           R2 = R2;
           R1 = Data.Bitraversable.$p1Bitraversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdOCR: // global
           I64[Sp - 8] = block_cdOCM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udOCV; else goto cdOCN;
       udOCV: // global
           call _cdOCM(R1) args: 0, res: 0, upd: 0;
       cdOCN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdOCM() //  [R1]
         { info_tbl: [(cdOCM,
                       label: block_cdOCM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOCM: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.396293046 UTC

[section ""data" . Data.Bitraversable.$p2Bitraversable_closure" {
     Data.Bitraversable.$p2Bitraversable_closure:
         const Data.Bitraversable.$p2Bitraversable_info;
 },
 Data.Bitraversable.$p2Bitraversable_entry() //  [R2]
         { info_tbl: [(cdOD3,
                       label: Data.Bitraversable.$p2Bitraversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOD3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdOD4; else goto cdOD5;
       cdOD4: // global
           R2 = R2;
           R1 = Data.Bitraversable.$p2Bitraversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdOD5: // global
           I64[Sp - 8] = block_cdOD0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udOD9; else goto cdOD1;
       udOD9: // global
           call _cdOD0(R1) args: 0, res: 0, upd: 0;
       cdOD1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdOD0() //  [R1]
         { info_tbl: [(cdOD0,
                       label: block_cdOD0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOD0: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.397596262 UTC

[section ""data" . Data.Bitraversable.bitraverse_closure" {
     Data.Bitraversable.bitraverse_closure:
         const Data.Bitraversable.bitraverse_info;
 },
 Data.Bitraversable.bitraverse_entry() //  [R2]
         { info_tbl: [(cdODh,
                       label: Data.Bitraversable.bitraverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdODh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdODi; else goto cdODj;
       cdODi: // global
           R2 = R2;
           R1 = Data.Bitraversable.bitraverse_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdODj: // global
           I64[Sp - 8] = block_cdODe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udODn; else goto cdODf;
       udODn: // global
           call _cdODe(R1) args: 0, res: 0, upd: 0;
       cdODf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdODe() //  [R1]
         { info_tbl: [(cdODe,
                       label: block_cdODe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdODe: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.3991464 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,)_$cbitraverse_info;
 },
 sat_sdOy2_entry() //  [R1]
         { info_tbl: [(cdODx,
                       label: sat_sdOy2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdODx: // global
           _sdOy2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdODy; else goto cdODz;
       cdODz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdODB; else goto cdODA;
       cdODB: // global
           HpAlloc = 24;
           goto cdODy;
       cdODy: // global
           R1 = _sdOy2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdODA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOy2::P64;
           _sdOxR::P64 = P64[_sdOy2::P64 + 16];
           _sdOxS::P64 = P64[_sdOy2::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdOxS::P64;
           R2 = Hp - 16;
           R1 = _sdOxR::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOxX_entry() //  [R1]
         { info_tbl: [(cdODH,
                       label: sat_sdOxX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdODH: // global
           _sdOxX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdODI; else goto cdODJ;
       cdODJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdODL; else goto cdODK;
       cdODL: // global
           HpAlloc = 24;
           goto cdODI;
       cdODI: // global
           R1 = _sdOxX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdODK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOxX::P64;
           _sdOxQ::P64 = P64[_sdOxX::P64 + 16];
           _sdOxS::P64 = P64[_sdOxX::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdOxS::P64;
           R2 = Hp - 16;
           R1 = _sdOxQ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bitraversable.$fBitraversable(,)_$cbitraverse_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cdODM,
                       label: Data.Bitraversable.$fBitraversable(,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdODM: // global
           _sdOxS::P64 = R5;
           _sdOxR::P64 = R4;
           _sdOxQ::P64 = R3;
           _sdOxP::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdODN; else goto cdODO;
       cdODO: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdODQ; else goto cdODP;
       cdODQ: // global
           HpAlloc = 64;
           goto cdODN;
       cdODN: // global
           R5 = _sdOxS::P64;
           R4 = _sdOxR::P64;
           R3 = _sdOxQ::P64;
           R2 = _sdOxP::P64;
           R1 = Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdODP: // global
           I64[Hp - 56] = sat_sdOy2_info;
           P64[Hp - 40] = _sdOxR::P64;
           P64[Hp - 32] = _sdOxS::P64;
           I64[Hp - 24] = sat_sdOxX_info;
           P64[Hp - 8] = _sdOxQ::P64;
           P64[Hp] = _sdOxS::P64;
           R2 = _sdOxP::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.400904024 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,)_closure" {
     Data.Bitraversable.$fBitraversable(,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,)_closure;
         const Data.Bifoldable.$fBifoldable(,)_closure;
         const Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.402282344 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_info;
 },
 sat_sdOyo_entry() //  [R1]
         { info_tbl: [(cdOE0,
                       label: sat_sdOyo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOE0: // global
           _sdOyo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOE1; else goto cdOE2;
       cdOE2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOE4; else goto cdOE3;
       cdOE4: // global
           HpAlloc = 24;
           goto cdOE1;
       cdOE1: // global
           R1 = _sdOyo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOE3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOyo::P64;
           _sdOy5::P64 = P64[_sdOyo::P64 + 16];
           _sdOy6::P64 = P64[_sdOyo::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdOy6::P64;
           R2 = Hp - 16;
           R1 = _sdOy5::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOyi_entry() //  [R1]
         { info_tbl: [(cdOEa,
                       label: sat_sdOyi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOEa: // global
           _sdOyi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOEb; else goto cdOEc;
       cdOEc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOEe; else goto cdOEd;
       cdOEe: // global
           HpAlloc = 24;
           goto cdOEb;
       cdOEb: // global
           R1 = _sdOyi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOEd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOyi::P64;
           _sdOy4::P64 = P64[_sdOyi::P64 + 16];
           _sdOy6::P64 = P64[_sdOyi::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdOy6::P64;
           R2 = Hp - 16;
           R1 = _sdOy4::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOyc_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOEm,
                       label: sat_sdOyc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOEm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdOEq; else goto cdOEp;
       cdOEq: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOEp: // global
           _sdOyb::P64 = P64[R1 + 6];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = _sdOyb::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdOEr,
                       label: Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOEr: // global
           _sdOy6::P64 = R5;
           _sdOy5::P64 = R4;
           _sdOy4::P64 = R3;
           _sdOy3::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOEs; else goto cdOEt;
       cdOEt: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdOEv; else goto cdOEu;
       cdOEv: // global
           HpAlloc = 104;
           goto cdOEs;
       cdOEs: // global
           R5 = _sdOy6::P64;
           R4 = _sdOy5::P64;
           R3 = _sdOy4::P64;
           R2 = _sdOy3::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOEu: // global
           I64[Hp - 96] = sat_sdOyo_info;
           P64[Hp - 80] = _sdOy5::P64;
           P64[Hp - 72] = _sdOy6::P64;
           I64[Hp - 64] = sat_sdOyi_info;
           P64[Hp - 48] = _sdOy4::P64;
           P64[Hp - 40] = _sdOy6::P64;
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdOy6::P64;
           I64[Hp - 8] = sat_sdOyc_info;
           P64[Hp] = Hp - 32;
           R2 = _sdOy3::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 96;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.404384167 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.405927216 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_info;
 },
 sat_sdOyT_entry() //  [R1]
         { info_tbl: [(cdOEF,
                       label: sat_sdOyT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOEF: // global
           _sdOyT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOEG; else goto cdOEH;
       cdOEH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOEJ; else goto cdOEI;
       cdOEJ: // global
           HpAlloc = 24;
           goto cdOEG;
       cdOEG: // global
           R1 = _sdOyT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOEI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOyT::P64;
           _sdOyr::P64 = P64[_sdOyT::P64 + 16];
           _sdOys::P64 = P64[_sdOyT::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdOys::P64;
           R2 = Hp - 16;
           R1 = _sdOyr::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOyM_entry() //  [R1]
         { info_tbl: [(cdOEP,
                       label: sat_sdOyM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOEP: // global
           _sdOyM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOEQ; else goto cdOER;
       cdOER: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOET; else goto cdOES;
       cdOET: // global
           HpAlloc = 24;
           goto cdOEQ;
       cdOEQ: // global
           R1 = _sdOyM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOES: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOyM::P64;
           _sdOyq::P64 = P64[_sdOyM::P64 + 16];
           _sdOys::P64 = P64[_sdOyM::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdOys::P64;
           R2 = Hp - 16;
           R1 = _sdOyq::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOyF_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOF2,
                       label: sat_sdOyF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOF2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdOF6; else goto cdOF5;
       cdOF6: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOF5: // global
           _sdOyy::P64 = P64[R1 + 6];
           _sdOyE::P64 = P64[R1 + 14];
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = _sdOyy::P64;
           P64[Hp - 16] = _sdOyE::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdOF7,
                       label: Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOF7: // global
           _sdOys::P64 = R5;
           _sdOyr::P64 = R4;
           _sdOyq::P64 = R3;
           _sdOyp::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOF8; else goto cdOF9;
       cdOF9: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cdOFb; else goto cdOFa;
       cdOFb: // global
           HpAlloc = 136;
           goto cdOF8;
       cdOF8: // global
           R5 = _sdOys::P64;
           R4 = _sdOyr::P64;
           R3 = _sdOyq::P64;
           R2 = _sdOyp::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOFa: // global
           I64[Hp - 128] = sat_sdOyT_info;
           P64[Hp - 112] = _sdOyr::P64;
           P64[Hp - 104] = _sdOys::P64;
           I64[Hp - 96] = sat_sdOyM_info;
           P64[Hp - 80] = _sdOyq::P64;
           P64[Hp - 72] = _sdOys::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdOys::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdOys::P64;
           I64[Hp - 16] = sat_sdOyF_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = _sdOyp::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 14;
           P64[Sp - 16] = Hp - 96;
           P64[Sp - 8] = Hp - 128;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.408128661 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.409638884 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_info;
 },
 sat_sdOzz_entry() //  [R1]
         { info_tbl: [(cdOFl,
                       label: sat_sdOzz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOFl: // global
           _sdOzz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOFm; else goto cdOFn;
       cdOFn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOFp; else goto cdOFo;
       cdOFp: // global
           HpAlloc = 24;
           goto cdOFm;
       cdOFm: // global
           R1 = _sdOzz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOFo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOzz::P64;
           _sdOyW::P64 = P64[_sdOzz::P64 + 16];
           _sdOyX::P64 = P64[_sdOzz::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdOyX::P64;
           R2 = Hp - 16;
           R1 = _sdOyW::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOzr_entry() //  [R1]
         { info_tbl: [(cdOFv,
                       label: sat_sdOzr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOFv: // global
           _sdOzr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOFw; else goto cdOFx;
       cdOFx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOFz; else goto cdOFy;
       cdOFz: // global
           HpAlloc = 24;
           goto cdOFw;
       cdOFw: // global
           R1 = _sdOzr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOFy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOzr::P64;
           _sdOyV::P64 = P64[_sdOzr::P64 + 16];
           _sdOyX::P64 = P64[_sdOzr::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdOyX::P64;
           R2 = Hp - 16;
           R1 = _sdOyV::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOzj_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOFJ,
                       label: sat_sdOzj_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOFJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdOFN; else goto cdOFM;
       cdOFN: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOFM: // global
           _sdOz4::P64 = P64[R1 + 6];
           _sdOzb::P64 = P64[R1 + 14];
           _sdOzi::P64 = P64[R1 + 22];
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = _sdOz4::P64;
           P64[Hp - 24] = _sdOzb::P64;
           P64[Hp - 16] = _sdOzi::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cdOFO,
                       label: Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOFO: // global
           _sdOyX::P64 = R5;
           _sdOyW::P64 = R4;
           _sdOyV::P64 = R3;
           _sdOyU::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOFP; else goto cdOFQ;
       cdOFQ: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cdOFS; else goto cdOFR;
       cdOFS: // global
           HpAlloc = 168;
           goto cdOFP;
       cdOFP: // global
           R5 = _sdOyX::P64;
           R4 = _sdOyW::P64;
           R3 = _sdOyV::P64;
           R2 = _sdOyU::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOFR: // global
           I64[Hp - 160] = sat_sdOzz_info;
           P64[Hp - 144] = _sdOyW::P64;
           P64[Hp - 136] = _sdOyX::P64;
           I64[Hp - 128] = sat_sdOzr_info;
           P64[Hp - 112] = _sdOyV::P64;
           P64[Hp - 104] = _sdOyX::P64;
           I64[Hp - 96] = stg_sel_2_upd_info;
           P64[Hp - 80] = _sdOyX::P64;
           I64[Hp - 72] = stg_sel_1_upd_info;
           P64[Hp - 56] = _sdOyX::P64;
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = _sdOyX::P64;
           I64[Hp - 24] = sat_sdOzj_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R2 = _sdOyU::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = Hp - 128;
           P64[Sp - 8] = Hp - 160;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.411830526 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.413274697 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_info;
 },
 sat_sdOAs_entry() //  [R1]
         { info_tbl: [(cdOG2,
                       label: sat_sdOAs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOG2: // global
           _sdOAs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOG3; else goto cdOG4;
       cdOG4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOG6; else goto cdOG5;
       cdOG6: // global
           HpAlloc = 24;
           goto cdOG3;
       cdOG3: // global
           R1 = _sdOAs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOG5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOAs::P64;
           _sdOzC::P64 = P64[_sdOAs::P64 + 16];
           _sdOzD::P64 = P64[_sdOAs::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdOzD::P64;
           R2 = Hp - 16;
           R1 = _sdOzC::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOAj_entry() //  [R1]
         { info_tbl: [(cdOGc,
                       label: sat_sdOAj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOGc: // global
           _sdOAj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOGd; else goto cdOGe;
       cdOGe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOGg; else goto cdOGf;
       cdOGg: // global
           HpAlloc = 24;
           goto cdOGd;
       cdOGd: // global
           R1 = _sdOAj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOGf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOAj::P64;
           _sdOzB::P64 = P64[_sdOAj::P64 + 16];
           _sdOzD::P64 = P64[_sdOAj::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdOzD::P64;
           R2 = Hp - 16;
           R1 = _sdOzB::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOAa_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOGr,
                       label: sat_sdOAa_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOGr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdOGv; else goto cdOGu;
       cdOGv: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOGu: // global
           _sdOzL::P64 = P64[R1 + 6];
           _sdOzT::P64 = P64[R1 + 14];
           _sdOA1::P64 = P64[R1 + 22];
           _sdOA9::P64 = P64[R1 + 30];
           I64[Hp - 48] = (,,,,,)_con_info;
           P64[Hp - 40] = _sdOzL::P64;
           P64[Hp - 32] = _sdOzT::P64;
           P64[Hp - 24] = _sdOA1::P64;
           P64[Hp - 16] = _sdOA9::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cdOGw,
                       label: Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOGw: // global
           _sdOzD::P64 = R5;
           _sdOzC::P64 = R4;
           _sdOzB::P64 = R3;
           _sdOzA::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOGx; else goto cdOGy;
       cdOGy: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cdOGA; else goto cdOGz;
       cdOGA: // global
           HpAlloc = 200;
           goto cdOGx;
       cdOGx: // global
           R5 = _sdOzD::P64;
           R4 = _sdOzC::P64;
           R3 = _sdOzB::P64;
           R2 = _sdOzA::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOGz: // global
           I64[Hp - 192] = sat_sdOAs_info;
           P64[Hp - 176] = _sdOzC::P64;
           P64[Hp - 168] = _sdOzD::P64;
           I64[Hp - 160] = sat_sdOAj_info;
           P64[Hp - 144] = _sdOzB::P64;
           P64[Hp - 136] = _sdOzD::P64;
           I64[Hp - 128] = stg_sel_3_upd_info;
           P64[Hp - 112] = _sdOzD::P64;
           I64[Hp - 104] = stg_sel_2_upd_info;
           P64[Hp - 88] = _sdOzD::P64;
           I64[Hp - 80] = stg_sel_1_upd_info;
           P64[Hp - 64] = _sdOzD::P64;
           I64[Hp - 56] = stg_sel_0_upd_info;
           P64[Hp - 40] = _sdOzD::P64;
           I64[Hp - 32] = sat_sdOAa_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R2 = _sdOzA::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 30;
           P64[Sp - 16] = Hp - 160;
           P64[Sp - 8] = Hp - 192;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.415638533 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.417105385 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_info;
 },
 sat_sdOBA_entry() //  [R1]
         { info_tbl: [(cdOGK,
                       label: sat_sdOBA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOGK: // global
           _sdOBA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOGL; else goto cdOGM;
       cdOGM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOGO; else goto cdOGN;
       cdOGO: // global
           HpAlloc = 24;
           goto cdOGL;
       cdOGL: // global
           R1 = _sdOBA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOGN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOBA::P64;
           _sdOAv::P64 = P64[_sdOBA::P64 + 16];
           _sdOAw::P64 = P64[_sdOBA::P64 + 24];
           I64[Hp - 16] = stg_sel_6_upd_info;
           P64[Hp] = _sdOAw::P64;
           R2 = Hp - 16;
           R1 = _sdOAv::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOBq_entry() //  [R1]
         { info_tbl: [(cdOGU,
                       label: sat_sdOBq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOGU: // global
           _sdOBq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOGV; else goto cdOGW;
       cdOGW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOGY; else goto cdOGX;
       cdOGY: // global
           HpAlloc = 24;
           goto cdOGV;
       cdOGV: // global
           R1 = _sdOBq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOGX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOBq::P64;
           _sdOAu::P64 = P64[_sdOBq::P64 + 16];
           _sdOAw::P64 = P64[_sdOBq::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdOAw::P64;
           R2 = Hp - 16;
           R1 = _sdOAu::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOBg_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOHa,
                       label: sat_sdOBg_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOHa: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdOHe; else goto cdOHd;
       cdOHe: // global
           HpAlloc = 64;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOHd: // global
           _sdOAF::P64 = P64[R1 + 6];
           _sdOAO::P64 = P64[R1 + 14];
           _sdOAX::P64 = P64[R1 + 22];
           _sdOB6::P64 = P64[R1 + 30];
           _sdOBf::P64 = P64[R1 + 38];
           I64[Hp - 56] = (,,,,,,)_con_info;
           P64[Hp - 48] = _sdOAF::P64;
           P64[Hp - 40] = _sdOAO::P64;
           P64[Hp - 32] = _sdOAX::P64;
           P64[Hp - 24] = _sdOB6::P64;
           P64[Hp - 16] = _sdOBf::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_entry() //  [R2,
                                                                      R3, R4, R5]
         { info_tbl: [(cdOHf,
                       label: Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOHf: // global
           _sdOAw::P64 = R5;
           _sdOAv::P64 = R4;
           _sdOAu::P64 = R3;
           _sdOAt::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOHg; else goto cdOHh;
       cdOHh: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cdOHj; else goto cdOHi;
       cdOHj: // global
           HpAlloc = 232;
           goto cdOHg;
       cdOHg: // global
           R5 = _sdOAw::P64;
           R4 = _sdOAv::P64;
           R3 = _sdOAu::P64;
           R2 = _sdOAt::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOHi: // global
           I64[Hp - 224] = sat_sdOBA_info;
           P64[Hp - 208] = _sdOAv::P64;
           P64[Hp - 200] = _sdOAw::P64;
           I64[Hp - 192] = sat_sdOBq_info;
           P64[Hp - 176] = _sdOAu::P64;
           P64[Hp - 168] = _sdOAw::P64;
           I64[Hp - 160] = stg_sel_4_upd_info;
           P64[Hp - 144] = _sdOAw::P64;
           I64[Hp - 136] = stg_sel_3_upd_info;
           P64[Hp - 120] = _sdOAw::P64;
           I64[Hp - 112] = stg_sel_2_upd_info;
           P64[Hp - 96] = _sdOAw::P64;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdOAw::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdOAw::P64;
           I64[Hp - 40] = sat_sdOBg_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R2 = _sdOAt::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 38;
           P64[Sp - 16] = Hp - 192;
           P64[Sp - 8] = Hp - 224;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.419571955 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.420994122 UTC

[section ""data" . Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversableEither_$cbitraverse_info;
 },
 Data.Bitraversable.$fBitraversableEither_$cbitraverse_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cdOHv,
                       label: Data.Bitraversable.$fBitraversableEither_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOHv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdOHw; else goto cdOHx;
       cdOHw: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOHx: // global
           I64[Sp - 32] = block_cdOHo_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udOHU; else goto cdOHp;
       udOHU: // global
           call _cdOHo(R1) args: 0, res: 0, upd: 0;
       cdOHp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdOHo() //  [R1]
         { info_tbl: [(cdOHo,
                       label: block_cdOHo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOHo: // global
           _sdOBB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdOHs; else goto cdOHt;
       cdOHs: // global
           Hp = Hp + 32;
           _sdOBF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdOHP; else goto cdOHD;
       cdOHD: // global
           _sdOBG::P64 = P64[_sdOBF::P64 + 7];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdOBG::P64;
           I64[Sp + 16] = block_cdOHB_info;
           R2 = _sdOBB::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
       cdOHt: // global
           Hp = Hp + 32;
           _sdOBF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdOHP; else goto cdOHO;
       cdOHP: // global
           HpAlloc = 32;
           R1 = _sdOBF::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdOHO: // global
           _sdOBJ::P64 = P64[_sdOBF::P64 + 6];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sdOBJ::P64;
           I64[Sp + 16] = block_cdOHM_info;
           R2 = _sdOBB::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdOHB() //  [R1]
         { info_tbl: [(cdOHB,
                       label: block_cdOHB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOHB: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Left_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cdOHM() //  [R1]
         { info_tbl: [(cdOHM,
                       label: block_cdOHM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOHM: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.423041023 UTC

[section ""data" . Data.Bitraversable.$fBitraversableEither_closure" {
     Data.Bitraversable.$fBitraversableEither_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctorEither_closure;
         const Data.Bifoldable.$fBifoldableEither_closure;
         const Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.42388057 UTC

[section ""data" . Data.Bitraversable.$fBitraversableConst1_closure" {
     Data.Bitraversable.$fBitraversableConst1_closure:
         const Data.Bitraversable.$fBitraversableConst1_info;
 },
 Data.Bitraversable.$fBitraversableConst1_entry() //  [R2]
         { info_tbl: [(cdOHZ,
                       label: Data.Bitraversable.$fBitraversableConst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOHZ: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.424940125 UTC

[section ""data" . Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversableConst_$cbitraverse_info;
 },
 Data.Bitraversable.$fBitraversableConst_$cbitraverse_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdOI9,
                       label: Data.Bitraversable.$fBitraversableConst_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOI9: // global
           _sdOBQ::P64 = R5;
           _sdOBP::P64 = R4;
           _sdOBO::P64 = R3;
           _sdOBN::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdOIa; else goto cdOIb;
       cdOIb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdOId; else goto cdOIc;
       cdOId: // global
           HpAlloc = 32;
           goto cdOIa;
       cdOIa: // global
           R5 = _sdOBQ::P64;
           R4 = _sdOBP::P64;
           R3 = _sdOBO::P64;
           R2 = _sdOBN::P64;
           R1 = Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOIc: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdOBO::P64;
           P64[Hp] = _sdOBQ::P64;
           I64[Sp - 16] = block_cdOI7_info;
           R2 = _sdOBN::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdOI7() //  [R1]
         { info_tbl: [(cdOI7,
                       label: block_cdOI7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOI7: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Bitraversable.$fBitraversableConst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.42623652 UTC

[section ""data" . Data.Bitraversable.$fBitraversableConst_closure" {
     Data.Bitraversable.$fBitraversableConst_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctorConst_closure;
         const Data.Bifoldable.$fBifoldableConst_closure;
         const Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.427139657 UTC

[section ""data" . Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversableK1_$cbitraverse_info;
 },
 Data.Bitraversable.$fBitraversableK1_$cbitraverse_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cdOIo,
                       label: Data.Bitraversable.$fBitraversableK1_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOIo: // global
           _sdOBW::P64 = R5;
           _sdOBV::P64 = R4;
           _sdOBU::P64 = R3;
           _sdOBT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdOIp; else goto cdOIq;
       cdOIq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdOIs; else goto cdOIr;
       cdOIs: // global
           HpAlloc = 32;
           goto cdOIp;
       cdOIp: // global
           R5 = _sdOBW::P64;
           R4 = _sdOBV::P64;
           R3 = _sdOBU::P64;
           R2 = _sdOBT::P64;
           R1 = Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOIr: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdOBU::P64;
           P64[Hp] = _sdOBW::P64;
           I64[Sp - 16] = block_cdOIm_info;
           R2 = _sdOBT::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdOIm() //  [R1]
         { info_tbl: [(cdOIm,
                       label: block_cdOIm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOIm: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Bitraversable.$fBitraversableConst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.42974213 UTC

[section ""data" . Data.Bitraversable.$fBitraversableK1_closure" {
     Data.Bitraversable.$fBitraversableK1_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctorK1_closure;
         const Data.Bifoldable.$fBifoldableK1_closure;
         const Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.430506588 UTC

[section ""data" . Data.Bitraversable.bimapM_closure" {
     Data.Bitraversable.bimapM_closure:
         const Data.Bitraversable.bimapM_info;
 },
 Data.Bitraversable.bimapM_entry() //  [R2, R3]
         { info_tbl: [(cdOIA,
                       label: Data.Bitraversable.bimapM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOIA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdOIB; else goto cdOIC;
       cdOIB: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.bimapM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOIC: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call Data.Bitraversable.bitraverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.431503777 UTC

[section ""data" . Data.Bitraversable.bisequence_closure" {
     Data.Bitraversable.bisequence_closure:
         const Data.Bitraversable.bisequence_info;
 },
 Data.Bitraversable.bisequence_entry() //  [R2, R3]
         { info_tbl: [(cdOIH,
                       label: Data.Bitraversable.bisequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOIH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdOII; else goto cdOIJ;
       cdOII: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.bisequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOIJ: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 32;
           call Data.Bitraversable.bitraverse_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.432491182 UTC

[section ""data" . Data.Bitraversable.bisequenceA_closure" {
     Data.Bitraversable.bisequenceA_closure:
         const Data.Bitraversable.bisequenceA_info;
 },
 Data.Bitraversable.bisequenceA_entry() //  [R2, R3]
         { info_tbl: [(cdOIO,
                       label: Data.Bitraversable.bisequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOIO: // global
           R3 = R3;
           R2 = R2;
           call Data.Bitraversable.bisequence_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.433963449 UTC

[section ""data" . Data.Bitraversable.$dmbitraverse_closure" {
     Data.Bitraversable.$dmbitraverse_closure:
         const Data.Bitraversable.$dmbitraverse_info;
 },
 f1_sdOC7_entry() //  [R1]
         { info_tbl: [(cdOIZ,
                       label: f1_sdOC7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOIZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdOJ0; else goto cdOJ1;
       cdOJ0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOJ1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 48;
           call Data.Bitraversable.bitraverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 g_sdOC8_entry() //  [R1]
         { info_tbl: [(cdOJ8,
                       label: g_sdOC8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOJ8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdOJ9; else goto cdOJa;
       cdOJ9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOJa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdOJ6_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Bitraversable.$p1Bitraversable_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdOJ6() //  [R1]
         { info_tbl: [(cdOJ6,
                       label: block_cdOJ6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOJ6: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Data.Bifunctor.bimap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdOCc_entry() //  [R1, R2]
         { info_tbl: [(cdOJk,
                       label: sat_sdOCc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOJk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdOJo; else goto cdOJn;
       cdOJo: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdOJn: // global
           _sdOC7::P64 = P64[R1 + 7];
           _sdOC8::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdOC8::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sdOC7::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$dmbitraverse_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdOJp,
                       label: Data.Bitraversable.$dmbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOJp: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdOJt; else goto cdOJs;
       cdOJt: // global
           HpAlloc = 96;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.$dmbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOJs: // global
           I64[Hp - 88] = f1_sdOC7_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = g_sdOC8_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = sat_sdOCc_info;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.436052443 UTC

[section ""data" . Data.Bitraversable.bifor_closure" {
     Data.Bitraversable.bifor_closure:
         const Data.Bitraversable.bifor_info;
 },
 Data.Bitraversable.bifor_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdOJy,
                       label: Data.Bitraversable.bifor_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOJy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdOJz; else goto cdOJA;
       cdOJz: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.bifor_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOJA: // global
           R2 = R2;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R5;
           P64[Sp - 16] = R6;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Bitraversable.bitraverse_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.437101311 UTC

[section ""data" . Data.Bitraversable.biforM_closure" {
     Data.Bitraversable.biforM_closure:
         const Data.Bitraversable.biforM_info;
 },
 Data.Bitraversable.biforM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdOJF,
                       label: Data.Bitraversable.biforM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOJF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bitraversable.bifor_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.438698085 UTC

[section ""data" . Data.Bitraversable.bimapAccumL_closure" {
     Data.Bitraversable.bimapAccumL_closure:
         const Data.Bitraversable.bimapAccumL_info;
         const 0;
 },
 sat_sdOCs_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOJR,
                       label: sat_sdOCs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOJR: // global
           _sdOCr::P64 = R3;
           R3 = R2;
           R2 = _sdOCr::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdOCp_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOJZ,
                       label: sat_sdOCp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOJZ: // global
           _sdOCo::P64 = R3;
           R3 = R2;
           R2 = _sdOCo::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.bimapAccumL_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdOK2,
                       label: Data.Bitraversable.bimapAccumL_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOK2: // global
           _sdOCm::P64 = R6;
           _sdOCl::P64 = R5;
           _sdOCk::P64 = R4;
           _sdOCj::P64 = R3;
           _sdOCi::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdOK3; else goto cdOK4;
       cdOK4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdOK6; else goto cdOK5;
       cdOK6: // global
           HpAlloc = 32;
           goto cdOK3;
       cdOK3: // global
           R6 = _sdOCm::P64;
           R5 = _sdOCl::P64;
           R4 = _sdOCk::P64;
           R3 = _sdOCj::P64;
           R2 = _sdOCi::P64;
           R1 = Data.Bitraversable.bimapAccumL_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOK5: // global
           I64[Hp - 24] = sat_sdOCs_info;
           P64[Hp - 16] = _sdOCk::P64;
           I64[Hp - 8] = sat_sdOCp_info;
           P64[Hp] = _sdOCj::P64;
           R2 = _sdOCi::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Functor.Utils.$fApplicativeStateL_closure;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = _sdOCm::P64;
           P64[Sp - 8] = _sdOCl::P64;
           Sp = Sp - 48;
           call Data.Bitraversable.bitraverse_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.441086145 UTC

[section ""data" . Data.Bitraversable.bimapAccumR_closure" {
     Data.Bitraversable.bimapAccumR_closure:
         const Data.Bitraversable.bimapAccumR_info;
         const 0;
 },
 sat_sdOCD_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOKh,
                       label: sat_sdOCD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOKh: // global
           _sdOCC::P64 = R3;
           R3 = R2;
           R2 = _sdOCC::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdOCA_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOKp,
                       label: sat_sdOCA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOKp: // global
           _sdOCz::P64 = R3;
           R3 = R2;
           R2 = _sdOCz::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.bimapAccumR_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdOKs,
                       label: Data.Bitraversable.bimapAccumR_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOKs: // global
           _sdOCx::P64 = R6;
           _sdOCw::P64 = R5;
           _sdOCv::P64 = R4;
           _sdOCu::P64 = R3;
           _sdOCt::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdOKt; else goto cdOKu;
       cdOKu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdOKw; else goto cdOKv;
       cdOKw: // global
           HpAlloc = 32;
           goto cdOKt;
       cdOKt: // global
           R6 = _sdOCx::P64;
           R5 = _sdOCw::P64;
           R4 = _sdOCv::P64;
           R3 = _sdOCu::P64;
           R2 = _sdOCt::P64;
           R1 = Data.Bitraversable.bimapAccumR_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOKv: // global
           I64[Hp - 24] = sat_sdOCD_info;
           P64[Hp - 16] = _sdOCv::P64;
           I64[Hp - 8] = sat_sdOCA_info;
           P64[Hp] = _sdOCu::P64;
           R2 = _sdOCt::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Functor.Utils.$fApplicativeStateR_closure;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = _sdOCx::P64;
           P64[Sp - 8] = _sdOCw::P64;
           Sp = Sp - 48;
           call Data.Bitraversable.bitraverse_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.443078971 UTC

[section ""data" . bimapDefault1_rdOxw_closure" {
     bimapDefault1_rdOxw_closure:
         const bimapDefault1_rdOxw_info;
         const 0;
 },
 bimapDefault1_rdOxw_entry() //  [R2]
         { info_tbl: [(cdOKB,
                       label: bimapDefault1_rdOxw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOKB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdOKC; else goto cdOKD;
       cdOKC: // global
           R2 = R2;
           R1 = bimapDefault1_rdOxw_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdOKD: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Functor.Identity.$fApplicativeIdentity_closure;
           Sp = Sp - 16;
           call Data.Bitraversable.bitraverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.44402273 UTC

[section ""data" . Data.Bitraversable.bimapDefault_closure" {
     Data.Bitraversable.bimapDefault_closure:
         const Data.Bitraversable.bimapDefault_info;
         const 0;
 },
 Data.Bitraversable.bimapDefault_entry() //  [R2]
         { info_tbl: [(cdOKI,
                       label: Data.Bitraversable.bimapDefault_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOKI: // global
           R2 = R2;
           call bimapDefault1_rdOxw_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.445039216 UTC

[section ""data" . bifoldMapDefault1_rdOxx_closure" {
     bifoldMapDefault1_rdOxx_closure:
         const bifoldMapDefault1_rdOxx_info;
         const 0;
 },
 sat_sdOCH_entry() //  [R1]
         { info_tbl: [(cdOKT,
                       label: sat_sdOCH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOKT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdOKU; else goto cdOKV;
       cdOKU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOKV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fApplicativeConst_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 bifoldMapDefault1_rdOxx_entry() //  [R2, R3]
         { info_tbl: [(cdOKW,
                       label: bifoldMapDefault1_rdOxx_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOKW: // global
           _sdOCG::P64 = R3;
           _sdOCF::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOKX; else goto cdOKY;
       cdOKY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOL0; else goto cdOKZ;
       cdOL0: // global
           HpAlloc = 24;
           goto cdOKX;
       cdOKX: // global
           R3 = _sdOCG::P64;
           R2 = _sdOCF::P64;
           R1 = bifoldMapDefault1_rdOxx_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOKZ: // global
           I64[Hp - 16] = sat_sdOCH_info;
           P64[Hp] = _sdOCG::P64;
           R2 = _sdOCF::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Bitraversable.bitraverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.446348784 UTC

[section ""data" . Data.Bitraversable.bifoldMapDefault_closure" {
     Data.Bitraversable.bifoldMapDefault_closure:
         const Data.Bitraversable.bifoldMapDefault_info;
         const 0;
 },
 Data.Bitraversable.bifoldMapDefault_entry() //  [R2, R3]
         { info_tbl: [(cdOL5,
                       label: Data.Bitraversable.bifoldMapDefault_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOL5: // global
           R3 = R3;
           R2 = R2;
           call bifoldMapDefault1_rdOxx_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.44713161 UTC

[section ""cstring" . Data.Bitraversable.$trModule4_bytes" {
     Data.Bitraversable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.44771583 UTC

[section ""data" . Data.Bitraversable.$trModule3_closure" {
     Data.Bitraversable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bitraversable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.448277948 UTC

[section ""cstring" . Data.Bitraversable.$trModule2_bytes" {
     Data.Bitraversable.$trModule2_bytes:
         I8[] [68,97,116,97,46,66,105,116,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.448840538 UTC

[section ""data" . Data.Bitraversable.$trModule1_closure" {
     Data.Bitraversable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bitraversable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.449495649 UTC

[section ""data" . Data.Bitraversable.$trModule_closure" {
     Data.Bitraversable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Bitraversable.$trModule3_closure+1;
         const Data.Bitraversable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.450152025 UTC

[section ""data" . $krep_rdOxy_closure" {
     $krep_rdOxy_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.450736091 UTC

[section ""data" . Data.Bitraversable.$tcBitraversable1_closure" {
     Data.Bitraversable.$tcBitraversable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep_rdOxy_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.451376066 UTC

[section ""cstring" . Data.Bitraversable.$tcBitraversable3_bytes" {
     Data.Bitraversable.$tcBitraversable3_bytes:
         I8[] [66,105,116,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.452279011 UTC

[section ""data" . Data.Bitraversable.$tcBitraversable2_closure" {
     Data.Bitraversable.$tcBitraversable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bitraversable.$tcBitraversable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.453169264 UTC

[section ""data" . Data.Bitraversable.$tcBitraversable_closure" {
     Data.Bitraversable.$tcBitraversable_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bitraversable.$trModule_closure+1;
         const Data.Bitraversable.$tcBitraversable2_closure+1;
         const Data.Bitraversable.$tcBitraversable1_closure+4;
         const 1654555613294690493;
         const 8030854156262073676;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.454221307 UTC

[section ""data" . Data.Bitraversable.C:Bitraversable_closure" {
     Data.Bitraversable.C:Bitraversable_closure:
         const Data.Bitraversable.C:Bitraversable_info;
 },
 Data.Bitraversable.C:Bitraversable_entry() //  [R2, R3, R4]
         { info_tbl: [(cdOLd,
                       label: Data.Bitraversable.C:Bitraversable_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOLd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdOLh; else goto cdOLg;
       cdOLh: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.C:Bitraversable_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOLg: // global
           I64[Hp - 24] = Data.Bitraversable.C:Bitraversable_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.455312254 UTC

[Data.Bitraversable.C:Bitraversable_con_entry() //  [R1]
         { info_tbl: [(cdOLi,
                       label: Data.Bitraversable.C:Bitraversable_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,116,114,97,118,101,114,115,97,98,108,101,46,67,58,66,105,116,114,97,118,101,114,115,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOLi: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.456074412 UTC

[section ""relreadonly" . SdOK7_srt" {
     SdOK7_srt:
         const Data.Functor.Utils.$fApplicativeStateL_closure;
         const Data.Bitraversable.bimapAccumL_closure;
         const Data.Functor.Utils.$fApplicativeStateR_closure;
         const Data.Bitraversable.bimapAccumR_closure;
         const Data.Functor.Identity.$fApplicativeIdentity_closure;
         const bimapDefault1_rdOxw_closure;
         const Data.Functor.Const.$fApplicativeConst_closure;
         const bifoldMapDefault1_rdOxx_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.456800538 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:03.457858988 UTC

[section ""data" . Data.Bitraversable.$p1Bitraversable_closure" {
     Data.Bitraversable.$p1Bitraversable_closure:
         const Data.Bitraversable.$p1Bitraversable_info;
 },
 Data.Bitraversable.$p1Bitraversable_entry() //  [R2]
         { info_tbl: [(cdOLq,
                       label: Data.Bitraversable.$p1Bitraversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOLq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdOLr; else goto cdOLs;
       cdOLr: // global
           R2 = R2;
           R1 = Data.Bitraversable.$p1Bitraversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdOLs: // global
           I64[Sp - 8] = block_cdOLn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udOLw; else goto cdOLo;
       udOLw: // global
           call _cdOLn(R1) args: 0, res: 0, upd: 0;
       cdOLo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdOLn() //  [R1]
         { info_tbl: [(cdOLn,
                       label: block_cdOLn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOLn: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.459147708 UTC

[section ""data" . Data.Bitraversable.$p2Bitraversable_closure" {
     Data.Bitraversable.$p2Bitraversable_closure:
         const Data.Bitraversable.$p2Bitraversable_info;
 },
 Data.Bitraversable.$p2Bitraversable_entry() //  [R2]
         { info_tbl: [(cdOLE,
                       label: Data.Bitraversable.$p2Bitraversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOLE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdOLF; else goto cdOLG;
       cdOLF: // global
           R2 = R2;
           R1 = Data.Bitraversable.$p2Bitraversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdOLG: // global
           I64[Sp - 8] = block_cdOLB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udOLK; else goto cdOLC;
       udOLK: // global
           call _cdOLB(R1) args: 0, res: 0, upd: 0;
       cdOLC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdOLB() //  [R1]
         { info_tbl: [(cdOLB,
                       label: block_cdOLB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOLB: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.460423117 UTC

[section ""data" . Data.Bitraversable.bitraverse_closure" {
     Data.Bitraversable.bitraverse_closure:
         const Data.Bitraversable.bitraverse_info;
 },
 Data.Bitraversable.bitraverse_entry() //  [R2]
         { info_tbl: [(cdOLS,
                       label: Data.Bitraversable.bitraverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOLS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdOLT; else goto cdOLU;
       cdOLT: // global
           R2 = R2;
           R1 = Data.Bitraversable.bitraverse_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdOLU: // global
           I64[Sp - 8] = block_cdOLP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udOLY; else goto cdOLQ;
       udOLY: // global
           call _cdOLP(R1) args: 0, res: 0, upd: 0;
       cdOLQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdOLP() //  [R1]
         { info_tbl: [(cdOLP,
                       label: block_cdOLP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOLP: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.462087134 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,)_$cbitraverse_info;
 },
 sat_sdOy2_entry() //  [R1]
         { info_tbl: [(cdOM8,
                       label: sat_sdOy2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOM8: // global
           _sdOy2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOM9; else goto cdOMa;
       cdOMa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOMc; else goto cdOMb;
       cdOMc: // global
           HpAlloc = 24;
           goto cdOM9;
       cdOM9: // global
           R1 = _sdOy2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOMb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOy2::P64;
           _sdOxR::P64 = P64[_sdOy2::P64 + 16];
           _sdOxS::P64 = P64[_sdOy2::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdOxS::P64;
           R2 = Hp - 16;
           R1 = _sdOxR::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOxX_entry() //  [R1]
         { info_tbl: [(cdOMi,
                       label: sat_sdOxX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOMi: // global
           _sdOxX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOMj; else goto cdOMk;
       cdOMk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOMm; else goto cdOMl;
       cdOMm: // global
           HpAlloc = 24;
           goto cdOMj;
       cdOMj: // global
           R1 = _sdOxX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOMl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOxX::P64;
           _sdOxQ::P64 = P64[_sdOxX::P64 + 16];
           _sdOxS::P64 = P64[_sdOxX::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdOxS::P64;
           R2 = Hp - 16;
           R1 = _sdOxQ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bitraversable.$fBitraversable(,)_$cbitraverse_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cdOMn,
                       label: Data.Bitraversable.$fBitraversable(,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOMn: // global
           _sdOxS::P64 = R5;
           _sdOxR::P64 = R4;
           _sdOxQ::P64 = R3;
           _sdOxP::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOMo; else goto cdOMp;
       cdOMp: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdOMr; else goto cdOMq;
       cdOMr: // global
           HpAlloc = 64;
           goto cdOMo;
       cdOMo: // global
           R5 = _sdOxS::P64;
           R4 = _sdOxR::P64;
           R3 = _sdOxQ::P64;
           R2 = _sdOxP::P64;
           R1 = Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOMq: // global
           I64[Hp - 56] = sat_sdOy2_info;
           P64[Hp - 40] = _sdOxR::P64;
           P64[Hp - 32] = _sdOxS::P64;
           I64[Hp - 24] = sat_sdOxX_info;
           P64[Hp - 8] = _sdOxQ::P64;
           P64[Hp] = _sdOxS::P64;
           R2 = _sdOxP::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.465068098 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,)_closure" {
     Data.Bitraversable.$fBitraversable(,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,)_closure;
         const Data.Bifoldable.$fBifoldable(,)_closure;
         const Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.46652605 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_info;
 },
 sat_sdOyo_entry() //  [R1]
         { info_tbl: [(cdOMB,
                       label: sat_sdOyo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOMB: // global
           _sdOyo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOMC; else goto cdOMD;
       cdOMD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOMF; else goto cdOME;
       cdOMF: // global
           HpAlloc = 24;
           goto cdOMC;
       cdOMC: // global
           R1 = _sdOyo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOME: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOyo::P64;
           _sdOy5::P64 = P64[_sdOyo::P64 + 16];
           _sdOy6::P64 = P64[_sdOyo::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdOy6::P64;
           R2 = Hp - 16;
           R1 = _sdOy5::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOyi_entry() //  [R1]
         { info_tbl: [(cdOML,
                       label: sat_sdOyi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOML: // global
           _sdOyi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOMM; else goto cdOMN;
       cdOMN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOMP; else goto cdOMO;
       cdOMP: // global
           HpAlloc = 24;
           goto cdOMM;
       cdOMM: // global
           R1 = _sdOyi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOMO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOyi::P64;
           _sdOy4::P64 = P64[_sdOyi::P64 + 16];
           _sdOy6::P64 = P64[_sdOyi::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdOy6::P64;
           R2 = Hp - 16;
           R1 = _sdOy4::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOyc_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOMX,
                       label: sat_sdOyc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOMX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdON1; else goto cdON0;
       cdON1: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdON0: // global
           _sdOyb::P64 = P64[R1 + 6];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = _sdOyb::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdON2,
                       label: Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdON2: // global
           _sdOy6::P64 = R5;
           _sdOy5::P64 = R4;
           _sdOy4::P64 = R3;
           _sdOy3::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdON3; else goto cdON4;
       cdON4: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdON6; else goto cdON5;
       cdON6: // global
           HpAlloc = 104;
           goto cdON3;
       cdON3: // global
           R5 = _sdOy6::P64;
           R4 = _sdOy5::P64;
           R3 = _sdOy4::P64;
           R2 = _sdOy3::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdON5: // global
           I64[Hp - 96] = sat_sdOyo_info;
           P64[Hp - 80] = _sdOy5::P64;
           P64[Hp - 72] = _sdOy6::P64;
           I64[Hp - 64] = sat_sdOyi_info;
           P64[Hp - 48] = _sdOy4::P64;
           P64[Hp - 40] = _sdOy6::P64;
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdOy6::P64;
           I64[Hp - 8] = sat_sdOyc_info;
           P64[Hp] = Hp - 32;
           R2 = _sdOy3::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 96;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.468530002 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.469883608 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_info;
 },
 sat_sdOyT_entry() //  [R1]
         { info_tbl: [(cdONg,
                       label: sat_sdOyT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdONg: // global
           _sdOyT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdONh; else goto cdONi;
       cdONi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdONk; else goto cdONj;
       cdONk: // global
           HpAlloc = 24;
           goto cdONh;
       cdONh: // global
           R1 = _sdOyT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdONj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOyT::P64;
           _sdOyr::P64 = P64[_sdOyT::P64 + 16];
           _sdOys::P64 = P64[_sdOyT::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdOys::P64;
           R2 = Hp - 16;
           R1 = _sdOyr::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOyM_entry() //  [R1]
         { info_tbl: [(cdONq,
                       label: sat_sdOyM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdONq: // global
           _sdOyM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdONr; else goto cdONs;
       cdONs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdONu; else goto cdONt;
       cdONu: // global
           HpAlloc = 24;
           goto cdONr;
       cdONr: // global
           R1 = _sdOyM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdONt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOyM::P64;
           _sdOyq::P64 = P64[_sdOyM::P64 + 16];
           _sdOys::P64 = P64[_sdOyM::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdOys::P64;
           R2 = Hp - 16;
           R1 = _sdOyq::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOyF_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOND,
                       label: sat_sdOyF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOND: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdONH; else goto cdONG;
       cdONH: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdONG: // global
           _sdOyy::P64 = P64[R1 + 6];
           _sdOyE::P64 = P64[R1 + 14];
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = _sdOyy::P64;
           P64[Hp - 16] = _sdOyE::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdONI,
                       label: Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdONI: // global
           _sdOys::P64 = R5;
           _sdOyr::P64 = R4;
           _sdOyq::P64 = R3;
           _sdOyp::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdONJ; else goto cdONK;
       cdONK: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cdONM; else goto cdONL;
       cdONM: // global
           HpAlloc = 136;
           goto cdONJ;
       cdONJ: // global
           R5 = _sdOys::P64;
           R4 = _sdOyr::P64;
           R3 = _sdOyq::P64;
           R2 = _sdOyp::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdONL: // global
           I64[Hp - 128] = sat_sdOyT_info;
           P64[Hp - 112] = _sdOyr::P64;
           P64[Hp - 104] = _sdOys::P64;
           I64[Hp - 96] = sat_sdOyM_info;
           P64[Hp - 80] = _sdOyq::P64;
           P64[Hp - 72] = _sdOys::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdOys::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdOys::P64;
           I64[Hp - 16] = sat_sdOyF_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = _sdOyp::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 14;
           P64[Sp - 16] = Hp - 96;
           P64[Sp - 8] = Hp - 128;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.471974574 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.473408957 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_info;
 },
 sat_sdOzz_entry() //  [R1]
         { info_tbl: [(cdONW,
                       label: sat_sdOzz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdONW: // global
           _sdOzz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdONX; else goto cdONY;
       cdONY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOO0; else goto cdONZ;
       cdOO0: // global
           HpAlloc = 24;
           goto cdONX;
       cdONX: // global
           R1 = _sdOzz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdONZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOzz::P64;
           _sdOyW::P64 = P64[_sdOzz::P64 + 16];
           _sdOyX::P64 = P64[_sdOzz::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdOyX::P64;
           R2 = Hp - 16;
           R1 = _sdOyW::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOzr_entry() //  [R1]
         { info_tbl: [(cdOO6,
                       label: sat_sdOzr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOO6: // global
           _sdOzr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOO7; else goto cdOO8;
       cdOO8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOOa; else goto cdOO9;
       cdOOa: // global
           HpAlloc = 24;
           goto cdOO7;
       cdOO7: // global
           R1 = _sdOzr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOO9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOzr::P64;
           _sdOyV::P64 = P64[_sdOzr::P64 + 16];
           _sdOyX::P64 = P64[_sdOzr::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdOyX::P64;
           R2 = Hp - 16;
           R1 = _sdOyV::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOzj_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOOk,
                       label: sat_sdOzj_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOOk: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdOOo; else goto cdOOn;
       cdOOo: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOOn: // global
           _sdOz4::P64 = P64[R1 + 6];
           _sdOzb::P64 = P64[R1 + 14];
           _sdOzi::P64 = P64[R1 + 22];
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = _sdOz4::P64;
           P64[Hp - 24] = _sdOzb::P64;
           P64[Hp - 16] = _sdOzi::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cdOOp,
                       label: Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOOp: // global
           _sdOyX::P64 = R5;
           _sdOyW::P64 = R4;
           _sdOyV::P64 = R3;
           _sdOyU::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOOq; else goto cdOOr;
       cdOOr: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cdOOt; else goto cdOOs;
       cdOOt: // global
           HpAlloc = 168;
           goto cdOOq;
       cdOOq: // global
           R5 = _sdOyX::P64;
           R4 = _sdOyW::P64;
           R3 = _sdOyV::P64;
           R2 = _sdOyU::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOOs: // global
           I64[Hp - 160] = sat_sdOzz_info;
           P64[Hp - 144] = _sdOyW::P64;
           P64[Hp - 136] = _sdOyX::P64;
           I64[Hp - 128] = sat_sdOzr_info;
           P64[Hp - 112] = _sdOyV::P64;
           P64[Hp - 104] = _sdOyX::P64;
           I64[Hp - 96] = stg_sel_2_upd_info;
           P64[Hp - 80] = _sdOyX::P64;
           I64[Hp - 72] = stg_sel_1_upd_info;
           P64[Hp - 56] = _sdOyX::P64;
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = _sdOyX::P64;
           I64[Hp - 24] = sat_sdOzj_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R2 = _sdOyU::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = Hp - 128;
           P64[Sp - 8] = Hp - 160;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.475664505 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.477065417 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_info;
 },
 sat_sdOAs_entry() //  [R1]
         { info_tbl: [(cdOOD,
                       label: sat_sdOAs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOOD: // global
           _sdOAs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOOE; else goto cdOOF;
       cdOOF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOOH; else goto cdOOG;
       cdOOH: // global
           HpAlloc = 24;
           goto cdOOE;
       cdOOE: // global
           R1 = _sdOAs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOOG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOAs::P64;
           _sdOzC::P64 = P64[_sdOAs::P64 + 16];
           _sdOzD::P64 = P64[_sdOAs::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdOzD::P64;
           R2 = Hp - 16;
           R1 = _sdOzC::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOAj_entry() //  [R1]
         { info_tbl: [(cdOON,
                       label: sat_sdOAj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOON: // global
           _sdOAj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOOO; else goto cdOOP;
       cdOOP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOOR; else goto cdOOQ;
       cdOOR: // global
           HpAlloc = 24;
           goto cdOOO;
       cdOOO: // global
           R1 = _sdOAj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOOQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOAj::P64;
           _sdOzB::P64 = P64[_sdOAj::P64 + 16];
           _sdOzD::P64 = P64[_sdOAj::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdOzD::P64;
           R2 = Hp - 16;
           R1 = _sdOzB::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOAa_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOP2,
                       label: sat_sdOAa_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOP2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdOP6; else goto cdOP5;
       cdOP6: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOP5: // global
           _sdOzL::P64 = P64[R1 + 6];
           _sdOzT::P64 = P64[R1 + 14];
           _sdOA1::P64 = P64[R1 + 22];
           _sdOA9::P64 = P64[R1 + 30];
           I64[Hp - 48] = (,,,,,)_con_info;
           P64[Hp - 40] = _sdOzL::P64;
           P64[Hp - 32] = _sdOzT::P64;
           P64[Hp - 24] = _sdOA1::P64;
           P64[Hp - 16] = _sdOA9::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cdOP7,
                       label: Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOP7: // global
           _sdOzD::P64 = R5;
           _sdOzC::P64 = R4;
           _sdOzB::P64 = R3;
           _sdOzA::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOP8; else goto cdOP9;
       cdOP9: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cdOPb; else goto cdOPa;
       cdOPb: // global
           HpAlloc = 200;
           goto cdOP8;
       cdOP8: // global
           R5 = _sdOzD::P64;
           R4 = _sdOzC::P64;
           R3 = _sdOzB::P64;
           R2 = _sdOzA::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOPa: // global
           I64[Hp - 192] = sat_sdOAs_info;
           P64[Hp - 176] = _sdOzC::P64;
           P64[Hp - 168] = _sdOzD::P64;
           I64[Hp - 160] = sat_sdOAj_info;
           P64[Hp - 144] = _sdOzB::P64;
           P64[Hp - 136] = _sdOzD::P64;
           I64[Hp - 128] = stg_sel_3_upd_info;
           P64[Hp - 112] = _sdOzD::P64;
           I64[Hp - 104] = stg_sel_2_upd_info;
           P64[Hp - 88] = _sdOzD::P64;
           I64[Hp - 80] = stg_sel_1_upd_info;
           P64[Hp - 64] = _sdOzD::P64;
           I64[Hp - 56] = stg_sel_0_upd_info;
           P64[Hp - 40] = _sdOzD::P64;
           I64[Hp - 32] = sat_sdOAa_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R2 = _sdOzA::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 30;
           P64[Sp - 16] = Hp - 160;
           P64[Sp - 8] = Hp - 192;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.479346645 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.480810191 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_info;
 },
 sat_sdOBA_entry() //  [R1]
         { info_tbl: [(cdOPl,
                       label: sat_sdOBA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOPl: // global
           _sdOBA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOPm; else goto cdOPn;
       cdOPn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOPp; else goto cdOPo;
       cdOPp: // global
           HpAlloc = 24;
           goto cdOPm;
       cdOPm: // global
           R1 = _sdOBA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOPo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOBA::P64;
           _sdOAv::P64 = P64[_sdOBA::P64 + 16];
           _sdOAw::P64 = P64[_sdOBA::P64 + 24];
           I64[Hp - 16] = stg_sel_6_upd_info;
           P64[Hp] = _sdOAw::P64;
           R2 = Hp - 16;
           R1 = _sdOAv::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOBq_entry() //  [R1]
         { info_tbl: [(cdOPv,
                       label: sat_sdOBq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOPv: // global
           _sdOBq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOPw; else goto cdOPx;
       cdOPx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOPz; else goto cdOPy;
       cdOPz: // global
           HpAlloc = 24;
           goto cdOPw;
       cdOPw: // global
           R1 = _sdOBq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOPy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOBq::P64;
           _sdOAu::P64 = P64[_sdOBq::P64 + 16];
           _sdOAw::P64 = P64[_sdOBq::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdOAw::P64;
           R2 = Hp - 16;
           R1 = _sdOAu::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOBg_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOPL,
                       label: sat_sdOBg_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOPL: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdOPP; else goto cdOPO;
       cdOPP: // global
           HpAlloc = 64;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOPO: // global
           _sdOAF::P64 = P64[R1 + 6];
           _sdOAO::P64 = P64[R1 + 14];
           _sdOAX::P64 = P64[R1 + 22];
           _sdOB6::P64 = P64[R1 + 30];
           _sdOBf::P64 = P64[R1 + 38];
           I64[Hp - 56] = (,,,,,,)_con_info;
           P64[Hp - 48] = _sdOAF::P64;
           P64[Hp - 40] = _sdOAO::P64;
           P64[Hp - 32] = _sdOAX::P64;
           P64[Hp - 24] = _sdOB6::P64;
           P64[Hp - 16] = _sdOBf::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_entry() //  [R2,
                                                                      R3, R4, R5]
         { info_tbl: [(cdOPQ,
                       label: Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOPQ: // global
           _sdOAw::P64 = R5;
           _sdOAv::P64 = R4;
           _sdOAu::P64 = R3;
           _sdOAt::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOPR; else goto cdOPS;
       cdOPS: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cdOPU; else goto cdOPT;
       cdOPU: // global
           HpAlloc = 232;
           goto cdOPR;
       cdOPR: // global
           R5 = _sdOAw::P64;
           R4 = _sdOAv::P64;
           R3 = _sdOAu::P64;
           R2 = _sdOAt::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOPT: // global
           I64[Hp - 224] = sat_sdOBA_info;
           P64[Hp - 208] = _sdOAv::P64;
           P64[Hp - 200] = _sdOAw::P64;
           I64[Hp - 192] = sat_sdOBq_info;
           P64[Hp - 176] = _sdOAu::P64;
           P64[Hp - 168] = _sdOAw::P64;
           I64[Hp - 160] = stg_sel_4_upd_info;
           P64[Hp - 144] = _sdOAw::P64;
           I64[Hp - 136] = stg_sel_3_upd_info;
           P64[Hp - 120] = _sdOAw::P64;
           I64[Hp - 112] = stg_sel_2_upd_info;
           P64[Hp - 96] = _sdOAw::P64;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdOAw::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdOAw::P64;
           I64[Hp - 40] = sat_sdOBg_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R2 = _sdOAt::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 38;
           P64[Sp - 16] = Hp - 192;
           P64[Sp - 8] = Hp - 224;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.483480473 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.484854628 UTC

[section ""data" . Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversableEither_$cbitraverse_info;
 },
 Data.Bitraversable.$fBitraversableEither_$cbitraverse_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cdOQ6,
                       label: Data.Bitraversable.$fBitraversableEither_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOQ6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdOQ7; else goto cdOQ8;
       cdOQ7: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOQ8: // global
           I64[Sp - 32] = block_cdOPZ_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udOQv; else goto cdOQ0;
       udOQv: // global
           call _cdOPZ(R1) args: 0, res: 0, upd: 0;
       cdOQ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdOPZ() //  [R1]
         { info_tbl: [(cdOPZ,
                       label: block_cdOPZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOPZ: // global
           _sdOBB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdOQ3; else goto cdOQ4;
       cdOQ3: // global
           Hp = Hp + 32;
           _sdOBF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdOQq; else goto cdOQe;
       cdOQe: // global
           _sdOBG::P64 = P64[_sdOBF::P64 + 7];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdOBG::P64;
           I64[Sp + 16] = block_cdOQc_info;
           R2 = _sdOBB::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
       cdOQ4: // global
           Hp = Hp + 32;
           _sdOBF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdOQq; else goto cdOQp;
       cdOQq: // global
           HpAlloc = 32;
           R1 = _sdOBF::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdOQp: // global
           _sdOBJ::P64 = P64[_sdOBF::P64 + 6];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sdOBJ::P64;
           I64[Sp + 16] = block_cdOQn_info;
           R2 = _sdOBB::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdOQc() //  [R1]
         { info_tbl: [(cdOQc,
                       label: block_cdOQc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOQc: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Left_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cdOQn() //  [R1]
         { info_tbl: [(cdOQn,
                       label: block_cdOQn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOQn: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.486622348 UTC

[section ""data" . Data.Bitraversable.$fBitraversableEither_closure" {
     Data.Bitraversable.$fBitraversableEither_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctorEither_closure;
         const Data.Bifoldable.$fBifoldableEither_closure;
         const Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.487289132 UTC

[section ""data" . Data.Bitraversable.$fBitraversableConst1_closure" {
     Data.Bitraversable.$fBitraversableConst1_closure:
         const Data.Bitraversable.$fBitraversableConst1_info;
 },
 Data.Bitraversable.$fBitraversableConst1_entry() //  [R2]
         { info_tbl: [(cdOQA,
                       label: Data.Bitraversable.$fBitraversableConst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOQA: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.488302374 UTC

[section ""data" . Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversableConst_$cbitraverse_info;
 },
 Data.Bitraversable.$fBitraversableConst_$cbitraverse_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdOQK,
                       label: Data.Bitraversable.$fBitraversableConst_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOQK: // global
           _sdOBQ::P64 = R5;
           _sdOBP::P64 = R4;
           _sdOBO::P64 = R3;
           _sdOBN::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdOQL; else goto cdOQM;
       cdOQM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdOQO; else goto cdOQN;
       cdOQO: // global
           HpAlloc = 32;
           goto cdOQL;
       cdOQL: // global
           R5 = _sdOBQ::P64;
           R4 = _sdOBP::P64;
           R3 = _sdOBO::P64;
           R2 = _sdOBN::P64;
           R1 = Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOQN: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdOBO::P64;
           P64[Hp] = _sdOBQ::P64;
           I64[Sp - 16] = block_cdOQI_info;
           R2 = _sdOBN::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdOQI() //  [R1]
         { info_tbl: [(cdOQI,
                       label: block_cdOQI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOQI: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Bitraversable.$fBitraversableConst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.489585367 UTC

[section ""data" . Data.Bitraversable.$fBitraversableConst_closure" {
     Data.Bitraversable.$fBitraversableConst_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctorConst_closure;
         const Data.Bifoldable.$fBifoldableConst_closure;
         const Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.490529456 UTC

[section ""data" . Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversableK1_$cbitraverse_info;
 },
 Data.Bitraversable.$fBitraversableK1_$cbitraverse_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cdOQZ,
                       label: Data.Bitraversable.$fBitraversableK1_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOQZ: // global
           _sdOBW::P64 = R5;
           _sdOBV::P64 = R4;
           _sdOBU::P64 = R3;
           _sdOBT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdOR0; else goto cdOR1;
       cdOR1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdOR3; else goto cdOR2;
       cdOR3: // global
           HpAlloc = 32;
           goto cdOR0;
       cdOR0: // global
           R5 = _sdOBW::P64;
           R4 = _sdOBV::P64;
           R3 = _sdOBU::P64;
           R2 = _sdOBT::P64;
           R1 = Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOR2: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdOBU::P64;
           P64[Hp] = _sdOBW::P64;
           I64[Sp - 16] = block_cdOQX_info;
           R2 = _sdOBT::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdOQX() //  [R1]
         { info_tbl: [(cdOQX,
                       label: block_cdOQX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOQX: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Bitraversable.$fBitraversableConst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.491732385 UTC

[section ""data" . Data.Bitraversable.$fBitraversableK1_closure" {
     Data.Bitraversable.$fBitraversableK1_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctorK1_closure;
         const Data.Bifoldable.$fBifoldableK1_closure;
         const Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.492548489 UTC

[section ""data" . Data.Bitraversable.bimapM_closure" {
     Data.Bitraversable.bimapM_closure:
         const Data.Bitraversable.bimapM_info;
 },
 Data.Bitraversable.bimapM_entry() //  [R2, R3]
         { info_tbl: [(cdORb,
                       label: Data.Bitraversable.bimapM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdORb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdORc; else goto cdORd;
       cdORc: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.bimapM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdORd: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call Data.Bitraversable.bitraverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.493622061 UTC

[section ""data" . Data.Bitraversable.bisequence_closure" {
     Data.Bitraversable.bisequence_closure:
         const Data.Bitraversable.bisequence_info;
 },
 Data.Bitraversable.bisequence_entry() //  [R2, R3]
         { info_tbl: [(cdORi,
                       label: Data.Bitraversable.bisequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdORi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdORj; else goto cdORk;
       cdORj: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.bisequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdORk: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 32;
           call Data.Bitraversable.bitraverse_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.494644254 UTC

[section ""data" . Data.Bitraversable.bisequenceA_closure" {
     Data.Bitraversable.bisequenceA_closure:
         const Data.Bitraversable.bisequenceA_info;
 },
 Data.Bitraversable.bisequenceA_entry() //  [R2, R3]
         { info_tbl: [(cdORp,
                       label: Data.Bitraversable.bisequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdORp: // global
           R3 = R3;
           R2 = R2;
           call Data.Bitraversable.bisequence_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.497450998 UTC

[section ""data" . Data.Bitraversable.$dmbitraverse_closure" {
     Data.Bitraversable.$dmbitraverse_closure:
         const Data.Bitraversable.$dmbitraverse_info;
 },
 f1_sdOC7_entry() //  [R1]
         { info_tbl: [(cdORA,
                       label: f1_sdOC7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdORA: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdORB; else goto cdORC;
       cdORB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdORC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 48;
           call Data.Bitraversable.bitraverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 g_sdOC8_entry() //  [R1]
         { info_tbl: [(cdORJ,
                       label: g_sdOC8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdORJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdORK; else goto cdORL;
       cdORK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdORL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdORH_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Bitraversable.$p1Bitraversable_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdORH() //  [R1]
         { info_tbl: [(cdORH,
                       label: block_cdORH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdORH: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Data.Bifunctor.bimap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdOCc_entry() //  [R1, R2]
         { info_tbl: [(cdORV,
                       label: sat_sdOCc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdORV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdORZ; else goto cdORY;
       cdORZ: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdORY: // global
           _sdOC7::P64 = P64[R1 + 7];
           _sdOC8::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdOC8::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sdOC7::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$dmbitraverse_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdOS0,
                       label: Data.Bitraversable.$dmbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOS0: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdOS4; else goto cdOS3;
       cdOS4: // global
           HpAlloc = 96;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.$dmbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOS3: // global
           I64[Hp - 88] = f1_sdOC7_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = g_sdOC8_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = sat_sdOCc_info;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.499506521 UTC

[section ""data" . Data.Bitraversable.bifor_closure" {
     Data.Bitraversable.bifor_closure:
         const Data.Bitraversable.bifor_info;
 },
 Data.Bitraversable.bifor_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdOS9,
                       label: Data.Bitraversable.bifor_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOS9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdOSa; else goto cdOSb;
       cdOSa: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.bifor_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOSb: // global
           R2 = R2;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R5;
           P64[Sp - 16] = R6;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Bitraversable.bitraverse_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.500562459 UTC

[section ""data" . Data.Bitraversable.biforM_closure" {
     Data.Bitraversable.biforM_closure:
         const Data.Bitraversable.biforM_info;
 },
 Data.Bitraversable.biforM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdOSg,
                       label: Data.Bitraversable.biforM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOSg: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bitraversable.bifor_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.501788022 UTC

[section ""data" . Data.Bitraversable.bimapAccumL_closure" {
     Data.Bitraversable.bimapAccumL_closure:
         const Data.Bitraversable.bimapAccumL_info;
         const 0;
 },
 sat_sdOCs_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOSs,
                       label: sat_sdOCs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOSs: // global
           _sdOCr::P64 = R3;
           R3 = R2;
           R2 = _sdOCr::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdOCp_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOSA,
                       label: sat_sdOCp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOSA: // global
           _sdOCo::P64 = R3;
           R3 = R2;
           R2 = _sdOCo::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.bimapAccumL_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdOSD,
                       label: Data.Bitraversable.bimapAccumL_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOSD: // global
           _sdOCm::P64 = R6;
           _sdOCl::P64 = R5;
           _sdOCk::P64 = R4;
           _sdOCj::P64 = R3;
           _sdOCi::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdOSE; else goto cdOSF;
       cdOSF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdOSH; else goto cdOSG;
       cdOSH: // global
           HpAlloc = 32;
           goto cdOSE;
       cdOSE: // global
           R6 = _sdOCm::P64;
           R5 = _sdOCl::P64;
           R4 = _sdOCk::P64;
           R3 = _sdOCj::P64;
           R2 = _sdOCi::P64;
           R1 = Data.Bitraversable.bimapAccumL_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOSG: // global
           I64[Hp - 24] = sat_sdOCs_info;
           P64[Hp - 16] = _sdOCk::P64;
           I64[Hp - 8] = sat_sdOCp_info;
           P64[Hp] = _sdOCj::P64;
           R2 = _sdOCi::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Functor.Utils.$fApplicativeStateL_closure;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = _sdOCm::P64;
           P64[Sp - 8] = _sdOCl::P64;
           Sp = Sp - 48;
           call Data.Bitraversable.bitraverse_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.503682932 UTC

[section ""data" . Data.Bitraversable.bimapAccumR_closure" {
     Data.Bitraversable.bimapAccumR_closure:
         const Data.Bitraversable.bimapAccumR_info;
         const 0;
 },
 sat_sdOCD_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOSR,
                       label: sat_sdOCD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOSR: // global
           _sdOCC::P64 = R3;
           R3 = R2;
           R2 = _sdOCC::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdOCA_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOSZ,
                       label: sat_sdOCA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOSZ: // global
           _sdOCz::P64 = R3;
           R3 = R2;
           R2 = _sdOCz::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.bimapAccumR_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdOT2,
                       label: Data.Bitraversable.bimapAccumR_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOT2: // global
           _sdOCx::P64 = R6;
           _sdOCw::P64 = R5;
           _sdOCv::P64 = R4;
           _sdOCu::P64 = R3;
           _sdOCt::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdOT3; else goto cdOT4;
       cdOT4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdOT6; else goto cdOT5;
       cdOT6: // global
           HpAlloc = 32;
           goto cdOT3;
       cdOT3: // global
           R6 = _sdOCx::P64;
           R5 = _sdOCw::P64;
           R4 = _sdOCv::P64;
           R3 = _sdOCu::P64;
           R2 = _sdOCt::P64;
           R1 = Data.Bitraversable.bimapAccumR_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOT5: // global
           I64[Hp - 24] = sat_sdOCD_info;
           P64[Hp - 16] = _sdOCv::P64;
           I64[Hp - 8] = sat_sdOCA_info;
           P64[Hp] = _sdOCu::P64;
           R2 = _sdOCt::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Functor.Utils.$fApplicativeStateR_closure;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = _sdOCx::P64;
           P64[Sp - 8] = _sdOCw::P64;
           Sp = Sp - 48;
           call Data.Bitraversable.bitraverse_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.505278681 UTC

[section ""data" . bimapDefault1_rdOxw_closure" {
     bimapDefault1_rdOxw_closure:
         const bimapDefault1_rdOxw_info;
         const 0;
 },
 bimapDefault1_rdOxw_entry() //  [R2]
         { info_tbl: [(cdOTb,
                       label: bimapDefault1_rdOxw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOTb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdOTc; else goto cdOTd;
       cdOTc: // global
           R2 = R2;
           R1 = bimapDefault1_rdOxw_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdOTd: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Functor.Identity.$fApplicativeIdentity_closure;
           Sp = Sp - 16;
           call Data.Bitraversable.bitraverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.50624208 UTC

[section ""data" . Data.Bitraversable.bimapDefault_closure" {
     Data.Bitraversable.bimapDefault_closure:
         const Data.Bitraversable.bimapDefault_info;
         const 0;
 },
 Data.Bitraversable.bimapDefault_entry() //  [R2]
         { info_tbl: [(cdOTi,
                       label: Data.Bitraversable.bimapDefault_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOTi: // global
           R2 = R2;
           call bimapDefault1_rdOxw_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.50722155 UTC

[section ""data" . bifoldMapDefault1_rdOxx_closure" {
     bifoldMapDefault1_rdOxx_closure:
         const bifoldMapDefault1_rdOxx_info;
         const 0;
 },
 sat_sdOCH_entry() //  [R1]
         { info_tbl: [(cdOTt,
                       label: sat_sdOCH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOTt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdOTu; else goto cdOTv;
       cdOTu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOTv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fApplicativeConst_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 bifoldMapDefault1_rdOxx_entry() //  [R2, R3]
         { info_tbl: [(cdOTw,
                       label: bifoldMapDefault1_rdOxx_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOTw: // global
           _sdOCG::P64 = R3;
           _sdOCF::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOTx; else goto cdOTy;
       cdOTy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOTA; else goto cdOTz;
       cdOTA: // global
           HpAlloc = 24;
           goto cdOTx;
       cdOTx: // global
           R3 = _sdOCG::P64;
           R2 = _sdOCF::P64;
           R1 = bifoldMapDefault1_rdOxx_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOTz: // global
           I64[Hp - 16] = sat_sdOCH_info;
           P64[Hp] = _sdOCG::P64;
           R2 = _sdOCF::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Bitraversable.bitraverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.508512366 UTC

[section ""data" . Data.Bitraversable.bifoldMapDefault_closure" {
     Data.Bitraversable.bifoldMapDefault_closure:
         const Data.Bitraversable.bifoldMapDefault_info;
         const 0;
 },
 Data.Bitraversable.bifoldMapDefault_entry() //  [R2, R3]
         { info_tbl: [(cdOTF,
                       label: Data.Bitraversable.bifoldMapDefault_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOTF: // global
           R3 = R3;
           R2 = R2;
           call bifoldMapDefault1_rdOxx_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.509225995 UTC

[section ""cstring" . Data.Bitraversable.$trModule4_bytes" {
     Data.Bitraversable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.509835839 UTC

[section ""data" . Data.Bitraversable.$trModule3_closure" {
     Data.Bitraversable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bitraversable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.510428284 UTC

[section ""cstring" . Data.Bitraversable.$trModule2_bytes" {
     Data.Bitraversable.$trModule2_bytes:
         I8[] [68,97,116,97,46,66,105,116,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.511065863 UTC

[section ""data" . Data.Bitraversable.$trModule1_closure" {
     Data.Bitraversable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bitraversable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.511644844 UTC

[section ""data" . Data.Bitraversable.$trModule_closure" {
     Data.Bitraversable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Bitraversable.$trModule3_closure+1;
         const Data.Bitraversable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.512253813 UTC

[section ""data" . $krep_rdOxy_closure" {
     $krep_rdOxy_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.512819057 UTC

[section ""data" . Data.Bitraversable.$tcBitraversable1_closure" {
     Data.Bitraversable.$tcBitraversable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep_rdOxy_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.513642703 UTC

[section ""cstring" . Data.Bitraversable.$tcBitraversable3_bytes" {
     Data.Bitraversable.$tcBitraversable3_bytes:
         I8[] [66,105,116,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.514222187 UTC

[section ""data" . Data.Bitraversable.$tcBitraversable2_closure" {
     Data.Bitraversable.$tcBitraversable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bitraversable.$tcBitraversable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.514840398 UTC

[section ""data" . Data.Bitraversable.$tcBitraversable_closure" {
     Data.Bitraversable.$tcBitraversable_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bitraversable.$trModule_closure+1;
         const Data.Bitraversable.$tcBitraversable2_closure+1;
         const Data.Bitraversable.$tcBitraversable1_closure+4;
         const 1654555613294690493;
         const 8030854156262073676;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.515798589 UTC

[section ""data" . Data.Bitraversable.C:Bitraversable_closure" {
     Data.Bitraversable.C:Bitraversable_closure:
         const Data.Bitraversable.C:Bitraversable_info;
 },
 Data.Bitraversable.C:Bitraversable_entry() //  [R2, R3, R4]
         { info_tbl: [(cdOTN,
                       label: Data.Bitraversable.C:Bitraversable_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOTN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdOTR; else goto cdOTQ;
       cdOTR: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.C:Bitraversable_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOTQ: // global
           I64[Hp - 24] = Data.Bitraversable.C:Bitraversable_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.516815015 UTC

[Data.Bitraversable.C:Bitraversable_con_entry() //  [R1]
         { info_tbl: [(cdOTS,
                       label: Data.Bitraversable.C:Bitraversable_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,116,114,97,118,101,114,115,97,98,108,101,46,67,58,66,105,116,114,97,118,101,114,115,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOTS: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.517852321 UTC

[section ""relreadonly" . SdOK7_srt" {
     SdOK7_srt:
         const Data.Functor.Utils.$fApplicativeStateL_closure;
         const Data.Bitraversable.bimapAccumL_closure;
         const Data.Functor.Utils.$fApplicativeStateR_closure;
         const Data.Bitraversable.bimapAccumR_closure;
         const Data.Functor.Identity.$fApplicativeIdentity_closure;
         const bimapDefault1_rdOxw_closure;
         const Data.Functor.Const.$fApplicativeConst_closure;
         const bifoldMapDefault1_rdOxx_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.518716398 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:03.520122517 UTC

[section ""data" . Data.Bitraversable.$p1Bitraversable_closure" {
     Data.Bitraversable.$p1Bitraversable_closure:
         const Data.Bitraversable.$p1Bitraversable_info;
 },
 Data.Bitraversable.$p1Bitraversable_entry() //  [R2]
         { info_tbl: [(cdOU1,
                       label: Data.Bitraversable.$p1Bitraversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOU1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdOU2; else goto cdOU3;
       cdOU2: // global
           R2 = R2;
           R1 = Data.Bitraversable.$p1Bitraversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdOU3: // global
           I64[Sp - 8] = block_cdOTY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udOU7; else goto cdOTZ;
       udOU7: // global
           call _cdOTY(R1) args: 0, res: 0, upd: 0;
       cdOTZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdOTY() //  [R1]
         { info_tbl: [(cdOTY,
                       label: block_cdOTY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOTY: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.526114868 UTC

[section ""data" . Data.Bitraversable.$p2Bitraversable_closure" {
     Data.Bitraversable.$p2Bitraversable_closure:
         const Data.Bitraversable.$p2Bitraversable_info;
 },
 Data.Bitraversable.$p2Bitraversable_entry() //  [R2]
         { info_tbl: [(cdOUq,
                       label: Data.Bitraversable.$p2Bitraversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOUq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdOUr; else goto cdOUs;
       cdOUr: // global
           R2 = R2;
           R1 = Data.Bitraversable.$p2Bitraversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdOUs: // global
           I64[Sp - 8] = block_cdOUn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udOUw; else goto cdOUo;
       udOUw: // global
           call _cdOUn(R1) args: 0, res: 0, upd: 0;
       cdOUo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdOUn() //  [R1]
         { info_tbl: [(cdOUn,
                       label: block_cdOUn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOUn: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.532789036 UTC

[section ""data" . Data.Bitraversable.bitraverse_closure" {
     Data.Bitraversable.bitraverse_closure:
         const Data.Bitraversable.bitraverse_info;
 },
 Data.Bitraversable.bitraverse_entry() //  [R2]
         { info_tbl: [(cdOUP,
                       label: Data.Bitraversable.bitraverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOUP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdOUQ; else goto cdOUR;
       cdOUQ: // global
           R2 = R2;
           R1 = Data.Bitraversable.bitraverse_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdOUR: // global
           I64[Sp - 8] = block_cdOUM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udOUV; else goto cdOUN;
       udOUV: // global
           call _cdOUM(R1) args: 0, res: 0, upd: 0;
       cdOUN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdOUM() //  [R1]
         { info_tbl: [(cdOUM,
                       label: block_cdOUM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOUM: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.539204264 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,)_$cbitraverse_info;
 },
 sat_sdOy2_entry() //  [R1]
         { info_tbl: [(cdOVe,
                       label: sat_sdOy2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOVe: // global
           _sdOy2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOVf; else goto cdOVg;
       cdOVg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOVi; else goto cdOVh;
       cdOVi: // global
           HpAlloc = 24;
           goto cdOVf;
       cdOVf: // global
           R1 = _sdOy2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOVh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOy2::P64;
           _sdOxR::P64 = P64[_sdOy2::P64 + 16];
           _sdOxS::P64 = P64[_sdOy2::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdOxS::P64;
           R2 = Hp - 16;
           R1 = _sdOxR::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOxX_entry() //  [R1]
         { info_tbl: [(cdOVo,
                       label: sat_sdOxX_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOVo: // global
           _sdOxX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOVp; else goto cdOVq;
       cdOVq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOVs; else goto cdOVr;
       cdOVs: // global
           HpAlloc = 24;
           goto cdOVp;
       cdOVp: // global
           R1 = _sdOxX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOVr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOxX::P64;
           _sdOxQ::P64 = P64[_sdOxX::P64 + 16];
           _sdOxS::P64 = P64[_sdOxX::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdOxS::P64;
           R2 = Hp - 16;
           R1 = _sdOxQ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bitraversable.$fBitraversable(,)_$cbitraverse_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cdOVt,
                       label: Data.Bitraversable.$fBitraversable(,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOVt: // global
           _sdOxS::P64 = R5;
           _sdOxR::P64 = R4;
           _sdOxQ::P64 = R3;
           _sdOxP::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOVu; else goto cdOVv;
       cdOVv: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdOVx; else goto cdOVw;
       cdOVx: // global
           HpAlloc = 64;
           goto cdOVu;
       cdOVu: // global
           R5 = _sdOxS::P64;
           R4 = _sdOxR::P64;
           R3 = _sdOxQ::P64;
           R2 = _sdOxP::P64;
           R1 = Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOVw: // global
           I64[Hp - 56] = sat_sdOy2_info;
           P64[Hp - 40] = _sdOxR::P64;
           P64[Hp - 32] = _sdOxS::P64;
           I64[Hp - 24] = sat_sdOxX_info;
           P64[Hp - 8] = _sdOxQ::P64;
           P64[Hp] = _sdOxS::P64;
           R2 = _sdOxP::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.548050318 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,)_closure" {
     Data.Bitraversable.$fBitraversable(,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,)_closure;
         const Data.Bifoldable.$fBifoldable(,)_closure;
         const Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.55121532 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_info;
 },
 sat_sdOyo_entry() //  [R1]
         { info_tbl: [(cdOVX,
                       label: sat_sdOyo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOVX: // global
           _sdOyo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOVY; else goto cdOVZ;
       cdOVZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOW1; else goto cdOW0;
       cdOW1: // global
           HpAlloc = 24;
           goto cdOVY;
       cdOVY: // global
           R1 = _sdOyo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOW0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOyo::P64;
           _sdOy5::P64 = P64[_sdOyo::P64 + 16];
           _sdOy6::P64 = P64[_sdOyo::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdOy6::P64;
           R2 = Hp - 16;
           R1 = _sdOy5::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOyi_entry() //  [R1]
         { info_tbl: [(cdOW7,
                       label: sat_sdOyi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOW7: // global
           _sdOyi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOW8; else goto cdOW9;
       cdOW9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOWb; else goto cdOWa;
       cdOWb: // global
           HpAlloc = 24;
           goto cdOW8;
       cdOW8: // global
           R1 = _sdOyi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOWa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOyi::P64;
           _sdOy4::P64 = P64[_sdOyi::P64 + 16];
           _sdOy6::P64 = P64[_sdOyi::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdOy6::P64;
           R2 = Hp - 16;
           R1 = _sdOy4::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOyc_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOWj,
                       label: sat_sdOyc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOWj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdOWn; else goto cdOWm;
       cdOWn: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOWm: // global
           _sdOyb::P64 = P64[R1 + 6];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = _sdOyb::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdOWo,
                       label: Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOWo: // global
           _sdOy6::P64 = R5;
           _sdOy5::P64 = R4;
           _sdOy4::P64 = R3;
           _sdOy3::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOWp; else goto cdOWq;
       cdOWq: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdOWs; else goto cdOWr;
       cdOWs: // global
           HpAlloc = 104;
           goto cdOWp;
       cdOWp: // global
           R5 = _sdOy6::P64;
           R4 = _sdOy5::P64;
           R3 = _sdOy4::P64;
           R2 = _sdOy3::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOWr: // global
           I64[Hp - 96] = sat_sdOyo_info;
           P64[Hp - 80] = _sdOy5::P64;
           P64[Hp - 72] = _sdOy6::P64;
           I64[Hp - 64] = sat_sdOyi_info;
           P64[Hp - 48] = _sdOy4::P64;
           P64[Hp - 40] = _sdOy6::P64;
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdOy6::P64;
           I64[Hp - 8] = sat_sdOyc_info;
           P64[Hp] = Hp - 32;
           R2 = _sdOy3::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 96;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.563680559 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.566475307 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_info;
 },
 sat_sdOyT_entry() //  [R1]
         { info_tbl: [(cdOWY,
                       label: sat_sdOyT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOWY: // global
           _sdOyT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOWZ; else goto cdOX0;
       cdOX0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOX2; else goto cdOX1;
       cdOX2: // global
           HpAlloc = 24;
           goto cdOWZ;
       cdOWZ: // global
           R1 = _sdOyT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOX1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOyT::P64;
           _sdOyr::P64 = P64[_sdOyT::P64 + 16];
           _sdOys::P64 = P64[_sdOyT::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdOys::P64;
           R2 = Hp - 16;
           R1 = _sdOyr::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOyM_entry() //  [R1]
         { info_tbl: [(cdOX8,
                       label: sat_sdOyM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOX8: // global
           _sdOyM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOX9; else goto cdOXa;
       cdOXa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOXc; else goto cdOXb;
       cdOXc: // global
           HpAlloc = 24;
           goto cdOX9;
       cdOX9: // global
           R1 = _sdOyM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOXb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOyM::P64;
           _sdOyq::P64 = P64[_sdOyM::P64 + 16];
           _sdOys::P64 = P64[_sdOyM::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdOys::P64;
           R2 = Hp - 16;
           R1 = _sdOyq::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOyF_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOXl,
                       label: sat_sdOyF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOXl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdOXp; else goto cdOXo;
       cdOXp: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOXo: // global
           _sdOyy::P64 = P64[R1 + 6];
           _sdOyE::P64 = P64[R1 + 14];
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = _sdOyy::P64;
           P64[Hp - 16] = _sdOyE::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdOXq,
                       label: Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOXq: // global
           _sdOys::P64 = R5;
           _sdOyr::P64 = R4;
           _sdOyq::P64 = R3;
           _sdOyp::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOXr; else goto cdOXs;
       cdOXs: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cdOXu; else goto cdOXt;
       cdOXu: // global
           HpAlloc = 136;
           goto cdOXr;
       cdOXr: // global
           R5 = _sdOys::P64;
           R4 = _sdOyr::P64;
           R3 = _sdOyq::P64;
           R2 = _sdOyp::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOXt: // global
           I64[Hp - 128] = sat_sdOyT_info;
           P64[Hp - 112] = _sdOyr::P64;
           P64[Hp - 104] = _sdOys::P64;
           I64[Hp - 96] = sat_sdOyM_info;
           P64[Hp - 80] = _sdOyq::P64;
           P64[Hp - 72] = _sdOys::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdOys::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdOys::P64;
           I64[Hp - 16] = sat_sdOyF_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = _sdOyp::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 14;
           P64[Sp - 16] = Hp - 96;
           P64[Sp - 8] = Hp - 128;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.579430866 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.583806828 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_info;
 },
 sat_sdOzz_entry() //  [R1]
         { info_tbl: [(cdOY1,
                       label: sat_sdOzz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOY1: // global
           _sdOzz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOY2; else goto cdOY3;
       cdOY3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOY5; else goto cdOY4;
       cdOY5: // global
           HpAlloc = 24;
           goto cdOY2;
       cdOY2: // global
           R1 = _sdOzz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOY4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOzz::P64;
           _sdOyW::P64 = P64[_sdOzz::P64 + 16];
           _sdOyX::P64 = P64[_sdOzz::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdOyX::P64;
           R2 = Hp - 16;
           R1 = _sdOyW::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOzr_entry() //  [R1]
         { info_tbl: [(cdOYb,
                       label: sat_sdOzr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOYb: // global
           _sdOzr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOYc; else goto cdOYd;
       cdOYd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOYf; else goto cdOYe;
       cdOYf: // global
           HpAlloc = 24;
           goto cdOYc;
       cdOYc: // global
           R1 = _sdOzr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOYe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOzr::P64;
           _sdOyV::P64 = P64[_sdOzr::P64 + 16];
           _sdOyX::P64 = P64[_sdOzr::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdOyX::P64;
           R2 = Hp - 16;
           R1 = _sdOyV::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOzj_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOYp,
                       label: sat_sdOzj_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOYp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdOYt; else goto cdOYs;
       cdOYt: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOYs: // global
           _sdOz4::P64 = P64[R1 + 6];
           _sdOzb::P64 = P64[R1 + 14];
           _sdOzi::P64 = P64[R1 + 22];
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = _sdOz4::P64;
           P64[Hp - 24] = _sdOzb::P64;
           P64[Hp - 16] = _sdOzi::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cdOYu,
                       label: Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOYu: // global
           _sdOyX::P64 = R5;
           _sdOyW::P64 = R4;
           _sdOyV::P64 = R3;
           _sdOyU::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOYv; else goto cdOYw;
       cdOYw: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cdOYy; else goto cdOYx;
       cdOYy: // global
           HpAlloc = 168;
           goto cdOYv;
       cdOYv: // global
           R5 = _sdOyX::P64;
           R4 = _sdOyW::P64;
           R3 = _sdOyV::P64;
           R2 = _sdOyU::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOYx: // global
           I64[Hp - 160] = sat_sdOzz_info;
           P64[Hp - 144] = _sdOyW::P64;
           P64[Hp - 136] = _sdOyX::P64;
           I64[Hp - 128] = sat_sdOzr_info;
           P64[Hp - 112] = _sdOyV::P64;
           P64[Hp - 104] = _sdOyX::P64;
           I64[Hp - 96] = stg_sel_2_upd_info;
           P64[Hp - 80] = _sdOyX::P64;
           I64[Hp - 72] = stg_sel_1_upd_info;
           P64[Hp - 56] = _sdOyX::P64;
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = _sdOyX::P64;
           I64[Hp - 24] = sat_sdOzj_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R2 = _sdOyU::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = Hp - 128;
           P64[Sp - 8] = Hp - 160;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.598519206 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.601639359 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_info;
 },
 sat_sdOAs_entry() //  [R1]
         { info_tbl: [(cdOZ6,
                       label: sat_sdOAs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOZ6: // global
           _sdOAs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOZ7; else goto cdOZ8;
       cdOZ8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOZa; else goto cdOZ9;
       cdOZa: // global
           HpAlloc = 24;
           goto cdOZ7;
       cdOZ7: // global
           R1 = _sdOAs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOZ9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOAs::P64;
           _sdOzC::P64 = P64[_sdOAs::P64 + 16];
           _sdOzD::P64 = P64[_sdOAs::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdOzD::P64;
           R2 = Hp - 16;
           R1 = _sdOzC::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOAj_entry() //  [R1]
         { info_tbl: [(cdOZg,
                       label: sat_sdOAj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOZg: // global
           _sdOAj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOZh; else goto cdOZi;
       cdOZi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdOZk; else goto cdOZj;
       cdOZk: // global
           HpAlloc = 24;
           goto cdOZh;
       cdOZh: // global
           R1 = _sdOAj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdOZj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOAj::P64;
           _sdOzB::P64 = P64[_sdOAj::P64 + 16];
           _sdOzD::P64 = P64[_sdOAj::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdOzD::P64;
           R2 = Hp - 16;
           R1 = _sdOzB::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOAa_entry() //  [R1, R2, R3]
         { info_tbl: [(cdOZv,
                       label: sat_sdOAa_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOZv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdOZz; else goto cdOZy;
       cdOZz: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOZy: // global
           _sdOzL::P64 = P64[R1 + 6];
           _sdOzT::P64 = P64[R1 + 14];
           _sdOA1::P64 = P64[R1 + 22];
           _sdOA9::P64 = P64[R1 + 30];
           I64[Hp - 48] = (,,,,,)_con_info;
           P64[Hp - 40] = _sdOzL::P64;
           P64[Hp - 32] = _sdOzT::P64;
           P64[Hp - 24] = _sdOA1::P64;
           P64[Hp - 16] = _sdOA9::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cdOZA,
                       label: Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdOZA: // global
           _sdOzD::P64 = R5;
           _sdOzC::P64 = R4;
           _sdOzB::P64 = R3;
           _sdOzA::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdOZB; else goto cdOZC;
       cdOZC: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cdOZE; else goto cdOZD;
       cdOZE: // global
           HpAlloc = 200;
           goto cdOZB;
       cdOZB: // global
           R5 = _sdOzD::P64;
           R4 = _sdOzC::P64;
           R3 = _sdOzB::P64;
           R2 = _sdOzA::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdOZD: // global
           I64[Hp - 192] = sat_sdOAs_info;
           P64[Hp - 176] = _sdOzC::P64;
           P64[Hp - 168] = _sdOzD::P64;
           I64[Hp - 160] = sat_sdOAj_info;
           P64[Hp - 144] = _sdOzB::P64;
           P64[Hp - 136] = _sdOzD::P64;
           I64[Hp - 128] = stg_sel_3_upd_info;
           P64[Hp - 112] = _sdOzD::P64;
           I64[Hp - 104] = stg_sel_2_upd_info;
           P64[Hp - 88] = _sdOzD::P64;
           I64[Hp - 80] = stg_sel_1_upd_info;
           P64[Hp - 64] = _sdOzD::P64;
           I64[Hp - 56] = stg_sel_0_upd_info;
           P64[Hp - 40] = _sdOzD::P64;
           I64[Hp - 32] = sat_sdOAa_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R2 = _sdOzA::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 30;
           P64[Sp - 16] = Hp - 160;
           P64[Sp - 8] = Hp - 192;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.614833109 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.61818848 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_info;
 },
 sat_sdOBA_entry() //  [R1]
         { info_tbl: [(cdP0d,
                       label: sat_sdOBA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP0d: // global
           _sdOBA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdP0e; else goto cdP0f;
       cdP0f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdP0h; else goto cdP0g;
       cdP0h: // global
           HpAlloc = 24;
           goto cdP0e;
       cdP0e: // global
           R1 = _sdOBA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdP0g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOBA::P64;
           _sdOAv::P64 = P64[_sdOBA::P64 + 16];
           _sdOAw::P64 = P64[_sdOBA::P64 + 24];
           I64[Hp - 16] = stg_sel_6_upd_info;
           P64[Hp] = _sdOAw::P64;
           R2 = Hp - 16;
           R1 = _sdOAv::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOBq_entry() //  [R1]
         { info_tbl: [(cdP0n,
                       label: sat_sdOBq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP0n: // global
           _sdOBq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdP0o; else goto cdP0p;
       cdP0p: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdP0r; else goto cdP0q;
       cdP0r: // global
           HpAlloc = 24;
           goto cdP0o;
       cdP0o: // global
           R1 = _sdOBq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdP0q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdOBq::P64;
           _sdOAu::P64 = P64[_sdOBq::P64 + 16];
           _sdOAw::P64 = P64[_sdOBq::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdOAw::P64;
           R2 = Hp - 16;
           R1 = _sdOAu::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdOBg_entry() //  [R1, R2, R3]
         { info_tbl: [(cdP0D,
                       label: sat_sdOBg_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP0D: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdP0H; else goto cdP0G;
       cdP0H: // global
           HpAlloc = 64;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdP0G: // global
           _sdOAF::P64 = P64[R1 + 6];
           _sdOAO::P64 = P64[R1 + 14];
           _sdOAX::P64 = P64[R1 + 22];
           _sdOB6::P64 = P64[R1 + 30];
           _sdOBf::P64 = P64[R1 + 38];
           I64[Hp - 56] = (,,,,,,)_con_info;
           P64[Hp - 48] = _sdOAF::P64;
           P64[Hp - 40] = _sdOAO::P64;
           P64[Hp - 32] = _sdOAX::P64;
           P64[Hp - 24] = _sdOB6::P64;
           P64[Hp - 16] = _sdOBf::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_entry() //  [R2,
                                                                      R3, R4, R5]
         { info_tbl: [(cdP0I,
                       label: Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP0I: // global
           _sdOAw::P64 = R5;
           _sdOAv::P64 = R4;
           _sdOAu::P64 = R3;
           _sdOAt::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdP0J; else goto cdP0K;
       cdP0K: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cdP0M; else goto cdP0L;
       cdP0M: // global
           HpAlloc = 232;
           goto cdP0J;
       cdP0J: // global
           R5 = _sdOAw::P64;
           R4 = _sdOAv::P64;
           R3 = _sdOAu::P64;
           R2 = _sdOAt::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdP0L: // global
           I64[Hp - 224] = sat_sdOBA_info;
           P64[Hp - 208] = _sdOAv::P64;
           P64[Hp - 200] = _sdOAw::P64;
           I64[Hp - 192] = sat_sdOBq_info;
           P64[Hp - 176] = _sdOAu::P64;
           P64[Hp - 168] = _sdOAw::P64;
           I64[Hp - 160] = stg_sel_4_upd_info;
           P64[Hp - 144] = _sdOAw::P64;
           I64[Hp - 136] = stg_sel_3_upd_info;
           P64[Hp - 120] = _sdOAw::P64;
           I64[Hp - 112] = stg_sel_2_upd_info;
           P64[Hp - 96] = _sdOAw::P64;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdOAw::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdOAw::P64;
           I64[Hp - 40] = sat_sdOBg_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R2 = _sdOAt::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 38;
           P64[Sp - 16] = Hp - 192;
           P64[Sp - 8] = Hp - 224;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.632773728 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.635757485 UTC

[section ""data" . Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversableEither_$cbitraverse_info;
 },
 Data.Bitraversable.$fBitraversableEither_$cbitraverse_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cdP1o,
                       label: Data.Bitraversable.$fBitraversableEither_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP1o: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdP1p; else goto cdP1q;
       cdP1p: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdP1q: // global
           I64[Sp - 32] = block_cdP1h_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udP1N; else goto cdP1i;
       udP1N: // global
           call _cdP1h(R1) args: 0, res: 0, upd: 0;
       cdP1i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdP1h() //  [R1]
         { info_tbl: [(cdP1h,
                       label: block_cdP1h_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP1h: // global
           _sdOBB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdP1l; else goto cdP1m;
       cdP1l: // global
           Hp = Hp + 32;
           _sdOBF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdP1I; else goto cdP1w;
       cdP1w: // global
           _sdOBG::P64 = P64[_sdOBF::P64 + 7];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdOBG::P64;
           I64[Sp + 16] = block_cdP1u_info;
           R2 = _sdOBB::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
       cdP1m: // global
           Hp = Hp + 32;
           _sdOBF::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdP1I; else goto cdP1H;
       cdP1I: // global
           HpAlloc = 32;
           R1 = _sdOBF::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdP1H: // global
           _sdOBJ::P64 = P64[_sdOBF::P64 + 6];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sdOBJ::P64;
           I64[Sp + 16] = block_cdP1F_info;
           R2 = _sdOBB::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdP1u() //  [R1]
         { info_tbl: [(cdP1u,
                       label: block_cdP1u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP1u: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Left_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cdP1F() //  [R1]
         { info_tbl: [(cdP1F,
                       label: block_cdP1F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP1F: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.647377074 UTC

[section ""data" . Data.Bitraversable.$fBitraversableEither_closure" {
     Data.Bitraversable.$fBitraversableEither_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctorEither_closure;
         const Data.Bifoldable.$fBifoldableEither_closure;
         const Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.649843443 UTC

[section ""data" . Data.Bitraversable.$fBitraversableConst1_closure" {
     Data.Bitraversable.$fBitraversableConst1_closure:
         const Data.Bitraversable.$fBitraversableConst1_info;
 },
 Data.Bitraversable.$fBitraversableConst1_entry() //  [R2]
         { info_tbl: [(cdP2e,
                       label: Data.Bitraversable.$fBitraversableConst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP2e: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.654139057 UTC

[section ""data" . Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversableConst_$cbitraverse_info;
 },
 Data.Bitraversable.$fBitraversableConst_$cbitraverse_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdP2s,
                       label: Data.Bitraversable.$fBitraversableConst_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP2s: // global
           _sdOBQ::P64 = R5;
           _sdOBP::P64 = R4;
           _sdOBO::P64 = R3;
           _sdOBN::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdP2t; else goto cdP2u;
       cdP2u: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdP2w; else goto cdP2v;
       cdP2w: // global
           HpAlloc = 32;
           goto cdP2t;
       cdP2t: // global
           R5 = _sdOBQ::P64;
           R4 = _sdOBP::P64;
           R3 = _sdOBO::P64;
           R2 = _sdOBN::P64;
           R1 = Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdP2v: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdOBO::P64;
           P64[Hp] = _sdOBQ::P64;
           I64[Sp - 16] = block_cdP2q_info;
           R2 = _sdOBN::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdP2q() //  [R1]
         { info_tbl: [(cdP2q,
                       label: block_cdP2q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP2q: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Bitraversable.$fBitraversableConst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.661411536 UTC

[section ""data" . Data.Bitraversable.$fBitraversableConst_closure" {
     Data.Bitraversable.$fBitraversableConst_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctorConst_closure;
         const Data.Bifoldable.$fBifoldableConst_closure;
         const Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.664128972 UTC

[section ""data" . Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversableK1_$cbitraverse_info;
 },
 Data.Bitraversable.$fBitraversableK1_$cbitraverse_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cdP2R,
                       label: Data.Bitraversable.$fBitraversableK1_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP2R: // global
           _sdOBW::P64 = R5;
           _sdOBV::P64 = R4;
           _sdOBU::P64 = R3;
           _sdOBT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdP2S; else goto cdP2T;
       cdP2T: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdP2V; else goto cdP2U;
       cdP2V: // global
           HpAlloc = 32;
           goto cdP2S;
       cdP2S: // global
           R5 = _sdOBW::P64;
           R4 = _sdOBV::P64;
           R3 = _sdOBU::P64;
           R2 = _sdOBT::P64;
           R1 = Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdP2U: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdOBU::P64;
           P64[Hp] = _sdOBW::P64;
           I64[Sp - 16] = block_cdP2P_info;
           R2 = _sdOBT::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdP2P() //  [R1]
         { info_tbl: [(cdP2P,
                       label: block_cdP2P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP2P: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Bitraversable.$fBitraversableConst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.671328151 UTC

[section ""data" . Data.Bitraversable.$fBitraversableK1_closure" {
     Data.Bitraversable.$fBitraversableK1_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctorK1_closure;
         const Data.Bifoldable.$fBifoldableK1_closure;
         const Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.673682946 UTC

[section ""data" . Data.Bitraversable.bimapM_closure" {
     Data.Bitraversable.bimapM_closure:
         const Data.Bitraversable.bimapM_info;
 },
 Data.Bitraversable.bimapM_entry() //  [R2, R3]
         { info_tbl: [(cdP3d,
                       label: Data.Bitraversable.bimapM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP3d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdP3e; else goto cdP3f;
       cdP3e: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.bimapM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdP3f: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call Data.Bitraversable.bitraverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.678232893 UTC

[section ""data" . Data.Bitraversable.bisequence_closure" {
     Data.Bitraversable.bisequence_closure:
         const Data.Bitraversable.bisequence_info;
 },
 Data.Bitraversable.bisequence_entry() //  [R2, R3]
         { info_tbl: [(cdP3p,
                       label: Data.Bitraversable.bisequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP3p: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdP3q; else goto cdP3r;
       cdP3q: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.bisequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdP3r: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 32;
           call Data.Bitraversable.bitraverse_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.682630154 UTC

[section ""data" . Data.Bitraversable.bisequenceA_closure" {
     Data.Bitraversable.bisequenceA_closure:
         const Data.Bitraversable.bisequenceA_info;
 },
 Data.Bitraversable.bisequenceA_entry() //  [R2, R3]
         { info_tbl: [(cdP3B,
                       label: Data.Bitraversable.bisequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP3B: // global
           R3 = R3;
           R2 = R2;
           call Data.Bitraversable.bisequence_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.687313191 UTC

[section ""data" . Data.Bitraversable.$dmbitraverse_closure" {
     Data.Bitraversable.$dmbitraverse_closure:
         const Data.Bitraversable.$dmbitraverse_info;
 },
 f1_sdOC7_entry() //  [R1]
         { info_tbl: [(cdP3Q,
                       label: f1_sdOC7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP3Q: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdP3R; else goto cdP3S;
       cdP3R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdP3S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 48;
           call Data.Bitraversable.bitraverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 g_sdOC8_entry() //  [R1]
         { info_tbl: [(cdP3Z,
                       label: g_sdOC8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP3Z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdP40; else goto cdP41;
       cdP40: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdP41: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdP3X_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Bitraversable.$p1Bitraversable_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdP3X() //  [R1]
         { info_tbl: [(cdP3X,
                       label: block_cdP3X_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP3X: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Data.Bifunctor.bimap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdOCc_entry() //  [R1, R2]
         { info_tbl: [(cdP4b,
                       label: sat_sdOCc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP4b: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdP4f; else goto cdP4e;
       cdP4f: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdP4e: // global
           _sdOC7::P64 = P64[R1 + 7];
           _sdOC8::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdOC8::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sdOC7::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$dmbitraverse_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdP4g,
                       label: Data.Bitraversable.$dmbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP4g: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdP4k; else goto cdP4j;
       cdP4k: // global
           HpAlloc = 96;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.$dmbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdP4j: // global
           I64[Hp - 88] = f1_sdOC7_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = g_sdOC8_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = sat_sdOCc_info;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.702953903 UTC

[section ""data" . Data.Bitraversable.bifor_closure" {
     Data.Bitraversable.bifor_closure:
         const Data.Bitraversable.bifor_info;
 },
 Data.Bitraversable.bifor_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdP4N,
                       label: Data.Bitraversable.bifor_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP4N: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdP4O; else goto cdP4P;
       cdP4O: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.bifor_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdP4P: // global
           R2 = R2;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R5;
           P64[Sp - 16] = R6;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Bitraversable.bitraverse_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.707714482 UTC

[section ""data" . Data.Bitraversable.biforM_closure" {
     Data.Bitraversable.biforM_closure:
         const Data.Bitraversable.biforM_info;
 },
 Data.Bitraversable.biforM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdP4Z,
                       label: Data.Bitraversable.biforM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP4Z: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bitraversable.bifor_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.712578745 UTC

[section ""data" . Data.Bitraversable.bimapAccumL_closure" {
     Data.Bitraversable.bimapAccumL_closure:
         const Data.Bitraversable.bimapAccumL_info;
         const 0;
 },
 sat_sdOCs_entry() //  [R1, R2, R3]
         { info_tbl: [(cdP5f,
                       label: sat_sdOCs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP5f: // global
           _sdOCr::P64 = R3;
           R3 = R2;
           R2 = _sdOCr::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdOCp_entry() //  [R1, R2, R3]
         { info_tbl: [(cdP5n,
                       label: sat_sdOCp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP5n: // global
           _sdOCo::P64 = R3;
           R3 = R2;
           R2 = _sdOCo::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.bimapAccumL_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdP5q,
                       label: Data.Bitraversable.bimapAccumL_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP5q: // global
           _sdOCm::P64 = R6;
           _sdOCl::P64 = R5;
           _sdOCk::P64 = R4;
           _sdOCj::P64 = R3;
           _sdOCi::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdP5r; else goto cdP5s;
       cdP5s: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdP5u; else goto cdP5t;
       cdP5u: // global
           HpAlloc = 32;
           goto cdP5r;
       cdP5r: // global
           R6 = _sdOCm::P64;
           R5 = _sdOCl::P64;
           R4 = _sdOCk::P64;
           R3 = _sdOCj::P64;
           R2 = _sdOCi::P64;
           R1 = Data.Bitraversable.bimapAccumL_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdP5t: // global
           I64[Hp - 24] = sat_sdOCs_info;
           P64[Hp - 16] = _sdOCk::P64;
           I64[Hp - 8] = sat_sdOCp_info;
           P64[Hp] = _sdOCj::P64;
           R2 = _sdOCi::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Functor.Utils.$fApplicativeStateL_closure;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = _sdOCm::P64;
           P64[Sp - 8] = _sdOCl::P64;
           Sp = Sp - 48;
           call Data.Bitraversable.bitraverse_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.727360371 UTC

[section ""data" . Data.Bitraversable.bimapAccumR_closure" {
     Data.Bitraversable.bimapAccumR_closure:
         const Data.Bitraversable.bimapAccumR_info;
         const 0;
 },
 sat_sdOCD_entry() //  [R1, R2, R3]
         { info_tbl: [(cdP5R,
                       label: sat_sdOCD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP5R: // global
           _sdOCC::P64 = R3;
           R3 = R2;
           R2 = _sdOCC::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdOCA_entry() //  [R1, R2, R3]
         { info_tbl: [(cdP5Z,
                       label: sat_sdOCA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP5Z: // global
           _sdOCz::P64 = R3;
           R3 = R2;
           R2 = _sdOCz::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.bimapAccumR_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdP62,
                       label: Data.Bitraversable.bimapAccumR_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP62: // global
           _sdOCx::P64 = R6;
           _sdOCw::P64 = R5;
           _sdOCv::P64 = R4;
           _sdOCu::P64 = R3;
           _sdOCt::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdP63; else goto cdP64;
       cdP64: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdP66; else goto cdP65;
       cdP66: // global
           HpAlloc = 32;
           goto cdP63;
       cdP63: // global
           R6 = _sdOCx::P64;
           R5 = _sdOCw::P64;
           R4 = _sdOCv::P64;
           R3 = _sdOCu::P64;
           R2 = _sdOCt::P64;
           R1 = Data.Bitraversable.bimapAccumR_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdP65: // global
           I64[Hp - 24] = sat_sdOCD_info;
           P64[Hp - 16] = _sdOCv::P64;
           I64[Hp - 8] = sat_sdOCA_info;
           P64[Hp] = _sdOCu::P64;
           R2 = _sdOCt::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Functor.Utils.$fApplicativeStateR_closure;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = _sdOCx::P64;
           P64[Sp - 8] = _sdOCw::P64;
           Sp = Sp - 48;
           call Data.Bitraversable.bitraverse_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.739753899 UTC

[section ""data" . bimapDefault1_rdOxw_closure" {
     bimapDefault1_rdOxw_closure:
         const bimapDefault1_rdOxw_info;
         const 0;
 },
 bimapDefault1_rdOxw_entry() //  [R2]
         { info_tbl: [(cdP6o,
                       label: bimapDefault1_rdOxw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP6o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdP6p; else goto cdP6q;
       cdP6p: // global
           R2 = R2;
           R1 = bimapDefault1_rdOxw_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdP6q: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Functor.Identity.$fApplicativeIdentity_closure;
           Sp = Sp - 16;
           call Data.Bitraversable.bitraverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.746813035 UTC

[section ""data" . Data.Bitraversable.bimapDefault_closure" {
     Data.Bitraversable.bimapDefault_closure:
         const Data.Bitraversable.bimapDefault_info;
         const 0;
 },
 Data.Bitraversable.bimapDefault_entry() //  [R2]
         { info_tbl: [(cdP6A,
                       label: Data.Bitraversable.bimapDefault_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP6A: // global
           R2 = R2;
           call bimapDefault1_rdOxw_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.751989744 UTC

[section ""data" . bifoldMapDefault1_rdOxx_closure" {
     bifoldMapDefault1_rdOxx_closure:
         const bifoldMapDefault1_rdOxx_info;
         const 0;
 },
 sat_sdOCH_entry() //  [R1]
         { info_tbl: [(cdP6P,
                       label: sat_sdOCH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP6P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdP6Q; else goto cdP6R;
       cdP6Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdP6R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fApplicativeConst_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 bifoldMapDefault1_rdOxx_entry() //  [R2, R3]
         { info_tbl: [(cdP6S,
                       label: bifoldMapDefault1_rdOxx_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP6S: // global
           _sdOCG::P64 = R3;
           _sdOCF::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdP6T; else goto cdP6U;
       cdP6U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdP6W; else goto cdP6V;
       cdP6W: // global
           HpAlloc = 24;
           goto cdP6T;
       cdP6T: // global
           R3 = _sdOCG::P64;
           R2 = _sdOCF::P64;
           R1 = bifoldMapDefault1_rdOxx_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdP6V: // global
           I64[Hp - 16] = sat_sdOCH_info;
           P64[Hp] = _sdOCG::P64;
           R2 = _sdOCF::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Bitraversable.bitraverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.760328897 UTC

[section ""data" . Data.Bitraversable.bifoldMapDefault_closure" {
     Data.Bitraversable.bifoldMapDefault_closure:
         const Data.Bitraversable.bifoldMapDefault_info;
         const 0;
 },
 Data.Bitraversable.bifoldMapDefault_entry() //  [R2, R3]
         { info_tbl: [(cdP7b,
                       label: Data.Bitraversable.bifoldMapDefault_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP7b: // global
           R3 = R3;
           R2 = R2;
           call bifoldMapDefault1_rdOxx_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.764184603 UTC

[section ""cstring" . Data.Bitraversable.$trModule4_bytes" {
     Data.Bitraversable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.766621561 UTC

[section ""data" . Data.Bitraversable.$trModule3_closure" {
     Data.Bitraversable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bitraversable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.769014062 UTC

[section ""cstring" . Data.Bitraversable.$trModule2_bytes" {
     Data.Bitraversable.$trModule2_bytes:
         I8[] [68,97,116,97,46,66,105,116,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.770812173 UTC

[section ""data" . Data.Bitraversable.$trModule1_closure" {
     Data.Bitraversable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bitraversable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.772604584 UTC

[section ""data" . Data.Bitraversable.$trModule_closure" {
     Data.Bitraversable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Bitraversable.$trModule3_closure+1;
         const Data.Bitraversable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.774633888 UTC

[section ""data" . $krep_rdOxy_closure" {
     $krep_rdOxy_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.77663651 UTC

[section ""data" . Data.Bitraversable.$tcBitraversable1_closure" {
     Data.Bitraversable.$tcBitraversable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep_rdOxy_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.778835316 UTC

[section ""cstring" . Data.Bitraversable.$tcBitraversable3_bytes" {
     Data.Bitraversable.$tcBitraversable3_bytes:
         I8[] [66,105,116,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.781199306 UTC

[section ""data" . Data.Bitraversable.$tcBitraversable2_closure" {
     Data.Bitraversable.$tcBitraversable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bitraversable.$tcBitraversable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.783031956 UTC

[section ""data" . Data.Bitraversable.$tcBitraversable_closure" {
     Data.Bitraversable.$tcBitraversable_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bitraversable.$trModule_closure+1;
         const Data.Bitraversable.$tcBitraversable2_closure+1;
         const Data.Bitraversable.$tcBitraversable1_closure+4;
         const 1654555613294690493;
         const 8030854156262073676;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.785321972 UTC

[section ""data" . Data.Bitraversable.C:Bitraversable_closure" {
     Data.Bitraversable.C:Bitraversable_closure:
         const Data.Bitraversable.C:Bitraversable_info;
 },
 Data.Bitraversable.C:Bitraversable_entry() //  [R2, R3, R4]
         { info_tbl: [(cdP7x,
                       label: Data.Bitraversable.C:Bitraversable_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP7x: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdP7B; else goto cdP7A;
       cdP7B: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.C:Bitraversable_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdP7A: // global
           I64[Hp - 24] = Data.Bitraversable.C:Bitraversable_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.790048449 UTC

[Data.Bitraversable.C:Bitraversable_con_entry() //  [R1]
         { info_tbl: [(cdP7H,
                       label: Data.Bitraversable.C:Bitraversable_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,116,114,97,118,101,114,115,97,98,108,101,46,67,58,66,105,116,114,97,118,101,114,115,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdP7H: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:03.793477355 UTC

[section ""relreadonly" . SdOK7_srt" {
     SdOK7_srt:
         const Data.Functor.Utils.$fApplicativeStateL_closure;
         const Data.Bitraversable.bimapAccumL_closure;
         const Data.Functor.Utils.$fApplicativeStateR_closure;
         const Data.Bitraversable.bimapAccumR_closure;
         const Data.Functor.Identity.$fApplicativeIdentity_closure;
         const bimapDefault1_rdOxw_closure;
         const Data.Functor.Const.$fApplicativeConst_closure;
         const bifoldMapDefault1_rdOxx_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.792688294 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:04.794416865 UTC

[section ""data" . Data.Bitraversable.$p1Bitraversable_closure" {
     Data.Bitraversable.$p1Bitraversable_closure:
         const Data.Bitraversable.$p1Bitraversable_info;
 },
 Data.Bitraversable.$p1Bitraversable_entry() //  [R2]
         { info_tbl: [(cdPd3,
                       label: Data.Bitraversable.$p1Bitraversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPd3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdPd4; else goto cdPd5;
       cdPd4: // global
           R2 = R2;
           R1 = Data.Bitraversable.$p1Bitraversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdPd5: // global
           I64[Sp - 8] = block_cdPd0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udPd9; else goto cdPd1;
       udPd9: // global
           call _cdPd0(R1) args: 0, res: 0, upd: 0;
       cdPd1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdPd0() //  [R1]
         { info_tbl: [(cdPd0,
                       label: block_cdPd0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPd0: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.801937561 UTC

[section ""data" . Data.Bitraversable.$p2Bitraversable_closure" {
     Data.Bitraversable.$p2Bitraversable_closure:
         const Data.Bitraversable.$p2Bitraversable_info;
 },
 Data.Bitraversable.$p2Bitraversable_entry() //  [R2]
         { info_tbl: [(cdPdt,
                       label: Data.Bitraversable.$p2Bitraversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPdt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdPdu; else goto cdPdv;
       cdPdu: // global
           R2 = R2;
           R1 = Data.Bitraversable.$p2Bitraversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdPdv: // global
           I64[Sp - 8] = block_cdPdq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udPdz; else goto cdPdr;
       udPdz: // global
           call _cdPdq(R1) args: 0, res: 0, upd: 0;
       cdPdr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdPdq() //  [R1]
         { info_tbl: [(cdPdq,
                       label: block_cdPdq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPdq: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.810571242 UTC

[section ""data" . Data.Bitraversable.bitraverse_closure" {
     Data.Bitraversable.bitraverse_closure:
         const Data.Bitraversable.bitraverse_info;
 },
 Data.Bitraversable.bitraverse_entry() //  [R2]
         { info_tbl: [(cdPdT,
                       label: Data.Bitraversable.bitraverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPdT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdPdU; else goto cdPdV;
       cdPdU: // global
           R2 = R2;
           R1 = Data.Bitraversable.bitraverse_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdPdV: // global
           I64[Sp - 8] = block_cdPdQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udPdZ; else goto cdPdR;
       udPdZ: // global
           call _cdPdQ(R1) args: 0, res: 0, upd: 0;
       cdPdR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdPdQ() //  [R1]
         { info_tbl: [(cdPdQ,
                       label: block_cdPdQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPdQ: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.819721586 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,)_$cbitraverse_info;
 },
 sat_sdP8g_entry() //  [R1]
         { info_tbl: [(cdPej,
                       label: sat_sdP8g_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPej: // global
           _sdP8g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPek; else goto cdPel;
       cdPel: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdPen; else goto cdPem;
       cdPen: // global
           HpAlloc = 24;
           goto cdPek;
       cdPek: // global
           R1 = _sdP8g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPem: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdP8g::P64;
           _sdP85::P64 = P64[_sdP8g::P64 + 16];
           _sdP86::P64 = P64[_sdP8g::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdP86::P64;
           R2 = Hp - 16;
           R1 = _sdP85::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdP8b_entry() //  [R1]
         { info_tbl: [(cdPet,
                       label: sat_sdP8b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPet: // global
           _sdP8b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPeu; else goto cdPev;
       cdPev: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdPex; else goto cdPew;
       cdPex: // global
           HpAlloc = 24;
           goto cdPeu;
       cdPeu: // global
           R1 = _sdP8b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPew: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdP8b::P64;
           _sdP84::P64 = P64[_sdP8b::P64 + 16];
           _sdP86::P64 = P64[_sdP8b::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdP86::P64;
           R2 = Hp - 16;
           R1 = _sdP84::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bitraversable.$fBitraversable(,)_$cbitraverse_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(cdPey,
                       label: Data.Bitraversable.$fBitraversable(,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPey: // global
           _sdP86::P64 = R5;
           _sdP85::P64 = R4;
           _sdP84::P64 = R3;
           _sdP83::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdPez; else goto cdPeA;
       cdPeA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdPeC; else goto cdPeB;
       cdPeC: // global
           HpAlloc = 64;
           goto cdPez;
       cdPez: // global
           R5 = _sdP86::P64;
           R4 = _sdP85::P64;
           R3 = _sdP84::P64;
           R2 = _sdP83::P64;
           R1 = Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPeB: // global
           I64[Hp - 56] = sat_sdP8g_info;
           P64[Hp - 40] = _sdP85::P64;
           P64[Hp - 32] = _sdP86::P64;
           I64[Hp - 24] = sat_sdP8b_info;
           P64[Hp - 8] = _sdP84::P64;
           P64[Hp] = _sdP86::P64;
           R2 = _sdP83::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Tuple.(,)_closure+2;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.834191418 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,)_closure" {
     Data.Bitraversable.$fBitraversable(,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,)_closure;
         const Data.Bifoldable.$fBifoldable(,)_closure;
         const Data.Bitraversable.$fBitraversable(,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.839698554 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_info;
 },
 sat_sdP8C_entry() //  [R1]
         { info_tbl: [(cdPfb,
                       label: sat_sdP8C_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPfb: // global
           _sdP8C::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPfc; else goto cdPfd;
       cdPfd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdPff; else goto cdPfe;
       cdPff: // global
           HpAlloc = 24;
           goto cdPfc;
       cdPfc: // global
           R1 = _sdP8C::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPfe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdP8C::P64;
           _sdP8j::P64 = P64[_sdP8C::P64 + 16];
           _sdP8k::P64 = P64[_sdP8C::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdP8k::P64;
           R2 = Hp - 16;
           R1 = _sdP8j::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdP8w_entry() //  [R1]
         { info_tbl: [(cdPfl,
                       label: sat_sdP8w_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPfl: // global
           _sdP8w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPfm; else goto cdPfn;
       cdPfn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdPfp; else goto cdPfo;
       cdPfp: // global
           HpAlloc = 24;
           goto cdPfm;
       cdPfm: // global
           R1 = _sdP8w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPfo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdP8w::P64;
           _sdP8i::P64 = P64[_sdP8w::P64 + 16];
           _sdP8k::P64 = P64[_sdP8w::P64 + 24];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sdP8k::P64;
           R2 = Hp - 16;
           R1 = _sdP8i::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdP8q_entry() //  [R1, R2, R3]
         { info_tbl: [(cdPfx,
                       label: sat_sdP8q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPfx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdPfB; else goto cdPfA;
       cdPfB: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPfA: // global
           _sdP8p::P64 = P64[R1 + 6];
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = _sdP8p::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_entry() //  [R2,
                                                                  R3, R4, R5]
         { info_tbl: [(cdPfC,
                       label: Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPfC: // global
           _sdP8k::P64 = R5;
           _sdP8j::P64 = R4;
           _sdP8i::P64 = R3;
           _sdP8h::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdPfD; else goto cdPfE;
       cdPfE: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdPfG; else goto cdPfF;
       cdPfG: // global
           HpAlloc = 104;
           goto cdPfD;
       cdPfD: // global
           R5 = _sdP8k::P64;
           R4 = _sdP8j::P64;
           R3 = _sdP8i::P64;
           R2 = _sdP8h::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPfF: // global
           I64[Hp - 96] = sat_sdP8C_info;
           P64[Hp - 80] = _sdP8j::P64;
           P64[Hp - 72] = _sdP8k::P64;
           I64[Hp - 64] = sat_sdP8w_info;
           P64[Hp - 48] = _sdP8i::P64;
           P64[Hp - 40] = _sdP8k::P64;
           I64[Hp - 32] = stg_sel_0_upd_info;
           P64[Hp - 16] = _sdP8k::P64;
           I64[Hp - 8] = sat_sdP8q_info;
           P64[Hp] = Hp - 32;
           R2 = _sdP8h::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = Hp - 64;
           P64[Sp - 8] = Hp - 96;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.856520976 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.860352917 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_info;
 },
 sat_sdP97_entry() //  [R1]
         { info_tbl: [(cdPgm,
                       label: sat_sdP97_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPgm: // global
           _sdP97::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPgn; else goto cdPgo;
       cdPgo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdPgq; else goto cdPgp;
       cdPgq: // global
           HpAlloc = 24;
           goto cdPgn;
       cdPgn: // global
           R1 = _sdP97::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPgp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdP97::P64;
           _sdP8F::P64 = P64[_sdP97::P64 + 16];
           _sdP8G::P64 = P64[_sdP97::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdP8G::P64;
           R2 = Hp - 16;
           R1 = _sdP8F::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdP90_entry() //  [R1]
         { info_tbl: [(cdPgw,
                       label: sat_sdP90_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPgw: // global
           _sdP90::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPgx; else goto cdPgy;
       cdPgy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdPgA; else goto cdPgz;
       cdPgA: // global
           HpAlloc = 24;
           goto cdPgx;
       cdPgx: // global
           R1 = _sdP90::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPgz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdP90::P64;
           _sdP8E::P64 = P64[_sdP90::P64 + 16];
           _sdP8G::P64 = P64[_sdP90::P64 + 24];
           I64[Hp - 16] = stg_sel_2_upd_info;
           P64[Hp] = _sdP8G::P64;
           R2 = Hp - 16;
           R1 = _sdP8E::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdP8T_entry() //  [R1, R2, R3]
         { info_tbl: [(cdPgJ,
                       label: sat_sdP8T_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPgJ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdPgN; else goto cdPgM;
       cdPgN: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPgM: // global
           _sdP8M::P64 = P64[R1 + 6];
           _sdP8S::P64 = P64[R1 + 14];
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = _sdP8M::P64;
           P64[Hp - 16] = _sdP8S::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdPgO,
                       label: Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPgO: // global
           _sdP8G::P64 = R5;
           _sdP8F::P64 = R4;
           _sdP8E::P64 = R3;
           _sdP8D::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdPgP; else goto cdPgQ;
       cdPgQ: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cdPgS; else goto cdPgR;
       cdPgS: // global
           HpAlloc = 136;
           goto cdPgP;
       cdPgP: // global
           R5 = _sdP8G::P64;
           R4 = _sdP8F::P64;
           R3 = _sdP8E::P64;
           R2 = _sdP8D::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPgR: // global
           I64[Hp - 128] = sat_sdP97_info;
           P64[Hp - 112] = _sdP8F::P64;
           P64[Hp - 104] = _sdP8G::P64;
           I64[Hp - 96] = sat_sdP90_info;
           P64[Hp - 80] = _sdP8E::P64;
           P64[Hp - 72] = _sdP8G::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdP8G::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdP8G::P64;
           I64[Hp - 16] = sat_sdP8T_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = _sdP8D::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 14;
           P64[Sp - 16] = Hp - 96;
           P64[Sp - 8] = Hp - 128;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.875111266 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.877906638 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_info;
 },
 sat_sdP9N_entry() //  [R1]
         { info_tbl: [(cdPhA,
                       label: sat_sdP9N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPhA: // global
           _sdP9N::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPhB; else goto cdPhC;
       cdPhC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdPhE; else goto cdPhD;
       cdPhE: // global
           HpAlloc = 24;
           goto cdPhB;
       cdPhB: // global
           R1 = _sdP9N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPhD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdP9N::P64;
           _sdP9a::P64 = P64[_sdP9N::P64 + 16];
           _sdP9b::P64 = P64[_sdP9N::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdP9b::P64;
           R2 = Hp - 16;
           R1 = _sdP9a::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdP9F_entry() //  [R1]
         { info_tbl: [(cdPhK,
                       label: sat_sdP9F_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPhK: // global
           _sdP9F::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPhL; else goto cdPhM;
       cdPhM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdPhO; else goto cdPhN;
       cdPhO: // global
           HpAlloc = 24;
           goto cdPhL;
       cdPhL: // global
           R1 = _sdP9F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPhN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdP9F::P64;
           _sdP99::P64 = P64[_sdP9F::P64 + 16];
           _sdP9b::P64 = P64[_sdP9F::P64 + 24];
           I64[Hp - 16] = stg_sel_3_upd_info;
           P64[Hp] = _sdP9b::P64;
           R2 = Hp - 16;
           R1 = _sdP99::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdP9x_entry() //  [R1, R2, R3]
         { info_tbl: [(cdPhY,
                       label: sat_sdP9x_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPhY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdPi2; else goto cdPi1;
       cdPi2: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPi1: // global
           _sdP9i::P64 = P64[R1 + 6];
           _sdP9p::P64 = P64[R1 + 14];
           _sdP9w::P64 = P64[R1 + 22];
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = _sdP9i::P64;
           P64[Hp - 24] = _sdP9p::P64;
           P64[Hp - 16] = _sdP9w::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cdPi3,
                       label: Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPi3: // global
           _sdP9b::P64 = R5;
           _sdP9a::P64 = R4;
           _sdP99::P64 = R3;
           _sdP98::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdPi4; else goto cdPi5;
       cdPi5: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cdPi7; else goto cdPi6;
       cdPi7: // global
           HpAlloc = 168;
           goto cdPi4;
       cdPi4: // global
           R5 = _sdP9b::P64;
           R4 = _sdP9a::P64;
           R3 = _sdP99::P64;
           R2 = _sdP98::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPi6: // global
           I64[Hp - 160] = sat_sdP9N_info;
           P64[Hp - 144] = _sdP9a::P64;
           P64[Hp - 136] = _sdP9b::P64;
           I64[Hp - 128] = sat_sdP9F_info;
           P64[Hp - 112] = _sdP99::P64;
           P64[Hp - 104] = _sdP9b::P64;
           I64[Hp - 96] = stg_sel_2_upd_info;
           P64[Hp - 80] = _sdP9b::P64;
           I64[Hp - 72] = stg_sel_1_upd_info;
           P64[Hp - 56] = _sdP9b::P64;
           I64[Hp - 48] = stg_sel_0_upd_info;
           P64[Hp - 32] = _sdP9b::P64;
           I64[Hp - 24] = sat_sdP9x_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R2 = _sdP98::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = Hp - 128;
           P64[Sp - 8] = Hp - 160;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.889569141 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.892321372 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_info;
 },
 sat_sdPaG_entry() //  [R1]
         { info_tbl: [(cdPiR,
                       label: sat_sdPaG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPiR: // global
           _sdPaG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPiS; else goto cdPiT;
       cdPiT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdPiV; else goto cdPiU;
       cdPiV: // global
           HpAlloc = 24;
           goto cdPiS;
       cdPiS: // global
           R1 = _sdPaG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPiU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdPaG::P64;
           _sdP9Q::P64 = P64[_sdPaG::P64 + 16];
           _sdP9R::P64 = P64[_sdPaG::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdP9R::P64;
           R2 = Hp - 16;
           R1 = _sdP9Q::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdPax_entry() //  [R1]
         { info_tbl: [(cdPj1,
                       label: sat_sdPax_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPj1: // global
           _sdPax::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPj2; else goto cdPj3;
       cdPj3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdPj5; else goto cdPj4;
       cdPj5: // global
           HpAlloc = 24;
           goto cdPj2;
       cdPj2: // global
           R1 = _sdPax::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPj4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdPax::P64;
           _sdP9P::P64 = P64[_sdPax::P64 + 16];
           _sdP9R::P64 = P64[_sdPax::P64 + 24];
           I64[Hp - 16] = stg_sel_4_upd_info;
           P64[Hp] = _sdP9R::P64;
           R2 = Hp - 16;
           R1 = _sdP9P::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdPao_entry() //  [R1, R2, R3]
         { info_tbl: [(cdPjg,
                       label: sat_sdPao_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPjg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdPjk; else goto cdPjj;
       cdPjk: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPjj: // global
           _sdP9Z::P64 = P64[R1 + 6];
           _sdPa7::P64 = P64[R1 + 14];
           _sdPaf::P64 = P64[R1 + 22];
           _sdPan::P64 = P64[R1 + 30];
           I64[Hp - 48] = (,,,,,)_con_info;
           P64[Hp - 40] = _sdP9Z::P64;
           P64[Hp - 32] = _sdPa7::P64;
           P64[Hp - 24] = _sdPaf::P64;
           P64[Hp - 16] = _sdPan::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_entry() //  [R2,
                                                                     R3, R4, R5]
         { info_tbl: [(cdPjl,
                       label: Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPjl: // global
           _sdP9R::P64 = R5;
           _sdP9Q::P64 = R4;
           _sdP9P::P64 = R3;
           _sdP9O::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdPjm; else goto cdPjn;
       cdPjn: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cdPjp; else goto cdPjo;
       cdPjp: // global
           HpAlloc = 200;
           goto cdPjm;
       cdPjm: // global
           R5 = _sdP9R::P64;
           R4 = _sdP9Q::P64;
           R3 = _sdP9P::P64;
           R2 = _sdP9O::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPjo: // global
           I64[Hp - 192] = sat_sdPaG_info;
           P64[Hp - 176] = _sdP9Q::P64;
           P64[Hp - 168] = _sdP9R::P64;
           I64[Hp - 160] = sat_sdPax_info;
           P64[Hp - 144] = _sdP9P::P64;
           P64[Hp - 136] = _sdP9R::P64;
           I64[Hp - 128] = stg_sel_3_upd_info;
           P64[Hp - 112] = _sdP9R::P64;
           I64[Hp - 104] = stg_sel_2_upd_info;
           P64[Hp - 88] = _sdP9R::P64;
           I64[Hp - 80] = stg_sel_1_upd_info;
           P64[Hp - 64] = _sdP9R::P64;
           I64[Hp - 56] = stg_sel_0_upd_info;
           P64[Hp - 40] = _sdP9R::P64;
           I64[Hp - 32] = sat_sdPao_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R2 = _sdP9O::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 30;
           P64[Sp - 16] = Hp - 160;
           P64[Sp - 8] = Hp - 192;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.904801251 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.907582997 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_info;
 },
 sat_sdPbO_entry() //  [R1]
         { info_tbl: [(cdPkb,
                       label: sat_sdPbO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPkb: // global
           _sdPbO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPkc; else goto cdPkd;
       cdPkd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdPkf; else goto cdPke;
       cdPkf: // global
           HpAlloc = 24;
           goto cdPkc;
       cdPkc: // global
           R1 = _sdPbO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPke: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdPbO::P64;
           _sdPaJ::P64 = P64[_sdPbO::P64 + 16];
           _sdPaK::P64 = P64[_sdPbO::P64 + 24];
           I64[Hp - 16] = stg_sel_6_upd_info;
           P64[Hp] = _sdPaK::P64;
           R2 = Hp - 16;
           R1 = _sdPaJ::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdPbE_entry() //  [R1]
         { info_tbl: [(cdPkl,
                       label: sat_sdPbE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPkl: // global
           _sdPbE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPkm; else goto cdPkn;
       cdPkn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdPkp; else goto cdPko;
       cdPkp: // global
           HpAlloc = 24;
           goto cdPkm;
       cdPkm: // global
           R1 = _sdPbE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPko: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdPbE::P64;
           _sdPaI::P64 = P64[_sdPbE::P64 + 16];
           _sdPaK::P64 = P64[_sdPbE::P64 + 24];
           I64[Hp - 16] = stg_sel_5_upd_info;
           P64[Hp] = _sdPaK::P64;
           R2 = Hp - 16;
           R1 = _sdPaI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdPbu_entry() //  [R1, R2, R3]
         { info_tbl: [(cdPkB,
                       label: sat_sdPbu_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPkB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdPkF; else goto cdPkE;
       cdPkF: // global
           HpAlloc = 64;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPkE: // global
           _sdPaT::P64 = P64[R1 + 6];
           _sdPb2::P64 = P64[R1 + 14];
           _sdPbb::P64 = P64[R1 + 22];
           _sdPbk::P64 = P64[R1 + 30];
           _sdPbt::P64 = P64[R1 + 38];
           I64[Hp - 56] = (,,,,,,)_con_info;
           P64[Hp - 48] = _sdPaT::P64;
           P64[Hp - 40] = _sdPb2::P64;
           P64[Hp - 32] = _sdPbb::P64;
           P64[Hp - 24] = _sdPbk::P64;
           P64[Hp - 16] = _sdPbt::P64;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_entry() //  [R2,
                                                                      R3, R4, R5]
         { info_tbl: [(cdPkG,
                       label: Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPkG: // global
           _sdPaK::P64 = R5;
           _sdPaJ::P64 = R4;
           _sdPaI::P64 = R3;
           _sdPaH::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdPkH; else goto cdPkI;
       cdPkI: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cdPkK; else goto cdPkJ;
       cdPkK: // global
           HpAlloc = 232;
           goto cdPkH;
       cdPkH: // global
           R5 = _sdPaK::P64;
           R4 = _sdPaJ::P64;
           R3 = _sdPaI::P64;
           R2 = _sdPaH::P64;
           R1 = Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPkJ: // global
           I64[Hp - 224] = sat_sdPbO_info;
           P64[Hp - 208] = _sdPaJ::P64;
           P64[Hp - 200] = _sdPaK::P64;
           I64[Hp - 192] = sat_sdPbE_info;
           P64[Hp - 176] = _sdPaI::P64;
           P64[Hp - 168] = _sdPaK::P64;
           I64[Hp - 160] = stg_sel_4_upd_info;
           P64[Hp - 144] = _sdPaK::P64;
           I64[Hp - 136] = stg_sel_3_upd_info;
           P64[Hp - 120] = _sdPaK::P64;
           I64[Hp - 112] = stg_sel_2_upd_info;
           P64[Hp - 96] = _sdPaK::P64;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdPaK::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdPaK::P64;
           I64[Hp - 40] = sat_sdPbu_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R2 = _sdPaH::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = Hp - 38;
           P64[Sp - 16] = Hp - 192;
           P64[Sp - 8] = Hp - 224;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.920502002 UTC

[section ""data" . Data.Bitraversable.$fBitraversable(,,,,,,)_closure" {
     Data.Bitraversable.$fBitraversable(,,,,,,)_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctor(,,,,,,)_closure;
         const Data.Bifoldable.$fBifoldable(,,,,,,)_closure;
         const Data.Bitraversable.$fBitraversable(,,,,,,)_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.923330878 UTC

[section ""data" . Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversableEither_$cbitraverse_info;
 },
 Data.Bitraversable.$fBitraversableEither_$cbitraverse_entry() //  [R2,
                                                                    R3, R4, R5]
         { info_tbl: [(cdPlA,
                       label: Data.Bitraversable.$fBitraversableEither_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPlA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdPlB; else goto cdPlC;
       cdPlB: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPlC: // global
           I64[Sp - 32] = block_cdPlt_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udPlZ; else goto cdPlu;
       udPlZ: // global
           call _cdPlt(R1) args: 0, res: 0, upd: 0;
       cdPlu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdPlt() //  [R1]
         { info_tbl: [(cdPlt,
                       label: block_cdPlt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPlt: // global
           _sdPbP::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdPlx; else goto cdPly;
       cdPlx: // global
           Hp = Hp + 32;
           _sdPbT::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdPlU; else goto cdPlI;
       cdPlI: // global
           _sdPbU::P64 = P64[_sdPbT::P64 + 7];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdPbU::P64;
           I64[Sp + 16] = block_cdPlG_info;
           R2 = _sdPbP::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
       cdPly: // global
           Hp = Hp + 32;
           _sdPbT::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdPlU; else goto cdPlT;
       cdPlU: // global
           HpAlloc = 32;
           R1 = _sdPbT::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdPlT: // global
           _sdPbX::P64 = P64[_sdPbT::P64 + 6];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sdPbX::P64;
           I64[Sp + 16] = block_cdPlR_info;
           R2 = _sdPbP::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdPlG() //  [R1]
         { info_tbl: [(cdPlG,
                       label: block_cdPlG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPlG: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Left_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cdPlR() //  [R1]
         { info_tbl: [(cdPlR,
                       label: block_cdPlR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPlR: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.933960462 UTC

[section ""data" . Data.Bitraversable.$fBitraversableEither_closure" {
     Data.Bitraversable.$fBitraversableEither_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctorEither_closure;
         const Data.Bifoldable.$fBifoldableEither_closure;
         const Data.Bitraversable.$fBitraversableEither_$cbitraverse_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.936043725 UTC

[section ""data" . Data.Bitraversable.$fBitraversableConst1_closure" {
     Data.Bitraversable.$fBitraversableConst1_closure:
         const Data.Bitraversable.$fBitraversableConst1_info;
 },
 Data.Bitraversable.$fBitraversableConst1_entry() //  [R2]
         { info_tbl: [(cdPmB,
                       label: Data.Bitraversable.$fBitraversableConst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPmB: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.94019793 UTC

[section ""data" . Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversableConst_$cbitraverse_info;
 },
 Data.Bitraversable.$fBitraversableConst_$cbitraverse_entry() //  [R2,
                                                                   R3, R4, R5]
         { info_tbl: [(cdPmP,
                       label: Data.Bitraversable.$fBitraversableConst_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPmP: // global
           _sdPc4::P64 = R5;
           _sdPc3::P64 = R4;
           _sdPc2::P64 = R3;
           _sdPc1::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdPmQ; else goto cdPmR;
       cdPmR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdPmT; else goto cdPmS;
       cdPmT: // global
           HpAlloc = 32;
           goto cdPmQ;
       cdPmQ: // global
           R5 = _sdPc4::P64;
           R4 = _sdPc3::P64;
           R3 = _sdPc2::P64;
           R2 = _sdPc1::P64;
           R1 = Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPmS: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdPc2::P64;
           P64[Hp] = _sdPc4::P64;
           I64[Sp - 16] = block_cdPmN_info;
           R2 = _sdPc1::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdPmN() //  [R1]
         { info_tbl: [(cdPmN,
                       label: block_cdPmN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPmN: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Bitraversable.$fBitraversableConst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.946048343 UTC

[section ""data" . Data.Bitraversable.$fBitraversableConst_closure" {
     Data.Bitraversable.$fBitraversableConst_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctorConst_closure;
         const Data.Bifoldable.$fBifoldableConst_closure;
         const Data.Bitraversable.$fBitraversableConst_$cbitraverse_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.948189208 UTC

[section ""data" . Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure" {
     Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure:
         const Data.Bitraversable.$fBitraversableK1_$cbitraverse_info;
 },
 Data.Bitraversable.$fBitraversableK1_$cbitraverse_entry() //  [R2,
                                                                R3, R4, R5]
         { info_tbl: [(cdPni,
                       label: Data.Bitraversable.$fBitraversableK1_$cbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPni: // global
           _sdPca::P64 = R5;
           _sdPc9::P64 = R4;
           _sdPc8::P64 = R3;
           _sdPc7::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdPnj; else goto cdPnk;
       cdPnk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdPnm; else goto cdPnl;
       cdPnm: // global
           HpAlloc = 32;
           goto cdPnj;
       cdPnj: // global
           R5 = _sdPca::P64;
           R4 = _sdPc9::P64;
           R3 = _sdPc8::P64;
           R2 = _sdPc7::P64;
           R1 = Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPnl: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdPc8::P64;
           P64[Hp] = _sdPca::P64;
           I64[Sp - 16] = block_cdPng_info;
           R2 = _sdPc7::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdPng() //  [R1]
         { info_tbl: [(cdPng,
                       label: block_cdPng_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPng: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Bitraversable.$fBitraversableConst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.957606786 UTC

[section ""data" . Data.Bitraversable.$fBitraversableK1_closure" {
     Data.Bitraversable.$fBitraversableK1_closure:
         const Data.Bitraversable.C:Bitraversable_con_info;
         const Data.Bifunctor.$fBifunctorK1_closure;
         const Data.Bifoldable.$fBifoldableK1_closure;
         const Data.Bitraversable.$fBitraversableK1_$cbitraverse_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.960177647 UTC

[section ""data" . Data.Bitraversable.bimapM_closure" {
     Data.Bitraversable.bimapM_closure:
         const Data.Bitraversable.bimapM_info;
 },
 Data.Bitraversable.bimapM_entry() //  [R2, R3]
         { info_tbl: [(cdPnI,
                       label: Data.Bitraversable.bimapM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPnI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdPnJ; else goto cdPnK;
       cdPnJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.bimapM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPnK: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call Data.Bitraversable.bitraverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.965005757 UTC

[section ""data" . Data.Bitraversable.bisequence_closure" {
     Data.Bitraversable.bisequence_closure:
         const Data.Bitraversable.bisequence_info;
 },
 Data.Bitraversable.bisequence_entry() //  [R2, R3]
         { info_tbl: [(cdPnV,
                       label: Data.Bitraversable.bisequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPnV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdPnW; else goto cdPnX;
       cdPnW: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.bisequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPnX: // global
           R2 = R2;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = GHC.Base.id_closure+1;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 32;
           call Data.Bitraversable.bitraverse_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.969170904 UTC

[section ""data" . Data.Bitraversable.bisequenceA_closure" {
     Data.Bitraversable.bisequenceA_closure:
         const Data.Bitraversable.bisequenceA_info;
 },
 Data.Bitraversable.bisequenceA_entry() //  [R2, R3]
         { info_tbl: [(cdPoc,
                       label: Data.Bitraversable.bisequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPoc: // global
           R3 = R3;
           R2 = R2;
           call Data.Bitraversable.bisequence_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.974085878 UTC

[section ""data" . Data.Bitraversable.$dmbitraverse_closure" {
     Data.Bitraversable.$dmbitraverse_closure:
         const Data.Bitraversable.$dmbitraverse_info;
 },
 f1_sdPcl_entry() //  [R1]
         { info_tbl: [(cdPor,
                       label: f1_sdPcl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPor: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cdPos; else goto cdPot;
       cdPos: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPot: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = GHC.Base.id_closure+1;
           Sp = Sp - 48;
           call Data.Bitraversable.bitraverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 g_sdPcm_entry() //  [R1]
         { info_tbl: [(cdPoA,
                       label: g_sdPcm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPoA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdPoB; else goto cdPoC;
       cdPoB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPoC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdPoy_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Bitraversable.$p1Bitraversable_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdPoy() //  [R1]
         { info_tbl: [(cdPoy,
                       label: block_cdPoy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPoy: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call Data.Bifunctor.bimap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdPcq_entry() //  [R1, R2]
         { info_tbl: [(cdPoM,
                       label: sat_sdPcq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPoM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdPoQ; else goto cdPoP;
       cdPoQ: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdPoP: // global
           _sdPcl::P64 = P64[R1 + 7];
           _sdPcm::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdPcm::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sdPcl::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.$dmbitraverse_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdPoR,
                       label: Data.Bitraversable.$dmbitraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPoR: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdPoV; else goto cdPoU;
       cdPoV: // global
           HpAlloc = 96;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.$dmbitraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPoU: // global
           I64[Hp - 88] = f1_sdPcl_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = g_sdPcm_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = sat_sdPcq_info;
           P64[Hp - 8] = Hp - 88;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.988769523 UTC

[section ""data" . Data.Bitraversable.bifor_closure" {
     Data.Bitraversable.bifor_closure:
         const Data.Bitraversable.bifor_info;
 },
 Data.Bitraversable.bifor_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdPpB,
                       label: Data.Bitraversable.bifor_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPpB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdPpC; else goto cdPpD;
       cdPpC: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.bifor_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPpD: // global
           R2 = R2;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R5;
           P64[Sp - 16] = R6;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Bitraversable.bitraverse_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.993049927 UTC

[section ""data" . Data.Bitraversable.biforM_closure" {
     Data.Bitraversable.biforM_closure:
         const Data.Bitraversable.biforM_info;
 },
 Data.Bitraversable.biforM_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdPpO,
                       label: Data.Bitraversable.biforM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPpO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Bitraversable.bifor_entry(R6,
                                               R5,
                                               R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:04.997391419 UTC

[section ""data" . Data.Bitraversable.bimapAccumL_closure" {
     Data.Bitraversable.bimapAccumL_closure:
         const Data.Bitraversable.bimapAccumL_info;
         const 0;
 },
 sat_sdPcG_entry() //  [R1, R2, R3]
         { info_tbl: [(cdPq4,
                       label: sat_sdPcG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPq4: // global
           _sdPcF::P64 = R3;
           R3 = R2;
           R2 = _sdPcF::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdPcD_entry() //  [R1, R2, R3]
         { info_tbl: [(cdPqc,
                       label: sat_sdPcD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPqc: // global
           _sdPcC::P64 = R3;
           R3 = R2;
           R2 = _sdPcC::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.bimapAccumL_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdPqf,
                       label: Data.Bitraversable.bimapAccumL_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPqf: // global
           _sdPcA::P64 = R6;
           _sdPcz::P64 = R5;
           _sdPcy::P64 = R4;
           _sdPcx::P64 = R3;
           _sdPcw::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdPqg; else goto cdPqh;
       cdPqh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdPqj; else goto cdPqi;
       cdPqj: // global
           HpAlloc = 32;
           goto cdPqg;
       cdPqg: // global
           R6 = _sdPcA::P64;
           R5 = _sdPcz::P64;
           R4 = _sdPcy::P64;
           R3 = _sdPcx::P64;
           R2 = _sdPcw::P64;
           R1 = Data.Bitraversable.bimapAccumL_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPqi: // global
           I64[Hp - 24] = sat_sdPcG_info;
           P64[Hp - 16] = _sdPcy::P64;
           I64[Hp - 8] = sat_sdPcD_info;
           P64[Hp] = _sdPcx::P64;
           R2 = _sdPcw::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Functor.Utils.$fApplicativeStateL_closure;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = _sdPcA::P64;
           P64[Sp - 8] = _sdPcz::P64;
           Sp = Sp - 48;
           call Data.Bitraversable.bitraverse_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.005224712 UTC

[section ""data" . Data.Bitraversable.bimapAccumR_closure" {
     Data.Bitraversable.bimapAccumR_closure:
         const Data.Bitraversable.bimapAccumR_info;
         const 0;
 },
 sat_sdPcR_entry() //  [R1, R2, R3]
         { info_tbl: [(cdPqL,
                       label: sat_sdPcR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPqL: // global
           _sdPcQ::P64 = R3;
           R3 = R2;
           R2 = _sdPcQ::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdPcO_entry() //  [R1, R2, R3]
         { info_tbl: [(cdPqT,
                       label: sat_sdPcO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPqT: // global
           _sdPcN::P64 = R3;
           R3 = R2;
           R2 = _sdPcN::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Bitraversable.bimapAccumR_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cdPqW,
                       label: Data.Bitraversable.bimapAccumR_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPqW: // global
           _sdPcL::P64 = R6;
           _sdPcK::P64 = R5;
           _sdPcJ::P64 = R4;
           _sdPcI::P64 = R3;
           _sdPcH::P64 = R2;
           if ((Sp + -48) < SpLim) (likely: False) goto cdPqX; else goto cdPqY;
       cdPqY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdPr0; else goto cdPqZ;
       cdPr0: // global
           HpAlloc = 32;
           goto cdPqX;
       cdPqX: // global
           R6 = _sdPcL::P64;
           R5 = _sdPcK::P64;
           R4 = _sdPcJ::P64;
           R3 = _sdPcI::P64;
           R2 = _sdPcH::P64;
           R1 = Data.Bitraversable.bimapAccumR_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPqZ: // global
           I64[Hp - 24] = sat_sdPcR_info;
           P64[Hp - 16] = _sdPcJ::P64;
           I64[Hp - 8] = sat_sdPcO_info;
           P64[Hp] = _sdPcI::P64;
           R2 = _sdPcH::P64;
           I64[Sp - 48] = stg_ap_ppppp_info;
           P64[Sp - 40] = Data.Functor.Utils.$fApplicativeStateR_closure;
           P64[Sp - 32] = Hp - 6;
           P64[Sp - 24] = Hp - 22;
           P64[Sp - 16] = _sdPcL::P64;
           P64[Sp - 8] = _sdPcK::P64;
           Sp = Sp - 48;
           call Data.Bitraversable.bitraverse_entry(R2) args: 56, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.012676649 UTC

[section ""data" . bimapDefault1_rdOxw_closure" {
     bimapDefault1_rdOxw_closure:
         const bimapDefault1_rdOxw_info;
         const 0;
 },
 bimapDefault1_rdOxw_entry() //  [R2]
         { info_tbl: [(cdPrm,
                       label: bimapDefault1_rdOxw_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPrm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdPrn; else goto cdPro;
       cdPrn: // global
           R2 = R2;
           R1 = bimapDefault1_rdOxw_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdPro: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Functor.Identity.$fApplicativeIdentity_closure;
           Sp = Sp - 16;
           call Data.Bitraversable.bitraverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.016387382 UTC

[section ""data" . Data.Bitraversable.bimapDefault_closure" {
     Data.Bitraversable.bimapDefault_closure:
         const Data.Bitraversable.bimapDefault_info;
         const 0;
 },
 Data.Bitraversable.bimapDefault_entry() //  [R2]
         { info_tbl: [(cdPrA,
                       label: Data.Bitraversable.bimapDefault_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPrA: // global
           R2 = R2;
           call bimapDefault1_rdOxw_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.020711581 UTC

[section ""data" . bifoldMapDefault1_rdOxx_closure" {
     bifoldMapDefault1_rdOxx_closure:
         const bifoldMapDefault1_rdOxx_info;
         const 0;
 },
 sat_sdPcV_entry() //  [R1]
         { info_tbl: [(cdPrP,
                       label: sat_sdPcV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPrP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdPrQ; else goto cdPrR;
       cdPrQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdPrR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fApplicativeConst_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 bifoldMapDefault1_rdOxx_entry() //  [R2, R3]
         { info_tbl: [(cdPrS,
                       label: bifoldMapDefault1_rdOxx_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPrS: // global
           _sdPcU::P64 = R3;
           _sdPcT::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPrT; else goto cdPrU;
       cdPrU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdPrW; else goto cdPrV;
       cdPrW: // global
           HpAlloc = 24;
           goto cdPrT;
       cdPrT: // global
           R3 = _sdPcU::P64;
           R2 = _sdPcT::P64;
           R1 = bifoldMapDefault1_rdOxx_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPrV: // global
           I64[Hp - 16] = sat_sdPcV_info;
           P64[Hp] = _sdPcU::P64;
           R2 = _sdPcT::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Bitraversable.bitraverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.026463485 UTC

[section ""data" . Data.Bitraversable.bifoldMapDefault_closure" {
     Data.Bitraversable.bifoldMapDefault_closure:
         const Data.Bitraversable.bifoldMapDefault_info;
         const 0;
 },
 Data.Bitraversable.bifoldMapDefault_entry() //  [R2, R3]
         { info_tbl: [(cdPse,
                       label: Data.Bitraversable.bifoldMapDefault_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPse: // global
           R3 = R3;
           R2 = R2;
           call bifoldMapDefault1_rdOxx_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.029618073 UTC

[section ""cstring" . Data.Bitraversable.$trModule4_bytes" {
     Data.Bitraversable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.031259168 UTC

[section ""data" . Data.Bitraversable.$trModule3_closure" {
     Data.Bitraversable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bitraversable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.032901115 UTC

[section ""cstring" . Data.Bitraversable.$trModule2_bytes" {
     Data.Bitraversable.$trModule2_bytes:
         I8[] [68,97,116,97,46,66,105,116,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.03506714 UTC

[section ""data" . Data.Bitraversable.$trModule1_closure" {
     Data.Bitraversable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bitraversable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.03669256 UTC

[section ""data" . Data.Bitraversable.$trModule_closure" {
     Data.Bitraversable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Bitraversable.$trModule3_closure+1;
         const Data.Bitraversable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.038424747 UTC

[section ""data" . $krep_rdOxy_closure" {
     $krep_rdOxy_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.040126815 UTC

[section ""data" . Data.Bitraversable.$tcBitraversable1_closure" {
     Data.Bitraversable.$tcBitraversable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*->*->*_closure;
         const $krep_rdOxy_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.041834503 UTC

[section ""cstring" . Data.Bitraversable.$tcBitraversable3_bytes" {
     Data.Bitraversable.$tcBitraversable3_bytes:
         I8[] [66,105,116,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.043435991 UTC

[section ""data" . Data.Bitraversable.$tcBitraversable2_closure" {
     Data.Bitraversable.$tcBitraversable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bitraversable.$tcBitraversable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.04568992 UTC

[section ""data" . Data.Bitraversable.$tcBitraversable_closure" {
     Data.Bitraversable.$tcBitraversable_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bitraversable.$trModule_closure+1;
         const Data.Bitraversable.$tcBitraversable2_closure+1;
         const Data.Bitraversable.$tcBitraversable1_closure+4;
         const 1654555613294690493;
         const 8030854156262073676;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.047838567 UTC

[section ""data" . Data.Bitraversable.C:Bitraversable_closure" {
     Data.Bitraversable.C:Bitraversable_closure:
         const Data.Bitraversable.C:Bitraversable_info;
 },
 Data.Bitraversable.C:Bitraversable_entry() //  [R2, R3, R4]
         { info_tbl: [(cdPsA,
                       label: Data.Bitraversable.C:Bitraversable_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPsA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdPsE; else goto cdPsD;
       cdPsE: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bitraversable.C:Bitraversable_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPsD: // global
           I64[Hp - 24] = Data.Bitraversable.C:Bitraversable_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.051972645 UTC

[Data.Bitraversable.C:Bitraversable_con_entry() //  [R1]
         { info_tbl: [(cdPsL,
                       label: Data.Bitraversable.C:Bitraversable_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,116,114,97,118,101,114,115,97,98,108,101,46,67,58,66,105,116,114,97,118,101,114,115,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdPsL: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.055066039 UTC

[section ""relreadonly" . SdPqk_srt" {
     SdPqk_srt:
         const Data.Functor.Utils.$fApplicativeStateL_closure;
         const Data.Bitraversable.bimapAccumL_closure;
         const Data.Functor.Utils.$fApplicativeStateR_closure;
         const Data.Bitraversable.bimapAccumR_closure;
         const Data.Functor.Identity.$fApplicativeIdentity_closure;
         const bimapDefault1_rdOxw_closure;
         const Data.Functor.Const.$fApplicativeConst_closure;
         const bifoldMapDefault1_rdOxx_closure;
 }]

