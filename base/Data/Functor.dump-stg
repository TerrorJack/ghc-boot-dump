
==================== Pre unarise: ====================
2018-03-16 15:56:19.308671555 UTC

Data.Functor.<$>
  :: forall (f :: * -> *) a b.
     GHC.Base.Functor f =>
     (a -> b) -> f a -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xAG] GHC.Base.fmap $dFunctor_s1xAG;

Data.Functor.<&>
  :: forall (f :: * -> *) a b.
     GHC.Base.Functor f =>
     f a -> (a -> b) -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xAH as_s1xAI f1_s1xAJ]
        GHC.Base.fmap $dFunctor_s1xAH f1_s1xAJ as_s1xAI;

Data.Functor.$>
  :: forall (f :: * -> *) a b. GHC.Base.Functor f => f a -> b -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xAK eta_s1xAL eta1_s1xAM]
        GHC.Base.<$ $dFunctor_s1xAK eta1_s1xAM eta_s1xAL;

Data.Functor.void
  :: forall (f :: * -> *) a. GHC.Base.Functor f => f a -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xAN x_s1xAO]
        GHC.Base.<$ $dFunctor_s1xAN GHC.Tuple.() x_s1xAO;

Data.Functor.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.$trModule4];

Data.Functor.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor"#;

Data.Functor.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.$trModule2];

Data.Functor.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.$trModule3
                                     Data.Functor.$trModule1];


==================== STG syntax: ====================
2018-03-16 15:56:19.310284853 UTC

Data.Functor.<$>
  :: forall (f :: * -> *) a b.
     GHC.Base.Functor f =>
     (a -> b) -> f a -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xAG] GHC.Base.fmap $dFunctor_s1xAG;

Data.Functor.<&>
  :: forall (f :: * -> *) a b.
     GHC.Base.Functor f =>
     f a -> (a -> b) -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xAH as_s1xAI f1_s1xAJ]
        GHC.Base.fmap $dFunctor_s1xAH f1_s1xAJ as_s1xAI;

Data.Functor.$>
  :: forall (f :: * -> *) a b. GHC.Base.Functor f => f a -> b -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xAK eta_s1xAL eta1_s1xAM]
        GHC.Base.<$ $dFunctor_s1xAK eta1_s1xAM eta_s1xAL;

Data.Functor.void
  :: forall (f :: * -> *) a. GHC.Base.Functor f => f a -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xAN x_s1xAO]
        GHC.Base.<$ $dFunctor_s1xAN GHC.Tuple.() x_s1xAO;

Data.Functor.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.$trModule4];

Data.Functor.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor"#;

Data.Functor.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.$trModule2];

Data.Functor.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.$trModule3
                                     Data.Functor.$trModule1];


==================== Pre unarise: ====================
2018-03-16 15:56:19.392393919 UTC

Data.Functor.<$>
  :: forall (f :: * -> *) a b.
     GHC.Base.Functor f =>
     (a -> b) -> f a -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xCB] GHC.Base.fmap $dFunctor_s1xCB;

Data.Functor.<&>
  :: forall (f :: * -> *) a b.
     GHC.Base.Functor f =>
     f a -> (a -> b) -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xCC as_s1xCD f1_s1xCE]
        GHC.Base.fmap $dFunctor_s1xCC f1_s1xCE as_s1xCD;

Data.Functor.$>
  :: forall (f :: * -> *) a b. GHC.Base.Functor f => f a -> b -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xCF eta_s1xCG eta1_s1xCH]
        GHC.Base.<$ $dFunctor_s1xCF eta1_s1xCH eta_s1xCG;

Data.Functor.void
  :: forall (f :: * -> *) a. GHC.Base.Functor f => f a -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xCI x_s1xCJ]
        GHC.Base.<$ $dFunctor_s1xCI GHC.Tuple.() x_s1xCJ;

Data.Functor.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.$trModule4];

Data.Functor.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor"#;

Data.Functor.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.$trModule2];

Data.Functor.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.$trModule3
                                     Data.Functor.$trModule1];


==================== STG syntax: ====================
2018-03-16 15:56:19.394888985 UTC

Data.Functor.<$>
  :: forall (f :: * -> *) a b.
     GHC.Base.Functor f =>
     (a -> b) -> f a -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xCB] GHC.Base.fmap $dFunctor_s1xCB;

Data.Functor.<&>
  :: forall (f :: * -> *) a b.
     GHC.Base.Functor f =>
     f a -> (a -> b) -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xCC as_s1xCD f1_s1xCE]
        GHC.Base.fmap $dFunctor_s1xCC f1_s1xCE as_s1xCD;

Data.Functor.$>
  :: forall (f :: * -> *) a b. GHC.Base.Functor f => f a -> b -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xCF eta_s1xCG eta1_s1xCH]
        GHC.Base.<$ $dFunctor_s1xCF eta1_s1xCH eta_s1xCG;

Data.Functor.void
  :: forall (f :: * -> *) a. GHC.Base.Functor f => f a -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))),1*U(A,1*C1(C1(U)))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s1xCI x_s1xCJ]
        GHC.Base.<$ $dFunctor_s1xCI GHC.Tuple.() x_s1xCJ;

Data.Functor.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Functor.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.$trModule4];

Data.Functor.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Functor"#;

Data.Functor.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Functor.$trModule2];

Data.Functor.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Functor.$trModule3
                                     Data.Functor.$trModule1];

