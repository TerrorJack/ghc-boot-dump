
==================== Pre unarise: ====================
2018-03-16 16:11:18.298453059 UTC

Data.Semigroup.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Min a
     -> [Data.Semigroup.Min a] -> Data.Semigroup.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfC7j ww_sfC7k ww1_sfC7l]
        let {
          go_sfC7m [Occ=LoopBreaker]
            :: Data.Semigroup.Min a_sfBoZ
               -> [Data.Semigroup.Min a_sfBoZ] -> Data.Semigroup.Min a_sfBoZ
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfC7j go_sfC7m] \r [b_sfC7n ds1_sfC7o]
                  case ds1_sfC7o of {
                    [] -> b_sfC7n;
                    : c_sfC7q [Occ=Once] cs_sfC7r [Occ=Once] ->
                        let {
                          sat_sfC7s [Occ=Once] :: a_sfBoZ
                          [LclId] =
                              [go_sfC7m c_sfC7q cs_sfC7r] \u [] go_sfC7m c_sfC7q cs_sfC7r;
                        } in  GHC.Classes.min w_sfC7j b_sfC7n sat_sfC7s;
                  };
        } in  go_sfC7m ww_sfC7k ww1_sfC7l;

Data.Semigroup.$fSemigroupMin_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Semigroup.Min a) -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfC7t w1_sfC7u]
        case w1_sfC7u of {
          GHC.Base.:| ww1_sfC7w [Occ=Once] ww2_sfC7x [Occ=Once] ->
              Data.Semigroup.$w$csconcat1 w_sfC7t ww1_sfC7w ww2_sfC7x;
        };

lvl_rfC66
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfC7y eta_sfC7z eta1_sfC7A]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfC7y eta_sfC7z eta1_sfC7A;

Data.Semigroup.$fSemigroupMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,A,A,U)>m] =
    [] \r [$dOrd_sfC7B]
        let {
          sat_sfC7D [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Min a_afzf5)
               -> Data.Semigroup.Min a_afzf5
          [LclId] =
              [$dOrd_sfC7B] \r [eta_B1]
                  Data.Semigroup.$fSemigroupMin_$csconcat $dOrd_sfC7B eta_B1; } in
        let {
          sat_sfC7C [Occ=Once]
            :: Data.Semigroup.Min a_afzf5
               -> Data.Semigroup.Min a_afzf5 -> Data.Semigroup.Min a_afzf5
          [LclId] =
              [$dOrd_sfC7B] \u [] GHC.Classes.min $dOrd_sfC7B;
        } in  GHC.Base.C:Semigroup [sat_sfC7C sat_sfC7D lvl_rfC66];

Data.Semigroup.$fFunctorMin2
  :: forall a b. (a -> b) -> Data.Semigroup.Min a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfC7E ds_sfC7F] f_sfC7E ds_sfC7F;

Data.Semigroup.$fFunctorMin1
  :: forall b a. a -> Data.Semigroup.Min b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sfC7G ds_sfC7H] x_sfC7G;

Data.Semigroup.$fFunctorMin [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorMin2
                                       Data.Semigroup.$fFunctorMin1];

Data.Semigroup.$fFoldableMin_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Min a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfC7I f_sfC7J ds_sfC7K] f_sfC7J ds_sfC7K;

Data.Semigroup.$fFoldableMin4
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.Min m -> Data.Semigroup.Min m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfC7L ds_sfC7M] ds_sfC7M;

Data.Semigroup.$fFoldableMin1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfC7N eta_sfC7O] eta_sfC7O;

Data.Semigroup.$fFoldableMin2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfC7P x_sfC7Q] x_sfC7Q;

Data.Semigroup.$fFoldableMin_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Min a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfC7R eta_sfC7S]
        let {
          f_sfC7T [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afzdA -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfC7R eta_sfC7S] \u []
                  GHC.Classes.== $dEq_sfC7R eta_sfC7S; } in
        let {
          sat_sfC7V [Occ=OnceT[0]]
            :: Data.Semigroup.Min a_afzdA -> GHC.Types.Bool
          [LclId] =
              [f_sfC7T] \r [ds_sfC7U] f_sfC7T ds_sfC7U;
        } in  sat_sfC7V;

Data.Semigroup.$fFoldableMin_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Min a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfC7W z_sfC7X t1_sfC7Y] f_sfC7W z_sfC7X t1_sfC7Y;

Data.Semigroup.$fFoldableMin3
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfC7Z xs_sfC80] xs_sfC80;

Data.Semigroup.$fFoldableMin_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Min a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfC81 z0_sfC82 xs_sfC83] f_sfC81 xs_sfC83 z0_sfC82;

Data.Semigroup.$fFoldableFirst3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Semigroup.$fFoldableMin_$clength
  :: forall a. Data.Semigroup.Min a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfC84] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableMin_$cnull
  :: forall a. Data.Semigroup.Min a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfC85] GHC.Types.False [];

Data.Semigroup.$fFoldableMin_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Min a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfC86] : [eta_sfC86 GHC.Types.[]];

Data.Semigroup.$fFoldableMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Min
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableMin4
                                             Data.Semigroup.$fFoldableMin_$cfoldMap
                                             Data.Semigroup.$fFoldableMin_$cfoldr'
                                             Data.Semigroup.$fFoldableMin_$cfoldr'
                                             Data.Semigroup.$fFoldableMin_$cfoldl
                                             Data.Semigroup.$fFoldableMin_$cfoldl
                                             Data.Semigroup.$fFoldableMin3
                                             Data.Semigroup.$fFoldableMin3
                                             Data.Semigroup.$fFoldableMin_$ctoList
                                             Data.Semigroup.$fFoldableMin_$cnull
                                             Data.Semigroup.$fFoldableMin_$clength
                                             Data.Semigroup.$fFoldableMin_$celem
                                             Data.Semigroup.$fFoldableMin2
                                             Data.Semigroup.$fFoldableMin2
                                             Data.Semigroup.$fFoldableMin1
                                             Data.Semigroup.$fFoldableMin1];

Data.Semigroup.$fApplicativeFirst3 :: forall b. b -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfC87] v_sfC87;

Data.Semigroup.$fTraversableMin_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.Min a -> f (Data.Semigroup.Min b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfC88 eta_sfC89 eta1_sfC8a]
        let {
          sat_sfC8c [Occ=Once] :: f_afzb8 b_afzba
          [LclId] =
              [eta_sfC89 eta1_sfC8a] \u [] eta_sfC89 eta1_sfC8a;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfC88 of sat_sfC8b {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfC8b Data.Semigroup.$fApplicativeFirst3 sat_sfC8c;
          };

Data.Semigroup.$fTraversableMin_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Min (f a) -> f (Data.Semigroup.Min a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfC8d eta_sfC8e]
        case GHC.Base.$p1Applicative $dApplicative_sfC8d of sat_sfC8f {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfC8f Data.Semigroup.$fApplicativeFirst3 eta_sfC8e;
        };

Data.Semigroup.$fTraversableMin_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.Min a -> m (Data.Semigroup.Min b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfC8g eta_sfC8h eta1_sfC8i]
        let {
          sat_sfC8l [Occ=Once] :: m_afzby b_afzbA
          [LclId] =
              [eta_sfC8h eta1_sfC8i] \u [] eta_sfC8h eta1_sfC8i;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfC8g of sat_sfC8j {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfC8j of sat_sfC8k {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfC8k Data.Semigroup.$fApplicativeFirst3 sat_sfC8l;
                };
          };

Data.Semigroup.$fTraversableMin_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Min (m a) -> m (Data.Semigroup.Min a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfC8m eta_sfC8n]
        case GHC.Base.$p1Monad $dMonad_sfC8m of sat_sfC8o {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfC8o of sat_sfC8p {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfC8p Data.Semigroup.$fApplicativeFirst3 eta_sfC8n;
              };
        };

Data.Semigroup.$fTraversableMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorMin
                                                   Data.Semigroup.$fFoldableMin
                                                   Data.Semigroup.$fTraversableMin_$ctraverse
                                                   Data.Semigroup.$fTraversableMin_$csequenceA
                                                   Data.Semigroup.$fTraversableMin_$cmapM
                                                   Data.Semigroup.$fTraversableMin_$csequence];

Data.Semigroup.$fApplicativeMin_$c<*
  :: forall a b.
     Data.Semigroup.Min a
     -> Data.Semigroup.Min b -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfC8q ds_sfC8r] a1_sfC8q;

Data.Semigroup.$fApplicativeMin_$c*>
  :: forall a b.
     Data.Semigroup.Min a
     -> Data.Semigroup.Min b -> Data.Semigroup.Min b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfC8s a1_sfC8t] a1_sfC8t;

Data.Semigroup.$fApplicativeFirst1
  :: forall a b c. (a -> b -> c) -> a -> b -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfC8u] v_sfC8u;

Data.Semigroup.$fApplicativeMin1
  :: forall a b.
     Data.Semigroup.Min (a -> b) -> Data.Semigroup.Min (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfC8v] v_sfC8v;

Data.Semigroup.$fApplicativeMin [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorMin
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeMin1
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeMin_$c*>
                                           Data.Semigroup.$fApplicativeMin_$c<*];

Data.Semigroup.$fMonadMin_$c>>=
  :: forall a b.
     Data.Semigroup.Min a
     -> (a -> Data.Semigroup.Min b) -> Data.Semigroup.Min b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfC8w f_sfC8x] f_sfC8x ds_sfC8w;

lvl1_rfC67 :: forall a. [GHC.Types.Char] -> Data.Semigroup.Min a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfC8y] GHC.Err.errorWithoutStackTrace eta_sfC8y;

Data.Semigroup.$fMonadMin [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeMin
                                     Data.Semigroup.$fMonadMin_$c>>=
                                     Data.Semigroup.$fApplicativeMin_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl1_rfC67];

Data.Semigroup.$fNumMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U))>m] =
    [] \r [$dNum_sfC8z]
        let {
          sat_sfC8Q [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [eta_sfC8P]
                  GHC.Num.fromInteger $dNum_sfC8z eta_sfC8P; } in
        let {
          sat_sfC8O [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [ds_sfC8N]
                  GHC.Num.signum $dNum_sfC8z ds_sfC8N; } in
        let {
          sat_sfC8M [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [ds_sfC8L] GHC.Num.abs $dNum_sfC8z ds_sfC8L; } in
        let {
          sat_sfC8K [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [ds_sfC8J]
                  GHC.Num.negate $dNum_sfC8z ds_sfC8J; } in
        let {
          sat_sfC8I [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK
               -> Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [ds_sfC8G ds1_sfC8H]
                  GHC.Num.* $dNum_sfC8z ds_sfC8G ds1_sfC8H; } in
        let {
          sat_sfC8F [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK
               -> Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [ds_sfC8D ds1_sfC8E]
                  GHC.Num.- $dNum_sfC8z ds_sfC8D ds1_sfC8E; } in
        let {
          sat_sfC8C [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK
               -> Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [ds_sfC8A ds1_sfC8B]
                  GHC.Num.+ $dNum_sfC8z ds_sfC8A ds1_sfC8B;
        } in 
          GHC.Num.C:Num [sat_sfC8C
                         sat_sfC8F
                         sat_sfC8I
                         sat_sfC8K
                         sat_sfC8M
                         sat_sfC8O
                         sat_sfC8Q];

Data.Semigroup.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Max a
     -> [Data.Semigroup.Max a] -> Data.Semigroup.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfC8R ww_sfC8S ww1_sfC8T]
        let {
          go_sfC8U [Occ=LoopBreaker]
            :: Data.Semigroup.Max a_sfBpa
               -> [Data.Semigroup.Max a_sfBpa] -> Data.Semigroup.Max a_sfBpa
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfC8R go_sfC8U] \r [b_sfC8V ds1_sfC8W]
                  case ds1_sfC8W of {
                    [] -> b_sfC8V;
                    : c_sfC8Y [Occ=Once] cs_sfC8Z [Occ=Once] ->
                        let {
                          sat_sfC90 [Occ=Once] :: a_sfBpa
                          [LclId] =
                              [go_sfC8U c_sfC8Y cs_sfC8Z] \u [] go_sfC8U c_sfC8Y cs_sfC8Z;
                        } in  GHC.Classes.max w_sfC8R b_sfC8V sat_sfC90;
                  };
        } in  go_sfC8U ww_sfC8S ww1_sfC8T;

Data.Semigroup.$fSemigroupMax_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Semigroup.Max a) -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfC91 w1_sfC92]
        case w1_sfC92 of {
          GHC.Base.:| ww1_sfC94 [Occ=Once] ww2_sfC95 [Occ=Once] ->
              Data.Semigroup.$w$csconcat w_sfC91 ww1_sfC94 ww2_sfC95;
        };

lvl2_rfC68
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfC96 eta_sfC97 eta1_sfC98]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfC96 eta_sfC97 eta1_sfC98;

Data.Semigroup.$fSemigroupMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,A,U,A)>m] =
    [] \r [$dOrd_sfC99]
        let {
          sat_sfC9b [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Max a_afz6w)
               -> Data.Semigroup.Max a_afz6w
          [LclId] =
              [$dOrd_sfC99] \r [eta_B1]
                  Data.Semigroup.$fSemigroupMax_$csconcat $dOrd_sfC99 eta_B1; } in
        let {
          sat_sfC9a [Occ=Once]
            :: Data.Semigroup.Max a_afz6w
               -> Data.Semigroup.Max a_afz6w -> Data.Semigroup.Max a_afz6w
          [LclId] =
              [$dOrd_sfC99] \u [] GHC.Classes.max $dOrd_sfC99;
        } in  GHC.Base.C:Semigroup [sat_sfC9a sat_sfC9b lvl2_rfC68];

Data.Semigroup.$fFunctorMax2
  :: forall a b. (a -> b) -> Data.Semigroup.Max a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfC9c ds_sfC9d] f_sfC9c ds_sfC9d;

Data.Semigroup.$fFunctorMax1
  :: forall b a. a -> Data.Semigroup.Max b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sfC9e ds_sfC9f] x_sfC9e;

Data.Semigroup.$fFunctorMax [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorMax2
                                       Data.Semigroup.$fFunctorMax1];

Data.Semigroup.$fFoldableMax_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Max a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfC9g f_sfC9h ds_sfC9i] f_sfC9h ds_sfC9i;

Data.Semigroup.$fFoldableMax4
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.Max m -> Data.Semigroup.Max m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfC9j ds_sfC9k] ds_sfC9k;

Data.Semigroup.$fFoldableMax1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfC9l eta_sfC9m] eta_sfC9m;

Data.Semigroup.$fFoldableMax2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfC9n x_sfC9o] x_sfC9o;

Data.Semigroup.$fFoldableMax_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Max a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfC9p eta_sfC9q]
        let {
          f_sfC9r [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afz51 -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfC9p eta_sfC9q] \u []
                  GHC.Classes.== $dEq_sfC9p eta_sfC9q; } in
        let {
          sat_sfC9t [Occ=OnceT[0]]
            :: Data.Semigroup.Max a_afz51 -> GHC.Types.Bool
          [LclId] =
              [f_sfC9r] \r [ds_sfC9s] f_sfC9r ds_sfC9s;
        } in  sat_sfC9t;

Data.Semigroup.$fFoldableMax_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Max a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfC9u z_sfC9v t1_sfC9w] f_sfC9u z_sfC9v t1_sfC9w;

Data.Semigroup.$fFoldableMax3
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfC9x xs_sfC9y] xs_sfC9y;

Data.Semigroup.$fFoldableMax_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Max a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfC9z z0_sfC9A xs_sfC9B] f_sfC9z xs_sfC9B z0_sfC9A;

Data.Semigroup.$fFoldableMax_$clength
  :: forall a. Data.Semigroup.Max a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfC9C] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableMax_$cnull
  :: forall a. Data.Semigroup.Max a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfC9D] GHC.Types.False [];

Data.Semigroup.$fFoldableMax_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Max a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfC9E] : [eta_sfC9E GHC.Types.[]];

Data.Semigroup.$fFoldableMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Max
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableMax4
                                             Data.Semigroup.$fFoldableMax_$cfoldMap
                                             Data.Semigroup.$fFoldableMax_$cfoldr'
                                             Data.Semigroup.$fFoldableMax_$cfoldr'
                                             Data.Semigroup.$fFoldableMax_$cfoldl
                                             Data.Semigroup.$fFoldableMax_$cfoldl
                                             Data.Semigroup.$fFoldableMax3
                                             Data.Semigroup.$fFoldableMax3
                                             Data.Semigroup.$fFoldableMax_$ctoList
                                             Data.Semigroup.$fFoldableMax_$cnull
                                             Data.Semigroup.$fFoldableMax_$clength
                                             Data.Semigroup.$fFoldableMax_$celem
                                             Data.Semigroup.$fFoldableMax2
                                             Data.Semigroup.$fFoldableMax2
                                             Data.Semigroup.$fFoldableMax1
                                             Data.Semigroup.$fFoldableMax1];

Data.Semigroup.$fTraversableMax_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.Max a -> f (Data.Semigroup.Max b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfC9F eta_sfC9G eta1_sfC9H]
        let {
          sat_sfC9J [Occ=Once] :: f_afz2z b_afz2B
          [LclId] =
              [eta_sfC9G eta1_sfC9H] \u [] eta_sfC9G eta1_sfC9H;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfC9F of sat_sfC9I {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfC9I Data.Semigroup.$fApplicativeFirst3 sat_sfC9J;
          };

Data.Semigroup.$fTraversableMax_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Max (f a) -> f (Data.Semigroup.Max a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfC9K eta_sfC9L]
        case GHC.Base.$p1Applicative $dApplicative_sfC9K of sat_sfC9M {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfC9M Data.Semigroup.$fApplicativeFirst3 eta_sfC9L;
        };

Data.Semigroup.$fTraversableMax_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.Max a -> m (Data.Semigroup.Max b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfC9N eta_sfC9O eta1_sfC9P]
        let {
          sat_sfC9S [Occ=Once] :: m_afz2Z b_afz31
          [LclId] =
              [eta_sfC9O eta1_sfC9P] \u [] eta_sfC9O eta1_sfC9P;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfC9N of sat_sfC9Q {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfC9Q of sat_sfC9R {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfC9R Data.Semigroup.$fApplicativeFirst3 sat_sfC9S;
                };
          };

Data.Semigroup.$fTraversableMax_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Max (m a) -> m (Data.Semigroup.Max a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfC9T eta_sfC9U]
        case GHC.Base.$p1Monad $dMonad_sfC9T of sat_sfC9V {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfC9V of sat_sfC9W {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfC9W Data.Semigroup.$fApplicativeFirst3 eta_sfC9U;
              };
        };

Data.Semigroup.$fTraversableMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorMax
                                                   Data.Semigroup.$fFoldableMax
                                                   Data.Semigroup.$fTraversableMax_$ctraverse
                                                   Data.Semigroup.$fTraversableMax_$csequenceA
                                                   Data.Semigroup.$fTraversableMax_$cmapM
                                                   Data.Semigroup.$fTraversableMax_$csequence];

Data.Semigroup.$fApplicativeMax_$c<*
  :: forall a b.
     Data.Semigroup.Max a
     -> Data.Semigroup.Max b -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfC9X ds_sfC9Y] a1_sfC9X;

Data.Semigroup.$fApplicativeMax_$c*>
  :: forall a b.
     Data.Semigroup.Max a
     -> Data.Semigroup.Max b -> Data.Semigroup.Max b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfC9Z a1_sfCa0] a1_sfCa0;

Data.Semigroup.$fApplicativeMax1
  :: forall a b.
     Data.Semigroup.Max (a -> b) -> Data.Semigroup.Max (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfCa1] v_sfCa1;

Data.Semigroup.$fApplicativeMax [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorMax
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeMax1
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeMax_$c*>
                                           Data.Semigroup.$fApplicativeMax_$c<*];

Data.Semigroup.$fMonadMax_$c>>=
  :: forall a b.
     Data.Semigroup.Max a
     -> (a -> Data.Semigroup.Max b) -> Data.Semigroup.Max b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfCa2 f_sfCa3] f_sfCa3 ds_sfCa2;

lvl3_rfC69 :: forall a. [GHC.Types.Char] -> Data.Semigroup.Max a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfCa4] GHC.Err.errorWithoutStackTrace eta_sfCa4;

Data.Semigroup.$fMonadMax [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeMax
                                     Data.Semigroup.$fMonadMax_$c>>=
                                     Data.Semigroup.$fApplicativeMax_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl3_rfC69];

Data.Semigroup.$fNumMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U))>m] =
    [] \r [$dNum_sfCa5]
        let {
          sat_sfCam [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [eta_sfCal]
                  GHC.Num.fromInteger $dNum_sfCa5 eta_sfCal; } in
        let {
          sat_sfCak [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [ds_sfCaj]
                  GHC.Num.signum $dNum_sfCa5 ds_sfCaj; } in
        let {
          sat_sfCai [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [ds_sfCah] GHC.Num.abs $dNum_sfCa5 ds_sfCah; } in
        let {
          sat_sfCag [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [ds_sfCaf]
                  GHC.Num.negate $dNum_sfCa5 ds_sfCaf; } in
        let {
          sat_sfCae [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3
               -> Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [ds_sfCac ds1_sfCad]
                  GHC.Num.* $dNum_sfCa5 ds_sfCac ds1_sfCad; } in
        let {
          sat_sfCab [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3
               -> Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [ds_sfCa9 ds1_sfCaa]
                  GHC.Num.- $dNum_sfCa5 ds_sfCa9 ds1_sfCaa; } in
        let {
          sat_sfCa8 [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3
               -> Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [ds_sfCa6 ds1_sfCa7]
                  GHC.Num.+ $dNum_sfCa5 ds_sfCa6 ds1_sfCa7;
        } in 
          GHC.Num.C:Num [sat_sfCa8
                         sat_sfCab
                         sat_sfCae
                         sat_sfCag
                         sat_sfCai
                         sat_sfCak
                         sat_sfCam];

Data.Semigroup.$fFunctorArg_$cfmap
  :: forall a1 a2 b.
     (a2 -> b) -> Data.Semigroup.Arg a1 a2 -> Data.Semigroup.Arg a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sfCan ds_sfCao]
        case ds_sfCao of {
          Data.Semigroup.Arg x_sfCaq [Occ=Once] a2_sfCar [Occ=Once] ->
              let {
                sat_sfCas [Occ=Once] :: b_afyZC
                [LclId] =
                    [f_sfCan a2_sfCar] \u [] f_sfCan a2_sfCar;
              } in  Data.Semigroup.Arg [x_sfCaq sat_sfCas];
        };

Data.Semigroup.$fFunctorArg_$c<$
  :: forall a1 a2 b.
     a2 -> Data.Semigroup.Arg a1 b -> Data.Semigroup.Arg a1 a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [x_sfCat ds_sfCau]
        case ds_sfCau of {
          Data.Semigroup.Arg x1_sfCaw [Occ=Once] _ [Occ=Dead] ->
              Data.Semigroup.Arg [x1_sfCaw x_sfCat];
        };

Data.Semigroup.$fFunctorArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Functor (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorArg_$cfmap
                                       Data.Semigroup.$fFunctorArg_$c<$];

Data.Semigroup.$fFoldableArg_$cfoldMap
  :: forall a1 m a2.
     GHC.Base.Monoid m =>
     (a2 -> m) -> Data.Semigroup.Arg a1 a2 -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCay f_sfCaz ds_sfCaA]
        case ds_sfCaA of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCaD [Occ=Once] ->
              f_sfCaz a2_sfCaD;
        };

Data.Semigroup.$fFoldableArg_$cfold
  :: forall a m. GHC.Base.Monoid m => Data.Semigroup.Arg a m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCaE ds_sfCaF]
        case ds_sfCaF of {
          Data.Semigroup.Arg _ [Occ=Dead] a1_sfCaI [Occ=Once] -> a1_sfCaI;
        };

Data.Semigroup.$fFoldableArg2
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Semigroup.Arg a1 a2 -> Data.Semigroup.Internal.Sum a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfCaJ eta_sfCaK]
        case eta_sfCaK of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCaN [Occ=Once] -> a2_sfCaN;
        };

Data.Semigroup.$fFoldableArg3
  :: forall a1 a2. Data.Semigroup.Arg a2 a1 -> a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [x_sfCaO]
        case x_sfCaO of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCaR [Occ=Once] -> a2_sfCaR;
        };

Data.Semigroup.$fFoldableArg_$cminimum
  :: forall a1 a2.
     GHC.Classes.Ord a2 =>
     Data.Semigroup.Arg a1 a2 -> a2
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sfCaS eta_B1] Data.Semigroup.$fFoldableArg3 eta_B1;

Data.Semigroup.$fFoldableArg_$celem
  :: forall a1 a2.
     GHC.Classes.Eq a2 =>
     a2 -> Data.Semigroup.Arg a1 a2 -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfCaT eta_sfCaU]
        let {
          f_sfCaV [Occ=OnceL!, Dmd=<L,C(U)>] :: a1_afyYK -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCaT eta_sfCaU] \u []
                  GHC.Classes.== $dEq_sfCaT eta_sfCaU; } in
        let {
          sat_sfCb0 [Occ=Once]
            :: Data.Semigroup.Arg a_XfzaV a1_afyYK
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_sfCaV] \r [ds_sfCaW]
                  case ds_sfCaW of {
                    Data.Semigroup.Arg _ [Occ=Dead] a2_sfCaZ [Occ=Once] ->
                        f_sfCaV a2_sfCaZ;
                  };
        } in  sat_sfCb0;

Data.Semigroup.$fFoldableArg_$cfoldl
  :: forall a1 b a2.
     (b -> a2 -> b) -> b -> Data.Semigroup.Arg a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfCb1 z_sfCb2 t1_sfCb3]
        case t1_sfCb3 of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCb6 [Occ=Once] ->
              f_sfCb1 z_sfCb2 a2_sfCb6;
        };

Data.Semigroup.$fFoldableArg_$cfoldl1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Data.Semigroup.Arg a1 a2 -> a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sfCb7 xs_sfCb8]
        case xs_sfCb8 of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCbb [Occ=Once] -> a2_sfCbb;
        };

Data.Semigroup.$fFoldableArg_$cfoldr'
  :: forall a1 a2 b.
     (a2 -> b -> b) -> b -> Data.Semigroup.Arg a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfCbc z0_sfCbd xs_sfCbe]
        case xs_sfCbe of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCbh [Occ=Once] ->
              f_sfCbc a2_sfCbh z0_sfCbd;
        };

Data.Semigroup.$fFoldableArg_$clength
  :: forall a1 a2. Data.Semigroup.Arg a1 a2 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_sfCbi]
        case xs_sfCbi of {
          Data.Semigroup.Arg _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Semigroup.$fFoldableFirst3;
        };

Data.Semigroup.$fFoldableArg_$cnull
  :: forall a1 a2. Data.Semigroup.Arg a1 a2 -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [t1_sfCbm]
        case t1_sfCbm of {
          Data.Semigroup.Arg _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Semigroup.$fFoldableArg1
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Semigroup.Arg a1 a2 -> Data.Semigroup.Internal.Product a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfCbq eta_sfCbr]
        case eta_sfCbr of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCbu [Occ=Once] -> a2_sfCbu;
        };

Data.Semigroup.$fFoldableArg_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. Data.Semigroup.Arg a1 a2 -> [a2]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_sfCbv]
        case eta_sfCbv of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCby [Occ=Once] ->
              : [a2_sfCby GHC.Types.[]];
        };

Data.Semigroup.$fFoldableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Foldable.Foldable (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableArg_$cfold
                                             Data.Semigroup.$fFoldableArg_$cfoldMap
                                             Data.Semigroup.$fFoldableArg_$cfoldr'
                                             Data.Semigroup.$fFoldableArg_$cfoldr'
                                             Data.Semigroup.$fFoldableArg_$cfoldl
                                             Data.Semigroup.$fFoldableArg_$cfoldl
                                             Data.Semigroup.$fFoldableArg_$cfoldl1
                                             Data.Semigroup.$fFoldableArg_$cfoldl1
                                             Data.Semigroup.$fFoldableArg_$ctoList
                                             Data.Semigroup.$fFoldableArg_$cnull
                                             Data.Semigroup.$fFoldableArg_$clength
                                             Data.Semigroup.$fFoldableArg_$celem
                                             Data.Semigroup.$fFoldableArg_$cminimum
                                             Data.Semigroup.$fFoldableArg_$cminimum
                                             Data.Semigroup.$fFoldableArg2
                                             Data.Semigroup.$fFoldableArg1];

Data.Semigroup.$fTraversableArg_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     GHC.Base.Applicative f =>
     (a2 -> f b)
     -> Data.Semigroup.Arg a1 a2 -> f (Data.Semigroup.Arg a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCbz eta_sfCbA eta1_sfCbB]
        case eta1_sfCbB of {
          Data.Semigroup.Arg x_sfCbD [Occ=OnceL] a2_sfCbE [Occ=Once] ->
              let {
                sat_sfCbH [Occ=Once] :: f_afyWg b_afyWi
                [LclId] =
                    [eta_sfCbA a2_sfCbE] \u [] eta_sfCbA a2_sfCbE; } in
              let {
                sat_sfCbG [Occ=Once]
                  :: b_afyWi -> Data.Semigroup.Arg a_afyW4 b_afyWi
                [LclId] =
                    [x_sfCbD] \r [eta_B1] Data.Semigroup.Arg [x_sfCbD eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfCbz of sat_sfCbF {
                  __DEFAULT -> GHC.Base.fmap sat_sfCbF sat_sfCbG sat_sfCbH;
                };
        };

Data.Semigroup.$fTraversableArg_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     GHC.Base.Applicative f =>
     Data.Semigroup.Arg a1 (f a2) -> f (Data.Semigroup.Arg a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCbI eta_sfCbJ]
        case eta_sfCbJ of {
          Data.Semigroup.Arg x_sfCbL [Occ=OnceL] a2_sfCbM [Occ=Once] ->
              let {
                sat_sfCbO [Occ=Once]
                  :: a1_afyWw -> Data.Semigroup.Arg a_afyW4 a1_afyWw
                [LclId] =
                    [x_sfCbL] \r [eta_B1] Data.Semigroup.Arg [x_sfCbL eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfCbI of sat_sfCbN {
                  __DEFAULT -> GHC.Base.fmap sat_sfCbN sat_sfCbO a2_sfCbM;
                };
        };

Data.Semigroup.$fTraversableArg_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     GHC.Base.Monad m =>
     (a2 -> m b)
     -> Data.Semigroup.Arg a1 a2 -> m (Data.Semigroup.Arg a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCbP eta_sfCbQ eta1_sfCbR]
        case eta1_sfCbR of {
          Data.Semigroup.Arg x_sfCbT [Occ=OnceL] a2_sfCbU [Occ=Once] ->
              let {
                sat_sfCbY [Occ=Once] :: m_afyWH b_afyWJ
                [LclId] =
                    [eta_sfCbQ a2_sfCbU] \u [] eta_sfCbQ a2_sfCbU; } in
              let {
                sat_sfCbX [Occ=Once]
                  :: b_afyWJ -> Data.Semigroup.Arg a_afyW4 b_afyWJ
                [LclId] =
                    [x_sfCbT] \r [eta_B1] Data.Semigroup.Arg [x_sfCbT eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sfCbP of sat_sfCbV {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sfCbV of sat_sfCbW {
                        __DEFAULT -> GHC.Base.fmap sat_sfCbW sat_sfCbX sat_sfCbY;
                      };
                };
        };

Data.Semigroup.$fTraversableArg_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     GHC.Base.Monad m =>
     Data.Semigroup.Arg a1 (m a2) -> m (Data.Semigroup.Arg a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCbZ eta_sfCc0]
        case eta_sfCc0 of {
          Data.Semigroup.Arg x_sfCc2 [Occ=OnceL] a2_sfCc3 [Occ=Once] ->
              let {
                sat_sfCc6 [Occ=Once]
                  :: a1_afyWW -> Data.Semigroup.Arg a_afyW4 a1_afyWW
                [LclId] =
                    [x_sfCc2] \r [eta_B1] Data.Semigroup.Arg [x_sfCc2 eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sfCbZ of sat_sfCc4 {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sfCc4 of sat_sfCc5 {
                        __DEFAULT -> GHC.Base.fmap sat_sfCc5 sat_sfCc6 a2_sfCc3;
                      };
                };
        };

Data.Semigroup.$fTraversableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Traversable.Traversable (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorArg
                                                   Data.Semigroup.$fFoldableArg
                                                   Data.Semigroup.$fTraversableArg_$ctraverse
                                                   Data.Semigroup.$fTraversableArg_$csequenceA
                                                   Data.Semigroup.$fTraversableArg_$cmapM
                                                   Data.Semigroup.$fTraversableArg_$csequence];

Data.Semigroup.$fEqArg_$c==
  :: forall a b.
     GHC.Classes.Eq a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfCc7 ds_sfCc8 ds1_sfCc9]
        case ds_sfCc8 of {
          Data.Semigroup.Arg a1_sfCcb [Occ=Once] _ [Occ=Dead] ->
              case ds1_sfCc9 of {
                Data.Semigroup.Arg b1_sfCce [Occ=Once] _ [Occ=Dead] ->
                    GHC.Classes.== $dEq_sfCc7 a1_sfCcb b1_sfCce;
              };
        };

Data.Semigroup.$fEqArg_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     GHC.Classes.Eq a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfCcg eta_sfCch eta1_sfCci]
        case eta_sfCch of {
          Data.Semigroup.Arg a1_sfCck [Occ=Once] _ [Occ=Dead] ->
              case eta1_sfCci of {
                Data.Semigroup.Arg b1_sfCcn [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.== $dEq_sfCcg a1_sfCck b1_sfCcn of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Semigroup.$fEqArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Arg a b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sfCcq]
        let {
          sat_sfCcs [Occ=Once]
            :: Data.Semigroup.Arg a_afyVO b_afyVP
               -> Data.Semigroup.Arg a_afyVO b_afyVP -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCcq] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fEqArg_$c/= $dEq_sfCcq eta_B2 eta_B1; } in
        let {
          sat_sfCcr [Occ=Once]
            :: Data.Semigroup.Arg a_afyVO b_afyVP
               -> Data.Semigroup.Arg a_afyVO b_afyVP -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCcq] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fEqArg_$c== $dEq_sfCcq eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sfCcr sat_sfCcs];

Data.Semigroup.$fOrdArg_$cmin
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b
     -> Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCct x_sfCcu y_sfCcv]
        case x_sfCcu of wild_sfCcw {
          Data.Semigroup.Arg a1_sfCcx [Occ=Once] _ [Occ=Dead] ->
              case y_sfCcv of wild1_sfCcz {
                Data.Semigroup.Arg b1_sfCcA [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.<= $dOrd_sfCct a1_sfCcx b1_sfCcA of {
                      GHC.Types.False -> wild1_sfCcz;
                      GHC.Types.True -> wild_sfCcw;
                    };
              };
        };

Data.Semigroup.$fOrdArg_$cmax
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b
     -> Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCcD x_sfCcE y_sfCcF]
        case x_sfCcE of wild_sfCcG {
          Data.Semigroup.Arg a1_sfCcH [Occ=Once] _ [Occ=Dead] ->
              case y_sfCcF of wild1_sfCcJ {
                Data.Semigroup.Arg b1_sfCcK [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.>= $dOrd_sfCcD a1_sfCcH b1_sfCcK of {
                      GHC.Types.False -> wild1_sfCcJ;
                      GHC.Types.True -> wild_sfCcG;
                    };
              };
        };

Data.Semigroup.$fOrdArg_$ccompare
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b
     -> Data.Semigroup.Arg a b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCcN ds_sfCcO ds1_sfCcP]
        case ds_sfCcO of {
          Data.Semigroup.Arg a1_sfCcR [Occ=Once] _ [Occ=Dead] ->
              case ds1_sfCcP of {
                Data.Semigroup.Arg b1_sfCcU [Occ=Once] _ [Occ=Dead] ->
                    GHC.Classes.compare $dOrd_sfCcN a1_sfCcR b1_sfCcU;
              };
        };

Data.Semigroup.$fOrdArg_$cp1Ord
  :: forall a b.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Arg a b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCcW]
        let {
          sat_sfCcX [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_afyV3
          [LclId] =
              [$dOrd_sfCcW] \u [] GHC.Classes.$p1Ord $dOrd_sfCcW;
        } in  Data.Semigroup.$fEqArg sat_sfCcX;

Data.Semigroup.$fOrdArg_$c<
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCcY x_sfCcZ y_sfCd0]
        case x_sfCcZ of {
          Data.Semigroup.Arg a1_sfCd2 [Occ=Once] _ [Occ=Dead] ->
              case y_sfCd0 of {
                Data.Semigroup.Arg b1_sfCd5 [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfCcY a1_sfCd2 b1_sfCd5 of {
                      __DEFAULT -> GHC.Types.False [];
                      GHC.Types.LT -> GHC.Types.True [];
                    };
              };
        };

Data.Semigroup.$fOrdArg_$c>
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCd8 x_sfCd9 y_sfCda]
        case x_sfCd9 of {
          Data.Semigroup.Arg a1_sfCdc [Occ=Once] _ [Occ=Dead] ->
              case y_sfCda of {
                Data.Semigroup.Arg b1_sfCdf [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfCd8 a1_sfCdc b1_sfCdf of {
                      __DEFAULT -> GHC.Types.False [];
                      GHC.Types.GT -> GHC.Types.True [];
                    };
              };
        };

Data.Semigroup.$fOrdArg_$c<=
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCdi x_sfCdj y_sfCdk]
        case x_sfCdj of {
          Data.Semigroup.Arg a1_sfCdm [Occ=Once] _ [Occ=Dead] ->
              case y_sfCdk of {
                Data.Semigroup.Arg b1_sfCdp [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfCdi a1_sfCdm b1_sfCdp of {
                      __DEFAULT -> GHC.Types.True [];
                      GHC.Types.GT -> GHC.Types.False [];
                    };
              };
        };

Data.Semigroup.$fOrdArg_$c>=
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCds x_sfCdt y_sfCdu]
        case x_sfCdt of {
          Data.Semigroup.Arg a1_sfCdw [Occ=Once] _ [Occ=Dead] ->
              case y_sfCdu of {
                Data.Semigroup.Arg b1_sfCdz [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfCds a1_sfCdw b1_sfCdz of {
                      __DEFAULT -> GHC.Types.True [];
                      GHC.Types.LT -> GHC.Types.False [];
                    };
              };
        };

Data.Semigroup.$fOrdArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,C(C1(U)),A,C(C1(U)),A,A)>m] =
    [] \r [$dOrd_sfCdC]
        let {
          sat_sfCdK [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$cmin $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdJ [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$cmax $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdI [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c>= $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdH [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c> $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdG [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c<= $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdF [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c< $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdE [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$ccompare $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdD [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Arg a_afyV3 b_afyV4)
          [LclId] =
              [$dOrd_sfCdC] \u [] Data.Semigroup.$fOrdArg_$cp1Ord $dOrd_sfCdC;
        } in 
          GHC.Classes.C:Ord [sat_sfCdD
                             sat_sfCdE
                             sat_sfCdF
                             sat_sfCdG
                             sat_sfCdH
                             sat_sfCdI
                             sat_sfCdJ
                             sat_sfCdK];

Data.Semigroup.$fBifunctorArg_$cbimap
  :: forall a b c d.
     (a -> b)
     -> (c -> d) -> Data.Semigroup.Arg a c -> Data.Semigroup.Arg b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sfCdL g_sfCdM ds_sfCdN]
        case ds_sfCdN of {
          Data.Semigroup.Arg a1_sfCdP [Occ=Once] b1_sfCdQ [Occ=Once] ->
              let {
                sat_sfCdS [Occ=Once] :: d_afyUz
                [LclId] =
                    [g_sfCdM b1_sfCdQ] \u [] g_sfCdM b1_sfCdQ; } in
              let {
                sat_sfCdR [Occ=Once] :: b_afyUx
                [LclId] =
                    [f_sfCdL a1_sfCdP] \u [] f_sfCdL a1_sfCdP;
              } in  Data.Semigroup.Arg [sat_sfCdR sat_sfCdS];
        };

Data.Semigroup.$fBifunctorArg_$cfirst
  :: forall a b c.
     (a -> b) -> Data.Semigroup.Arg a c -> Data.Semigroup.Arg b c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sfCdT ds_sfCdU]
        case ds_sfCdU of {
          Data.Semigroup.Arg a1_sfCdW [Occ=Once] b1_sfCdX [Occ=Once] ->
              let {
                sat_sfCdY [Occ=Once] :: b_afyUH
                [LclId] =
                    [f_sfCdT a1_sfCdW] \u [] f_sfCdT a1_sfCdW;
              } in  Data.Semigroup.Arg [sat_sfCdY b1_sfCdX];
        };

Data.Semigroup.$fBifunctorArg_$csecond
  :: forall b c a.
     (b -> c) -> Data.Semigroup.Arg a b -> Data.Semigroup.Arg a c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [g_sfCdZ ds_sfCe0]
        case ds_sfCe0 of {
          Data.Semigroup.Arg a1_sfCe2 [Occ=Once] b1_sfCe3 [Occ=Once] ->
              let {
                sat_sfCe4 [Occ=Once] :: c_afyUT
                [LclId] =
                    [g_sfCdZ b1_sfCe3] \u [] g_sfCdZ b1_sfCe3;
              } in  Data.Semigroup.Arg [a1_sfCe2 sat_sfCe4];
        };

Data.Semigroup.$fBifunctorArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor Data.Semigroup.Arg
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Semigroup.$fBifunctorArg_$cbimap
                                               Data.Semigroup.$fBifunctorArg_$cfirst
                                               Data.Semigroup.$fBifunctorArg_$csecond];

Data.Semigroup.$fBifoldableArg_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> Data.Semigroup.Arg a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCe5 eta_sfCe6 eta1_sfCe7 eta2_sfCe8]
        case eta2_sfCe8 of {
          Data.Semigroup.Arg a1_sfCea [Occ=Once] b1_sfCeb [Occ=Once] ->
              let {
                sat_sfCee [Occ=Once] :: m_afyTV
                [LclId] =
                    [eta1_sfCe7 b1_sfCeb] \u [] eta1_sfCe7 b1_sfCeb; } in
              let {
                sat_sfCed [Occ=Once] :: m_afyTV
                [LclId] =
                    [eta_sfCe6 a1_sfCea] \u [] eta_sfCe6 a1_sfCea;
              } in 
                case GHC.Base.$p1Monoid $dMonoid_sfCe5 of sat_sfCec {
                  __DEFAULT -> GHC.Base.<> sat_sfCec sat_sfCed sat_sfCee;
                };
        };

Data.Semigroup.$fBifoldableArg_$cbifold
  :: forall m. GHC.Base.Monoid m => Data.Semigroup.Arg m m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCef eta_sfCeg]
        case eta_sfCeg of {
          Data.Semigroup.Arg a_sfCei [Occ=Once] b_sfCej [Occ=Once] ->
              case GHC.Base.$p1Monoid $dMonoid_sfCef of sat_sfCek {
                __DEFAULT -> GHC.Base.<> sat_sfCek a_sfCei b_sfCej;
              };
        };

Data.Semigroup.$fBifoldableArg_$cbifoldr
  :: forall a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> Data.Semigroup.Arg a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfCel g_sfCem z_sfCen t_sfCeo]
        case t_sfCeo of {
          Data.Semigroup.Arg a1_sfCeq [Occ=Once] b1_sfCer [Occ=Once] ->
              let {
                sat_sfCes [Occ=Once] :: c_afyU7
                [LclId] =
                    [g_sfCem z_sfCen b1_sfCer] \u [] g_sfCem b1_sfCer z_sfCen;
              } in  f_sfCel a1_sfCeq sat_sfCes;
        };

Data.Semigroup.$fBifoldableArg_$cbifoldl
  :: forall c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> Data.Semigroup.Arg a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfCet g_sfCeu z_sfCev t_sfCew]
        case t_sfCew of {
          Data.Semigroup.Arg a1_sfCey [Occ=Once] b1_sfCez [Occ=Once] ->
              let {
                sat_sfCeA [Occ=Once] :: c_afyUi
                [LclId] =
                    [f_sfCet z_sfCev a1_sfCey] \u [] f_sfCet z_sfCev a1_sfCey;
              } in  g_sfCeu sat_sfCeA b1_sfCez;
        };

Data.Semigroup.$fBifoldableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable Data.Semigroup.Arg
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Semigroup.$fBifoldableArg_$cbifold
                                                 Data.Semigroup.$fBifoldableArg_$cbifoldMap
                                                 Data.Semigroup.$fBifoldableArg_$cbifoldr
                                                 Data.Semigroup.$fBifoldableArg_$cbifoldl];

Data.Semigroup.$w$cbitraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> a -> b -> f (Data.Semigroup.Arg c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCeB w1_sfCeC w2_sfCeD ww_sfCeE ww1_sfCeF]
        let {
          sat_sfCeJ [Occ=Once] :: f_sfBpj d_sfBpn
          [LclId] =
              [w2_sfCeD ww1_sfCeF] \u [] w2_sfCeD ww1_sfCeF; } in
        let {
          sat_sfCeI [Occ=Once]
            :: f_sfBpj (d_sfBpn -> Data.Semigroup.Arg c_sfBpl d_sfBpn)
          [LclId] =
              [w_sfCeB w1_sfCeC ww_sfCeE] \u []
                  let {
                    sat_sfCeH [Occ=Once] :: f_sfBpj c_sfBpl
                    [LclId] =
                        [w1_sfCeC ww_sfCeE] \u [] w1_sfCeC ww_sfCeE;
                  } in 
                    case GHC.Base.$p1Applicative w_sfCeB of sat_sfCeG {
                      __DEFAULT -> GHC.Base.fmap sat_sfCeG Data.Semigroup.Arg sat_sfCeH;
                    };
        } in  GHC.Base.<*> w_sfCeB sat_sfCeI sat_sfCeJ;

Data.Semigroup.$fBitraversableArg_$cbitraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d)
     -> Data.Semigroup.Arg a b
     -> f (Data.Semigroup.Arg c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sfCeK w1_sfCeL w2_sfCeM w3_sfCeN]
        case w3_sfCeN of {
          Data.Semigroup.Arg ww1_sfCeP [Occ=Once] ww2_sfCeQ [Occ=Once] ->
              Data.Semigroup.$w$cbitraverse
                  w_sfCeK w1_sfCeL w2_sfCeM ww1_sfCeP ww2_sfCeQ;
        };

Data.Semigroup.$fBitraversableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable Data.Semigroup.Arg
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Semigroup.$fBifunctorArg
                                                       Data.Semigroup.$fBifoldableArg
                                                       Data.Semigroup.$fBitraversableArg_$cbitraverse];

Data.Semigroup.$fSemigroupFirst_$cstimes
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfCeR eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfCeR eta_B2 eta_B1;

Data.Semigroup.$fSemigroupFirst_$c<>
  :: forall a.
     Data.Semigroup.First a
     -> Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfCeS ds_sfCeT] a1_sfCeS;

Data.Semigroup.$fSemigroupFirst_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Semigroup.First a)
     -> Data.Semigroup.First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfCeU]
        case ds_sfCeU of {
          GHC.Base.:| a1_sfCeW [Occ=Once] as_sfCeX [Occ=Once] ->
              case as_sfCeX of { __DEFAULT -> a1_sfCeW; };
        };

Data.Semigroup.$fSemigroupFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Semigroup.First a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Semigroup.$fSemigroupFirst_$c<>
                                         Data.Semigroup.$fSemigroupFirst_$csconcat
                                         Data.Semigroup.$fSemigroupFirst_$cstimes];

Data.Semigroup.$fFunctorFirst2
  :: forall a b. (a -> b) -> Data.Semigroup.First a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfCeZ ds_sfCf0] f_sfCeZ ds_sfCf0;

Data.Semigroup.$fFunctorFirst1
  :: forall b a. a -> Data.Semigroup.First b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sfCf1 ds_sfCf2] x_sfCf1;

Data.Semigroup.$fFunctorFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorFirst2
                                       Data.Semigroup.$fFunctorFirst1];

Data.Semigroup.$fFoldableFirst_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.First a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCf3 f_sfCf4 ds_sfCf5] f_sfCf4 ds_sfCf5;

Data.Semigroup.$fFoldableFirst5
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.First m -> Data.Semigroup.First m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCf6 ds_sfCf7] ds_sfCf7;

Data.Semigroup.$fFoldableFirst1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfCf8 eta_sfCf9] eta_sfCf9;

Data.Semigroup.$fFoldableFirst2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCfa x_sfCfb] x_sfCfb;

Data.Semigroup.$fFoldableFirst_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.First a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfCfc eta_sfCfd]
        let {
          f_sfCfe [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afyQr -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCfc eta_sfCfd] \u []
                  GHC.Classes.== $dEq_sfCfc eta_sfCfd; } in
        let {
          sat_sfCfg [Occ=OnceT[0]]
            :: Data.Semigroup.First a_afyQr -> GHC.Types.Bool
          [LclId] =
              [f_sfCfe] \r [ds_sfCff] f_sfCfe ds_sfCff;
        } in  sat_sfCfg;

Data.Semigroup.$fFoldableFirst_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfCfh z_sfCfi t1_sfCfj] f_sfCfh z_sfCfi t1_sfCfj;

Data.Semigroup.$fFoldableFirst4
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfCfk xs_sfCfl] xs_sfCfl;

Data.Semigroup.$fFoldableFirst_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfCfm z0_sfCfn xs_sfCfo] f_sfCfm xs_sfCfo z0_sfCfn;

Data.Semigroup.$fFoldableFirst_$clength
  :: forall a. Data.Semigroup.First a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfCfp] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableFirst_$cnull
  :: forall a. Data.Semigroup.First a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfCfq] GHC.Types.False [];

Data.Semigroup.$fFoldableFirst_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.First a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfCfr] : [eta_sfCfr GHC.Types.[]];

Data.Semigroup.$fFoldableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.First
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableFirst5
                                             Data.Semigroup.$fFoldableFirst_$cfoldMap
                                             Data.Semigroup.$fFoldableFirst_$cfoldr'
                                             Data.Semigroup.$fFoldableFirst_$cfoldr'
                                             Data.Semigroup.$fFoldableFirst_$cfoldl
                                             Data.Semigroup.$fFoldableFirst_$cfoldl
                                             Data.Semigroup.$fFoldableFirst4
                                             Data.Semigroup.$fFoldableFirst4
                                             Data.Semigroup.$fFoldableFirst_$ctoList
                                             Data.Semigroup.$fFoldableFirst_$cnull
                                             Data.Semigroup.$fFoldableFirst_$clength
                                             Data.Semigroup.$fFoldableFirst_$celem
                                             Data.Semigroup.$fFoldableFirst2
                                             Data.Semigroup.$fFoldableFirst2
                                             Data.Semigroup.$fFoldableFirst1
                                             Data.Semigroup.$fFoldableFirst1];

Data.Semigroup.$fTraversableFirst_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.First a -> f (Data.Semigroup.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCfs eta_sfCft eta1_sfCfu]
        let {
          sat_sfCfw [Occ=Once] :: f_afyNZ b_afyO1
          [LclId] =
              [eta_sfCft eta1_sfCfu] \u [] eta_sfCft eta1_sfCfu;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfCfs of sat_sfCfv {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfCfv Data.Semigroup.$fApplicativeFirst3 sat_sfCfw;
          };

Data.Semigroup.$fTraversableFirst_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.First (f a) -> f (Data.Semigroup.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCfx eta_sfCfy]
        case GHC.Base.$p1Applicative $dApplicative_sfCfx of sat_sfCfz {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfCfz Data.Semigroup.$fApplicativeFirst3 eta_sfCfy;
        };

Data.Semigroup.$fTraversableFirst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.First a -> m (Data.Semigroup.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCfA eta_sfCfB eta1_sfCfC]
        let {
          sat_sfCfF [Occ=Once] :: m_afyOp b_afyOr
          [LclId] =
              [eta_sfCfB eta1_sfCfC] \u [] eta_sfCfB eta1_sfCfC;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfCfA of sat_sfCfD {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfCfD of sat_sfCfE {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfCfE Data.Semigroup.$fApplicativeFirst3 sat_sfCfF;
                };
          };

Data.Semigroup.$fTraversableFirst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.First (m a) -> m (Data.Semigroup.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCfG eta_sfCfH]
        case GHC.Base.$p1Monad $dMonad_sfCfG of sat_sfCfI {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfCfI of sat_sfCfJ {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfCfJ Data.Semigroup.$fApplicativeFirst3 eta_sfCfH;
              };
        };

Data.Semigroup.$fTraversableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorFirst
                                                   Data.Semigroup.$fFoldableFirst
                                                   Data.Semigroup.$fTraversableFirst_$ctraverse
                                                   Data.Semigroup.$fTraversableFirst_$csequenceA
                                                   Data.Semigroup.$fTraversableFirst_$cmapM
                                                   Data.Semigroup.$fTraversableFirst_$csequence];

Data.Semigroup.$fApplicativeFirst_$c<*
  :: forall a b.
     Data.Semigroup.First a
     -> Data.Semigroup.First b -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfCfK ds_sfCfL] a1_sfCfK;

Data.Semigroup.$fApplicativeFirst_$c*>
  :: forall a b.
     Data.Semigroup.First a
     -> Data.Semigroup.First b -> Data.Semigroup.First b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfCfM a1_sfCfN] a1_sfCfN;

Data.Semigroup.$fApplicativeFirst2
  :: forall a b.
     Data.Semigroup.First (a -> b) -> Data.Semigroup.First (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfCfO] v_sfCfO;

Data.Semigroup.$fApplicativeFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorFirst
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeFirst2
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeFirst_$c*>
                                           Data.Semigroup.$fApplicativeFirst_$c<*];

Data.Semigroup.$fMonadFirst_$c>>=
  :: forall a b.
     Data.Semigroup.First a
     -> (a -> Data.Semigroup.First b) -> Data.Semigroup.First b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfCfP f_sfCfQ] f_sfCfQ ds_sfCfP;

lvl4_rfC6a :: forall a. [GHC.Types.Char] -> Data.Semigroup.First a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfCfR] GHC.Err.errorWithoutStackTrace eta_sfCfR;

Data.Semigroup.$fMonadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeFirst
                                     Data.Semigroup.$fMonadFirst_$c>>=
                                     Data.Semigroup.$fApplicativeFirst_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl4_rfC6a];

Data.Semigroup.$fSemigroupLast_$cstimes
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfCfS eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfCfS eta_B2 eta_B1;

Data.Semigroup.$fSemigroupLast_$c<>
  :: forall a.
     Data.Semigroup.Last a
     -> Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfCfT b_sfCfU] b_sfCfU;

Data.Semigroup.$fSemigroupLast1 [Occ=LoopBreaker]
  :: forall a.
     Data.Semigroup.Last a
     -> [Data.Semigroup.Last a] -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sfCfV ds1_sfCfW]
        case ds1_sfCfW of {
          [] -> b_sfCfV;
          : c_sfCfY [Occ=Once] cs_sfCfZ [Occ=Once] ->
              Data.Semigroup.$fSemigroupLast1 c_sfCfY cs_sfCfZ;
        };

Data.Semigroup.$fSemigroupLast_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Semigroup.Last a) -> Data.Semigroup.Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfCg0]
        case ds_sfCg0 of {
          GHC.Base.:| a1_sfCg2 [Occ=Once] as_sfCg3 [Occ=Once] ->
              Data.Semigroup.$fSemigroupLast1 a1_sfCg2 as_sfCg3;
        };

Data.Semigroup.$fSemigroupLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Semigroup.Last a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Semigroup.$fSemigroupLast_$c<>
                                         Data.Semigroup.$fSemigroupLast_$csconcat
                                         Data.Semigroup.$fSemigroupLast_$cstimes];

Data.Semigroup.$fFunctorLast1
  :: forall a b. a -> Data.Semigroup.Last b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfCg4 ds_sfCg5] a1_sfCg4;

Data.Semigroup.$fFunctorLast2
  :: forall a b. (a -> b) -> Data.Semigroup.Last a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfCg6 ds_sfCg7] f_sfCg6 ds_sfCg7;

Data.Semigroup.$fFunctorLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorLast2
                                       Data.Semigroup.$fFunctorLast1];

Data.Semigroup.$fFoldableLast_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Last a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCg8 f_sfCg9 ds_sfCga] f_sfCg9 ds_sfCga;

Data.Semigroup.$fFoldableLast4
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.Last m -> Data.Semigroup.Last m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCgb ds_sfCgc] ds_sfCgc;

Data.Semigroup.$fFoldableLast1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfCgd eta_sfCge] eta_sfCge;

Data.Semigroup.$fFoldableLast2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCgf x_sfCgg] x_sfCgg;

Data.Semigroup.$fFoldableLast_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Last a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfCgh eta_sfCgi]
        let {
          f_sfCgj [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afyJq -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCgh eta_sfCgi] \u []
                  GHC.Classes.== $dEq_sfCgh eta_sfCgi; } in
        let {
          sat_sfCgl [Occ=OnceT[0]]
            :: Data.Semigroup.Last a_afyJq -> GHC.Types.Bool
          [LclId] =
              [f_sfCgj] \r [ds_sfCgk] f_sfCgj ds_sfCgk;
        } in  sat_sfCgl;

Data.Semigroup.$fFoldableLast_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfCgm z_sfCgn t1_sfCgo] f_sfCgm z_sfCgn t1_sfCgo;

Data.Semigroup.$fFoldableLast3
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfCgp xs_sfCgq] xs_sfCgq;

Data.Semigroup.$fFoldableLast_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfCgr z0_sfCgs xs_sfCgt] f_sfCgr xs_sfCgt z0_sfCgs;

Data.Semigroup.$fFoldableLast_$clength
  :: forall a. Data.Semigroup.Last a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfCgu] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableLast_$cnull
  :: forall a. Data.Semigroup.Last a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfCgv] GHC.Types.False [];

Data.Semigroup.$fFoldableLast_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Last a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfCgw] : [eta_sfCgw GHC.Types.[]];

Data.Semigroup.$fFoldableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableLast4
                                             Data.Semigroup.$fFoldableLast_$cfoldMap
                                             Data.Semigroup.$fFoldableLast_$cfoldr'
                                             Data.Semigroup.$fFoldableLast_$cfoldr'
                                             Data.Semigroup.$fFoldableLast_$cfoldl
                                             Data.Semigroup.$fFoldableLast_$cfoldl
                                             Data.Semigroup.$fFoldableLast3
                                             Data.Semigroup.$fFoldableLast3
                                             Data.Semigroup.$fFoldableLast_$ctoList
                                             Data.Semigroup.$fFoldableLast_$cnull
                                             Data.Semigroup.$fFoldableLast_$clength
                                             Data.Semigroup.$fFoldableLast_$celem
                                             Data.Semigroup.$fFoldableLast2
                                             Data.Semigroup.$fFoldableLast2
                                             Data.Semigroup.$fFoldableLast1
                                             Data.Semigroup.$fFoldableLast1];

Data.Semigroup.$fTraversableLast_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.Last a -> f (Data.Semigroup.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCgx eta_sfCgy eta1_sfCgz]
        let {
          sat_sfCgB [Occ=Once] :: f_afyGY b_afyH0
          [LclId] =
              [eta_sfCgy eta1_sfCgz] \u [] eta_sfCgy eta1_sfCgz;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfCgx of sat_sfCgA {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfCgA Data.Semigroup.$fApplicativeFirst3 sat_sfCgB;
          };

Data.Semigroup.$fTraversableLast_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Last (f a) -> f (Data.Semigroup.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCgC eta_sfCgD]
        case GHC.Base.$p1Applicative $dApplicative_sfCgC of sat_sfCgE {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfCgE Data.Semigroup.$fApplicativeFirst3 eta_sfCgD;
        };

Data.Semigroup.$fTraversableLast_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.Last a -> m (Data.Semigroup.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCgF eta_sfCgG eta1_sfCgH]
        let {
          sat_sfCgK [Occ=Once] :: m_afyHo b_afyHq
          [LclId] =
              [eta_sfCgG eta1_sfCgH] \u [] eta_sfCgG eta1_sfCgH;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfCgF of sat_sfCgI {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfCgI of sat_sfCgJ {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfCgJ Data.Semigroup.$fApplicativeFirst3 sat_sfCgK;
                };
          };

Data.Semigroup.$fTraversableLast_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Last (m a) -> m (Data.Semigroup.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCgL eta_sfCgM]
        case GHC.Base.$p1Monad $dMonad_sfCgL of sat_sfCgN {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfCgN of sat_sfCgO {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfCgO Data.Semigroup.$fApplicativeFirst3 eta_sfCgM;
              };
        };

Data.Semigroup.$fTraversableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorLast
                                                   Data.Semigroup.$fFoldableLast
                                                   Data.Semigroup.$fTraversableLast_$ctraverse
                                                   Data.Semigroup.$fTraversableLast_$csequenceA
                                                   Data.Semigroup.$fTraversableLast_$cmapM
                                                   Data.Semigroup.$fTraversableLast_$csequence];

Data.Semigroup.$fApplicativeLast_$c<*
  :: forall a b.
     Data.Semigroup.Last a
     -> Data.Semigroup.Last b -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfCgP ds_sfCgQ] a1_sfCgP;

Data.Semigroup.$fApplicativeLast_$c*>
  :: forall a b.
     Data.Semigroup.Last a
     -> Data.Semigroup.Last b -> Data.Semigroup.Last b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfCgR a1_sfCgS] a1_sfCgS;

Data.Semigroup.$fApplicativeLast1
  :: forall a b.
     Data.Semigroup.Last (a -> b) -> Data.Semigroup.Last (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfCgT] v_sfCgT;

Data.Semigroup.$fApplicativeLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorLast
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeLast1
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeLast_$c*>
                                           Data.Semigroup.$fApplicativeLast_$c<*];

Data.Semigroup.$fMonadLast_$c>>=
  :: forall a b.
     Data.Semigroup.Last a
     -> (a -> Data.Semigroup.Last b) -> Data.Semigroup.Last b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfCgU f_sfCgV] f_sfCgV ds_sfCgU;

lvl5_rfC6b :: forall a. [GHC.Types.Char] -> Data.Semigroup.Last a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfCgW] GHC.Err.errorWithoutStackTrace eta_sfCgW;

Data.Semigroup.$fMonadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeLast
                                     Data.Semigroup.$fMonadLast_$c>>=
                                     Data.Semigroup.$fApplicativeLast_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl5_rfC6b];

Data.Semigroup.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.WrappedMonoid m
     -> [Data.Semigroup.WrappedMonoid m]
     -> Data.Semigroup.WrappedMonoid m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfCgX ww_sfCgY ww1_sfCgZ]
        let {
          go_sfCh0 [Occ=LoopBreaker]
            :: Data.Semigroup.WrappedMonoid m_sfBpD
               -> [Data.Semigroup.WrappedMonoid m_sfBpD]
               -> Data.Semigroup.WrappedMonoid m_sfBpD
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfCgX go_sfCh0] \r [b_sfCh1 ds1_sfCh2]
                  case ds1_sfCh2 of {
                    [] -> b_sfCh1;
                    : c_sfCh4 [Occ=Once] cs_sfCh5 [Occ=Once] ->
                        let {
                          sat_sfCh6 [Occ=Once] :: m_sfBpD
                          [LclId] =
                              [go_sfCh0 c_sfCh4 cs_sfCh5] \u [] go_sfCh0 c_sfCh4 cs_sfCh5;
                        } in  GHC.Base.mappend w_sfCgX b_sfCh1 sat_sfCh6;
                  };
        } in  go_sfCh0 ww_sfCgY ww1_sfCgZ;

Data.Semigroup.$fSemigroupWrappedMonoid_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Base.NonEmpty (Data.Semigroup.WrappedMonoid m)
     -> Data.Semigroup.WrappedMonoid m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfCh7 w1_sfCh8]
        case w1_sfCh8 of {
          GHC.Base.:| ww1_sfCha [Occ=Once] ww2_sfChb [Occ=Once] ->
              Data.Semigroup.$w$csconcat3 w_sfCh7 ww1_sfCha ww2_sfChb;
        };

Data.Semigroup.$fSemigroupWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,U,A)>m] =
    [] \r [$dMonoid_sfChc]
        let {
          sat_sfChf [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.WrappedMonoid m_afyEA
               -> Data.Semigroup.WrappedMonoid m_afyEA
          [LclId] =
              [$dMonoid_sfChc] \r [eta_B1]
                  Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes
                      $dMonoid_sfChc eta_B1; } in
        let {
          sat_sfChe [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.WrappedMonoid m_afyEA)
               -> Data.Semigroup.WrappedMonoid m_afyEA
          [LclId] =
              [$dMonoid_sfChc] \r [eta_B1]
                  Data.Semigroup.$fSemigroupWrappedMonoid_$csconcat
                      $dMonoid_sfChc eta_B1; } in
        let {
          sat_sfChd [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyEA
               -> Data.Semigroup.WrappedMonoid m_afyEA
               -> Data.Semigroup.WrappedMonoid m_afyEA
          [LclId] =
              [$dMonoid_sfChc] \u [] GHC.Base.mappend $dMonoid_sfChc;
        } in  GHC.Base.C:Semigroup [sat_sfChd sat_sfChe sat_sfChf];
Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes [Occ=LoopBreaker]
  :: forall m.
     GHC.Base.Monoid m =>
     forall b.
     GHC.Real.Integral b =>
     b
     -> Data.Semigroup.WrappedMonoid m -> Data.Semigroup.WrappedMonoid m
[GblId, Arity=2, Str=<L,U(A,A,U,A)><L,U>, Unf=OtherCon []] =
    [] \r [$dMonoid_sfChg $dIntegral_sfChh]
        let {
          sat_sfChi [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m_afyEA)
          [LclId] =
              [$dMonoid_sfChg] \u []
                  Data.Semigroup.$fSemigroupWrappedMonoid $dMonoid_sfChg;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_sfChh sat_sfChi;

Data.Semigroup.$fMonoidWrappedMonoid_$cmconcat
  :: forall m.
     GHC.Base.Monoid m =>
     [Data.Semigroup.WrappedMonoid m] -> Data.Semigroup.WrappedMonoid m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfChj eta_sfChk]
        let {
          z_sfChl [Occ=OnceL] :: m_afyEb
          [LclId] =
              [$dMonoid_sfChj] \u [] GHC.Base.mempty $dMonoid_sfChj; } in
        let {
          go_sfChm [Occ=LoopBreaker]
            :: [Data.Semigroup.WrappedMonoid m_afyEb]
               -> Data.Semigroup.WrappedMonoid m_afyEb
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_sfChj z_sfChl go_sfChm] \r [ds_sfChn]
                  case ds_sfChn of {
                    [] -> z_sfChl;
                    : y_sfChp [Occ=Once] ys_sfChq [Occ=Once] ->
                        let {
                          sat_sfChr [Occ=Once] :: m_afyEb
                          [LclId] =
                              [go_sfChm ys_sfChq] \u [] go_sfChm ys_sfChq;
                        } in  GHC.Base.mappend $dMonoid_sfChj y_sfChp sat_sfChr;
                  };
        } in  go_sfChm eta_sfChk;

Data.Semigroup.$fMonoidWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Base.Monoid (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(A,U,U,A)>m] =
    [] \r [$dMonoid_sfChs]
        let {
          sat_sfChw [Occ=Once]
            :: [Data.Semigroup.WrappedMonoid m_afyEb]
               -> Data.Semigroup.WrappedMonoid m_afyEb
          [LclId] =
              [$dMonoid_sfChs] \r [eta_B1]
                  Data.Semigroup.$fMonoidWrappedMonoid_$cmconcat
                      $dMonoid_sfChs eta_B1; } in
        let {
          sat_sfChv [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyEb
               -> Data.Semigroup.WrappedMonoid m_afyEb
               -> Data.Semigroup.WrappedMonoid m_afyEb
          [LclId] =
              [$dMonoid_sfChs] \u [] GHC.Base.mappend $dMonoid_sfChs; } in
        let {
          sat_sfChu [Occ=Once] :: Data.Semigroup.WrappedMonoid m_afyEb
          [LclId] =
              [$dMonoid_sfChs] \u [] GHC.Base.mempty $dMonoid_sfChs; } in
        let {
          sat_sfCht [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m_afyEb)
          [LclId] =
              [$dMonoid_sfChs] \u []
                  Data.Semigroup.$fSemigroupWrappedMonoid $dMonoid_sfChs;
        } in  GHC.Base.C:Monoid [sat_sfCht sat_sfChu sat_sfChv sat_sfChw];

Data.Semigroup.$fFunctorOption1
  :: forall a b. a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sfChx ds1_sfChy]
        case ds1_sfChy of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Base.Just [x_sfChx];
        };

Data.Semigroup.$fFunctorOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       Data.Semigroup.$fFunctorOption1];

Data.Semigroup.$fApplicativeOption_$c*>
  :: forall a b.
     Data.Semigroup.Option a
     -> Data.Semigroup.Option b -> Data.Semigroup.Option b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfChB ds1_sfChC]
        case ds_sfChB of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> ds1_sfChC;
        };

Data.Semigroup.$fApplicativeOption1
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfChF ds1_sfChG]
        case ds_sfChF of wild_sfChH {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] ->
              case ds1_sfChG of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just _ [Occ=Dead] -> wild_sfChH;
              };
        };

Data.Semigroup.$fApplicativeOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorOption
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           Data.Semigroup.$fApplicativeOption_$c*>
                                           Data.Semigroup.$fApplicativeOption1];

Data.Semigroup.$fMonadOption_$c>>=
  :: forall a b.
     Data.Semigroup.Option a
     -> (a -> Data.Semigroup.Option b) -> Data.Semigroup.Option b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfChL k_sfChM]
        case ds_sfChL of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_sfChO [Occ=Once] -> k_sfChM a1_sfChO;
        };

lvl6_rfC6c :: forall a. [GHC.Types.Char] -> Data.Semigroup.Option a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfChP] GHC.Err.errorWithoutStackTrace eta_sfChP;

Data.Semigroup.$fMonadOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeOption
                                     Data.Semigroup.$fMonadOption_$c>>=
                                     Data.Semigroup.$fApplicativeOption_$c*>
                                     GHC.Base.Just
                                     lvl6_rfC6c];

Data.Semigroup.$fAlternativeOption_$c<|>
  :: forall a.
     Data.Semigroup.Option a
     -> Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfChQ b_sfChR]
        case ds_sfChQ of wild_sfChS {
          GHC.Base.Nothing -> b_sfChR;
          GHC.Base.Just _ [Occ=Dead] -> wild_sfChS;
        };

Data.Semigroup.$fAlternativeOption_$csome
  :: forall a. Data.Semigroup.Option a -> Data.Semigroup.Option [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sfChU]
        let {
          some_v_sfChV [Occ=LoopBreaker] :: GHC.Base.Maybe [a_afyAE]
          [LclId] =
              [v_sfChU some_v_sfChV] \u []
                  case v_sfChU of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sfChX [Occ=Once*] ->
                        case some_v_sfChV of {
                          GHC.Base.Nothing ->
                              let {
                                sat_sfChZ [Occ=Once] :: [a_afyAE]
                                [LclId] =
                                    CCCS :! [x_sfChX GHC.Types.[]];
                              } in  GHC.Base.Just [sat_sfChZ];
                          GHC.Base.Just ipv_sfCi0 [Occ=Once] ->
                              let {
                                sat_sfCi1 [Occ=Once] :: [a_afyAE]
                                [LclId] =
                                    CCCS :! [x_sfChX ipv_sfCi0];
                              } in  GHC.Base.Just [sat_sfCi1];
                        };
                  };
        } in  some_v_sfChV;

Data.Semigroup.$fAlternativeOption1 :: forall a. GHC.Base.Maybe [a]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [GHC.Types.[]];

Data.Semigroup.$fAlternativeOption_$cmany
  :: forall a. Data.Semigroup.Option a -> Data.Semigroup.Option [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sfCi2]
        let {
          many_v_sfCi3 [Occ=LoopBreaker] :: Data.Semigroup.Option [a_afyAM]
          [LclId] =
              [v_sfCi2 many_v_sfCi3] \u []
                  case v_sfCi2 of {
                    GHC.Base.Nothing -> Data.Semigroup.$fAlternativeOption1;
                    GHC.Base.Just x_sfCi5 [Occ=Once] ->
                        case many_v_sfCi3 of {
                          GHC.Base.Nothing -> Data.Semigroup.$fAlternativeOption1;
                          GHC.Base.Just y_sfCi7 [Occ=Once] ->
                              let {
                                sat_sfCi8 [Occ=Once] :: [a_afyAM]
                                [LclId] =
                                    CCCS :! [x_sfCi5 y_sfCi7];
                              } in  GHC.Base.Just [sat_sfCi8];
                        };
                  };
        } in  many_v_sfCi3;

Data.Semigroup.$fAlternativeOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Data.Semigroup.$fApplicativeOption
                                           GHC.Base.Nothing
                                           Data.Semigroup.$fAlternativeOption_$c<|>
                                           Data.Semigroup.$fAlternativeOption_$csome
                                           Data.Semigroup.$fAlternativeOption_$cmany];

Data.Semigroup.$fMonadPlusOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Data.Semigroup.$fAlternativeOption
                                         Data.Semigroup.$fMonadOption
                                         GHC.Base.Nothing
                                         Data.Semigroup.$fAlternativeOption_$c<|>];

Data.Semigroup.$fFoldableOption_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Option a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCi9 f_sfCia ds_sfCib]
        case ds_sfCib of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_sfCi9;
          GHC.Base.Just m1_sfCid [Occ=Once] -> f_sfCia m1_sfCid;
        };

Data.Semigroup.$fFoldableOption_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Semigroup.Option m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCie ds_sfCif]
        case ds_sfCif of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_sfCie;
          GHC.Base.Just m1_sfCih [Occ=Once] -> m1_sfCih;
        };

Data.Semigroup.$fFoldableOption2
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Option a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfCii ds_sfCij]
        case ds_sfCij of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_sfCii;
          GHC.Base.Just m_sfCil [Occ=Once] -> m_sfCil;
        };

lvl7_rfC6d :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Semigroup.$fFoldableOption4 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl7_rfC6d of sat_sfCim {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfCim;
        };

Data.Semigroup.$fFoldableOption3
  :: forall a. Data.Semigroup.Option a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCin]
        case x_sfCin of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption4;
          GHC.Base.Just v_sfCip [Occ=Once] -> v_sfCip;
        };

Data.Semigroup.$fFoldableOption_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sfCiq eta_B1] Data.Semigroup.$fFoldableOption3 eta_B1;

lvl8_rfC6e :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Semigroup.$fFoldableOption6 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl8_rfC6e of sat_sfCir {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfCir;
        };

Data.Semigroup.$fFoldableOption5
  :: forall a. Data.Semigroup.Option a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCis]
        case x_sfCis of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption6;
          GHC.Base.Just v_sfCiu [Occ=Once] -> v_sfCiu;
        };

Data.Semigroup.$fFoldableOption_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sfCiv eta_B1] Data.Semigroup.$fFoldableOption5 eta_B1;

Data.Semigroup.$fFoldableOption_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Option a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfCiw eta_sfCix]
        let {
          f_sfCiy [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afyyC -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCiw eta_sfCix] \u []
                  GHC.Classes.== $dEq_sfCiw eta_sfCix; } in
        let {
          sat_sfCiC [Occ=Once]
            :: Data.Semigroup.Option a_afyyC -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_sfCiy] \r [ds_sfCiz]
                  case ds_sfCiz of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just m_sfCiB [Occ=Once] -> f_sfCiy m_sfCiB;
                  };
        } in  sat_sfCiC;

Data.Semigroup.$fFoldableOption7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Semigroup.$fFoldableOption_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfCiD z_sfCiE t1_sfCiF]
        case t1_sfCiF of {
          GHC.Base.Nothing -> z_sfCiE;
          GHC.Base.Just m_sfCiH [Occ=Once] -> f_sfCiD z_sfCiE m_sfCiH;
        };

lvl9_rfC6f :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Semigroup.$fFoldableOption8 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl9_rfC6f of sat_sfCiI {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfCiI;
        };

Data.Semigroup.$fFoldableOption_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sfCiJ xs_sfCiK]
        case xs_sfCiK of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption8;
          GHC.Base.Just m_sfCiM [Occ=Once] -> m_sfCiM;
        };

Data.Semigroup.$fFoldableOption_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfCiN z0_sfCiO xs_sfCiP]
        case xs_sfCiP of {
          GHC.Base.Nothing -> z0_sfCiO;
          GHC.Base.Just m_sfCiR [Occ=Once] -> f_sfCiN m_sfCiR z0_sfCiO;
        };

Data.Semigroup.$fFoldableOption_$clength
  :: forall a. Data.Semigroup.Option a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_sfCiS]
        case xs_sfCiS of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption7;
          GHC.Base.Just _ [Occ=Dead] -> Data.Semigroup.$fFoldableFirst3;
        };

lvl10_rfC6g :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Semigroup.$fFoldableOption9 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl10_rfC6g of sat_sfCiV {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfCiV;
        };

Data.Semigroup.$fFoldableOption_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sfCiW xs_sfCiX]
        case xs_sfCiX of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption9;
          GHC.Base.Just m_sfCiZ [Occ=Once] -> m_sfCiZ;
        };

Data.Semigroup.$fFoldableOption_$cnull
  :: forall a. Data.Semigroup.Option a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [t1_sfCj0]
        case t1_sfCj0 of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Semigroup.$fFoldableOption1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Option a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfCj3 ds_sfCj4]
        case ds_sfCj4 of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_sfCj3;
          GHC.Base.Just m_sfCj6 [Occ=Once] -> m_sfCj6;
        };

Data.Semigroup.$fFoldableOption_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Option a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_sfCj7]
        case eta_sfCj7 of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just m_sfCj9 [Occ=Once] -> : [m_sfCj9 GHC.Types.[]];
        };

Data.Semigroup.$fFoldableOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Option
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableOption_$cfold
                                             Data.Semigroup.$fFoldableOption_$cfoldMap
                                             Data.Semigroup.$fFoldableOption_$cfoldr'
                                             Data.Semigroup.$fFoldableOption_$cfoldr'
                                             Data.Semigroup.$fFoldableOption_$cfoldl
                                             Data.Semigroup.$fFoldableOption_$cfoldl
                                             Data.Semigroup.$fFoldableOption_$cfoldr1
                                             Data.Semigroup.$fFoldableOption_$cfoldl1
                                             Data.Semigroup.$fFoldableOption_$ctoList
                                             Data.Semigroup.$fFoldableOption_$cnull
                                             Data.Semigroup.$fFoldableOption_$clength
                                             Data.Semigroup.$fFoldableOption_$celem
                                             Data.Semigroup.$fFoldableOption_$cmaximum
                                             Data.Semigroup.$fFoldableOption_$cminimum
                                             Data.Semigroup.$fFoldableOption2
                                             Data.Semigroup.$fFoldableOption1];

Data.Semigroup.$fTraversableOption_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Option a -> f (Data.Semigroup.Option b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCja eta_sfCjb eta1_sfCjc]
        case eta1_sfCjc of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sfCja GHC.Base.Nothing;
          GHC.Base.Just a1_sfCje [Occ=Once] ->
              let {
                sat_sfCjg [Occ=Once] :: f_afyvr b_afyvt
                [LclId] =
                    [eta_sfCjb a1_sfCje] \u [] eta_sfCjb a1_sfCje;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfCja of sat_sfCjf {
                  __DEFAULT -> GHC.Base.fmap sat_sfCjf GHC.Base.Just sat_sfCjg;
                };
        };

Data.Semigroup.$fTraversableOption_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Option (f a) -> f (Data.Semigroup.Option a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCjh eta_sfCji]
        case eta_sfCji of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sfCjh GHC.Base.Nothing;
          GHC.Base.Just a1_sfCjk [Occ=Once] ->
              case GHC.Base.$p1Applicative $dApplicative_sfCjh of sat_sfCjl {
                __DEFAULT -> GHC.Base.fmap sat_sfCjl GHC.Base.Just a1_sfCjk;
              };
        };

Data.Semigroup.$fTraversableOption_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCjm eta_sfCjn eta1_sfCjo]
        case GHC.Base.$p1Monad $dMonad_sfCjm of sat_sfCjp {
          __DEFAULT ->
              Data.Semigroup.$fTraversableOption_$ctraverse
                  sat_sfCjp eta_sfCjn eta1_sfCjo;
        };

Data.Semigroup.$fTraversableOption_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Option (m a) -> m (Data.Semigroup.Option a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCjq eta_sfCjr]
        case eta_sfCjr of {
          GHC.Base.Nothing ->
              case GHC.Base.$p1Monad $dMonad_sfCjq of sat_sfCjt {
                __DEFAULT -> GHC.Base.pure sat_sfCjt GHC.Base.Nothing;
              };
          GHC.Base.Just a1_sfCju [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sfCjq of sat_sfCjv {
                __DEFAULT ->
                    case GHC.Base.$p1Applicative sat_sfCjv of sat_sfCjw {
                      __DEFAULT -> GHC.Base.fmap sat_sfCjw GHC.Base.Just a1_sfCju;
                    };
              };
        };

Data.Semigroup.$fTraversableOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorOption
                                                   Data.Semigroup.$fFoldableOption
                                                   Data.Semigroup.$fTraversableOption_$ctraverse
                                                   Data.Semigroup.$fTraversableOption_$csequenceA
                                                   Data.Semigroup.$fTraversableOption_$cmapM
                                                   Data.Semigroup.$fTraversableOption_$csequence];

lvl11_rfC6h :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: Option, negative multiplier"#;

Data.Semigroup.$fSemigroupOption1
  :: forall a. Data.Semigroup.Option a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl11_rfC6h of sat_sfCjx {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfCjx;
        };

Data.Semigroup.$fSemigroupOption2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Semigroup.$fSemigroupOption_$cstimes
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,U(U(U(U,U,U,U,U,U,U),U(U,U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfCjy $dIntegral_sfCjz eta_sfCjA eta1_sfCjB]
        case eta1_sfCjB of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_sfCjD [Occ=Once] ->
              case
                  GHC.Real.$p1Integral $dIntegral_sfCjz
              of
              $dReal_sfCjE [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      sat_sfCjH [Occ=Once] :: b_afyuS
                      [LclId] =
                          [$dReal_sfCjE] \u []
                              case GHC.Real.$p1Real $dReal_sfCjE of sat_sfCjG {
                                __DEFAULT ->
                                    GHC.Num.fromInteger sat_sfCjG Data.Semigroup.$fSemigroupOption2;
                              };
                    } in 
                      case GHC.Real.$p2Real $dReal_sfCjE of sat_sfCjF {
                        __DEFAULT ->
                            case GHC.Classes.compare sat_sfCjF eta_sfCjA sat_sfCjH of {
                              GHC.Types.LT -> Data.Semigroup.$fSemigroupOption1;
                              GHC.Types.EQ -> GHC.Base.Nothing [];
                              GHC.Types.GT ->
                                  let {
                                    sat_sfCjJ [Occ=Once] :: a_afyuq
                                    [LclId] =
                                        [$dSemigroup_sfCjy
                                         $dIntegral_sfCjz
                                         eta_sfCjA
                                         a1_sfCjD] \u []
                                            GHC.Base.stimes
                                                $dSemigroup_sfCjy
                                                $dIntegral_sfCjz
                                                eta_sfCjA
                                                a1_sfCjD;
                                  } in  GHC.Base.Just [sat_sfCjJ];
                            };
                      };
              };
        };

Data.Semigroup.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     Data.Semigroup.Option a
     -> [Data.Semigroup.Option a] -> Data.Semigroup.Option a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfCjK ww_sfCjL ww1_sfCjM]
        let {
          go_sfCjN [Occ=LoopBreaker]
            :: Data.Semigroup.Option a_sfBqa
               -> [Data.Semigroup.Option a_sfBqa] -> Data.Semigroup.Option a_sfBqa
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfCjK go_sfCjN] \r [b_sfCjO ds1_sfCjP]
                  case ds1_sfCjP of {
                    [] -> b_sfCjO;
                    : c_sfCjR [Occ=Once*] cs_sfCjS [Occ=Once*] ->
                        case b_sfCjO of wild_sfCjT {
                          GHC.Base.Nothing -> go_sfCjN c_sfCjR cs_sfCjS;
                          GHC.Base.Just ipv_sfCjU [Occ=Once] ->
                              case go_sfCjN c_sfCjR cs_sfCjS of {
                                GHC.Base.Nothing -> wild_sfCjT;
                                GHC.Base.Just ipv1_sfCjW [Occ=Once] ->
                                    let {
                                      sat_sfCjX [Occ=Once] :: a_sfBqa
                                      [LclId] =
                                          [w_sfCjK ipv_sfCjU ipv1_sfCjW] \u []
                                              GHC.Base.<> w_sfCjK ipv_sfCjU ipv1_sfCjW;
                                    } in  GHC.Base.Just [sat_sfCjX];
                              };
                        };
                  };
        } in  go_sfCjN ww_sfCjL ww1_sfCjM;

Data.Semigroup.$fSemigroupOption_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (Data.Semigroup.Option a)
     -> Data.Semigroup.Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfCjY w1_sfCjZ]
        case w1_sfCjZ of {
          GHC.Base.:| ww1_sfCk1 [Occ=Once] ww2_sfCk2 [Occ=Once] ->
              Data.Semigroup.$w$csconcat2 w_sfCjY ww1_sfCk1 ww2_sfCk2;
        };

Data.Semigroup.$fSemigroupOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_sfCk3]
        let {
          sat_sfCk6 [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> Data.Semigroup.Option a_afyuq -> Data.Semigroup.Option a_afyuq
          [LclId] =
              [$dSemigroup_sfCk3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fSemigroupOption_$cstimes
                      $dSemigroup_sfCk3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCk5 [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Option a_afyuq)
               -> Data.Semigroup.Option a_afyuq
          [LclId] =
              [$dSemigroup_sfCk3] \r [eta_B1]
                  Data.Semigroup.$fSemigroupOption_$csconcat
                      $dSemigroup_sfCk3 eta_B1; } in
        let {
          sat_sfCk4 [Occ=Once]
            :: Data.Semigroup.Option a_afyuq
               -> Data.Semigroup.Option a_afyuq -> Data.Semigroup.Option a_afyuq
          [LclId] =
              [$dSemigroup_sfCk3] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_sfCk3 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_sfCk4 sat_sfCk5 sat_sfCk6];

Data.Semigroup.$fMonoidOption_$cmconcat
  :: forall a.
     GHC.Base.Semigroup a =>
     [Data.Semigroup.Option a] -> Data.Semigroup.Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfCk7 eta_sfCk8]
        let {
          go_sfCk9 [Occ=LoopBreaker]
            :: [Data.Semigroup.Option a_XfyO3] -> Data.Semigroup.Option a_XfyO3
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_sfCk7 go_sfCk9] \r [ds_sfCka]
                  case ds_sfCka of {
                    [] -> GHC.Base.Nothing [];
                    : y_sfCkc [Occ=Once] ys_sfCkd [Occ=Once*] ->
                        case y_sfCkc of wild1_sfCke {
                          GHC.Base.Nothing -> go_sfCk9 ys_sfCkd;
                          GHC.Base.Just ipv_sfCkf [Occ=Once] ->
                              case go_sfCk9 ys_sfCkd of {
                                GHC.Base.Nothing -> wild1_sfCke;
                                GHC.Base.Just ipv1_sfCkh [Occ=Once] ->
                                    let {
                                      sat_sfCki [Occ=Once] :: a_XfyO3
                                      [LclId] =
                                          [$dSemigroup_sfCk7 ipv_sfCkf ipv1_sfCkh] \u []
                                              GHC.Base.<> $dSemigroup_sfCk7 ipv_sfCkf ipv1_sfCkh;
                                    } in  GHC.Base.Just [sat_sfCki];
                              };
                        };
                  };
        } in  go_sfCk9 eta_sfCk8;

Data.Semigroup.$fMonoidOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Monoid (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_sfCkj]
        let {
          sat_sfCkm [Occ=Once]
            :: [Data.Semigroup.Option a_XfyO1] -> Data.Semigroup.Option a_XfyO1
          [LclId] =
              [$dSemigroup_sfCkj] \r [eta_B1]
                  Data.Semigroup.$fMonoidOption_$cmconcat
                      $dSemigroup_sfCkj eta_B1; } in
        let {
          sat_sfCkl [Occ=Once]
            :: Data.Semigroup.Option a_XfyO1
               -> Data.Semigroup.Option a_XfyO1 -> Data.Semigroup.Option a_XfyO1
          [LclId] =
              [$dSemigroup_sfCkj] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_sfCkj eta_B2 eta_B1; } in
        let {
          sat_sfCkk [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Option a_XfyO1)
          [LclId] =
              [$dSemigroup_sfCkj] \u []
                  Data.Semigroup.$fSemigroupOption $dSemigroup_sfCkj;
        } in 
          GHC.Base.C:Monoid [sat_sfCkk GHC.Base.Nothing sat_sfCkl sat_sfCkm];

Data.Semigroup.$fGeneric1Option1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Option a
     -> GHC.Generics.Rep1 Data.Semigroup.Option a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCkn] ds_sfCkn;

Data.Semigroup.$fGeneric1Option2
  :: forall a. Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCko] x_sfCko;

Data.Semigroup.$fGeneric1Option [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Option2
                                            Data.Semigroup.$fGeneric1Option1];

Data.Semigroup.$fGenericOption1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Option a) x
     -> GHC.Generics.Rep (Data.Semigroup.Option a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCkp] ds_sfCkp;

Data.Semigroup.$fGenericOption2
  :: forall a x. Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfCkq] x1_sfCkq;

Data.Semigroup.$fGenericOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Option a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericOption2
                                           Data.Semigroup.$fGenericOption1];

Data.Semigroup.$fDataOption2
  :: forall a. GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfCkr] v_sfCkr;

Data.Semigroup.$fDataOption_$cgunfold
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCks]
        let {
          $dData1_sfCkt [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_afyoV)
          [LclId] =
              [$dData_sfCks] \u [] Data.Data.$fDataMaybe $dData_sfCks; } in
        let {
          sat_sfCky [Occ=OnceT[0]]
            :: (forall b r. Data.Data.Data b => c_afypf (b -> r) -> c_afypf r)
               -> (forall r. r -> c_afypf r)
               -> Data.Data.Constr
               -> c_afypf (Data.Semigroup.Option a_afyoV)
          [LclId] =
              [$dData1_sfCkt] \r [k_sfCku z_sfCkv ds_sfCkw]
                  let {
                    sat_sfCkx [Occ=Once]
                      :: c_afypf (GHC.Base.Maybe a_afyoV
                                  -> Data.Semigroup.Option a_afyoV)
                    [LclId] =
                        [z_sfCkv] \u [] z_sfCkv Data.Semigroup.$fDataOption2;
                  } in  k_sfCku $dData1_sfCkt sat_sfCkx;
        } in  sat_sfCky;

Data.Semigroup.$fDataOption_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Option a
     -> c (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCkz]
        let {
          $dData1_sfCkA [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_afyoV)
          [LclId] =
              [$dData_sfCkz] \u [] Data.Data.$fDataMaybe $dData_sfCkz; } in
        let {
          sat_sfCkF [Occ=OnceT[0]]
            :: (forall d b.
                Data.Data.Data d =>
                c_afyp4 (d -> b) -> d -> c_afyp4 b)
               -> (forall g. g -> c_afyp4 g)
               -> Data.Semigroup.Option a_afyoV
               -> c_afyp4 (Data.Semigroup.Option a_afyoV)
          [LclId] =
              [$dData1_sfCkA] \r [k_sfCkB z_sfCkC ds_sfCkD]
                  let {
                    sat_sfCkE [Occ=Once]
                      :: c_afyp4 (GHC.Base.Maybe a_afyoV
                                  -> Data.Semigroup.Option a_afyoV)
                    [LclId] =
                        [z_sfCkC] \u [] z_sfCkC Data.Semigroup.$fDataOption2;
                  } in  k_sfCkB $dData1_sfCkA sat_sfCkE ds_sfCkD;
        } in  sat_sfCkF;

Data.Semigroup.$fDataOption6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Option"#;

Data.Semigroup.$fDataOption9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataOption6;

Data.Semigroup.$fReadOption_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataOption9];

Data.Semigroup.$fReadFirst8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Data.Semigroup.$fReadFirst7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadFirst8;

Data.Semigroup.$fReadFirst_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.$fReadFirst7];

Data.Semigroup.$fReadOption3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getOption"#;

Data.Semigroup.$fReadOption2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadOption3;

Data.Semigroup.$fReadArg2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Semigroup.$fReadFirst4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Data.Semigroup.$fReadFirst3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadFirst4;

Data.Semigroup.$fReadFirst2 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.$fReadFirst3];

Data.Semigroup.$fReadOption1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Option a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfCkG eta_sfCkH eta1_sfCkI]
        let {
          ds_sfCkJ [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (GHC.Base.Maybe a_afyo6 -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
              [$dRead_sfCkG] \r [ds1_sfCkK eta2_sfCkL]
                  GHC.Read.$fReadMaybe1
                      $dRead_sfCkG
                      Text.ParserCombinators.ReadPrec.minPrec
                      eta2_sfCkL; } in
        let {
          sat_sfCl5 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Option a_afyo6)
          [LclId] =
              [ds_sfCkJ] \r [c_sfCkM eta2_sfCkN]
                  case c_sfCkM of {
                    GHC.Types.I# x_sfCkP [Occ=Once] ->
                        case <=# [x_sfCkP 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCl2 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                [LclId] =
                                    [ds_sfCkJ eta2_sfCkN] \r [a1_sfCkR]
                                        let {
                                          sat_sfCkZ [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                          [LclId] =
                                              [ds_sfCkJ eta2_sfCkN] \r [a2_sfCkS]
                                                  let {
                                                    sat_sfCkY [Occ=Once]
                                                      :: GHC.Base.Maybe a_afyo6
                                                         -> Text.ParserCombinators.ReadP.P b1_i815E
                                                    [LclId] =
                                                        [eta2_sfCkN] \r [a3_sfCkT]
                                                            let {
                                                              sat_sfCkV [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b1_i815E
                                                              [LclId] =
                                                                  [eta2_sfCkN
                                                                   a3_sfCkT] \r [a4_sfCkU]
                                                                      eta2_sfCkN a3_sfCkT;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfCkV
                                                              of
                                                              { Unit# ww1_sfCkX [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfCkX];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadOption2
                                                        ds_sfCkJ
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCkY;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfCkZ
                                          of
                                          { Unit# ww1_sfCl1 [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfCl1];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadOption_lexeme sat_sfCl2
                                of
                                { Unit# ww1_sfCl4 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCl4];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCl5 eta_sfCkH eta1_sfCkI;

Data.Semigroup.$fReadOption_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Option a)
[GblId, Arity=2, Str=<L,U(A,A,C(C1(U)),A)><L,U>, Unf=OtherCon []] =
    [] \r [$dRead_sfCl6 n_sfCl7]
        let {
          sat_sfCl8 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Option a_XfyIB)
          [LclId] =
              [$dRead_sfCl6 n_sfCl7] \u []
                  Data.Semigroup.$fReadOption1
                      $dRead_sfCl6
                      n_sfCl7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCl8;

Data.Semigroup.$fReadOption_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Option a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCl9]
        let {
          sat_sfCla [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Option a_XfyIz)
          [LclId] =
              [$dRead_sfCl9] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadOption1 $dRead_sfCl9 eta_B2 eta_B1;
        } in  GHC.Read.list sat_sfCla;

Data.Semigroup.$fReadOption_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Option a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfClb]
        let {
          sat_sfCld [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Option a_XfyIA]
          [LclId] =
              [$dRead_sfClb] \u []
                  let {
                    sat_sfClc [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Option a_XfyIA)
                    [LclId] =
                        [$dRead_sfClb] \r [eta_B2 eta_B1]
                            Data.Semigroup.$fReadOption1 $dRead_sfClb eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sfClc
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCld;

Data.Semigroup.$fReadOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sfCle]
        let {
          sat_sfCli [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Option a_XfyIy]
          [LclId] =
              [$dRead_sfCle] \u []
                  Data.Semigroup.$fReadOption_$creadListPrec $dRead_sfCle; } in
        let {
          sat_sfClh [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Option a_XfyIy)
          [LclId] =
              [$dRead_sfCle] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadOption1 $dRead_sfCle eta_B2 eta_B1; } in
        let {
          sat_sfClg [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Option a_XfyIy]
          [LclId] =
              [$dRead_sfCle] \u []
                  Data.Semigroup.$fReadOption_$creadList $dRead_sfCle; } in
        let {
          sat_sfClf [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Option a_XfyIy)
          [LclId] =
              [$dRead_sfCle] \r [eta_B1]
                  Data.Semigroup.$fReadOption_$creadsPrec $dRead_sfCle eta_B1;
        } in  GHC.Read.C:Read [sat_sfClf sat_sfClg sat_sfClh sat_sfCli];

Data.Semigroup.$fShowOption2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Option {"#;

Data.Semigroup.$fShowOption1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getOption = "#;

Data.Semigroup.$w$cshowsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Option a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfClj ww_sfClk w1_sfCll]
        let {
          f_sfClm [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfClj w1_sfCll] \u []
                  GHC.Show.$fShowMaybe_$cshowsPrec
                      w_sfClj Data.Semigroup.$fFoldableOption7 w1_sfCll;
        } in 
          case >=# [ww_sfClk 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCls [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfClm] \r [x_sfClo]
                          let {
                            sat_sfClr [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfClm x_sfClo] \u []
                                    let {
                                      sat_sfClq [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfClm x_sfClo] \u []
                                              let {
                                                sat_sfClp [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfClo] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfClo;
                                              } in  f_sfClm sat_sfClp;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowOption1 sat_sfClq;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowOption2 sat_sfClr;
                } in  sat_sfCls;
            1# ->
                let {
                  sat_sfClz [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfClm] \r [x_sfClt]
                          let {
                            sat_sfCly [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfClm x_sfClt] \u []
                                    let {
                                      sat_sfClx [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfClm x_sfClt] \u []
                                              let {
                                                sat_sfClw [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfClm x_sfClt] \u []
                                                        let {
                                                          sat_sfClv [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfClt] \u []
                                                                  let {
                                                                    sat_sfClu [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfClt];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfClu;
                                                        } in  f_sfClm sat_sfClv;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowOption1 sat_sfClw;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowOption2 sat_sfClx;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCly];
                } in  sat_sfClz;
          };

Data.Semigroup.$fShowOption_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Option a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfClA w1_sfClB w2_sfClC]
        case w1_sfClB of {
          GHC.Types.I# ww1_sfClE [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec5 w_sfClA ww1_sfClE w2_sfClC;
        };

Data.Semigroup.$fShowOption3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++ GHC.Show.$fShowMaybe4 Data.Semigroup.$fReadFirst3;

Data.Semigroup.$fShowOption_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Option a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfClF x_sfClG]
        let {
          sat_sfClL [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfClF x_sfClG] \u []
                  let {
                    sat_sfClK [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfClF x_sfClG] \u []
                            case x_sfClG of {
                              GHC.Base.Nothing -> Data.Semigroup.$fShowOption3;
                              GHC.Base.Just b1_sfClI [Occ=Once] ->
                                  let {
                                    sat_sfClJ [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [$dShow_sfClF b1_sfClI] \s []
                                            GHC.Show.showsPrec
                                                $dShow_sfClF
                                                GHC.Show.appPrec1
                                                b1_sfClI
                                                Data.Semigroup.$fReadFirst3;
                                  } in  GHC.Base.++ GHC.Show.$fShowMaybe1 sat_sfClJ;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowOption1 sat_sfClK;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowOption2 sat_sfClL;

Data.Semigroup.$fShowOption_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Option a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfClM ls_sfClN s_sfClO]
        let {
          sat_sfClQ [Occ=Once]
            :: Data.Semigroup.Option a_afynB -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfClM] \r [w_sfClP]
                  Data.Semigroup.$w$cshowsPrec5 $dShow_sfClM 0# w_sfClP;
        } in  GHC.Show.showList__ sat_sfClQ ls_sfClN s_sfClO;

Data.Semigroup.$fShowOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfClR]
        let {
          sat_sfClU [Occ=Once]
            :: [Data.Semigroup.Option a_afynB] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfClR] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowOption_$cshowList
                      $dShow_sfClR eta_B2 eta_B1; } in
        let {
          sat_sfClT [Occ=Once]
            :: Data.Semigroup.Option a_afynB -> GHC.Base.String
          [LclId] =
              [$dShow_sfClR] \r [eta_B1]
                  Data.Semigroup.$fShowOption_$cshow $dShow_sfClR eta_B1; } in
        let {
          sat_sfClS [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Option a_afynB -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfClR] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowOption_$cshowsPrec $dShow_sfClR eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfClS sat_sfClT sat_sfClU];

Data.Semigroup.$fEqOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sfClV]
        let {
          sat_sfClX [Occ=Once]
            :: Data.Semigroup.Option a_afyle
               -> Data.Semigroup.Option a_afyle -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfClV] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_sfClV eta_B2 eta_B1; } in
        let {
          sat_sfClW [Occ=Once]
            :: Data.Semigroup.Option a_afyle
               -> Data.Semigroup.Option a_afyle -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfClV] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_sfClV eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sfClW sat_sfClX];

Data.Semigroup.$fOrdOption_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfClY]
        let {
          sat_sfClZ [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_XfyGz
          [LclId] =
              [$dOrd_sfClY] \u [] GHC.Classes.$p1Ord $dOrd_sfClY;
        } in  Data.Semigroup.$fEqOption sat_sfClZ;

Data.Semigroup.$fOrdOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Option a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_sfCm0]
        let {
          sat_sfCma [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> Data.Semigroup.Option a_XfyGA
          [LclId] =
              [$dOrd_sfCm0] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_sfCm0 eta_B2 eta_B1; } in
        let {
          sat_sfCm9 [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> Data.Semigroup.Option a_XfyGA
          [LclId] =
              [$dOrd_sfCm0] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_sfCm0 eta_B2 eta_B1; } in
        let {
          sat_sfCm8 [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCm0] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_sfCm0 eta_B2 eta_B1; } in
        let {
          sat_sfCm7 [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCm0] \r [a1_sfCm5 b_sfCm6]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_sfCm0 b_sfCm6 a1_sfCm5; } in
        let {
          sat_sfCm4 [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCm0] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_sfCm0 eta_B2 eta_B1; } in
        let {
          sat_sfCm3 [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCm0] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_sfCm0 eta_B2 eta_B1; } in
        let {
          sat_sfCm2 [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCm0] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_sfCm0 eta_B2 eta_B1; } in
        let {
          sat_sfCm1 [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Option a_XfyGA)
          [LclId] =
              [$dOrd_sfCm0] \u [] Data.Semigroup.$fOrdOption_$cp1Ord $dOrd_sfCm0;
        } in 
          GHC.Classes.C:Ord [sat_sfCm1
                             sat_sfCm2
                             sat_sfCm3
                             sat_sfCm4
                             sat_sfCm7
                             sat_sfCm8
                             sat_sfCm9
                             sat_sfCma];

Data.Semigroup.$fGeneric1WrappedMonoid1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.WrappedMonoid a
     -> GHC.Generics.Rep1 Data.Semigroup.WrappedMonoid a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCmb] ds_sfCmb;

Data.Semigroup.$fGeneric1WrappedMonoid2
  :: forall a.
     Data.Semigroup.WrappedMonoid a -> Data.Semigroup.WrappedMonoid a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCmc] x_sfCmc;

Data.Semigroup.$fGeneric1WrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.WrappedMonoid
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1WrappedMonoid2
                                            Data.Semigroup.$fGeneric1WrappedMonoid1];

Data.Semigroup.$fGenericWrappedMonoid1
  :: forall m x.
     GHC.Generics.Rep (Data.Semigroup.WrappedMonoid m) x
     -> GHC.Generics.Rep (Data.Semigroup.WrappedMonoid m) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCmd] ds_sfCmd;

Data.Semigroup.$fGenericWrappedMonoid2
  :: forall m x.
     Data.Semigroup.WrappedMonoid m -> Data.Semigroup.WrappedMonoid m
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfCme] x1_sfCme;

Data.Semigroup.$fGenericWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. GHC.Generics.Generic (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericWrappedMonoid2
                                           Data.Semigroup.$fGenericWrappedMonoid1];

Data.Semigroup.$fDataWrappedMonoid_$cgfoldl
  :: forall m.
     Data.Data.Data m =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.WrappedMonoid m
     -> c (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCmf k_sfCmg z_sfCmh ds_sfCmi]
        let {
          sat_sfCmj [Occ=Once]
            :: c_afygk (m_afygb -> Data.Semigroup.WrappedMonoid m_afygb)
          [LclId] =
              [z_sfCmh] \u [] z_sfCmh Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfCmg $dData_sfCmf sat_sfCmj ds_sfCmi;

Data.Semigroup.$fReadWrappedMonoid5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrapMonoid"#;

Data.Semigroup.$fReadWrappedMonoid4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.$fReadWrappedMonoid5;

Data.Semigroup.$fReadWrappedMonoid_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fReadWrappedMonoid4];

Data.Semigroup.$fReadWrappedMonoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "unwrapMonoid"#;

Data.Semigroup.$fReadWrappedMonoid2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.$fReadWrappedMonoid3;

Data.Semigroup.$fReadWrappedMonoid1
  :: forall m.
     GHC.Read.Read m =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.WrappedMonoid m
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCmk]
        let {
          lvl33_sfCml [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP m_afyfm
          [LclId] =
              [$dRead_sfCmk] \u []
                  GHC.Read.readPrec
                      $dRead_sfCmk Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfCmm [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP m_afyfm
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfCml] \r [ds1_sfCmn] lvl33_sfCml; } in
        let {
          sat_sfCmH [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.WrappedMonoid m_afyfm)
          [LclId] =
              [ds_sfCmm] \r [c_sfCmo eta_sfCmp]
                  case c_sfCmo of {
                    GHC.Types.I# x_sfCmr [Occ=Once] ->
                        case <=# [x_sfCmr 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCmE [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfCmm eta_sfCmp] \r [a1_sfCmt]
                                        let {
                                          sat_sfCmB [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfCmm eta_sfCmp] \r [a2_sfCmu]
                                                  let {
                                                    sat_sfCmA [Occ=Once]
                                                      :: m_afyfm
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfCmp] \r [a3_sfCmv]
                                                            let {
                                                              sat_sfCmx [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfCmp a3_sfCmv] \r [a4_sfCmw]
                                                                      eta_sfCmp a3_sfCmv;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfCmx
                                                              of
                                                              { Unit# ww1_sfCmz [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfCmz];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadWrappedMonoid2
                                                        ds_sfCmm
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCmA;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfCmB
                                          of
                                          { Unit# ww1_sfCmD [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfCmD];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadWrappedMonoid_lexeme sat_sfCmE
                                of
                                { Unit# ww1_sfCmG [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCmG];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCmH;

Data.Semigroup.$fReadWrappedMonoid_$creadsPrec
  :: forall m.
     GHC.Read.Read m =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.WrappedMonoid m)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCmI]
        let {
          ds_sfCmJ [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.WrappedMonoid m_XfyAE
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfCmI] \u []
                  Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfCmI; } in
        let {
          sat_sfCmM [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.WrappedMonoid m_XfyAE)
          [LclId] =
              [ds_sfCmJ] \r [n_sfCmK]
                  let {
                    sat_sfCmL [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.WrappedMonoid m_XfyAE)
                    [LclId] =
                        [ds_sfCmJ n_sfCmK] \u []
                            ds_sfCmJ
                                n_sfCmK Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfCmL;
        } in  sat_sfCmM;

Data.Semigroup.$fReadWrappedMonoid_$creadListPrec
  :: forall m.
     GHC.Read.Read m =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.WrappedMonoid m]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCmN]
        let {
          sat_sfCmO [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.WrappedMonoid m_XfyAC)
          [LclId] =
              [$dRead_sfCmN] \s []
                  Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfCmN;
        } in  GHC.Read.list sat_sfCmO;

Data.Semigroup.$fReadWrappedMonoid_$creadList
  :: forall m.
     GHC.Read.Read m =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.WrappedMonoid m]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCmP]
        let {
          sat_sfCmR [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.WrappedMonoid m_XfyAD]
          [LclId] =
              [$dRead_sfCmP] \u []
                  let {
                    sat_sfCmQ [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.WrappedMonoid m_XfyAD)
                    [LclId] =
                        [$dRead_sfCmP] \s []
                            Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfCmP;
                  } in 
                    GHC.Read.list
                        sat_sfCmQ
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCmR;

Data.Semigroup.$fReadWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Read.Read m =>
     GHC.Read.Read (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfCmS]
        let {
          sat_sfCmW [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.WrappedMonoid m_XfyAB]
          [LclId] =
              [$dRead_sfCmS] \u []
                  Data.Semigroup.$fReadWrappedMonoid_$creadListPrec
                      $dRead_sfCmS; } in
        let {
          sat_sfCmV [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.WrappedMonoid m_XfyAB)
          [LclId] =
              [$dRead_sfCmS] \u []
                  Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfCmS; } in
        let {
          sat_sfCmU [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.WrappedMonoid m_XfyAB]
          [LclId] =
              [$dRead_sfCmS] \u []
                  Data.Semigroup.$fReadWrappedMonoid_$creadList $dRead_sfCmS; } in
        let {
          sat_sfCmT [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.WrappedMonoid m_XfyAB)
          [LclId] =
              [$dRead_sfCmS] \u []
                  Data.Semigroup.$fReadWrappedMonoid_$creadsPrec $dRead_sfCmS;
        } in  GHC.Read.C:Read [sat_sfCmT sat_sfCmU sat_sfCmV sat_sfCmW];

Data.Semigroup.$fShowWrappedMonoid2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrapMonoid {"#;

Data.Semigroup.$fShowWrappedMonoid1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "unwrapMonoid = "#;

Data.Semigroup.$w$cshowsPrec6 [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Show.Show m =>
     GHC.Prim.Int# -> Data.Semigroup.WrappedMonoid m -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCmX ww_sfCmY w1_sfCmZ]
        let {
          f_sfCn0 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfCmX w1_sfCmZ] \u []
                  GHC.Show.showsPrec
                      w_sfCmX Data.Semigroup.$fFoldableOption7 w1_sfCmZ;
        } in 
          case >=# [ww_sfCmY 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCn6 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCn0] \r [x_sfCn2]
                          let {
                            sat_sfCn5 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCn0 x_sfCn2] \u []
                                    let {
                                      sat_sfCn4 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCn0 x_sfCn2] \u []
                                              let {
                                                sat_sfCn3 [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfCn2] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfCn2;
                                              } in  f_sfCn0 sat_sfCn3;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowWrappedMonoid1 sat_sfCn4;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowWrappedMonoid2 sat_sfCn5;
                } in  sat_sfCn6;
            1# ->
                let {
                  sat_sfCnd [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCn0] \r [x_sfCn7]
                          let {
                            sat_sfCnc [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCn0 x_sfCn7] \u []
                                    let {
                                      sat_sfCnb [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCn0 x_sfCn7] \u []
                                              let {
                                                sat_sfCna [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfCn0 x_sfCn7] \u []
                                                        let {
                                                          sat_sfCn9 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfCn7] \u []
                                                                  let {
                                                                    sat_sfCn8 [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfCn7];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfCn8;
                                                        } in  f_sfCn0 sat_sfCn9;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowWrappedMonoid1 sat_sfCna;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowWrappedMonoid2 sat_sfCnb;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCnc];
                } in  sat_sfCnd;
          };

Data.Semigroup.$fShowWrappedMonoid_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Show.Show m =>
     GHC.Types.Int -> Data.Semigroup.WrappedMonoid m -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCne w1_sfCnf w2_sfCng]
        case w1_sfCnf of {
          GHC.Types.I# ww1_sfCni [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec6 w_sfCne ww1_sfCni w2_sfCng;
        };

Data.Semigroup.$fShowWrappedMonoid_$cshow
  :: forall m.
     GHC.Show.Show m =>
     Data.Semigroup.WrappedMonoid m -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCnj x_sfCnk]
        let {
          sat_sfCnm [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfCnj x_sfCnk] \u []
                  let {
                    sat_sfCnl [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfCnj x_sfCnk] \u []
                            GHC.Show.showsPrec
                                $dShow_sfCnj
                                Data.Semigroup.$fFoldableOption7
                                x_sfCnk
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowWrappedMonoid1 sat_sfCnl;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowWrappedMonoid2 sat_sfCnm;

Data.Semigroup.$fShowWrappedMonoid_$cshowList
  :: forall m.
     GHC.Show.Show m =>
     [Data.Semigroup.WrappedMonoid m] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCnn ls_sfCno s_sfCnp]
        let {
          sat_sfCnr [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyeR -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCnn] \r [w_sfCnq]
                  Data.Semigroup.$w$cshowsPrec6 $dShow_sfCnn 0# w_sfCnq;
        } in  GHC.Show.showList__ sat_sfCnr ls_sfCno s_sfCnp;

Data.Semigroup.$fShowWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Show.Show m =>
     GHC.Show.Show (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfCns]
        let {
          sat_sfCnv [Occ=Once]
            :: [Data.Semigroup.WrappedMonoid m_afyeR] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCns] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowWrappedMonoid_$cshowList
                      $dShow_sfCns eta_B2 eta_B1; } in
        let {
          sat_sfCnu [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyeR -> GHC.Base.String
          [LclId] =
              [$dShow_sfCns] \r [eta_B1]
                  Data.Semigroup.$fShowWrappedMonoid_$cshow $dShow_sfCns eta_B1; } in
        let {
          sat_sfCnt [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.WrappedMonoid m_afyeR -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCns] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowWrappedMonoid_$cshowsPrec
                      $dShow_sfCns eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfCnt sat_sfCnu sat_sfCnv];

Data.Semigroup.$fEqWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Classes.Eq m =>
     GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfCnw]
        let {
          sat_sfCny [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afycu
               -> Data.Semigroup.WrappedMonoid m_afycu -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCnw] \u [] GHC.Classes./= $dEq_sfCnw; } in
        let {
          sat_sfCnx [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afycu
               -> Data.Semigroup.WrappedMonoid m_afycu -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCnw] \u [] GHC.Classes.== $dEq_sfCnw;
        } in  GHC.Classes.C:Eq [sat_sfCnx sat_sfCny];

Data.Semigroup.$fOrdWrappedMonoid_$cp1Ord
  :: forall m.
     GHC.Classes.Ord m =>
     GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCnz]
        let {
          sat_sfCnA [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq m_afyd2
          [LclId] =
              [$dOrd_sfCnz] \u [] GHC.Classes.$p1Ord $dOrd_sfCnz;
        } in  Data.Semigroup.$fEqWrappedMonoid sat_sfCnA;

Data.Semigroup.$fOrdWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Classes.Ord m =>
     GHC.Classes.Ord (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfCnB]
        let {
          sat_sfCnJ [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.min $dOrd_sfCnB; } in
        let {
          sat_sfCnI [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.max $dOrd_sfCnB; } in
        let {
          sat_sfCnH [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.>= $dOrd_sfCnB; } in
        let {
          sat_sfCnG [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.> $dOrd_sfCnB; } in
        let {
          sat_sfCnF [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.<= $dOrd_sfCnB; } in
        let {
          sat_sfCnE [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.< $dOrd_sfCnB; } in
        let {
          sat_sfCnD [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.compare $dOrd_sfCnB; } in
        let {
          sat_sfCnC [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m_afyd2)
          [LclId] =
              [$dOrd_sfCnB] \u []
                  Data.Semigroup.$fOrdWrappedMonoid_$cp1Ord $dOrd_sfCnB;
        } in 
          GHC.Classes.C:Ord [sat_sfCnC
                             sat_sfCnD
                             sat_sfCnE
                             sat_sfCnF
                             sat_sfCnG
                             sat_sfCnH
                             sat_sfCnI
                             sat_sfCnJ];

Data.Semigroup.$fBoundedWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Enum.Bounded m =>
     GHC.Enum.Bounded (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfCnK]
        let {
          sat_sfCnM [Occ=Once] :: Data.Semigroup.WrappedMonoid m_afycc
          [LclId] =
              [$dBounded_sfCnK] \u [] GHC.Enum.maxBound $dBounded_sfCnK; } in
        let {
          sat_sfCnL [Occ=Once] :: Data.Semigroup.WrappedMonoid m_afycc
          [LclId] =
              [$dBounded_sfCnK] \u [] GHC.Enum.minBound $dBounded_sfCnK;
        } in  GHC.Enum.C:Bounded [sat_sfCnL sat_sfCnM];

Data.Semigroup.$fGeneric1Last1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Last a
     -> GHC.Generics.Rep1 Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCnN] ds_sfCnN;

Data.Semigroup.$fGeneric1Last2
  :: forall a. Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCnO] x_sfCnO;

Data.Semigroup.$fGeneric1Last [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Last2
                                            Data.Semigroup.$fGeneric1Last1];

Data.Semigroup.$fGenericLast1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Last a) x
     -> GHC.Generics.Rep (Data.Semigroup.Last a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCnP] ds_sfCnP;

Data.Semigroup.$fGenericLast2
  :: forall a x. Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfCnQ] x1_sfCnQ;

Data.Semigroup.$fGenericLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Last a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericLast2
                                           Data.Semigroup.$fGenericLast1];

Data.Semigroup.$fDataLast_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Last a
     -> c (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCnR k_sfCnS z_sfCnT ds_sfCnU]
        let {
          sat_sfCnV [Occ=Once]
            :: c_afy7i (a_afy79 -> Data.Semigroup.Last a_afy79)
          [LclId] =
              [z_sfCnT] \u [] z_sfCnT Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfCnS $dData_sfCnR sat_sfCnV ds_sfCnU;

Data.Semigroup.$fDataLast4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last"#;

Data.Semigroup.$fDataLast7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataLast4;

Data.Semigroup.$fReadLast_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataLast7];

Data.Semigroup.$fReadLast3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast"#;

Data.Semigroup.$fReadLast2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadLast3;

Data.Semigroup.$fReadLast1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Last a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCnW]
        let {
          lvl33_sfCnX [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afy6k
          [LclId] =
              [$dRead_sfCnW] \u []
                  GHC.Read.readPrec
                      $dRead_sfCnW Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfCnY [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afy6k
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfCnX] \r [ds1_sfCnZ] lvl33_sfCnX; } in
        let {
          sat_sfCoj [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Last a_afy6k)
          [LclId] =
              [ds_sfCnY] \r [c_sfCo0 eta_sfCo1]
                  case c_sfCo0 of {
                    GHC.Types.I# x_sfCo3 [Occ=Once] ->
                        case <=# [x_sfCo3 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCog [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfCnY eta_sfCo1] \r [a1_sfCo5]
                                        let {
                                          sat_sfCod [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfCnY eta_sfCo1] \r [a2_sfCo6]
                                                  let {
                                                    sat_sfCoc [Occ=Once]
                                                      :: a_afy6k
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfCo1] \r [a3_sfCo7]
                                                            let {
                                                              sat_sfCo9 [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfCo1 a3_sfCo7] \r [a4_sfCo8]
                                                                      eta_sfCo1 a3_sfCo7;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfCo9
                                                              of
                                                              { Unit# ww1_sfCob [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfCob];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadLast2
                                                        ds_sfCnY
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCoc;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfCod
                                          of
                                          { Unit# ww1_sfCof [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfCof];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadLast_lexeme sat_sfCog
                                of
                                { Unit# ww1_sfCoi [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCoi];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCoj;

Data.Semigroup.$fReadLast_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Last a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCok]
        let {
          ds_sfCol [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Last a_Xfysp -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfCok] \u [] Data.Semigroup.$fReadLast1 $dRead_sfCok; } in
        let {
          sat_sfCoo [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Last a_Xfysp)
          [LclId] =
              [ds_sfCol] \r [n_sfCom]
                  let {
                    sat_sfCon [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Last a_Xfysp)
                    [LclId] =
                        [ds_sfCol n_sfCom] \u []
                            ds_sfCol
                                n_sfCom Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfCon;
        } in  sat_sfCoo;

Data.Semigroup.$fReadLast_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Last a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCop]
        let {
          sat_sfCoq [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Last a_Xfysn)
          [LclId] =
              [$dRead_sfCop] \s [] Data.Semigroup.$fReadLast1 $dRead_sfCop;
        } in  GHC.Read.list sat_sfCoq;

Data.Semigroup.$fReadLast_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Last a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCor]
        let {
          sat_sfCot [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Last a_Xfyso]
          [LclId] =
              [$dRead_sfCor] \u []
                  let {
                    sat_sfCos [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Last a_Xfyso)
                    [LclId] =
                        [$dRead_sfCor] \s [] Data.Semigroup.$fReadLast1 $dRead_sfCor;
                  } in 
                    GHC.Read.list
                        sat_sfCos
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCot;

Data.Semigroup.$fReadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfCou]
        let {
          sat_sfCoy [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Last a_Xfysm]
          [LclId] =
              [$dRead_sfCou] \u []
                  Data.Semigroup.$fReadLast_$creadListPrec $dRead_sfCou; } in
        let {
          sat_sfCox [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Last a_Xfysm)
          [LclId] =
              [$dRead_sfCou] \u [] Data.Semigroup.$fReadLast1 $dRead_sfCou; } in
        let {
          sat_sfCow [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Last a_Xfysm]
          [LclId] =
              [$dRead_sfCou] \u []
                  Data.Semigroup.$fReadLast_$creadList $dRead_sfCou; } in
        let {
          sat_sfCov [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Last a_Xfysm)
          [LclId] =
              [$dRead_sfCou] \u []
                  Data.Semigroup.$fReadLast_$creadsPrec $dRead_sfCou;
        } in  GHC.Read.C:Read [sat_sfCov sat_sfCow sat_sfCox sat_sfCoy];

Data.Semigroup.$fShowLast2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last {"#;

Data.Semigroup.$fShowLast1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast = "#;

Data.Semigroup.$w$cshowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCoz ww_sfCoA w1_sfCoB]
        let {
          f_sfCoC [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfCoz w1_sfCoB] \u []
                  GHC.Show.showsPrec
                      w_sfCoz Data.Semigroup.$fFoldableOption7 w1_sfCoB;
        } in 
          case >=# [ww_sfCoA 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCoI [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCoC] \r [x_sfCoE]
                          let {
                            sat_sfCoH [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCoC x_sfCoE] \u []
                                    let {
                                      sat_sfCoG [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCoC x_sfCoE] \u []
                                              let {
                                                sat_sfCoF [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfCoE] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfCoE;
                                              } in  f_sfCoC sat_sfCoF;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowLast1 sat_sfCoG;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowLast2 sat_sfCoH;
                } in  sat_sfCoI;
            1# ->
                let {
                  sat_sfCoP [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCoC] \r [x_sfCoJ]
                          let {
                            sat_sfCoO [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCoC x_sfCoJ] \u []
                                    let {
                                      sat_sfCoN [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCoC x_sfCoJ] \u []
                                              let {
                                                sat_sfCoM [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfCoC x_sfCoJ] \u []
                                                        let {
                                                          sat_sfCoL [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfCoJ] \u []
                                                                  let {
                                                                    sat_sfCoK [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfCoJ];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfCoK;
                                                        } in  f_sfCoC sat_sfCoL;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowLast1 sat_sfCoM;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowLast2 sat_sfCoN;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCoO];
                } in  sat_sfCoP;
          };

Data.Semigroup.$fShowLast_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCoQ w1_sfCoR w2_sfCoS]
        case w1_sfCoR of {
          GHC.Types.I# ww1_sfCoU [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec2 w_sfCoQ ww1_sfCoU w2_sfCoS;
        };

Data.Semigroup.$fShowLast_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Last a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCoV x_sfCoW]
        let {
          sat_sfCoY [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfCoV x_sfCoW] \u []
                  let {
                    sat_sfCoX [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfCoV x_sfCoW] \u []
                            GHC.Show.showsPrec
                                $dShow_sfCoV
                                Data.Semigroup.$fFoldableOption7
                                x_sfCoW
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowLast1 sat_sfCoX;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowLast2 sat_sfCoY;

Data.Semigroup.$fShowLast_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Last a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCoZ ls_sfCp0 s_sfCp1]
        let {
          sat_sfCp3 [Occ=Once]
            :: Data.Semigroup.Last a_afy5P -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCoZ] \r [w_sfCp2]
                  Data.Semigroup.$w$cshowsPrec2 $dShow_sfCoZ 0# w_sfCp2;
        } in  GHC.Show.showList__ sat_sfCp3 ls_sfCp0 s_sfCp1;

Data.Semigroup.$fShowLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfCp4]
        let {
          sat_sfCp7 [Occ=Once]
            :: [Data.Semigroup.Last a_afy5P] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCp4] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowLast_$cshowList
                      $dShow_sfCp4 eta_B2 eta_B1; } in
        let {
          sat_sfCp6 [Occ=Once]
            :: Data.Semigroup.Last a_afy5P -> GHC.Base.String
          [LclId] =
              [$dShow_sfCp4] \r [eta_B1]
                  Data.Semigroup.$fShowLast_$cshow $dShow_sfCp4 eta_B1; } in
        let {
          sat_sfCp5 [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Last a_afy5P -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCp4] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowLast_$cshowsPrec $dShow_sfCp4 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfCp5 sat_sfCp6 sat_sfCp7];

Data.Semigroup.$fEqLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfCp8]
        let {
          sat_sfCpa [Occ=Once]
            :: Data.Semigroup.Last a_afy3s
               -> Data.Semigroup.Last a_afy3s -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCp8] \u [] GHC.Classes./= $dEq_sfCp8; } in
        let {
          sat_sfCp9 [Occ=Once]
            :: Data.Semigroup.Last a_afy3s
               -> Data.Semigroup.Last a_afy3s -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCp8] \u [] GHC.Classes.== $dEq_sfCp8;
        } in  GHC.Classes.C:Eq [sat_sfCp9 sat_sfCpa];

Data.Semigroup.$fOrdLast_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Last a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCpb]
        let {
          sat_sfCpc [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afy40
          [LclId] =
              [$dOrd_sfCpb] \u [] GHC.Classes.$p1Ord $dOrd_sfCpb;
        } in  Data.Semigroup.$fEqLast sat_sfCpc;

Data.Semigroup.$fOrdLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfCpd]
        let {
          sat_sfCpl [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> Data.Semigroup.Last a_afy40
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.min $dOrd_sfCpd; } in
        let {
          sat_sfCpk [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> Data.Semigroup.Last a_afy40
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.max $dOrd_sfCpd; } in
        let {
          sat_sfCpj [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.>= $dOrd_sfCpd; } in
        let {
          sat_sfCpi [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.> $dOrd_sfCpd; } in
        let {
          sat_sfCph [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.<= $dOrd_sfCpd; } in
        let {
          sat_sfCpg [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.< $dOrd_sfCpd; } in
        let {
          sat_sfCpf [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.compare $dOrd_sfCpd; } in
        let {
          sat_sfCpe [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Last a_afy40)
          [LclId] =
              [$dOrd_sfCpd] \u [] Data.Semigroup.$fOrdLast_$cp1Ord $dOrd_sfCpd;
        } in 
          GHC.Classes.C:Ord [sat_sfCpe
                             sat_sfCpf
                             sat_sfCpg
                             sat_sfCph
                             sat_sfCpi
                             sat_sfCpj
                             sat_sfCpk
                             sat_sfCpl];

Data.Semigroup.$fBoundedLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfCpm]
        let {
          sat_sfCpo [Occ=Once] :: Data.Semigroup.Last a_afy3a
          [LclId] =
              [$dBounded_sfCpm] \u [] GHC.Enum.maxBound $dBounded_sfCpm; } in
        let {
          sat_sfCpn [Occ=Once] :: Data.Semigroup.Last a_afy3a
          [LclId] =
              [$dBounded_sfCpm] \u [] GHC.Enum.minBound $dBounded_sfCpm;
        } in  GHC.Enum.C:Bounded [sat_sfCpn sat_sfCpo];

Data.Semigroup.$fGeneric1First1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.First a
     -> GHC.Generics.Rep1 Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCpp] ds_sfCpp;

Data.Semigroup.$fGeneric1First2
  :: forall a. Data.Semigroup.First a -> Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCpq] x_sfCpq;

Data.Semigroup.$fGeneric1First [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1First2
                                            Data.Semigroup.$fGeneric1First1];

Data.Semigroup.$fGenericFirst1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.First a) x
     -> GHC.Generics.Rep (Data.Semigroup.First a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCpr] ds_sfCpr;

Data.Semigroup.$fGenericFirst2
  :: forall a x. Data.Semigroup.First a -> Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfCps] x1_sfCps;

Data.Semigroup.$fGenericFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.First a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericFirst2
                                           Data.Semigroup.$fGenericFirst1];

Data.Semigroup.$fDataFirst_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.First a
     -> c (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCpt k_sfCpu z_sfCpv ds_sfCpw]
        let {
          sat_sfCpx [Occ=Once]
            :: c_afxYg (a_afxY7 -> Data.Semigroup.First a_afxY7)
          [LclId] =
              [z_sfCpv] \u [] z_sfCpv Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfCpu $dData_sfCpt sat_sfCpx ds_sfCpw;

Data.Semigroup.$fDataFirst4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First"#;

Data.Semigroup.$fDataFirst7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataFirst4;

Data.Semigroup.$fReadFirst_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataFirst7];

Data.Semigroup.$fReadFirst6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst"#;

Data.Semigroup.$fReadFirst5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadFirst6;

Data.Semigroup.$fReadFirst1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.First a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCpy]
        let {
          lvl33_sfCpz [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afxXi
          [LclId] =
              [$dRead_sfCpy] \u []
                  GHC.Read.readPrec
                      $dRead_sfCpy Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfCpA [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afxXi
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfCpz] \r [ds1_sfCpB] lvl33_sfCpz; } in
        let {
          sat_sfCpV [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.First a_afxXi)
          [LclId] =
              [ds_sfCpA] \r [c_sfCpC eta_sfCpD]
                  case c_sfCpC of {
                    GHC.Types.I# x_sfCpF [Occ=Once] ->
                        case <=# [x_sfCpF 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCpS [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfCpA eta_sfCpD] \r [a1_sfCpH]
                                        let {
                                          sat_sfCpP [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfCpA eta_sfCpD] \r [a2_sfCpI]
                                                  let {
                                                    sat_sfCpO [Occ=Once]
                                                      :: a_afxXi
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfCpD] \r [a3_sfCpJ]
                                                            let {
                                                              sat_sfCpL [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfCpD a3_sfCpJ] \r [a4_sfCpK]
                                                                      eta_sfCpD a3_sfCpJ;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfCpL
                                                              of
                                                              { Unit# ww1_sfCpN [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfCpN];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadFirst5
                                                        ds_sfCpA
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCpO;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfCpP
                                          of
                                          { Unit# ww1_sfCpR [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfCpR];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadFirst_lexeme1 sat_sfCpS
                                of
                                { Unit# ww1_sfCpU [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCpU];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCpV;

Data.Semigroup.$fReadFirst_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.First a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCpW]
        let {
          ds_sfCpX [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.First a_Xfyka -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfCpW] \u [] Data.Semigroup.$fReadFirst1 $dRead_sfCpW; } in
        let {
          sat_sfCq0 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.First a_Xfyka)
          [LclId] =
              [ds_sfCpX] \r [n_sfCpY]
                  let {
                    sat_sfCpZ [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.First a_Xfyka)
                    [LclId] =
                        [ds_sfCpX n_sfCpY] \u []
                            ds_sfCpX
                                n_sfCpY Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfCpZ;
        } in  sat_sfCq0;

Data.Semigroup.$fReadFirst_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.First a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCq1]
        let {
          sat_sfCq2 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.First a_Xfyk8)
          [LclId] =
              [$dRead_sfCq1] \s [] Data.Semigroup.$fReadFirst1 $dRead_sfCq1;
        } in  GHC.Read.list sat_sfCq2;

Data.Semigroup.$fReadFirst_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.First a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCq3]
        let {
          sat_sfCq5 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.First a_Xfyk9]
          [LclId] =
              [$dRead_sfCq3] \u []
                  let {
                    sat_sfCq4 [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.First a_Xfyk9)
                    [LclId] =
                        [$dRead_sfCq3] \s [] Data.Semigroup.$fReadFirst1 $dRead_sfCq3;
                  } in 
                    GHC.Read.list
                        sat_sfCq4
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCq5;

Data.Semigroup.$fReadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfCq6]
        let {
          sat_sfCqa [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.First a_Xfyk7]
          [LclId] =
              [$dRead_sfCq6] \u []
                  Data.Semigroup.$fReadFirst_$creadListPrec $dRead_sfCq6; } in
        let {
          sat_sfCq9 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.First a_Xfyk7)
          [LclId] =
              [$dRead_sfCq6] \u [] Data.Semigroup.$fReadFirst1 $dRead_sfCq6; } in
        let {
          sat_sfCq8 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.First a_Xfyk7]
          [LclId] =
              [$dRead_sfCq6] \u []
                  Data.Semigroup.$fReadFirst_$creadList $dRead_sfCq6; } in
        let {
          sat_sfCq7 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.First a_Xfyk7)
          [LclId] =
              [$dRead_sfCq6] \u []
                  Data.Semigroup.$fReadFirst_$creadsPrec $dRead_sfCq6;
        } in  GHC.Read.C:Read [sat_sfCq7 sat_sfCq8 sat_sfCq9 sat_sfCqa];

Data.Semigroup.$fShowFirst2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First {"#;

Data.Semigroup.$fShowFirst1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst = "#;

Data.Semigroup.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCqb ww_sfCqc w1_sfCqd]
        let {
          f_sfCqe [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfCqb w1_sfCqd] \u []
                  GHC.Show.showsPrec
                      w_sfCqb Data.Semigroup.$fFoldableOption7 w1_sfCqd;
        } in 
          case >=# [ww_sfCqc 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCqk [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCqe] \r [x_sfCqg]
                          let {
                            sat_sfCqj [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCqe x_sfCqg] \u []
                                    let {
                                      sat_sfCqi [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCqe x_sfCqg] \u []
                                              let {
                                                sat_sfCqh [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfCqg] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfCqg;
                                              } in  f_sfCqe sat_sfCqh;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowFirst1 sat_sfCqi;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowFirst2 sat_sfCqj;
                } in  sat_sfCqk;
            1# ->
                let {
                  sat_sfCqr [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCqe] \r [x_sfCql]
                          let {
                            sat_sfCqq [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCqe x_sfCql] \u []
                                    let {
                                      sat_sfCqp [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCqe x_sfCql] \u []
                                              let {
                                                sat_sfCqo [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfCqe x_sfCql] \u []
                                                        let {
                                                          sat_sfCqn [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfCql] \u []
                                                                  let {
                                                                    sat_sfCqm [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfCql];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfCqm;
                                                        } in  f_sfCqe sat_sfCqn;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowFirst1 sat_sfCqo;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowFirst2 sat_sfCqp;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCqq];
                } in  sat_sfCqr;
          };

Data.Semigroup.$fShowFirst_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCqs w1_sfCqt w2_sfCqu]
        case w1_sfCqt of {
          GHC.Types.I# ww1_sfCqw [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec1 w_sfCqs ww1_sfCqw w2_sfCqu;
        };

Data.Semigroup.$fShowFirst_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.First a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCqx x_sfCqy]
        let {
          sat_sfCqA [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfCqx x_sfCqy] \u []
                  let {
                    sat_sfCqz [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfCqx x_sfCqy] \u []
                            GHC.Show.showsPrec
                                $dShow_sfCqx
                                Data.Semigroup.$fFoldableOption7
                                x_sfCqy
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowFirst1 sat_sfCqz;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowFirst2 sat_sfCqA;

Data.Semigroup.$fShowFirst_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.First a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCqB ls_sfCqC s_sfCqD]
        let {
          sat_sfCqF [Occ=Once]
            :: Data.Semigroup.First a_afxWN -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCqB] \r [w_sfCqE]
                  Data.Semigroup.$w$cshowsPrec1 $dShow_sfCqB 0# w_sfCqE;
        } in  GHC.Show.showList__ sat_sfCqF ls_sfCqC s_sfCqD;

Data.Semigroup.$fShowFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfCqG]
        let {
          sat_sfCqJ [Occ=Once]
            :: [Data.Semigroup.First a_afxWN] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCqG] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowFirst_$cshowList
                      $dShow_sfCqG eta_B2 eta_B1; } in
        let {
          sat_sfCqI [Occ=Once]
            :: Data.Semigroup.First a_afxWN -> GHC.Base.String
          [LclId] =
              [$dShow_sfCqG] \r [eta_B1]
                  Data.Semigroup.$fShowFirst_$cshow $dShow_sfCqG eta_B1; } in
        let {
          sat_sfCqH [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.First a_afxWN -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCqG] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowFirst_$cshowsPrec $dShow_sfCqG eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfCqH sat_sfCqI sat_sfCqJ];

Data.Semigroup.$fEqFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfCqK]
        let {
          sat_sfCqM [Occ=Once]
            :: Data.Semigroup.First a_afxUq
               -> Data.Semigroup.First a_afxUq -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCqK] \u [] GHC.Classes./= $dEq_sfCqK; } in
        let {
          sat_sfCqL [Occ=Once]
            :: Data.Semigroup.First a_afxUq
               -> Data.Semigroup.First a_afxUq -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCqK] \u [] GHC.Classes.== $dEq_sfCqK;
        } in  GHC.Classes.C:Eq [sat_sfCqL sat_sfCqM];

Data.Semigroup.$fOrdFirst_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.First a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCqN]
        let {
          sat_sfCqO [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afxUY
          [LclId] =
              [$dOrd_sfCqN] \u [] GHC.Classes.$p1Ord $dOrd_sfCqN;
        } in  Data.Semigroup.$fEqFirst sat_sfCqO;

Data.Semigroup.$fOrdFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfCqP]
        let {
          sat_sfCqX [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> Data.Semigroup.First a_afxUY
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.min $dOrd_sfCqP; } in
        let {
          sat_sfCqW [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> Data.Semigroup.First a_afxUY
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.max $dOrd_sfCqP; } in
        let {
          sat_sfCqV [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.>= $dOrd_sfCqP; } in
        let {
          sat_sfCqU [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.> $dOrd_sfCqP; } in
        let {
          sat_sfCqT [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.<= $dOrd_sfCqP; } in
        let {
          sat_sfCqS [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.< $dOrd_sfCqP; } in
        let {
          sat_sfCqR [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.compare $dOrd_sfCqP; } in
        let {
          sat_sfCqQ [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.First a_afxUY)
          [LclId] =
              [$dOrd_sfCqP] \u [] Data.Semigroup.$fOrdFirst_$cp1Ord $dOrd_sfCqP;
        } in 
          GHC.Classes.C:Ord [sat_sfCqQ
                             sat_sfCqR
                             sat_sfCqS
                             sat_sfCqT
                             sat_sfCqU
                             sat_sfCqV
                             sat_sfCqW
                             sat_sfCqX];

Data.Semigroup.$fBoundedFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfCqY]
        let {
          sat_sfCr0 [Occ=Once] :: Data.Semigroup.First a_afxU8
          [LclId] =
              [$dBounded_sfCqY] \u [] GHC.Enum.maxBound $dBounded_sfCqY; } in
        let {
          sat_sfCqZ [Occ=Once] :: Data.Semigroup.First a_afxU8
          [LclId] =
              [$dBounded_sfCqY] \u [] GHC.Enum.minBound $dBounded_sfCqY;
        } in  GHC.Enum.C:Bounded [sat_sfCqZ sat_sfCr0];

Data.Semigroup.$fGeneric1Arg_$cto1
  :: forall a1 a2.
     GHC.Generics.Rep1 (Data.Semigroup.Arg a1) a2
     -> Data.Semigroup.Arg a1 a2
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sfCr1]
        case ds_sfCr1 of {
          GHC.Generics.:*: ds1_sfCr3 [Occ=Once] ds2_sfCr4 [Occ=Once] ->
              Data.Semigroup.Arg [ds1_sfCr3 ds2_sfCr4];
        };

Data.Semigroup.$fGeneric1Arg1
  :: forall a1 a2.
     Data.Semigroup.Arg a1 a2
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Arg" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R a1)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              GHC.Generics.Par1)
          a2
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_sfCr5]
        case x_sfCr5 of {
          Data.Semigroup.Arg g1_sfCr7 [Occ=Once] g2_sfCr8 [Occ=Once] ->
              GHC.Generics.:*: [g1_sfCr7 g2_sfCr8];
        };

Data.Semigroup.$fGeneric1Arg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic1 (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Arg1
                                            Data.Semigroup.$fGeneric1Arg_$cto1];

Data.Semigroup.$fGenericArg_$cto
  :: forall a b x.
     GHC.Generics.Rep (Data.Semigroup.Arg a b) x
     -> Data.Semigroup.Arg a b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sfCr9]
        case ds_sfCr9 of {
          GHC.Generics.:*: ds1_sfCrb [Occ=Once] ds2_sfCrc [Occ=Once] ->
              Data.Semigroup.Arg [ds1_sfCrb ds2_sfCrc];
        };

Data.Semigroup.$fGenericArg1
  :: forall a b x.
     Data.Semigroup.Arg a b
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Arg" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R a)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.K1 GHC.Generics.R b))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x1_sfCrd]
        case x1_sfCrd of {
          Data.Semigroup.Arg g1_sfCrf [Occ=Once] g2_sfCrg [Occ=Once] ->
              GHC.Generics.:*: [g1_sfCrf g2_sfCrg];
        };

Data.Semigroup.$fGenericArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. GHC.Generics.Generic (Data.Semigroup.Arg a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericArg1
                                           Data.Semigroup.$fGenericArg_$cto];

Data.Semigroup.$fDataArg_$cgunfold
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (c :: * -> *).
     (forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCrh $dData1_sfCri k_sfCrj z_sfCrk ds_sfCrl]
        let {
          sat_sfCrn [Occ=Once]
            :: c_afxOm (b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
          [LclId] =
              [$dData_sfCrh k_sfCrj z_sfCrk] \u []
                  let {
                    sat_sfCrm [Occ=Once]
                      :: c_afxOm (a_afxNW
                                  -> b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
                    [LclId] =
                        [z_sfCrk] \u [] z_sfCrk Data.Semigroup.Arg;
                  } in  k_sfCrj $dData_sfCrh sat_sfCrm;
        } in  k_sfCrj $dData1_sfCri sat_sfCrn;

Data.Semigroup.$fDataArg_$cgfoldl
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (c :: * -> *).
     (forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Arg a b
     -> c (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCro $dData1_sfCrp k_sfCrq z_sfCrr ds_sfCrs]
        case ds_sfCrs of {
          Data.Semigroup.Arg a1_sfCru [Occ=Once] a2_sfCrv [Occ=Once] ->
              let {
                sat_sfCrx [Occ=Once]
                  :: c_afxO7 (b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
                [LclId] =
                    [$dData_sfCro k_sfCrq z_sfCrr a1_sfCru] \u []
                        let {
                          sat_sfCrw [Occ=Once]
                            :: c_afxO7 (a_afxNW
                                        -> b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
                          [LclId] =
                              [z_sfCrr] \u [] z_sfCrr Data.Semigroup.Arg;
                        } in  k_sfCrq $dData_sfCro sat_sfCrw a1_sfCru;
              } in  k_sfCrq $dData1_sfCrp sat_sfCrx a2_sfCrv;
        };

Data.Semigroup.$fDataArg6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Arg"#;

Data.Semigroup.$fDataArg9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataArg6;

Data.Semigroup.$fReadArg_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataArg9];

Data.Semigroup.$fReadArg1
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Semigroup.Arg a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfCry $dRead1_sfCrz eta_sfCrA eta1_sfCrB]
        let {
          sat_sfCrQ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Arg a_afxN6 b_afxN7)
          [LclId] =
              [$dRead_sfCry $dRead1_sfCrz] \r [c_sfCrC eta2_sfCrD]
                  case c_sfCrC of {
                    GHC.Types.I# x_sfCrF [Occ=Once] ->
                        case <=# [x_sfCrF 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCrN [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b2_i815E
                                [LclId] =
                                    [$dRead_sfCry $dRead1_sfCrz eta2_sfCrD] \r [a1_sfCrH]
                                        let {
                                          sat_sfCrM [Occ=Once]
                                            :: a_afxN6 -> Text.ParserCombinators.ReadP.P b2_i815E
                                          [LclId] =
                                              [$dRead1_sfCrz eta2_sfCrD] \r [a2_sfCrI]
                                                  let {
                                                    sat_sfCrL [Occ=Once]
                                                      :: b_afxN7
                                                         -> Text.ParserCombinators.ReadP.P b2_i815E
                                                    [LclId] =
                                                        [eta2_sfCrD a2_sfCrI] \r [a3_sfCrJ]
                                                            let {
                                                              sat_sfCrK [Occ=Once]
                                                                :: Data.Semigroup.Arg
                                                                     a_afxN6 b_afxN7
                                                              [LclId] =
                                                                  CCCS Data.Semigroup.Arg! [a2_sfCrI
                                                                                            a3_sfCrJ];
                                                            } in  eta2_sfCrD sat_sfCrK;
                                                  } in 
                                                    GHC.Read.readPrec
                                                        $dRead1_sfCrz
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCrL;
                                        } in 
                                          GHC.Read.readPrec
                                              $dRead_sfCry Data.Semigroup.$fReadArg2 sat_sfCrM;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Semigroup.$fReadArg_lexeme sat_sfCrN
                                of
                                { Unit# ww1_sfCrP [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCrP];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCrQ eta_sfCrA eta1_sfCrB;

Data.Semigroup.$fReadArg_$creadsPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Arg a b)
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfCrR $dRead1_sfCrS n_sfCrT]
        let {
          sat_sfCrU [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Semigroup.Arg a_XfyaI b_XfyaK)
          [LclId] =
              [$dRead_sfCrR $dRead1_sfCrS n_sfCrT] \u []
                  Data.Semigroup.$fReadArg1
                      $dRead_sfCrR
                      $dRead1_sfCrS
                      n_sfCrT
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCrU;

Data.Semigroup.$fReadArg_$creadListPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Arg a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfCrV $dRead1_sfCrW]
        let {
          sat_sfCrX [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Arg a_XfyaG b_XfyaI)
          [LclId] =
              [$dRead_sfCrV $dRead1_sfCrW] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadArg1 $dRead_sfCrV $dRead1_sfCrW eta_B2 eta_B1;
        } in  GHC.Read.list sat_sfCrX;

Data.Semigroup.$fReadArg_$creadList
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Arg a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfCrY $dRead1_sfCrZ]
        let {
          sat_sfCs1 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Arg a_XfyaH b_XfyaJ]
          [LclId] =
              [$dRead_sfCrY $dRead1_sfCrZ] \u []
                  let {
                    sat_sfCs0 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Arg a_XfyaH b_XfyaJ)
                    [LclId] =
                        [$dRead_sfCrY $dRead1_sfCrZ] \r [eta_B2 eta_B1]
                            Data.Semigroup.$fReadArg1 $dRead_sfCrY $dRead1_sfCrZ eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sfCs0
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCs1;

Data.Semigroup.$fReadArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Read.Read (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sfCs2 $dRead1_sfCs3]
        let {
          sat_sfCs7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Arg a_XfyaF b_XfyaH]
          [LclId] =
              [$dRead_sfCs2 $dRead1_sfCs3] \u []
                  Data.Semigroup.$fReadArg_$creadListPrec
                      $dRead_sfCs2 $dRead1_sfCs3; } in
        let {
          sat_sfCs6 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Arg a_XfyaF b_XfyaH)
          [LclId] =
              [$dRead_sfCs2 $dRead1_sfCs3] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadArg1
                      $dRead_sfCs2 $dRead1_sfCs3 eta_B2 eta_B1; } in
        let {
          sat_sfCs5 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Arg a_XfyaF b_XfyaH]
          [LclId] =
              [$dRead_sfCs2 $dRead1_sfCs3] \u []
                  Data.Semigroup.$fReadArg_$creadList
                      $dRead_sfCs2 $dRead1_sfCs3; } in
        let {
          sat_sfCs4 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Arg a_XfyaF b_XfyaH)
          [LclId] =
              [$dRead_sfCs2 $dRead1_sfCs3] \r [eta_B1]
                  Data.Semigroup.$fReadArg_$creadsPrec
                      $dRead_sfCs2 $dRead1_sfCs3 eta_B1;
        } in  GHC.Read.C:Read [sat_sfCs4 sat_sfCs5 sat_sfCs6 sat_sfCs7];

Data.Semigroup.$fShowArg1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Arg "#;

Data.Semigroup.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Prim.Int# -> a -> b -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCs8 w1_sfCs9 ww_sfCsa ww1_sfCsb ww2_sfCsc]
        let {
          f_sfCsd [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfCs8 ww1_sfCsb] \u []
                  GHC.Show.showsPrec
                      w_sfCs8 Data.Semigroup.$fReadArg2 ww1_sfCsb; } in
        let {
          g_sfCse [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sfCs9 ww2_sfCsc] \u []
                  GHC.Show.showsPrec w1_sfCs9 Data.Semigroup.$fReadArg2 ww2_sfCsc;
        } in 
          case >=# [ww_sfCsa 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCsk [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCsd g_sfCse] \r [x_sfCsg]
                          let {
                            sat_sfCsj [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCsd g_sfCse x_sfCsg] \u []
                                    let {
                                      sat_sfCsh [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sfCse x_sfCsg] \u [] g_sfCse x_sfCsg; } in
                                    let {
                                      sat_sfCsi [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          CCCS :! [GHC.Show.showSpace1 sat_sfCsh];
                                    } in  f_sfCsd sat_sfCsi;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowArg1 sat_sfCsj;
                } in  sat_sfCsk;
            1# ->
                let {
                  sat_sfCsr [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCsd g_sfCse] \r [x_sfCsl]
                          let {
                            sat_sfCsq [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCsd g_sfCse x_sfCsl] \u []
                                    let {
                                      sat_sfCsp [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCsd g_sfCse x_sfCsl] \u []
                                              let {
                                                sat_sfCsn [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sfCse x_sfCsl] \u []
                                                        let {
                                                          sat_sfCsm [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sfCsl];
                                                        } in  g_sfCse sat_sfCsm; } in
                                              let {
                                                sat_sfCso [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.showSpace1 sat_sfCsn];
                                              } in  f_sfCsd sat_sfCso;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowArg1 sat_sfCsp;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCsq];
                } in  sat_sfCsr;
          };

Data.Semigroup.$fShowArg_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Types.Int -> Data.Semigroup.Arg a b -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sfCss w1_sfCst w2_sfCsu w3_sfCsv]
        case w2_sfCsu of {
          GHC.Types.I# ww1_sfCsx [Occ=Once] ->
              case w3_sfCsv of {
                Data.Semigroup.Arg ww3_sfCsz [Occ=Once] ww4_sfCsA [Occ=Once] ->
                    Data.Semigroup.$w$cshowsPrec
                        w_sfCss w1_sfCst ww1_sfCsx ww3_sfCsz ww4_sfCsA;
              };
        };

Data.Semigroup.$fShowArg_$cshow
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     Data.Semigroup.Arg a b -> GHC.Base.String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCsB $dShow1_sfCsC x_sfCsD]
        case x_sfCsD of {
          Data.Semigroup.Arg ww1_sfCsF [Occ=Once] ww2_sfCsG [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec
                  $dShow_sfCsB $dShow1_sfCsC 0# ww1_sfCsF ww2_sfCsG GHC.Types.[];
        };

Data.Semigroup.$fShowArg_$cshowList
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     [Data.Semigroup.Arg a b] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCsH $dShow1_sfCsI ls_sfCsJ s_sfCsK]
        let {
          sat_sfCsP [Occ=Once]
            :: Data.Semigroup.Arg a_afxMx b_afxMy -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCsH $dShow1_sfCsI] \r [w_sfCsL]
                  case w_sfCsL of {
                    Data.Semigroup.Arg ww1_sfCsN [Occ=Once] ww2_sfCsO [Occ=Once] ->
                        Data.Semigroup.$w$cshowsPrec
                            $dShow_sfCsH $dShow1_sfCsI 0# ww1_sfCsN ww2_sfCsO;
                  };
        } in  GHC.Show.showList__ sat_sfCsP ls_sfCsJ s_sfCsK;

Data.Semigroup.$fShowArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Show.Show (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfCsQ $dShow1_sfCsR]
        let {
          sat_sfCsU [Occ=Once]
            :: [Data.Semigroup.Arg a_afxMx b_afxMy] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCsQ $dShow1_sfCsR] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowArg_$cshowList
                      $dShow_sfCsQ $dShow1_sfCsR eta_B2 eta_B1; } in
        let {
          sat_sfCsT [Occ=Once]
            :: Data.Semigroup.Arg a_afxMx b_afxMy -> GHC.Base.String
          [LclId] =
              [$dShow_sfCsQ $dShow1_sfCsR] \r [eta_B1]
                  Data.Semigroup.$fShowArg_$cshow
                      $dShow_sfCsQ $dShow1_sfCsR eta_B1; } in
        let {
          sat_sfCsS [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Arg a_afxMx b_afxMy -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCsQ $dShow1_sfCsR] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowArg_$cshowsPrec
                      $dShow_sfCsQ $dShow1_sfCsR eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfCsS sat_sfCsT sat_sfCsU];

Data.Semigroup.$fGeneric1Max1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Max a
     -> GHC.Generics.Rep1 Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCsV] ds_sfCsV;

Data.Semigroup.$fGeneric1Max2
  :: forall a. Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCsW] x_sfCsW;

Data.Semigroup.$fGeneric1Max [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Max
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Max2
                                            Data.Semigroup.$fGeneric1Max1];

Data.Semigroup.$fGenericMax1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Max a) x
     -> GHC.Generics.Rep (Data.Semigroup.Max a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCsX] ds_sfCsX;

Data.Semigroup.$fGenericMax2
  :: forall a x. Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfCsY] x1_sfCsY;

Data.Semigroup.$fGenericMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Max a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericMax2
                                           Data.Semigroup.$fGenericMax1];

Data.Semigroup.$fDataMax_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Max a
     -> c (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCsZ k_sfCt0 z_sfCt1 ds_sfCt2]
        let {
          sat_sfCt3 [Occ=Once]
            :: c_afxHD (a_afxHu -> Data.Semigroup.Max a_afxHu)
          [LclId] =
              [z_sfCt1] \u [] z_sfCt1 Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfCt0 $dData_sfCsZ sat_sfCt3 ds_sfCt2;

Data.Semigroup.$fDataMax4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Max"#;

Data.Semigroup.$fDataMax7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataMax4;

Data.Semigroup.$fReadMax_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataMax7];

Data.Semigroup.$fReadMax3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMax"#;

Data.Semigroup.$fReadMax2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadMax3;

Data.Semigroup.$fReadMax1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Max a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCt4]
        let {
          lvl33_sfCt5 [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afxGF
          [LclId] =
              [$dRead_sfCt4] \u []
                  GHC.Read.readPrec
                      $dRead_sfCt4 Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfCt6 [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afxGF
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfCt5] \r [ds1_sfCt7] lvl33_sfCt5; } in
        let {
          sat_sfCtr [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Max a_afxGF)
          [LclId] =
              [ds_sfCt6] \r [c_sfCt8 eta_sfCt9]
                  case c_sfCt8 of {
                    GHC.Types.I# x_sfCtb [Occ=Once] ->
                        case <=# [x_sfCtb 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCto [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfCt6 eta_sfCt9] \r [a1_sfCtd]
                                        let {
                                          sat_sfCtl [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfCt6 eta_sfCt9] \r [a2_sfCte]
                                                  let {
                                                    sat_sfCtk [Occ=Once]
                                                      :: a_afxGF
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfCt9] \r [a3_sfCtf]
                                                            let {
                                                              sat_sfCth [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfCt9 a3_sfCtf] \r [a4_sfCtg]
                                                                      eta_sfCt9 a3_sfCtf;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfCth
                                                              of
                                                              { Unit# ww1_sfCtj [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfCtj];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadMax2
                                                        ds_sfCt6
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCtk;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfCtl
                                          of
                                          { Unit# ww1_sfCtn [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfCtn];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Semigroup.$fReadMax_lexeme sat_sfCto
                                of
                                { Unit# ww1_sfCtq [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCtq];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCtr;

Data.Semigroup.$fReadMax_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Max a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCts]
        let {
          ds_sfCtt [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Max a_Xfy4P -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfCts] \u [] Data.Semigroup.$fReadMax1 $dRead_sfCts; } in
        let {
          sat_sfCtw [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Max a_Xfy4P)
          [LclId] =
              [ds_sfCtt] \r [n_sfCtu]
                  let {
                    sat_sfCtv [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Max a_Xfy4P)
                    [LclId] =
                        [ds_sfCtt n_sfCtu] \u []
                            ds_sfCtt
                                n_sfCtu Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfCtv;
        } in  sat_sfCtw;

Data.Semigroup.$fReadMax_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Max a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCtx]
        let {
          sat_sfCty [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Max a_Xfy4N)
          [LclId] =
              [$dRead_sfCtx] \s [] Data.Semigroup.$fReadMax1 $dRead_sfCtx;
        } in  GHC.Read.list sat_sfCty;

Data.Semigroup.$fReadMax_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Max a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCtz]
        let {
          sat_sfCtB [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Max a_Xfy4O]
          [LclId] =
              [$dRead_sfCtz] \u []
                  let {
                    sat_sfCtA [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Max a_Xfy4O)
                    [LclId] =
                        [$dRead_sfCtz] \s [] Data.Semigroup.$fReadMax1 $dRead_sfCtz;
                  } in 
                    GHC.Read.list
                        sat_sfCtA
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCtB;

Data.Semigroup.$fReadMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfCtC]
        let {
          sat_sfCtG [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Max a_Xfy4M]
          [LclId] =
              [$dRead_sfCtC] \u []
                  Data.Semigroup.$fReadMax_$creadListPrec $dRead_sfCtC; } in
        let {
          sat_sfCtF [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Max a_Xfy4M)
          [LclId] =
              [$dRead_sfCtC] \u [] Data.Semigroup.$fReadMax1 $dRead_sfCtC; } in
        let {
          sat_sfCtE [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Max a_Xfy4M]
          [LclId] =
              [$dRead_sfCtC] \u []
                  Data.Semigroup.$fReadMax_$creadList $dRead_sfCtC; } in
        let {
          sat_sfCtD [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Max a_Xfy4M)
          [LclId] =
              [$dRead_sfCtC] \u []
                  Data.Semigroup.$fReadMax_$creadsPrec $dRead_sfCtC;
        } in  GHC.Read.C:Read [sat_sfCtD sat_sfCtE sat_sfCtF sat_sfCtG];

Data.Semigroup.$fShowMax2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Max {"#;

Data.Semigroup.$fShowMax1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMax = "#;

Data.Semigroup.$w$cshowsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Max a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCtH ww_sfCtI w1_sfCtJ]
        let {
          f_sfCtK [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfCtH w1_sfCtJ] \u []
                  GHC.Show.showsPrec
                      w_sfCtH Data.Semigroup.$fFoldableOption7 w1_sfCtJ;
        } in 
          case >=# [ww_sfCtI 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCtQ [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCtK] \r [x_sfCtM]
                          let {
                            sat_sfCtP [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCtK x_sfCtM] \u []
                                    let {
                                      sat_sfCtO [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCtK x_sfCtM] \u []
                                              let {
                                                sat_sfCtN [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfCtM] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfCtM;
                                              } in  f_sfCtK sat_sfCtN;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMax1 sat_sfCtO;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowMax2 sat_sfCtP;
                } in  sat_sfCtQ;
            1# ->
                let {
                  sat_sfCtX [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCtK] \r [x_sfCtR]
                          let {
                            sat_sfCtW [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCtK x_sfCtR] \u []
                                    let {
                                      sat_sfCtV [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCtK x_sfCtR] \u []
                                              let {
                                                sat_sfCtU [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfCtK x_sfCtR] \u []
                                                        let {
                                                          sat_sfCtT [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfCtR] \u []
                                                                  let {
                                                                    sat_sfCtS [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfCtR];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfCtS;
                                                        } in  f_sfCtK sat_sfCtT;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowMax1 sat_sfCtU;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMax2 sat_sfCtV;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCtW];
                } in  sat_sfCtX;
          };

Data.Semigroup.$fShowMax_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Max a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCtY w1_sfCtZ w2_sfCu0]
        case w1_sfCtZ of {
          GHC.Types.I# ww1_sfCu2 [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec3 w_sfCtY ww1_sfCu2 w2_sfCu0;
        };

Data.Semigroup.$fShowMax_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Max a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCu3 x_sfCu4]
        let {
          sat_sfCu6 [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfCu3 x_sfCu4] \u []
                  let {
                    sat_sfCu5 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfCu3 x_sfCu4] \u []
                            GHC.Show.showsPrec
                                $dShow_sfCu3
                                Data.Semigroup.$fFoldableOption7
                                x_sfCu4
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowMax1 sat_sfCu5;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowMax2 sat_sfCu6;

Data.Semigroup.$fShowMax_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Max a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCu7 ls_sfCu8 s_sfCu9]
        let {
          sat_sfCub [Occ=Once]
            :: Data.Semigroup.Max a_afxGa -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCu7] \r [w_sfCua]
                  Data.Semigroup.$w$cshowsPrec3 $dShow_sfCu7 0# w_sfCua;
        } in  GHC.Show.showList__ sat_sfCub ls_sfCu8 s_sfCu9;

Data.Semigroup.$fShowMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfCuc]
        let {
          sat_sfCuf [Occ=Once]
            :: [Data.Semigroup.Max a_afxGa] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCuc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMax_$cshowList
                      $dShow_sfCuc eta_B2 eta_B1; } in
        let {
          sat_sfCue [Occ=Once]
            :: Data.Semigroup.Max a_afxGa -> GHC.Base.String
          [LclId] =
              [$dShow_sfCuc] \r [eta_B1]
                  Data.Semigroup.$fShowMax_$cshow $dShow_sfCuc eta_B1; } in
        let {
          sat_sfCud [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Max a_afxGa -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCuc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMax_$cshowsPrec $dShow_sfCuc eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfCud sat_sfCue sat_sfCuf];

Data.Semigroup.$fEqMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfCug]
        let {
          sat_sfCui [Occ=Once]
            :: Data.Semigroup.Max a_afxDN
               -> Data.Semigroup.Max a_afxDN -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCug] \u [] GHC.Classes./= $dEq_sfCug; } in
        let {
          sat_sfCuh [Occ=Once]
            :: Data.Semigroup.Max a_afxDN
               -> Data.Semigroup.Max a_afxDN -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCug] \u [] GHC.Classes.== $dEq_sfCug;
        } in  GHC.Classes.C:Eq [sat_sfCuh sat_sfCui];

Data.Semigroup.$fOrdMax_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Max a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCuj]
        let {
          sat_sfCuk [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afxEl
          [LclId] =
              [$dOrd_sfCuj] \u [] GHC.Classes.$p1Ord $dOrd_sfCuj;
        } in  Data.Semigroup.$fEqMax sat_sfCuk;

Data.Semigroup.$fOrdMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfCul]
        let {
          sat_sfCut [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> Data.Semigroup.Max a_afxEl
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.min $dOrd_sfCul; } in
        let {
          sat_sfCus [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> Data.Semigroup.Max a_afxEl
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.max $dOrd_sfCul; } in
        let {
          sat_sfCur [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.>= $dOrd_sfCul; } in
        let {
          sat_sfCuq [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.> $dOrd_sfCul; } in
        let {
          sat_sfCup [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.<= $dOrd_sfCul; } in
        let {
          sat_sfCuo [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.< $dOrd_sfCul; } in
        let {
          sat_sfCun [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.compare $dOrd_sfCul; } in
        let {
          sat_sfCum [Occ=Once] :: GHC.Classes.Eq (Data.Semigroup.Max a_afxEl)
          [LclId] =
              [$dOrd_sfCul] \u [] Data.Semigroup.$fOrdMax_$cp1Ord $dOrd_sfCul;
        } in 
          GHC.Classes.C:Ord [sat_sfCum
                             sat_sfCun
                             sat_sfCuo
                             sat_sfCup
                             sat_sfCuq
                             sat_sfCur
                             sat_sfCus
                             sat_sfCut];

Data.Semigroup.$fBoundedMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfCuu]
        let {
          sat_sfCuw [Occ=Once] :: Data.Semigroup.Max a_afxDv
          [LclId] =
              [$dBounded_sfCuu] \u [] GHC.Enum.maxBound $dBounded_sfCuu; } in
        let {
          sat_sfCuv [Occ=Once] :: Data.Semigroup.Max a_afxDv
          [LclId] =
              [$dBounded_sfCuu] \u [] GHC.Enum.minBound $dBounded_sfCuu;
        } in  GHC.Enum.C:Bounded [sat_sfCuv sat_sfCuw];

Data.Semigroup.$fMonoidMax_$cmconcat
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     [Data.Semigroup.Max a] -> Data.Semigroup.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><L,1*U(1*U,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCux $dBounded_sfCuy eta_sfCuz]
        let {
          z_sfCuA [Occ=OnceL] :: a_XfzuM
          [LclId] =
              [$dBounded_sfCuy] \u [] GHC.Enum.minBound $dBounded_sfCuy; } in
        let {
          go_sfCuB [Occ=LoopBreaker]
            :: [Data.Semigroup.Max a_XfzuM] -> Data.Semigroup.Max a_XfzuM
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_sfCux z_sfCuA go_sfCuB] \r [ds_sfCuC]
                  case ds_sfCuC of {
                    [] -> z_sfCuA;
                    : y_sfCuE [Occ=Once] ys_sfCuF [Occ=Once] ->
                        let {
                          sat_sfCuG [Occ=Once] :: a_XfzuM
                          [LclId] =
                              [go_sfCuB ys_sfCuF] \u [] go_sfCuB ys_sfCuF;
                        } in  GHC.Classes.max $dOrd_sfCux y_sfCuE sat_sfCuG;
                  };
        } in  go_sfCuB eta_sfCuz;

Data.Semigroup.$fMonoidMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     GHC.Base.Monoid (Data.Semigroup.Max a)
[GblId[DFunId], Arity=2, Str=<L,U(A,A,A,A,A,A,U,A)><L,U(U,A)>m] =
    [] \r [$dOrd_sfCuH $dBounded_sfCuI]
        let {
          sat_sfCuM [Occ=Once]
            :: [Data.Semigroup.Max a_XfzuG] -> Data.Semigroup.Max a_XfzuG
          [LclId] =
              [$dOrd_sfCuH $dBounded_sfCuI] \r [eta_B1]
                  Data.Semigroup.$fMonoidMax_$cmconcat
                      $dOrd_sfCuH $dBounded_sfCuI eta_B1; } in
        let {
          sat_sfCuL [Occ=Once]
            :: Data.Semigroup.Max a_XfzuG
               -> Data.Semigroup.Max a_XfzuG -> Data.Semigroup.Max a_XfzuG
          [LclId] =
              [$dOrd_sfCuH] \u [] GHC.Classes.max $dOrd_sfCuH; } in
        let {
          sat_sfCuK [Occ=Once] :: Data.Semigroup.Max a_XfzuG
          [LclId] =
              [$dBounded_sfCuI] \u [] GHC.Enum.minBound $dBounded_sfCuI; } in
        let {
          sat_sfCuJ [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Max a_XfzuG)
          [LclId] =
              [$dOrd_sfCuH] \u [] Data.Semigroup.$fSemigroupMax $dOrd_sfCuH;
        } in  GHC.Base.C:Monoid [sat_sfCuJ sat_sfCuK sat_sfCuL sat_sfCuM];

Data.Semigroup.$fGeneric1Min1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Min a
     -> GHC.Generics.Rep1 Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCuN] ds_sfCuN;

Data.Semigroup.$fGeneric1Min2
  :: forall a. Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCuO] x_sfCuO;

Data.Semigroup.$fGeneric1Min [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Min
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Min2
                                            Data.Semigroup.$fGeneric1Min1];

Data.Semigroup.$fGenericMin1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Min a) x
     -> GHC.Generics.Rep (Data.Semigroup.Min a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCuP] ds_sfCuP;

Data.Semigroup.$fGenericMin2
  :: forall a x. Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfCuQ] x1_sfCuQ;

Data.Semigroup.$fGenericMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Min a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericMin2
                                           Data.Semigroup.$fGenericMin1];

Data.Semigroup.$fDataMin_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Min a
     -> c (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCuR k_sfCuS z_sfCuT ds_sfCuU]
        let {
          sat_sfCuV [Occ=Once]
            :: c_afxyB (a_afxys -> Data.Semigroup.Min a_afxys)
          [LclId] =
              [z_sfCuT] \u [] z_sfCuT Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfCuS $dData_sfCuR sat_sfCuV ds_sfCuU;

Data.Semigroup.$fDataMin4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Min"#;

Data.Semigroup.$fDataMin7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataMin4;

Data.Semigroup.$fReadMin_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataMin7];

Data.Semigroup.$fReadMin3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMin"#;

Data.Semigroup.$fReadMin2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadMin3;

Data.Semigroup.$fReadMin1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Min a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCuW]
        let {
          lvl33_sfCuX [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afxxD
          [LclId] =
              [$dRead_sfCuW] \u []
                  GHC.Read.readPrec
                      $dRead_sfCuW Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfCuY [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afxxD
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfCuX] \r [ds1_sfCuZ] lvl33_sfCuX; } in
        let {
          sat_sfCvj [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Min a_afxxD)
          [LclId] =
              [ds_sfCuY] \r [c_sfCv0 eta_sfCv1]
                  case c_sfCv0 of {
                    GHC.Types.I# x_sfCv3 [Occ=Once] ->
                        case <=# [x_sfCv3 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCvg [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfCuY eta_sfCv1] \r [a1_sfCv5]
                                        let {
                                          sat_sfCvd [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfCuY eta_sfCv1] \r [a2_sfCv6]
                                                  let {
                                                    sat_sfCvc [Occ=Once]
                                                      :: a_afxxD
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfCv1] \r [a3_sfCv7]
                                                            let {
                                                              sat_sfCv9 [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfCv1 a3_sfCv7] \r [a4_sfCv8]
                                                                      eta_sfCv1 a3_sfCv7;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfCv9
                                                              of
                                                              { Unit# ww1_sfCvb [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfCvb];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadMin2
                                                        ds_sfCuY
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCvc;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfCvd
                                          of
                                          { Unit# ww1_sfCvf [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfCvf];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Semigroup.$fReadMin_lexeme sat_sfCvg
                                of
                                { Unit# ww1_sfCvi [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCvi];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCvj;

Data.Semigroup.$fReadMin_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Min a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCvk]
        let {
          ds_sfCvl [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Min a_XfxWM -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfCvk] \u [] Data.Semigroup.$fReadMin1 $dRead_sfCvk; } in
        let {
          sat_sfCvo [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Min a_XfxWM)
          [LclId] =
              [ds_sfCvl] \r [n_sfCvm]
                  let {
                    sat_sfCvn [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Min a_XfxWM)
                    [LclId] =
                        [ds_sfCvl n_sfCvm] \u []
                            ds_sfCvl
                                n_sfCvm Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfCvn;
        } in  sat_sfCvo;

Data.Semigroup.$fReadMin_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Min a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCvp]
        let {
          sat_sfCvq [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Min a_XfxWK)
          [LclId] =
              [$dRead_sfCvp] \s [] Data.Semigroup.$fReadMin1 $dRead_sfCvp;
        } in  GHC.Read.list sat_sfCvq;

Data.Semigroup.$fReadMin_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Min a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCvr]
        let {
          sat_sfCvt [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Min a_XfxWL]
          [LclId] =
              [$dRead_sfCvr] \u []
                  let {
                    sat_sfCvs [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Min a_XfxWL)
                    [LclId] =
                        [$dRead_sfCvr] \s [] Data.Semigroup.$fReadMin1 $dRead_sfCvr;
                  } in 
                    GHC.Read.list
                        sat_sfCvs
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCvt;

Data.Semigroup.$fReadMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfCvu]
        let {
          sat_sfCvy [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Min a_XfxWJ]
          [LclId] =
              [$dRead_sfCvu] \u []
                  Data.Semigroup.$fReadMin_$creadListPrec $dRead_sfCvu; } in
        let {
          sat_sfCvx [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Min a_XfxWJ)
          [LclId] =
              [$dRead_sfCvu] \u [] Data.Semigroup.$fReadMin1 $dRead_sfCvu; } in
        let {
          sat_sfCvw [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Min a_XfxWJ]
          [LclId] =
              [$dRead_sfCvu] \u []
                  Data.Semigroup.$fReadMin_$creadList $dRead_sfCvu; } in
        let {
          sat_sfCvv [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Min a_XfxWJ)
          [LclId] =
              [$dRead_sfCvu] \u []
                  Data.Semigroup.$fReadMin_$creadsPrec $dRead_sfCvu;
        } in  GHC.Read.C:Read [sat_sfCvv sat_sfCvw sat_sfCvx sat_sfCvy];

Data.Semigroup.$fShowMin2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Min {"#;

Data.Semigroup.$fShowMin1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMin = "#;

Data.Semigroup.$w$cshowsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Min a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCvz ww_sfCvA w1_sfCvB]
        let {
          f_sfCvC [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfCvz w1_sfCvB] \u []
                  GHC.Show.showsPrec
                      w_sfCvz Data.Semigroup.$fFoldableOption7 w1_sfCvB;
        } in 
          case >=# [ww_sfCvA 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCvI [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCvC] \r [x_sfCvE]
                          let {
                            sat_sfCvH [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCvC x_sfCvE] \u []
                                    let {
                                      sat_sfCvG [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCvC x_sfCvE] \u []
                                              let {
                                                sat_sfCvF [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfCvE] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfCvE;
                                              } in  f_sfCvC sat_sfCvF;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMin1 sat_sfCvG;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowMin2 sat_sfCvH;
                } in  sat_sfCvI;
            1# ->
                let {
                  sat_sfCvP [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCvC] \r [x_sfCvJ]
                          let {
                            sat_sfCvO [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCvC x_sfCvJ] \u []
                                    let {
                                      sat_sfCvN [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCvC x_sfCvJ] \u []
                                              let {
                                                sat_sfCvM [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfCvC x_sfCvJ] \u []
                                                        let {
                                                          sat_sfCvL [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfCvJ] \u []
                                                                  let {
                                                                    sat_sfCvK [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfCvJ];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfCvK;
                                                        } in  f_sfCvC sat_sfCvL;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowMin1 sat_sfCvM;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMin2 sat_sfCvN;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCvO];
                } in  sat_sfCvP;
          };

Data.Semigroup.$fShowMin_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Min a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCvQ w1_sfCvR w2_sfCvS]
        case w1_sfCvR of {
          GHC.Types.I# ww1_sfCvU [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec4 w_sfCvQ ww1_sfCvU w2_sfCvS;
        };

Data.Semigroup.$fShowMin_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Min a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCvV x_sfCvW]
        let {
          sat_sfCvY [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfCvV x_sfCvW] \u []
                  let {
                    sat_sfCvX [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfCvV x_sfCvW] \u []
                            GHC.Show.showsPrec
                                $dShow_sfCvV
                                Data.Semigroup.$fFoldableOption7
                                x_sfCvW
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowMin1 sat_sfCvX;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowMin2 sat_sfCvY;

Data.Semigroup.$fShowMin_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Min a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCvZ ls_sfCw0 s_sfCw1]
        let {
          sat_sfCw3 [Occ=Once]
            :: Data.Semigroup.Min a_afxx8 -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCvZ] \r [w_sfCw2]
                  Data.Semigroup.$w$cshowsPrec4 $dShow_sfCvZ 0# w_sfCw2;
        } in  GHC.Show.showList__ sat_sfCw3 ls_sfCw0 s_sfCw1;

Data.Semigroup.$fShowMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfCw4]
        let {
          sat_sfCw7 [Occ=Once]
            :: [Data.Semigroup.Min a_afxx8] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCw4] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMin_$cshowList
                      $dShow_sfCw4 eta_B2 eta_B1; } in
        let {
          sat_sfCw6 [Occ=Once]
            :: Data.Semigroup.Min a_afxx8 -> GHC.Base.String
          [LclId] =
              [$dShow_sfCw4] \r [eta_B1]
                  Data.Semigroup.$fShowMin_$cshow $dShow_sfCw4 eta_B1; } in
        let {
          sat_sfCw5 [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Min a_afxx8 -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCw4] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMin_$cshowsPrec $dShow_sfCw4 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfCw5 sat_sfCw6 sat_sfCw7];

Data.Semigroup.$fEqMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfCw8]
        let {
          sat_sfCwa [Occ=Once]
            :: Data.Semigroup.Min a_afxuL
               -> Data.Semigroup.Min a_afxuL -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCw8] \u [] GHC.Classes./= $dEq_sfCw8; } in
        let {
          sat_sfCw9 [Occ=Once]
            :: Data.Semigroup.Min a_afxuL
               -> Data.Semigroup.Min a_afxuL -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCw8] \u [] GHC.Classes.== $dEq_sfCw8;
        } in  GHC.Classes.C:Eq [sat_sfCw9 sat_sfCwa];

Data.Semigroup.$fOrdMin_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Min a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCwb]
        let {
          sat_sfCwc [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afxvj
          [LclId] =
              [$dOrd_sfCwb] \u [] GHC.Classes.$p1Ord $dOrd_sfCwb;
        } in  Data.Semigroup.$fEqMin sat_sfCwc;

Data.Semigroup.$fOrdMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfCwd]
        let {
          sat_sfCwl [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> Data.Semigroup.Min a_afxvj
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.min $dOrd_sfCwd; } in
        let {
          sat_sfCwk [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> Data.Semigroup.Min a_afxvj
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.max $dOrd_sfCwd; } in
        let {
          sat_sfCwj [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.>= $dOrd_sfCwd; } in
        let {
          sat_sfCwi [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.> $dOrd_sfCwd; } in
        let {
          sat_sfCwh [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.<= $dOrd_sfCwd; } in
        let {
          sat_sfCwg [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.< $dOrd_sfCwd; } in
        let {
          sat_sfCwf [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.compare $dOrd_sfCwd; } in
        let {
          sat_sfCwe [Occ=Once] :: GHC.Classes.Eq (Data.Semigroup.Min a_afxvj)
          [LclId] =
              [$dOrd_sfCwd] \u [] Data.Semigroup.$fOrdMin_$cp1Ord $dOrd_sfCwd;
        } in 
          GHC.Classes.C:Ord [sat_sfCwe
                             sat_sfCwf
                             sat_sfCwg
                             sat_sfCwh
                             sat_sfCwi
                             sat_sfCwj
                             sat_sfCwk
                             sat_sfCwl];

Data.Semigroup.$fBoundedMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfCwm]
        let {
          sat_sfCwo [Occ=Once] :: Data.Semigroup.Min a_afxut
          [LclId] =
              [$dBounded_sfCwm] \u [] GHC.Enum.maxBound $dBounded_sfCwm; } in
        let {
          sat_sfCwn [Occ=Once] :: Data.Semigroup.Min a_afxut
          [LclId] =
              [$dBounded_sfCwm] \u [] GHC.Enum.minBound $dBounded_sfCwm;
        } in  GHC.Enum.C:Bounded [sat_sfCwn sat_sfCwo];

Data.Semigroup.$fMonoidMin_$cmconcat
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     [Data.Semigroup.Min a] -> Data.Semigroup.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><L,1*U(A,1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCwp $dBounded_sfCwq eta_sfCwr]
        let {
          z_sfCws [Occ=OnceL] :: a_XfzEk
          [LclId] =
              [$dBounded_sfCwq] \u [] GHC.Enum.maxBound $dBounded_sfCwq; } in
        let {
          go_sfCwt [Occ=LoopBreaker]
            :: [Data.Semigroup.Min a_XfzEk] -> Data.Semigroup.Min a_XfzEk
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_sfCwp z_sfCws go_sfCwt] \r [ds_sfCwu]
                  case ds_sfCwu of {
                    [] -> z_sfCws;
                    : y_sfCww [Occ=Once] ys_sfCwx [Occ=Once] ->
                        let {
                          sat_sfCwy [Occ=Once] :: a_XfzEk
                          [LclId] =
                              [go_sfCwt ys_sfCwx] \u [] go_sfCwt ys_sfCwx;
                        } in  GHC.Classes.min $dOrd_sfCwp y_sfCww sat_sfCwy;
                  };
        } in  go_sfCwt eta_sfCwr;

Data.Semigroup.$fMonoidMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     GHC.Base.Monoid (Data.Semigroup.Min a)
[GblId[DFunId], Arity=2, Str=<L,U(A,A,A,A,A,A,A,U)><L,U(A,U)>m] =
    [] \r [$dOrd_sfCwz $dBounded_sfCwA]
        let {
          sat_sfCwE [Occ=Once]
            :: [Data.Semigroup.Min a_XfzEe] -> Data.Semigroup.Min a_XfzEe
          [LclId] =
              [$dOrd_sfCwz $dBounded_sfCwA] \r [eta_B1]
                  Data.Semigroup.$fMonoidMin_$cmconcat
                      $dOrd_sfCwz $dBounded_sfCwA eta_B1; } in
        let {
          sat_sfCwD [Occ=Once]
            :: Data.Semigroup.Min a_XfzEe
               -> Data.Semigroup.Min a_XfzEe -> Data.Semigroup.Min a_XfzEe
          [LclId] =
              [$dOrd_sfCwz] \u [] GHC.Classes.min $dOrd_sfCwz; } in
        let {
          sat_sfCwC [Occ=Once] :: Data.Semigroup.Min a_XfzEe
          [LclId] =
              [$dBounded_sfCwA] \u [] GHC.Enum.maxBound $dBounded_sfCwA; } in
        let {
          sat_sfCwB [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Min a_XfzEe)
          [LclId] =
              [$dOrd_sfCwz] \u [] Data.Semigroup.$fSemigroupMin $dOrd_sfCwz;
        } in  GHC.Base.C:Monoid [sat_sfCwB sat_sfCwC sat_sfCwD sat_sfCwE];

Data.Semigroup.getMin :: forall a. Data.Semigroup.Min a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Min2 eta_B1;

Data.Semigroup.$fMonadFixMin_$cmfix
  :: forall a. (a -> Data.Semigroup.Min a) -> Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfCwF]
        let {
          x_sfCwG [Occ=LoopBreaker] :: Data.Semigroup.Min a_afz9s
          [LclId] =
              [f_sfCwF x_sfCwG] \u [] f_sfCwF x_sfCwG;
        } in  x_sfCwG;

Data.Semigroup.$fMonadFixMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadMin
                                                 Data.Semigroup.$fMonadFixMin_$cmfix];

Data.Semigroup.$fEnumMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfCwH]
        let {
          sat_sfCx1 [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs
               -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfCwH] \r [ds_sfCwY ds1_sfCwZ ds2_sfCx0]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfCwH ds_sfCwY ds1_sfCwZ ds2_sfCx0; } in
        let {
          sat_sfCwX [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfCwH] \r [ds_sfCwV ds1_sfCwW]
                  GHC.Enum.enumFromTo $dEnum_sfCwH ds_sfCwV ds1_sfCwW; } in
        let {
          sat_sfCwU [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfCwH] \r [ds_sfCwS ds1_sfCwT]
                  GHC.Enum.enumFromThen $dEnum_sfCwH ds_sfCwS ds1_sfCwT; } in
        let {
          sat_sfCwR [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfCwH] \r [ds_sfCwQ]
                  GHC.Enum.enumFrom $dEnum_sfCwH ds_sfCwQ; } in
        let {
          sat_sfCwP [Occ=Once] :: Data.Semigroup.Min a_XfzFs -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfCwH] \r [eta_sfCwO]
                  GHC.Enum.fromEnum $dEnum_sfCwH eta_sfCwO; } in
        let {
          sat_sfCwN [Occ=Once] :: GHC.Types.Int -> Data.Semigroup.Min a_XfzFs
          [LclId] =
              [$dEnum_sfCwH] \r [eta_sfCwM]
                  GHC.Enum.toEnum $dEnum_sfCwH eta_sfCwM; } in
        let {
          sat_sfCwL [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs -> Data.Semigroup.Min a_XfzFs
          [LclId] =
              [$dEnum_sfCwH] \r [ds_sfCwK]
                  GHC.Enum.pred $dEnum_sfCwH ds_sfCwK; } in
        let {
          sat_sfCwJ [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs -> Data.Semigroup.Min a_XfzFs
          [LclId] =
              [$dEnum_sfCwH] \r [ds_sfCwI] GHC.Enum.succ $dEnum_sfCwH ds_sfCwI;
        } in 
          GHC.Enum.C:Enum [sat_sfCwJ
                           sat_sfCwL
                           sat_sfCwN
                           sat_sfCwP
                           sat_sfCwR
                           sat_sfCwU
                           sat_sfCwX
                           sat_sfCx1];

Data.Semigroup.getMax :: forall a. Data.Semigroup.Max a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Max2 eta_B1;

Data.Semigroup.$fMonadFixMax_$cmfix
  :: forall a. (a -> Data.Semigroup.Max a) -> Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfCx2]
        let {
          x_sfCx3 [Occ=LoopBreaker] :: Data.Semigroup.Max a_afz0T
          [LclId] =
              [f_sfCx2 x_sfCx3] \u [] f_sfCx2 x_sfCx3;
        } in  x_sfCx3;

Data.Semigroup.$fMonadFixMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadMax
                                                 Data.Semigroup.$fMonadFixMax_$cmfix];

Data.Semigroup.$fEnumMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfCx4]
        let {
          sat_sfCxo [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1
               -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfCx4] \r [ds_sfCxl ds1_sfCxm ds2_sfCxn]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfCx4 ds_sfCxl ds1_sfCxm ds2_sfCxn; } in
        let {
          sat_sfCxk [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1 -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfCx4] \r [ds_sfCxi ds1_sfCxj]
                  GHC.Enum.enumFromTo $dEnum_sfCx4 ds_sfCxi ds1_sfCxj; } in
        let {
          sat_sfCxh [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1 -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfCx4] \r [ds_sfCxf ds1_sfCxg]
                  GHC.Enum.enumFromThen $dEnum_sfCx4 ds_sfCxf ds1_sfCxg; } in
        let {
          sat_sfCxe [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1 -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfCx4] \r [ds_sfCxd]
                  GHC.Enum.enumFrom $dEnum_sfCx4 ds_sfCxd; } in
        let {
          sat_sfCxc [Occ=Once] :: Data.Semigroup.Max a_Xfzx1 -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfCx4] \r [eta_sfCxb]
                  GHC.Enum.fromEnum $dEnum_sfCx4 eta_sfCxb; } in
        let {
          sat_sfCxa [Occ=Once] :: GHC.Types.Int -> Data.Semigroup.Max a_Xfzx1
          [LclId] =
              [$dEnum_sfCx4] \r [eta_sfCx9]
                  GHC.Enum.toEnum $dEnum_sfCx4 eta_sfCx9; } in
        let {
          sat_sfCx8 [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1 -> Data.Semigroup.Max a_Xfzx1
          [LclId] =
              [$dEnum_sfCx4] \r [ds_sfCx7]
                  GHC.Enum.pred $dEnum_sfCx4 ds_sfCx7; } in
        let {
          sat_sfCx6 [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1 -> Data.Semigroup.Max a_Xfzx1
          [LclId] =
              [$dEnum_sfCx4] \r [ds_sfCx5] GHC.Enum.succ $dEnum_sfCx4 ds_sfCx5;
        } in 
          GHC.Enum.C:Enum [sat_sfCx6
                           sat_sfCx8
                           sat_sfCxa
                           sat_sfCxc
                           sat_sfCxe
                           sat_sfCxh
                           sat_sfCxk
                           sat_sfCxo];

Data.Semigroup.getFirst :: forall a. Data.Semigroup.First a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1First2 eta_B1;

Data.Semigroup.$fMonadFixFirst_$cmfix
  :: forall a.
     (a -> Data.Semigroup.First a) -> Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfCxp]
        let {
          x_sfCxq [Occ=LoopBreaker] :: Data.Semigroup.First a_afyMj
          [LclId] =
              [f_sfCxp x_sfCxq] \u [] f_sfCxp x_sfCxq;
        } in  x_sfCxq;

Data.Semigroup.$fMonadFixFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadFirst
                                                 Data.Semigroup.$fMonadFixFirst_$cmfix];

Data.Semigroup.$fEnumFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfCxr]
        let {
          sat_sfCxL [Occ=Once]
            :: Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV
               -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfCxr] \r [ds_sfCxI ds1_sfCxJ ds2_sfCxK]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfCxr ds_sfCxI ds1_sfCxJ ds2_sfCxK; } in
        let {
          sat_sfCxH [Occ=Once]
            :: Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfCxr] \r [ds_sfCxF ds1_sfCxG]
                  GHC.Enum.enumFromTo $dEnum_sfCxr ds_sfCxF ds1_sfCxG; } in
        let {
          sat_sfCxE [Occ=Once]
            :: Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfCxr] \r [ds_sfCxC ds1_sfCxD]
                  GHC.Enum.enumFromThen $dEnum_sfCxr ds_sfCxC ds1_sfCxD; } in
        let {
          sat_sfCxB [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfCxr] \r [ds_sfCxA]
                  GHC.Enum.enumFrom $dEnum_sfCxr ds_sfCxA; } in
        let {
          sat_sfCxz [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfCxr] \r [eta_sfCxy]
                  GHC.Enum.fromEnum $dEnum_sfCxr eta_sfCxy; } in
        let {
          sat_sfCxx [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.First a_XfzhV
          [LclId] =
              [$dEnum_sfCxr] \r [eta_sfCxw]
                  GHC.Enum.toEnum $dEnum_sfCxr eta_sfCxw; } in
        let {
          sat_sfCxv [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> Data.Semigroup.First a_XfzhV
          [LclId] =
              [$dEnum_sfCxr] \r [ds_sfCxu]
                  GHC.Enum.pred $dEnum_sfCxr ds_sfCxu; } in
        let {
          sat_sfCxt [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> Data.Semigroup.First a_XfzhV
          [LclId] =
              [$dEnum_sfCxr] \r [ds_sfCxs] GHC.Enum.succ $dEnum_sfCxr ds_sfCxs;
        } in 
          GHC.Enum.C:Enum [sat_sfCxt
                           sat_sfCxv
                           sat_sfCxx
                           sat_sfCxz
                           sat_sfCxB
                           sat_sfCxE
                           sat_sfCxH
                           sat_sfCxL];

Data.Semigroup.getLast :: forall a. Data.Semigroup.Last a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Last2 eta_B1;

Data.Semigroup.$fMonadFixLast_$cmfix
  :: forall a. (a -> Data.Semigroup.Last a) -> Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfCxM]
        let {
          x_sfCxN [Occ=LoopBreaker] :: Data.Semigroup.Last a_afyFi
          [LclId] =
              [f_sfCxM x_sfCxN] \u [] f_sfCxM x_sfCxN;
        } in  x_sfCxN;

Data.Semigroup.$fMonadFixLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadLast
                                                 Data.Semigroup.$fMonadFixLast_$cmfix];

Data.Semigroup.$fEnumLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfCxO]
        let {
          sat_sfCy8 [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2
               -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfCxO] \r [ds_sfCy5 ds1_sfCy6 ds2_sfCy7]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfCxO ds_sfCy5 ds1_sfCy6 ds2_sfCy7; } in
        let {
          sat_sfCy4 [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2 -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfCxO] \r [ds_sfCy2 ds1_sfCy3]
                  GHC.Enum.enumFromTo $dEnum_sfCxO ds_sfCy2 ds1_sfCy3; } in
        let {
          sat_sfCy1 [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2 -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfCxO] \r [ds_sfCxZ ds1_sfCy0]
                  GHC.Enum.enumFromThen $dEnum_sfCxO ds_sfCxZ ds1_sfCy0; } in
        let {
          sat_sfCxY [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfCxO] \r [ds_sfCxX]
                  GHC.Enum.enumFrom $dEnum_sfCxO ds_sfCxX; } in
        let {
          sat_sfCxW [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfCxO] \r [eta_sfCxV]
                  GHC.Enum.fromEnum $dEnum_sfCxO eta_sfCxV; } in
        let {
          sat_sfCxU [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Last a_Xfzb2
          [LclId] =
              [$dEnum_sfCxO] \r [eta_sfCxT]
                  GHC.Enum.toEnum $dEnum_sfCxO eta_sfCxT; } in
        let {
          sat_sfCxS [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> Data.Semigroup.Last a_Xfzb2
          [LclId] =
              [$dEnum_sfCxO] \r [ds_sfCxR]
                  GHC.Enum.pred $dEnum_sfCxO ds_sfCxR; } in
        let {
          sat_sfCxQ [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> Data.Semigroup.Last a_Xfzb2
          [LclId] =
              [$dEnum_sfCxO] \r [ds_sfCxP] GHC.Enum.succ $dEnum_sfCxO ds_sfCxP;
        } in 
          GHC.Enum.C:Enum [sat_sfCxQ
                           sat_sfCxS
                           sat_sfCxU
                           sat_sfCxW
                           sat_sfCxY
                           sat_sfCy1
                           sat_sfCy4
                           sat_sfCy8];

Data.Semigroup.unwrapMonoid
  :: forall m. Data.Semigroup.WrappedMonoid m -> m
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1WrappedMonoid2 eta_B1;

Data.Semigroup.$fEnumWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.WrappedMonoid a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfCy9]
        let {
          sat_sfCyt [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfCy9] \r [ds_sfCyq ds1_sfCyr ds2_sfCys]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfCy9 ds_sfCyq ds1_sfCyr ds2_sfCys; } in
        let {
          sat_sfCyp [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfCy9] \r [ds_sfCyn ds1_sfCyo]
                  GHC.Enum.enumFromTo $dEnum_sfCy9 ds_sfCyn ds1_sfCyo; } in
        let {
          sat_sfCym [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfCy9] \r [ds_sfCyk ds1_sfCyl]
                  GHC.Enum.enumFromThen $dEnum_sfCy9 ds_sfCyk ds1_sfCyl; } in
        let {
          sat_sfCyj [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfCy9] \r [ds_sfCyi]
                  GHC.Enum.enumFrom $dEnum_sfCy9 ds_sfCyi; } in
        let {
          sat_sfCyh [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37 -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfCy9] \r [eta_sfCyg]
                  GHC.Enum.fromEnum $dEnum_sfCy9 eta_sfCyg; } in
        let {
          sat_sfCyf [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.WrappedMonoid a_Xfz37
          [LclId] =
              [$dEnum_sfCy9] \r [eta_sfCye]
                  GHC.Enum.toEnum $dEnum_sfCy9 eta_sfCye; } in
        let {
          sat_sfCyd [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
          [LclId] =
              [$dEnum_sfCy9] \r [ds_sfCyc]
                  GHC.Enum.pred $dEnum_sfCy9 ds_sfCyc; } in
        let {
          sat_sfCyb [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
          [LclId] =
              [$dEnum_sfCy9] \r [ds_sfCya] GHC.Enum.succ $dEnum_sfCy9 ds_sfCya;
        } in 
          GHC.Enum.C:Enum [sat_sfCyb
                           sat_sfCyd
                           sat_sfCyf
                           sat_sfCyh
                           sat_sfCyj
                           sat_sfCym
                           sat_sfCyp
                           sat_sfCyt];

Data.Semigroup.getOption
  :: forall a. Data.Semigroup.Option a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Option2 eta_B1;

Data.Semigroup.$fMonadFixOption_$cmfix
  :: forall a.
     (a -> Data.Semigroup.Option a) -> Data.Semigroup.Option a
[GblId, Arity=1, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfCyu]
        let {
          a1_sfCyv [Occ=LoopBreaker] :: Data.Semigroup.Option a_afyzI
          [LclId] =
              [f_sfCyu a1_sfCyv] \u []
                  let {
                    sat_sfCyy [Occ=Once] :: a_afyzI
                    [LclId] =
                        [a1_sfCyv] \u []
                            case a1_sfCyv of {
                              GHC.Base.Nothing -> Control.Monad.Fix.$fMonadFixFirst1;
                              GHC.Base.Just x_sfCyx [Occ=Once] -> x_sfCyx;
                            };
                  } in  f_sfCyu sat_sfCyy;
        } in  a1_sfCyv;

Data.Semigroup.$fMonadFixOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadOption
                                                 Data.Semigroup.$fMonadFixOption_$cmfix];

Data.Semigroup.cycle1 :: forall m. GHC.Base.Semigroup m => m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),U(C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfCyz xs_sfCyA]
        let {
          xs'_sfCyB [Occ=LoopBreaker] :: m_afxsV
          [LclId] =
              [$dSemigroup_sfCyz xs_sfCyA xs'_sfCyB] \u []
                  GHC.Base.<> $dSemigroup_sfCyz xs_sfCyA xs'_sfCyB;
        } in  xs'_sfCyB;

Data.Semigroup.diff1
  :: forall m. GHC.Base.Semigroup m => m -> m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfCyC eta_sfCyD]
        GHC.Base.<> $dSemigroup_sfCyC eta_sfCyD;

Data.Semigroup.diff
  :: forall m.
     GHC.Base.Semigroup m =>
     m -> Data.Semigroup.Internal.Endo m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Semigroup.diff1 eta_B2 eta_B1;

Data.Semigroup.mtimesDefault
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Monoid a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(U,U,U,U,U,U,U),U(U(U,U),U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U(A,1*U,U,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfCyE $dMonoid_sfCyF eta_sfCyG eta1_sfCyH]
        case
            GHC.Real.$p1Integral $dIntegral_sfCyE
        of
        $dReal_sfCyI [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_sfCyM [Occ=Once] :: b_afxst
                [LclId] =
                    [$dReal_sfCyI] \u []
                        case GHC.Real.$p1Real $dReal_sfCyI of sat_sfCyL {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_sfCyL Data.Semigroup.$fSemigroupOption2;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_sfCyI of sat_sfCyJ {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_sfCyJ of sat_sfCyK {
                        __DEFAULT ->
                            case GHC.Classes.== sat_sfCyK eta_sfCyG sat_sfCyM of {
                              GHC.Types.False ->
                                  Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes
                                      $dMonoid_sfCyF $dIntegral_sfCyE eta_sfCyG eta1_sfCyH;
                              GHC.Types.True -> GHC.Base.mempty $dMonoid_sfCyF;
                            };
                      };
                };
        };

Data.Semigroup.option
  :: forall b a. b -> (a -> b) -> Data.Semigroup.Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] Data.Maybe.maybe eta_B3 eta_B2 eta_B1;

$cMin1_rfC6i :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadMin2 GHC.Types.[]];

go61_rfC6j
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCyO _ys_sfCyP]
        case ds2_sfCyO of {
          [] -> GHC.List.badHead;
          : ipv_sfCyR [Occ=Once!] ipv1_sfCyS [Occ=Once] ->
              case _ys_sfCyP of {
                [] -> GHC.List.badHead;
                : ipv2_sfCyU [Occ=Once] ipv3_sfCyV [Occ=Once] ->
                    case ipv_sfCyR of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCyY [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfCyY Data.Semigroup.$fDataMin7 of {
                            GHC.Types.False -> go61_rfC6j ipv1_sfCyS ipv3_sfCyV;
                            GHC.Types.True -> ipv2_sfCyU;
                          };
                    };
              };
        };

$cMin2_rfC6k :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cMin3_rfC6l];
Data.Semigroup.$fDataMin6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cMin GHC.Types.[]];
Data.Semigroup.$fDataMin5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataMin6];
Data.Semigroup.$tMin :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataMin7
                                       Data.Semigroup.$fDataMin5];
Data.Semigroup.$cMin [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cMin2_rfC6k
                                     Data.Semigroup.$fDataMin7
                                     $cMin1_rfC6i
                                     Data.Data.Prefix
                                     Data.Semigroup.$tMin];
$cMin3_rfC6l :: Data.Data.ConIndex
[GblId] =
    [] \u [] go61_rfC6j Data.Semigroup.$fDataMin6 Data.Data.mkConstr1;

$cMax1_rfC6m :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadMax2 GHC.Types.[]];

go1_rfC6n
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCz3 _ys_sfCz4]
        case ds2_sfCz3 of {
          [] -> GHC.List.badHead;
          : ipv_sfCz6 [Occ=Once!] ipv1_sfCz7 [Occ=Once] ->
              case _ys_sfCz4 of {
                [] -> GHC.List.badHead;
                : ipv2_sfCz9 [Occ=Once] ipv3_sfCza [Occ=Once] ->
                    case ipv_sfCz6 of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCzd [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfCzd Data.Semigroup.$fDataMax7 of {
                            GHC.Types.False -> go1_rfC6n ipv1_sfCz7 ipv3_sfCza;
                            GHC.Types.True -> ipv2_sfCz9;
                          };
                    };
              };
        };

$cMax2_rfC6o :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cMax3_rfC6p];
Data.Semigroup.$fDataMax6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cMax GHC.Types.[]];
Data.Semigroup.$fDataMax5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataMax6];
Data.Semigroup.$tMax :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataMax7
                                       Data.Semigroup.$fDataMax5];
Data.Semigroup.$cMax [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cMax2_rfC6o
                                     Data.Semigroup.$fDataMax7
                                     $cMax1_rfC6m
                                     Data.Data.Prefix
                                     Data.Semigroup.$tMax];
$cMax3_rfC6p :: Data.Data.ConIndex
[GblId] =
    [] \u [] go1_rfC6n Data.Semigroup.$fDataMax6 Data.Data.mkConstr1;

go2_rfC6q
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCzi _ys_sfCzj]
        case ds2_sfCzi of {
          [] -> GHC.List.badHead;
          : ipv_sfCzl [Occ=Once!] ipv1_sfCzm [Occ=Once] ->
              case _ys_sfCzj of {
                [] -> GHC.List.badHead;
                : ipv2_sfCzo [Occ=Once] ipv3_sfCzp [Occ=Once] ->
                    case ipv_sfCzl of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCzs [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfCzs Data.Semigroup.$fDataArg9 of {
                            GHC.Types.False -> go2_rfC6q ipv1_sfCzm ipv3_sfCzp;
                            GHC.Types.True -> ipv2_sfCzo;
                          };
                    };
              };
        };

$cArg1_rfC6r :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cArg2_rfC6s];
Data.Semigroup.$fDataArg8 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cArg GHC.Types.[]];
Data.Semigroup.$fDataArg7 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataArg8];
Data.Semigroup.$tArg :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataArg9
                                       Data.Semigroup.$fDataArg7];
Data.Semigroup.$cArg [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cArg1_rfC6r
                                     Data.Semigroup.$fDataArg9
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Semigroup.$tArg];
$cArg2_rfC6s :: Data.Data.ConIndex
[GblId] =
    [] \u [] go2_rfC6q Data.Semigroup.$fDataArg8 Data.Data.mkConstr1;

$cFirst1_rfC6t :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadFirst5 GHC.Types.[]];

go3_rfC6u
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCzx _ys_sfCzy]
        case ds2_sfCzx of {
          [] -> GHC.List.badHead;
          : ipv_sfCzA [Occ=Once!] ipv1_sfCzB [Occ=Once] ->
              case _ys_sfCzy of {
                [] -> GHC.List.badHead;
                : ipv2_sfCzD [Occ=Once] ipv3_sfCzE [Occ=Once] ->
                    case ipv_sfCzA of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCzH [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfCzH Data.Semigroup.$fDataFirst7 of {
                            GHC.Types.False -> go3_rfC6u ipv1_sfCzB ipv3_sfCzE;
                            GHC.Types.True -> ipv2_sfCzD;
                          };
                    };
              };
        };

$cFirst2_rfC6v :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cFirst3_rfC6w];
Data.Semigroup.$fDataFirst6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cFirst GHC.Types.[]];
Data.Semigroup.$fDataFirst5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataFirst6];
Data.Semigroup.$tFirst :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataFirst7
                                       Data.Semigroup.$fDataFirst5];
Data.Semigroup.$cFirst [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cFirst2_rfC6v
                                     Data.Semigroup.$fDataFirst7
                                     $cFirst1_rfC6t
                                     Data.Data.Prefix
                                     Data.Semigroup.$tFirst];
$cFirst3_rfC6w :: Data.Data.ConIndex
[GblId] =
    [] \u [] go3_rfC6u Data.Semigroup.$fDataFirst6 Data.Data.mkConstr1;

$cLast1_rfC6x :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadLast2 GHC.Types.[]];

go4_rfC6y
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCzM _ys_sfCzN]
        case ds2_sfCzM of {
          [] -> GHC.List.badHead;
          : ipv_sfCzP [Occ=Once!] ipv1_sfCzQ [Occ=Once] ->
              case _ys_sfCzN of {
                [] -> GHC.List.badHead;
                : ipv2_sfCzS [Occ=Once] ipv3_sfCzT [Occ=Once] ->
                    case ipv_sfCzP of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCzW [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfCzW Data.Semigroup.$fDataLast7 of {
                            GHC.Types.False -> go4_rfC6y ipv1_sfCzQ ipv3_sfCzT;
                            GHC.Types.True -> ipv2_sfCzS;
                          };
                    };
              };
        };

$cLast2_rfC6z :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cLast3_rfC6A];
Data.Semigroup.$fDataLast6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cLast GHC.Types.[]];
Data.Semigroup.$fDataLast5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataLast6];
Data.Semigroup.$tLast :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataLast7
                                       Data.Semigroup.$fDataLast5];
Data.Semigroup.$cLast [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cLast2_rfC6z
                                     Data.Semigroup.$fDataLast7
                                     $cLast1_rfC6x
                                     Data.Data.Prefix
                                     Data.Semigroup.$tLast];
$cLast3_rfC6A :: Data.Data.ConIndex
[GblId] =
    [] \u [] go4_rfC6y Data.Semigroup.$fDataLast6 Data.Data.mkConstr1;

Data.Semigroup.$fDataWrappedMonoid4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrappedMonoid"#;

Data.Semigroup.$fDataWrappedMonoid7 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.$fDataWrappedMonoid4;

$cWrapMonoid1_rfC6B :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadWrappedMonoid2
                      GHC.Types.[]];

go5_rfC6C
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCA1 _ys_sfCA2]
        case ds2_sfCA1 of {
          [] -> GHC.List.badHead;
          : ipv_sfCA4 [Occ=Once!] ipv1_sfCA5 [Occ=Once] ->
              case _ys_sfCA2 of {
                [] -> GHC.List.badHead;
                : ipv2_sfCA7 [Occ=Once] ipv3_sfCA8 [Occ=Once] ->
                    case ipv_sfCA4 of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCAb [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case
                              GHC.Base.eqString ds4_sfCAb Data.Semigroup.$fReadWrappedMonoid4
                          of
                          { GHC.Types.False -> go5_rfC6C ipv1_sfCA5 ipv3_sfCA8;
                            GHC.Types.True -> ipv2_sfCA7;
                          };
                    };
              };
        };

$cWrapMonoid2_rfC6D :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cWrapMonoid3_rfC6E];
Data.Semigroup.$fDataWrappedMonoid6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cWrapMonoid GHC.Types.[]];
Data.Semigroup.$fDataWrappedMonoid5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataWrappedMonoid6];
Data.Semigroup.$tWrappedMonoid :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataWrappedMonoid7
                                       Data.Semigroup.$fDataWrappedMonoid5];
Data.Semigroup.$cWrapMonoid [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cWrapMonoid2_rfC6D
                                     Data.Semigroup.$fReadWrappedMonoid4
                                     $cWrapMonoid1_rfC6B
                                     Data.Data.Prefix
                                     Data.Semigroup.$tWrappedMonoid];
$cWrapMonoid3_rfC6E :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go5_rfC6C Data.Semigroup.$fDataWrappedMonoid6 Data.Data.mkConstr1;

$cOption1_rfC6F :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadOption2 GHC.Types.[]];

go6_rfC6G
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCAg _ys_sfCAh]
        case ds2_sfCAg of {
          [] -> GHC.List.badHead;
          : ipv_sfCAj [Occ=Once!] ipv1_sfCAk [Occ=Once] ->
              case _ys_sfCAh of {
                [] -> GHC.List.badHead;
                : ipv2_sfCAm [Occ=Once] ipv3_sfCAn [Occ=Once] ->
                    case ipv_sfCAj of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCAq [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfCAq Data.Semigroup.$fDataOption9 of {
                            GHC.Types.False -> go6_rfC6G ipv1_sfCAk ipv3_sfCAn;
                            GHC.Types.True -> ipv2_sfCAm;
                          };
                    };
              };
        };

$cOption2_rfC6H :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cOption3_rfC6I];
Data.Semigroup.$fDataOption8 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cOption GHC.Types.[]];
Data.Semigroup.$fDataOption7 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataOption8];
Data.Semigroup.$tOption :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataOption9
                                       Data.Semigroup.$fDataOption7];
Data.Semigroup.$cOption [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cOption2_rfC6H
                                     Data.Semigroup.$fDataOption9
                                     $cOption1_rfC6F
                                     Data.Data.Prefix
                                     Data.Semigroup.$tOption];
$cOption3_rfC6I :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go6_rfC6G Data.Semigroup.$fDataOption8 Data.Data.mkConstr1;

Data.Semigroup.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Semigroup.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$trModule4];

Data.Semigroup.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Semigroup"#;

Data.Semigroup.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$trModule2];

Data.Semigroup.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Semigroup.$trModule3
                                     Data.Semigroup.$trModule1];

$krep_rfC6J :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_rfC6K :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_rfC6L :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rfC6K GHC.Types.[]];

$krep3_rfC6M :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep2_rfC6L];

Data.Semigroup.$fDataMin3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataMin4];

Data.Semigroup.$tcMin :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2898124504153588682##
                                    15185633012309158566##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataMin3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep4_rfC6N :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcMin
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Min1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep4_rfC6N];

Data.Semigroup.$tc'Min3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Min"#;

Data.Semigroup.$tc'Min2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Min3];

Data.Semigroup.$tc'Min :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7769702422559516318##
                                    9758175179672887730##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Min2
                                    1#
                                    Data.Semigroup.$tc'Min1];

Data.Semigroup.$fDataMin2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Min
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                2898124504153588682##
                15185633012309158566##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataMin3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCAw [Occ=Once]
                   ww9_sfCAx [Occ=Once]
                   ww10_sfCAy [Occ=Once]
                   ww11_sfCAz [Occ=Once]
                   ww12_sfCAA [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCAw
                                              ww9_sfCAx
                                              ww10_sfCAy
                                              ww11_sfCAz
                                              ww12_sfCAA];
        };

Data.Semigroup.$fDataMin8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Min a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCAB]
        case Data.Data.$p1Data $dData_sfCAB of sat_sfCAC {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp Data.Semigroup.$fDataMin2 sat_sfCAC;
        };

Data.Semigroup.$fDataMin_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Min a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCAD $dTypeable_sfCAE]
        let {
          lvl33_sfCAF [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCAE] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCAE Data.Semigroup.$fDataMin2; } in
        let {
          sat_sfCAJ [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afxz6 (t_afxz5 d))
               -> GHC.Base.Maybe (c_afxz6 (Data.Semigroup.Min a_Xfy02))
          [LclId] =
              [$dData_sfCAD lvl33_sfCAF] \r [f_sfCAG]
                  case lvl33_sfCAF of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCAI [Occ=Once] :: c_afxz6 (Data.Semigroup.Min a_Xfy02)
                          [LclId] =
                              [$dData_sfCAD f_sfCAG] \u [] f_sfCAG $dData_sfCAD;
                        } in  GHC.Base.Just [sat_sfCAI];
                  };
        } in  sat_sfCAJ;

Data.Semigroup.$fDataMin1
  :: forall a. (a -> Data.Semigroup.Min a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataMin_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Min a -> m (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCAK $dMonadPlus_sfCAL ds_sfCAM eta_sfCAN]
        let {
          lvl33_sfCAO [Occ=OnceL] :: m_afxBb (Data.Semigroup.Min a_Xfy0b)
          [LclId] =
              [$dMonadPlus_sfCAL] \u [] GHC.Base.mzero $dMonadPlus_sfCAL;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCAL
          of
          $dMonad_sfCAP [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCBb [Occ=Once]
                    :: (Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                       -> m_afxBb (Data.Semigroup.Min a_Xfy0b)
                  [LclId] =
                      [lvl33_sfCAO $dMonad_sfCAP] \r [ds1_sfCB6]
                          case ds1_sfCB6 of {
                            (,) x'_sfCB8 [Occ=Once] b_sfCB9 [Occ=Once!] ->
                                case b_sfCB9 of {
                                  GHC.Types.False -> lvl33_sfCAO;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCAP x'_sfCB8;
                                };
                          }; } in
                let {
                  sat_sfCB5 [Occ=Once]
                    :: m_afxBb (Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCAK
                       $dMonadPlus_sfCAL
                       ds_sfCAM
                       eta_sfCAN
                       $dMonad_sfCAP] \u []
                          let {
                            lvl34_sfCAQ [Occ=OnceL] :: m_afxBb a_Xfy0b
                            [LclId] =
                                [$dData_sfCAK ds_sfCAM eta_sfCAN] \u []
                                    ds_sfCAM $dData_sfCAK eta_sfCAN; } in
                          let {
                            sat_sfCB4 [Occ=Once]
                              :: (a_Xfy0b -> Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                                 -> m_afxBb (Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCAL
                                 eta_sfCAN
                                 $dMonad_sfCAP
                                 lvl34_sfCAQ] \r [ds1_sfCAS]
                                    case ds1_sfCAS of {
                                      (,) h_sfCAU b1_sfCAV [Occ=Once] ->
                                          let {
                                            sat_sfCB3 [Occ=Once]
                                              :: m_afxBb (Data.Semigroup.Min a_Xfy0b,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfCAN $dMonad_sfCAP h_sfCAU b1_sfCAV] \u []
                                                    let {
                                                      sat_sfCB1 [Occ=Once]
                                                        :: Data.Semigroup.Min a_Xfy0b
                                                      [LclId] =
                                                          [eta_sfCAN h_sfCAU] \u []
                                                              h_sfCAU eta_sfCAN; } in
                                                    let {
                                                      sat_sfCB2 [Occ=Once]
                                                        :: (Data.Semigroup.Min a_Xfy0b,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfCB1 b1_sfCAV];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfCAP sat_sfCB2; } in
                                          let {
                                            sat_sfCB0 [Occ=Once]
                                              :: m_afxBb (Data.Semigroup.Min a_Xfy0b,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfCAP lvl34_sfCAQ h_sfCAU] \u []
                                                    let {
                                                      sat_sfCAZ [Occ=Once]
                                                        :: a_Xfy0b
                                                           -> m_afxBb (Data.Semigroup.Min a_Xfy0b,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfCAP h_sfCAU] \r [y'_sfCAW]
                                                              let {
                                                                sat_sfCAX [Occ=Once]
                                                                  :: Data.Semigroup.Min a_Xfy0b
                                                                [LclId] =
                                                                    [h_sfCAU y'_sfCAW] \u []
                                                                        h_sfCAU y'_sfCAW; } in
                                                              let {
                                                                sat_sfCAY [Occ=Once]
                                                                  :: (Data.Semigroup.Min a_Xfy0b,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfCAX
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfCAP sat_sfCAY;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfCAP lvl34_sfCAQ sat_sfCAZ;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfCAL sat_sfCB0 sat_sfCB3;
                                    }; } in
                          let {
                            sat_sfCAR [Occ=Once]
                              :: m_afxBb (a_Xfy0b -> Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCAP] \u []
                                    GHC.Base.return $dMonad_sfCAP Data.Semigroup.$fDataMin1;
                          } in  GHC.Base.>>= $dMonad_sfCAP sat_sfCAR sat_sfCB4;
                } in  GHC.Base.>>= $dMonad_sfCAP sat_sfCB5 sat_sfCBb;
          };

Data.Semigroup.$fDataMin_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Min a -> m (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCBc $dMonad_sfCBd ds_sfCBe eta_sfCBf]
        let {
          lvl33_sfCBg [Occ=OnceL] :: m_afxAV a_Xfy0a
          [LclId] =
              [$dData_sfCBc ds_sfCBe eta_sfCBf] \u []
                  ds_sfCBe $dData_sfCBc eta_sfCBf; } in
        let {
          sat_sfCBm [Occ=Once]
            :: (a_Xfy0a -> Data.Semigroup.Min a_Xfy0a)
               -> m_afxAV (Data.Semigroup.Min a_Xfy0a)
          [LclId] =
              [$dMonad_sfCBd lvl33_sfCBg] \r [c'_sfCBi]
                  let {
                    sat_sfCBl [Occ=Once]
                      :: a_Xfy0a -> m_afxAV (Data.Semigroup.Min a_Xfy0a)
                    [LclId] =
                        [$dMonad_sfCBd c'_sfCBi] \r [x'_sfCBj]
                            let {
                              sat_sfCBk [Occ=Once] :: Data.Semigroup.Min a_Xfy0a
                              [LclId] =
                                  [c'_sfCBi x'_sfCBj] \u [] c'_sfCBi x'_sfCBj;
                            } in  GHC.Base.return $dMonad_sfCBd sat_sfCBk;
                  } in  GHC.Base.>>= $dMonad_sfCBd lvl33_sfCBg sat_sfCBl; } in
        let {
          sat_sfCBh [Occ=Once]
            :: m_afxAV (a_Xfy0a -> Data.Semigroup.Min a_Xfy0a)
          [LclId] =
              [$dMonad_sfCBd] \u []
                  GHC.Base.return $dMonad_sfCBd Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfCBd sat_sfCBh sat_sfCBm;

Data.Semigroup.$fDataMin_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Min a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCBn ds_sfCBo ds1_sfCBp x_sfCBq]
        case ds_sfCBo of {
          GHC.Types.I# x1_sfCBs [Occ=Once!] ->
              case x1_sfCBs of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfCBp $dData_sfCBn x_sfCBq;
              };
        };

Data.Semigroup.$fDataMin_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Min a -> m (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCBu $dMonadPlus_sfCBv ds_sfCBw eta_sfCBx]
        let {
          lvl33_sfCBy [Occ=OnceL] :: m_afxBr (Data.Semigroup.Min a_Xfy04)
          [LclId] =
              [$dMonadPlus_sfCBv] \u [] GHC.Base.mzero $dMonadPlus_sfCBv;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCBv
          of
          $dMonad_sfCBz [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCBY [Occ=Once]
                    :: (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                       -> m_afxBr (Data.Semigroup.Min a_Xfy04)
                  [LclId] =
                      [lvl33_sfCBy $dMonad_sfCBz] \r [ds1_sfCBT]
                          case ds1_sfCBT of {
                            (,) x'_sfCBV [Occ=Once] b_sfCBW [Occ=Once!] ->
                                case b_sfCBW of {
                                  GHC.Types.False -> lvl33_sfCBy;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCBz x'_sfCBV;
                                };
                          }; } in
                let {
                  sat_sfCBS [Occ=Once]
                    :: m_afxBr (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCBu
                       $dMonadPlus_sfCBv
                       ds_sfCBw
                       eta_sfCBx
                       $dMonad_sfCBz] \u []
                          let {
                            lvl34_sfCBA [Occ=OnceL] :: m_afxBr a_Xfy04
                            [LclId] =
                                [$dData_sfCBu ds_sfCBw eta_sfCBx] \u []
                                    ds_sfCBw $dData_sfCBu eta_sfCBx; } in
                          let {
                            sat_sfCBR [Occ=Once]
                              :: (a_Xfy04 -> Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                                 -> m_afxBr (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCBv
                                 eta_sfCBx
                                 $dMonad_sfCBz
                                 lvl34_sfCBA] \r [ds1_sfCBC]
                                    case ds1_sfCBC of {
                                      (,) h_sfCBE b1_sfCBF [Occ=Once!] ->
                                          case b1_sfCBF of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfCBO [Occ=Once]
                                                    :: m_afxBr (Data.Semigroup.Min a_Xfy04,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfCBx $dMonad_sfCBz h_sfCBE] \u []
                                                          let {
                                                            sat_sfCBM [Occ=Once]
                                                              :: Data.Semigroup.Min a_Xfy04
                                                            [LclId] =
                                                                [eta_sfCBx h_sfCBE] \u []
                                                                    h_sfCBE eta_sfCBx; } in
                                                          let {
                                                            sat_sfCBN [Occ=Once]
                                                              :: (Data.Semigroup.Min a_Xfy04,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfCBM
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfCBz sat_sfCBN; } in
                                                let {
                                                  sat_sfCBL [Occ=Once]
                                                    :: m_afxBr (Data.Semigroup.Min a_Xfy04,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfCBz lvl34_sfCBA h_sfCBE] \u []
                                                          let {
                                                            sat_sfCBK [Occ=Once]
                                                              :: a_Xfy04
                                                                 -> m_afxBr (Data.Semigroup.Min
                                                                               a_Xfy04,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCBz
                                                                 h_sfCBE] \r [y'_sfCBH]
                                                                    let {
                                                                      sat_sfCBI [Occ=Once]
                                                                        :: Data.Semigroup.Min
                                                                             a_Xfy04
                                                                      [LclId] =
                                                                          [h_sfCBE y'_sfCBH] \u []
                                                                              h_sfCBE y'_sfCBH; } in
                                                                    let {
                                                                      sat_sfCBJ [Occ=Once]
                                                                        :: (Data.Semigroup.Min
                                                                              a_Xfy04,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCBI
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCBz sat_sfCBJ;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfCBz lvl34_sfCBA sat_sfCBK;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfCBv sat_sfCBL sat_sfCBO;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfCBP [Occ=Once] :: Data.Semigroup.Min a_Xfy04
                                                  [LclId] =
                                                      [eta_sfCBx h_sfCBE] \u []
                                                          h_sfCBE eta_sfCBx; } in
                                                let {
                                                  sat_sfCBQ [Occ=Once]
                                                    :: (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfCBP GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfCBz sat_sfCBQ;
                                          };
                                    }; } in
                          let {
                            sat_sfCBB [Occ=Once]
                              :: m_afxBr (a_Xfy04 -> Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCBz] \u []
                                    GHC.Base.return $dMonad_sfCBz Data.Semigroup.$fDataMin1;
                          } in  GHC.Base.>>= $dMonad_sfCBz sat_sfCBB sat_sfCBR;
                } in  GHC.Base.>>= $dMonad_sfCBz sat_sfCBS sat_sfCBY;
          };

lvl12_rfC6O :: forall a. Data.Semigroup.Min a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCBZ] Data.Semigroup.$cMin;

lvl13_rfC6P :: forall a. Data.Semigroup.Min a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCC0] Data.Semigroup.$tMin;

lvl14_rfC6Q
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Min a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCC1 ds_sfCC2] GHC.Base.Nothing [];

Data.Semigroup.$fDataMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCC3]
        let {
          sat_sfCCy [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Min a_Xfy03 -> m (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfCC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapMo
                      $dData_sfCC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCCx [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Min a_Xfy03 -> m (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfCC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapMp
                      $dData_sfCC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCCw [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Min a_Xfy03 -> m (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfCC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapM
                      $dData_sfCC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCCv [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Min a_Xfy03
               -> u
          [LclId] =
              [$dData_sfCC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapQi
                      $dData_sfCC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCCu [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Min a_Xfy03 -> [u]
          [LclId] =
              [$dData_sfCC3] \r [ds_sfCCr x0_sfCCs]
                  let {
                    sat_sfCCt [Occ=Once] :: u_afxAt
                    [LclId] =
                        [$dData_sfCC3 ds_sfCCr x0_sfCCs] \u []
                            ds_sfCCr $dData_sfCC3 x0_sfCCs;
                  } in  : [sat_sfCCt GHC.Types.[]]; } in
        let {
          sat_sfCCq [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Min a_Xfy03
               -> r
          [LclId] =
              [$dData_sfCC3] \r [ds_sfCCl ds1_sfCCm ds2_sfCCn x0_sfCCo]
                  let {
                    sat_sfCCp [Occ=Once] :: r'_afxAd
                    [LclId] =
                        [$dData_sfCC3 ds2_sfCCn x0_sfCCo] \u []
                            ds2_sfCCn $dData_sfCC3 x0_sfCCo;
                  } in  ds_sfCCl sat_sfCCp ds1_sfCCm; } in
        let {
          sat_sfCCk [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Min a_Xfy03
               -> r
          [LclId] =
              [$dData_sfCC3] \r [ds_sfCCf ds1_sfCCg ds2_sfCCh eta_sfCCi]
                  let {
                    sat_sfCCj [Occ=Once] :: r'_afxzW
                    [LclId] =
                        [$dData_sfCC3 ds2_sfCCh eta_sfCCi] \u []
                            ds2_sfCCh $dData_sfCC3 eta_sfCCi;
                  } in  ds_sfCCf ds1_sfCCg sat_sfCCj; } in
        let {
          sat_sfCCe [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Min a_Xfy03 -> Data.Semigroup.Min a_Xfy03
          [LclId] =
              [$dData_sfCC3] \r [ds_sfCCc x0_sfCCd]
                  ds_sfCCc $dData_sfCC3 x0_sfCCd; } in
        let {
          sat_sfCCb [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Min a_Xfy03))
          [LclId] =
              [$dData_sfCC3] \r [eta_B1]
                  Data.Semigroup.$fDataMin_$cdataCast1 $dData_sfCC3 eta_B1; } in
        let {
          sat_sfCCa [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfCC3] \r [k_sfCC6 z_sfCC7 ds_sfCC8]
                  let {
                    sat_sfCC9 [Occ=Once]
                      :: c_afxyM (a_Xfy03 -> Data.Semigroup.Min a_Xfy03)
                    [LclId] =
                        [z_sfCC7] \u [] z_sfCC7 Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfCC6 $dData_sfCC3 sat_sfCC9; } in
        let {
          sat_sfCC5 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Min a_Xfy03
               -> c (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfCC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgfoldl
                      $dData_sfCC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCC4 [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfCC3] \u [] Data.Semigroup.$fDataMin8 $dData_sfCC3;
        } in 
          Data.Data.C:Data [sat_sfCC4
                            sat_sfCC5
                            sat_sfCCa
                            lvl12_rfC6O
                            lvl13_rfC6P
                            sat_sfCCb
                            lvl14_rfC6Q
                            sat_sfCCe
                            sat_sfCCk
                            sat_sfCCq
                            sat_sfCCu
                            sat_sfCCv
                            sat_sfCCw
                            sat_sfCCx
                            sat_sfCCy];

Data.Semigroup.$fDataMax3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataMax4];

Data.Semigroup.$tcMax :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10813679156066679206##
                                    10491840004411982061##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataMax3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep5_rfC6R :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcMax
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Max1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep5_rfC6R];

Data.Semigroup.$tc'Max3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Max"#;

Data.Semigroup.$tc'Max2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Max3];

Data.Semigroup.$tc'Max :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9964620667386625613##
                                    8300955803911017019##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Max2
                                    1#
                                    Data.Semigroup.$tc'Max1];

Data.Semigroup.$fDataMax2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Max
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                10813679156066679206##
                10491840004411982061##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataMax3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCCA [Occ=Once]
                   ww9_sfCCB [Occ=Once]
                   ww10_sfCCC [Occ=Once]
                   ww11_sfCCD [Occ=Once]
                   ww12_sfCCE [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCCA
                                              ww9_sfCCB
                                              ww10_sfCCC
                                              ww11_sfCCD
                                              ww12_sfCCE];
        };

Data.Semigroup.$fDataMax8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Max a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCCF]
        case Data.Data.$p1Data $dData_sfCCF of sat_sfCCG {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp Data.Semigroup.$fDataMax2 sat_sfCCG;
        };

Data.Semigroup.$fDataMax_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Max a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCCH $dTypeable_sfCCI]
        let {
          lvl33_sfCCJ [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCCI] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCCI Data.Semigroup.$fDataMax2; } in
        let {
          sat_sfCCN [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afxI8 (t_afxI7 d))
               -> GHC.Base.Maybe (c_afxI8 (Data.Semigroup.Max a_Xfy9s))
          [LclId] =
              [$dData_sfCCH lvl33_sfCCJ] \r [f_sfCCK]
                  case lvl33_sfCCJ of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCCM [Occ=Once] :: c_afxI8 (Data.Semigroup.Max a_Xfy9s)
                          [LclId] =
                              [$dData_sfCCH f_sfCCK] \u [] f_sfCCK $dData_sfCCH;
                        } in  GHC.Base.Just [sat_sfCCM];
                  };
        } in  sat_sfCCN;

Data.Semigroup.$fDataMax1
  :: forall a. (a -> Data.Semigroup.Max a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataMax_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Max a -> m (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCCO $dMonadPlus_sfCCP ds_sfCCQ eta_sfCCR]
        let {
          lvl33_sfCCS [Occ=OnceL] :: m_afxKd (Data.Semigroup.Max a_Xfy9B)
          [LclId] =
              [$dMonadPlus_sfCCP] \u [] GHC.Base.mzero $dMonadPlus_sfCCP;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCCP
          of
          $dMonad_sfCCT [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCDf [Occ=Once]
                    :: (Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                       -> m_afxKd (Data.Semigroup.Max a_Xfy9B)
                  [LclId] =
                      [lvl33_sfCCS $dMonad_sfCCT] \r [ds1_sfCDa]
                          case ds1_sfCDa of {
                            (,) x'_sfCDc [Occ=Once] b_sfCDd [Occ=Once!] ->
                                case b_sfCDd of {
                                  GHC.Types.False -> lvl33_sfCCS;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCCT x'_sfCDc;
                                };
                          }; } in
                let {
                  sat_sfCD9 [Occ=Once]
                    :: m_afxKd (Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCCO
                       $dMonadPlus_sfCCP
                       ds_sfCCQ
                       eta_sfCCR
                       $dMonad_sfCCT] \u []
                          let {
                            lvl34_sfCCU [Occ=OnceL] :: m_afxKd a_Xfy9B
                            [LclId] =
                                [$dData_sfCCO ds_sfCCQ eta_sfCCR] \u []
                                    ds_sfCCQ $dData_sfCCO eta_sfCCR; } in
                          let {
                            sat_sfCD8 [Occ=Once]
                              :: (a_Xfy9B -> Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                                 -> m_afxKd (Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCCP
                                 eta_sfCCR
                                 $dMonad_sfCCT
                                 lvl34_sfCCU] \r [ds1_sfCCW]
                                    case ds1_sfCCW of {
                                      (,) h_sfCCY b1_sfCCZ [Occ=Once] ->
                                          let {
                                            sat_sfCD7 [Occ=Once]
                                              :: m_afxKd (Data.Semigroup.Max a_Xfy9B,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfCCR $dMonad_sfCCT h_sfCCY b1_sfCCZ] \u []
                                                    let {
                                                      sat_sfCD5 [Occ=Once]
                                                        :: Data.Semigroup.Max a_Xfy9B
                                                      [LclId] =
                                                          [eta_sfCCR h_sfCCY] \u []
                                                              h_sfCCY eta_sfCCR; } in
                                                    let {
                                                      sat_sfCD6 [Occ=Once]
                                                        :: (Data.Semigroup.Max a_Xfy9B,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfCD5 b1_sfCCZ];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfCCT sat_sfCD6; } in
                                          let {
                                            sat_sfCD4 [Occ=Once]
                                              :: m_afxKd (Data.Semigroup.Max a_Xfy9B,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfCCT lvl34_sfCCU h_sfCCY] \u []
                                                    let {
                                                      sat_sfCD3 [Occ=Once]
                                                        :: a_Xfy9B
                                                           -> m_afxKd (Data.Semigroup.Max a_Xfy9B,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfCCT h_sfCCY] \r [y'_sfCD0]
                                                              let {
                                                                sat_sfCD1 [Occ=Once]
                                                                  :: Data.Semigroup.Max a_Xfy9B
                                                                [LclId] =
                                                                    [h_sfCCY y'_sfCD0] \u []
                                                                        h_sfCCY y'_sfCD0; } in
                                                              let {
                                                                sat_sfCD2 [Occ=Once]
                                                                  :: (Data.Semigroup.Max a_Xfy9B,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfCD1
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfCCT sat_sfCD2;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfCCT lvl34_sfCCU sat_sfCD3;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfCCP sat_sfCD4 sat_sfCD7;
                                    }; } in
                          let {
                            sat_sfCCV [Occ=Once]
                              :: m_afxKd (a_Xfy9B -> Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCCT] \u []
                                    GHC.Base.return $dMonad_sfCCT Data.Semigroup.$fDataMax1;
                          } in  GHC.Base.>>= $dMonad_sfCCT sat_sfCCV sat_sfCD8;
                } in  GHC.Base.>>= $dMonad_sfCCT sat_sfCD9 sat_sfCDf;
          };

Data.Semigroup.$fDataMax_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Max a -> m (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCDg $dMonad_sfCDh ds_sfCDi eta_sfCDj]
        let {
          lvl33_sfCDk [Occ=OnceL] :: m_afxJX a_Xfy9A
          [LclId] =
              [$dData_sfCDg ds_sfCDi eta_sfCDj] \u []
                  ds_sfCDi $dData_sfCDg eta_sfCDj; } in
        let {
          sat_sfCDq [Occ=Once]
            :: (a_Xfy9A -> Data.Semigroup.Max a_Xfy9A)
               -> m_afxJX (Data.Semigroup.Max a_Xfy9A)
          [LclId] =
              [$dMonad_sfCDh lvl33_sfCDk] \r [c'_sfCDm]
                  let {
                    sat_sfCDp [Occ=Once]
                      :: a_Xfy9A -> m_afxJX (Data.Semigroup.Max a_Xfy9A)
                    [LclId] =
                        [$dMonad_sfCDh c'_sfCDm] \r [x'_sfCDn]
                            let {
                              sat_sfCDo [Occ=Once] :: Data.Semigroup.Max a_Xfy9A
                              [LclId] =
                                  [c'_sfCDm x'_sfCDn] \u [] c'_sfCDm x'_sfCDn;
                            } in  GHC.Base.return $dMonad_sfCDh sat_sfCDo;
                  } in  GHC.Base.>>= $dMonad_sfCDh lvl33_sfCDk sat_sfCDp; } in
        let {
          sat_sfCDl [Occ=Once]
            :: m_afxJX (a_Xfy9A -> Data.Semigroup.Max a_Xfy9A)
          [LclId] =
              [$dMonad_sfCDh] \u []
                  GHC.Base.return $dMonad_sfCDh Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfCDh sat_sfCDl sat_sfCDq;

Data.Semigroup.$fDataMax_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Max a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCDr ds_sfCDs ds1_sfCDt x_sfCDu]
        case ds_sfCDs of {
          GHC.Types.I# x1_sfCDw [Occ=Once!] ->
              case x1_sfCDw of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfCDt $dData_sfCDr x_sfCDu;
              };
        };

Data.Semigroup.$fDataMax_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Max a -> m (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCDy $dMonadPlus_sfCDz ds_sfCDA eta_sfCDB]
        let {
          lvl33_sfCDC [Occ=OnceL] :: m_afxKt (Data.Semigroup.Max a_Xfy9u)
          [LclId] =
              [$dMonadPlus_sfCDz] \u [] GHC.Base.mzero $dMonadPlus_sfCDz;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCDz
          of
          $dMonad_sfCDD [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCE2 [Occ=Once]
                    :: (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                       -> m_afxKt (Data.Semigroup.Max a_Xfy9u)
                  [LclId] =
                      [lvl33_sfCDC $dMonad_sfCDD] \r [ds1_sfCDX]
                          case ds1_sfCDX of {
                            (,) x'_sfCDZ [Occ=Once] b_sfCE0 [Occ=Once!] ->
                                case b_sfCE0 of {
                                  GHC.Types.False -> lvl33_sfCDC;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCDD x'_sfCDZ;
                                };
                          }; } in
                let {
                  sat_sfCDW [Occ=Once]
                    :: m_afxKt (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCDy
                       $dMonadPlus_sfCDz
                       ds_sfCDA
                       eta_sfCDB
                       $dMonad_sfCDD] \u []
                          let {
                            lvl34_sfCDE [Occ=OnceL] :: m_afxKt a_Xfy9u
                            [LclId] =
                                [$dData_sfCDy ds_sfCDA eta_sfCDB] \u []
                                    ds_sfCDA $dData_sfCDy eta_sfCDB; } in
                          let {
                            sat_sfCDV [Occ=Once]
                              :: (a_Xfy9u -> Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                                 -> m_afxKt (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCDz
                                 eta_sfCDB
                                 $dMonad_sfCDD
                                 lvl34_sfCDE] \r [ds1_sfCDG]
                                    case ds1_sfCDG of {
                                      (,) h_sfCDI b1_sfCDJ [Occ=Once!] ->
                                          case b1_sfCDJ of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfCDS [Occ=Once]
                                                    :: m_afxKt (Data.Semigroup.Max a_Xfy9u,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfCDB $dMonad_sfCDD h_sfCDI] \u []
                                                          let {
                                                            sat_sfCDQ [Occ=Once]
                                                              :: Data.Semigroup.Max a_Xfy9u
                                                            [LclId] =
                                                                [eta_sfCDB h_sfCDI] \u []
                                                                    h_sfCDI eta_sfCDB; } in
                                                          let {
                                                            sat_sfCDR [Occ=Once]
                                                              :: (Data.Semigroup.Max a_Xfy9u,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfCDQ
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfCDD sat_sfCDR; } in
                                                let {
                                                  sat_sfCDP [Occ=Once]
                                                    :: m_afxKt (Data.Semigroup.Max a_Xfy9u,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfCDD lvl34_sfCDE h_sfCDI] \u []
                                                          let {
                                                            sat_sfCDO [Occ=Once]
                                                              :: a_Xfy9u
                                                                 -> m_afxKt (Data.Semigroup.Max
                                                                               a_Xfy9u,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCDD
                                                                 h_sfCDI] \r [y'_sfCDL]
                                                                    let {
                                                                      sat_sfCDM [Occ=Once]
                                                                        :: Data.Semigroup.Max
                                                                             a_Xfy9u
                                                                      [LclId] =
                                                                          [h_sfCDI y'_sfCDL] \u []
                                                                              h_sfCDI y'_sfCDL; } in
                                                                    let {
                                                                      sat_sfCDN [Occ=Once]
                                                                        :: (Data.Semigroup.Max
                                                                              a_Xfy9u,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCDM
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCDD sat_sfCDN;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfCDD lvl34_sfCDE sat_sfCDO;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfCDz sat_sfCDP sat_sfCDS;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfCDT [Occ=Once] :: Data.Semigroup.Max a_Xfy9u
                                                  [LclId] =
                                                      [eta_sfCDB h_sfCDI] \u []
                                                          h_sfCDI eta_sfCDB; } in
                                                let {
                                                  sat_sfCDU [Occ=Once]
                                                    :: (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfCDT GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfCDD sat_sfCDU;
                                          };
                                    }; } in
                          let {
                            sat_sfCDF [Occ=Once]
                              :: m_afxKt (a_Xfy9u -> Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCDD] \u []
                                    GHC.Base.return $dMonad_sfCDD Data.Semigroup.$fDataMax1;
                          } in  GHC.Base.>>= $dMonad_sfCDD sat_sfCDF sat_sfCDV;
                } in  GHC.Base.>>= $dMonad_sfCDD sat_sfCDW sat_sfCE2;
          };

lvl15_rfC6S :: forall a. Data.Semigroup.Max a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCE3] Data.Semigroup.$cMax;

lvl16_rfC6T :: forall a. Data.Semigroup.Max a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCE4] Data.Semigroup.$tMax;

lvl17_rfC6U
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Max a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCE5 ds_sfCE6] GHC.Base.Nothing [];

Data.Semigroup.$fDataMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCE7]
        let {
          sat_sfCEC [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Max a_Xfy9t -> m (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfCE7] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapMo
                      $dData_sfCE7 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCEB [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Max a_Xfy9t -> m (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfCE7] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapMp
                      $dData_sfCE7 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCEA [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Max a_Xfy9t -> m (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfCE7] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapM
                      $dData_sfCE7 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCEz [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Max a_Xfy9t
               -> u
          [LclId] =
              [$dData_sfCE7] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapQi
                      $dData_sfCE7 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCEy [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Max a_Xfy9t -> [u]
          [LclId] =
              [$dData_sfCE7] \r [ds_sfCEv x0_sfCEw]
                  let {
                    sat_sfCEx [Occ=Once] :: u_afxJv
                    [LclId] =
                        [$dData_sfCE7 ds_sfCEv x0_sfCEw] \u []
                            ds_sfCEv $dData_sfCE7 x0_sfCEw;
                  } in  : [sat_sfCEx GHC.Types.[]]; } in
        let {
          sat_sfCEu [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Max a_Xfy9t
               -> r
          [LclId] =
              [$dData_sfCE7] \r [ds_sfCEp ds1_sfCEq ds2_sfCEr x0_sfCEs]
                  let {
                    sat_sfCEt [Occ=Once] :: r'_afxJf
                    [LclId] =
                        [$dData_sfCE7 ds2_sfCEr x0_sfCEs] \u []
                            ds2_sfCEr $dData_sfCE7 x0_sfCEs;
                  } in  ds_sfCEp sat_sfCEt ds1_sfCEq; } in
        let {
          sat_sfCEo [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Max a_Xfy9t
               -> r
          [LclId] =
              [$dData_sfCE7] \r [ds_sfCEj ds1_sfCEk ds2_sfCEl eta_sfCEm]
                  let {
                    sat_sfCEn [Occ=Once] :: r'_afxIY
                    [LclId] =
                        [$dData_sfCE7 ds2_sfCEl eta_sfCEm] \u []
                            ds2_sfCEl $dData_sfCE7 eta_sfCEm;
                  } in  ds_sfCEj ds1_sfCEk sat_sfCEn; } in
        let {
          sat_sfCEi [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Max a_Xfy9t -> Data.Semigroup.Max a_Xfy9t
          [LclId] =
              [$dData_sfCE7] \r [ds_sfCEg x0_sfCEh]
                  ds_sfCEg $dData_sfCE7 x0_sfCEh; } in
        let {
          sat_sfCEf [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Max a_Xfy9t))
          [LclId] =
              [$dData_sfCE7] \r [eta_B1]
                  Data.Semigroup.$fDataMax_$cdataCast1 $dData_sfCE7 eta_B1; } in
        let {
          sat_sfCEe [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfCE7] \r [k_sfCEa z_sfCEb ds_sfCEc]
                  let {
                    sat_sfCEd [Occ=Once]
                      :: c_afxHO (a_Xfy9t -> Data.Semigroup.Max a_Xfy9t)
                    [LclId] =
                        [z_sfCEb] \u [] z_sfCEb Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfCEa $dData_sfCE7 sat_sfCEd; } in
        let {
          sat_sfCE9 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Max a_Xfy9t
               -> c (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfCE7] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgfoldl
                      $dData_sfCE7 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCE8 [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfCE7] \u [] Data.Semigroup.$fDataMax8 $dData_sfCE7;
        } in 
          Data.Data.C:Data [sat_sfCE8
                            sat_sfCE9
                            sat_sfCEe
                            lvl15_rfC6S
                            lvl16_rfC6T
                            sat_sfCEf
                            lvl17_rfC6U
                            sat_sfCEi
                            sat_sfCEo
                            sat_sfCEu
                            sat_sfCEy
                            sat_sfCEz
                            sat_sfCEA
                            sat_sfCEB
                            sat_sfCEC];

Data.Semigroup.$fDataArg5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataArg6];

Data.Semigroup.$tcArg :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12181131229304595757##
                                    13964868205162960136##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataArg5
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep6_rfC6V :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rfC6J GHC.Types.[]];

$krep7_rfC6W :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rfC6K $krep6_rfC6V];

$krep8_rfC6X :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcArg
                                              $krep7_rfC6W];

$krep9_rfC6Y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rfC6J $krep8_rfC6X];

Data.Semigroup.$tc'Arg1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep9_rfC6Y];

Data.Semigroup.$tc'Arg3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Arg"#;

Data.Semigroup.$tc'Arg2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Arg3];

Data.Semigroup.$tc'Arg :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1079323530693211499##
                                    7260223244427450599##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Arg2
                                    2#
                                    Data.Semigroup.$tc'Arg1];

Data.Semigroup.$fDataArg4
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Arg
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                12181131229304595757##
                13964868205162960136##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataArg5
                0#
                GHC.Types.krep$*->*->*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCEE [Occ=Once]
                   ww9_sfCEF [Occ=Once]
                   ww10_sfCEG [Occ=Once]
                   ww11_sfCEH [Occ=Once]
                   ww12_sfCEI [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCEE
                                              ww9_sfCEF
                                              ww10_sfCEG
                                              ww11_sfCEH
                                              ww12_sfCEI];
        };

Data.Semigroup.$fDataArg10
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Arg a b)
[GblId,
 Arity=2,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCEJ $dData1_sfCEK]
        case Data.Data.$p1Data $dData1_sfCEK of sat_sfCEN {
          __DEFAULT ->
              case Data.Data.$p1Data $dData_sfCEJ of sat_sfCEL {
                __DEFAULT ->
                    case
                        Data.Typeable.Internal.mkTrApp Data.Semigroup.$fDataArg4 sat_sfCEL
                    of
                    sat_sfCEM
                    { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sfCEM sat_sfCEN;
                    };
              };
        };

Data.Semigroup.$fDataArg_$cdataCast2
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Arg a b))
[GblId, Arity=3, Str=<L,U><L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCEO $dData1_sfCEP $dTypeable_sfCEQ]
        let {
          lvl33_sfCER [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCEQ] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCEQ Data.Semigroup.$fDataArg4; } in
        let {
          sat_sfCEV [Occ=OnceT[0]]
            :: (forall d e.
                (Data.Data.Data d, Data.Data.Data e) =>
                c_afxP3 (t_afxP2 d e))
               -> GHC.Base.Maybe (c_afxP3 (Data.Semigroup.Arg a_Xfygm b_Xfygo))
          [LclId] =
              [$dData_sfCEO $dData1_sfCEP lvl33_sfCER] \r [f_sfCES]
                  case lvl33_sfCER of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCEU [Occ=Once]
                            :: c_afxP3 (Data.Semigroup.Arg a_Xfygm b_Xfygo)
                          [LclId] =
                              [$dData_sfCEO $dData1_sfCEP f_sfCES] \u []
                                  f_sfCES $dData_sfCEO $dData1_sfCEP;
                        } in  GHC.Base.Just [sat_sfCEU];
                  };
        } in  sat_sfCEV;

Data.Semigroup.$fDataArg1
  :: forall b a. (a -> b -> Data.Semigroup.Arg a b, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.Arg GHC.Types.False];

Data.Semigroup.$fDataArg_$cgmapMp
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Arg a b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCEW
           $dData1_sfCEX
           $dMonadPlus_sfCEY
           ds_sfCEZ
           eta_sfCF0]
        let {
          lvl33_sfCF1 [Occ=OnceL]
            :: m_afxQP (Data.Semigroup.Arg a_Xfygv b_Xfygx)
          [LclId] =
              [$dMonadPlus_sfCEY] \u [] GHC.Base.mzero $dMonadPlus_sfCEY;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCEY
          of
          $dMonad_sfCF2 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCFw [Occ=Once]
                    :: (Data.Semigroup.Arg a_Xfygv b_Xfygx, GHC.Types.Bool)
                       -> m_afxQP (Data.Semigroup.Arg a_Xfygv b_Xfygx)
                  [LclId] =
                      [lvl33_sfCF1 $dMonad_sfCF2] \r [ds1_sfCFr]
                          case ds1_sfCFr of {
                            (,) x'_sfCFt [Occ=Once] b1_sfCFu [Occ=Once!] ->
                                case b1_sfCFu of {
                                  GHC.Types.False -> lvl33_sfCF1;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCF2 x'_sfCFt;
                                };
                          }; } in
                let {
                  sat_sfCFq [Occ=Once]
                    :: m_afxQP (Data.Semigroup.Arg a_Xfygv b_Xfygx, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCEW
                       $dData1_sfCEX
                       $dMonadPlus_sfCEY
                       ds_sfCEZ
                       eta_sfCF0
                       $dMonad_sfCF2] \u []
                          case eta_sfCF0 of {
                            Data.Semigroup.Arg a1_sfCF4 [Occ=Once] a2_sfCF5 [Occ=Once] ->
                                let {
                                  k_sfCF6 [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b1.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_afxQP (d -> b1)
                                       -> d -> m_afxQP (b1, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sfCEY
                                                ds_sfCEZ
                                                $dMonad_sfCF2] \r [$dData2_sfCF7 ds1_sfCF8 y_sfCF9]
                                          let {
                                            lvl34_sfCFa [Occ=OnceL] :: m_afxQP d_ae2Ws
                                            [LclId] =
                                                [ds_sfCEZ $dData2_sfCF7 y_sfCF9] \u []
                                                    ds_sfCEZ $dData2_sfCF7 y_sfCF9; } in
                                          let {
                                            sat_sfCFn [Occ=Once]
                                              :: (d_ae2Ws -> b1_ae2Wt, GHC.Types.Bool)
                                                 -> m_afxQP (b1_ae2Wt, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sfCEY
                                                 $dMonad_sfCF2
                                                 y_sfCF9
                                                 lvl34_sfCFa] \r [ds2_sfCFb]
                                                    case ds2_sfCFb of {
                                                      (,) h_sfCFd b2_sfCFe [Occ=Once] ->
                                                          let {
                                                            sat_sfCFm [Occ=Once]
                                                              :: m_afxQP (b1_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCF2
                                                                 y_sfCF9
                                                                 h_sfCFd
                                                                 b2_sfCFe] \u []
                                                                    let {
                                                                      sat_sfCFk [Occ=Once]
                                                                        :: b1_ae2Wt
                                                                      [LclId] =
                                                                          [y_sfCF9 h_sfCFd] \u []
                                                                              h_sfCFd y_sfCF9; } in
                                                                    let {
                                                                      sat_sfCFl [Occ=Once]
                                                                        :: (b1_ae2Wt,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCFk
                                                                                     b2_sfCFe];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCF2
                                                                          sat_sfCFl; } in
                                                          let {
                                                            sat_sfCFj [Occ=Once]
                                                              :: m_afxQP (b1_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCF2
                                                                 lvl34_sfCFa
                                                                 h_sfCFd] \u []
                                                                    let {
                                                                      sat_sfCFi [Occ=Once]
                                                                        :: d_ae2Ws
                                                                           -> m_afxQP (b1_ae2Wt,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sfCF2
                                                                           h_sfCFd] \r [y'_sfCFf]
                                                                              let {
                                                                                sat_sfCFg [Occ=Once]
                                                                                  :: b1_ae2Wt
                                                                                [LclId] =
                                                                                    [h_sfCFd
                                                                                     y'_sfCFf] \u []
                                                                                        h_sfCFd
                                                                                            y'_sfCFf; } in
                                                                              let {
                                                                                sat_sfCFh [Occ=Once]
                                                                                  :: (b1_ae2Wt,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sfCFg
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sfCF2
                                                                                    sat_sfCFh;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sfCF2
                                                                          lvl34_sfCFa
                                                                          sat_sfCFi;
                                                          } in 
                                                            GHC.Base.mplus
                                                                $dMonadPlus_sfCEY
                                                                sat_sfCFj
                                                                sat_sfCFm;
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sfCF2 ds1_sfCF8 sat_sfCFn; } in
                                let {
                                  sat_sfCFp [Occ=Once]
                                    :: Data.Data.Mp
                                         m_afxQP (b_Xfygx -> Data.Semigroup.Arg a_Xfygv b_Xfygx)
                                  [LclId] =
                                      [$dData_sfCEW $dMonad_sfCF2 a1_sfCF4 k_sfCF6] \u []
                                          let {
                                            sat_sfCFo [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_afxQP
                                                   (a_Xfygv
                                                    -> b_Xfygx
                                                    -> Data.Semigroup.Arg a_Xfygv b_Xfygx)
                                            [LclId] =
                                                [$dMonad_sfCF2] \u []
                                                    GHC.Base.return
                                                        $dMonad_sfCF2 Data.Semigroup.$fDataArg1;
                                          } in  k_sfCF6 $dData_sfCEW sat_sfCFo a1_sfCF4;
                                } in  k_sfCF6 $dData1_sfCEX sat_sfCFp a2_sfCF5;
                          };
                } in  GHC.Base.>>= $dMonad_sfCF2 sat_sfCFq sat_sfCFw;
          };

Data.Semigroup.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> a -> b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCFx w1_sfCFy w2_sfCFz w3_sfCFA ww_sfCFB ww1_sfCFC]
        let {
          k_sfCFD [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
            :: forall d b1.
               Data.Data.Data d =>
               m_sfBu8 (d -> b1) -> d -> m_sfBu8 b1
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w2_sfCFz w3_sfCFA] \r [$dData1_sfCFE c_sfCFF x_sfCFG]
                  let {
                    lvl33_sfCFH [Occ=OnceL] :: m_sfBu8 d_ae2Vh
                    [LclId] =
                        [w3_sfCFA $dData1_sfCFE x_sfCFG] \u []
                            w3_sfCFA $dData1_sfCFE x_sfCFG; } in
                  let {
                    sat_sfCFM [Occ=Once] :: (d_ae2Vh -> b1_ae2Vi) -> m_sfBu8 b1_ae2Vi
                    [LclId] =
                        [w2_sfCFz lvl33_sfCFH] \r [c'_sfCFI]
                            let {
                              sat_sfCFL [Occ=Once] :: d_ae2Vh -> m_sfBu8 b1_ae2Vi
                              [LclId] =
                                  [w2_sfCFz c'_sfCFI] \r [x'_sfCFJ]
                                      let {
                                        sat_sfCFK [Occ=Once] :: b1_ae2Vi
                                        [LclId] =
                                            [c'_sfCFI x'_sfCFJ] \u [] c'_sfCFI x'_sfCFJ;
                                      } in  GHC.Base.return w2_sfCFz sat_sfCFK;
                            } in  GHC.Base.>>= w2_sfCFz lvl33_sfCFH sat_sfCFL;
                  } in  GHC.Base.>>= w2_sfCFz c_sfCFF sat_sfCFM; } in
        let {
          sat_sfCFO [Occ=Once]
            :: m_sfBu8 (b_sfBu5 -> Data.Semigroup.Arg a_sfBu4 b_sfBu5)
          [LclId] =
              [w_sfCFx w2_sfCFz ww_sfCFB k_sfCFD] \u []
                  let {
                    sat_sfCFN [Occ=Once]
                      :: m_sfBu8 (a_sfBu4
                                  -> b_sfBu5 -> Data.Semigroup.Arg a_sfBu4 b_sfBu5)
                    [LclId] =
                        [w2_sfCFz] \u [] GHC.Base.return w2_sfCFz Data.Semigroup.Arg;
                  } in  k_sfCFD w_sfCFx sat_sfCFN ww_sfCFB;
        } in  k_sfCFD w1_sfCFy sat_sfCFO ww1_sfCFC;

Data.Semigroup.$fDataArg_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Arg a b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sfCFP w1_sfCFQ w2_sfCFR w3_sfCFS w4_sfCFT]
        case w4_sfCFT of {
          Data.Semigroup.Arg ww1_sfCFV [Occ=Once] ww2_sfCFW [Occ=Once] ->
              Data.Semigroup.$w$cgmapM
                  w_sfCFP w1_sfCFQ w2_sfCFR w3_sfCFS ww1_sfCFV ww2_sfCFW;
        };

Data.Semigroup.$fDataArg_$cgmapQi
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Arg a b
     -> u
[GblId,
 Arity=5,
 Str=<L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCFX $dData1_sfCFY ds_sfCFZ ds1_sfCG0 x_sfCG1]
        case x_sfCG1 of {
          Data.Semigroup.Arg a1_sfCG3 [Occ=Once] a2_sfCG4 [Occ=Once] ->
              case ds_sfCFZ of {
                GHC.Types.I# x1_sfCG6 [Occ=Once!] ->
                    case x1_sfCG6 of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sfCG0 $dData_sfCFX a1_sfCG3;
                      1# -> ds1_sfCG0 $dData1_sfCFY a2_sfCG4;
                    };
              };
        };

Data.Semigroup.$fDataArg_$cgmapQr
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Arg a b
     -> r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCG8
           $dData1_sfCG9
           ds_sfCGa
           ds1_sfCGb
           ds2_sfCGc
           x0_sfCGd]
        case x0_sfCGd of {
          Data.Semigroup.Arg a1_sfCGf [Occ=Once] a2_sfCGg [Occ=Once] ->
              let {
                sat_sfCGj [Occ=Once] :: r_afxPQ
                [LclId] =
                    [$dData1_sfCG9 ds_sfCGa ds1_sfCGb ds2_sfCGc a2_sfCGg] \u []
                        let {
                          sat_sfCGi [Occ=Once] :: r'_afxPR
                          [LclId] =
                              [$dData1_sfCG9 ds2_sfCGc a2_sfCGg] \u []
                                  ds2_sfCGc $dData1_sfCG9 a2_sfCGg;
                        } in  ds_sfCGa sat_sfCGi ds1_sfCGb; } in
              let {
                sat_sfCGh [Occ=Once] :: r'_afxPR
                [LclId] =
                    [$dData_sfCG8 ds2_sfCGc a1_sfCGf] \u []
                        ds2_sfCGc $dData_sfCG8 a1_sfCGf;
              } in  ds_sfCGa sat_sfCGh sat_sfCGj;
        };

Data.Semigroup.$fDataArg_$cgmapQ
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Arg a b -> [u]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,C(C1(U))><S,1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [$dData_sfCGk $dData1_sfCGl ds_sfCGm x0_sfCGn]
        case x0_sfCGn of {
          Data.Semigroup.Arg a1_sfCGp [Occ=Once] a2_sfCGq [Occ=Once] ->
              let {
                sat_sfCGs [Occ=Once] :: u_afxQ7
                [LclId] =
                    [$dData1_sfCGl ds_sfCGm a2_sfCGq] \u []
                        ds_sfCGm $dData1_sfCGl a2_sfCGq; } in
              let {
                sat_sfCGt [Occ=Once] :: [u_afxQ7]
                [LclId] =
                    CCCS :! [sat_sfCGs GHC.Types.[]]; } in
              let {
                sat_sfCGr [Occ=Once] :: u_afxQ7
                [LclId] =
                    [$dData_sfCGk ds_sfCGm a1_sfCGp] \u []
                        ds_sfCGm $dData_sfCGk a1_sfCGp;
              } in  : [sat_sfCGr sat_sfCGt];
        };

Data.Semigroup.$fDataArg2
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Arg a b
     -> Data.Functor.Const.Const r (Data.Semigroup.Arg a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCGu
           $dData1_sfCGv
           ds_sfCGw
           ds1_sfCGx
           ds2_sfCGy
           eta_sfCGz]
        case eta_sfCGz of {
          Data.Semigroup.Arg a1_sfCGB [Occ=Once] a2_sfCGC [Occ=Once] ->
              let {
                sat_sfCGF [Occ=Once] :: r'_afxPA
                [LclId] =
                    [$dData1_sfCGv ds2_sfCGy a2_sfCGC] \u []
                        ds2_sfCGy $dData1_sfCGv a2_sfCGC; } in
              let {
                sat_sfCGE [Occ=Once] :: r_afxPz
                [LclId] =
                    [$dData_sfCGu ds_sfCGw ds1_sfCGx ds2_sfCGy a1_sfCGB] \u []
                        let {
                          sat_sfCGD [Occ=Once] :: r'_afxPA
                          [LclId] =
                              [$dData_sfCGu ds2_sfCGy a1_sfCGB] \u []
                                  ds2_sfCGy $dData_sfCGu a1_sfCGB;
                        } in  ds_sfCGw ds1_sfCGx sat_sfCGD;
              } in  ds_sfCGw sat_sfCGE sat_sfCGF;
        };

Data.Semigroup.$fDataArg3
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     (forall b1. Data.Data.Data b1 => b1 -> b1)
     -> Data.Semigroup.Arg a b
     -> Data.Functor.Identity.Identity (Data.Semigroup.Arg a b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,C(C1(U))><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dData_sfCGG $dData1_sfCGH ds_sfCGI x0_sfCGJ]
        case x0_sfCGJ of {
          Data.Semigroup.Arg a1_sfCGL [Occ=Once] a2_sfCGM [Occ=Once] ->
              let {
                sat_sfCGO [Occ=Once] :: b_Xfygr
                [LclId] =
                    [$dData1_sfCGH ds_sfCGI a2_sfCGM] \u []
                        ds_sfCGI $dData1_sfCGH a2_sfCGM; } in
              let {
                sat_sfCGN [Occ=Once] :: a_Xfygp
                [LclId] =
                    [$dData_sfCGG ds_sfCGI a1_sfCGL] \u []
                        ds_sfCGI $dData_sfCGG a1_sfCGL;
              } in  Data.Semigroup.Arg [sat_sfCGN sat_sfCGO];
        };

Data.Semigroup.$fDataArg_$cgmapMo
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Arg a b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCGP
           $dData1_sfCGQ
           $dMonadPlus_sfCGR
           ds_sfCGS
           eta_sfCGT]
        let {
          lvl33_sfCGU [Occ=OnceL]
            :: m_afxR5 (Data.Semigroup.Arg a_Xfygo b_XfyDI)
          [LclId] =
              [$dMonadPlus_sfCGR] \u [] GHC.Base.mzero $dMonadPlus_sfCGR;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCGR
          of
          $dMonad_sfCGV [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCHs [Occ=Once]
                    :: (Data.Semigroup.Arg a_Xfygo b_XfyDI, GHC.Types.Bool)
                       -> m_afxR5 (Data.Semigroup.Arg a_Xfygo b_XfyDI)
                  [LclId] =
                      [lvl33_sfCGU $dMonad_sfCGV] \r [ds1_sfCHn]
                          case ds1_sfCHn of {
                            (,) x'_sfCHp [Occ=Once] b1_sfCHq [Occ=Once!] ->
                                case b1_sfCHq of {
                                  GHC.Types.False -> lvl33_sfCGU;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCGV x'_sfCHp;
                                };
                          }; } in
                let {
                  sat_sfCHm [Occ=Once]
                    :: m_afxR5 (Data.Semigroup.Arg a_Xfygo b_XfyDI, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCGP
                       $dData1_sfCGQ
                       $dMonadPlus_sfCGR
                       ds_sfCGS
                       eta_sfCGT
                       $dMonad_sfCGV] \u []
                          case eta_sfCGT of {
                            Data.Semigroup.Arg a1_sfCGX [Occ=Once] a2_sfCGY [Occ=Once] ->
                                let {
                                  k_sfCGZ [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b1.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_afxR5 (d -> b1)
                                       -> d -> m_afxR5 (b1, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sfCGR
                                                ds_sfCGS
                                                $dMonad_sfCGV] \r [$dData2_sfCH0 ds1_sfCH1 y_sfCH2]
                                          let {
                                            lvl34_sfCH3 [Occ=OnceL] :: m_afxR5 d_ae2Ya
                                            [LclId] =
                                                [ds_sfCGS $dData2_sfCH0 y_sfCH2] \u []
                                                    ds_sfCGS $dData2_sfCH0 y_sfCH2; } in
                                          let {
                                            sat_sfCHj [Occ=Once]
                                              :: (d_ae2Ya -> b1_ae2Yb, GHC.Types.Bool)
                                                 -> m_afxR5 (b1_ae2Yb, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sfCGR
                                                 $dMonad_sfCGV
                                                 y_sfCH2
                                                 lvl34_sfCH3] \r [ds2_sfCH4]
                                                    case ds2_sfCH4 of {
                                                      (,) h_sfCH6 b2_sfCH7 [Occ=Once!] ->
                                                          case b2_sfCH7 of {
                                                            GHC.Types.False ->
                                                                let {
                                                                  sat_sfCHg [Occ=Once]
                                                                    :: m_afxR5 (b1_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sfCGV
                                                                       y_sfCH2
                                                                       h_sfCH6] \u []
                                                                          let {
                                                                            sat_sfCHe [Occ=Once]
                                                                              :: b1_ae2Yb
                                                                            [LclId] =
                                                                                [y_sfCH2
                                                                                 h_sfCH6] \u []
                                                                                    h_sfCH6
                                                                                        y_sfCH2; } in
                                                                          let {
                                                                            sat_sfCHf [Occ=Once]
                                                                              :: (b1_ae2Yb,
                                                                                  GHC.Types.Bool)
                                                                            [LclId] =
                                                                                CCCS (,)! [sat_sfCHe
                                                                                           GHC.Types.False];
                                                                          } in 
                                                                            GHC.Base.return
                                                                                $dMonad_sfCGV
                                                                                sat_sfCHf; } in
                                                                let {
                                                                  sat_sfCHd [Occ=Once]
                                                                    :: m_afxR5 (b1_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sfCGV
                                                                       lvl34_sfCH3
                                                                       h_sfCH6] \u []
                                                                          let {
                                                                            sat_sfCHc [Occ=Once]
                                                                              :: d_ae2Ya
                                                                                 -> m_afxR5 (b1_ae2Yb,
                                                                                             GHC.Types.Bool)
                                                                            [LclId] =
                                                                                [$dMonad_sfCGV
                                                                                 h_sfCH6] \r [y'_sfCH9]
                                                                                    let {
                                                                                      sat_sfCHa [Occ=Once]
                                                                                        :: b1_ae2Yb
                                                                                      [LclId] =
                                                                                          [h_sfCH6
                                                                                           y'_sfCH9] \u []
                                                                                              h_sfCH6
                                                                                                  y'_sfCH9; } in
                                                                                    let {
                                                                                      sat_sfCHb [Occ=Once]
                                                                                        :: (b1_ae2Yb,
                                                                                            GHC.Types.Bool)
                                                                                      [LclId] =
                                                                                          CCCS (,)! [sat_sfCHa
                                                                                                     GHC.Types.True];
                                                                                    } in 
                                                                                      GHC.Base.return
                                                                                          $dMonad_sfCGV
                                                                                          sat_sfCHb;
                                                                          } in 
                                                                            GHC.Base.>>=
                                                                                $dMonad_sfCGV
                                                                                lvl34_sfCH3
                                                                                sat_sfCHc;
                                                                } in 
                                                                  GHC.Base.mplus
                                                                      $dMonadPlus_sfCGR
                                                                      sat_sfCHd
                                                                      sat_sfCHg;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_sfCHh [Occ=Once] :: b1_ae2Yb
                                                                  [LclId] =
                                                                      [y_sfCH2 h_sfCH6] \u []
                                                                          h_sfCH6 y_sfCH2; } in
                                                                let {
                                                                  sat_sfCHi [Occ=Once]
                                                                    :: (b1_ae2Yb, GHC.Types.Bool)
                                                                  [LclId] =
                                                                      CCCS (,)! [sat_sfCHh
                                                                                 GHC.Types.True];
                                                                } in 
                                                                  GHC.Base.return
                                                                      $dMonad_sfCGV sat_sfCHi;
                                                          };
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sfCGV ds1_sfCH1 sat_sfCHj; } in
                                let {
                                  sat_sfCHl [Occ=Once]
                                    :: Data.Data.Mp
                                         m_afxR5 (b_XfyDI -> Data.Semigroup.Arg a_Xfygo b_XfyDI)
                                  [LclId] =
                                      [$dData_sfCGP $dMonad_sfCGV a1_sfCGX k_sfCGZ] \u []
                                          let {
                                            sat_sfCHk [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_afxR5
                                                   (a_Xfygo
                                                    -> b_XfyDI
                                                    -> Data.Semigroup.Arg a_Xfygo b_XfyDI)
                                            [LclId] =
                                                [$dMonad_sfCGV] \u []
                                                    GHC.Base.return
                                                        $dMonad_sfCGV Data.Semigroup.$fDataArg1;
                                          } in  k_sfCGZ $dData_sfCGP sat_sfCHk a1_sfCGX;
                                } in  k_sfCGZ $dData1_sfCGQ sat_sfCHl a2_sfCGY;
                          };
                } in  GHC.Base.>>= $dMonad_sfCGV sat_sfCHm sat_sfCHs;
          };

lvl18_rfC6Z
  :: forall b a. Data.Semigroup.Arg a b -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_sfCHt]
        case ds_sfCHt of {
          Data.Semigroup.Arg _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Semigroup.$cArg;
        };

lvl19_rfC70
  :: forall a b. Data.Semigroup.Arg a b -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCHx] Data.Semigroup.$tArg;

lvl20_rfC71
  :: forall a b (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Arg a b))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCHy ds_sfCHz] GHC.Base.Nothing [];

Data.Semigroup.$fDataArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     Data.Data.Data (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCHA $dData1_sfCHB]
        let {
          sat_sfCHN [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> m (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapMo
                      $dData_sfCHA $dData1_sfCHB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHM [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> m (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapMp
                      $dData_sfCHA $dData1_sfCHB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHL [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> m (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapM
                      $dData_sfCHA $dData1_sfCHB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHK [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> u
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapQi
                      $dData_sfCHA $dData1_sfCHB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHJ [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI -> [u]
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapQ
                      $dData_sfCHA $dData1_sfCHB eta_B2 eta_B1; } in
        let {
          sat_sfCHI [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> r
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapQr
                      $dData_sfCHA $dData1_sfCHB eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHH [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> r
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg2
                      $dData_sfCHA $dData1_sfCHB eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHG [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg3
                      $dData_sfCHA $dData1_sfCHB eta_B2 eta_B1; } in
        let {
          sat_sfCHF [Occ=Once]
            :: forall (t :: * -> * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
               -> GHC.Base.Maybe (c (Data.Semigroup.Arg a_Xfygn b_XfyDI))
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B1]
                  Data.Semigroup.$fDataArg_$cdataCast2
                      $dData_sfCHA $dData1_sfCHB eta_B1; } in
        let {
          sat_sfCHE [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgunfold
                      $dData_sfCHA $dData1_sfCHB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHD [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> c (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgfoldl
                      $dData_sfCHA $dData1_sfCHB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHC [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \u []
                  Data.Semigroup.$fDataArg10 $dData_sfCHA $dData1_sfCHB;
        } in 
          Data.Data.C:Data [sat_sfCHC
                            sat_sfCHD
                            sat_sfCHE
                            lvl18_rfC6Z
                            lvl19_rfC70
                            lvl20_rfC71
                            sat_sfCHF
                            sat_sfCHG
                            sat_sfCHH
                            sat_sfCHI
                            sat_sfCHJ
                            sat_sfCHK
                            sat_sfCHL
                            sat_sfCHM
                            sat_sfCHN];

Data.Semigroup.$fDataFirst3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataFirst4];

Data.Semigroup.$tcFirst :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5289672677956055491##
                                    1507157566582617174##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataFirst3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep10_rfC72 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcFirst
                                              $krep2_rfC6L];

Data.Semigroup.$tc'First1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep10_rfC72];

Data.Semigroup.$tc'First3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'First"#;

Data.Semigroup.$tc'First2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'First3];

Data.Semigroup.$tc'First :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14746522314279732838##
                                    14022550265149674723##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'First2
                                    1#
                                    Data.Semigroup.$tc'First1];

Data.Semigroup.$fDataFirst2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.First
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                5289672677956055491##
                1507157566582617174##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataFirst3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCHP [Occ=Once]
                   ww9_sfCHQ [Occ=Once]
                   ww10_sfCHR [Occ=Once]
                   ww11_sfCHS [Occ=Once]
                   ww12_sfCHT [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCHP
                                              ww9_sfCHQ
                                              ww10_sfCHR
                                              ww11_sfCHS
                                              ww12_sfCHT];
        };

Data.Semigroup.$fDataFirst8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.First a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCHU]
        case Data.Data.$p1Data $dData_sfCHU of sat_sfCHV {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataFirst2 sat_sfCHV;
        };

Data.Semigroup.$fDataFirst_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.First a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCHW $dTypeable_sfCHX]
        let {
          lvl33_sfCHY [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCHX] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCHX Data.Semigroup.$fDataFirst2; } in
        let {
          sat_sfCI2 [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afxYL (t_afxYK d))
               -> GHC.Base.Maybe (c_afxYL (Data.Semigroup.First a_XfyqV))
          [LclId] =
              [$dData_sfCHW lvl33_sfCHY] \r [f_sfCHZ]
                  case lvl33_sfCHY of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCI1 [Occ=Once] :: c_afxYL (Data.Semigroup.First a_XfyqV)
                          [LclId] =
                              [$dData_sfCHW f_sfCHZ] \u [] f_sfCHZ $dData_sfCHW;
                        } in  GHC.Base.Just [sat_sfCI1];
                  };
        } in  sat_sfCI2;

Data.Semigroup.$fDataFirst1
  :: forall a. (a -> Data.Semigroup.First a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataFirst_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.First a -> m (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCI3 $dMonadPlus_sfCI4 ds_sfCI5 eta_sfCI6]
        let {
          lvl33_sfCI7 [Occ=OnceL] :: m_afy0Q (Data.Semigroup.First a_Xfyr4)
          [LclId] =
              [$dMonadPlus_sfCI4] \u [] GHC.Base.mzero $dMonadPlus_sfCI4;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCI4
          of
          $dMonad_sfCI8 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCIu [Occ=Once]
                    :: (Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                       -> m_afy0Q (Data.Semigroup.First a_Xfyr4)
                  [LclId] =
                      [lvl33_sfCI7 $dMonad_sfCI8] \r [ds1_sfCIp]
                          case ds1_sfCIp of {
                            (,) x'_sfCIr [Occ=Once] b_sfCIs [Occ=Once!] ->
                                case b_sfCIs of {
                                  GHC.Types.False -> lvl33_sfCI7;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCI8 x'_sfCIr;
                                };
                          }; } in
                let {
                  sat_sfCIo [Occ=Once]
                    :: m_afy0Q (Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCI3
                       $dMonadPlus_sfCI4
                       ds_sfCI5
                       eta_sfCI6
                       $dMonad_sfCI8] \u []
                          let {
                            lvl34_sfCI9 [Occ=OnceL] :: m_afy0Q a_Xfyr4
                            [LclId] =
                                [$dData_sfCI3 ds_sfCI5 eta_sfCI6] \u []
                                    ds_sfCI5 $dData_sfCI3 eta_sfCI6; } in
                          let {
                            sat_sfCIn [Occ=Once]
                              :: (a_Xfyr4 -> Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                                 -> m_afy0Q (Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCI4
                                 eta_sfCI6
                                 $dMonad_sfCI8
                                 lvl34_sfCI9] \r [ds1_sfCIb]
                                    case ds1_sfCIb of {
                                      (,) h_sfCId b1_sfCIe [Occ=Once] ->
                                          let {
                                            sat_sfCIm [Occ=Once]
                                              :: m_afy0Q (Data.Semigroup.First a_Xfyr4,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfCI6 $dMonad_sfCI8 h_sfCId b1_sfCIe] \u []
                                                    let {
                                                      sat_sfCIk [Occ=Once]
                                                        :: Data.Semigroup.First a_Xfyr4
                                                      [LclId] =
                                                          [eta_sfCI6 h_sfCId] \u []
                                                              h_sfCId eta_sfCI6; } in
                                                    let {
                                                      sat_sfCIl [Occ=Once]
                                                        :: (Data.Semigroup.First a_Xfyr4,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfCIk b1_sfCIe];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfCI8 sat_sfCIl; } in
                                          let {
                                            sat_sfCIj [Occ=Once]
                                              :: m_afy0Q (Data.Semigroup.First a_Xfyr4,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfCI8 lvl34_sfCI9 h_sfCId] \u []
                                                    let {
                                                      sat_sfCIi [Occ=Once]
                                                        :: a_Xfyr4
                                                           -> m_afy0Q (Data.Semigroup.First a_Xfyr4,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfCI8 h_sfCId] \r [y'_sfCIf]
                                                              let {
                                                                sat_sfCIg [Occ=Once]
                                                                  :: Data.Semigroup.First a_Xfyr4
                                                                [LclId] =
                                                                    [h_sfCId y'_sfCIf] \u []
                                                                        h_sfCId y'_sfCIf; } in
                                                              let {
                                                                sat_sfCIh [Occ=Once]
                                                                  :: (Data.Semigroup.First a_Xfyr4,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfCIg
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfCI8 sat_sfCIh;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfCI8 lvl34_sfCI9 sat_sfCIi;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfCI4 sat_sfCIj sat_sfCIm;
                                    }; } in
                          let {
                            sat_sfCIa [Occ=Once]
                              :: m_afy0Q (a_Xfyr4 -> Data.Semigroup.First a_Xfyr4,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCI8] \u []
                                    GHC.Base.return $dMonad_sfCI8 Data.Semigroup.$fDataFirst1;
                          } in  GHC.Base.>>= $dMonad_sfCI8 sat_sfCIa sat_sfCIn;
                } in  GHC.Base.>>= $dMonad_sfCI8 sat_sfCIo sat_sfCIu;
          };

Data.Semigroup.$fDataFirst_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.First a -> m (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCIv $dMonad_sfCIw ds_sfCIx eta_sfCIy]
        let {
          lvl33_sfCIz [Occ=OnceL] :: m_afy0A a_Xfyr3
          [LclId] =
              [$dData_sfCIv ds_sfCIx eta_sfCIy] \u []
                  ds_sfCIx $dData_sfCIv eta_sfCIy; } in
        let {
          sat_sfCIF [Occ=Once]
            :: (a_Xfyr3 -> Data.Semigroup.First a_Xfyr3)
               -> m_afy0A (Data.Semigroup.First a_Xfyr3)
          [LclId] =
              [$dMonad_sfCIw lvl33_sfCIz] \r [c'_sfCIB]
                  let {
                    sat_sfCIE [Occ=Once]
                      :: a_Xfyr3 -> m_afy0A (Data.Semigroup.First a_Xfyr3)
                    [LclId] =
                        [$dMonad_sfCIw c'_sfCIB] \r [x'_sfCIC]
                            let {
                              sat_sfCID [Occ=Once] :: Data.Semigroup.First a_Xfyr3
                              [LclId] =
                                  [c'_sfCIB x'_sfCIC] \u [] c'_sfCIB x'_sfCIC;
                            } in  GHC.Base.return $dMonad_sfCIw sat_sfCID;
                  } in  GHC.Base.>>= $dMonad_sfCIw lvl33_sfCIz sat_sfCIE; } in
        let {
          sat_sfCIA [Occ=Once]
            :: m_afy0A (a_Xfyr3 -> Data.Semigroup.First a_Xfyr3)
          [LclId] =
              [$dMonad_sfCIw] \u []
                  GHC.Base.return $dMonad_sfCIw Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfCIw sat_sfCIA sat_sfCIF;

Data.Semigroup.$fDataFirst_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.First a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCIG ds_sfCIH ds1_sfCII x_sfCIJ]
        case ds_sfCIH of {
          GHC.Types.I# x1_sfCIL [Occ=Once!] ->
              case x1_sfCIL of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfCII $dData_sfCIG x_sfCIJ;
              };
        };

Data.Semigroup.$fDataFirst_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.First a -> m (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCIN $dMonadPlus_sfCIO ds_sfCIP eta_sfCIQ]
        let {
          lvl33_sfCIR [Occ=OnceL] :: m_afy16 (Data.Semigroup.First a_XfyqX)
          [LclId] =
              [$dMonadPlus_sfCIO] \u [] GHC.Base.mzero $dMonadPlus_sfCIO;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCIO
          of
          $dMonad_sfCIS [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCJh [Occ=Once]
                    :: (Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                       -> m_afy16 (Data.Semigroup.First a_XfyqX)
                  [LclId] =
                      [lvl33_sfCIR $dMonad_sfCIS] \r [ds1_sfCJc]
                          case ds1_sfCJc of {
                            (,) x'_sfCJe [Occ=Once] b_sfCJf [Occ=Once!] ->
                                case b_sfCJf of {
                                  GHC.Types.False -> lvl33_sfCIR;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCIS x'_sfCJe;
                                };
                          }; } in
                let {
                  sat_sfCJb [Occ=Once]
                    :: m_afy16 (Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCIN
                       $dMonadPlus_sfCIO
                       ds_sfCIP
                       eta_sfCIQ
                       $dMonad_sfCIS] \u []
                          let {
                            lvl34_sfCIT [Occ=OnceL] :: m_afy16 a_XfyqX
                            [LclId] =
                                [$dData_sfCIN ds_sfCIP eta_sfCIQ] \u []
                                    ds_sfCIP $dData_sfCIN eta_sfCIQ; } in
                          let {
                            sat_sfCJa [Occ=Once]
                              :: (a_XfyqX -> Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                                 -> m_afy16 (Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCIO
                                 eta_sfCIQ
                                 $dMonad_sfCIS
                                 lvl34_sfCIT] \r [ds1_sfCIV]
                                    case ds1_sfCIV of {
                                      (,) h_sfCIX b1_sfCIY [Occ=Once!] ->
                                          case b1_sfCIY of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfCJ7 [Occ=Once]
                                                    :: m_afy16 (Data.Semigroup.First a_XfyqX,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfCIQ $dMonad_sfCIS h_sfCIX] \u []
                                                          let {
                                                            sat_sfCJ5 [Occ=Once]
                                                              :: Data.Semigroup.First a_XfyqX
                                                            [LclId] =
                                                                [eta_sfCIQ h_sfCIX] \u []
                                                                    h_sfCIX eta_sfCIQ; } in
                                                          let {
                                                            sat_sfCJ6 [Occ=Once]
                                                              :: (Data.Semigroup.First a_XfyqX,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfCJ5
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfCIS sat_sfCJ6; } in
                                                let {
                                                  sat_sfCJ4 [Occ=Once]
                                                    :: m_afy16 (Data.Semigroup.First a_XfyqX,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfCIS lvl34_sfCIT h_sfCIX] \u []
                                                          let {
                                                            sat_sfCJ3 [Occ=Once]
                                                              :: a_XfyqX
                                                                 -> m_afy16 (Data.Semigroup.First
                                                                               a_XfyqX,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCIS
                                                                 h_sfCIX] \r [y'_sfCJ0]
                                                                    let {
                                                                      sat_sfCJ1 [Occ=Once]
                                                                        :: Data.Semigroup.First
                                                                             a_XfyqX
                                                                      [LclId] =
                                                                          [h_sfCIX y'_sfCJ0] \u []
                                                                              h_sfCIX y'_sfCJ0; } in
                                                                    let {
                                                                      sat_sfCJ2 [Occ=Once]
                                                                        :: (Data.Semigroup.First
                                                                              a_XfyqX,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCJ1
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCIS sat_sfCJ2;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfCIS lvl34_sfCIT sat_sfCJ3;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfCIO sat_sfCJ4 sat_sfCJ7;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfCJ8 [Occ=Once]
                                                    :: Data.Semigroup.First a_XfyqX
                                                  [LclId] =
                                                      [eta_sfCIQ h_sfCIX] \u []
                                                          h_sfCIX eta_sfCIQ; } in
                                                let {
                                                  sat_sfCJ9 [Occ=Once]
                                                    :: (Data.Semigroup.First a_XfyqX,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfCJ8 GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfCIS sat_sfCJ9;
                                          };
                                    }; } in
                          let {
                            sat_sfCIU [Occ=Once]
                              :: m_afy16 (a_XfyqX -> Data.Semigroup.First a_XfyqX,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCIS] \u []
                                    GHC.Base.return $dMonad_sfCIS Data.Semigroup.$fDataFirst1;
                          } in  GHC.Base.>>= $dMonad_sfCIS sat_sfCIU sat_sfCJa;
                } in  GHC.Base.>>= $dMonad_sfCIS sat_sfCJb sat_sfCJh;
          };

lvl21_rfC73 :: forall a. Data.Semigroup.First a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCJi] Data.Semigroup.$cFirst;

lvl22_rfC74
  :: forall a. Data.Semigroup.First a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCJj] Data.Semigroup.$tFirst;

lvl23_rfC75
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.First a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCJk ds_sfCJl] GHC.Base.Nothing [];

Data.Semigroup.$fDataFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.First a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCJm]
        let {
          sat_sfCJR [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.First a_XfyqW -> m (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfCJm] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapMo
                      $dData_sfCJm eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCJQ [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.First a_XfyqW -> m (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfCJm] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapMp
                      $dData_sfCJm eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCJP [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.First a_XfyqW -> m (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfCJm] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapM
                      $dData_sfCJm eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCJO [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.First a_XfyqW
               -> u
          [LclId] =
              [$dData_sfCJm] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapQi
                      $dData_sfCJm eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCJN [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.First a_XfyqW -> [u]
          [LclId] =
              [$dData_sfCJm] \r [ds_sfCJK x0_sfCJL]
                  let {
                    sat_sfCJM [Occ=Once] :: u_afy08
                    [LclId] =
                        [$dData_sfCJm ds_sfCJK x0_sfCJL] \u []
                            ds_sfCJK $dData_sfCJm x0_sfCJL;
                  } in  : [sat_sfCJM GHC.Types.[]]; } in
        let {
          sat_sfCJJ [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.First a_XfyqW
               -> r
          [LclId] =
              [$dData_sfCJm] \r [ds_sfCJE ds1_sfCJF ds2_sfCJG x0_sfCJH]
                  let {
                    sat_sfCJI [Occ=Once] :: r'_afxZS
                    [LclId] =
                        [$dData_sfCJm ds2_sfCJG x0_sfCJH] \u []
                            ds2_sfCJG $dData_sfCJm x0_sfCJH;
                  } in  ds_sfCJE sat_sfCJI ds1_sfCJF; } in
        let {
          sat_sfCJD [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.First a_XfyqW
               -> r
          [LclId] =
              [$dData_sfCJm] \r [ds_sfCJy ds1_sfCJz ds2_sfCJA eta_sfCJB]
                  let {
                    sat_sfCJC [Occ=Once] :: r'_afxZB
                    [LclId] =
                        [$dData_sfCJm ds2_sfCJA eta_sfCJB] \u []
                            ds2_sfCJA $dData_sfCJm eta_sfCJB;
                  } in  ds_sfCJy ds1_sfCJz sat_sfCJC; } in
        let {
          sat_sfCJx [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.First a_XfyqW -> Data.Semigroup.First a_XfyqW
          [LclId] =
              [$dData_sfCJm] \r [ds_sfCJv x0_sfCJw]
                  ds_sfCJv $dData_sfCJm x0_sfCJw; } in
        let {
          sat_sfCJu [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.First a_XfyqW))
          [LclId] =
              [$dData_sfCJm] \r [eta_B1]
                  Data.Semigroup.$fDataFirst_$cdataCast1 $dData_sfCJm eta_B1; } in
        let {
          sat_sfCJt [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfCJm] \r [k_sfCJp z_sfCJq ds_sfCJr]
                  let {
                    sat_sfCJs [Occ=Once]
                      :: c_afxYr (a_XfyqW -> Data.Semigroup.First a_XfyqW)
                    [LclId] =
                        [z_sfCJq] \u [] z_sfCJq Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfCJp $dData_sfCJm sat_sfCJs; } in
        let {
          sat_sfCJo [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.First a_XfyqW
               -> c (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfCJm] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgfoldl
                      $dData_sfCJm eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCJn [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfCJm] \u [] Data.Semigroup.$fDataFirst8 $dData_sfCJm;
        } in 
          Data.Data.C:Data [sat_sfCJn
                            sat_sfCJo
                            sat_sfCJt
                            lvl21_rfC73
                            lvl22_rfC74
                            sat_sfCJu
                            lvl23_rfC75
                            sat_sfCJx
                            sat_sfCJD
                            sat_sfCJJ
                            sat_sfCJN
                            sat_sfCJO
                            sat_sfCJP
                            sat_sfCJQ
                            sat_sfCJR];

Data.Semigroup.$fDataLast3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataLast4];

Data.Semigroup.$tcLast :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11434676963974803827##
                                    15911814017027463598##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataLast3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep11_rfC76 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcLast
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Last1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep11_rfC76];

Data.Semigroup.$tc'Last3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Last"#;

Data.Semigroup.$tc'Last2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Last3];

Data.Semigroup.$tc'Last :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3320600960953447003##
                                    12383530634546204472##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Last2
                                    1#
                                    Data.Semigroup.$tc'Last1];

Data.Semigroup.$fDataLast2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Last
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                11434676963974803827##
                15911814017027463598##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataLast3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCJT [Occ=Once]
                   ww9_sfCJU [Occ=Once]
                   ww10_sfCJV [Occ=Once]
                   ww11_sfCJW [Occ=Once]
                   ww12_sfCJX [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCJT
                                              ww9_sfCJU
                                              ww10_sfCJV
                                              ww11_sfCJW
                                              ww12_sfCJX];
        };

Data.Semigroup.$fDataLast8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Last a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCJY]
        case Data.Data.$p1Data $dData_sfCJY of sat_sfCJZ {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataLast2 sat_sfCJZ;
        };

Data.Semigroup.$fDataLast_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Last a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCK0 $dTypeable_sfCK1]
        let {
          lvl33_sfCK2 [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCK1] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCK1 Data.Semigroup.$fDataLast2; } in
        let {
          sat_sfCK6 [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afy7N (t_afy7M d))
               -> GHC.Base.Maybe (c_afy7N (Data.Semigroup.Last a_XfyAl))
          [LclId] =
              [$dData_sfCK0 lvl33_sfCK2] \r [f_sfCK3]
                  case lvl33_sfCK2 of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCK5 [Occ=Once] :: c_afy7N (Data.Semigroup.Last a_XfyAl)
                          [LclId] =
                              [$dData_sfCK0 f_sfCK3] \u [] f_sfCK3 $dData_sfCK0;
                        } in  GHC.Base.Just [sat_sfCK5];
                  };
        } in  sat_sfCK6;

Data.Semigroup.$fDataLast1
  :: forall a. (a -> Data.Semigroup.Last a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataLast_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Last a -> m (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCK7 $dMonadPlus_sfCK8 ds_sfCK9 eta_sfCKa]
        let {
          lvl33_sfCKb [Occ=OnceL] :: m_afy9S (Data.Semigroup.Last a_XfyAu)
          [LclId] =
              [$dMonadPlus_sfCK8] \u [] GHC.Base.mzero $dMonadPlus_sfCK8;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCK8
          of
          $dMonad_sfCKc [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCKy [Occ=Once]
                    :: (Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                       -> m_afy9S (Data.Semigroup.Last a_XfyAu)
                  [LclId] =
                      [lvl33_sfCKb $dMonad_sfCKc] \r [ds1_sfCKt]
                          case ds1_sfCKt of {
                            (,) x'_sfCKv [Occ=Once] b_sfCKw [Occ=Once!] ->
                                case b_sfCKw of {
                                  GHC.Types.False -> lvl33_sfCKb;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCKc x'_sfCKv;
                                };
                          }; } in
                let {
                  sat_sfCKs [Occ=Once]
                    :: m_afy9S (Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCK7
                       $dMonadPlus_sfCK8
                       ds_sfCK9
                       eta_sfCKa
                       $dMonad_sfCKc] \u []
                          let {
                            lvl34_sfCKd [Occ=OnceL] :: m_afy9S a_XfyAu
                            [LclId] =
                                [$dData_sfCK7 ds_sfCK9 eta_sfCKa] \u []
                                    ds_sfCK9 $dData_sfCK7 eta_sfCKa; } in
                          let {
                            sat_sfCKr [Occ=Once]
                              :: (a_XfyAu -> Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                                 -> m_afy9S (Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCK8
                                 eta_sfCKa
                                 $dMonad_sfCKc
                                 lvl34_sfCKd] \r [ds1_sfCKf]
                                    case ds1_sfCKf of {
                                      (,) h_sfCKh b1_sfCKi [Occ=Once] ->
                                          let {
                                            sat_sfCKq [Occ=Once]
                                              :: m_afy9S (Data.Semigroup.Last a_XfyAu,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfCKa $dMonad_sfCKc h_sfCKh b1_sfCKi] \u []
                                                    let {
                                                      sat_sfCKo [Occ=Once]
                                                        :: Data.Semigroup.Last a_XfyAu
                                                      [LclId] =
                                                          [eta_sfCKa h_sfCKh] \u []
                                                              h_sfCKh eta_sfCKa; } in
                                                    let {
                                                      sat_sfCKp [Occ=Once]
                                                        :: (Data.Semigroup.Last a_XfyAu,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfCKo b1_sfCKi];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfCKc sat_sfCKp; } in
                                          let {
                                            sat_sfCKn [Occ=Once]
                                              :: m_afy9S (Data.Semigroup.Last a_XfyAu,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfCKc lvl34_sfCKd h_sfCKh] \u []
                                                    let {
                                                      sat_sfCKm [Occ=Once]
                                                        :: a_XfyAu
                                                           -> m_afy9S (Data.Semigroup.Last a_XfyAu,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfCKc h_sfCKh] \r [y'_sfCKj]
                                                              let {
                                                                sat_sfCKk [Occ=Once]
                                                                  :: Data.Semigroup.Last a_XfyAu
                                                                [LclId] =
                                                                    [h_sfCKh y'_sfCKj] \u []
                                                                        h_sfCKh y'_sfCKj; } in
                                                              let {
                                                                sat_sfCKl [Occ=Once]
                                                                  :: (Data.Semigroup.Last a_XfyAu,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfCKk
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfCKc sat_sfCKl;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfCKc lvl34_sfCKd sat_sfCKm;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfCK8 sat_sfCKn sat_sfCKq;
                                    }; } in
                          let {
                            sat_sfCKe [Occ=Once]
                              :: m_afy9S (a_XfyAu -> Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCKc] \u []
                                    GHC.Base.return $dMonad_sfCKc Data.Semigroup.$fDataLast1;
                          } in  GHC.Base.>>= $dMonad_sfCKc sat_sfCKe sat_sfCKr;
                } in  GHC.Base.>>= $dMonad_sfCKc sat_sfCKs sat_sfCKy;
          };

Data.Semigroup.$fDataLast_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Last a -> m (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCKz $dMonad_sfCKA ds_sfCKB eta_sfCKC]
        let {
          lvl33_sfCKD [Occ=OnceL] :: m_afy9C a_XfyAt
          [LclId] =
              [$dData_sfCKz ds_sfCKB eta_sfCKC] \u []
                  ds_sfCKB $dData_sfCKz eta_sfCKC; } in
        let {
          sat_sfCKJ [Occ=Once]
            :: (a_XfyAt -> Data.Semigroup.Last a_XfyAt)
               -> m_afy9C (Data.Semigroup.Last a_XfyAt)
          [LclId] =
              [$dMonad_sfCKA lvl33_sfCKD] \r [c'_sfCKF]
                  let {
                    sat_sfCKI [Occ=Once]
                      :: a_XfyAt -> m_afy9C (Data.Semigroup.Last a_XfyAt)
                    [LclId] =
                        [$dMonad_sfCKA c'_sfCKF] \r [x'_sfCKG]
                            let {
                              sat_sfCKH [Occ=Once] :: Data.Semigroup.Last a_XfyAt
                              [LclId] =
                                  [c'_sfCKF x'_sfCKG] \u [] c'_sfCKF x'_sfCKG;
                            } in  GHC.Base.return $dMonad_sfCKA sat_sfCKH;
                  } in  GHC.Base.>>= $dMonad_sfCKA lvl33_sfCKD sat_sfCKI; } in
        let {
          sat_sfCKE [Occ=Once]
            :: m_afy9C (a_XfyAt -> Data.Semigroup.Last a_XfyAt)
          [LclId] =
              [$dMonad_sfCKA] \u []
                  GHC.Base.return $dMonad_sfCKA Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfCKA sat_sfCKE sat_sfCKJ;

Data.Semigroup.$fDataLast_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Last a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCKK ds_sfCKL ds1_sfCKM x_sfCKN]
        case ds_sfCKL of {
          GHC.Types.I# x1_sfCKP [Occ=Once!] ->
              case x1_sfCKP of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfCKM $dData_sfCKK x_sfCKN;
              };
        };

Data.Semigroup.$fDataLast_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Last a -> m (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCKR $dMonadPlus_sfCKS ds_sfCKT eta_sfCKU]
        let {
          lvl33_sfCKV [Occ=OnceL] :: m_afya8 (Data.Semigroup.Last a_XfyAn)
          [LclId] =
              [$dMonadPlus_sfCKS] \u [] GHC.Base.mzero $dMonadPlus_sfCKS;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCKS
          of
          $dMonad_sfCKW [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCLl [Occ=Once]
                    :: (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                       -> m_afya8 (Data.Semigroup.Last a_XfyAn)
                  [LclId] =
                      [lvl33_sfCKV $dMonad_sfCKW] \r [ds1_sfCLg]
                          case ds1_sfCLg of {
                            (,) x'_sfCLi [Occ=Once] b_sfCLj [Occ=Once!] ->
                                case b_sfCLj of {
                                  GHC.Types.False -> lvl33_sfCKV;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCKW x'_sfCLi;
                                };
                          }; } in
                let {
                  sat_sfCLf [Occ=Once]
                    :: m_afya8 (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCKR
                       $dMonadPlus_sfCKS
                       ds_sfCKT
                       eta_sfCKU
                       $dMonad_sfCKW] \u []
                          let {
                            lvl34_sfCKX [Occ=OnceL] :: m_afya8 a_XfyAn
                            [LclId] =
                                [$dData_sfCKR ds_sfCKT eta_sfCKU] \u []
                                    ds_sfCKT $dData_sfCKR eta_sfCKU; } in
                          let {
                            sat_sfCLe [Occ=Once]
                              :: (a_XfyAn -> Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                                 -> m_afya8 (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCKS
                                 eta_sfCKU
                                 $dMonad_sfCKW
                                 lvl34_sfCKX] \r [ds1_sfCKZ]
                                    case ds1_sfCKZ of {
                                      (,) h_sfCL1 b1_sfCL2 [Occ=Once!] ->
                                          case b1_sfCL2 of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfCLb [Occ=Once]
                                                    :: m_afya8 (Data.Semigroup.Last a_XfyAn,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfCKU $dMonad_sfCKW h_sfCL1] \u []
                                                          let {
                                                            sat_sfCL9 [Occ=Once]
                                                              :: Data.Semigroup.Last a_XfyAn
                                                            [LclId] =
                                                                [eta_sfCKU h_sfCL1] \u []
                                                                    h_sfCL1 eta_sfCKU; } in
                                                          let {
                                                            sat_sfCLa [Occ=Once]
                                                              :: (Data.Semigroup.Last a_XfyAn,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfCL9
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfCKW sat_sfCLa; } in
                                                let {
                                                  sat_sfCL8 [Occ=Once]
                                                    :: m_afya8 (Data.Semigroup.Last a_XfyAn,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfCKW lvl34_sfCKX h_sfCL1] \u []
                                                          let {
                                                            sat_sfCL7 [Occ=Once]
                                                              :: a_XfyAn
                                                                 -> m_afya8 (Data.Semigroup.Last
                                                                               a_XfyAn,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCKW
                                                                 h_sfCL1] \r [y'_sfCL4]
                                                                    let {
                                                                      sat_sfCL5 [Occ=Once]
                                                                        :: Data.Semigroup.Last
                                                                             a_XfyAn
                                                                      [LclId] =
                                                                          [h_sfCL1 y'_sfCL4] \u []
                                                                              h_sfCL1 y'_sfCL4; } in
                                                                    let {
                                                                      sat_sfCL6 [Occ=Once]
                                                                        :: (Data.Semigroup.Last
                                                                              a_XfyAn,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCL5
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCKW sat_sfCL6;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfCKW lvl34_sfCKX sat_sfCL7;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfCKS sat_sfCL8 sat_sfCLb;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfCLc [Occ=Once]
                                                    :: Data.Semigroup.Last a_XfyAn
                                                  [LclId] =
                                                      [eta_sfCKU h_sfCL1] \u []
                                                          h_sfCL1 eta_sfCKU; } in
                                                let {
                                                  sat_sfCLd [Occ=Once]
                                                    :: (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfCLc GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfCKW sat_sfCLd;
                                          };
                                    }; } in
                          let {
                            sat_sfCKY [Occ=Once]
                              :: m_afya8 (a_XfyAn -> Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCKW] \u []
                                    GHC.Base.return $dMonad_sfCKW Data.Semigroup.$fDataLast1;
                          } in  GHC.Base.>>= $dMonad_sfCKW sat_sfCKY sat_sfCLe;
                } in  GHC.Base.>>= $dMonad_sfCKW sat_sfCLf sat_sfCLl;
          };

lvl24_rfC77 :: forall a. Data.Semigroup.Last a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCLm] Data.Semigroup.$cLast;

lvl25_rfC78
  :: forall a. Data.Semigroup.Last a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCLn] Data.Semigroup.$tLast;

lvl26_rfC79
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Last a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCLo ds_sfCLp] GHC.Base.Nothing [];

Data.Semigroup.$fDataLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Last a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCLq]
        let {
          sat_sfCLV [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Last a_XfyAm -> m (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfCLq] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapMo
                      $dData_sfCLq eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCLU [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Last a_XfyAm -> m (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfCLq] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapMp
                      $dData_sfCLq eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCLT [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Last a_XfyAm -> m (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfCLq] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapM
                      $dData_sfCLq eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCLS [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Last a_XfyAm
               -> u
          [LclId] =
              [$dData_sfCLq] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapQi
                      $dData_sfCLq eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCLR [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Last a_XfyAm -> [u]
          [LclId] =
              [$dData_sfCLq] \r [ds_sfCLO x0_sfCLP]
                  let {
                    sat_sfCLQ [Occ=Once] :: u_afy9a
                    [LclId] =
                        [$dData_sfCLq ds_sfCLO x0_sfCLP] \u []
                            ds_sfCLO $dData_sfCLq x0_sfCLP;
                  } in  : [sat_sfCLQ GHC.Types.[]]; } in
        let {
          sat_sfCLN [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Last a_XfyAm
               -> r
          [LclId] =
              [$dData_sfCLq] \r [ds_sfCLI ds1_sfCLJ ds2_sfCLK x0_sfCLL]
                  let {
                    sat_sfCLM [Occ=Once] :: r'_afy8U
                    [LclId] =
                        [$dData_sfCLq ds2_sfCLK x0_sfCLL] \u []
                            ds2_sfCLK $dData_sfCLq x0_sfCLL;
                  } in  ds_sfCLI sat_sfCLM ds1_sfCLJ; } in
        let {
          sat_sfCLH [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Last a_XfyAm
               -> r
          [LclId] =
              [$dData_sfCLq] \r [ds_sfCLC ds1_sfCLD ds2_sfCLE eta_sfCLF]
                  let {
                    sat_sfCLG [Occ=Once] :: r'_afy8D
                    [LclId] =
                        [$dData_sfCLq ds2_sfCLE eta_sfCLF] \u []
                            ds2_sfCLE $dData_sfCLq eta_sfCLF;
                  } in  ds_sfCLC ds1_sfCLD sat_sfCLG; } in
        let {
          sat_sfCLB [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Last a_XfyAm -> Data.Semigroup.Last a_XfyAm
          [LclId] =
              [$dData_sfCLq] \r [ds_sfCLz x0_sfCLA]
                  ds_sfCLz $dData_sfCLq x0_sfCLA; } in
        let {
          sat_sfCLy [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Last a_XfyAm))
          [LclId] =
              [$dData_sfCLq] \r [eta_B1]
                  Data.Semigroup.$fDataLast_$cdataCast1 $dData_sfCLq eta_B1; } in
        let {
          sat_sfCLx [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfCLq] \r [k_sfCLt z_sfCLu ds_sfCLv]
                  let {
                    sat_sfCLw [Occ=Once]
                      :: c_afy7t (a_XfyAm -> Data.Semigroup.Last a_XfyAm)
                    [LclId] =
                        [z_sfCLu] \u [] z_sfCLu Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfCLt $dData_sfCLq sat_sfCLw; } in
        let {
          sat_sfCLs [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Last a_XfyAm
               -> c (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfCLq] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgfoldl
                      $dData_sfCLq eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCLr [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfCLq] \u [] Data.Semigroup.$fDataLast8 $dData_sfCLq;
        } in 
          Data.Data.C:Data [sat_sfCLr
                            sat_sfCLs
                            sat_sfCLx
                            lvl24_rfC77
                            lvl25_rfC78
                            sat_sfCLy
                            lvl26_rfC79
                            sat_sfCLB
                            sat_sfCLH
                            sat_sfCLN
                            sat_sfCLR
                            sat_sfCLS
                            sat_sfCLT
                            sat_sfCLU
                            sat_sfCLV];

Data.Semigroup.$fDataWrappedMonoid3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataWrappedMonoid4];

Data.Semigroup.$tcWrappedMonoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3715640179151546043##
                                    2823802549020348832##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataWrappedMonoid3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep12_rfC7a :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcWrappedMonoid
                                              $krep2_rfC6L];

Data.Semigroup.$tc'WrapMonoid1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep12_rfC7a];

Data.Semigroup.$tc'WrapMonoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'WrapMonoid"#;

Data.Semigroup.$tc'WrapMonoid2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'WrapMonoid3];

Data.Semigroup.$tc'WrapMonoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4283841874858276090##
                                    3445460813926951313##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'WrapMonoid2
                                    1#
                                    Data.Semigroup.$tc'WrapMonoid1];

Data.Semigroup.$fDataWrappedMonoid2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.WrappedMonoid
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                3715640179151546043##
                2823802549020348832##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataWrappedMonoid3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCLX [Occ=Once]
                   ww9_sfCLY [Occ=Once]
                   ww10_sfCLZ [Occ=Once]
                   ww11_sfCM0 [Occ=Once]
                   ww12_sfCM1 [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCLX
                                              ww9_sfCLY
                                              ww10_sfCLZ
                                              ww11_sfCM0
                                              ww12_sfCM1];
        };

Data.Semigroup.$fDataWrappedMonoid8
  :: forall m.
     Data.Data.Data m =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCM2]
        case Data.Data.$p1Data $dData_sfCM2 of sat_sfCM3 {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataWrappedMonoid2 sat_sfCM3;
        };

Data.Semigroup.$fDataWrappedMonoid_$cdataCast1
  :: forall m.
     Data.Data.Data m =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.WrappedMonoid m))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCM4 $dTypeable_sfCM5]
        let {
          lvl33_sfCM6 [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCM5] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCM5 Data.Semigroup.$fDataWrappedMonoid2; } in
        let {
          sat_sfCMa [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afygP (t_afygO d))
               -> GHC.Base.Maybe (c_afygP (Data.Semigroup.WrappedMonoid m_XfyJL))
          [LclId] =
              [$dData_sfCM4 lvl33_sfCM6] \r [f_sfCM7]
                  case lvl33_sfCM6 of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCM9 [Occ=Once]
                            :: c_afygP (Data.Semigroup.WrappedMonoid m_XfyJL)
                          [LclId] =
                              [$dData_sfCM4 f_sfCM7] \u [] f_sfCM7 $dData_sfCM4;
                        } in  GHC.Base.Just [sat_sfCM9];
                  };
        } in  sat_sfCMa;

Data.Semigroup.$fDataWrappedMonoid1
  :: forall m. (m -> Data.Semigroup.WrappedMonoid m, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataWrappedMonoid_$cgmapMp
  :: forall m.
     Data.Data.Data m =>
     forall (m1 :: * -> *).
     GHC.Base.MonadPlus m1 =>
     (forall d. Data.Data.Data d => d -> m1 d)
     -> Data.Semigroup.WrappedMonoid m
     -> m1 (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCMb $dMonadPlus_sfCMc ds_sfCMd eta_sfCMe]
        let {
          lvl33_sfCMf [Occ=OnceL]
            :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU)
          [LclId] =
              [$dMonadPlus_sfCMc] \u [] GHC.Base.mzero $dMonadPlus_sfCMc;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCMc
          of
          $dMonad_sfCMg [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCMC [Occ=Once]
                    :: (Data.Semigroup.WrappedMonoid m_XfyJU, GHC.Types.Bool)
                       -> m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU)
                  [LclId] =
                      [lvl33_sfCMf $dMonad_sfCMg] \r [ds1_sfCMx]
                          case ds1_sfCMx of {
                            (,) x'_sfCMz [Occ=Once] b_sfCMA [Occ=Once!] ->
                                case b_sfCMA of {
                                  GHC.Types.False -> lvl33_sfCMf;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCMg x'_sfCMz;
                                };
                          }; } in
                let {
                  sat_sfCMw [Occ=Once]
                    :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCMb
                       $dMonadPlus_sfCMc
                       ds_sfCMd
                       eta_sfCMe
                       $dMonad_sfCMg] \u []
                          let {
                            lvl34_sfCMh [Occ=OnceL] :: m1_afyiU m_XfyJU
                            [LclId] =
                                [$dData_sfCMb ds_sfCMd eta_sfCMe] \u []
                                    ds_sfCMd $dData_sfCMb eta_sfCMe; } in
                          let {
                            sat_sfCMv [Occ=Once]
                              :: (m_XfyJU -> Data.Semigroup.WrappedMonoid m_XfyJU,
                                  GHC.Types.Bool)
                                 -> m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCMc
                                 eta_sfCMe
                                 $dMonad_sfCMg
                                 lvl34_sfCMh] \r [ds1_sfCMj]
                                    case ds1_sfCMj of {
                                      (,) h_sfCMl b1_sfCMm [Occ=Once] ->
                                          let {
                                            sat_sfCMu [Occ=Once]
                                              :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU,
                                                           GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfCMe $dMonad_sfCMg h_sfCMl b1_sfCMm] \u []
                                                    let {
                                                      sat_sfCMs [Occ=Once]
                                                        :: Data.Semigroup.WrappedMonoid m_XfyJU
                                                      [LclId] =
                                                          [eta_sfCMe h_sfCMl] \u []
                                                              h_sfCMl eta_sfCMe; } in
                                                    let {
                                                      sat_sfCMt [Occ=Once]
                                                        :: (Data.Semigroup.WrappedMonoid m_XfyJU,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfCMs b1_sfCMm];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfCMg sat_sfCMt; } in
                                          let {
                                            sat_sfCMr [Occ=Once]
                                              :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU,
                                                           GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfCMg lvl34_sfCMh h_sfCMl] \u []
                                                    let {
                                                      sat_sfCMq [Occ=Once]
                                                        :: m_XfyJU
                                                           -> m1_afyiU (Data.Semigroup.WrappedMonoid
                                                                          m_XfyJU,
                                                                        GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfCMg h_sfCMl] \r [y'_sfCMn]
                                                              let {
                                                                sat_sfCMo [Occ=Once]
                                                                  :: Data.Semigroup.WrappedMonoid
                                                                       m_XfyJU
                                                                [LclId] =
                                                                    [h_sfCMl y'_sfCMn] \u []
                                                                        h_sfCMl y'_sfCMn; } in
                                                              let {
                                                                sat_sfCMp [Occ=Once]
                                                                  :: (Data.Semigroup.WrappedMonoid
                                                                        m_XfyJU,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfCMo
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfCMg sat_sfCMp;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfCMg lvl34_sfCMh sat_sfCMq;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfCMc sat_sfCMr sat_sfCMu;
                                    }; } in
                          let {
                            sat_sfCMi [Occ=Once]
                              :: m1_afyiU (m_XfyJU -> Data.Semigroup.WrappedMonoid m_XfyJU,
                                           GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCMg] \u []
                                    GHC.Base.return
                                        $dMonad_sfCMg Data.Semigroup.$fDataWrappedMonoid1;
                          } in  GHC.Base.>>= $dMonad_sfCMg sat_sfCMi sat_sfCMv;
                } in  GHC.Base.>>= $dMonad_sfCMg sat_sfCMw sat_sfCMC;
          };

Data.Semigroup.$fDataWrappedMonoid_$cgmapM
  :: forall m.
     Data.Data.Data m =>
     forall (m1 :: * -> *).
     GHC.Base.Monad m1 =>
     (forall d. Data.Data.Data d => d -> m1 d)
     -> Data.Semigroup.WrappedMonoid m
     -> m1 (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCMD $dMonad_sfCME ds_sfCMF eta_sfCMG]
        let {
          lvl33_sfCMH [Occ=OnceL] :: m1_afyiE m_XfyJT
          [LclId] =
              [$dData_sfCMD ds_sfCMF eta_sfCMG] \u []
                  ds_sfCMF $dData_sfCMD eta_sfCMG; } in
        let {
          sat_sfCMN [Occ=Once]
            :: (m_XfyJT -> Data.Semigroup.WrappedMonoid m_XfyJT)
               -> m1_afyiE (Data.Semigroup.WrappedMonoid m_XfyJT)
          [LclId] =
              [$dMonad_sfCME lvl33_sfCMH] \r [c'_sfCMJ]
                  let {
                    sat_sfCMM [Occ=Once]
                      :: m_XfyJT -> m1_afyiE (Data.Semigroup.WrappedMonoid m_XfyJT)
                    [LclId] =
                        [$dMonad_sfCME c'_sfCMJ] \r [x'_sfCMK]
                            let {
                              sat_sfCML [Occ=Once] :: Data.Semigroup.WrappedMonoid m_XfyJT
                              [LclId] =
                                  [c'_sfCMJ x'_sfCMK] \u [] c'_sfCMJ x'_sfCMK;
                            } in  GHC.Base.return $dMonad_sfCME sat_sfCML;
                  } in  GHC.Base.>>= $dMonad_sfCME lvl33_sfCMH sat_sfCMM; } in
        let {
          sat_sfCMI [Occ=Once]
            :: m1_afyiE (m_XfyJT -> Data.Semigroup.WrappedMonoid m_XfyJT)
          [LclId] =
              [$dMonad_sfCME] \u []
                  GHC.Base.return $dMonad_sfCME Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfCME sat_sfCMI sat_sfCMN;

Data.Semigroup.$fDataWrappedMonoid_$cgmapQi
  :: forall m.
     Data.Data.Data m =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.WrappedMonoid m
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCMO ds_sfCMP ds1_sfCMQ x_sfCMR]
        case ds_sfCMP of {
          GHC.Types.I# x1_sfCMT [Occ=Once!] ->
              case x1_sfCMT of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfCMQ $dData_sfCMO x_sfCMR;
              };
        };

Data.Semigroup.$fDataWrappedMonoid_$cgmapMo
  :: forall m.
     Data.Data.Data m =>
     forall (m1 :: * -> *).
     GHC.Base.MonadPlus m1 =>
     (forall d. Data.Data.Data d => d -> m1 d)
     -> Data.Semigroup.WrappedMonoid m
     -> m1 (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCMV $dMonadPlus_sfCMW ds_sfCMX eta_sfCMY]
        let {
          lvl33_sfCMZ [Occ=OnceL]
            :: m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN)
          [LclId] =
              [$dMonadPlus_sfCMW] \u [] GHC.Base.mzero $dMonadPlus_sfCMW;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCMW
          of
          $dMonad_sfCN0 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCNp [Occ=Once]
                    :: (Data.Semigroup.WrappedMonoid m_XfyJN, GHC.Types.Bool)
                       -> m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN)
                  [LclId] =
                      [lvl33_sfCMZ $dMonad_sfCN0] \r [ds1_sfCNk]
                          case ds1_sfCNk of {
                            (,) x'_sfCNm [Occ=Once] b_sfCNn [Occ=Once!] ->
                                case b_sfCNn of {
                                  GHC.Types.False -> lvl33_sfCMZ;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCN0 x'_sfCNm;
                                };
                          }; } in
                let {
                  sat_sfCNj [Occ=Once]
                    :: m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCMV
                       $dMonadPlus_sfCMW
                       ds_sfCMX
                       eta_sfCMY
                       $dMonad_sfCN0] \u []
                          let {
                            lvl34_sfCN1 [Occ=OnceL] :: m1_afyja m_XfyJN
                            [LclId] =
                                [$dData_sfCMV ds_sfCMX eta_sfCMY] \u []
                                    ds_sfCMX $dData_sfCMV eta_sfCMY; } in
                          let {
                            sat_sfCNi [Occ=Once]
                              :: (m_XfyJN -> Data.Semigroup.WrappedMonoid m_XfyJN,
                                  GHC.Types.Bool)
                                 -> m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCMW
                                 eta_sfCMY
                                 $dMonad_sfCN0
                                 lvl34_sfCN1] \r [ds1_sfCN3]
                                    case ds1_sfCN3 of {
                                      (,) h_sfCN5 b1_sfCN6 [Occ=Once!] ->
                                          case b1_sfCN6 of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfCNf [Occ=Once]
                                                    :: m1_afyja (Data.Semigroup.WrappedMonoid
                                                                   m_XfyJN,
                                                                 GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfCMY $dMonad_sfCN0 h_sfCN5] \u []
                                                          let {
                                                            sat_sfCNd [Occ=Once]
                                                              :: Data.Semigroup.WrappedMonoid
                                                                   m_XfyJN
                                                            [LclId] =
                                                                [eta_sfCMY h_sfCN5] \u []
                                                                    h_sfCN5 eta_sfCMY; } in
                                                          let {
                                                            sat_sfCNe [Occ=Once]
                                                              :: (Data.Semigroup.WrappedMonoid
                                                                    m_XfyJN,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfCNd
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfCN0 sat_sfCNe; } in
                                                let {
                                                  sat_sfCNc [Occ=Once]
                                                    :: m1_afyja (Data.Semigroup.WrappedMonoid
                                                                   m_XfyJN,
                                                                 GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfCN0 lvl34_sfCN1 h_sfCN5] \u []
                                                          let {
                                                            sat_sfCNb [Occ=Once]
                                                              :: m_XfyJN
                                                                 -> m1_afyja (Data.Semigroup.WrappedMonoid
                                                                                m_XfyJN,
                                                                              GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCN0
                                                                 h_sfCN5] \r [y'_sfCN8]
                                                                    let {
                                                                      sat_sfCN9 [Occ=Once]
                                                                        :: Data.Semigroup.WrappedMonoid
                                                                             m_XfyJN
                                                                      [LclId] =
                                                                          [h_sfCN5 y'_sfCN8] \u []
                                                                              h_sfCN5 y'_sfCN8; } in
                                                                    let {
                                                                      sat_sfCNa [Occ=Once]
                                                                        :: (Data.Semigroup.WrappedMonoid
                                                                              m_XfyJN,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCN9
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCN0 sat_sfCNa;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfCN0 lvl34_sfCN1 sat_sfCNb;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfCMW sat_sfCNc sat_sfCNf;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfCNg [Occ=Once]
                                                    :: Data.Semigroup.WrappedMonoid m_XfyJN
                                                  [LclId] =
                                                      [eta_sfCMY h_sfCN5] \u []
                                                          h_sfCN5 eta_sfCMY; } in
                                                let {
                                                  sat_sfCNh [Occ=Once]
                                                    :: (Data.Semigroup.WrappedMonoid m_XfyJN,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfCNg GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfCN0 sat_sfCNh;
                                          };
                                    }; } in
                          let {
                            sat_sfCN2 [Occ=Once]
                              :: m1_afyja (m_XfyJN -> Data.Semigroup.WrappedMonoid m_XfyJN,
                                           GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCN0] \u []
                                    GHC.Base.return
                                        $dMonad_sfCN0 Data.Semigroup.$fDataWrappedMonoid1;
                          } in  GHC.Base.>>= $dMonad_sfCN0 sat_sfCN2 sat_sfCNi;
                } in  GHC.Base.>>= $dMonad_sfCN0 sat_sfCNj sat_sfCNp;
          };

lvl27_rfC7b
  :: forall m. Data.Semigroup.WrappedMonoid m -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCNq] Data.Semigroup.$cWrapMonoid;

lvl28_rfC7c
  :: forall m. Data.Semigroup.WrappedMonoid m -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCNr] Data.Semigroup.$tWrappedMonoid;

lvl29_rfC7d
  :: forall m (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.WrappedMonoid m))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCNs ds_sfCNt] GHC.Base.Nothing [];

Data.Semigroup.$fDataWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     Data.Data.Data m =>
     Data.Data.Data (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCNu]
        let {
          sat_sfCNZ [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> m (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfCNu] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapMo
                      $dData_sfCNu eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCNY [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> m (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfCNu] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapMp
                      $dData_sfCNu eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCNX [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> m (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfCNu] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapM
                      $dData_sfCNu eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCNW [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> u
          [LclId] =
              [$dData_sfCNu] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapQi
                      $dData_sfCNu eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCNV [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.WrappedMonoid m_XfyJM -> [u]
          [LclId] =
              [$dData_sfCNu] \r [ds_sfCNS x0_sfCNT]
                  let {
                    sat_sfCNU [Occ=Once] :: u_afyic
                    [LclId] =
                        [$dData_sfCNu ds_sfCNS x0_sfCNT] \u []
                            ds_sfCNS $dData_sfCNu x0_sfCNT;
                  } in  : [sat_sfCNU GHC.Types.[]]; } in
        let {
          sat_sfCNR [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> r
          [LclId] =
              [$dData_sfCNu] \r [ds_sfCNM ds1_sfCNN ds2_sfCNO x0_sfCNP]
                  let {
                    sat_sfCNQ [Occ=Once] :: r'_afyhW
                    [LclId] =
                        [$dData_sfCNu ds2_sfCNO x0_sfCNP] \u []
                            ds2_sfCNO $dData_sfCNu x0_sfCNP;
                  } in  ds_sfCNM sat_sfCNQ ds1_sfCNN; } in
        let {
          sat_sfCNL [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> r
          [LclId] =
              [$dData_sfCNu] \r [ds_sfCNG ds1_sfCNH ds2_sfCNI eta_sfCNJ]
                  let {
                    sat_sfCNK [Occ=Once] :: r'_afyhF
                    [LclId] =
                        [$dData_sfCNu ds2_sfCNI eta_sfCNJ] \u []
                            ds2_sfCNI $dData_sfCNu eta_sfCNJ;
                  } in  ds_sfCNG ds1_sfCNH sat_sfCNK; } in
        let {
          sat_sfCNF [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> Data.Semigroup.WrappedMonoid m_XfyJM
          [LclId] =
              [$dData_sfCNu] \r [ds_sfCND x0_sfCNE]
                  ds_sfCND $dData_sfCNu x0_sfCNE; } in
        let {
          sat_sfCNC [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.WrappedMonoid m_XfyJM))
          [LclId] =
              [$dData_sfCNu] \r [eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cdataCast1
                      $dData_sfCNu eta_B1; } in
        let {
          sat_sfCNB [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfCNu] \r [k_sfCNx z_sfCNy ds_sfCNz]
                  let {
                    sat_sfCNA [Occ=Once]
                      :: c_afygv (m_XfyJM -> Data.Semigroup.WrappedMonoid m_XfyJM)
                    [LclId] =
                        [z_sfCNy] \u [] z_sfCNy Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfCNx $dData_sfCNu sat_sfCNA; } in
        let {
          sat_sfCNw [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> c (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfCNu] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgfoldl
                      $dData_sfCNu eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCNv [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfCNu] \u []
                  Data.Semigroup.$fDataWrappedMonoid8 $dData_sfCNu;
        } in 
          Data.Data.C:Data [sat_sfCNv
                            sat_sfCNw
                            sat_sfCNB
                            lvl27_rfC7b
                            lvl28_rfC7c
                            sat_sfCNC
                            lvl29_rfC7d
                            sat_sfCNF
                            sat_sfCNL
                            sat_sfCNR
                            sat_sfCNV
                            sat_sfCNW
                            sat_sfCNX
                            sat_sfCNY
                            sat_sfCNZ];

Data.Semigroup.$fDataOption5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataOption6];

Data.Semigroup.$tcOption :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10723619047615802556##
                                    16447525423442151350##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataOption5
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep13_rfC7e :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcOption
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Option1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rfC6M $krep13_rfC7e];

Data.Semigroup.$tc'Option3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Option"#;

Data.Semigroup.$tc'Option2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Option3];

Data.Semigroup.$tc'Option :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10684524870560962689##
                                    6198254930115905464##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Option2
                                    1#
                                    Data.Semigroup.$tc'Option1];

Data.Semigroup.$fDataOption4
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Option
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                10723619047615802556##
                16447525423442151350##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataOption5
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCO1 [Occ=Once]
                   ww9_sfCO2 [Occ=Once]
                   ww10_sfCO3 [Occ=Once]
                   ww11_sfCO4 [Occ=Once]
                   ww12_sfCO5 [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCO1
                                              ww9_sfCO2
                                              ww10_sfCO3
                                              ww11_sfCO4
                                              ww12_sfCO5];
        };

Data.Semigroup.$fDataOption10
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCO6]
        case Data.Data.$p1Data $dData_sfCO6 of sat_sfCO7 {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataOption4 sat_sfCO7;
        };

Data.Semigroup.$fDataOption_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Option a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCO8 $dTypeable_sfCO9]
        let {
          lvl33_sfCOa [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCO9] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCO9 Data.Semigroup.$fDataOption4; } in
        let {
          sat_sfCOe [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afypz (t_afypy d))
               -> GHC.Base.Maybe (c_afypz (Data.Semigroup.Option a_XfyST))
          [LclId] =
              [$dData_sfCO8 lvl33_sfCOa] \r [f_sfCOb]
                  case lvl33_sfCOa of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCOd [Occ=Once] :: c_afypz (Data.Semigroup.Option a_XfyST)
                          [LclId] =
                              [$dData_sfCO8 f_sfCOb] \u [] f_sfCOb $dData_sfCO8;
                        } in  GHC.Base.Just [sat_sfCOd];
                  };
        } in  sat_sfCOe;

Data.Semigroup.$fDataOption1
  :: forall a.
     (GHC.Base.Maybe a -> Data.Semigroup.Option a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fDataOption2 GHC.Types.False];

Data.Semigroup.$fDataOption_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCOf $dMonadPlus_sfCOg ds_sfCOh eta_sfCOi]
        let {
          lvl33_sfCOj [Occ=OnceL] :: m_afyrE (Data.Semigroup.Option a_XfyT2)
          [LclId] =
              [$dMonadPlus_sfCOg] \u [] GHC.Base.mzero $dMonadPlus_sfCOg;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCOg
          of
          $dMonad_sfCOk [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCOH [Occ=Once]
                    :: (Data.Semigroup.Option a_XfyT2, GHC.Types.Bool)
                       -> m_afyrE (Data.Semigroup.Option a_XfyT2)
                  [LclId] =
                      [lvl33_sfCOj $dMonad_sfCOk] \r [ds1_sfCOC]
                          case ds1_sfCOC of {
                            (,) x'_sfCOE [Occ=Once] b_sfCOF [Occ=Once!] ->
                                case b_sfCOF of {
                                  GHC.Types.False -> lvl33_sfCOj;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCOk x'_sfCOE;
                                };
                          }; } in
                let {
                  sat_sfCOB [Occ=Once]
                    :: m_afyrE (Data.Semigroup.Option a_XfyT2, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCOf
                       $dMonadPlus_sfCOg
                       ds_sfCOh
                       eta_sfCOi
                       $dMonad_sfCOk] \u []
                          let {
                            lvl34_sfCOl [Occ=OnceL] :: m_afyrE (GHC.Base.Maybe a_XfyT2)
                            [LclId] =
                                [$dData_sfCOf ds_sfCOh eta_sfCOi] \u []
                                    let {
                                      sat_sfCOm [Occ=Once]
                                        :: Data.Data.Data (GHC.Base.Maybe a_XfyT2)
                                      [LclId] =
                                          [$dData_sfCOf] \u [] Data.Data.$fDataMaybe $dData_sfCOf;
                                    } in  ds_sfCOh sat_sfCOm eta_sfCOi; } in
                          let {
                            sat_sfCOA [Occ=Once]
                              :: (GHC.Base.Maybe a_XfyT2 -> Data.Semigroup.Option a_XfyT2,
                                  GHC.Types.Bool)
                                 -> m_afyrE (Data.Semigroup.Option a_XfyT2, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCOg
                                 eta_sfCOi
                                 $dMonad_sfCOk
                                 lvl34_sfCOl] \r [ds1_sfCOo]
                                    case ds1_sfCOo of {
                                      (,) h_sfCOq b1_sfCOr [Occ=Once] ->
                                          let {
                                            sat_sfCOz [Occ=Once]
                                              :: m_afyrE (Data.Semigroup.Option a_XfyT2,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfCOi $dMonad_sfCOk h_sfCOq b1_sfCOr] \u []
                                                    let {
                                                      sat_sfCOx [Occ=Once]
                                                        :: Data.Semigroup.Option a_XfyT2
                                                      [LclId] =
                                                          [eta_sfCOi h_sfCOq] \u []
                                                              h_sfCOq eta_sfCOi; } in
                                                    let {
                                                      sat_sfCOy [Occ=Once]
                                                        :: (Data.Semigroup.Option a_XfyT2,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfCOx b1_sfCOr];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfCOk sat_sfCOy; } in
                                          let {
                                            sat_sfCOw [Occ=Once]
                                              :: m_afyrE (Data.Semigroup.Option a_XfyT2,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfCOk lvl34_sfCOl h_sfCOq] \u []
                                                    let {
                                                      sat_sfCOv [Occ=Once]
                                                        :: GHC.Base.Maybe a_XfyT2
                                                           -> m_afyrE (Data.Semigroup.Option
                                                                         a_XfyT2,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfCOk h_sfCOq] \r [y'_sfCOs]
                                                              let {
                                                                sat_sfCOt [Occ=Once]
                                                                  :: Data.Semigroup.Option a_XfyT2
                                                                [LclId] =
                                                                    [h_sfCOq y'_sfCOs] \u []
                                                                        h_sfCOq y'_sfCOs; } in
                                                              let {
                                                                sat_sfCOu [Occ=Once]
                                                                  :: (Data.Semigroup.Option a_XfyT2,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfCOt
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfCOk sat_sfCOu;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfCOk lvl34_sfCOl sat_sfCOv;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfCOg sat_sfCOw sat_sfCOz;
                                    }; } in
                          let {
                            sat_sfCOn [Occ=Once]
                              :: m_afyrE (GHC.Base.Maybe a_XfyT2
                                          -> Data.Semigroup.Option a_XfyT2,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCOk] \u []
                                    GHC.Base.return $dMonad_sfCOk Data.Semigroup.$fDataOption1;
                          } in  GHC.Base.>>= $dMonad_sfCOk sat_sfCOn sat_sfCOA;
                } in  GHC.Base.>>= $dMonad_sfCOk sat_sfCOB sat_sfCOH;
          };

Data.Semigroup.$fDataOption_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option a)
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCOI $dMonad_sfCOJ ds_sfCOK]
        let {
          $dData1_sfCOL [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_XfyT1)
          [LclId] =
              [$dData_sfCOI] \u [] Data.Data.$fDataMaybe $dData_sfCOI; } in
        let {
          lvl33_sfCOM [Occ=OnceL]
            :: m_afyro (GHC.Base.Maybe a_XfyT1
                        -> Data.Semigroup.Option a_XfyT1)
          [LclId] =
              [$dMonad_sfCOJ] \u []
                  GHC.Base.return $dMonad_sfCOJ Data.Semigroup.$fDataOption2; } in
        let {
          sat_sfCOU [Occ=OnceT[0]]
            :: Data.Semigroup.Option a_XfyT1
               -> m_afyro (Data.Semigroup.Option a_XfyT1)
          [LclId] =
              [$dMonad_sfCOJ ds_sfCOK $dData1_sfCOL lvl33_sfCOM] \r [ds1_sfCON]
                  let {
                    lvl34_sfCOO [Occ=OnceL] :: m_afyro (GHC.Base.Maybe a_XfyT1)
                    [LclId] =
                        [ds_sfCOK $dData1_sfCOL ds1_sfCON] \u []
                            ds_sfCOK $dData1_sfCOL ds1_sfCON; } in
                  let {
                    sat_sfCOT [Occ=Once]
                      :: (GHC.Base.Maybe a_XfyT1 -> Data.Semigroup.Option a_XfyT1)
                         -> m_afyro (Data.Semigroup.Option a_XfyT1)
                    [LclId] =
                        [$dMonad_sfCOJ lvl34_sfCOO] \r [c'_sfCOP]
                            let {
                              sat_sfCOS [Occ=Once]
                                :: GHC.Base.Maybe a_XfyT1
                                   -> m_afyro (Data.Semigroup.Option a_XfyT1)
                              [LclId] =
                                  [$dMonad_sfCOJ c'_sfCOP] \r [x'_sfCOQ]
                                      let {
                                        sat_sfCOR [Occ=Once] :: Data.Semigroup.Option a_XfyT1
                                        [LclId] =
                                            [c'_sfCOP x'_sfCOQ] \u [] c'_sfCOP x'_sfCOQ;
                                      } in  GHC.Base.return $dMonad_sfCOJ sat_sfCOR;
                            } in  GHC.Base.>>= $dMonad_sfCOJ lvl34_sfCOO sat_sfCOS;
                  } in  GHC.Base.>>= $dMonad_sfCOJ lvl33_sfCOM sat_sfCOT;
        } in  sat_sfCOU;

Data.Semigroup.$fDataOption_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Option a
     -> u
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCOV ds_sfCOW ds1_sfCOX x_sfCOY]
        case ds_sfCOW of {
          GHC.Types.I# x1_sfCP0 [Occ=Once!] ->
              case x1_sfCP0 of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# ->
                    let {
                      sat_sfCP2 [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfyT0)
                      [LclId] =
                          [$dData_sfCOV] \u [] Data.Data.$fDataMaybe $dData_sfCOV;
                    } in  ds1_sfCOX sat_sfCP2 x_sfCOY;
              };
        };

Data.Semigroup.$fDataOption_$cgmapQr
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Option a
     -> r
[GblId,
 Arity=5,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCP3 ds_sfCP4 ds1_sfCP5 ds2_sfCP6 x0_sfCP7]
        let {
          sat_sfCP9 [Occ=Once] :: r'_afyqG
          [LclId] =
              [$dData_sfCP3 ds2_sfCP6 x0_sfCP7] \u []
                  let {
                    sat_sfCP8 [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfySY)
                    [LclId] =
                        [$dData_sfCP3] \u [] Data.Data.$fDataMaybe $dData_sfCP3;
                  } in  ds2_sfCP6 sat_sfCP8 x0_sfCP7;
        } in  ds_sfCP4 sat_sfCP9 ds1_sfCP5;

Data.Semigroup.$fDataOption_$cgmapQ
  :: forall a.
     Data.Data.Data a =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Option a -> [u]
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,1*C1(C1(U))><L,U>m2,
 Unf=OtherCon []] =
    [] \r [$dData_sfCPa ds_sfCPb x0_sfCPc]
        let {
          sat_sfCPe [Occ=Once] :: u_afyqW
          [LclId] =
              [$dData_sfCPa ds_sfCPb x0_sfCPc] \u []
                  let {
                    sat_sfCPd [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfySZ)
                    [LclId] =
                        [$dData_sfCPa] \u [] Data.Data.$fDataMaybe $dData_sfCPa;
                  } in  ds_sfCPb sat_sfCPd x0_sfCPc;
        } in  : [sat_sfCPe GHC.Types.[]];

Data.Semigroup.$fDataOption_$cgmapQl
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Option a
     -> r
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCPf ds_sfCPg ds1_sfCPh ds2_sfCPi]
        let {
          $dData1_sfCPj [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_XfySX)
          [LclId] =
              [$dData_sfCPf] \u [] Data.Data.$fDataMaybe $dData_sfCPf; } in
        let {
          sat_sfCPm [Occ=OnceT[0]]
            :: Data.Semigroup.Option a_XfySX -> r_afyqo
          [LclId] =
              [ds_sfCPg ds1_sfCPh ds2_sfCPi $dData1_sfCPj] \r [x_sfCPk]
                  let {
                    sat_sfCPl [Occ=Once] :: r'_afyqp
                    [LclId] =
                        [ds2_sfCPi $dData1_sfCPj x_sfCPk] \u []
                            ds2_sfCPi $dData1_sfCPj x_sfCPk;
                  } in  ds_sfCPg ds1_sfCPh sat_sfCPl;
        } in  sat_sfCPm;

Data.Semigroup.$fDataOption3
  :: forall a.
     Data.Data.Data a =>
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Semigroup.Option a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCPn ds_sfCPo x0_sfCPp]
        let {
          sat_sfCPq [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfySW)
          [LclId] =
              [$dData_sfCPn] \u [] Data.Data.$fDataMaybe $dData_sfCPn;
        } in  ds_sfCPo sat_sfCPq x0_sfCPp;

Data.Semigroup.$fDataOption_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCPr $dMonadPlus_sfCPs ds_sfCPt eta_sfCPu]
        let {
          lvl33_sfCPv [Occ=OnceL] :: m_afyrU (Data.Semigroup.Option a_XfySV)
          [LclId] =
              [$dMonadPlus_sfCPs] \u [] GHC.Base.mzero $dMonadPlus_sfCPs;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCPs
          of
          $dMonad_sfCPw [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCPW [Occ=Once]
                    :: (Data.Semigroup.Option a_XfySV, GHC.Types.Bool)
                       -> m_afyrU (Data.Semigroup.Option a_XfySV)
                  [LclId] =
                      [lvl33_sfCPv $dMonad_sfCPw] \r [ds1_sfCPR]
                          case ds1_sfCPR of {
                            (,) x'_sfCPT [Occ=Once] b_sfCPU [Occ=Once!] ->
                                case b_sfCPU of {
                                  GHC.Types.False -> lvl33_sfCPv;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCPw x'_sfCPT;
                                };
                          }; } in
                let {
                  sat_sfCPQ [Occ=Once]
                    :: m_afyrU (Data.Semigroup.Option a_XfySV, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCPr
                       $dMonadPlus_sfCPs
                       ds_sfCPt
                       eta_sfCPu
                       $dMonad_sfCPw] \u []
                          let {
                            lvl34_sfCPx [Occ=OnceL] :: m_afyrU (GHC.Base.Maybe a_XfySV)
                            [LclId] =
                                [$dData_sfCPr ds_sfCPt eta_sfCPu] \u []
                                    let {
                                      sat_sfCPy [Occ=Once]
                                        :: Data.Data.Data (GHC.Base.Maybe a_XfySV)
                                      [LclId] =
                                          [$dData_sfCPr] \u [] Data.Data.$fDataMaybe $dData_sfCPr;
                                    } in  ds_sfCPt sat_sfCPy eta_sfCPu; } in
                          let {
                            sat_sfCPP [Occ=Once]
                              :: (GHC.Base.Maybe a_XfySV -> Data.Semigroup.Option a_XfySV,
                                  GHC.Types.Bool)
                                 -> m_afyrU (Data.Semigroup.Option a_XfySV, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCPs
                                 eta_sfCPu
                                 $dMonad_sfCPw
                                 lvl34_sfCPx] \r [ds1_sfCPA]
                                    case ds1_sfCPA of {
                                      (,) h_sfCPC b1_sfCPD [Occ=Once!] ->
                                          case b1_sfCPD of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfCPM [Occ=Once]
                                                    :: m_afyrU (Data.Semigroup.Option a_XfySV,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfCPu $dMonad_sfCPw h_sfCPC] \u []
                                                          let {
                                                            sat_sfCPK [Occ=Once]
                                                              :: Data.Semigroup.Option a_XfySV
                                                            [LclId] =
                                                                [eta_sfCPu h_sfCPC] \u []
                                                                    h_sfCPC eta_sfCPu; } in
                                                          let {
                                                            sat_sfCPL [Occ=Once]
                                                              :: (Data.Semigroup.Option a_XfySV,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfCPK
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfCPw sat_sfCPL; } in
                                                let {
                                                  sat_sfCPJ [Occ=Once]
                                                    :: m_afyrU (Data.Semigroup.Option a_XfySV,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfCPw lvl34_sfCPx h_sfCPC] \u []
                                                          let {
                                                            sat_sfCPI [Occ=Once]
                                                              :: GHC.Base.Maybe a_XfySV
                                                                 -> m_afyrU (Data.Semigroup.Option
                                                                               a_XfySV,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCPw
                                                                 h_sfCPC] \r [y'_sfCPF]
                                                                    let {
                                                                      sat_sfCPG [Occ=Once]
                                                                        :: Data.Semigroup.Option
                                                                             a_XfySV
                                                                      [LclId] =
                                                                          [h_sfCPC y'_sfCPF] \u []
                                                                              h_sfCPC y'_sfCPF; } in
                                                                    let {
                                                                      sat_sfCPH [Occ=Once]
                                                                        :: (Data.Semigroup.Option
                                                                              a_XfySV,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCPG
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCPw sat_sfCPH;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfCPw lvl34_sfCPx sat_sfCPI;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfCPs sat_sfCPJ sat_sfCPM;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfCPN [Occ=Once]
                                                    :: Data.Semigroup.Option a_XfySV
                                                  [LclId] =
                                                      [eta_sfCPu h_sfCPC] \u []
                                                          h_sfCPC eta_sfCPu; } in
                                                let {
                                                  sat_sfCPO [Occ=Once]
                                                    :: (Data.Semigroup.Option a_XfySV,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfCPN GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfCPw sat_sfCPO;
                                          };
                                    }; } in
                          let {
                            sat_sfCPz [Occ=Once]
                              :: m_afyrU (GHC.Base.Maybe a_XfySV
                                          -> Data.Semigroup.Option a_XfySV,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCPw] \u []
                                    GHC.Base.return $dMonad_sfCPw Data.Semigroup.$fDataOption1;
                          } in  GHC.Base.>>= $dMonad_sfCPw sat_sfCPz sat_sfCPP;
                } in  GHC.Base.>>= $dMonad_sfCPw sat_sfCPQ sat_sfCPW;
          };

lvl30_rfC7f
  :: forall a. Data.Semigroup.Option a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCPX] Data.Semigroup.$cOption;

lvl31_rfC7g
  :: forall a. Data.Semigroup.Option a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCPY] Data.Semigroup.$tOption;

lvl32_rfC7h
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Option a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCPZ ds_sfCQ0] GHC.Base.Nothing [];

Data.Semigroup.$fDataOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Option a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCQ1]
        let {
          sat_sfCQd [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Option a_XfySU
               -> m (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfCQ1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapMo
                      $dData_sfCQ1 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCQc [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Option a_XfySU
               -> m (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfCQ1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapMp
                      $dData_sfCQ1 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCQb [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Option a_XfySU
               -> m (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfCQ1] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapM
                      $dData_sfCQ1 eta_B2 eta_B1; } in
        let {
          sat_sfCQa [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Option a_XfySU
               -> u
          [LclId] =
              [$dData_sfCQ1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQi
                      $dData_sfCQ1 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCQ9 [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Option a_XfySU -> [u]
          [LclId] =
              [$dData_sfCQ1] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQ
                      $dData_sfCQ1 eta_B2 eta_B1; } in
        let {
          sat_sfCQ8 [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Option a_XfySU
               -> r
          [LclId] =
              [$dData_sfCQ1] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQr
                      $dData_sfCQ1 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCQ7 [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Option a_XfySU
               -> r
          [LclId] =
              [$dData_sfCQ1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQl
                      $dData_sfCQ1 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCQ6 [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Option a_XfySU -> Data.Semigroup.Option a_XfySU
          [LclId] =
              [$dData_sfCQ1] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption3 $dData_sfCQ1 eta_B2 eta_B1; } in
        let {
          sat_sfCQ5 [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Option a_XfySU))
          [LclId] =
              [$dData_sfCQ1] \r [eta_B1]
                  Data.Semigroup.$fDataOption_$cdataCast1 $dData_sfCQ1 eta_B1; } in
        let {
          sat_sfCQ4 [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfCQ1] \u []
                  Data.Semigroup.$fDataOption_$cgunfold $dData_sfCQ1; } in
        let {
          sat_sfCQ3 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Option a_XfySU
               -> c (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfCQ1] \u []
                  Data.Semigroup.$fDataOption_$cgfoldl $dData_sfCQ1; } in
        let {
          sat_sfCQ2 [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfCQ1] \u [] Data.Semigroup.$fDataOption10 $dData_sfCQ1;
        } in 
          Data.Data.C:Data [sat_sfCQ2
                            sat_sfCQ3
                            sat_sfCQ4
                            lvl30_rfC7f
                            lvl31_rfC7g
                            sat_sfCQ5
                            lvl32_rfC7h
                            sat_sfCQ6
                            sat_sfCQ7
                            sat_sfCQ8
                            sat_sfCQ9
                            sat_sfCQa
                            sat_sfCQb
                            sat_sfCQc
                            sat_sfCQd];

Data.Semigroup.Arg :: forall a b. a -> b -> Data.Semigroup.Arg a b
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Semigroup.Arg [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:11:18.527512205 UTC

Data.Semigroup.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Min a
     -> [Data.Semigroup.Min a] -> Data.Semigroup.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfC7j ww_sfC7k ww1_sfC7l]
        let {
          go_sfC7m [Occ=LoopBreaker]
            :: Data.Semigroup.Min a_sfBoZ
               -> [Data.Semigroup.Min a_sfBoZ] -> Data.Semigroup.Min a_sfBoZ
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfC7j go_sfC7m] \r [b_sfC7n ds1_sfC7o]
                  case ds1_sfC7o of {
                    [] -> b_sfC7n;
                    : c_sfC7q [Occ=Once] cs_sfC7r [Occ=Once] ->
                        let {
                          sat_sfC7s [Occ=Once] :: a_sfBoZ
                          [LclId] =
                              [go_sfC7m c_sfC7q cs_sfC7r] \u [] go_sfC7m c_sfC7q cs_sfC7r;
                        } in  GHC.Classes.min w_sfC7j b_sfC7n sat_sfC7s;
                  };
        } in  go_sfC7m ww_sfC7k ww1_sfC7l;

Data.Semigroup.$fSemigroupMin_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Semigroup.Min a) -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfC7t w1_sfC7u]
        case w1_sfC7u of {
          GHC.Base.:| ww1_sfC7w [Occ=Once] ww2_sfC7x [Occ=Once] ->
              Data.Semigroup.$w$csconcat1 w_sfC7t ww1_sfC7w ww2_sfC7x;
        };

lvl_rfC66
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfC7y eta_sfC7z eta1_sfC7A]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfC7y eta_sfC7z eta1_sfC7A;

Data.Semigroup.$fSemigroupMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,A,A,U)>m] =
    [] \r [$dOrd_sfC7B]
        let {
          sat_sfC7D [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Min a_afzf5)
               -> Data.Semigroup.Min a_afzf5
          [LclId] =
              [$dOrd_sfC7B] \r [eta_B1]
                  Data.Semigroup.$fSemigroupMin_$csconcat $dOrd_sfC7B eta_B1; } in
        let {
          sat_sfC7C [Occ=Once]
            :: Data.Semigroup.Min a_afzf5
               -> Data.Semigroup.Min a_afzf5 -> Data.Semigroup.Min a_afzf5
          [LclId] =
              [$dOrd_sfC7B] \u [] GHC.Classes.min $dOrd_sfC7B;
        } in  GHC.Base.C:Semigroup [sat_sfC7C sat_sfC7D lvl_rfC66];

Data.Semigroup.$fFunctorMin2
  :: forall a b. (a -> b) -> Data.Semigroup.Min a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfC7E ds_sfC7F] f_sfC7E ds_sfC7F;

Data.Semigroup.$fFunctorMin1
  :: forall b a. a -> Data.Semigroup.Min b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sfC7G ds_sfC7H] x_sfC7G;

Data.Semigroup.$fFunctorMin [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorMin2
                                       Data.Semigroup.$fFunctorMin1];

Data.Semigroup.$fFoldableMin_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Min a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfC7I f_sfC7J ds_sfC7K] f_sfC7J ds_sfC7K;

Data.Semigroup.$fFoldableMin4
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.Min m -> Data.Semigroup.Min m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfC7L ds_sfC7M] ds_sfC7M;

Data.Semigroup.$fFoldableMin1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfC7N eta_sfC7O] eta_sfC7O;

Data.Semigroup.$fFoldableMin2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfC7P x_sfC7Q] x_sfC7Q;

Data.Semigroup.$fFoldableMin_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Min a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfC7R eta_sfC7S]
        let {
          f_sfC7T [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afzdA -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfC7R eta_sfC7S] \u []
                  GHC.Classes.== $dEq_sfC7R eta_sfC7S; } in
        let {
          sat_sfC7V [Occ=OnceT[0]]
            :: Data.Semigroup.Min a_afzdA -> GHC.Types.Bool
          [LclId] =
              [f_sfC7T] \r [ds_sfC7U] f_sfC7T ds_sfC7U;
        } in  sat_sfC7V;

Data.Semigroup.$fFoldableMin_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Min a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfC7W z_sfC7X t1_sfC7Y] f_sfC7W z_sfC7X t1_sfC7Y;

Data.Semigroup.$fFoldableMin3
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfC7Z xs_sfC80] xs_sfC80;

Data.Semigroup.$fFoldableMin_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Min a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfC81 z0_sfC82 xs_sfC83] f_sfC81 xs_sfC83 z0_sfC82;

Data.Semigroup.$fFoldableFirst3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Semigroup.$fFoldableMin_$clength
  :: forall a. Data.Semigroup.Min a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfC84] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableMin_$cnull
  :: forall a. Data.Semigroup.Min a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfC85] GHC.Types.False [];

Data.Semigroup.$fFoldableMin_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Min a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfC86] : [eta_sfC86 GHC.Types.[]];

Data.Semigroup.$fFoldableMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Min
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableMin4
                                             Data.Semigroup.$fFoldableMin_$cfoldMap
                                             Data.Semigroup.$fFoldableMin_$cfoldr'
                                             Data.Semigroup.$fFoldableMin_$cfoldr'
                                             Data.Semigroup.$fFoldableMin_$cfoldl
                                             Data.Semigroup.$fFoldableMin_$cfoldl
                                             Data.Semigroup.$fFoldableMin3
                                             Data.Semigroup.$fFoldableMin3
                                             Data.Semigroup.$fFoldableMin_$ctoList
                                             Data.Semigroup.$fFoldableMin_$cnull
                                             Data.Semigroup.$fFoldableMin_$clength
                                             Data.Semigroup.$fFoldableMin_$celem
                                             Data.Semigroup.$fFoldableMin2
                                             Data.Semigroup.$fFoldableMin2
                                             Data.Semigroup.$fFoldableMin1
                                             Data.Semigroup.$fFoldableMin1];

Data.Semigroup.$fApplicativeFirst3 :: forall b. b -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfC87] v_sfC87;

Data.Semigroup.$fTraversableMin_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.Min a -> f (Data.Semigroup.Min b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfC88 eta_sfC89 eta1_sfC8a]
        let {
          sat_sfC8c [Occ=Once] :: f_afzb8 b_afzba
          [LclId] =
              [eta_sfC89 eta1_sfC8a] \u [] eta_sfC89 eta1_sfC8a;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfC88 of sat_sfC8b {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfC8b Data.Semigroup.$fApplicativeFirst3 sat_sfC8c;
          };

Data.Semigroup.$fTraversableMin_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Min (f a) -> f (Data.Semigroup.Min a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfC8d eta_sfC8e]
        case GHC.Base.$p1Applicative $dApplicative_sfC8d of sat_sfC8f {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfC8f Data.Semigroup.$fApplicativeFirst3 eta_sfC8e;
        };

Data.Semigroup.$fTraversableMin_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.Min a -> m (Data.Semigroup.Min b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfC8g eta_sfC8h eta1_sfC8i]
        let {
          sat_sfC8l [Occ=Once] :: m_afzby b_afzbA
          [LclId] =
              [eta_sfC8h eta1_sfC8i] \u [] eta_sfC8h eta1_sfC8i;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfC8g of sat_sfC8j {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfC8j of sat_sfC8k {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfC8k Data.Semigroup.$fApplicativeFirst3 sat_sfC8l;
                };
          };

Data.Semigroup.$fTraversableMin_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Min (m a) -> m (Data.Semigroup.Min a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfC8m eta_sfC8n]
        case GHC.Base.$p1Monad $dMonad_sfC8m of sat_sfC8o {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfC8o of sat_sfC8p {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfC8p Data.Semigroup.$fApplicativeFirst3 eta_sfC8n;
              };
        };

Data.Semigroup.$fTraversableMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorMin
                                                   Data.Semigroup.$fFoldableMin
                                                   Data.Semigroup.$fTraversableMin_$ctraverse
                                                   Data.Semigroup.$fTraversableMin_$csequenceA
                                                   Data.Semigroup.$fTraversableMin_$cmapM
                                                   Data.Semigroup.$fTraversableMin_$csequence];

Data.Semigroup.$fApplicativeMin_$c<*
  :: forall a b.
     Data.Semigroup.Min a
     -> Data.Semigroup.Min b -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfC8q ds_sfC8r] a1_sfC8q;

Data.Semigroup.$fApplicativeMin_$c*>
  :: forall a b.
     Data.Semigroup.Min a
     -> Data.Semigroup.Min b -> Data.Semigroup.Min b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfC8s a1_sfC8t] a1_sfC8t;

Data.Semigroup.$fApplicativeFirst1
  :: forall a b c. (a -> b -> c) -> a -> b -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfC8u] v_sfC8u;

Data.Semigroup.$fApplicativeMin1
  :: forall a b.
     Data.Semigroup.Min (a -> b) -> Data.Semigroup.Min (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfC8v] v_sfC8v;

Data.Semigroup.$fApplicativeMin [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorMin
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeMin1
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeMin_$c*>
                                           Data.Semigroup.$fApplicativeMin_$c<*];

Data.Semigroup.$fMonadMin_$c>>=
  :: forall a b.
     Data.Semigroup.Min a
     -> (a -> Data.Semigroup.Min b) -> Data.Semigroup.Min b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfC8w f_sfC8x] f_sfC8x ds_sfC8w;

lvl1_rfC67 :: forall a. [GHC.Types.Char] -> Data.Semigroup.Min a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfC8y] GHC.Err.errorWithoutStackTrace eta_sfC8y;

Data.Semigroup.$fMonadMin [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeMin
                                     Data.Semigroup.$fMonadMin_$c>>=
                                     Data.Semigroup.$fApplicativeMin_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl1_rfC67];

Data.Semigroup.$fNumMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U))>m] =
    [] \r [$dNum_sfC8z]
        let {
          sat_sfC8Q [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [eta_sfC8P]
                  GHC.Num.fromInteger $dNum_sfC8z eta_sfC8P; } in
        let {
          sat_sfC8O [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [ds_sfC8N]
                  GHC.Num.signum $dNum_sfC8z ds_sfC8N; } in
        let {
          sat_sfC8M [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [ds_sfC8L] GHC.Num.abs $dNum_sfC8z ds_sfC8L; } in
        let {
          sat_sfC8K [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [ds_sfC8J]
                  GHC.Num.negate $dNum_sfC8z ds_sfC8J; } in
        let {
          sat_sfC8I [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK
               -> Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [ds_sfC8G ds1_sfC8H]
                  GHC.Num.* $dNum_sfC8z ds_sfC8G ds1_sfC8H; } in
        let {
          sat_sfC8F [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK
               -> Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [ds_sfC8D ds1_sfC8E]
                  GHC.Num.- $dNum_sfC8z ds_sfC8D ds1_sfC8E; } in
        let {
          sat_sfC8C [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK
               -> Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfC8z] \r [ds_sfC8A ds1_sfC8B]
                  GHC.Num.+ $dNum_sfC8z ds_sfC8A ds1_sfC8B;
        } in 
          GHC.Num.C:Num [sat_sfC8C
                         sat_sfC8F
                         sat_sfC8I
                         sat_sfC8K
                         sat_sfC8M
                         sat_sfC8O
                         sat_sfC8Q];

Data.Semigroup.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Max a
     -> [Data.Semigroup.Max a] -> Data.Semigroup.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfC8R ww_sfC8S ww1_sfC8T]
        let {
          go_sfC8U [Occ=LoopBreaker]
            :: Data.Semigroup.Max a_sfBpa
               -> [Data.Semigroup.Max a_sfBpa] -> Data.Semigroup.Max a_sfBpa
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfC8R go_sfC8U] \r [b_sfC8V ds1_sfC8W]
                  case ds1_sfC8W of {
                    [] -> b_sfC8V;
                    : c_sfC8Y [Occ=Once] cs_sfC8Z [Occ=Once] ->
                        let {
                          sat_sfC90 [Occ=Once] :: a_sfBpa
                          [LclId] =
                              [go_sfC8U c_sfC8Y cs_sfC8Z] \u [] go_sfC8U c_sfC8Y cs_sfC8Z;
                        } in  GHC.Classes.max w_sfC8R b_sfC8V sat_sfC90;
                  };
        } in  go_sfC8U ww_sfC8S ww1_sfC8T;

Data.Semigroup.$fSemigroupMax_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Semigroup.Max a) -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfC91 w1_sfC92]
        case w1_sfC92 of {
          GHC.Base.:| ww1_sfC94 [Occ=Once] ww2_sfC95 [Occ=Once] ->
              Data.Semigroup.$w$csconcat w_sfC91 ww1_sfC94 ww2_sfC95;
        };

lvl2_rfC68
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfC96 eta_sfC97 eta1_sfC98]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfC96 eta_sfC97 eta1_sfC98;

Data.Semigroup.$fSemigroupMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,A,U,A)>m] =
    [] \r [$dOrd_sfC99]
        let {
          sat_sfC9b [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Max a_afz6w)
               -> Data.Semigroup.Max a_afz6w
          [LclId] =
              [$dOrd_sfC99] \r [eta_B1]
                  Data.Semigroup.$fSemigroupMax_$csconcat $dOrd_sfC99 eta_B1; } in
        let {
          sat_sfC9a [Occ=Once]
            :: Data.Semigroup.Max a_afz6w
               -> Data.Semigroup.Max a_afz6w -> Data.Semigroup.Max a_afz6w
          [LclId] =
              [$dOrd_sfC99] \u [] GHC.Classes.max $dOrd_sfC99;
        } in  GHC.Base.C:Semigroup [sat_sfC9a sat_sfC9b lvl2_rfC68];

Data.Semigroup.$fFunctorMax2
  :: forall a b. (a -> b) -> Data.Semigroup.Max a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfC9c ds_sfC9d] f_sfC9c ds_sfC9d;

Data.Semigroup.$fFunctorMax1
  :: forall b a. a -> Data.Semigroup.Max b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sfC9e ds_sfC9f] x_sfC9e;

Data.Semigroup.$fFunctorMax [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorMax2
                                       Data.Semigroup.$fFunctorMax1];

Data.Semigroup.$fFoldableMax_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Max a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfC9g f_sfC9h ds_sfC9i] f_sfC9h ds_sfC9i;

Data.Semigroup.$fFoldableMax4
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.Max m -> Data.Semigroup.Max m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfC9j ds_sfC9k] ds_sfC9k;

Data.Semigroup.$fFoldableMax1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfC9l eta_sfC9m] eta_sfC9m;

Data.Semigroup.$fFoldableMax2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfC9n x_sfC9o] x_sfC9o;

Data.Semigroup.$fFoldableMax_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Max a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfC9p eta_sfC9q]
        let {
          f_sfC9r [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afz51 -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfC9p eta_sfC9q] \u []
                  GHC.Classes.== $dEq_sfC9p eta_sfC9q; } in
        let {
          sat_sfC9t [Occ=OnceT[0]]
            :: Data.Semigroup.Max a_afz51 -> GHC.Types.Bool
          [LclId] =
              [f_sfC9r] \r [ds_sfC9s] f_sfC9r ds_sfC9s;
        } in  sat_sfC9t;

Data.Semigroup.$fFoldableMax_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Max a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfC9u z_sfC9v t1_sfC9w] f_sfC9u z_sfC9v t1_sfC9w;

Data.Semigroup.$fFoldableMax3
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfC9x xs_sfC9y] xs_sfC9y;

Data.Semigroup.$fFoldableMax_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Max a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfC9z z0_sfC9A xs_sfC9B] f_sfC9z xs_sfC9B z0_sfC9A;

Data.Semigroup.$fFoldableMax_$clength
  :: forall a. Data.Semigroup.Max a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfC9C] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableMax_$cnull
  :: forall a. Data.Semigroup.Max a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfC9D] GHC.Types.False [];

Data.Semigroup.$fFoldableMax_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Max a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfC9E] : [eta_sfC9E GHC.Types.[]];

Data.Semigroup.$fFoldableMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Max
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableMax4
                                             Data.Semigroup.$fFoldableMax_$cfoldMap
                                             Data.Semigroup.$fFoldableMax_$cfoldr'
                                             Data.Semigroup.$fFoldableMax_$cfoldr'
                                             Data.Semigroup.$fFoldableMax_$cfoldl
                                             Data.Semigroup.$fFoldableMax_$cfoldl
                                             Data.Semigroup.$fFoldableMax3
                                             Data.Semigroup.$fFoldableMax3
                                             Data.Semigroup.$fFoldableMax_$ctoList
                                             Data.Semigroup.$fFoldableMax_$cnull
                                             Data.Semigroup.$fFoldableMax_$clength
                                             Data.Semigroup.$fFoldableMax_$celem
                                             Data.Semigroup.$fFoldableMax2
                                             Data.Semigroup.$fFoldableMax2
                                             Data.Semigroup.$fFoldableMax1
                                             Data.Semigroup.$fFoldableMax1];

Data.Semigroup.$fTraversableMax_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.Max a -> f (Data.Semigroup.Max b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfC9F eta_sfC9G eta1_sfC9H]
        let {
          sat_sfC9J [Occ=Once] :: f_afz2z b_afz2B
          [LclId] =
              [eta_sfC9G eta1_sfC9H] \u [] eta_sfC9G eta1_sfC9H;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfC9F of sat_sfC9I {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfC9I Data.Semigroup.$fApplicativeFirst3 sat_sfC9J;
          };

Data.Semigroup.$fTraversableMax_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Max (f a) -> f (Data.Semigroup.Max a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfC9K eta_sfC9L]
        case GHC.Base.$p1Applicative $dApplicative_sfC9K of sat_sfC9M {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfC9M Data.Semigroup.$fApplicativeFirst3 eta_sfC9L;
        };

Data.Semigroup.$fTraversableMax_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.Max a -> m (Data.Semigroup.Max b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfC9N eta_sfC9O eta1_sfC9P]
        let {
          sat_sfC9S [Occ=Once] :: m_afz2Z b_afz31
          [LclId] =
              [eta_sfC9O eta1_sfC9P] \u [] eta_sfC9O eta1_sfC9P;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfC9N of sat_sfC9Q {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfC9Q of sat_sfC9R {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfC9R Data.Semigroup.$fApplicativeFirst3 sat_sfC9S;
                };
          };

Data.Semigroup.$fTraversableMax_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Max (m a) -> m (Data.Semigroup.Max a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfC9T eta_sfC9U]
        case GHC.Base.$p1Monad $dMonad_sfC9T of sat_sfC9V {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfC9V of sat_sfC9W {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfC9W Data.Semigroup.$fApplicativeFirst3 eta_sfC9U;
              };
        };

Data.Semigroup.$fTraversableMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorMax
                                                   Data.Semigroup.$fFoldableMax
                                                   Data.Semigroup.$fTraversableMax_$ctraverse
                                                   Data.Semigroup.$fTraversableMax_$csequenceA
                                                   Data.Semigroup.$fTraversableMax_$cmapM
                                                   Data.Semigroup.$fTraversableMax_$csequence];

Data.Semigroup.$fApplicativeMax_$c<*
  :: forall a b.
     Data.Semigroup.Max a
     -> Data.Semigroup.Max b -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfC9X ds_sfC9Y] a1_sfC9X;

Data.Semigroup.$fApplicativeMax_$c*>
  :: forall a b.
     Data.Semigroup.Max a
     -> Data.Semigroup.Max b -> Data.Semigroup.Max b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfC9Z a1_sfCa0] a1_sfCa0;

Data.Semigroup.$fApplicativeMax1
  :: forall a b.
     Data.Semigroup.Max (a -> b) -> Data.Semigroup.Max (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfCa1] v_sfCa1;

Data.Semigroup.$fApplicativeMax [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorMax
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeMax1
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeMax_$c*>
                                           Data.Semigroup.$fApplicativeMax_$c<*];

Data.Semigroup.$fMonadMax_$c>>=
  :: forall a b.
     Data.Semigroup.Max a
     -> (a -> Data.Semigroup.Max b) -> Data.Semigroup.Max b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfCa2 f_sfCa3] f_sfCa3 ds_sfCa2;

lvl3_rfC69 :: forall a. [GHC.Types.Char] -> Data.Semigroup.Max a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfCa4] GHC.Err.errorWithoutStackTrace eta_sfCa4;

Data.Semigroup.$fMonadMax [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeMax
                                     Data.Semigroup.$fMonadMax_$c>>=
                                     Data.Semigroup.$fApplicativeMax_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl3_rfC69];

Data.Semigroup.$fNumMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U))>m] =
    [] \r [$dNum_sfCa5]
        let {
          sat_sfCam [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [eta_sfCal]
                  GHC.Num.fromInteger $dNum_sfCa5 eta_sfCal; } in
        let {
          sat_sfCak [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [ds_sfCaj]
                  GHC.Num.signum $dNum_sfCa5 ds_sfCaj; } in
        let {
          sat_sfCai [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [ds_sfCah] GHC.Num.abs $dNum_sfCa5 ds_sfCah; } in
        let {
          sat_sfCag [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [ds_sfCaf]
                  GHC.Num.negate $dNum_sfCa5 ds_sfCaf; } in
        let {
          sat_sfCae [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3
               -> Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [ds_sfCac ds1_sfCad]
                  GHC.Num.* $dNum_sfCa5 ds_sfCac ds1_sfCad; } in
        let {
          sat_sfCab [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3
               -> Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [ds_sfCa9 ds1_sfCaa]
                  GHC.Num.- $dNum_sfCa5 ds_sfCa9 ds1_sfCaa; } in
        let {
          sat_sfCa8 [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3
               -> Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfCa5] \r [ds_sfCa6 ds1_sfCa7]
                  GHC.Num.+ $dNum_sfCa5 ds_sfCa6 ds1_sfCa7;
        } in 
          GHC.Num.C:Num [sat_sfCa8
                         sat_sfCab
                         sat_sfCae
                         sat_sfCag
                         sat_sfCai
                         sat_sfCak
                         sat_sfCam];

Data.Semigroup.$fFunctorArg_$cfmap
  :: forall a1 a2 b.
     (a2 -> b) -> Data.Semigroup.Arg a1 a2 -> Data.Semigroup.Arg a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sfCan ds_sfCao]
        case ds_sfCao of {
          Data.Semigroup.Arg x_sfCaq [Occ=Once] a2_sfCar [Occ=Once] ->
              let {
                sat_sfCas [Occ=Once] :: b_afyZC
                [LclId] =
                    [f_sfCan a2_sfCar] \u [] f_sfCan a2_sfCar;
              } in  Data.Semigroup.Arg [x_sfCaq sat_sfCas];
        };

Data.Semigroup.$fFunctorArg_$c<$
  :: forall a1 a2 b.
     a2 -> Data.Semigroup.Arg a1 b -> Data.Semigroup.Arg a1 a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [x_sfCat ds_sfCau]
        case ds_sfCau of {
          Data.Semigroup.Arg x1_sfCaw [Occ=Once] _ [Occ=Dead] ->
              Data.Semigroup.Arg [x1_sfCaw x_sfCat];
        };

Data.Semigroup.$fFunctorArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Functor (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorArg_$cfmap
                                       Data.Semigroup.$fFunctorArg_$c<$];

Data.Semigroup.$fFoldableArg_$cfoldMap
  :: forall a1 m a2.
     GHC.Base.Monoid m =>
     (a2 -> m) -> Data.Semigroup.Arg a1 a2 -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCay f_sfCaz ds_sfCaA]
        case ds_sfCaA of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCaD [Occ=Once] ->
              f_sfCaz a2_sfCaD;
        };

Data.Semigroup.$fFoldableArg_$cfold
  :: forall a m. GHC.Base.Monoid m => Data.Semigroup.Arg a m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCaE ds_sfCaF]
        case ds_sfCaF of {
          Data.Semigroup.Arg _ [Occ=Dead] a1_sfCaI [Occ=Once] -> a1_sfCaI;
        };

Data.Semigroup.$fFoldableArg2
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Semigroup.Arg a1 a2 -> Data.Semigroup.Internal.Sum a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfCaJ eta_sfCaK]
        case eta_sfCaK of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCaN [Occ=Once] -> a2_sfCaN;
        };

Data.Semigroup.$fFoldableArg3
  :: forall a1 a2. Data.Semigroup.Arg a2 a1 -> a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [x_sfCaO]
        case x_sfCaO of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCaR [Occ=Once] -> a2_sfCaR;
        };

Data.Semigroup.$fFoldableArg_$cminimum
  :: forall a1 a2.
     GHC.Classes.Ord a2 =>
     Data.Semigroup.Arg a1 a2 -> a2
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sfCaS eta_B1] Data.Semigroup.$fFoldableArg3 eta_B1;

Data.Semigroup.$fFoldableArg_$celem
  :: forall a1 a2.
     GHC.Classes.Eq a2 =>
     a2 -> Data.Semigroup.Arg a1 a2 -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfCaT eta_sfCaU]
        let {
          f_sfCaV [Occ=OnceL!, Dmd=<L,C(U)>] :: a1_afyYK -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCaT eta_sfCaU] \u []
                  GHC.Classes.== $dEq_sfCaT eta_sfCaU; } in
        let {
          sat_sfCb0 [Occ=Once]
            :: Data.Semigroup.Arg a_XfzaV a1_afyYK
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_sfCaV] \r [ds_sfCaW]
                  case ds_sfCaW of {
                    Data.Semigroup.Arg _ [Occ=Dead] a2_sfCaZ [Occ=Once] ->
                        f_sfCaV a2_sfCaZ;
                  };
        } in  sat_sfCb0;

Data.Semigroup.$fFoldableArg_$cfoldl
  :: forall a1 b a2.
     (b -> a2 -> b) -> b -> Data.Semigroup.Arg a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfCb1 z_sfCb2 t1_sfCb3]
        case t1_sfCb3 of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCb6 [Occ=Once] ->
              f_sfCb1 z_sfCb2 a2_sfCb6;
        };

Data.Semigroup.$fFoldableArg_$cfoldl1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Data.Semigroup.Arg a1 a2 -> a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sfCb7 xs_sfCb8]
        case xs_sfCb8 of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCbb [Occ=Once] -> a2_sfCbb;
        };

Data.Semigroup.$fFoldableArg_$cfoldr'
  :: forall a1 a2 b.
     (a2 -> b -> b) -> b -> Data.Semigroup.Arg a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfCbc z0_sfCbd xs_sfCbe]
        case xs_sfCbe of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCbh [Occ=Once] ->
              f_sfCbc a2_sfCbh z0_sfCbd;
        };

Data.Semigroup.$fFoldableArg_$clength
  :: forall a1 a2. Data.Semigroup.Arg a1 a2 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_sfCbi]
        case xs_sfCbi of {
          Data.Semigroup.Arg _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Semigroup.$fFoldableFirst3;
        };

Data.Semigroup.$fFoldableArg_$cnull
  :: forall a1 a2. Data.Semigroup.Arg a1 a2 -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [t1_sfCbm]
        case t1_sfCbm of {
          Data.Semigroup.Arg _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Semigroup.$fFoldableArg1
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Semigroup.Arg a1 a2 -> Data.Semigroup.Internal.Product a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfCbq eta_sfCbr]
        case eta_sfCbr of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCbu [Occ=Once] -> a2_sfCbu;
        };

Data.Semigroup.$fFoldableArg_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. Data.Semigroup.Arg a1 a2 -> [a2]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_sfCbv]
        case eta_sfCbv of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfCby [Occ=Once] ->
              : [a2_sfCby GHC.Types.[]];
        };

Data.Semigroup.$fFoldableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Foldable.Foldable (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableArg_$cfold
                                             Data.Semigroup.$fFoldableArg_$cfoldMap
                                             Data.Semigroup.$fFoldableArg_$cfoldr'
                                             Data.Semigroup.$fFoldableArg_$cfoldr'
                                             Data.Semigroup.$fFoldableArg_$cfoldl
                                             Data.Semigroup.$fFoldableArg_$cfoldl
                                             Data.Semigroup.$fFoldableArg_$cfoldl1
                                             Data.Semigroup.$fFoldableArg_$cfoldl1
                                             Data.Semigroup.$fFoldableArg_$ctoList
                                             Data.Semigroup.$fFoldableArg_$cnull
                                             Data.Semigroup.$fFoldableArg_$clength
                                             Data.Semigroup.$fFoldableArg_$celem
                                             Data.Semigroup.$fFoldableArg_$cminimum
                                             Data.Semigroup.$fFoldableArg_$cminimum
                                             Data.Semigroup.$fFoldableArg2
                                             Data.Semigroup.$fFoldableArg1];

Data.Semigroup.$fTraversableArg_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     GHC.Base.Applicative f =>
     (a2 -> f b)
     -> Data.Semigroup.Arg a1 a2 -> f (Data.Semigroup.Arg a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCbz eta_sfCbA eta1_sfCbB]
        case eta1_sfCbB of {
          Data.Semigroup.Arg x_sfCbD [Occ=OnceL] a2_sfCbE [Occ=Once] ->
              let {
                sat_sfCbH [Occ=Once] :: f_afyWg b_afyWi
                [LclId] =
                    [eta_sfCbA a2_sfCbE] \u [] eta_sfCbA a2_sfCbE; } in
              let {
                sat_sfCbG [Occ=Once]
                  :: b_afyWi -> Data.Semigroup.Arg a_afyW4 b_afyWi
                [LclId] =
                    [x_sfCbD] \r [eta_B1] Data.Semigroup.Arg [x_sfCbD eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfCbz of sat_sfCbF {
                  __DEFAULT -> GHC.Base.fmap sat_sfCbF sat_sfCbG sat_sfCbH;
                };
        };

Data.Semigroup.$fTraversableArg_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     GHC.Base.Applicative f =>
     Data.Semigroup.Arg a1 (f a2) -> f (Data.Semigroup.Arg a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCbI eta_sfCbJ]
        case eta_sfCbJ of {
          Data.Semigroup.Arg x_sfCbL [Occ=OnceL] a2_sfCbM [Occ=Once] ->
              let {
                sat_sfCbO [Occ=Once]
                  :: a1_afyWw -> Data.Semigroup.Arg a_afyW4 a1_afyWw
                [LclId] =
                    [x_sfCbL] \r [eta_B1] Data.Semigroup.Arg [x_sfCbL eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfCbI of sat_sfCbN {
                  __DEFAULT -> GHC.Base.fmap sat_sfCbN sat_sfCbO a2_sfCbM;
                };
        };

Data.Semigroup.$fTraversableArg_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     GHC.Base.Monad m =>
     (a2 -> m b)
     -> Data.Semigroup.Arg a1 a2 -> m (Data.Semigroup.Arg a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCbP eta_sfCbQ eta1_sfCbR]
        case eta1_sfCbR of {
          Data.Semigroup.Arg x_sfCbT [Occ=OnceL] a2_sfCbU [Occ=Once] ->
              let {
                sat_sfCbY [Occ=Once] :: m_afyWH b_afyWJ
                [LclId] =
                    [eta_sfCbQ a2_sfCbU] \u [] eta_sfCbQ a2_sfCbU; } in
              let {
                sat_sfCbX [Occ=Once]
                  :: b_afyWJ -> Data.Semigroup.Arg a_afyW4 b_afyWJ
                [LclId] =
                    [x_sfCbT] \r [eta_B1] Data.Semigroup.Arg [x_sfCbT eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sfCbP of sat_sfCbV {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sfCbV of sat_sfCbW {
                        __DEFAULT -> GHC.Base.fmap sat_sfCbW sat_sfCbX sat_sfCbY;
                      };
                };
        };

Data.Semigroup.$fTraversableArg_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     GHC.Base.Monad m =>
     Data.Semigroup.Arg a1 (m a2) -> m (Data.Semigroup.Arg a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCbZ eta_sfCc0]
        case eta_sfCc0 of {
          Data.Semigroup.Arg x_sfCc2 [Occ=OnceL] a2_sfCc3 [Occ=Once] ->
              let {
                sat_sfCc6 [Occ=Once]
                  :: a1_afyWW -> Data.Semigroup.Arg a_afyW4 a1_afyWW
                [LclId] =
                    [x_sfCc2] \r [eta_B1] Data.Semigroup.Arg [x_sfCc2 eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sfCbZ of sat_sfCc4 {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sfCc4 of sat_sfCc5 {
                        __DEFAULT -> GHC.Base.fmap sat_sfCc5 sat_sfCc6 a2_sfCc3;
                      };
                };
        };

Data.Semigroup.$fTraversableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Traversable.Traversable (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorArg
                                                   Data.Semigroup.$fFoldableArg
                                                   Data.Semigroup.$fTraversableArg_$ctraverse
                                                   Data.Semigroup.$fTraversableArg_$csequenceA
                                                   Data.Semigroup.$fTraversableArg_$cmapM
                                                   Data.Semigroup.$fTraversableArg_$csequence];

Data.Semigroup.$fEqArg_$c==
  :: forall a b.
     GHC.Classes.Eq a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfCc7 ds_sfCc8 ds1_sfCc9]
        case ds_sfCc8 of {
          Data.Semigroup.Arg a1_sfCcb [Occ=Once] _ [Occ=Dead] ->
              case ds1_sfCc9 of {
                Data.Semigroup.Arg b1_sfCce [Occ=Once] _ [Occ=Dead] ->
                    GHC.Classes.== $dEq_sfCc7 a1_sfCcb b1_sfCce;
              };
        };

Data.Semigroup.$fEqArg_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     GHC.Classes.Eq a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfCcg eta_sfCch eta1_sfCci]
        case eta_sfCch of {
          Data.Semigroup.Arg a1_sfCck [Occ=Once] _ [Occ=Dead] ->
              case eta1_sfCci of {
                Data.Semigroup.Arg b1_sfCcn [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.== $dEq_sfCcg a1_sfCck b1_sfCcn of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Semigroup.$fEqArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Arg a b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sfCcq]
        let {
          sat_sfCcs [Occ=Once]
            :: Data.Semigroup.Arg a_afyVO b_afyVP
               -> Data.Semigroup.Arg a_afyVO b_afyVP -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCcq] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fEqArg_$c/= $dEq_sfCcq eta_B2 eta_B1; } in
        let {
          sat_sfCcr [Occ=Once]
            :: Data.Semigroup.Arg a_afyVO b_afyVP
               -> Data.Semigroup.Arg a_afyVO b_afyVP -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCcq] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fEqArg_$c== $dEq_sfCcq eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sfCcr sat_sfCcs];

Data.Semigroup.$fOrdArg_$cmin
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b
     -> Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCct x_sfCcu y_sfCcv]
        case x_sfCcu of wild_sfCcw {
          Data.Semigroup.Arg a1_sfCcx [Occ=Once] _ [Occ=Dead] ->
              case y_sfCcv of wild1_sfCcz {
                Data.Semigroup.Arg b1_sfCcA [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.<= $dOrd_sfCct a1_sfCcx b1_sfCcA of {
                      GHC.Types.False -> wild1_sfCcz;
                      GHC.Types.True -> wild_sfCcw;
                    };
              };
        };

Data.Semigroup.$fOrdArg_$cmax
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b
     -> Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCcD x_sfCcE y_sfCcF]
        case x_sfCcE of wild_sfCcG {
          Data.Semigroup.Arg a1_sfCcH [Occ=Once] _ [Occ=Dead] ->
              case y_sfCcF of wild1_sfCcJ {
                Data.Semigroup.Arg b1_sfCcK [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.>= $dOrd_sfCcD a1_sfCcH b1_sfCcK of {
                      GHC.Types.False -> wild1_sfCcJ;
                      GHC.Types.True -> wild_sfCcG;
                    };
              };
        };

Data.Semigroup.$fOrdArg_$ccompare
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b
     -> Data.Semigroup.Arg a b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCcN ds_sfCcO ds1_sfCcP]
        case ds_sfCcO of {
          Data.Semigroup.Arg a1_sfCcR [Occ=Once] _ [Occ=Dead] ->
              case ds1_sfCcP of {
                Data.Semigroup.Arg b1_sfCcU [Occ=Once] _ [Occ=Dead] ->
                    GHC.Classes.compare $dOrd_sfCcN a1_sfCcR b1_sfCcU;
              };
        };

Data.Semigroup.$fOrdArg_$cp1Ord
  :: forall a b.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Arg a b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCcW]
        let {
          sat_sfCcX [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_afyV3
          [LclId] =
              [$dOrd_sfCcW] \u [] GHC.Classes.$p1Ord $dOrd_sfCcW;
        } in  Data.Semigroup.$fEqArg sat_sfCcX;

Data.Semigroup.$fOrdArg_$c<
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCcY x_sfCcZ y_sfCd0]
        case x_sfCcZ of {
          Data.Semigroup.Arg a1_sfCd2 [Occ=Once] _ [Occ=Dead] ->
              case y_sfCd0 of {
                Data.Semigroup.Arg b1_sfCd5 [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfCcY a1_sfCd2 b1_sfCd5 of {
                      __DEFAULT -> GHC.Types.False [];
                      GHC.Types.LT -> GHC.Types.True [];
                    };
              };
        };

Data.Semigroup.$fOrdArg_$c>
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCd8 x_sfCd9 y_sfCda]
        case x_sfCd9 of {
          Data.Semigroup.Arg a1_sfCdc [Occ=Once] _ [Occ=Dead] ->
              case y_sfCda of {
                Data.Semigroup.Arg b1_sfCdf [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfCd8 a1_sfCdc b1_sfCdf of {
                      __DEFAULT -> GHC.Types.False [];
                      GHC.Types.GT -> GHC.Types.True [];
                    };
              };
        };

Data.Semigroup.$fOrdArg_$c<=
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCdi x_sfCdj y_sfCdk]
        case x_sfCdj of {
          Data.Semigroup.Arg a1_sfCdm [Occ=Once] _ [Occ=Dead] ->
              case y_sfCdk of {
                Data.Semigroup.Arg b1_sfCdp [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfCdi a1_sfCdm b1_sfCdp of {
                      __DEFAULT -> GHC.Types.True [];
                      GHC.Types.GT -> GHC.Types.False [];
                    };
              };
        };

Data.Semigroup.$fOrdArg_$c>=
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCds x_sfCdt y_sfCdu]
        case x_sfCdt of {
          Data.Semigroup.Arg a1_sfCdw [Occ=Once] _ [Occ=Dead] ->
              case y_sfCdu of {
                Data.Semigroup.Arg b1_sfCdz [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfCds a1_sfCdw b1_sfCdz of {
                      __DEFAULT -> GHC.Types.True [];
                      GHC.Types.LT -> GHC.Types.False [];
                    };
              };
        };

Data.Semigroup.$fOrdArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,C(C1(U)),A,C(C1(U)),A,A)>m] =
    [] \r [$dOrd_sfCdC]
        let {
          sat_sfCdK [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$cmin $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdJ [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$cmax $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdI [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c>= $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdH [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c> $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdG [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c<= $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdF [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c< $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdE [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCdC] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$ccompare $dOrd_sfCdC eta_B2 eta_B1; } in
        let {
          sat_sfCdD [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Arg a_afyV3 b_afyV4)
          [LclId] =
              [$dOrd_sfCdC] \u [] Data.Semigroup.$fOrdArg_$cp1Ord $dOrd_sfCdC;
        } in 
          GHC.Classes.C:Ord [sat_sfCdD
                             sat_sfCdE
                             sat_sfCdF
                             sat_sfCdG
                             sat_sfCdH
                             sat_sfCdI
                             sat_sfCdJ
                             sat_sfCdK];

Data.Semigroup.$fBifunctorArg_$cbimap
  :: forall a b c d.
     (a -> b)
     -> (c -> d) -> Data.Semigroup.Arg a c -> Data.Semigroup.Arg b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sfCdL g_sfCdM ds_sfCdN]
        case ds_sfCdN of {
          Data.Semigroup.Arg a1_sfCdP [Occ=Once] b1_sfCdQ [Occ=Once] ->
              let {
                sat_sfCdS [Occ=Once] :: d_afyUz
                [LclId] =
                    [g_sfCdM b1_sfCdQ] \u [] g_sfCdM b1_sfCdQ; } in
              let {
                sat_sfCdR [Occ=Once] :: b_afyUx
                [LclId] =
                    [f_sfCdL a1_sfCdP] \u [] f_sfCdL a1_sfCdP;
              } in  Data.Semigroup.Arg [sat_sfCdR sat_sfCdS];
        };

Data.Semigroup.$fBifunctorArg_$cfirst
  :: forall a b c.
     (a -> b) -> Data.Semigroup.Arg a c -> Data.Semigroup.Arg b c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sfCdT ds_sfCdU]
        case ds_sfCdU of {
          Data.Semigroup.Arg a1_sfCdW [Occ=Once] b1_sfCdX [Occ=Once] ->
              let {
                sat_sfCdY [Occ=Once] :: b_afyUH
                [LclId] =
                    [f_sfCdT a1_sfCdW] \u [] f_sfCdT a1_sfCdW;
              } in  Data.Semigroup.Arg [sat_sfCdY b1_sfCdX];
        };

Data.Semigroup.$fBifunctorArg_$csecond
  :: forall b c a.
     (b -> c) -> Data.Semigroup.Arg a b -> Data.Semigroup.Arg a c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [g_sfCdZ ds_sfCe0]
        case ds_sfCe0 of {
          Data.Semigroup.Arg a1_sfCe2 [Occ=Once] b1_sfCe3 [Occ=Once] ->
              let {
                sat_sfCe4 [Occ=Once] :: c_afyUT
                [LclId] =
                    [g_sfCdZ b1_sfCe3] \u [] g_sfCdZ b1_sfCe3;
              } in  Data.Semigroup.Arg [a1_sfCe2 sat_sfCe4];
        };

Data.Semigroup.$fBifunctorArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor Data.Semigroup.Arg
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Semigroup.$fBifunctorArg_$cbimap
                                               Data.Semigroup.$fBifunctorArg_$cfirst
                                               Data.Semigroup.$fBifunctorArg_$csecond];

Data.Semigroup.$fBifoldableArg_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> Data.Semigroup.Arg a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCe5 eta_sfCe6 eta1_sfCe7 eta2_sfCe8]
        case eta2_sfCe8 of {
          Data.Semigroup.Arg a1_sfCea [Occ=Once] b1_sfCeb [Occ=Once] ->
              let {
                sat_sfCee [Occ=Once] :: m_afyTV
                [LclId] =
                    [eta1_sfCe7 b1_sfCeb] \u [] eta1_sfCe7 b1_sfCeb; } in
              let {
                sat_sfCed [Occ=Once] :: m_afyTV
                [LclId] =
                    [eta_sfCe6 a1_sfCea] \u [] eta_sfCe6 a1_sfCea;
              } in 
                case GHC.Base.$p1Monoid $dMonoid_sfCe5 of sat_sfCec {
                  __DEFAULT -> GHC.Base.<> sat_sfCec sat_sfCed sat_sfCee;
                };
        };

Data.Semigroup.$fBifoldableArg_$cbifold
  :: forall m. GHC.Base.Monoid m => Data.Semigroup.Arg m m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCef eta_sfCeg]
        case eta_sfCeg of {
          Data.Semigroup.Arg a_sfCei [Occ=Once] b_sfCej [Occ=Once] ->
              case GHC.Base.$p1Monoid $dMonoid_sfCef of sat_sfCek {
                __DEFAULT -> GHC.Base.<> sat_sfCek a_sfCei b_sfCej;
              };
        };

Data.Semigroup.$fBifoldableArg_$cbifoldr
  :: forall a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> Data.Semigroup.Arg a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfCel g_sfCem z_sfCen t_sfCeo]
        case t_sfCeo of {
          Data.Semigroup.Arg a1_sfCeq [Occ=Once] b1_sfCer [Occ=Once] ->
              let {
                sat_sfCes [Occ=Once] :: c_afyU7
                [LclId] =
                    [g_sfCem z_sfCen b1_sfCer] \u [] g_sfCem b1_sfCer z_sfCen;
              } in  f_sfCel a1_sfCeq sat_sfCes;
        };

Data.Semigroup.$fBifoldableArg_$cbifoldl
  :: forall c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> Data.Semigroup.Arg a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfCet g_sfCeu z_sfCev t_sfCew]
        case t_sfCew of {
          Data.Semigroup.Arg a1_sfCey [Occ=Once] b1_sfCez [Occ=Once] ->
              let {
                sat_sfCeA [Occ=Once] :: c_afyUi
                [LclId] =
                    [f_sfCet z_sfCev a1_sfCey] \u [] f_sfCet z_sfCev a1_sfCey;
              } in  g_sfCeu sat_sfCeA b1_sfCez;
        };

Data.Semigroup.$fBifoldableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable Data.Semigroup.Arg
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Semigroup.$fBifoldableArg_$cbifold
                                                 Data.Semigroup.$fBifoldableArg_$cbifoldMap
                                                 Data.Semigroup.$fBifoldableArg_$cbifoldr
                                                 Data.Semigroup.$fBifoldableArg_$cbifoldl];

Data.Semigroup.$w$cbitraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> a -> b -> f (Data.Semigroup.Arg c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCeB w1_sfCeC w2_sfCeD ww_sfCeE ww1_sfCeF]
        let {
          sat_sfCeJ [Occ=Once] :: f_sfBpj d_sfBpn
          [LclId] =
              [w2_sfCeD ww1_sfCeF] \u [] w2_sfCeD ww1_sfCeF; } in
        let {
          sat_sfCeI [Occ=Once]
            :: f_sfBpj (d_sfBpn -> Data.Semigroup.Arg c_sfBpl d_sfBpn)
          [LclId] =
              [w_sfCeB w1_sfCeC ww_sfCeE] \u []
                  let {
                    sat_sfCeH [Occ=Once] :: f_sfBpj c_sfBpl
                    [LclId] =
                        [w1_sfCeC ww_sfCeE] \u [] w1_sfCeC ww_sfCeE;
                  } in 
                    case GHC.Base.$p1Applicative w_sfCeB of sat_sfCeG {
                      __DEFAULT -> GHC.Base.fmap sat_sfCeG Data.Semigroup.Arg sat_sfCeH;
                    };
        } in  GHC.Base.<*> w_sfCeB sat_sfCeI sat_sfCeJ;

Data.Semigroup.$fBitraversableArg_$cbitraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d)
     -> Data.Semigroup.Arg a b
     -> f (Data.Semigroup.Arg c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sfCeK w1_sfCeL w2_sfCeM w3_sfCeN]
        case w3_sfCeN of {
          Data.Semigroup.Arg ww1_sfCeP [Occ=Once] ww2_sfCeQ [Occ=Once] ->
              Data.Semigroup.$w$cbitraverse
                  w_sfCeK w1_sfCeL w2_sfCeM ww1_sfCeP ww2_sfCeQ;
        };

Data.Semigroup.$fBitraversableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable Data.Semigroup.Arg
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Semigroup.$fBifunctorArg
                                                       Data.Semigroup.$fBifoldableArg
                                                       Data.Semigroup.$fBitraversableArg_$cbitraverse];

Data.Semigroup.$fSemigroupFirst_$cstimes
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfCeR eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfCeR eta_B2 eta_B1;

Data.Semigroup.$fSemigroupFirst_$c<>
  :: forall a.
     Data.Semigroup.First a
     -> Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfCeS ds_sfCeT] a1_sfCeS;

Data.Semigroup.$fSemigroupFirst_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Semigroup.First a)
     -> Data.Semigroup.First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfCeU]
        case ds_sfCeU of {
          GHC.Base.:| a1_sfCeW [Occ=Once] as_sfCeX [Occ=Once] ->
              case as_sfCeX of { __DEFAULT -> a1_sfCeW; };
        };

Data.Semigroup.$fSemigroupFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Semigroup.First a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Semigroup.$fSemigroupFirst_$c<>
                                         Data.Semigroup.$fSemigroupFirst_$csconcat
                                         Data.Semigroup.$fSemigroupFirst_$cstimes];

Data.Semigroup.$fFunctorFirst2
  :: forall a b. (a -> b) -> Data.Semigroup.First a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfCeZ ds_sfCf0] f_sfCeZ ds_sfCf0;

Data.Semigroup.$fFunctorFirst1
  :: forall b a. a -> Data.Semigroup.First b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sfCf1 ds_sfCf2] x_sfCf1;

Data.Semigroup.$fFunctorFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorFirst2
                                       Data.Semigroup.$fFunctorFirst1];

Data.Semigroup.$fFoldableFirst_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.First a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCf3 f_sfCf4 ds_sfCf5] f_sfCf4 ds_sfCf5;

Data.Semigroup.$fFoldableFirst5
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.First m -> Data.Semigroup.First m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCf6 ds_sfCf7] ds_sfCf7;

Data.Semigroup.$fFoldableFirst1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfCf8 eta_sfCf9] eta_sfCf9;

Data.Semigroup.$fFoldableFirst2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCfa x_sfCfb] x_sfCfb;

Data.Semigroup.$fFoldableFirst_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.First a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfCfc eta_sfCfd]
        let {
          f_sfCfe [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afyQr -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCfc eta_sfCfd] \u []
                  GHC.Classes.== $dEq_sfCfc eta_sfCfd; } in
        let {
          sat_sfCfg [Occ=OnceT[0]]
            :: Data.Semigroup.First a_afyQr -> GHC.Types.Bool
          [LclId] =
              [f_sfCfe] \r [ds_sfCff] f_sfCfe ds_sfCff;
        } in  sat_sfCfg;

Data.Semigroup.$fFoldableFirst_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfCfh z_sfCfi t1_sfCfj] f_sfCfh z_sfCfi t1_sfCfj;

Data.Semigroup.$fFoldableFirst4
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfCfk xs_sfCfl] xs_sfCfl;

Data.Semigroup.$fFoldableFirst_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfCfm z0_sfCfn xs_sfCfo] f_sfCfm xs_sfCfo z0_sfCfn;

Data.Semigroup.$fFoldableFirst_$clength
  :: forall a. Data.Semigroup.First a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfCfp] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableFirst_$cnull
  :: forall a. Data.Semigroup.First a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfCfq] GHC.Types.False [];

Data.Semigroup.$fFoldableFirst_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.First a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfCfr] : [eta_sfCfr GHC.Types.[]];

Data.Semigroup.$fFoldableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.First
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableFirst5
                                             Data.Semigroup.$fFoldableFirst_$cfoldMap
                                             Data.Semigroup.$fFoldableFirst_$cfoldr'
                                             Data.Semigroup.$fFoldableFirst_$cfoldr'
                                             Data.Semigroup.$fFoldableFirst_$cfoldl
                                             Data.Semigroup.$fFoldableFirst_$cfoldl
                                             Data.Semigroup.$fFoldableFirst4
                                             Data.Semigroup.$fFoldableFirst4
                                             Data.Semigroup.$fFoldableFirst_$ctoList
                                             Data.Semigroup.$fFoldableFirst_$cnull
                                             Data.Semigroup.$fFoldableFirst_$clength
                                             Data.Semigroup.$fFoldableFirst_$celem
                                             Data.Semigroup.$fFoldableFirst2
                                             Data.Semigroup.$fFoldableFirst2
                                             Data.Semigroup.$fFoldableFirst1
                                             Data.Semigroup.$fFoldableFirst1];

Data.Semigroup.$fTraversableFirst_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.First a -> f (Data.Semigroup.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCfs eta_sfCft eta1_sfCfu]
        let {
          sat_sfCfw [Occ=Once] :: f_afyNZ b_afyO1
          [LclId] =
              [eta_sfCft eta1_sfCfu] \u [] eta_sfCft eta1_sfCfu;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfCfs of sat_sfCfv {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfCfv Data.Semigroup.$fApplicativeFirst3 sat_sfCfw;
          };

Data.Semigroup.$fTraversableFirst_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.First (f a) -> f (Data.Semigroup.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCfx eta_sfCfy]
        case GHC.Base.$p1Applicative $dApplicative_sfCfx of sat_sfCfz {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfCfz Data.Semigroup.$fApplicativeFirst3 eta_sfCfy;
        };

Data.Semigroup.$fTraversableFirst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.First a -> m (Data.Semigroup.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCfA eta_sfCfB eta1_sfCfC]
        let {
          sat_sfCfF [Occ=Once] :: m_afyOp b_afyOr
          [LclId] =
              [eta_sfCfB eta1_sfCfC] \u [] eta_sfCfB eta1_sfCfC;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfCfA of sat_sfCfD {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfCfD of sat_sfCfE {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfCfE Data.Semigroup.$fApplicativeFirst3 sat_sfCfF;
                };
          };

Data.Semigroup.$fTraversableFirst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.First (m a) -> m (Data.Semigroup.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCfG eta_sfCfH]
        case GHC.Base.$p1Monad $dMonad_sfCfG of sat_sfCfI {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfCfI of sat_sfCfJ {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfCfJ Data.Semigroup.$fApplicativeFirst3 eta_sfCfH;
              };
        };

Data.Semigroup.$fTraversableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorFirst
                                                   Data.Semigroup.$fFoldableFirst
                                                   Data.Semigroup.$fTraversableFirst_$ctraverse
                                                   Data.Semigroup.$fTraversableFirst_$csequenceA
                                                   Data.Semigroup.$fTraversableFirst_$cmapM
                                                   Data.Semigroup.$fTraversableFirst_$csequence];

Data.Semigroup.$fApplicativeFirst_$c<*
  :: forall a b.
     Data.Semigroup.First a
     -> Data.Semigroup.First b -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfCfK ds_sfCfL] a1_sfCfK;

Data.Semigroup.$fApplicativeFirst_$c*>
  :: forall a b.
     Data.Semigroup.First a
     -> Data.Semigroup.First b -> Data.Semigroup.First b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfCfM a1_sfCfN] a1_sfCfN;

Data.Semigroup.$fApplicativeFirst2
  :: forall a b.
     Data.Semigroup.First (a -> b) -> Data.Semigroup.First (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfCfO] v_sfCfO;

Data.Semigroup.$fApplicativeFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorFirst
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeFirst2
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeFirst_$c*>
                                           Data.Semigroup.$fApplicativeFirst_$c<*];

Data.Semigroup.$fMonadFirst_$c>>=
  :: forall a b.
     Data.Semigroup.First a
     -> (a -> Data.Semigroup.First b) -> Data.Semigroup.First b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfCfP f_sfCfQ] f_sfCfQ ds_sfCfP;

lvl4_rfC6a :: forall a. [GHC.Types.Char] -> Data.Semigroup.First a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfCfR] GHC.Err.errorWithoutStackTrace eta_sfCfR;

Data.Semigroup.$fMonadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeFirst
                                     Data.Semigroup.$fMonadFirst_$c>>=
                                     Data.Semigroup.$fApplicativeFirst_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl4_rfC6a];

Data.Semigroup.$fSemigroupLast_$cstimes
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfCfS eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfCfS eta_B2 eta_B1;

Data.Semigroup.$fSemigroupLast_$c<>
  :: forall a.
     Data.Semigroup.Last a
     -> Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfCfT b_sfCfU] b_sfCfU;

Data.Semigroup.$fSemigroupLast1 [Occ=LoopBreaker]
  :: forall a.
     Data.Semigroup.Last a
     -> [Data.Semigroup.Last a] -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sfCfV ds1_sfCfW]
        case ds1_sfCfW of {
          [] -> b_sfCfV;
          : c_sfCfY [Occ=Once] cs_sfCfZ [Occ=Once] ->
              Data.Semigroup.$fSemigroupLast1 c_sfCfY cs_sfCfZ;
        };

Data.Semigroup.$fSemigroupLast_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Semigroup.Last a) -> Data.Semigroup.Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfCg0]
        case ds_sfCg0 of {
          GHC.Base.:| a1_sfCg2 [Occ=Once] as_sfCg3 [Occ=Once] ->
              Data.Semigroup.$fSemigroupLast1 a1_sfCg2 as_sfCg3;
        };

Data.Semigroup.$fSemigroupLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Semigroup.Last a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Semigroup.$fSemigroupLast_$c<>
                                         Data.Semigroup.$fSemigroupLast_$csconcat
                                         Data.Semigroup.$fSemigroupLast_$cstimes];

Data.Semigroup.$fFunctorLast1
  :: forall a b. a -> Data.Semigroup.Last b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfCg4 ds_sfCg5] a1_sfCg4;

Data.Semigroup.$fFunctorLast2
  :: forall a b. (a -> b) -> Data.Semigroup.Last a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfCg6 ds_sfCg7] f_sfCg6 ds_sfCg7;

Data.Semigroup.$fFunctorLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorLast2
                                       Data.Semigroup.$fFunctorLast1];

Data.Semigroup.$fFoldableLast_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Last a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCg8 f_sfCg9 ds_sfCga] f_sfCg9 ds_sfCga;

Data.Semigroup.$fFoldableLast4
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.Last m -> Data.Semigroup.Last m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCgb ds_sfCgc] ds_sfCgc;

Data.Semigroup.$fFoldableLast1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfCgd eta_sfCge] eta_sfCge;

Data.Semigroup.$fFoldableLast2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCgf x_sfCgg] x_sfCgg;

Data.Semigroup.$fFoldableLast_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Last a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfCgh eta_sfCgi]
        let {
          f_sfCgj [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afyJq -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCgh eta_sfCgi] \u []
                  GHC.Classes.== $dEq_sfCgh eta_sfCgi; } in
        let {
          sat_sfCgl [Occ=OnceT[0]]
            :: Data.Semigroup.Last a_afyJq -> GHC.Types.Bool
          [LclId] =
              [f_sfCgj] \r [ds_sfCgk] f_sfCgj ds_sfCgk;
        } in  sat_sfCgl;

Data.Semigroup.$fFoldableLast_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfCgm z_sfCgn t1_sfCgo] f_sfCgm z_sfCgn t1_sfCgo;

Data.Semigroup.$fFoldableLast3
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfCgp xs_sfCgq] xs_sfCgq;

Data.Semigroup.$fFoldableLast_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfCgr z0_sfCgs xs_sfCgt] f_sfCgr xs_sfCgt z0_sfCgs;

Data.Semigroup.$fFoldableLast_$clength
  :: forall a. Data.Semigroup.Last a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfCgu] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableLast_$cnull
  :: forall a. Data.Semigroup.Last a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfCgv] GHC.Types.False [];

Data.Semigroup.$fFoldableLast_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Last a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfCgw] : [eta_sfCgw GHC.Types.[]];

Data.Semigroup.$fFoldableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableLast4
                                             Data.Semigroup.$fFoldableLast_$cfoldMap
                                             Data.Semigroup.$fFoldableLast_$cfoldr'
                                             Data.Semigroup.$fFoldableLast_$cfoldr'
                                             Data.Semigroup.$fFoldableLast_$cfoldl
                                             Data.Semigroup.$fFoldableLast_$cfoldl
                                             Data.Semigroup.$fFoldableLast3
                                             Data.Semigroup.$fFoldableLast3
                                             Data.Semigroup.$fFoldableLast_$ctoList
                                             Data.Semigroup.$fFoldableLast_$cnull
                                             Data.Semigroup.$fFoldableLast_$clength
                                             Data.Semigroup.$fFoldableLast_$celem
                                             Data.Semigroup.$fFoldableLast2
                                             Data.Semigroup.$fFoldableLast2
                                             Data.Semigroup.$fFoldableLast1
                                             Data.Semigroup.$fFoldableLast1];

Data.Semigroup.$fTraversableLast_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.Last a -> f (Data.Semigroup.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCgx eta_sfCgy eta1_sfCgz]
        let {
          sat_sfCgB [Occ=Once] :: f_afyGY b_afyH0
          [LclId] =
              [eta_sfCgy eta1_sfCgz] \u [] eta_sfCgy eta1_sfCgz;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfCgx of sat_sfCgA {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfCgA Data.Semigroup.$fApplicativeFirst3 sat_sfCgB;
          };

Data.Semigroup.$fTraversableLast_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Last (f a) -> f (Data.Semigroup.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCgC eta_sfCgD]
        case GHC.Base.$p1Applicative $dApplicative_sfCgC of sat_sfCgE {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfCgE Data.Semigroup.$fApplicativeFirst3 eta_sfCgD;
        };

Data.Semigroup.$fTraversableLast_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.Last a -> m (Data.Semigroup.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCgF eta_sfCgG eta1_sfCgH]
        let {
          sat_sfCgK [Occ=Once] :: m_afyHo b_afyHq
          [LclId] =
              [eta_sfCgG eta1_sfCgH] \u [] eta_sfCgG eta1_sfCgH;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfCgF of sat_sfCgI {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfCgI of sat_sfCgJ {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfCgJ Data.Semigroup.$fApplicativeFirst3 sat_sfCgK;
                };
          };

Data.Semigroup.$fTraversableLast_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Last (m a) -> m (Data.Semigroup.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCgL eta_sfCgM]
        case GHC.Base.$p1Monad $dMonad_sfCgL of sat_sfCgN {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfCgN of sat_sfCgO {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfCgO Data.Semigroup.$fApplicativeFirst3 eta_sfCgM;
              };
        };

Data.Semigroup.$fTraversableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorLast
                                                   Data.Semigroup.$fFoldableLast
                                                   Data.Semigroup.$fTraversableLast_$ctraverse
                                                   Data.Semigroup.$fTraversableLast_$csequenceA
                                                   Data.Semigroup.$fTraversableLast_$cmapM
                                                   Data.Semigroup.$fTraversableLast_$csequence];

Data.Semigroup.$fApplicativeLast_$c<*
  :: forall a b.
     Data.Semigroup.Last a
     -> Data.Semigroup.Last b -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfCgP ds_sfCgQ] a1_sfCgP;

Data.Semigroup.$fApplicativeLast_$c*>
  :: forall a b.
     Data.Semigroup.Last a
     -> Data.Semigroup.Last b -> Data.Semigroup.Last b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfCgR a1_sfCgS] a1_sfCgS;

Data.Semigroup.$fApplicativeLast1
  :: forall a b.
     Data.Semigroup.Last (a -> b) -> Data.Semigroup.Last (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfCgT] v_sfCgT;

Data.Semigroup.$fApplicativeLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorLast
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeLast1
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeLast_$c*>
                                           Data.Semigroup.$fApplicativeLast_$c<*];

Data.Semigroup.$fMonadLast_$c>>=
  :: forall a b.
     Data.Semigroup.Last a
     -> (a -> Data.Semigroup.Last b) -> Data.Semigroup.Last b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfCgU f_sfCgV] f_sfCgV ds_sfCgU;

lvl5_rfC6b :: forall a. [GHC.Types.Char] -> Data.Semigroup.Last a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfCgW] GHC.Err.errorWithoutStackTrace eta_sfCgW;

Data.Semigroup.$fMonadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeLast
                                     Data.Semigroup.$fMonadLast_$c>>=
                                     Data.Semigroup.$fApplicativeLast_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl5_rfC6b];

Data.Semigroup.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.WrappedMonoid m
     -> [Data.Semigroup.WrappedMonoid m]
     -> Data.Semigroup.WrappedMonoid m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfCgX ww_sfCgY ww1_sfCgZ]
        let {
          go_sfCh0 [Occ=LoopBreaker]
            :: Data.Semigroup.WrappedMonoid m_sfBpD
               -> [Data.Semigroup.WrappedMonoid m_sfBpD]
               -> Data.Semigroup.WrappedMonoid m_sfBpD
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfCgX go_sfCh0] \r [b_sfCh1 ds1_sfCh2]
                  case ds1_sfCh2 of {
                    [] -> b_sfCh1;
                    : c_sfCh4 [Occ=Once] cs_sfCh5 [Occ=Once] ->
                        let {
                          sat_sfCh6 [Occ=Once] :: m_sfBpD
                          [LclId] =
                              [go_sfCh0 c_sfCh4 cs_sfCh5] \u [] go_sfCh0 c_sfCh4 cs_sfCh5;
                        } in  GHC.Base.mappend w_sfCgX b_sfCh1 sat_sfCh6;
                  };
        } in  go_sfCh0 ww_sfCgY ww1_sfCgZ;

Data.Semigroup.$fSemigroupWrappedMonoid_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Base.NonEmpty (Data.Semigroup.WrappedMonoid m)
     -> Data.Semigroup.WrappedMonoid m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfCh7 w1_sfCh8]
        case w1_sfCh8 of {
          GHC.Base.:| ww1_sfCha [Occ=Once] ww2_sfChb [Occ=Once] ->
              Data.Semigroup.$w$csconcat3 w_sfCh7 ww1_sfCha ww2_sfChb;
        };

Data.Semigroup.$fSemigroupWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,U,A)>m] =
    [] \r [$dMonoid_sfChc]
        let {
          sat_sfChf [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.WrappedMonoid m_afyEA
               -> Data.Semigroup.WrappedMonoid m_afyEA
          [LclId] =
              [$dMonoid_sfChc] \r [eta_B1]
                  Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes
                      $dMonoid_sfChc eta_B1; } in
        let {
          sat_sfChe [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.WrappedMonoid m_afyEA)
               -> Data.Semigroup.WrappedMonoid m_afyEA
          [LclId] =
              [$dMonoid_sfChc] \r [eta_B1]
                  Data.Semigroup.$fSemigroupWrappedMonoid_$csconcat
                      $dMonoid_sfChc eta_B1; } in
        let {
          sat_sfChd [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyEA
               -> Data.Semigroup.WrappedMonoid m_afyEA
               -> Data.Semigroup.WrappedMonoid m_afyEA
          [LclId] =
              [$dMonoid_sfChc] \u [] GHC.Base.mappend $dMonoid_sfChc;
        } in  GHC.Base.C:Semigroup [sat_sfChd sat_sfChe sat_sfChf];
Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes [Occ=LoopBreaker]
  :: forall m.
     GHC.Base.Monoid m =>
     forall b.
     GHC.Real.Integral b =>
     b
     -> Data.Semigroup.WrappedMonoid m -> Data.Semigroup.WrappedMonoid m
[GblId, Arity=2, Str=<L,U(A,A,U,A)><L,U>, Unf=OtherCon []] =
    [] \r [$dMonoid_sfChg $dIntegral_sfChh]
        let {
          sat_sfChi [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m_afyEA)
          [LclId] =
              [$dMonoid_sfChg] \u []
                  Data.Semigroup.$fSemigroupWrappedMonoid $dMonoid_sfChg;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_sfChh sat_sfChi;

Data.Semigroup.$fMonoidWrappedMonoid_$cmconcat
  :: forall m.
     GHC.Base.Monoid m =>
     [Data.Semigroup.WrappedMonoid m] -> Data.Semigroup.WrappedMonoid m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfChj eta_sfChk]
        let {
          z_sfChl [Occ=OnceL] :: m_afyEb
          [LclId] =
              [$dMonoid_sfChj] \u [] GHC.Base.mempty $dMonoid_sfChj; } in
        let {
          go_sfChm [Occ=LoopBreaker]
            :: [Data.Semigroup.WrappedMonoid m_afyEb]
               -> Data.Semigroup.WrappedMonoid m_afyEb
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_sfChj z_sfChl go_sfChm] \r [ds_sfChn]
                  case ds_sfChn of {
                    [] -> z_sfChl;
                    : y_sfChp [Occ=Once] ys_sfChq [Occ=Once] ->
                        let {
                          sat_sfChr [Occ=Once] :: m_afyEb
                          [LclId] =
                              [go_sfChm ys_sfChq] \u [] go_sfChm ys_sfChq;
                        } in  GHC.Base.mappend $dMonoid_sfChj y_sfChp sat_sfChr;
                  };
        } in  go_sfChm eta_sfChk;

Data.Semigroup.$fMonoidWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Base.Monoid (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(A,U,U,A)>m] =
    [] \r [$dMonoid_sfChs]
        let {
          sat_sfChw [Occ=Once]
            :: [Data.Semigroup.WrappedMonoid m_afyEb]
               -> Data.Semigroup.WrappedMonoid m_afyEb
          [LclId] =
              [$dMonoid_sfChs] \r [eta_B1]
                  Data.Semigroup.$fMonoidWrappedMonoid_$cmconcat
                      $dMonoid_sfChs eta_B1; } in
        let {
          sat_sfChv [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyEb
               -> Data.Semigroup.WrappedMonoid m_afyEb
               -> Data.Semigroup.WrappedMonoid m_afyEb
          [LclId] =
              [$dMonoid_sfChs] \u [] GHC.Base.mappend $dMonoid_sfChs; } in
        let {
          sat_sfChu [Occ=Once] :: Data.Semigroup.WrappedMonoid m_afyEb
          [LclId] =
              [$dMonoid_sfChs] \u [] GHC.Base.mempty $dMonoid_sfChs; } in
        let {
          sat_sfCht [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m_afyEb)
          [LclId] =
              [$dMonoid_sfChs] \u []
                  Data.Semigroup.$fSemigroupWrappedMonoid $dMonoid_sfChs;
        } in  GHC.Base.C:Monoid [sat_sfCht sat_sfChu sat_sfChv sat_sfChw];

Data.Semigroup.$fFunctorOption1
  :: forall a b. a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sfChx ds1_sfChy]
        case ds1_sfChy of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Base.Just [x_sfChx];
        };

Data.Semigroup.$fFunctorOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       Data.Semigroup.$fFunctorOption1];

Data.Semigroup.$fApplicativeOption_$c*>
  :: forall a b.
     Data.Semigroup.Option a
     -> Data.Semigroup.Option b -> Data.Semigroup.Option b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfChB ds1_sfChC]
        case ds_sfChB of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> ds1_sfChC;
        };

Data.Semigroup.$fApplicativeOption1
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfChF ds1_sfChG]
        case ds_sfChF of wild_sfChH {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] ->
              case ds1_sfChG of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just _ [Occ=Dead] -> wild_sfChH;
              };
        };

Data.Semigroup.$fApplicativeOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorOption
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           Data.Semigroup.$fApplicativeOption_$c*>
                                           Data.Semigroup.$fApplicativeOption1];

Data.Semigroup.$fMonadOption_$c>>=
  :: forall a b.
     Data.Semigroup.Option a
     -> (a -> Data.Semigroup.Option b) -> Data.Semigroup.Option b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfChL k_sfChM]
        case ds_sfChL of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_sfChO [Occ=Once] -> k_sfChM a1_sfChO;
        };

lvl6_rfC6c :: forall a. [GHC.Types.Char] -> Data.Semigroup.Option a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfChP] GHC.Err.errorWithoutStackTrace eta_sfChP;

Data.Semigroup.$fMonadOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeOption
                                     Data.Semigroup.$fMonadOption_$c>>=
                                     Data.Semigroup.$fApplicativeOption_$c*>
                                     GHC.Base.Just
                                     lvl6_rfC6c];

Data.Semigroup.$fAlternativeOption_$c<|>
  :: forall a.
     Data.Semigroup.Option a
     -> Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfChQ b_sfChR]
        case ds_sfChQ of wild_sfChS {
          GHC.Base.Nothing -> b_sfChR;
          GHC.Base.Just _ [Occ=Dead] -> wild_sfChS;
        };

Data.Semigroup.$fAlternativeOption_$csome
  :: forall a. Data.Semigroup.Option a -> Data.Semigroup.Option [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sfChU]
        let {
          some_v_sfChV [Occ=LoopBreaker] :: GHC.Base.Maybe [a_afyAE]
          [LclId] =
              [v_sfChU some_v_sfChV] \u []
                  case v_sfChU of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sfChX [Occ=Once*] ->
                        case some_v_sfChV of {
                          GHC.Base.Nothing ->
                              let {
                                sat_sfChZ [Occ=Once] :: [a_afyAE]
                                [LclId] =
                                    CCCS :! [x_sfChX GHC.Types.[]];
                              } in  GHC.Base.Just [sat_sfChZ];
                          GHC.Base.Just ipv_sfCi0 [Occ=Once] ->
                              let {
                                sat_sfCi1 [Occ=Once] :: [a_afyAE]
                                [LclId] =
                                    CCCS :! [x_sfChX ipv_sfCi0];
                              } in  GHC.Base.Just [sat_sfCi1];
                        };
                  };
        } in  some_v_sfChV;

Data.Semigroup.$fAlternativeOption1 :: forall a. GHC.Base.Maybe [a]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [GHC.Types.[]];

Data.Semigroup.$fAlternativeOption_$cmany
  :: forall a. Data.Semigroup.Option a -> Data.Semigroup.Option [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sfCi2]
        let {
          many_v_sfCi3 [Occ=LoopBreaker] :: Data.Semigroup.Option [a_afyAM]
          [LclId] =
              [v_sfCi2 many_v_sfCi3] \u []
                  case v_sfCi2 of {
                    GHC.Base.Nothing -> Data.Semigroup.$fAlternativeOption1;
                    GHC.Base.Just x_sfCi5 [Occ=Once] ->
                        case many_v_sfCi3 of {
                          GHC.Base.Nothing -> Data.Semigroup.$fAlternativeOption1;
                          GHC.Base.Just y_sfCi7 [Occ=Once] ->
                              let {
                                sat_sfCi8 [Occ=Once] :: [a_afyAM]
                                [LclId] =
                                    CCCS :! [x_sfCi5 y_sfCi7];
                              } in  GHC.Base.Just [sat_sfCi8];
                        };
                  };
        } in  many_v_sfCi3;

Data.Semigroup.$fAlternativeOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Data.Semigroup.$fApplicativeOption
                                           GHC.Base.Nothing
                                           Data.Semigroup.$fAlternativeOption_$c<|>
                                           Data.Semigroup.$fAlternativeOption_$csome
                                           Data.Semigroup.$fAlternativeOption_$cmany];

Data.Semigroup.$fMonadPlusOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Data.Semigroup.$fAlternativeOption
                                         Data.Semigroup.$fMonadOption
                                         GHC.Base.Nothing
                                         Data.Semigroup.$fAlternativeOption_$c<|>];

Data.Semigroup.$fFoldableOption_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Option a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCi9 f_sfCia ds_sfCib]
        case ds_sfCib of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_sfCi9;
          GHC.Base.Just m1_sfCid [Occ=Once] -> f_sfCia m1_sfCid;
        };

Data.Semigroup.$fFoldableOption_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Semigroup.Option m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfCie ds_sfCif]
        case ds_sfCif of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_sfCie;
          GHC.Base.Just m1_sfCih [Occ=Once] -> m1_sfCih;
        };

Data.Semigroup.$fFoldableOption2
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Option a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfCii ds_sfCij]
        case ds_sfCij of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_sfCii;
          GHC.Base.Just m_sfCil [Occ=Once] -> m_sfCil;
        };

lvl7_rfC6d :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Semigroup.$fFoldableOption4 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl7_rfC6d of sat_sfCim {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfCim;
        };

Data.Semigroup.$fFoldableOption3
  :: forall a. Data.Semigroup.Option a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCin]
        case x_sfCin of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption4;
          GHC.Base.Just v_sfCip [Occ=Once] -> v_sfCip;
        };

Data.Semigroup.$fFoldableOption_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sfCiq eta_B1] Data.Semigroup.$fFoldableOption3 eta_B1;

lvl8_rfC6e :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Semigroup.$fFoldableOption6 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl8_rfC6e of sat_sfCir {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfCir;
        };

Data.Semigroup.$fFoldableOption5
  :: forall a. Data.Semigroup.Option a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCis]
        case x_sfCis of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption6;
          GHC.Base.Just v_sfCiu [Occ=Once] -> v_sfCiu;
        };

Data.Semigroup.$fFoldableOption_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sfCiv eta_B1] Data.Semigroup.$fFoldableOption5 eta_B1;

Data.Semigroup.$fFoldableOption_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Option a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfCiw eta_sfCix]
        let {
          f_sfCiy [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afyyC -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCiw eta_sfCix] \u []
                  GHC.Classes.== $dEq_sfCiw eta_sfCix; } in
        let {
          sat_sfCiC [Occ=Once]
            :: Data.Semigroup.Option a_afyyC -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_sfCiy] \r [ds_sfCiz]
                  case ds_sfCiz of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just m_sfCiB [Occ=Once] -> f_sfCiy m_sfCiB;
                  };
        } in  sat_sfCiC;

Data.Semigroup.$fFoldableOption7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Semigroup.$fFoldableOption_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfCiD z_sfCiE t1_sfCiF]
        case t1_sfCiF of {
          GHC.Base.Nothing -> z_sfCiE;
          GHC.Base.Just m_sfCiH [Occ=Once] -> f_sfCiD z_sfCiE m_sfCiH;
        };

lvl9_rfC6f :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Semigroup.$fFoldableOption8 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl9_rfC6f of sat_sfCiI {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfCiI;
        };

Data.Semigroup.$fFoldableOption_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sfCiJ xs_sfCiK]
        case xs_sfCiK of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption8;
          GHC.Base.Just m_sfCiM [Occ=Once] -> m_sfCiM;
        };

Data.Semigroup.$fFoldableOption_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfCiN z0_sfCiO xs_sfCiP]
        case xs_sfCiP of {
          GHC.Base.Nothing -> z0_sfCiO;
          GHC.Base.Just m_sfCiR [Occ=Once] -> f_sfCiN m_sfCiR z0_sfCiO;
        };

Data.Semigroup.$fFoldableOption_$clength
  :: forall a. Data.Semigroup.Option a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_sfCiS]
        case xs_sfCiS of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption7;
          GHC.Base.Just _ [Occ=Dead] -> Data.Semigroup.$fFoldableFirst3;
        };

lvl10_rfC6g :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Semigroup.$fFoldableOption9 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl10_rfC6g of sat_sfCiV {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfCiV;
        };

Data.Semigroup.$fFoldableOption_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sfCiW xs_sfCiX]
        case xs_sfCiX of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption9;
          GHC.Base.Just m_sfCiZ [Occ=Once] -> m_sfCiZ;
        };

Data.Semigroup.$fFoldableOption_$cnull
  :: forall a. Data.Semigroup.Option a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [t1_sfCj0]
        case t1_sfCj0 of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Semigroup.$fFoldableOption1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Option a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfCj3 ds_sfCj4]
        case ds_sfCj4 of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_sfCj3;
          GHC.Base.Just m_sfCj6 [Occ=Once] -> m_sfCj6;
        };

Data.Semigroup.$fFoldableOption_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Option a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_sfCj7]
        case eta_sfCj7 of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just m_sfCj9 [Occ=Once] -> : [m_sfCj9 GHC.Types.[]];
        };

Data.Semigroup.$fFoldableOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Option
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableOption_$cfold
                                             Data.Semigroup.$fFoldableOption_$cfoldMap
                                             Data.Semigroup.$fFoldableOption_$cfoldr'
                                             Data.Semigroup.$fFoldableOption_$cfoldr'
                                             Data.Semigroup.$fFoldableOption_$cfoldl
                                             Data.Semigroup.$fFoldableOption_$cfoldl
                                             Data.Semigroup.$fFoldableOption_$cfoldr1
                                             Data.Semigroup.$fFoldableOption_$cfoldl1
                                             Data.Semigroup.$fFoldableOption_$ctoList
                                             Data.Semigroup.$fFoldableOption_$cnull
                                             Data.Semigroup.$fFoldableOption_$clength
                                             Data.Semigroup.$fFoldableOption_$celem
                                             Data.Semigroup.$fFoldableOption_$cmaximum
                                             Data.Semigroup.$fFoldableOption_$cminimum
                                             Data.Semigroup.$fFoldableOption2
                                             Data.Semigroup.$fFoldableOption1];

Data.Semigroup.$fTraversableOption_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Option a -> f (Data.Semigroup.Option b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCja eta_sfCjb eta1_sfCjc]
        case eta1_sfCjc of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sfCja GHC.Base.Nothing;
          GHC.Base.Just a1_sfCje [Occ=Once] ->
              let {
                sat_sfCjg [Occ=Once] :: f_afyvr b_afyvt
                [LclId] =
                    [eta_sfCjb a1_sfCje] \u [] eta_sfCjb a1_sfCje;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfCja of sat_sfCjf {
                  __DEFAULT -> GHC.Base.fmap sat_sfCjf GHC.Base.Just sat_sfCjg;
                };
        };

Data.Semigroup.$fTraversableOption_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Option (f a) -> f (Data.Semigroup.Option a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfCjh eta_sfCji]
        case eta_sfCji of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sfCjh GHC.Base.Nothing;
          GHC.Base.Just a1_sfCjk [Occ=Once] ->
              case GHC.Base.$p1Applicative $dApplicative_sfCjh of sat_sfCjl {
                __DEFAULT -> GHC.Base.fmap sat_sfCjl GHC.Base.Just a1_sfCjk;
              };
        };

Data.Semigroup.$fTraversableOption_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCjm eta_sfCjn eta1_sfCjo]
        case GHC.Base.$p1Monad $dMonad_sfCjm of sat_sfCjp {
          __DEFAULT ->
              Data.Semigroup.$fTraversableOption_$ctraverse
                  sat_sfCjp eta_sfCjn eta1_sfCjo;
        };

Data.Semigroup.$fTraversableOption_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Option (m a) -> m (Data.Semigroup.Option a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfCjq eta_sfCjr]
        case eta_sfCjr of {
          GHC.Base.Nothing ->
              case GHC.Base.$p1Monad $dMonad_sfCjq of sat_sfCjt {
                __DEFAULT -> GHC.Base.pure sat_sfCjt GHC.Base.Nothing;
              };
          GHC.Base.Just a1_sfCju [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sfCjq of sat_sfCjv {
                __DEFAULT ->
                    case GHC.Base.$p1Applicative sat_sfCjv of sat_sfCjw {
                      __DEFAULT -> GHC.Base.fmap sat_sfCjw GHC.Base.Just a1_sfCju;
                    };
              };
        };

Data.Semigroup.$fTraversableOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorOption
                                                   Data.Semigroup.$fFoldableOption
                                                   Data.Semigroup.$fTraversableOption_$ctraverse
                                                   Data.Semigroup.$fTraversableOption_$csequenceA
                                                   Data.Semigroup.$fTraversableOption_$cmapM
                                                   Data.Semigroup.$fTraversableOption_$csequence];

lvl11_rfC6h :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: Option, negative multiplier"#;

Data.Semigroup.$fSemigroupOption1
  :: forall a. Data.Semigroup.Option a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl11_rfC6h of sat_sfCjx {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfCjx;
        };

Data.Semigroup.$fSemigroupOption2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Semigroup.$fSemigroupOption_$cstimes
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,U(U(U(U,U,U,U,U,U,U),U(U,U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfCjy $dIntegral_sfCjz eta_sfCjA eta1_sfCjB]
        case eta1_sfCjB of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_sfCjD [Occ=Once] ->
              case
                  GHC.Real.$p1Integral $dIntegral_sfCjz
              of
              $dReal_sfCjE [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      sat_sfCjH [Occ=Once] :: b_afyuS
                      [LclId] =
                          [$dReal_sfCjE] \u []
                              case GHC.Real.$p1Real $dReal_sfCjE of sat_sfCjG {
                                __DEFAULT ->
                                    GHC.Num.fromInteger sat_sfCjG Data.Semigroup.$fSemigroupOption2;
                              };
                    } in 
                      case GHC.Real.$p2Real $dReal_sfCjE of sat_sfCjF {
                        __DEFAULT ->
                            case GHC.Classes.compare sat_sfCjF eta_sfCjA sat_sfCjH of {
                              GHC.Types.LT -> Data.Semigroup.$fSemigroupOption1;
                              GHC.Types.EQ -> GHC.Base.Nothing [];
                              GHC.Types.GT ->
                                  let {
                                    sat_sfCjJ [Occ=Once] :: a_afyuq
                                    [LclId] =
                                        [$dSemigroup_sfCjy
                                         $dIntegral_sfCjz
                                         eta_sfCjA
                                         a1_sfCjD] \u []
                                            GHC.Base.stimes
                                                $dSemigroup_sfCjy
                                                $dIntegral_sfCjz
                                                eta_sfCjA
                                                a1_sfCjD;
                                  } in  GHC.Base.Just [sat_sfCjJ];
                            };
                      };
              };
        };

Data.Semigroup.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     Data.Semigroup.Option a
     -> [Data.Semigroup.Option a] -> Data.Semigroup.Option a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfCjK ww_sfCjL ww1_sfCjM]
        let {
          go_sfCjN [Occ=LoopBreaker]
            :: Data.Semigroup.Option a_sfBqa
               -> [Data.Semigroup.Option a_sfBqa] -> Data.Semigroup.Option a_sfBqa
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfCjK go_sfCjN] \r [b_sfCjO ds1_sfCjP]
                  case ds1_sfCjP of {
                    [] -> b_sfCjO;
                    : c_sfCjR [Occ=Once*] cs_sfCjS [Occ=Once*] ->
                        case b_sfCjO of wild_sfCjT {
                          GHC.Base.Nothing -> go_sfCjN c_sfCjR cs_sfCjS;
                          GHC.Base.Just ipv_sfCjU [Occ=Once] ->
                              case go_sfCjN c_sfCjR cs_sfCjS of {
                                GHC.Base.Nothing -> wild_sfCjT;
                                GHC.Base.Just ipv1_sfCjW [Occ=Once] ->
                                    let {
                                      sat_sfCjX [Occ=Once] :: a_sfBqa
                                      [LclId] =
                                          [w_sfCjK ipv_sfCjU ipv1_sfCjW] \u []
                                              GHC.Base.<> w_sfCjK ipv_sfCjU ipv1_sfCjW;
                                    } in  GHC.Base.Just [sat_sfCjX];
                              };
                        };
                  };
        } in  go_sfCjN ww_sfCjL ww1_sfCjM;

Data.Semigroup.$fSemigroupOption_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (Data.Semigroup.Option a)
     -> Data.Semigroup.Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfCjY w1_sfCjZ]
        case w1_sfCjZ of {
          GHC.Base.:| ww1_sfCk1 [Occ=Once] ww2_sfCk2 [Occ=Once] ->
              Data.Semigroup.$w$csconcat2 w_sfCjY ww1_sfCk1 ww2_sfCk2;
        };

Data.Semigroup.$fSemigroupOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_sfCk3]
        let {
          sat_sfCk6 [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> Data.Semigroup.Option a_afyuq -> Data.Semigroup.Option a_afyuq
          [LclId] =
              [$dSemigroup_sfCk3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fSemigroupOption_$cstimes
                      $dSemigroup_sfCk3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCk5 [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Option a_afyuq)
               -> Data.Semigroup.Option a_afyuq
          [LclId] =
              [$dSemigroup_sfCk3] \r [eta_B1]
                  Data.Semigroup.$fSemigroupOption_$csconcat
                      $dSemigroup_sfCk3 eta_B1; } in
        let {
          sat_sfCk4 [Occ=Once]
            :: Data.Semigroup.Option a_afyuq
               -> Data.Semigroup.Option a_afyuq -> Data.Semigroup.Option a_afyuq
          [LclId] =
              [$dSemigroup_sfCk3] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_sfCk3 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_sfCk4 sat_sfCk5 sat_sfCk6];

Data.Semigroup.$fMonoidOption_$cmconcat
  :: forall a.
     GHC.Base.Semigroup a =>
     [Data.Semigroup.Option a] -> Data.Semigroup.Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfCk7 eta_sfCk8]
        let {
          go_sfCk9 [Occ=LoopBreaker]
            :: [Data.Semigroup.Option a_XfyO3] -> Data.Semigroup.Option a_XfyO3
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_sfCk7 go_sfCk9] \r [ds_sfCka]
                  case ds_sfCka of {
                    [] -> GHC.Base.Nothing [];
                    : y_sfCkc [Occ=Once] ys_sfCkd [Occ=Once*] ->
                        case y_sfCkc of wild1_sfCke {
                          GHC.Base.Nothing -> go_sfCk9 ys_sfCkd;
                          GHC.Base.Just ipv_sfCkf [Occ=Once] ->
                              case go_sfCk9 ys_sfCkd of {
                                GHC.Base.Nothing -> wild1_sfCke;
                                GHC.Base.Just ipv1_sfCkh [Occ=Once] ->
                                    let {
                                      sat_sfCki [Occ=Once] :: a_XfyO3
                                      [LclId] =
                                          [$dSemigroup_sfCk7 ipv_sfCkf ipv1_sfCkh] \u []
                                              GHC.Base.<> $dSemigroup_sfCk7 ipv_sfCkf ipv1_sfCkh;
                                    } in  GHC.Base.Just [sat_sfCki];
                              };
                        };
                  };
        } in  go_sfCk9 eta_sfCk8;

Data.Semigroup.$fMonoidOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Monoid (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_sfCkj]
        let {
          sat_sfCkm [Occ=Once]
            :: [Data.Semigroup.Option a_XfyO1] -> Data.Semigroup.Option a_XfyO1
          [LclId] =
              [$dSemigroup_sfCkj] \r [eta_B1]
                  Data.Semigroup.$fMonoidOption_$cmconcat
                      $dSemigroup_sfCkj eta_B1; } in
        let {
          sat_sfCkl [Occ=Once]
            :: Data.Semigroup.Option a_XfyO1
               -> Data.Semigroup.Option a_XfyO1 -> Data.Semigroup.Option a_XfyO1
          [LclId] =
              [$dSemigroup_sfCkj] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_sfCkj eta_B2 eta_B1; } in
        let {
          sat_sfCkk [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Option a_XfyO1)
          [LclId] =
              [$dSemigroup_sfCkj] \u []
                  Data.Semigroup.$fSemigroupOption $dSemigroup_sfCkj;
        } in 
          GHC.Base.C:Monoid [sat_sfCkk GHC.Base.Nothing sat_sfCkl sat_sfCkm];

Data.Semigroup.$fGeneric1Option1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Option a
     -> GHC.Generics.Rep1 Data.Semigroup.Option a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCkn] ds_sfCkn;

Data.Semigroup.$fGeneric1Option2
  :: forall a. Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCko] x_sfCko;

Data.Semigroup.$fGeneric1Option [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Option2
                                            Data.Semigroup.$fGeneric1Option1];

Data.Semigroup.$fGenericOption1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Option a) x
     -> GHC.Generics.Rep (Data.Semigroup.Option a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCkp] ds_sfCkp;

Data.Semigroup.$fGenericOption2
  :: forall a x. Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfCkq] x1_sfCkq;

Data.Semigroup.$fGenericOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Option a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericOption2
                                           Data.Semigroup.$fGenericOption1];

Data.Semigroup.$fDataOption2
  :: forall a. GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfCkr] v_sfCkr;

Data.Semigroup.$fDataOption_$cgunfold
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCks]
        let {
          $dData1_sfCkt [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_afyoV)
          [LclId] =
              [$dData_sfCks] \u [] Data.Data.$fDataMaybe $dData_sfCks; } in
        let {
          sat_sfCky [Occ=OnceT[0]]
            :: (forall b r. Data.Data.Data b => c_afypf (b -> r) -> c_afypf r)
               -> (forall r. r -> c_afypf r)
               -> Data.Data.Constr
               -> c_afypf (Data.Semigroup.Option a_afyoV)
          [LclId] =
              [$dData1_sfCkt] \r [k_sfCku z_sfCkv ds_sfCkw]
                  let {
                    sat_sfCkx [Occ=Once]
                      :: c_afypf (GHC.Base.Maybe a_afyoV
                                  -> Data.Semigroup.Option a_afyoV)
                    [LclId] =
                        [z_sfCkv] \u [] z_sfCkv Data.Semigroup.$fDataOption2;
                  } in  k_sfCku $dData1_sfCkt sat_sfCkx;
        } in  sat_sfCky;

Data.Semigroup.$fDataOption_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Option a
     -> c (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCkz]
        let {
          $dData1_sfCkA [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_afyoV)
          [LclId] =
              [$dData_sfCkz] \u [] Data.Data.$fDataMaybe $dData_sfCkz; } in
        let {
          sat_sfCkF [Occ=OnceT[0]]
            :: (forall d b.
                Data.Data.Data d =>
                c_afyp4 (d -> b) -> d -> c_afyp4 b)
               -> (forall g. g -> c_afyp4 g)
               -> Data.Semigroup.Option a_afyoV
               -> c_afyp4 (Data.Semigroup.Option a_afyoV)
          [LclId] =
              [$dData1_sfCkA] \r [k_sfCkB z_sfCkC ds_sfCkD]
                  let {
                    sat_sfCkE [Occ=Once]
                      :: c_afyp4 (GHC.Base.Maybe a_afyoV
                                  -> Data.Semigroup.Option a_afyoV)
                    [LclId] =
                        [z_sfCkC] \u [] z_sfCkC Data.Semigroup.$fDataOption2;
                  } in  k_sfCkB $dData1_sfCkA sat_sfCkE ds_sfCkD;
        } in  sat_sfCkF;

Data.Semigroup.$fDataOption6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Option"#;

Data.Semigroup.$fDataOption9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataOption6;

Data.Semigroup.$fReadOption_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataOption9];

Data.Semigroup.$fReadFirst8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Data.Semigroup.$fReadFirst7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadFirst8;

Data.Semigroup.$fReadFirst_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.$fReadFirst7];

Data.Semigroup.$fReadOption3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getOption"#;

Data.Semigroup.$fReadOption2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadOption3;

Data.Semigroup.$fReadArg2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Semigroup.$fReadFirst4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Data.Semigroup.$fReadFirst3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadFirst4;

Data.Semigroup.$fReadFirst2 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.$fReadFirst3];

Data.Semigroup.$fReadOption1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Option a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfCkG eta_sfCkH eta1_sfCkI]
        let {
          ds_sfCkJ [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (GHC.Base.Maybe a_afyo6 -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
              [$dRead_sfCkG] \r [ds1_sfCkK eta2_sfCkL]
                  GHC.Read.$fReadMaybe1
                      $dRead_sfCkG
                      Text.ParserCombinators.ReadPrec.minPrec
                      eta2_sfCkL; } in
        let {
          sat_sfCl5 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Option a_afyo6)
          [LclId] =
              [ds_sfCkJ] \r [c_sfCkM eta2_sfCkN]
                  case c_sfCkM of {
                    GHC.Types.I# x_sfCkP [Occ=Once] ->
                        case <=# [x_sfCkP 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCl2 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                [LclId] =
                                    [ds_sfCkJ eta2_sfCkN] \r [a1_sfCkR]
                                        let {
                                          sat_sfCkZ [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                          [LclId] =
                                              [ds_sfCkJ eta2_sfCkN] \r [a2_sfCkS]
                                                  let {
                                                    sat_sfCkY [Occ=Once]
                                                      :: GHC.Base.Maybe a_afyo6
                                                         -> Text.ParserCombinators.ReadP.P b1_i815E
                                                    [LclId] =
                                                        [eta2_sfCkN] \r [a3_sfCkT]
                                                            let {
                                                              sat_sfCkV [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b1_i815E
                                                              [LclId] =
                                                                  [eta2_sfCkN
                                                                   a3_sfCkT] \r [a4_sfCkU]
                                                                      eta2_sfCkN a3_sfCkT;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfCkV
                                                              of
                                                              { Unit# ww1_sfCkX [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfCkX];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadOption2
                                                        ds_sfCkJ
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCkY;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfCkZ
                                          of
                                          { Unit# ww1_sfCl1 [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfCl1];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadOption_lexeme sat_sfCl2
                                of
                                { Unit# ww1_sfCl4 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCl4];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCl5 eta_sfCkH eta1_sfCkI;

Data.Semigroup.$fReadOption_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Option a)
[GblId, Arity=2, Str=<L,U(A,A,C(C1(U)),A)><L,U>, Unf=OtherCon []] =
    [] \r [$dRead_sfCl6 n_sfCl7]
        let {
          sat_sfCl8 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Option a_XfyIB)
          [LclId] =
              [$dRead_sfCl6 n_sfCl7] \u []
                  Data.Semigroup.$fReadOption1
                      $dRead_sfCl6
                      n_sfCl7
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCl8;

Data.Semigroup.$fReadOption_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Option a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCl9]
        let {
          sat_sfCla [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Option a_XfyIz)
          [LclId] =
              [$dRead_sfCl9] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadOption1 $dRead_sfCl9 eta_B2 eta_B1;
        } in  GHC.Read.list sat_sfCla;

Data.Semigroup.$fReadOption_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Option a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfClb]
        let {
          sat_sfCld [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Option a_XfyIA]
          [LclId] =
              [$dRead_sfClb] \u []
                  let {
                    sat_sfClc [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Option a_XfyIA)
                    [LclId] =
                        [$dRead_sfClb] \r [eta_B2 eta_B1]
                            Data.Semigroup.$fReadOption1 $dRead_sfClb eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sfClc
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCld;

Data.Semigroup.$fReadOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sfCle]
        let {
          sat_sfCli [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Option a_XfyIy]
          [LclId] =
              [$dRead_sfCle] \u []
                  Data.Semigroup.$fReadOption_$creadListPrec $dRead_sfCle; } in
        let {
          sat_sfClh [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Option a_XfyIy)
          [LclId] =
              [$dRead_sfCle] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadOption1 $dRead_sfCle eta_B2 eta_B1; } in
        let {
          sat_sfClg [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Option a_XfyIy]
          [LclId] =
              [$dRead_sfCle] \u []
                  Data.Semigroup.$fReadOption_$creadList $dRead_sfCle; } in
        let {
          sat_sfClf [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Option a_XfyIy)
          [LclId] =
              [$dRead_sfCle] \r [eta_B1]
                  Data.Semigroup.$fReadOption_$creadsPrec $dRead_sfCle eta_B1;
        } in  GHC.Read.C:Read [sat_sfClf sat_sfClg sat_sfClh sat_sfCli];

Data.Semigroup.$fShowOption2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Option {"#;

Data.Semigroup.$fShowOption1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getOption = "#;

Data.Semigroup.$w$cshowsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Option a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfClj ww_sfClk w1_sfCll]
        let {
          f_sfClm [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfClj w1_sfCll] \u []
                  GHC.Show.$fShowMaybe_$cshowsPrec
                      w_sfClj Data.Semigroup.$fFoldableOption7 w1_sfCll;
        } in 
          case >=# [ww_sfClk 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCls [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfClm] \r [x_sfClo]
                          let {
                            sat_sfClr [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfClm x_sfClo] \u []
                                    let {
                                      sat_sfClq [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfClm x_sfClo] \u []
                                              let {
                                                sat_sfClp [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfClo] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfClo;
                                              } in  f_sfClm sat_sfClp;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowOption1 sat_sfClq;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowOption2 sat_sfClr;
                } in  sat_sfCls;
            1# ->
                let {
                  sat_sfClz [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfClm] \r [x_sfClt]
                          let {
                            sat_sfCly [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfClm x_sfClt] \u []
                                    let {
                                      sat_sfClx [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfClm x_sfClt] \u []
                                              let {
                                                sat_sfClw [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfClm x_sfClt] \u []
                                                        let {
                                                          sat_sfClv [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfClt] \u []
                                                                  let {
                                                                    sat_sfClu [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfClt];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfClu;
                                                        } in  f_sfClm sat_sfClv;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowOption1 sat_sfClw;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowOption2 sat_sfClx;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCly];
                } in  sat_sfClz;
          };

Data.Semigroup.$fShowOption_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Option a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfClA w1_sfClB w2_sfClC]
        case w1_sfClB of {
          GHC.Types.I# ww1_sfClE [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec5 w_sfClA ww1_sfClE w2_sfClC;
        };

Data.Semigroup.$fShowOption3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++ GHC.Show.$fShowMaybe4 Data.Semigroup.$fReadFirst3;

Data.Semigroup.$fShowOption_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Option a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfClF x_sfClG]
        let {
          sat_sfClL [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfClF x_sfClG] \u []
                  let {
                    sat_sfClK [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfClF x_sfClG] \u []
                            case x_sfClG of {
                              GHC.Base.Nothing -> Data.Semigroup.$fShowOption3;
                              GHC.Base.Just b1_sfClI [Occ=Once] ->
                                  let {
                                    sat_sfClJ [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [$dShow_sfClF b1_sfClI] \s []
                                            GHC.Show.showsPrec
                                                $dShow_sfClF
                                                GHC.Show.appPrec1
                                                b1_sfClI
                                                Data.Semigroup.$fReadFirst3;
                                  } in  GHC.Base.++ GHC.Show.$fShowMaybe1 sat_sfClJ;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowOption1 sat_sfClK;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowOption2 sat_sfClL;

Data.Semigroup.$fShowOption_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Option a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfClM ls_sfClN s_sfClO]
        let {
          sat_sfClQ [Occ=Once]
            :: Data.Semigroup.Option a_afynB -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfClM] \r [w_sfClP]
                  Data.Semigroup.$w$cshowsPrec5 $dShow_sfClM 0# w_sfClP;
        } in  GHC.Show.showList__ sat_sfClQ ls_sfClN s_sfClO;

Data.Semigroup.$fShowOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfClR]
        let {
          sat_sfClU [Occ=Once]
            :: [Data.Semigroup.Option a_afynB] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfClR] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowOption_$cshowList
                      $dShow_sfClR eta_B2 eta_B1; } in
        let {
          sat_sfClT [Occ=Once]
            :: Data.Semigroup.Option a_afynB -> GHC.Base.String
          [LclId] =
              [$dShow_sfClR] \r [eta_B1]
                  Data.Semigroup.$fShowOption_$cshow $dShow_sfClR eta_B1; } in
        let {
          sat_sfClS [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Option a_afynB -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfClR] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowOption_$cshowsPrec $dShow_sfClR eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfClS sat_sfClT sat_sfClU];

Data.Semigroup.$fEqOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sfClV]
        let {
          sat_sfClX [Occ=Once]
            :: Data.Semigroup.Option a_afyle
               -> Data.Semigroup.Option a_afyle -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfClV] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_sfClV eta_B2 eta_B1; } in
        let {
          sat_sfClW [Occ=Once]
            :: Data.Semigroup.Option a_afyle
               -> Data.Semigroup.Option a_afyle -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfClV] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_sfClV eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sfClW sat_sfClX];

Data.Semigroup.$fOrdOption_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfClY]
        let {
          sat_sfClZ [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_XfyGz
          [LclId] =
              [$dOrd_sfClY] \u [] GHC.Classes.$p1Ord $dOrd_sfClY;
        } in  Data.Semigroup.$fEqOption sat_sfClZ;

Data.Semigroup.$fOrdOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Option a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_sfCm0]
        let {
          sat_sfCma [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> Data.Semigroup.Option a_XfyGA
          [LclId] =
              [$dOrd_sfCm0] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_sfCm0 eta_B2 eta_B1; } in
        let {
          sat_sfCm9 [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> Data.Semigroup.Option a_XfyGA
          [LclId] =
              [$dOrd_sfCm0] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_sfCm0 eta_B2 eta_B1; } in
        let {
          sat_sfCm8 [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCm0] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_sfCm0 eta_B2 eta_B1; } in
        let {
          sat_sfCm7 [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCm0] \r [a1_sfCm5 b_sfCm6]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_sfCm0 b_sfCm6 a1_sfCm5; } in
        let {
          sat_sfCm4 [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCm0] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_sfCm0 eta_B2 eta_B1; } in
        let {
          sat_sfCm3 [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCm0] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_sfCm0 eta_B2 eta_B1; } in
        let {
          sat_sfCm2 [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCm0] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_sfCm0 eta_B2 eta_B1; } in
        let {
          sat_sfCm1 [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Option a_XfyGA)
          [LclId] =
              [$dOrd_sfCm0] \u [] Data.Semigroup.$fOrdOption_$cp1Ord $dOrd_sfCm0;
        } in 
          GHC.Classes.C:Ord [sat_sfCm1
                             sat_sfCm2
                             sat_sfCm3
                             sat_sfCm4
                             sat_sfCm7
                             sat_sfCm8
                             sat_sfCm9
                             sat_sfCma];

Data.Semigroup.$fGeneric1WrappedMonoid1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.WrappedMonoid a
     -> GHC.Generics.Rep1 Data.Semigroup.WrappedMonoid a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCmb] ds_sfCmb;

Data.Semigroup.$fGeneric1WrappedMonoid2
  :: forall a.
     Data.Semigroup.WrappedMonoid a -> Data.Semigroup.WrappedMonoid a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCmc] x_sfCmc;

Data.Semigroup.$fGeneric1WrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.WrappedMonoid
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1WrappedMonoid2
                                            Data.Semigroup.$fGeneric1WrappedMonoid1];

Data.Semigroup.$fGenericWrappedMonoid1
  :: forall m x.
     GHC.Generics.Rep (Data.Semigroup.WrappedMonoid m) x
     -> GHC.Generics.Rep (Data.Semigroup.WrappedMonoid m) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCmd] ds_sfCmd;

Data.Semigroup.$fGenericWrappedMonoid2
  :: forall m x.
     Data.Semigroup.WrappedMonoid m -> Data.Semigroup.WrappedMonoid m
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfCme] x1_sfCme;

Data.Semigroup.$fGenericWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. GHC.Generics.Generic (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericWrappedMonoid2
                                           Data.Semigroup.$fGenericWrappedMonoid1];

Data.Semigroup.$fDataWrappedMonoid_$cgfoldl
  :: forall m.
     Data.Data.Data m =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.WrappedMonoid m
     -> c (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCmf k_sfCmg z_sfCmh ds_sfCmi]
        let {
          sat_sfCmj [Occ=Once]
            :: c_afygk (m_afygb -> Data.Semigroup.WrappedMonoid m_afygb)
          [LclId] =
              [z_sfCmh] \u [] z_sfCmh Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfCmg $dData_sfCmf sat_sfCmj ds_sfCmi;

Data.Semigroup.$fReadWrappedMonoid5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrapMonoid"#;

Data.Semigroup.$fReadWrappedMonoid4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.$fReadWrappedMonoid5;

Data.Semigroup.$fReadWrappedMonoid_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fReadWrappedMonoid4];

Data.Semigroup.$fReadWrappedMonoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "unwrapMonoid"#;

Data.Semigroup.$fReadWrappedMonoid2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.$fReadWrappedMonoid3;

Data.Semigroup.$fReadWrappedMonoid1
  :: forall m.
     GHC.Read.Read m =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.WrappedMonoid m
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCmk]
        let {
          lvl33_sfCml [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP m_afyfm
          [LclId] =
              [$dRead_sfCmk] \u []
                  GHC.Read.readPrec
                      $dRead_sfCmk Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfCmm [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP m_afyfm
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfCml] \r [ds1_sfCmn] lvl33_sfCml; } in
        let {
          sat_sfCmH [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.WrappedMonoid m_afyfm)
          [LclId] =
              [ds_sfCmm] \r [c_sfCmo eta_sfCmp]
                  case c_sfCmo of {
                    GHC.Types.I# x_sfCmr [Occ=Once] ->
                        case <=# [x_sfCmr 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCmE [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfCmm eta_sfCmp] \r [a1_sfCmt]
                                        let {
                                          sat_sfCmB [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfCmm eta_sfCmp] \r [a2_sfCmu]
                                                  let {
                                                    sat_sfCmA [Occ=Once]
                                                      :: m_afyfm
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfCmp] \r [a3_sfCmv]
                                                            let {
                                                              sat_sfCmx [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfCmp a3_sfCmv] \r [a4_sfCmw]
                                                                      eta_sfCmp a3_sfCmv;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfCmx
                                                              of
                                                              { Unit# ww1_sfCmz [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfCmz];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadWrappedMonoid2
                                                        ds_sfCmm
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCmA;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfCmB
                                          of
                                          { Unit# ww1_sfCmD [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfCmD];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadWrappedMonoid_lexeme sat_sfCmE
                                of
                                { Unit# ww1_sfCmG [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCmG];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCmH;

Data.Semigroup.$fReadWrappedMonoid_$creadsPrec
  :: forall m.
     GHC.Read.Read m =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.WrappedMonoid m)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCmI]
        let {
          ds_sfCmJ [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.WrappedMonoid m_XfyAE
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfCmI] \u []
                  Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfCmI; } in
        let {
          sat_sfCmM [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.WrappedMonoid m_XfyAE)
          [LclId] =
              [ds_sfCmJ] \r [n_sfCmK]
                  let {
                    sat_sfCmL [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.WrappedMonoid m_XfyAE)
                    [LclId] =
                        [ds_sfCmJ n_sfCmK] \u []
                            ds_sfCmJ
                                n_sfCmK Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfCmL;
        } in  sat_sfCmM;

Data.Semigroup.$fReadWrappedMonoid_$creadListPrec
  :: forall m.
     GHC.Read.Read m =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.WrappedMonoid m]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCmN]
        let {
          sat_sfCmO [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.WrappedMonoid m_XfyAC)
          [LclId] =
              [$dRead_sfCmN] \s []
                  Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfCmN;
        } in  GHC.Read.list sat_sfCmO;

Data.Semigroup.$fReadWrappedMonoid_$creadList
  :: forall m.
     GHC.Read.Read m =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.WrappedMonoid m]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCmP]
        let {
          sat_sfCmR [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.WrappedMonoid m_XfyAD]
          [LclId] =
              [$dRead_sfCmP] \u []
                  let {
                    sat_sfCmQ [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.WrappedMonoid m_XfyAD)
                    [LclId] =
                        [$dRead_sfCmP] \s []
                            Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfCmP;
                  } in 
                    GHC.Read.list
                        sat_sfCmQ
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCmR;

Data.Semigroup.$fReadWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Read.Read m =>
     GHC.Read.Read (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfCmS]
        let {
          sat_sfCmW [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.WrappedMonoid m_XfyAB]
          [LclId] =
              [$dRead_sfCmS] \u []
                  Data.Semigroup.$fReadWrappedMonoid_$creadListPrec
                      $dRead_sfCmS; } in
        let {
          sat_sfCmV [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.WrappedMonoid m_XfyAB)
          [LclId] =
              [$dRead_sfCmS] \u []
                  Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfCmS; } in
        let {
          sat_sfCmU [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.WrappedMonoid m_XfyAB]
          [LclId] =
              [$dRead_sfCmS] \u []
                  Data.Semigroup.$fReadWrappedMonoid_$creadList $dRead_sfCmS; } in
        let {
          sat_sfCmT [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.WrappedMonoid m_XfyAB)
          [LclId] =
              [$dRead_sfCmS] \u []
                  Data.Semigroup.$fReadWrappedMonoid_$creadsPrec $dRead_sfCmS;
        } in  GHC.Read.C:Read [sat_sfCmT sat_sfCmU sat_sfCmV sat_sfCmW];

Data.Semigroup.$fShowWrappedMonoid2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrapMonoid {"#;

Data.Semigroup.$fShowWrappedMonoid1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "unwrapMonoid = "#;

Data.Semigroup.$w$cshowsPrec6 [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Show.Show m =>
     GHC.Prim.Int# -> Data.Semigroup.WrappedMonoid m -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCmX ww_sfCmY w1_sfCmZ]
        let {
          f_sfCn0 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfCmX w1_sfCmZ] \u []
                  GHC.Show.showsPrec
                      w_sfCmX Data.Semigroup.$fFoldableOption7 w1_sfCmZ;
        } in 
          case >=# [ww_sfCmY 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCn6 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCn0] \r [x_sfCn2]
                          let {
                            sat_sfCn5 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCn0 x_sfCn2] \u []
                                    let {
                                      sat_sfCn4 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCn0 x_sfCn2] \u []
                                              let {
                                                sat_sfCn3 [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfCn2] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfCn2;
                                              } in  f_sfCn0 sat_sfCn3;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowWrappedMonoid1 sat_sfCn4;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowWrappedMonoid2 sat_sfCn5;
                } in  sat_sfCn6;
            1# ->
                let {
                  sat_sfCnd [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCn0] \r [x_sfCn7]
                          let {
                            sat_sfCnc [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCn0 x_sfCn7] \u []
                                    let {
                                      sat_sfCnb [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCn0 x_sfCn7] \u []
                                              let {
                                                sat_sfCna [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfCn0 x_sfCn7] \u []
                                                        let {
                                                          sat_sfCn9 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfCn7] \u []
                                                                  let {
                                                                    sat_sfCn8 [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfCn7];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfCn8;
                                                        } in  f_sfCn0 sat_sfCn9;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowWrappedMonoid1 sat_sfCna;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowWrappedMonoid2 sat_sfCnb;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCnc];
                } in  sat_sfCnd;
          };

Data.Semigroup.$fShowWrappedMonoid_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Show.Show m =>
     GHC.Types.Int -> Data.Semigroup.WrappedMonoid m -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCne w1_sfCnf w2_sfCng]
        case w1_sfCnf of {
          GHC.Types.I# ww1_sfCni [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec6 w_sfCne ww1_sfCni w2_sfCng;
        };

Data.Semigroup.$fShowWrappedMonoid_$cshow
  :: forall m.
     GHC.Show.Show m =>
     Data.Semigroup.WrappedMonoid m -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCnj x_sfCnk]
        let {
          sat_sfCnm [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfCnj x_sfCnk] \u []
                  let {
                    sat_sfCnl [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfCnj x_sfCnk] \u []
                            GHC.Show.showsPrec
                                $dShow_sfCnj
                                Data.Semigroup.$fFoldableOption7
                                x_sfCnk
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowWrappedMonoid1 sat_sfCnl;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowWrappedMonoid2 sat_sfCnm;

Data.Semigroup.$fShowWrappedMonoid_$cshowList
  :: forall m.
     GHC.Show.Show m =>
     [Data.Semigroup.WrappedMonoid m] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCnn ls_sfCno s_sfCnp]
        let {
          sat_sfCnr [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyeR -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCnn] \r [w_sfCnq]
                  Data.Semigroup.$w$cshowsPrec6 $dShow_sfCnn 0# w_sfCnq;
        } in  GHC.Show.showList__ sat_sfCnr ls_sfCno s_sfCnp;

Data.Semigroup.$fShowWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Show.Show m =>
     GHC.Show.Show (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfCns]
        let {
          sat_sfCnv [Occ=Once]
            :: [Data.Semigroup.WrappedMonoid m_afyeR] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCns] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowWrappedMonoid_$cshowList
                      $dShow_sfCns eta_B2 eta_B1; } in
        let {
          sat_sfCnu [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyeR -> GHC.Base.String
          [LclId] =
              [$dShow_sfCns] \r [eta_B1]
                  Data.Semigroup.$fShowWrappedMonoid_$cshow $dShow_sfCns eta_B1; } in
        let {
          sat_sfCnt [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.WrappedMonoid m_afyeR -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCns] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowWrappedMonoid_$cshowsPrec
                      $dShow_sfCns eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfCnt sat_sfCnu sat_sfCnv];

Data.Semigroup.$fEqWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Classes.Eq m =>
     GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfCnw]
        let {
          sat_sfCny [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afycu
               -> Data.Semigroup.WrappedMonoid m_afycu -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCnw] \u [] GHC.Classes./= $dEq_sfCnw; } in
        let {
          sat_sfCnx [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afycu
               -> Data.Semigroup.WrappedMonoid m_afycu -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCnw] \u [] GHC.Classes.== $dEq_sfCnw;
        } in  GHC.Classes.C:Eq [sat_sfCnx sat_sfCny];

Data.Semigroup.$fOrdWrappedMonoid_$cp1Ord
  :: forall m.
     GHC.Classes.Ord m =>
     GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCnz]
        let {
          sat_sfCnA [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq m_afyd2
          [LclId] =
              [$dOrd_sfCnz] \u [] GHC.Classes.$p1Ord $dOrd_sfCnz;
        } in  Data.Semigroup.$fEqWrappedMonoid sat_sfCnA;

Data.Semigroup.$fOrdWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Classes.Ord m =>
     GHC.Classes.Ord (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfCnB]
        let {
          sat_sfCnJ [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.min $dOrd_sfCnB; } in
        let {
          sat_sfCnI [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.max $dOrd_sfCnB; } in
        let {
          sat_sfCnH [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.>= $dOrd_sfCnB; } in
        let {
          sat_sfCnG [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.> $dOrd_sfCnB; } in
        let {
          sat_sfCnF [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.<= $dOrd_sfCnB; } in
        let {
          sat_sfCnE [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.< $dOrd_sfCnB; } in
        let {
          sat_sfCnD [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCnB] \u [] GHC.Classes.compare $dOrd_sfCnB; } in
        let {
          sat_sfCnC [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m_afyd2)
          [LclId] =
              [$dOrd_sfCnB] \u []
                  Data.Semigroup.$fOrdWrappedMonoid_$cp1Ord $dOrd_sfCnB;
        } in 
          GHC.Classes.C:Ord [sat_sfCnC
                             sat_sfCnD
                             sat_sfCnE
                             sat_sfCnF
                             sat_sfCnG
                             sat_sfCnH
                             sat_sfCnI
                             sat_sfCnJ];

Data.Semigroup.$fBoundedWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Enum.Bounded m =>
     GHC.Enum.Bounded (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfCnK]
        let {
          sat_sfCnM [Occ=Once] :: Data.Semigroup.WrappedMonoid m_afycc
          [LclId] =
              [$dBounded_sfCnK] \u [] GHC.Enum.maxBound $dBounded_sfCnK; } in
        let {
          sat_sfCnL [Occ=Once] :: Data.Semigroup.WrappedMonoid m_afycc
          [LclId] =
              [$dBounded_sfCnK] \u [] GHC.Enum.minBound $dBounded_sfCnK;
        } in  GHC.Enum.C:Bounded [sat_sfCnL sat_sfCnM];

Data.Semigroup.$fGeneric1Last1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Last a
     -> GHC.Generics.Rep1 Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCnN] ds_sfCnN;

Data.Semigroup.$fGeneric1Last2
  :: forall a. Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCnO] x_sfCnO;

Data.Semigroup.$fGeneric1Last [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Last2
                                            Data.Semigroup.$fGeneric1Last1];

Data.Semigroup.$fGenericLast1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Last a) x
     -> GHC.Generics.Rep (Data.Semigroup.Last a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCnP] ds_sfCnP;

Data.Semigroup.$fGenericLast2
  :: forall a x. Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfCnQ] x1_sfCnQ;

Data.Semigroup.$fGenericLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Last a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericLast2
                                           Data.Semigroup.$fGenericLast1];

Data.Semigroup.$fDataLast_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Last a
     -> c (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCnR k_sfCnS z_sfCnT ds_sfCnU]
        let {
          sat_sfCnV [Occ=Once]
            :: c_afy7i (a_afy79 -> Data.Semigroup.Last a_afy79)
          [LclId] =
              [z_sfCnT] \u [] z_sfCnT Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfCnS $dData_sfCnR sat_sfCnV ds_sfCnU;

Data.Semigroup.$fDataLast4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last"#;

Data.Semigroup.$fDataLast7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataLast4;

Data.Semigroup.$fReadLast_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataLast7];

Data.Semigroup.$fReadLast3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast"#;

Data.Semigroup.$fReadLast2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadLast3;

Data.Semigroup.$fReadLast1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Last a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCnW]
        let {
          lvl33_sfCnX [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afy6k
          [LclId] =
              [$dRead_sfCnW] \u []
                  GHC.Read.readPrec
                      $dRead_sfCnW Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfCnY [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afy6k
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfCnX] \r [ds1_sfCnZ] lvl33_sfCnX; } in
        let {
          sat_sfCoj [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Last a_afy6k)
          [LclId] =
              [ds_sfCnY] \r [c_sfCo0 eta_sfCo1]
                  case c_sfCo0 of {
                    GHC.Types.I# x_sfCo3 [Occ=Once] ->
                        case <=# [x_sfCo3 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCog [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfCnY eta_sfCo1] \r [a1_sfCo5]
                                        let {
                                          sat_sfCod [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfCnY eta_sfCo1] \r [a2_sfCo6]
                                                  let {
                                                    sat_sfCoc [Occ=Once]
                                                      :: a_afy6k
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfCo1] \r [a3_sfCo7]
                                                            let {
                                                              sat_sfCo9 [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfCo1 a3_sfCo7] \r [a4_sfCo8]
                                                                      eta_sfCo1 a3_sfCo7;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfCo9
                                                              of
                                                              { Unit# ww1_sfCob [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfCob];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadLast2
                                                        ds_sfCnY
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCoc;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfCod
                                          of
                                          { Unit# ww1_sfCof [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfCof];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadLast_lexeme sat_sfCog
                                of
                                { Unit# ww1_sfCoi [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCoi];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCoj;

Data.Semigroup.$fReadLast_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Last a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCok]
        let {
          ds_sfCol [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Last a_Xfysp -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfCok] \u [] Data.Semigroup.$fReadLast1 $dRead_sfCok; } in
        let {
          sat_sfCoo [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Last a_Xfysp)
          [LclId] =
              [ds_sfCol] \r [n_sfCom]
                  let {
                    sat_sfCon [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Last a_Xfysp)
                    [LclId] =
                        [ds_sfCol n_sfCom] \u []
                            ds_sfCol
                                n_sfCom Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfCon;
        } in  sat_sfCoo;

Data.Semigroup.$fReadLast_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Last a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCop]
        let {
          sat_sfCoq [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Last a_Xfysn)
          [LclId] =
              [$dRead_sfCop] \s [] Data.Semigroup.$fReadLast1 $dRead_sfCop;
        } in  GHC.Read.list sat_sfCoq;

Data.Semigroup.$fReadLast_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Last a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCor]
        let {
          sat_sfCot [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Last a_Xfyso]
          [LclId] =
              [$dRead_sfCor] \u []
                  let {
                    sat_sfCos [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Last a_Xfyso)
                    [LclId] =
                        [$dRead_sfCor] \s [] Data.Semigroup.$fReadLast1 $dRead_sfCor;
                  } in 
                    GHC.Read.list
                        sat_sfCos
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCot;

Data.Semigroup.$fReadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfCou]
        let {
          sat_sfCoy [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Last a_Xfysm]
          [LclId] =
              [$dRead_sfCou] \u []
                  Data.Semigroup.$fReadLast_$creadListPrec $dRead_sfCou; } in
        let {
          sat_sfCox [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Last a_Xfysm)
          [LclId] =
              [$dRead_sfCou] \u [] Data.Semigroup.$fReadLast1 $dRead_sfCou; } in
        let {
          sat_sfCow [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Last a_Xfysm]
          [LclId] =
              [$dRead_sfCou] \u []
                  Data.Semigroup.$fReadLast_$creadList $dRead_sfCou; } in
        let {
          sat_sfCov [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Last a_Xfysm)
          [LclId] =
              [$dRead_sfCou] \u []
                  Data.Semigroup.$fReadLast_$creadsPrec $dRead_sfCou;
        } in  GHC.Read.C:Read [sat_sfCov sat_sfCow sat_sfCox sat_sfCoy];

Data.Semigroup.$fShowLast2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last {"#;

Data.Semigroup.$fShowLast1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast = "#;

Data.Semigroup.$w$cshowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCoz ww_sfCoA w1_sfCoB]
        let {
          f_sfCoC [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfCoz w1_sfCoB] \u []
                  GHC.Show.showsPrec
                      w_sfCoz Data.Semigroup.$fFoldableOption7 w1_sfCoB;
        } in 
          case >=# [ww_sfCoA 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCoI [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCoC] \r [x_sfCoE]
                          let {
                            sat_sfCoH [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCoC x_sfCoE] \u []
                                    let {
                                      sat_sfCoG [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCoC x_sfCoE] \u []
                                              let {
                                                sat_sfCoF [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfCoE] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfCoE;
                                              } in  f_sfCoC sat_sfCoF;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowLast1 sat_sfCoG;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowLast2 sat_sfCoH;
                } in  sat_sfCoI;
            1# ->
                let {
                  sat_sfCoP [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCoC] \r [x_sfCoJ]
                          let {
                            sat_sfCoO [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCoC x_sfCoJ] \u []
                                    let {
                                      sat_sfCoN [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCoC x_sfCoJ] \u []
                                              let {
                                                sat_sfCoM [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfCoC x_sfCoJ] \u []
                                                        let {
                                                          sat_sfCoL [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfCoJ] \u []
                                                                  let {
                                                                    sat_sfCoK [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfCoJ];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfCoK;
                                                        } in  f_sfCoC sat_sfCoL;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowLast1 sat_sfCoM;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowLast2 sat_sfCoN;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCoO];
                } in  sat_sfCoP;
          };

Data.Semigroup.$fShowLast_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCoQ w1_sfCoR w2_sfCoS]
        case w1_sfCoR of {
          GHC.Types.I# ww1_sfCoU [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec2 w_sfCoQ ww1_sfCoU w2_sfCoS;
        };

Data.Semigroup.$fShowLast_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Last a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCoV x_sfCoW]
        let {
          sat_sfCoY [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfCoV x_sfCoW] \u []
                  let {
                    sat_sfCoX [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfCoV x_sfCoW] \u []
                            GHC.Show.showsPrec
                                $dShow_sfCoV
                                Data.Semigroup.$fFoldableOption7
                                x_sfCoW
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowLast1 sat_sfCoX;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowLast2 sat_sfCoY;

Data.Semigroup.$fShowLast_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Last a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCoZ ls_sfCp0 s_sfCp1]
        let {
          sat_sfCp3 [Occ=Once]
            :: Data.Semigroup.Last a_afy5P -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCoZ] \r [w_sfCp2]
                  Data.Semigroup.$w$cshowsPrec2 $dShow_sfCoZ 0# w_sfCp2;
        } in  GHC.Show.showList__ sat_sfCp3 ls_sfCp0 s_sfCp1;

Data.Semigroup.$fShowLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfCp4]
        let {
          sat_sfCp7 [Occ=Once]
            :: [Data.Semigroup.Last a_afy5P] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCp4] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowLast_$cshowList
                      $dShow_sfCp4 eta_B2 eta_B1; } in
        let {
          sat_sfCp6 [Occ=Once]
            :: Data.Semigroup.Last a_afy5P -> GHC.Base.String
          [LclId] =
              [$dShow_sfCp4] \r [eta_B1]
                  Data.Semigroup.$fShowLast_$cshow $dShow_sfCp4 eta_B1; } in
        let {
          sat_sfCp5 [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Last a_afy5P -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCp4] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowLast_$cshowsPrec $dShow_sfCp4 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfCp5 sat_sfCp6 sat_sfCp7];

Data.Semigroup.$fEqLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfCp8]
        let {
          sat_sfCpa [Occ=Once]
            :: Data.Semigroup.Last a_afy3s
               -> Data.Semigroup.Last a_afy3s -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCp8] \u [] GHC.Classes./= $dEq_sfCp8; } in
        let {
          sat_sfCp9 [Occ=Once]
            :: Data.Semigroup.Last a_afy3s
               -> Data.Semigroup.Last a_afy3s -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCp8] \u [] GHC.Classes.== $dEq_sfCp8;
        } in  GHC.Classes.C:Eq [sat_sfCp9 sat_sfCpa];

Data.Semigroup.$fOrdLast_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Last a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCpb]
        let {
          sat_sfCpc [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afy40
          [LclId] =
              [$dOrd_sfCpb] \u [] GHC.Classes.$p1Ord $dOrd_sfCpb;
        } in  Data.Semigroup.$fEqLast sat_sfCpc;

Data.Semigroup.$fOrdLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfCpd]
        let {
          sat_sfCpl [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> Data.Semigroup.Last a_afy40
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.min $dOrd_sfCpd; } in
        let {
          sat_sfCpk [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> Data.Semigroup.Last a_afy40
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.max $dOrd_sfCpd; } in
        let {
          sat_sfCpj [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.>= $dOrd_sfCpd; } in
        let {
          sat_sfCpi [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.> $dOrd_sfCpd; } in
        let {
          sat_sfCph [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.<= $dOrd_sfCpd; } in
        let {
          sat_sfCpg [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.< $dOrd_sfCpd; } in
        let {
          sat_sfCpf [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCpd] \u [] GHC.Classes.compare $dOrd_sfCpd; } in
        let {
          sat_sfCpe [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Last a_afy40)
          [LclId] =
              [$dOrd_sfCpd] \u [] Data.Semigroup.$fOrdLast_$cp1Ord $dOrd_sfCpd;
        } in 
          GHC.Classes.C:Ord [sat_sfCpe
                             sat_sfCpf
                             sat_sfCpg
                             sat_sfCph
                             sat_sfCpi
                             sat_sfCpj
                             sat_sfCpk
                             sat_sfCpl];

Data.Semigroup.$fBoundedLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfCpm]
        let {
          sat_sfCpo [Occ=Once] :: Data.Semigroup.Last a_afy3a
          [LclId] =
              [$dBounded_sfCpm] \u [] GHC.Enum.maxBound $dBounded_sfCpm; } in
        let {
          sat_sfCpn [Occ=Once] :: Data.Semigroup.Last a_afy3a
          [LclId] =
              [$dBounded_sfCpm] \u [] GHC.Enum.minBound $dBounded_sfCpm;
        } in  GHC.Enum.C:Bounded [sat_sfCpn sat_sfCpo];

Data.Semigroup.$fGeneric1First1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.First a
     -> GHC.Generics.Rep1 Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCpp] ds_sfCpp;

Data.Semigroup.$fGeneric1First2
  :: forall a. Data.Semigroup.First a -> Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCpq] x_sfCpq;

Data.Semigroup.$fGeneric1First [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1First2
                                            Data.Semigroup.$fGeneric1First1];

Data.Semigroup.$fGenericFirst1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.First a) x
     -> GHC.Generics.Rep (Data.Semigroup.First a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCpr] ds_sfCpr;

Data.Semigroup.$fGenericFirst2
  :: forall a x. Data.Semigroup.First a -> Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfCps] x1_sfCps;

Data.Semigroup.$fGenericFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.First a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericFirst2
                                           Data.Semigroup.$fGenericFirst1];

Data.Semigroup.$fDataFirst_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.First a
     -> c (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCpt k_sfCpu z_sfCpv ds_sfCpw]
        let {
          sat_sfCpx [Occ=Once]
            :: c_afxYg (a_afxY7 -> Data.Semigroup.First a_afxY7)
          [LclId] =
              [z_sfCpv] \u [] z_sfCpv Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfCpu $dData_sfCpt sat_sfCpx ds_sfCpw;

Data.Semigroup.$fDataFirst4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First"#;

Data.Semigroup.$fDataFirst7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataFirst4;

Data.Semigroup.$fReadFirst_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataFirst7];

Data.Semigroup.$fReadFirst6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst"#;

Data.Semigroup.$fReadFirst5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadFirst6;

Data.Semigroup.$fReadFirst1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.First a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCpy]
        let {
          lvl33_sfCpz [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afxXi
          [LclId] =
              [$dRead_sfCpy] \u []
                  GHC.Read.readPrec
                      $dRead_sfCpy Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfCpA [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afxXi
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfCpz] \r [ds1_sfCpB] lvl33_sfCpz; } in
        let {
          sat_sfCpV [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.First a_afxXi)
          [LclId] =
              [ds_sfCpA] \r [c_sfCpC eta_sfCpD]
                  case c_sfCpC of {
                    GHC.Types.I# x_sfCpF [Occ=Once] ->
                        case <=# [x_sfCpF 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCpS [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfCpA eta_sfCpD] \r [a1_sfCpH]
                                        let {
                                          sat_sfCpP [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfCpA eta_sfCpD] \r [a2_sfCpI]
                                                  let {
                                                    sat_sfCpO [Occ=Once]
                                                      :: a_afxXi
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfCpD] \r [a3_sfCpJ]
                                                            let {
                                                              sat_sfCpL [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfCpD a3_sfCpJ] \r [a4_sfCpK]
                                                                      eta_sfCpD a3_sfCpJ;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfCpL
                                                              of
                                                              { Unit# ww1_sfCpN [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfCpN];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadFirst5
                                                        ds_sfCpA
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCpO;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfCpP
                                          of
                                          { Unit# ww1_sfCpR [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfCpR];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadFirst_lexeme1 sat_sfCpS
                                of
                                { Unit# ww1_sfCpU [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCpU];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCpV;

Data.Semigroup.$fReadFirst_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.First a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCpW]
        let {
          ds_sfCpX [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.First a_Xfyka -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfCpW] \u [] Data.Semigroup.$fReadFirst1 $dRead_sfCpW; } in
        let {
          sat_sfCq0 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.First a_Xfyka)
          [LclId] =
              [ds_sfCpX] \r [n_sfCpY]
                  let {
                    sat_sfCpZ [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.First a_Xfyka)
                    [LclId] =
                        [ds_sfCpX n_sfCpY] \u []
                            ds_sfCpX
                                n_sfCpY Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfCpZ;
        } in  sat_sfCq0;

Data.Semigroup.$fReadFirst_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.First a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCq1]
        let {
          sat_sfCq2 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.First a_Xfyk8)
          [LclId] =
              [$dRead_sfCq1] \s [] Data.Semigroup.$fReadFirst1 $dRead_sfCq1;
        } in  GHC.Read.list sat_sfCq2;

Data.Semigroup.$fReadFirst_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.First a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCq3]
        let {
          sat_sfCq5 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.First a_Xfyk9]
          [LclId] =
              [$dRead_sfCq3] \u []
                  let {
                    sat_sfCq4 [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.First a_Xfyk9)
                    [LclId] =
                        [$dRead_sfCq3] \s [] Data.Semigroup.$fReadFirst1 $dRead_sfCq3;
                  } in 
                    GHC.Read.list
                        sat_sfCq4
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCq5;

Data.Semigroup.$fReadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfCq6]
        let {
          sat_sfCqa [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.First a_Xfyk7]
          [LclId] =
              [$dRead_sfCq6] \u []
                  Data.Semigroup.$fReadFirst_$creadListPrec $dRead_sfCq6; } in
        let {
          sat_sfCq9 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.First a_Xfyk7)
          [LclId] =
              [$dRead_sfCq6] \u [] Data.Semigroup.$fReadFirst1 $dRead_sfCq6; } in
        let {
          sat_sfCq8 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.First a_Xfyk7]
          [LclId] =
              [$dRead_sfCq6] \u []
                  Data.Semigroup.$fReadFirst_$creadList $dRead_sfCq6; } in
        let {
          sat_sfCq7 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.First a_Xfyk7)
          [LclId] =
              [$dRead_sfCq6] \u []
                  Data.Semigroup.$fReadFirst_$creadsPrec $dRead_sfCq6;
        } in  GHC.Read.C:Read [sat_sfCq7 sat_sfCq8 sat_sfCq9 sat_sfCqa];

Data.Semigroup.$fShowFirst2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First {"#;

Data.Semigroup.$fShowFirst1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst = "#;

Data.Semigroup.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCqb ww_sfCqc w1_sfCqd]
        let {
          f_sfCqe [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfCqb w1_sfCqd] \u []
                  GHC.Show.showsPrec
                      w_sfCqb Data.Semigroup.$fFoldableOption7 w1_sfCqd;
        } in 
          case >=# [ww_sfCqc 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCqk [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCqe] \r [x_sfCqg]
                          let {
                            sat_sfCqj [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCqe x_sfCqg] \u []
                                    let {
                                      sat_sfCqi [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCqe x_sfCqg] \u []
                                              let {
                                                sat_sfCqh [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfCqg] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfCqg;
                                              } in  f_sfCqe sat_sfCqh;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowFirst1 sat_sfCqi;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowFirst2 sat_sfCqj;
                } in  sat_sfCqk;
            1# ->
                let {
                  sat_sfCqr [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCqe] \r [x_sfCql]
                          let {
                            sat_sfCqq [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCqe x_sfCql] \u []
                                    let {
                                      sat_sfCqp [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCqe x_sfCql] \u []
                                              let {
                                                sat_sfCqo [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfCqe x_sfCql] \u []
                                                        let {
                                                          sat_sfCqn [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfCql] \u []
                                                                  let {
                                                                    sat_sfCqm [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfCql];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfCqm;
                                                        } in  f_sfCqe sat_sfCqn;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowFirst1 sat_sfCqo;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowFirst2 sat_sfCqp;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCqq];
                } in  sat_sfCqr;
          };

Data.Semigroup.$fShowFirst_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCqs w1_sfCqt w2_sfCqu]
        case w1_sfCqt of {
          GHC.Types.I# ww1_sfCqw [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec1 w_sfCqs ww1_sfCqw w2_sfCqu;
        };

Data.Semigroup.$fShowFirst_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.First a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCqx x_sfCqy]
        let {
          sat_sfCqA [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfCqx x_sfCqy] \u []
                  let {
                    sat_sfCqz [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfCqx x_sfCqy] \u []
                            GHC.Show.showsPrec
                                $dShow_sfCqx
                                Data.Semigroup.$fFoldableOption7
                                x_sfCqy
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowFirst1 sat_sfCqz;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowFirst2 sat_sfCqA;

Data.Semigroup.$fShowFirst_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.First a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCqB ls_sfCqC s_sfCqD]
        let {
          sat_sfCqF [Occ=Once]
            :: Data.Semigroup.First a_afxWN -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCqB] \r [w_sfCqE]
                  Data.Semigroup.$w$cshowsPrec1 $dShow_sfCqB 0# w_sfCqE;
        } in  GHC.Show.showList__ sat_sfCqF ls_sfCqC s_sfCqD;

Data.Semigroup.$fShowFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfCqG]
        let {
          sat_sfCqJ [Occ=Once]
            :: [Data.Semigroup.First a_afxWN] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCqG] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowFirst_$cshowList
                      $dShow_sfCqG eta_B2 eta_B1; } in
        let {
          sat_sfCqI [Occ=Once]
            :: Data.Semigroup.First a_afxWN -> GHC.Base.String
          [LclId] =
              [$dShow_sfCqG] \r [eta_B1]
                  Data.Semigroup.$fShowFirst_$cshow $dShow_sfCqG eta_B1; } in
        let {
          sat_sfCqH [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.First a_afxWN -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCqG] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowFirst_$cshowsPrec $dShow_sfCqG eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfCqH sat_sfCqI sat_sfCqJ];

Data.Semigroup.$fEqFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfCqK]
        let {
          sat_sfCqM [Occ=Once]
            :: Data.Semigroup.First a_afxUq
               -> Data.Semigroup.First a_afxUq -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCqK] \u [] GHC.Classes./= $dEq_sfCqK; } in
        let {
          sat_sfCqL [Occ=Once]
            :: Data.Semigroup.First a_afxUq
               -> Data.Semigroup.First a_afxUq -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCqK] \u [] GHC.Classes.== $dEq_sfCqK;
        } in  GHC.Classes.C:Eq [sat_sfCqL sat_sfCqM];

Data.Semigroup.$fOrdFirst_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.First a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCqN]
        let {
          sat_sfCqO [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afxUY
          [LclId] =
              [$dOrd_sfCqN] \u [] GHC.Classes.$p1Ord $dOrd_sfCqN;
        } in  Data.Semigroup.$fEqFirst sat_sfCqO;

Data.Semigroup.$fOrdFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfCqP]
        let {
          sat_sfCqX [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> Data.Semigroup.First a_afxUY
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.min $dOrd_sfCqP; } in
        let {
          sat_sfCqW [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> Data.Semigroup.First a_afxUY
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.max $dOrd_sfCqP; } in
        let {
          sat_sfCqV [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.>= $dOrd_sfCqP; } in
        let {
          sat_sfCqU [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.> $dOrd_sfCqP; } in
        let {
          sat_sfCqT [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.<= $dOrd_sfCqP; } in
        let {
          sat_sfCqS [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.< $dOrd_sfCqP; } in
        let {
          sat_sfCqR [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCqP] \u [] GHC.Classes.compare $dOrd_sfCqP; } in
        let {
          sat_sfCqQ [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.First a_afxUY)
          [LclId] =
              [$dOrd_sfCqP] \u [] Data.Semigroup.$fOrdFirst_$cp1Ord $dOrd_sfCqP;
        } in 
          GHC.Classes.C:Ord [sat_sfCqQ
                             sat_sfCqR
                             sat_sfCqS
                             sat_sfCqT
                             sat_sfCqU
                             sat_sfCqV
                             sat_sfCqW
                             sat_sfCqX];

Data.Semigroup.$fBoundedFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfCqY]
        let {
          sat_sfCr0 [Occ=Once] :: Data.Semigroup.First a_afxU8
          [LclId] =
              [$dBounded_sfCqY] \u [] GHC.Enum.maxBound $dBounded_sfCqY; } in
        let {
          sat_sfCqZ [Occ=Once] :: Data.Semigroup.First a_afxU8
          [LclId] =
              [$dBounded_sfCqY] \u [] GHC.Enum.minBound $dBounded_sfCqY;
        } in  GHC.Enum.C:Bounded [sat_sfCqZ sat_sfCr0];

Data.Semigroup.$fGeneric1Arg_$cto1
  :: forall a1 a2.
     GHC.Generics.Rep1 (Data.Semigroup.Arg a1) a2
     -> Data.Semigroup.Arg a1 a2
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sfCr1]
        case ds_sfCr1 of {
          GHC.Generics.:*: ds1_sfCr3 [Occ=Once] ds2_sfCr4 [Occ=Once] ->
              Data.Semigroup.Arg [ds1_sfCr3 ds2_sfCr4];
        };

Data.Semigroup.$fGeneric1Arg1
  :: forall a1 a2.
     Data.Semigroup.Arg a1 a2
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Arg" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R a1)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              GHC.Generics.Par1)
          a2
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_sfCr5]
        case x_sfCr5 of {
          Data.Semigroup.Arg g1_sfCr7 [Occ=Once] g2_sfCr8 [Occ=Once] ->
              GHC.Generics.:*: [g1_sfCr7 g2_sfCr8];
        };

Data.Semigroup.$fGeneric1Arg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic1 (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Arg1
                                            Data.Semigroup.$fGeneric1Arg_$cto1];

Data.Semigroup.$fGenericArg_$cto
  :: forall a b x.
     GHC.Generics.Rep (Data.Semigroup.Arg a b) x
     -> Data.Semigroup.Arg a b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sfCr9]
        case ds_sfCr9 of {
          GHC.Generics.:*: ds1_sfCrb [Occ=Once] ds2_sfCrc [Occ=Once] ->
              Data.Semigroup.Arg [ds1_sfCrb ds2_sfCrc];
        };

Data.Semigroup.$fGenericArg1
  :: forall a b x.
     Data.Semigroup.Arg a b
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Arg" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R a)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.K1 GHC.Generics.R b))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x1_sfCrd]
        case x1_sfCrd of {
          Data.Semigroup.Arg g1_sfCrf [Occ=Once] g2_sfCrg [Occ=Once] ->
              GHC.Generics.:*: [g1_sfCrf g2_sfCrg];
        };

Data.Semigroup.$fGenericArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. GHC.Generics.Generic (Data.Semigroup.Arg a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericArg1
                                           Data.Semigroup.$fGenericArg_$cto];

Data.Semigroup.$fDataArg_$cgunfold
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (c :: * -> *).
     (forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCrh $dData1_sfCri k_sfCrj z_sfCrk ds_sfCrl]
        let {
          sat_sfCrn [Occ=Once]
            :: c_afxOm (b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
          [LclId] =
              [$dData_sfCrh k_sfCrj z_sfCrk] \u []
                  let {
                    sat_sfCrm [Occ=Once]
                      :: c_afxOm (a_afxNW
                                  -> b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
                    [LclId] =
                        [z_sfCrk] \u [] z_sfCrk Data.Semigroup.Arg;
                  } in  k_sfCrj $dData_sfCrh sat_sfCrm;
        } in  k_sfCrj $dData1_sfCri sat_sfCrn;

Data.Semigroup.$fDataArg_$cgfoldl
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (c :: * -> *).
     (forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Arg a b
     -> c (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCro $dData1_sfCrp k_sfCrq z_sfCrr ds_sfCrs]
        case ds_sfCrs of {
          Data.Semigroup.Arg a1_sfCru [Occ=Once] a2_sfCrv [Occ=Once] ->
              let {
                sat_sfCrx [Occ=Once]
                  :: c_afxO7 (b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
                [LclId] =
                    [$dData_sfCro k_sfCrq z_sfCrr a1_sfCru] \u []
                        let {
                          sat_sfCrw [Occ=Once]
                            :: c_afxO7 (a_afxNW
                                        -> b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
                          [LclId] =
                              [z_sfCrr] \u [] z_sfCrr Data.Semigroup.Arg;
                        } in  k_sfCrq $dData_sfCro sat_sfCrw a1_sfCru;
              } in  k_sfCrq $dData1_sfCrp sat_sfCrx a2_sfCrv;
        };

Data.Semigroup.$fDataArg6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Arg"#;

Data.Semigroup.$fDataArg9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataArg6;

Data.Semigroup.$fReadArg_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataArg9];

Data.Semigroup.$fReadArg1
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Semigroup.Arg a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfCry $dRead1_sfCrz eta_sfCrA eta1_sfCrB]
        let {
          sat_sfCrQ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Arg a_afxN6 b_afxN7)
          [LclId] =
              [$dRead_sfCry $dRead1_sfCrz] \r [c_sfCrC eta2_sfCrD]
                  case c_sfCrC of {
                    GHC.Types.I# x_sfCrF [Occ=Once] ->
                        case <=# [x_sfCrF 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCrN [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b2_i815E
                                [LclId] =
                                    [$dRead_sfCry $dRead1_sfCrz eta2_sfCrD] \r [a1_sfCrH]
                                        let {
                                          sat_sfCrM [Occ=Once]
                                            :: a_afxN6 -> Text.ParserCombinators.ReadP.P b2_i815E
                                          [LclId] =
                                              [$dRead1_sfCrz eta2_sfCrD] \r [a2_sfCrI]
                                                  let {
                                                    sat_sfCrL [Occ=Once]
                                                      :: b_afxN7
                                                         -> Text.ParserCombinators.ReadP.P b2_i815E
                                                    [LclId] =
                                                        [eta2_sfCrD a2_sfCrI] \r [a3_sfCrJ]
                                                            let {
                                                              sat_sfCrK [Occ=Once]
                                                                :: Data.Semigroup.Arg
                                                                     a_afxN6 b_afxN7
                                                              [LclId] =
                                                                  CCCS Data.Semigroup.Arg! [a2_sfCrI
                                                                                            a3_sfCrJ];
                                                            } in  eta2_sfCrD sat_sfCrK;
                                                  } in 
                                                    GHC.Read.readPrec
                                                        $dRead1_sfCrz
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCrL;
                                        } in 
                                          GHC.Read.readPrec
                                              $dRead_sfCry Data.Semigroup.$fReadArg2 sat_sfCrM;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Semigroup.$fReadArg_lexeme sat_sfCrN
                                of
                                { Unit# ww1_sfCrP [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCrP];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCrQ eta_sfCrA eta1_sfCrB;

Data.Semigroup.$fReadArg_$creadsPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Arg a b)
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfCrR $dRead1_sfCrS n_sfCrT]
        let {
          sat_sfCrU [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Semigroup.Arg a_XfyaI b_XfyaK)
          [LclId] =
              [$dRead_sfCrR $dRead1_sfCrS n_sfCrT] \u []
                  Data.Semigroup.$fReadArg1
                      $dRead_sfCrR
                      $dRead1_sfCrS
                      n_sfCrT
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCrU;

Data.Semigroup.$fReadArg_$creadListPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Arg a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfCrV $dRead1_sfCrW]
        let {
          sat_sfCrX [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Arg a_XfyaG b_XfyaI)
          [LclId] =
              [$dRead_sfCrV $dRead1_sfCrW] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadArg1 $dRead_sfCrV $dRead1_sfCrW eta_B2 eta_B1;
        } in  GHC.Read.list sat_sfCrX;

Data.Semigroup.$fReadArg_$creadList
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Arg a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfCrY $dRead1_sfCrZ]
        let {
          sat_sfCs1 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Arg a_XfyaH b_XfyaJ]
          [LclId] =
              [$dRead_sfCrY $dRead1_sfCrZ] \u []
                  let {
                    sat_sfCs0 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Arg a_XfyaH b_XfyaJ)
                    [LclId] =
                        [$dRead_sfCrY $dRead1_sfCrZ] \r [eta_B2 eta_B1]
                            Data.Semigroup.$fReadArg1 $dRead_sfCrY $dRead1_sfCrZ eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sfCs0
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCs1;

Data.Semigroup.$fReadArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Read.Read (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sfCs2 $dRead1_sfCs3]
        let {
          sat_sfCs7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Arg a_XfyaF b_XfyaH]
          [LclId] =
              [$dRead_sfCs2 $dRead1_sfCs3] \u []
                  Data.Semigroup.$fReadArg_$creadListPrec
                      $dRead_sfCs2 $dRead1_sfCs3; } in
        let {
          sat_sfCs6 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Arg a_XfyaF b_XfyaH)
          [LclId] =
              [$dRead_sfCs2 $dRead1_sfCs3] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadArg1
                      $dRead_sfCs2 $dRead1_sfCs3 eta_B2 eta_B1; } in
        let {
          sat_sfCs5 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Arg a_XfyaF b_XfyaH]
          [LclId] =
              [$dRead_sfCs2 $dRead1_sfCs3] \u []
                  Data.Semigroup.$fReadArg_$creadList
                      $dRead_sfCs2 $dRead1_sfCs3; } in
        let {
          sat_sfCs4 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Arg a_XfyaF b_XfyaH)
          [LclId] =
              [$dRead_sfCs2 $dRead1_sfCs3] \r [eta_B1]
                  Data.Semigroup.$fReadArg_$creadsPrec
                      $dRead_sfCs2 $dRead1_sfCs3 eta_B1;
        } in  GHC.Read.C:Read [sat_sfCs4 sat_sfCs5 sat_sfCs6 sat_sfCs7];

Data.Semigroup.$fShowArg1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Arg "#;

Data.Semigroup.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Prim.Int# -> a -> b -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCs8 w1_sfCs9 ww_sfCsa ww1_sfCsb ww2_sfCsc]
        let {
          f_sfCsd [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfCs8 ww1_sfCsb] \u []
                  GHC.Show.showsPrec
                      w_sfCs8 Data.Semigroup.$fReadArg2 ww1_sfCsb; } in
        let {
          g_sfCse [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sfCs9 ww2_sfCsc] \u []
                  GHC.Show.showsPrec w1_sfCs9 Data.Semigroup.$fReadArg2 ww2_sfCsc;
        } in 
          case >=# [ww_sfCsa 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCsk [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCsd g_sfCse] \r [x_sfCsg]
                          let {
                            sat_sfCsj [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCsd g_sfCse x_sfCsg] \u []
                                    let {
                                      sat_sfCsh [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sfCse x_sfCsg] \u [] g_sfCse x_sfCsg; } in
                                    let {
                                      sat_sfCsi [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          CCCS :! [GHC.Show.showSpace1 sat_sfCsh];
                                    } in  f_sfCsd sat_sfCsi;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowArg1 sat_sfCsj;
                } in  sat_sfCsk;
            1# ->
                let {
                  sat_sfCsr [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCsd g_sfCse] \r [x_sfCsl]
                          let {
                            sat_sfCsq [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCsd g_sfCse x_sfCsl] \u []
                                    let {
                                      sat_sfCsp [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCsd g_sfCse x_sfCsl] \u []
                                              let {
                                                sat_sfCsn [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sfCse x_sfCsl] \u []
                                                        let {
                                                          sat_sfCsm [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sfCsl];
                                                        } in  g_sfCse sat_sfCsm; } in
                                              let {
                                                sat_sfCso [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.showSpace1 sat_sfCsn];
                                              } in  f_sfCsd sat_sfCso;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowArg1 sat_sfCsp;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCsq];
                } in  sat_sfCsr;
          };

Data.Semigroup.$fShowArg_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Types.Int -> Data.Semigroup.Arg a b -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sfCss w1_sfCst w2_sfCsu w3_sfCsv]
        case w2_sfCsu of {
          GHC.Types.I# ww1_sfCsx [Occ=Once] ->
              case w3_sfCsv of {
                Data.Semigroup.Arg ww3_sfCsz [Occ=Once] ww4_sfCsA [Occ=Once] ->
                    Data.Semigroup.$w$cshowsPrec
                        w_sfCss w1_sfCst ww1_sfCsx ww3_sfCsz ww4_sfCsA;
              };
        };

Data.Semigroup.$fShowArg_$cshow
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     Data.Semigroup.Arg a b -> GHC.Base.String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCsB $dShow1_sfCsC x_sfCsD]
        case x_sfCsD of {
          Data.Semigroup.Arg ww1_sfCsF [Occ=Once] ww2_sfCsG [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec
                  $dShow_sfCsB $dShow1_sfCsC 0# ww1_sfCsF ww2_sfCsG GHC.Types.[];
        };

Data.Semigroup.$fShowArg_$cshowList
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     [Data.Semigroup.Arg a b] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCsH $dShow1_sfCsI ls_sfCsJ s_sfCsK]
        let {
          sat_sfCsP [Occ=Once]
            :: Data.Semigroup.Arg a_afxMx b_afxMy -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCsH $dShow1_sfCsI] \r [w_sfCsL]
                  case w_sfCsL of {
                    Data.Semigroup.Arg ww1_sfCsN [Occ=Once] ww2_sfCsO [Occ=Once] ->
                        Data.Semigroup.$w$cshowsPrec
                            $dShow_sfCsH $dShow1_sfCsI 0# ww1_sfCsN ww2_sfCsO;
                  };
        } in  GHC.Show.showList__ sat_sfCsP ls_sfCsJ s_sfCsK;

Data.Semigroup.$fShowArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Show.Show (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfCsQ $dShow1_sfCsR]
        let {
          sat_sfCsU [Occ=Once]
            :: [Data.Semigroup.Arg a_afxMx b_afxMy] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCsQ $dShow1_sfCsR] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowArg_$cshowList
                      $dShow_sfCsQ $dShow1_sfCsR eta_B2 eta_B1; } in
        let {
          sat_sfCsT [Occ=Once]
            :: Data.Semigroup.Arg a_afxMx b_afxMy -> GHC.Base.String
          [LclId] =
              [$dShow_sfCsQ $dShow1_sfCsR] \r [eta_B1]
                  Data.Semigroup.$fShowArg_$cshow
                      $dShow_sfCsQ $dShow1_sfCsR eta_B1; } in
        let {
          sat_sfCsS [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Arg a_afxMx b_afxMy -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCsQ $dShow1_sfCsR] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowArg_$cshowsPrec
                      $dShow_sfCsQ $dShow1_sfCsR eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfCsS sat_sfCsT sat_sfCsU];

Data.Semigroup.$fGeneric1Max1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Max a
     -> GHC.Generics.Rep1 Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCsV] ds_sfCsV;

Data.Semigroup.$fGeneric1Max2
  :: forall a. Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCsW] x_sfCsW;

Data.Semigroup.$fGeneric1Max [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Max
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Max2
                                            Data.Semigroup.$fGeneric1Max1];

Data.Semigroup.$fGenericMax1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Max a) x
     -> GHC.Generics.Rep (Data.Semigroup.Max a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCsX] ds_sfCsX;

Data.Semigroup.$fGenericMax2
  :: forall a x. Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfCsY] x1_sfCsY;

Data.Semigroup.$fGenericMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Max a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericMax2
                                           Data.Semigroup.$fGenericMax1];

Data.Semigroup.$fDataMax_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Max a
     -> c (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCsZ k_sfCt0 z_sfCt1 ds_sfCt2]
        let {
          sat_sfCt3 [Occ=Once]
            :: c_afxHD (a_afxHu -> Data.Semigroup.Max a_afxHu)
          [LclId] =
              [z_sfCt1] \u [] z_sfCt1 Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfCt0 $dData_sfCsZ sat_sfCt3 ds_sfCt2;

Data.Semigroup.$fDataMax4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Max"#;

Data.Semigroup.$fDataMax7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataMax4;

Data.Semigroup.$fReadMax_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataMax7];

Data.Semigroup.$fReadMax3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMax"#;

Data.Semigroup.$fReadMax2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadMax3;

Data.Semigroup.$fReadMax1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Max a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCt4]
        let {
          lvl33_sfCt5 [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afxGF
          [LclId] =
              [$dRead_sfCt4] \u []
                  GHC.Read.readPrec
                      $dRead_sfCt4 Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfCt6 [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afxGF
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfCt5] \r [ds1_sfCt7] lvl33_sfCt5; } in
        let {
          sat_sfCtr [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Max a_afxGF)
          [LclId] =
              [ds_sfCt6] \r [c_sfCt8 eta_sfCt9]
                  case c_sfCt8 of {
                    GHC.Types.I# x_sfCtb [Occ=Once] ->
                        case <=# [x_sfCtb 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCto [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfCt6 eta_sfCt9] \r [a1_sfCtd]
                                        let {
                                          sat_sfCtl [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfCt6 eta_sfCt9] \r [a2_sfCte]
                                                  let {
                                                    sat_sfCtk [Occ=Once]
                                                      :: a_afxGF
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfCt9] \r [a3_sfCtf]
                                                            let {
                                                              sat_sfCth [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfCt9 a3_sfCtf] \r [a4_sfCtg]
                                                                      eta_sfCt9 a3_sfCtf;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfCth
                                                              of
                                                              { Unit# ww1_sfCtj [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfCtj];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadMax2
                                                        ds_sfCt6
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCtk;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfCtl
                                          of
                                          { Unit# ww1_sfCtn [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfCtn];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Semigroup.$fReadMax_lexeme sat_sfCto
                                of
                                { Unit# ww1_sfCtq [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCtq];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCtr;

Data.Semigroup.$fReadMax_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Max a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCts]
        let {
          ds_sfCtt [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Max a_Xfy4P -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfCts] \u [] Data.Semigroup.$fReadMax1 $dRead_sfCts; } in
        let {
          sat_sfCtw [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Max a_Xfy4P)
          [LclId] =
              [ds_sfCtt] \r [n_sfCtu]
                  let {
                    sat_sfCtv [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Max a_Xfy4P)
                    [LclId] =
                        [ds_sfCtt n_sfCtu] \u []
                            ds_sfCtt
                                n_sfCtu Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfCtv;
        } in  sat_sfCtw;

Data.Semigroup.$fReadMax_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Max a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCtx]
        let {
          sat_sfCty [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Max a_Xfy4N)
          [LclId] =
              [$dRead_sfCtx] \s [] Data.Semigroup.$fReadMax1 $dRead_sfCtx;
        } in  GHC.Read.list sat_sfCty;

Data.Semigroup.$fReadMax_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Max a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCtz]
        let {
          sat_sfCtB [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Max a_Xfy4O]
          [LclId] =
              [$dRead_sfCtz] \u []
                  let {
                    sat_sfCtA [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Max a_Xfy4O)
                    [LclId] =
                        [$dRead_sfCtz] \s [] Data.Semigroup.$fReadMax1 $dRead_sfCtz;
                  } in 
                    GHC.Read.list
                        sat_sfCtA
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCtB;

Data.Semigroup.$fReadMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfCtC]
        let {
          sat_sfCtG [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Max a_Xfy4M]
          [LclId] =
              [$dRead_sfCtC] \u []
                  Data.Semigroup.$fReadMax_$creadListPrec $dRead_sfCtC; } in
        let {
          sat_sfCtF [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Max a_Xfy4M)
          [LclId] =
              [$dRead_sfCtC] \u [] Data.Semigroup.$fReadMax1 $dRead_sfCtC; } in
        let {
          sat_sfCtE [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Max a_Xfy4M]
          [LclId] =
              [$dRead_sfCtC] \u []
                  Data.Semigroup.$fReadMax_$creadList $dRead_sfCtC; } in
        let {
          sat_sfCtD [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Max a_Xfy4M)
          [LclId] =
              [$dRead_sfCtC] \u []
                  Data.Semigroup.$fReadMax_$creadsPrec $dRead_sfCtC;
        } in  GHC.Read.C:Read [sat_sfCtD sat_sfCtE sat_sfCtF sat_sfCtG];

Data.Semigroup.$fShowMax2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Max {"#;

Data.Semigroup.$fShowMax1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMax = "#;

Data.Semigroup.$w$cshowsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Max a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCtH ww_sfCtI w1_sfCtJ]
        let {
          f_sfCtK [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfCtH w1_sfCtJ] \u []
                  GHC.Show.showsPrec
                      w_sfCtH Data.Semigroup.$fFoldableOption7 w1_sfCtJ;
        } in 
          case >=# [ww_sfCtI 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCtQ [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCtK] \r [x_sfCtM]
                          let {
                            sat_sfCtP [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCtK x_sfCtM] \u []
                                    let {
                                      sat_sfCtO [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCtK x_sfCtM] \u []
                                              let {
                                                sat_sfCtN [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfCtM] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfCtM;
                                              } in  f_sfCtK sat_sfCtN;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMax1 sat_sfCtO;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowMax2 sat_sfCtP;
                } in  sat_sfCtQ;
            1# ->
                let {
                  sat_sfCtX [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCtK] \r [x_sfCtR]
                          let {
                            sat_sfCtW [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCtK x_sfCtR] \u []
                                    let {
                                      sat_sfCtV [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCtK x_sfCtR] \u []
                                              let {
                                                sat_sfCtU [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfCtK x_sfCtR] \u []
                                                        let {
                                                          sat_sfCtT [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfCtR] \u []
                                                                  let {
                                                                    sat_sfCtS [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfCtR];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfCtS;
                                                        } in  f_sfCtK sat_sfCtT;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowMax1 sat_sfCtU;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMax2 sat_sfCtV;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCtW];
                } in  sat_sfCtX;
          };

Data.Semigroup.$fShowMax_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Max a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCtY w1_sfCtZ w2_sfCu0]
        case w1_sfCtZ of {
          GHC.Types.I# ww1_sfCu2 [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec3 w_sfCtY ww1_sfCu2 w2_sfCu0;
        };

Data.Semigroup.$fShowMax_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Max a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCu3 x_sfCu4]
        let {
          sat_sfCu6 [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfCu3 x_sfCu4] \u []
                  let {
                    sat_sfCu5 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfCu3 x_sfCu4] \u []
                            GHC.Show.showsPrec
                                $dShow_sfCu3
                                Data.Semigroup.$fFoldableOption7
                                x_sfCu4
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowMax1 sat_sfCu5;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowMax2 sat_sfCu6;

Data.Semigroup.$fShowMax_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Max a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCu7 ls_sfCu8 s_sfCu9]
        let {
          sat_sfCub [Occ=Once]
            :: Data.Semigroup.Max a_afxGa -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCu7] \r [w_sfCua]
                  Data.Semigroup.$w$cshowsPrec3 $dShow_sfCu7 0# w_sfCua;
        } in  GHC.Show.showList__ sat_sfCub ls_sfCu8 s_sfCu9;

Data.Semigroup.$fShowMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfCuc]
        let {
          sat_sfCuf [Occ=Once]
            :: [Data.Semigroup.Max a_afxGa] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCuc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMax_$cshowList
                      $dShow_sfCuc eta_B2 eta_B1; } in
        let {
          sat_sfCue [Occ=Once]
            :: Data.Semigroup.Max a_afxGa -> GHC.Base.String
          [LclId] =
              [$dShow_sfCuc] \r [eta_B1]
                  Data.Semigroup.$fShowMax_$cshow $dShow_sfCuc eta_B1; } in
        let {
          sat_sfCud [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Max a_afxGa -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCuc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMax_$cshowsPrec $dShow_sfCuc eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfCud sat_sfCue sat_sfCuf];

Data.Semigroup.$fEqMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfCug]
        let {
          sat_sfCui [Occ=Once]
            :: Data.Semigroup.Max a_afxDN
               -> Data.Semigroup.Max a_afxDN -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCug] \u [] GHC.Classes./= $dEq_sfCug; } in
        let {
          sat_sfCuh [Occ=Once]
            :: Data.Semigroup.Max a_afxDN
               -> Data.Semigroup.Max a_afxDN -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCug] \u [] GHC.Classes.== $dEq_sfCug;
        } in  GHC.Classes.C:Eq [sat_sfCuh sat_sfCui];

Data.Semigroup.$fOrdMax_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Max a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCuj]
        let {
          sat_sfCuk [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afxEl
          [LclId] =
              [$dOrd_sfCuj] \u [] GHC.Classes.$p1Ord $dOrd_sfCuj;
        } in  Data.Semigroup.$fEqMax sat_sfCuk;

Data.Semigroup.$fOrdMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfCul]
        let {
          sat_sfCut [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> Data.Semigroup.Max a_afxEl
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.min $dOrd_sfCul; } in
        let {
          sat_sfCus [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> Data.Semigroup.Max a_afxEl
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.max $dOrd_sfCul; } in
        let {
          sat_sfCur [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.>= $dOrd_sfCul; } in
        let {
          sat_sfCuq [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.> $dOrd_sfCul; } in
        let {
          sat_sfCup [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.<= $dOrd_sfCul; } in
        let {
          sat_sfCuo [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.< $dOrd_sfCul; } in
        let {
          sat_sfCun [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCul] \u [] GHC.Classes.compare $dOrd_sfCul; } in
        let {
          sat_sfCum [Occ=Once] :: GHC.Classes.Eq (Data.Semigroup.Max a_afxEl)
          [LclId] =
              [$dOrd_sfCul] \u [] Data.Semigroup.$fOrdMax_$cp1Ord $dOrd_sfCul;
        } in 
          GHC.Classes.C:Ord [sat_sfCum
                             sat_sfCun
                             sat_sfCuo
                             sat_sfCup
                             sat_sfCuq
                             sat_sfCur
                             sat_sfCus
                             sat_sfCut];

Data.Semigroup.$fBoundedMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfCuu]
        let {
          sat_sfCuw [Occ=Once] :: Data.Semigroup.Max a_afxDv
          [LclId] =
              [$dBounded_sfCuu] \u [] GHC.Enum.maxBound $dBounded_sfCuu; } in
        let {
          sat_sfCuv [Occ=Once] :: Data.Semigroup.Max a_afxDv
          [LclId] =
              [$dBounded_sfCuu] \u [] GHC.Enum.minBound $dBounded_sfCuu;
        } in  GHC.Enum.C:Bounded [sat_sfCuv sat_sfCuw];

Data.Semigroup.$fMonoidMax_$cmconcat
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     [Data.Semigroup.Max a] -> Data.Semigroup.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><L,1*U(1*U,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCux $dBounded_sfCuy eta_sfCuz]
        let {
          z_sfCuA [Occ=OnceL] :: a_XfzuM
          [LclId] =
              [$dBounded_sfCuy] \u [] GHC.Enum.minBound $dBounded_sfCuy; } in
        let {
          go_sfCuB [Occ=LoopBreaker]
            :: [Data.Semigroup.Max a_XfzuM] -> Data.Semigroup.Max a_XfzuM
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_sfCux z_sfCuA go_sfCuB] \r [ds_sfCuC]
                  case ds_sfCuC of {
                    [] -> z_sfCuA;
                    : y_sfCuE [Occ=Once] ys_sfCuF [Occ=Once] ->
                        let {
                          sat_sfCuG [Occ=Once] :: a_XfzuM
                          [LclId] =
                              [go_sfCuB ys_sfCuF] \u [] go_sfCuB ys_sfCuF;
                        } in  GHC.Classes.max $dOrd_sfCux y_sfCuE sat_sfCuG;
                  };
        } in  go_sfCuB eta_sfCuz;

Data.Semigroup.$fMonoidMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     GHC.Base.Monoid (Data.Semigroup.Max a)
[GblId[DFunId], Arity=2, Str=<L,U(A,A,A,A,A,A,U,A)><L,U(U,A)>m] =
    [] \r [$dOrd_sfCuH $dBounded_sfCuI]
        let {
          sat_sfCuM [Occ=Once]
            :: [Data.Semigroup.Max a_XfzuG] -> Data.Semigroup.Max a_XfzuG
          [LclId] =
              [$dOrd_sfCuH $dBounded_sfCuI] \r [eta_B1]
                  Data.Semigroup.$fMonoidMax_$cmconcat
                      $dOrd_sfCuH $dBounded_sfCuI eta_B1; } in
        let {
          sat_sfCuL [Occ=Once]
            :: Data.Semigroup.Max a_XfzuG
               -> Data.Semigroup.Max a_XfzuG -> Data.Semigroup.Max a_XfzuG
          [LclId] =
              [$dOrd_sfCuH] \u [] GHC.Classes.max $dOrd_sfCuH; } in
        let {
          sat_sfCuK [Occ=Once] :: Data.Semigroup.Max a_XfzuG
          [LclId] =
              [$dBounded_sfCuI] \u [] GHC.Enum.minBound $dBounded_sfCuI; } in
        let {
          sat_sfCuJ [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Max a_XfzuG)
          [LclId] =
              [$dOrd_sfCuH] \u [] Data.Semigroup.$fSemigroupMax $dOrd_sfCuH;
        } in  GHC.Base.C:Monoid [sat_sfCuJ sat_sfCuK sat_sfCuL sat_sfCuM];

Data.Semigroup.$fGeneric1Min1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Min a
     -> GHC.Generics.Rep1 Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCuN] ds_sfCuN;

Data.Semigroup.$fGeneric1Min2
  :: forall a. Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfCuO] x_sfCuO;

Data.Semigroup.$fGeneric1Min [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Min
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Min2
                                            Data.Semigroup.$fGeneric1Min1];

Data.Semigroup.$fGenericMin1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Min a) x
     -> GHC.Generics.Rep (Data.Semigroup.Min a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfCuP] ds_sfCuP;

Data.Semigroup.$fGenericMin2
  :: forall a x. Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfCuQ] x1_sfCuQ;

Data.Semigroup.$fGenericMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Min a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericMin2
                                           Data.Semigroup.$fGenericMin1];

Data.Semigroup.$fDataMin_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Min a
     -> c (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCuR k_sfCuS z_sfCuT ds_sfCuU]
        let {
          sat_sfCuV [Occ=Once]
            :: c_afxyB (a_afxys -> Data.Semigroup.Min a_afxys)
          [LclId] =
              [z_sfCuT] \u [] z_sfCuT Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfCuS $dData_sfCuR sat_sfCuV ds_sfCuU;

Data.Semigroup.$fDataMin4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Min"#;

Data.Semigroup.$fDataMin7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataMin4;

Data.Semigroup.$fReadMin_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataMin7];

Data.Semigroup.$fReadMin3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMin"#;

Data.Semigroup.$fReadMin2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadMin3;

Data.Semigroup.$fReadMin1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Min a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCuW]
        let {
          lvl33_sfCuX [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afxxD
          [LclId] =
              [$dRead_sfCuW] \u []
                  GHC.Read.readPrec
                      $dRead_sfCuW Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfCuY [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afxxD
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfCuX] \r [ds1_sfCuZ] lvl33_sfCuX; } in
        let {
          sat_sfCvj [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Min a_afxxD)
          [LclId] =
              [ds_sfCuY] \r [c_sfCv0 eta_sfCv1]
                  case c_sfCv0 of {
                    GHC.Types.I# x_sfCv3 [Occ=Once] ->
                        case <=# [x_sfCv3 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfCvg [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfCuY eta_sfCv1] \r [a1_sfCv5]
                                        let {
                                          sat_sfCvd [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfCuY eta_sfCv1] \r [a2_sfCv6]
                                                  let {
                                                    sat_sfCvc [Occ=Once]
                                                      :: a_afxxD
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfCv1] \r [a3_sfCv7]
                                                            let {
                                                              sat_sfCv9 [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfCv1 a3_sfCv7] \r [a4_sfCv8]
                                                                      eta_sfCv1 a3_sfCv7;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfCv9
                                                              of
                                                              { Unit# ww1_sfCvb [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfCvb];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadMin2
                                                        ds_sfCuY
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfCvc;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfCvd
                                          of
                                          { Unit# ww1_sfCvf [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfCvf];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Semigroup.$fReadMin_lexeme sat_sfCvg
                                of
                                { Unit# ww1_sfCvi [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfCvi];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfCvj;

Data.Semigroup.$fReadMin_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Min a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCvk]
        let {
          ds_sfCvl [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Min a_XfxWM -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfCvk] \u [] Data.Semigroup.$fReadMin1 $dRead_sfCvk; } in
        let {
          sat_sfCvo [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Min a_XfxWM)
          [LclId] =
              [ds_sfCvl] \r [n_sfCvm]
                  let {
                    sat_sfCvn [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Min a_XfxWM)
                    [LclId] =
                        [ds_sfCvl n_sfCvm] \u []
                            ds_sfCvl
                                n_sfCvm Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfCvn;
        } in  sat_sfCvo;

Data.Semigroup.$fReadMin_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Min a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCvp]
        let {
          sat_sfCvq [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Min a_XfxWK)
          [LclId] =
              [$dRead_sfCvp] \s [] Data.Semigroup.$fReadMin1 $dRead_sfCvp;
        } in  GHC.Read.list sat_sfCvq;

Data.Semigroup.$fReadMin_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Min a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfCvr]
        let {
          sat_sfCvt [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Min a_XfxWL]
          [LclId] =
              [$dRead_sfCvr] \u []
                  let {
                    sat_sfCvs [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Min a_XfxWL)
                    [LclId] =
                        [$dRead_sfCvr] \s [] Data.Semigroup.$fReadMin1 $dRead_sfCvr;
                  } in 
                    GHC.Read.list
                        sat_sfCvs
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfCvt;

Data.Semigroup.$fReadMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfCvu]
        let {
          sat_sfCvy [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Min a_XfxWJ]
          [LclId] =
              [$dRead_sfCvu] \u []
                  Data.Semigroup.$fReadMin_$creadListPrec $dRead_sfCvu; } in
        let {
          sat_sfCvx [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Min a_XfxWJ)
          [LclId] =
              [$dRead_sfCvu] \u [] Data.Semigroup.$fReadMin1 $dRead_sfCvu; } in
        let {
          sat_sfCvw [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Min a_XfxWJ]
          [LclId] =
              [$dRead_sfCvu] \u []
                  Data.Semigroup.$fReadMin_$creadList $dRead_sfCvu; } in
        let {
          sat_sfCvv [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Min a_XfxWJ)
          [LclId] =
              [$dRead_sfCvu] \u []
                  Data.Semigroup.$fReadMin_$creadsPrec $dRead_sfCvu;
        } in  GHC.Read.C:Read [sat_sfCvv sat_sfCvw sat_sfCvx sat_sfCvy];

Data.Semigroup.$fShowMin2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Min {"#;

Data.Semigroup.$fShowMin1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMin = "#;

Data.Semigroup.$w$cshowsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Min a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCvz ww_sfCvA w1_sfCvB]
        let {
          f_sfCvC [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfCvz w1_sfCvB] \u []
                  GHC.Show.showsPrec
                      w_sfCvz Data.Semigroup.$fFoldableOption7 w1_sfCvB;
        } in 
          case >=# [ww_sfCvA 11#] of {
            __DEFAULT ->
                let {
                  sat_sfCvI [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCvC] \r [x_sfCvE]
                          let {
                            sat_sfCvH [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCvC x_sfCvE] \u []
                                    let {
                                      sat_sfCvG [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCvC x_sfCvE] \u []
                                              let {
                                                sat_sfCvF [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfCvE] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfCvE;
                                              } in  f_sfCvC sat_sfCvF;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMin1 sat_sfCvG;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowMin2 sat_sfCvH;
                } in  sat_sfCvI;
            1# ->
                let {
                  sat_sfCvP [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfCvC] \r [x_sfCvJ]
                          let {
                            sat_sfCvO [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfCvC x_sfCvJ] \u []
                                    let {
                                      sat_sfCvN [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfCvC x_sfCvJ] \u []
                                              let {
                                                sat_sfCvM [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfCvC x_sfCvJ] \u []
                                                        let {
                                                          sat_sfCvL [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfCvJ] \u []
                                                                  let {
                                                                    sat_sfCvK [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfCvJ];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfCvK;
                                                        } in  f_sfCvC sat_sfCvL;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowMin1 sat_sfCvM;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMin2 sat_sfCvN;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfCvO];
                } in  sat_sfCvP;
          };

Data.Semigroup.$fShowMin_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Min a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCvQ w1_sfCvR w2_sfCvS]
        case w1_sfCvR of {
          GHC.Types.I# ww1_sfCvU [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec4 w_sfCvQ ww1_sfCvU w2_sfCvS;
        };

Data.Semigroup.$fShowMin_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Min a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCvV x_sfCvW]
        let {
          sat_sfCvY [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfCvV x_sfCvW] \u []
                  let {
                    sat_sfCvX [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfCvV x_sfCvW] \u []
                            GHC.Show.showsPrec
                                $dShow_sfCvV
                                Data.Semigroup.$fFoldableOption7
                                x_sfCvW
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowMin1 sat_sfCvX;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowMin2 sat_sfCvY;

Data.Semigroup.$fShowMin_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Min a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfCvZ ls_sfCw0 s_sfCw1]
        let {
          sat_sfCw3 [Occ=Once]
            :: Data.Semigroup.Min a_afxx8 -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCvZ] \r [w_sfCw2]
                  Data.Semigroup.$w$cshowsPrec4 $dShow_sfCvZ 0# w_sfCw2;
        } in  GHC.Show.showList__ sat_sfCw3 ls_sfCw0 s_sfCw1;

Data.Semigroup.$fShowMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfCw4]
        let {
          sat_sfCw7 [Occ=Once]
            :: [Data.Semigroup.Min a_afxx8] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCw4] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMin_$cshowList
                      $dShow_sfCw4 eta_B2 eta_B1; } in
        let {
          sat_sfCw6 [Occ=Once]
            :: Data.Semigroup.Min a_afxx8 -> GHC.Base.String
          [LclId] =
              [$dShow_sfCw4] \r [eta_B1]
                  Data.Semigroup.$fShowMin_$cshow $dShow_sfCw4 eta_B1; } in
        let {
          sat_sfCw5 [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Min a_afxx8 -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfCw4] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMin_$cshowsPrec $dShow_sfCw4 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfCw5 sat_sfCw6 sat_sfCw7];

Data.Semigroup.$fEqMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfCw8]
        let {
          sat_sfCwa [Occ=Once]
            :: Data.Semigroup.Min a_afxuL
               -> Data.Semigroup.Min a_afxuL -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCw8] \u [] GHC.Classes./= $dEq_sfCw8; } in
        let {
          sat_sfCw9 [Occ=Once]
            :: Data.Semigroup.Min a_afxuL
               -> Data.Semigroup.Min a_afxuL -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfCw8] \u [] GHC.Classes.== $dEq_sfCw8;
        } in  GHC.Classes.C:Eq [sat_sfCw9 sat_sfCwa];

Data.Semigroup.$fOrdMin_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Min a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCwb]
        let {
          sat_sfCwc [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afxvj
          [LclId] =
              [$dOrd_sfCwb] \u [] GHC.Classes.$p1Ord $dOrd_sfCwb;
        } in  Data.Semigroup.$fEqMin sat_sfCwc;

Data.Semigroup.$fOrdMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfCwd]
        let {
          sat_sfCwl [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> Data.Semigroup.Min a_afxvj
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.min $dOrd_sfCwd; } in
        let {
          sat_sfCwk [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> Data.Semigroup.Min a_afxvj
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.max $dOrd_sfCwd; } in
        let {
          sat_sfCwj [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.>= $dOrd_sfCwd; } in
        let {
          sat_sfCwi [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.> $dOrd_sfCwd; } in
        let {
          sat_sfCwh [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.<= $dOrd_sfCwd; } in
        let {
          sat_sfCwg [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.< $dOrd_sfCwd; } in
        let {
          sat_sfCwf [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfCwd] \u [] GHC.Classes.compare $dOrd_sfCwd; } in
        let {
          sat_sfCwe [Occ=Once] :: GHC.Classes.Eq (Data.Semigroup.Min a_afxvj)
          [LclId] =
              [$dOrd_sfCwd] \u [] Data.Semigroup.$fOrdMin_$cp1Ord $dOrd_sfCwd;
        } in 
          GHC.Classes.C:Ord [sat_sfCwe
                             sat_sfCwf
                             sat_sfCwg
                             sat_sfCwh
                             sat_sfCwi
                             sat_sfCwj
                             sat_sfCwk
                             sat_sfCwl];

Data.Semigroup.$fBoundedMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfCwm]
        let {
          sat_sfCwo [Occ=Once] :: Data.Semigroup.Min a_afxut
          [LclId] =
              [$dBounded_sfCwm] \u [] GHC.Enum.maxBound $dBounded_sfCwm; } in
        let {
          sat_sfCwn [Occ=Once] :: Data.Semigroup.Min a_afxut
          [LclId] =
              [$dBounded_sfCwm] \u [] GHC.Enum.minBound $dBounded_sfCwm;
        } in  GHC.Enum.C:Bounded [sat_sfCwn sat_sfCwo];

Data.Semigroup.$fMonoidMin_$cmconcat
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     [Data.Semigroup.Min a] -> Data.Semigroup.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><L,1*U(A,1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfCwp $dBounded_sfCwq eta_sfCwr]
        let {
          z_sfCws [Occ=OnceL] :: a_XfzEk
          [LclId] =
              [$dBounded_sfCwq] \u [] GHC.Enum.maxBound $dBounded_sfCwq; } in
        let {
          go_sfCwt [Occ=LoopBreaker]
            :: [Data.Semigroup.Min a_XfzEk] -> Data.Semigroup.Min a_XfzEk
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_sfCwp z_sfCws go_sfCwt] \r [ds_sfCwu]
                  case ds_sfCwu of {
                    [] -> z_sfCws;
                    : y_sfCww [Occ=Once] ys_sfCwx [Occ=Once] ->
                        let {
                          sat_sfCwy [Occ=Once] :: a_XfzEk
                          [LclId] =
                              [go_sfCwt ys_sfCwx] \u [] go_sfCwt ys_sfCwx;
                        } in  GHC.Classes.min $dOrd_sfCwp y_sfCww sat_sfCwy;
                  };
        } in  go_sfCwt eta_sfCwr;

Data.Semigroup.$fMonoidMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     GHC.Base.Monoid (Data.Semigroup.Min a)
[GblId[DFunId], Arity=2, Str=<L,U(A,A,A,A,A,A,A,U)><L,U(A,U)>m] =
    [] \r [$dOrd_sfCwz $dBounded_sfCwA]
        let {
          sat_sfCwE [Occ=Once]
            :: [Data.Semigroup.Min a_XfzEe] -> Data.Semigroup.Min a_XfzEe
          [LclId] =
              [$dOrd_sfCwz $dBounded_sfCwA] \r [eta_B1]
                  Data.Semigroup.$fMonoidMin_$cmconcat
                      $dOrd_sfCwz $dBounded_sfCwA eta_B1; } in
        let {
          sat_sfCwD [Occ=Once]
            :: Data.Semigroup.Min a_XfzEe
               -> Data.Semigroup.Min a_XfzEe -> Data.Semigroup.Min a_XfzEe
          [LclId] =
              [$dOrd_sfCwz] \u [] GHC.Classes.min $dOrd_sfCwz; } in
        let {
          sat_sfCwC [Occ=Once] :: Data.Semigroup.Min a_XfzEe
          [LclId] =
              [$dBounded_sfCwA] \u [] GHC.Enum.maxBound $dBounded_sfCwA; } in
        let {
          sat_sfCwB [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Min a_XfzEe)
          [LclId] =
              [$dOrd_sfCwz] \u [] Data.Semigroup.$fSemigroupMin $dOrd_sfCwz;
        } in  GHC.Base.C:Monoid [sat_sfCwB sat_sfCwC sat_sfCwD sat_sfCwE];

Data.Semigroup.getMin :: forall a. Data.Semigroup.Min a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Min2 eta_B1;

Data.Semigroup.$fMonadFixMin_$cmfix
  :: forall a. (a -> Data.Semigroup.Min a) -> Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfCwF]
        let {
          x_sfCwG [Occ=LoopBreaker] :: Data.Semigroup.Min a_afz9s
          [LclId] =
              [f_sfCwF x_sfCwG] \u [] f_sfCwF x_sfCwG;
        } in  x_sfCwG;

Data.Semigroup.$fMonadFixMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadMin
                                                 Data.Semigroup.$fMonadFixMin_$cmfix];

Data.Semigroup.$fEnumMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfCwH]
        let {
          sat_sfCx1 [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs
               -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfCwH] \r [ds_sfCwY ds1_sfCwZ ds2_sfCx0]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfCwH ds_sfCwY ds1_sfCwZ ds2_sfCx0; } in
        let {
          sat_sfCwX [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfCwH] \r [ds_sfCwV ds1_sfCwW]
                  GHC.Enum.enumFromTo $dEnum_sfCwH ds_sfCwV ds1_sfCwW; } in
        let {
          sat_sfCwU [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfCwH] \r [ds_sfCwS ds1_sfCwT]
                  GHC.Enum.enumFromThen $dEnum_sfCwH ds_sfCwS ds1_sfCwT; } in
        let {
          sat_sfCwR [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfCwH] \r [ds_sfCwQ]
                  GHC.Enum.enumFrom $dEnum_sfCwH ds_sfCwQ; } in
        let {
          sat_sfCwP [Occ=Once] :: Data.Semigroup.Min a_XfzFs -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfCwH] \r [eta_sfCwO]
                  GHC.Enum.fromEnum $dEnum_sfCwH eta_sfCwO; } in
        let {
          sat_sfCwN [Occ=Once] :: GHC.Types.Int -> Data.Semigroup.Min a_XfzFs
          [LclId] =
              [$dEnum_sfCwH] \r [eta_sfCwM]
                  GHC.Enum.toEnum $dEnum_sfCwH eta_sfCwM; } in
        let {
          sat_sfCwL [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs -> Data.Semigroup.Min a_XfzFs
          [LclId] =
              [$dEnum_sfCwH] \r [ds_sfCwK]
                  GHC.Enum.pred $dEnum_sfCwH ds_sfCwK; } in
        let {
          sat_sfCwJ [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs -> Data.Semigroup.Min a_XfzFs
          [LclId] =
              [$dEnum_sfCwH] \r [ds_sfCwI] GHC.Enum.succ $dEnum_sfCwH ds_sfCwI;
        } in 
          GHC.Enum.C:Enum [sat_sfCwJ
                           sat_sfCwL
                           sat_sfCwN
                           sat_sfCwP
                           sat_sfCwR
                           sat_sfCwU
                           sat_sfCwX
                           sat_sfCx1];

Data.Semigroup.getMax :: forall a. Data.Semigroup.Max a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Max2 eta_B1;

Data.Semigroup.$fMonadFixMax_$cmfix
  :: forall a. (a -> Data.Semigroup.Max a) -> Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfCx2]
        let {
          x_sfCx3 [Occ=LoopBreaker] :: Data.Semigroup.Max a_afz0T
          [LclId] =
              [f_sfCx2 x_sfCx3] \u [] f_sfCx2 x_sfCx3;
        } in  x_sfCx3;

Data.Semigroup.$fMonadFixMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadMax
                                                 Data.Semigroup.$fMonadFixMax_$cmfix];

Data.Semigroup.$fEnumMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfCx4]
        let {
          sat_sfCxo [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1
               -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfCx4] \r [ds_sfCxl ds1_sfCxm ds2_sfCxn]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfCx4 ds_sfCxl ds1_sfCxm ds2_sfCxn; } in
        let {
          sat_sfCxk [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1 -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfCx4] \r [ds_sfCxi ds1_sfCxj]
                  GHC.Enum.enumFromTo $dEnum_sfCx4 ds_sfCxi ds1_sfCxj; } in
        let {
          sat_sfCxh [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1 -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfCx4] \r [ds_sfCxf ds1_sfCxg]
                  GHC.Enum.enumFromThen $dEnum_sfCx4 ds_sfCxf ds1_sfCxg; } in
        let {
          sat_sfCxe [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1 -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfCx4] \r [ds_sfCxd]
                  GHC.Enum.enumFrom $dEnum_sfCx4 ds_sfCxd; } in
        let {
          sat_sfCxc [Occ=Once] :: Data.Semigroup.Max a_Xfzx1 -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfCx4] \r [eta_sfCxb]
                  GHC.Enum.fromEnum $dEnum_sfCx4 eta_sfCxb; } in
        let {
          sat_sfCxa [Occ=Once] :: GHC.Types.Int -> Data.Semigroup.Max a_Xfzx1
          [LclId] =
              [$dEnum_sfCx4] \r [eta_sfCx9]
                  GHC.Enum.toEnum $dEnum_sfCx4 eta_sfCx9; } in
        let {
          sat_sfCx8 [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1 -> Data.Semigroup.Max a_Xfzx1
          [LclId] =
              [$dEnum_sfCx4] \r [ds_sfCx7]
                  GHC.Enum.pred $dEnum_sfCx4 ds_sfCx7; } in
        let {
          sat_sfCx6 [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1 -> Data.Semigroup.Max a_Xfzx1
          [LclId] =
              [$dEnum_sfCx4] \r [ds_sfCx5] GHC.Enum.succ $dEnum_sfCx4 ds_sfCx5;
        } in 
          GHC.Enum.C:Enum [sat_sfCx6
                           sat_sfCx8
                           sat_sfCxa
                           sat_sfCxc
                           sat_sfCxe
                           sat_sfCxh
                           sat_sfCxk
                           sat_sfCxo];

Data.Semigroup.getFirst :: forall a. Data.Semigroup.First a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1First2 eta_B1;

Data.Semigroup.$fMonadFixFirst_$cmfix
  :: forall a.
     (a -> Data.Semigroup.First a) -> Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfCxp]
        let {
          x_sfCxq [Occ=LoopBreaker] :: Data.Semigroup.First a_afyMj
          [LclId] =
              [f_sfCxp x_sfCxq] \u [] f_sfCxp x_sfCxq;
        } in  x_sfCxq;

Data.Semigroup.$fMonadFixFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadFirst
                                                 Data.Semigroup.$fMonadFixFirst_$cmfix];

Data.Semigroup.$fEnumFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfCxr]
        let {
          sat_sfCxL [Occ=Once]
            :: Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV
               -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfCxr] \r [ds_sfCxI ds1_sfCxJ ds2_sfCxK]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfCxr ds_sfCxI ds1_sfCxJ ds2_sfCxK; } in
        let {
          sat_sfCxH [Occ=Once]
            :: Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfCxr] \r [ds_sfCxF ds1_sfCxG]
                  GHC.Enum.enumFromTo $dEnum_sfCxr ds_sfCxF ds1_sfCxG; } in
        let {
          sat_sfCxE [Occ=Once]
            :: Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfCxr] \r [ds_sfCxC ds1_sfCxD]
                  GHC.Enum.enumFromThen $dEnum_sfCxr ds_sfCxC ds1_sfCxD; } in
        let {
          sat_sfCxB [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfCxr] \r [ds_sfCxA]
                  GHC.Enum.enumFrom $dEnum_sfCxr ds_sfCxA; } in
        let {
          sat_sfCxz [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfCxr] \r [eta_sfCxy]
                  GHC.Enum.fromEnum $dEnum_sfCxr eta_sfCxy; } in
        let {
          sat_sfCxx [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.First a_XfzhV
          [LclId] =
              [$dEnum_sfCxr] \r [eta_sfCxw]
                  GHC.Enum.toEnum $dEnum_sfCxr eta_sfCxw; } in
        let {
          sat_sfCxv [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> Data.Semigroup.First a_XfzhV
          [LclId] =
              [$dEnum_sfCxr] \r [ds_sfCxu]
                  GHC.Enum.pred $dEnum_sfCxr ds_sfCxu; } in
        let {
          sat_sfCxt [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> Data.Semigroup.First a_XfzhV
          [LclId] =
              [$dEnum_sfCxr] \r [ds_sfCxs] GHC.Enum.succ $dEnum_sfCxr ds_sfCxs;
        } in 
          GHC.Enum.C:Enum [sat_sfCxt
                           sat_sfCxv
                           sat_sfCxx
                           sat_sfCxz
                           sat_sfCxB
                           sat_sfCxE
                           sat_sfCxH
                           sat_sfCxL];

Data.Semigroup.getLast :: forall a. Data.Semigroup.Last a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Last2 eta_B1;

Data.Semigroup.$fMonadFixLast_$cmfix
  :: forall a. (a -> Data.Semigroup.Last a) -> Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfCxM]
        let {
          x_sfCxN [Occ=LoopBreaker] :: Data.Semigroup.Last a_afyFi
          [LclId] =
              [f_sfCxM x_sfCxN] \u [] f_sfCxM x_sfCxN;
        } in  x_sfCxN;

Data.Semigroup.$fMonadFixLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadLast
                                                 Data.Semigroup.$fMonadFixLast_$cmfix];

Data.Semigroup.$fEnumLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfCxO]
        let {
          sat_sfCy8 [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2
               -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfCxO] \r [ds_sfCy5 ds1_sfCy6 ds2_sfCy7]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfCxO ds_sfCy5 ds1_sfCy6 ds2_sfCy7; } in
        let {
          sat_sfCy4 [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2 -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfCxO] \r [ds_sfCy2 ds1_sfCy3]
                  GHC.Enum.enumFromTo $dEnum_sfCxO ds_sfCy2 ds1_sfCy3; } in
        let {
          sat_sfCy1 [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2 -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfCxO] \r [ds_sfCxZ ds1_sfCy0]
                  GHC.Enum.enumFromThen $dEnum_sfCxO ds_sfCxZ ds1_sfCy0; } in
        let {
          sat_sfCxY [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfCxO] \r [ds_sfCxX]
                  GHC.Enum.enumFrom $dEnum_sfCxO ds_sfCxX; } in
        let {
          sat_sfCxW [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfCxO] \r [eta_sfCxV]
                  GHC.Enum.fromEnum $dEnum_sfCxO eta_sfCxV; } in
        let {
          sat_sfCxU [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Last a_Xfzb2
          [LclId] =
              [$dEnum_sfCxO] \r [eta_sfCxT]
                  GHC.Enum.toEnum $dEnum_sfCxO eta_sfCxT; } in
        let {
          sat_sfCxS [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> Data.Semigroup.Last a_Xfzb2
          [LclId] =
              [$dEnum_sfCxO] \r [ds_sfCxR]
                  GHC.Enum.pred $dEnum_sfCxO ds_sfCxR; } in
        let {
          sat_sfCxQ [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> Data.Semigroup.Last a_Xfzb2
          [LclId] =
              [$dEnum_sfCxO] \r [ds_sfCxP] GHC.Enum.succ $dEnum_sfCxO ds_sfCxP;
        } in 
          GHC.Enum.C:Enum [sat_sfCxQ
                           sat_sfCxS
                           sat_sfCxU
                           sat_sfCxW
                           sat_sfCxY
                           sat_sfCy1
                           sat_sfCy4
                           sat_sfCy8];

Data.Semigroup.unwrapMonoid
  :: forall m. Data.Semigroup.WrappedMonoid m -> m
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1WrappedMonoid2 eta_B1;

Data.Semigroup.$fEnumWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.WrappedMonoid a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfCy9]
        let {
          sat_sfCyt [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfCy9] \r [ds_sfCyq ds1_sfCyr ds2_sfCys]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfCy9 ds_sfCyq ds1_sfCyr ds2_sfCys; } in
        let {
          sat_sfCyp [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfCy9] \r [ds_sfCyn ds1_sfCyo]
                  GHC.Enum.enumFromTo $dEnum_sfCy9 ds_sfCyn ds1_sfCyo; } in
        let {
          sat_sfCym [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfCy9] \r [ds_sfCyk ds1_sfCyl]
                  GHC.Enum.enumFromThen $dEnum_sfCy9 ds_sfCyk ds1_sfCyl; } in
        let {
          sat_sfCyj [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfCy9] \r [ds_sfCyi]
                  GHC.Enum.enumFrom $dEnum_sfCy9 ds_sfCyi; } in
        let {
          sat_sfCyh [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37 -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfCy9] \r [eta_sfCyg]
                  GHC.Enum.fromEnum $dEnum_sfCy9 eta_sfCyg; } in
        let {
          sat_sfCyf [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.WrappedMonoid a_Xfz37
          [LclId] =
              [$dEnum_sfCy9] \r [eta_sfCye]
                  GHC.Enum.toEnum $dEnum_sfCy9 eta_sfCye; } in
        let {
          sat_sfCyd [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
          [LclId] =
              [$dEnum_sfCy9] \r [ds_sfCyc]
                  GHC.Enum.pred $dEnum_sfCy9 ds_sfCyc; } in
        let {
          sat_sfCyb [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
          [LclId] =
              [$dEnum_sfCy9] \r [ds_sfCya] GHC.Enum.succ $dEnum_sfCy9 ds_sfCya;
        } in 
          GHC.Enum.C:Enum [sat_sfCyb
                           sat_sfCyd
                           sat_sfCyf
                           sat_sfCyh
                           sat_sfCyj
                           sat_sfCym
                           sat_sfCyp
                           sat_sfCyt];

Data.Semigroup.getOption
  :: forall a. Data.Semigroup.Option a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Option2 eta_B1;

Data.Semigroup.$fMonadFixOption_$cmfix
  :: forall a.
     (a -> Data.Semigroup.Option a) -> Data.Semigroup.Option a
[GblId, Arity=1, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfCyu]
        let {
          a1_sfCyv [Occ=LoopBreaker] :: Data.Semigroup.Option a_afyzI
          [LclId] =
              [f_sfCyu a1_sfCyv] \u []
                  let {
                    sat_sfCyy [Occ=Once] :: a_afyzI
                    [LclId] =
                        [a1_sfCyv] \u []
                            case a1_sfCyv of {
                              GHC.Base.Nothing -> Control.Monad.Fix.$fMonadFixFirst1;
                              GHC.Base.Just x_sfCyx [Occ=Once] -> x_sfCyx;
                            };
                  } in  f_sfCyu sat_sfCyy;
        } in  a1_sfCyv;

Data.Semigroup.$fMonadFixOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadOption
                                                 Data.Semigroup.$fMonadFixOption_$cmfix];

Data.Semigroup.cycle1 :: forall m. GHC.Base.Semigroup m => m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),U(C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfCyz xs_sfCyA]
        let {
          xs'_sfCyB [Occ=LoopBreaker] :: m_afxsV
          [LclId] =
              [$dSemigroup_sfCyz xs_sfCyA xs'_sfCyB] \u []
                  GHC.Base.<> $dSemigroup_sfCyz xs_sfCyA xs'_sfCyB;
        } in  xs'_sfCyB;

Data.Semigroup.diff1
  :: forall m. GHC.Base.Semigroup m => m -> m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfCyC eta_sfCyD]
        GHC.Base.<> $dSemigroup_sfCyC eta_sfCyD;

Data.Semigroup.diff
  :: forall m.
     GHC.Base.Semigroup m =>
     m -> Data.Semigroup.Internal.Endo m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Semigroup.diff1 eta_B2 eta_B1;

Data.Semigroup.mtimesDefault
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Monoid a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(U,U,U,U,U,U,U),U(U(U,U),U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U(A,1*U,U,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfCyE $dMonoid_sfCyF eta_sfCyG eta1_sfCyH]
        case
            GHC.Real.$p1Integral $dIntegral_sfCyE
        of
        $dReal_sfCyI [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_sfCyM [Occ=Once] :: b_afxst
                [LclId] =
                    [$dReal_sfCyI] \u []
                        case GHC.Real.$p1Real $dReal_sfCyI of sat_sfCyL {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_sfCyL Data.Semigroup.$fSemigroupOption2;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_sfCyI of sat_sfCyJ {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_sfCyJ of sat_sfCyK {
                        __DEFAULT ->
                            case GHC.Classes.== sat_sfCyK eta_sfCyG sat_sfCyM of {
                              GHC.Types.False ->
                                  Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes
                                      $dMonoid_sfCyF $dIntegral_sfCyE eta_sfCyG eta1_sfCyH;
                              GHC.Types.True -> GHC.Base.mempty $dMonoid_sfCyF;
                            };
                      };
                };
        };

Data.Semigroup.option
  :: forall b a. b -> (a -> b) -> Data.Semigroup.Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] Data.Maybe.maybe eta_B3 eta_B2 eta_B1;

$cMin1_rfC6i :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadMin2 GHC.Types.[]];

go61_rfC6j
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCyO _ys_sfCyP]
        case ds2_sfCyO of {
          [] -> GHC.List.badHead;
          : ipv_sfCyR [Occ=Once!] ipv1_sfCyS [Occ=Once] ->
              case _ys_sfCyP of {
                [] -> GHC.List.badHead;
                : ipv2_sfCyU [Occ=Once] ipv3_sfCyV [Occ=Once] ->
                    case ipv_sfCyR of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCyY [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfCyY Data.Semigroup.$fDataMin7 of {
                            GHC.Types.False -> go61_rfC6j ipv1_sfCyS ipv3_sfCyV;
                            GHC.Types.True -> ipv2_sfCyU;
                          };
                    };
              };
        };

$cMin2_rfC6k :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cMin3_rfC6l];
Data.Semigroup.$fDataMin6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cMin GHC.Types.[]];
Data.Semigroup.$fDataMin5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataMin6];
Data.Semigroup.$tMin :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataMin7
                                       Data.Semigroup.$fDataMin5];
Data.Semigroup.$cMin [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cMin2_rfC6k
                                     Data.Semigroup.$fDataMin7
                                     $cMin1_rfC6i
                                     Data.Data.Prefix
                                     Data.Semigroup.$tMin];
$cMin3_rfC6l :: Data.Data.ConIndex
[GblId] =
    [] \u [] go61_rfC6j Data.Semigroup.$fDataMin6 Data.Data.mkConstr1;

$cMax1_rfC6m :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadMax2 GHC.Types.[]];

go1_rfC6n
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCz3 _ys_sfCz4]
        case ds2_sfCz3 of {
          [] -> GHC.List.badHead;
          : ipv_sfCz6 [Occ=Once!] ipv1_sfCz7 [Occ=Once] ->
              case _ys_sfCz4 of {
                [] -> GHC.List.badHead;
                : ipv2_sfCz9 [Occ=Once] ipv3_sfCza [Occ=Once] ->
                    case ipv_sfCz6 of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCzd [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfCzd Data.Semigroup.$fDataMax7 of {
                            GHC.Types.False -> go1_rfC6n ipv1_sfCz7 ipv3_sfCza;
                            GHC.Types.True -> ipv2_sfCz9;
                          };
                    };
              };
        };

$cMax2_rfC6o :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cMax3_rfC6p];
Data.Semigroup.$fDataMax6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cMax GHC.Types.[]];
Data.Semigroup.$fDataMax5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataMax6];
Data.Semigroup.$tMax :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataMax7
                                       Data.Semigroup.$fDataMax5];
Data.Semigroup.$cMax [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cMax2_rfC6o
                                     Data.Semigroup.$fDataMax7
                                     $cMax1_rfC6m
                                     Data.Data.Prefix
                                     Data.Semigroup.$tMax];
$cMax3_rfC6p :: Data.Data.ConIndex
[GblId] =
    [] \u [] go1_rfC6n Data.Semigroup.$fDataMax6 Data.Data.mkConstr1;

go2_rfC6q
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCzi _ys_sfCzj]
        case ds2_sfCzi of {
          [] -> GHC.List.badHead;
          : ipv_sfCzl [Occ=Once!] ipv1_sfCzm [Occ=Once] ->
              case _ys_sfCzj of {
                [] -> GHC.List.badHead;
                : ipv2_sfCzo [Occ=Once] ipv3_sfCzp [Occ=Once] ->
                    case ipv_sfCzl of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCzs [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfCzs Data.Semigroup.$fDataArg9 of {
                            GHC.Types.False -> go2_rfC6q ipv1_sfCzm ipv3_sfCzp;
                            GHC.Types.True -> ipv2_sfCzo;
                          };
                    };
              };
        };

$cArg1_rfC6r :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cArg2_rfC6s];
Data.Semigroup.$fDataArg8 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cArg GHC.Types.[]];
Data.Semigroup.$fDataArg7 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataArg8];
Data.Semigroup.$tArg :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataArg9
                                       Data.Semigroup.$fDataArg7];
Data.Semigroup.$cArg [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cArg1_rfC6r
                                     Data.Semigroup.$fDataArg9
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Semigroup.$tArg];
$cArg2_rfC6s :: Data.Data.ConIndex
[GblId] =
    [] \u [] go2_rfC6q Data.Semigroup.$fDataArg8 Data.Data.mkConstr1;

$cFirst1_rfC6t :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadFirst5 GHC.Types.[]];

go3_rfC6u
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCzx _ys_sfCzy]
        case ds2_sfCzx of {
          [] -> GHC.List.badHead;
          : ipv_sfCzA [Occ=Once!] ipv1_sfCzB [Occ=Once] ->
              case _ys_sfCzy of {
                [] -> GHC.List.badHead;
                : ipv2_sfCzD [Occ=Once] ipv3_sfCzE [Occ=Once] ->
                    case ipv_sfCzA of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCzH [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfCzH Data.Semigroup.$fDataFirst7 of {
                            GHC.Types.False -> go3_rfC6u ipv1_sfCzB ipv3_sfCzE;
                            GHC.Types.True -> ipv2_sfCzD;
                          };
                    };
              };
        };

$cFirst2_rfC6v :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cFirst3_rfC6w];
Data.Semigroup.$fDataFirst6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cFirst GHC.Types.[]];
Data.Semigroup.$fDataFirst5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataFirst6];
Data.Semigroup.$tFirst :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataFirst7
                                       Data.Semigroup.$fDataFirst5];
Data.Semigroup.$cFirst [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cFirst2_rfC6v
                                     Data.Semigroup.$fDataFirst7
                                     $cFirst1_rfC6t
                                     Data.Data.Prefix
                                     Data.Semigroup.$tFirst];
$cFirst3_rfC6w :: Data.Data.ConIndex
[GblId] =
    [] \u [] go3_rfC6u Data.Semigroup.$fDataFirst6 Data.Data.mkConstr1;

$cLast1_rfC6x :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadLast2 GHC.Types.[]];

go4_rfC6y
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCzM _ys_sfCzN]
        case ds2_sfCzM of {
          [] -> GHC.List.badHead;
          : ipv_sfCzP [Occ=Once!] ipv1_sfCzQ [Occ=Once] ->
              case _ys_sfCzN of {
                [] -> GHC.List.badHead;
                : ipv2_sfCzS [Occ=Once] ipv3_sfCzT [Occ=Once] ->
                    case ipv_sfCzP of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCzW [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfCzW Data.Semigroup.$fDataLast7 of {
                            GHC.Types.False -> go4_rfC6y ipv1_sfCzQ ipv3_sfCzT;
                            GHC.Types.True -> ipv2_sfCzS;
                          };
                    };
              };
        };

$cLast2_rfC6z :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cLast3_rfC6A];
Data.Semigroup.$fDataLast6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cLast GHC.Types.[]];
Data.Semigroup.$fDataLast5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataLast6];
Data.Semigroup.$tLast :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataLast7
                                       Data.Semigroup.$fDataLast5];
Data.Semigroup.$cLast [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cLast2_rfC6z
                                     Data.Semigroup.$fDataLast7
                                     $cLast1_rfC6x
                                     Data.Data.Prefix
                                     Data.Semigroup.$tLast];
$cLast3_rfC6A :: Data.Data.ConIndex
[GblId] =
    [] \u [] go4_rfC6y Data.Semigroup.$fDataLast6 Data.Data.mkConstr1;

Data.Semigroup.$fDataWrappedMonoid4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrappedMonoid"#;

Data.Semigroup.$fDataWrappedMonoid7 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.$fDataWrappedMonoid4;

$cWrapMonoid1_rfC6B :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadWrappedMonoid2
                      GHC.Types.[]];

go5_rfC6C
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCA1 _ys_sfCA2]
        case ds2_sfCA1 of {
          [] -> GHC.List.badHead;
          : ipv_sfCA4 [Occ=Once!] ipv1_sfCA5 [Occ=Once] ->
              case _ys_sfCA2 of {
                [] -> GHC.List.badHead;
                : ipv2_sfCA7 [Occ=Once] ipv3_sfCA8 [Occ=Once] ->
                    case ipv_sfCA4 of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCAb [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case
                              GHC.Base.eqString ds4_sfCAb Data.Semigroup.$fReadWrappedMonoid4
                          of
                          { GHC.Types.False -> go5_rfC6C ipv1_sfCA5 ipv3_sfCA8;
                            GHC.Types.True -> ipv2_sfCA7;
                          };
                    };
              };
        };

$cWrapMonoid2_rfC6D :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cWrapMonoid3_rfC6E];
Data.Semigroup.$fDataWrappedMonoid6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cWrapMonoid GHC.Types.[]];
Data.Semigroup.$fDataWrappedMonoid5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataWrappedMonoid6];
Data.Semigroup.$tWrappedMonoid :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataWrappedMonoid7
                                       Data.Semigroup.$fDataWrappedMonoid5];
Data.Semigroup.$cWrapMonoid [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cWrapMonoid2_rfC6D
                                     Data.Semigroup.$fReadWrappedMonoid4
                                     $cWrapMonoid1_rfC6B
                                     Data.Data.Prefix
                                     Data.Semigroup.$tWrappedMonoid];
$cWrapMonoid3_rfC6E :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go5_rfC6C Data.Semigroup.$fDataWrappedMonoid6 Data.Data.mkConstr1;

$cOption1_rfC6F :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadOption2 GHC.Types.[]];

go6_rfC6G
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfCAg _ys_sfCAh]
        case ds2_sfCAg of {
          [] -> GHC.List.badHead;
          : ipv_sfCAj [Occ=Once!] ipv1_sfCAk [Occ=Once] ->
              case _ys_sfCAh of {
                [] -> GHC.List.badHead;
                : ipv2_sfCAm [Occ=Once] ipv3_sfCAn [Occ=Once] ->
                    case ipv_sfCAj of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfCAq [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfCAq Data.Semigroup.$fDataOption9 of {
                            GHC.Types.False -> go6_rfC6G ipv1_sfCAk ipv3_sfCAn;
                            GHC.Types.True -> ipv2_sfCAm;
                          };
                    };
              };
        };

$cOption2_rfC6H :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cOption3_rfC6I];
Data.Semigroup.$fDataOption8 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cOption GHC.Types.[]];
Data.Semigroup.$fDataOption7 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataOption8];
Data.Semigroup.$tOption :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataOption9
                                       Data.Semigroup.$fDataOption7];
Data.Semigroup.$cOption [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cOption2_rfC6H
                                     Data.Semigroup.$fDataOption9
                                     $cOption1_rfC6F
                                     Data.Data.Prefix
                                     Data.Semigroup.$tOption];
$cOption3_rfC6I :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go6_rfC6G Data.Semigroup.$fDataOption8 Data.Data.mkConstr1;

Data.Semigroup.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Semigroup.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$trModule4];

Data.Semigroup.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Semigroup"#;

Data.Semigroup.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$trModule2];

Data.Semigroup.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Semigroup.$trModule3
                                     Data.Semigroup.$trModule1];

$krep_rfC6J :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_rfC6K :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_rfC6L :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rfC6K GHC.Types.[]];

$krep3_rfC6M :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep2_rfC6L];

Data.Semigroup.$fDataMin3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataMin4];

Data.Semigroup.$tcMin :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2898124504153588682##
                                    15185633012309158566##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataMin3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep4_rfC6N :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcMin
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Min1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep4_rfC6N];

Data.Semigroup.$tc'Min3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Min"#;

Data.Semigroup.$tc'Min2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Min3];

Data.Semigroup.$tc'Min :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7769702422559516318##
                                    9758175179672887730##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Min2
                                    1#
                                    Data.Semigroup.$tc'Min1];

Data.Semigroup.$fDataMin2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Min
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                2898124504153588682##
                15185633012309158566##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataMin3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCAw [Occ=Once]
                   ww9_sfCAx [Occ=Once]
                   ww10_sfCAy [Occ=Once]
                   ww11_sfCAz [Occ=Once]
                   ww12_sfCAA [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCAw
                                              ww9_sfCAx
                                              ww10_sfCAy
                                              ww11_sfCAz
                                              ww12_sfCAA];
        };

Data.Semigroup.$fDataMin8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Min a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCAB]
        case Data.Data.$p1Data $dData_sfCAB of sat_sfCAC {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp Data.Semigroup.$fDataMin2 sat_sfCAC;
        };

Data.Semigroup.$fDataMin_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Min a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCAD $dTypeable_sfCAE]
        let {
          lvl33_sfCAF [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCAE] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCAE Data.Semigroup.$fDataMin2; } in
        let {
          sat_sfCAJ [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afxz6 (t_afxz5 d))
               -> GHC.Base.Maybe (c_afxz6 (Data.Semigroup.Min a_Xfy02))
          [LclId] =
              [$dData_sfCAD lvl33_sfCAF] \r [f_sfCAG]
                  case lvl33_sfCAF of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCAI [Occ=Once] :: c_afxz6 (Data.Semigroup.Min a_Xfy02)
                          [LclId] =
                              [$dData_sfCAD f_sfCAG] \u [] f_sfCAG $dData_sfCAD;
                        } in  GHC.Base.Just [sat_sfCAI];
                  };
        } in  sat_sfCAJ;

Data.Semigroup.$fDataMin1
  :: forall a. (a -> Data.Semigroup.Min a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataMin_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Min a -> m (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCAK $dMonadPlus_sfCAL ds_sfCAM eta_sfCAN]
        let {
          lvl33_sfCAO [Occ=OnceL] :: m_afxBb (Data.Semigroup.Min a_Xfy0b)
          [LclId] =
              [$dMonadPlus_sfCAL] \u [] GHC.Base.mzero $dMonadPlus_sfCAL;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCAL
          of
          $dMonad_sfCAP [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCBb [Occ=Once]
                    :: (Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                       -> m_afxBb (Data.Semigroup.Min a_Xfy0b)
                  [LclId] =
                      [lvl33_sfCAO $dMonad_sfCAP] \r [ds1_sfCB6]
                          case ds1_sfCB6 of {
                            (,) x'_sfCB8 [Occ=Once] b_sfCB9 [Occ=Once!] ->
                                case b_sfCB9 of {
                                  GHC.Types.False -> lvl33_sfCAO;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCAP x'_sfCB8;
                                };
                          }; } in
                let {
                  sat_sfCB5 [Occ=Once]
                    :: m_afxBb (Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCAK
                       $dMonadPlus_sfCAL
                       ds_sfCAM
                       eta_sfCAN
                       $dMonad_sfCAP] \u []
                          let {
                            lvl34_sfCAQ [Occ=OnceL] :: m_afxBb a_Xfy0b
                            [LclId] =
                                [$dData_sfCAK ds_sfCAM eta_sfCAN] \u []
                                    ds_sfCAM $dData_sfCAK eta_sfCAN; } in
                          let {
                            sat_sfCB4 [Occ=Once]
                              :: (a_Xfy0b -> Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                                 -> m_afxBb (Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCAL
                                 eta_sfCAN
                                 $dMonad_sfCAP
                                 lvl34_sfCAQ] \r [ds1_sfCAS]
                                    case ds1_sfCAS of {
                                      (,) h_sfCAU b1_sfCAV [Occ=Once] ->
                                          let {
                                            sat_sfCB3 [Occ=Once]
                                              :: m_afxBb (Data.Semigroup.Min a_Xfy0b,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfCAN $dMonad_sfCAP h_sfCAU b1_sfCAV] \u []
                                                    let {
                                                      sat_sfCB1 [Occ=Once]
                                                        :: Data.Semigroup.Min a_Xfy0b
                                                      [LclId] =
                                                          [eta_sfCAN h_sfCAU] \u []
                                                              h_sfCAU eta_sfCAN; } in
                                                    let {
                                                      sat_sfCB2 [Occ=Once]
                                                        :: (Data.Semigroup.Min a_Xfy0b,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfCB1 b1_sfCAV];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfCAP sat_sfCB2; } in
                                          let {
                                            sat_sfCB0 [Occ=Once]
                                              :: m_afxBb (Data.Semigroup.Min a_Xfy0b,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfCAP lvl34_sfCAQ h_sfCAU] \u []
                                                    let {
                                                      sat_sfCAZ [Occ=Once]
                                                        :: a_Xfy0b
                                                           -> m_afxBb (Data.Semigroup.Min a_Xfy0b,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfCAP h_sfCAU] \r [y'_sfCAW]
                                                              let {
                                                                sat_sfCAX [Occ=Once]
                                                                  :: Data.Semigroup.Min a_Xfy0b
                                                                [LclId] =
                                                                    [h_sfCAU y'_sfCAW] \u []
                                                                        h_sfCAU y'_sfCAW; } in
                                                              let {
                                                                sat_sfCAY [Occ=Once]
                                                                  :: (Data.Semigroup.Min a_Xfy0b,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfCAX
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfCAP sat_sfCAY;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfCAP lvl34_sfCAQ sat_sfCAZ;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfCAL sat_sfCB0 sat_sfCB3;
                                    }; } in
                          let {
                            sat_sfCAR [Occ=Once]
                              :: m_afxBb (a_Xfy0b -> Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCAP] \u []
                                    GHC.Base.return $dMonad_sfCAP Data.Semigroup.$fDataMin1;
                          } in  GHC.Base.>>= $dMonad_sfCAP sat_sfCAR sat_sfCB4;
                } in  GHC.Base.>>= $dMonad_sfCAP sat_sfCB5 sat_sfCBb;
          };

Data.Semigroup.$fDataMin_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Min a -> m (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCBc $dMonad_sfCBd ds_sfCBe eta_sfCBf]
        let {
          lvl33_sfCBg [Occ=OnceL] :: m_afxAV a_Xfy0a
          [LclId] =
              [$dData_sfCBc ds_sfCBe eta_sfCBf] \u []
                  ds_sfCBe $dData_sfCBc eta_sfCBf; } in
        let {
          sat_sfCBm [Occ=Once]
            :: (a_Xfy0a -> Data.Semigroup.Min a_Xfy0a)
               -> m_afxAV (Data.Semigroup.Min a_Xfy0a)
          [LclId] =
              [$dMonad_sfCBd lvl33_sfCBg] \r [c'_sfCBi]
                  let {
                    sat_sfCBl [Occ=Once]
                      :: a_Xfy0a -> m_afxAV (Data.Semigroup.Min a_Xfy0a)
                    [LclId] =
                        [$dMonad_sfCBd c'_sfCBi] \r [x'_sfCBj]
                            let {
                              sat_sfCBk [Occ=Once] :: Data.Semigroup.Min a_Xfy0a
                              [LclId] =
                                  [c'_sfCBi x'_sfCBj] \u [] c'_sfCBi x'_sfCBj;
                            } in  GHC.Base.return $dMonad_sfCBd sat_sfCBk;
                  } in  GHC.Base.>>= $dMonad_sfCBd lvl33_sfCBg sat_sfCBl; } in
        let {
          sat_sfCBh [Occ=Once]
            :: m_afxAV (a_Xfy0a -> Data.Semigroup.Min a_Xfy0a)
          [LclId] =
              [$dMonad_sfCBd] \u []
                  GHC.Base.return $dMonad_sfCBd Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfCBd sat_sfCBh sat_sfCBm;

Data.Semigroup.$fDataMin_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Min a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCBn ds_sfCBo ds1_sfCBp x_sfCBq]
        case ds_sfCBo of {
          GHC.Types.I# x1_sfCBs [Occ=Once!] ->
              case x1_sfCBs of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfCBp $dData_sfCBn x_sfCBq;
              };
        };

Data.Semigroup.$fDataMin_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Min a -> m (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCBu $dMonadPlus_sfCBv ds_sfCBw eta_sfCBx]
        let {
          lvl33_sfCBy [Occ=OnceL] :: m_afxBr (Data.Semigroup.Min a_Xfy04)
          [LclId] =
              [$dMonadPlus_sfCBv] \u [] GHC.Base.mzero $dMonadPlus_sfCBv;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCBv
          of
          $dMonad_sfCBz [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCBY [Occ=Once]
                    :: (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                       -> m_afxBr (Data.Semigroup.Min a_Xfy04)
                  [LclId] =
                      [lvl33_sfCBy $dMonad_sfCBz] \r [ds1_sfCBT]
                          case ds1_sfCBT of {
                            (,) x'_sfCBV [Occ=Once] b_sfCBW [Occ=Once!] ->
                                case b_sfCBW of {
                                  GHC.Types.False -> lvl33_sfCBy;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCBz x'_sfCBV;
                                };
                          }; } in
                let {
                  sat_sfCBS [Occ=Once]
                    :: m_afxBr (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCBu
                       $dMonadPlus_sfCBv
                       ds_sfCBw
                       eta_sfCBx
                       $dMonad_sfCBz] \u []
                          let {
                            lvl34_sfCBA [Occ=OnceL] :: m_afxBr a_Xfy04
                            [LclId] =
                                [$dData_sfCBu ds_sfCBw eta_sfCBx] \u []
                                    ds_sfCBw $dData_sfCBu eta_sfCBx; } in
                          let {
                            sat_sfCBR [Occ=Once]
                              :: (a_Xfy04 -> Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                                 -> m_afxBr (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCBv
                                 eta_sfCBx
                                 $dMonad_sfCBz
                                 lvl34_sfCBA] \r [ds1_sfCBC]
                                    case ds1_sfCBC of {
                                      (,) h_sfCBE b1_sfCBF [Occ=Once!] ->
                                          case b1_sfCBF of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfCBO [Occ=Once]
                                                    :: m_afxBr (Data.Semigroup.Min a_Xfy04,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfCBx $dMonad_sfCBz h_sfCBE] \u []
                                                          let {
                                                            sat_sfCBM [Occ=Once]
                                                              :: Data.Semigroup.Min a_Xfy04
                                                            [LclId] =
                                                                [eta_sfCBx h_sfCBE] \u []
                                                                    h_sfCBE eta_sfCBx; } in
                                                          let {
                                                            sat_sfCBN [Occ=Once]
                                                              :: (Data.Semigroup.Min a_Xfy04,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfCBM
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfCBz sat_sfCBN; } in
                                                let {
                                                  sat_sfCBL [Occ=Once]
                                                    :: m_afxBr (Data.Semigroup.Min a_Xfy04,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfCBz lvl34_sfCBA h_sfCBE] \u []
                                                          let {
                                                            sat_sfCBK [Occ=Once]
                                                              :: a_Xfy04
                                                                 -> m_afxBr (Data.Semigroup.Min
                                                                               a_Xfy04,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCBz
                                                                 h_sfCBE] \r [y'_sfCBH]
                                                                    let {
                                                                      sat_sfCBI [Occ=Once]
                                                                        :: Data.Semigroup.Min
                                                                             a_Xfy04
                                                                      [LclId] =
                                                                          [h_sfCBE y'_sfCBH] \u []
                                                                              h_sfCBE y'_sfCBH; } in
                                                                    let {
                                                                      sat_sfCBJ [Occ=Once]
                                                                        :: (Data.Semigroup.Min
                                                                              a_Xfy04,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCBI
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCBz sat_sfCBJ;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfCBz lvl34_sfCBA sat_sfCBK;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfCBv sat_sfCBL sat_sfCBO;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfCBP [Occ=Once] :: Data.Semigroup.Min a_Xfy04
                                                  [LclId] =
                                                      [eta_sfCBx h_sfCBE] \u []
                                                          h_sfCBE eta_sfCBx; } in
                                                let {
                                                  sat_sfCBQ [Occ=Once]
                                                    :: (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfCBP GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfCBz sat_sfCBQ;
                                          };
                                    }; } in
                          let {
                            sat_sfCBB [Occ=Once]
                              :: m_afxBr (a_Xfy04 -> Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCBz] \u []
                                    GHC.Base.return $dMonad_sfCBz Data.Semigroup.$fDataMin1;
                          } in  GHC.Base.>>= $dMonad_sfCBz sat_sfCBB sat_sfCBR;
                } in  GHC.Base.>>= $dMonad_sfCBz sat_sfCBS sat_sfCBY;
          };

lvl12_rfC6O :: forall a. Data.Semigroup.Min a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCBZ] Data.Semigroup.$cMin;

lvl13_rfC6P :: forall a. Data.Semigroup.Min a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCC0] Data.Semigroup.$tMin;

lvl14_rfC6Q
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Min a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCC1 ds_sfCC2] GHC.Base.Nothing [];

Data.Semigroup.$fDataMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCC3]
        let {
          sat_sfCCy [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Min a_Xfy03 -> m (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfCC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapMo
                      $dData_sfCC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCCx [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Min a_Xfy03 -> m (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfCC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapMp
                      $dData_sfCC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCCw [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Min a_Xfy03 -> m (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfCC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapM
                      $dData_sfCC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCCv [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Min a_Xfy03
               -> u
          [LclId] =
              [$dData_sfCC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapQi
                      $dData_sfCC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCCu [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Min a_Xfy03 -> [u]
          [LclId] =
              [$dData_sfCC3] \r [ds_sfCCr x0_sfCCs]
                  let {
                    sat_sfCCt [Occ=Once] :: u_afxAt
                    [LclId] =
                        [$dData_sfCC3 ds_sfCCr x0_sfCCs] \u []
                            ds_sfCCr $dData_sfCC3 x0_sfCCs;
                  } in  : [sat_sfCCt GHC.Types.[]]; } in
        let {
          sat_sfCCq [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Min a_Xfy03
               -> r
          [LclId] =
              [$dData_sfCC3] \r [ds_sfCCl ds1_sfCCm ds2_sfCCn x0_sfCCo]
                  let {
                    sat_sfCCp [Occ=Once] :: r'_afxAd
                    [LclId] =
                        [$dData_sfCC3 ds2_sfCCn x0_sfCCo] \u []
                            ds2_sfCCn $dData_sfCC3 x0_sfCCo;
                  } in  ds_sfCCl sat_sfCCp ds1_sfCCm; } in
        let {
          sat_sfCCk [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Min a_Xfy03
               -> r
          [LclId] =
              [$dData_sfCC3] \r [ds_sfCCf ds1_sfCCg ds2_sfCCh eta_sfCCi]
                  let {
                    sat_sfCCj [Occ=Once] :: r'_afxzW
                    [LclId] =
                        [$dData_sfCC3 ds2_sfCCh eta_sfCCi] \u []
                            ds2_sfCCh $dData_sfCC3 eta_sfCCi;
                  } in  ds_sfCCf ds1_sfCCg sat_sfCCj; } in
        let {
          sat_sfCCe [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Min a_Xfy03 -> Data.Semigroup.Min a_Xfy03
          [LclId] =
              [$dData_sfCC3] \r [ds_sfCCc x0_sfCCd]
                  ds_sfCCc $dData_sfCC3 x0_sfCCd; } in
        let {
          sat_sfCCb [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Min a_Xfy03))
          [LclId] =
              [$dData_sfCC3] \r [eta_B1]
                  Data.Semigroup.$fDataMin_$cdataCast1 $dData_sfCC3 eta_B1; } in
        let {
          sat_sfCCa [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfCC3] \r [k_sfCC6 z_sfCC7 ds_sfCC8]
                  let {
                    sat_sfCC9 [Occ=Once]
                      :: c_afxyM (a_Xfy03 -> Data.Semigroup.Min a_Xfy03)
                    [LclId] =
                        [z_sfCC7] \u [] z_sfCC7 Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfCC6 $dData_sfCC3 sat_sfCC9; } in
        let {
          sat_sfCC5 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Min a_Xfy03
               -> c (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfCC3] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgfoldl
                      $dData_sfCC3 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCC4 [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfCC3] \u [] Data.Semigroup.$fDataMin8 $dData_sfCC3;
        } in 
          Data.Data.C:Data [sat_sfCC4
                            sat_sfCC5
                            sat_sfCCa
                            lvl12_rfC6O
                            lvl13_rfC6P
                            sat_sfCCb
                            lvl14_rfC6Q
                            sat_sfCCe
                            sat_sfCCk
                            sat_sfCCq
                            sat_sfCCu
                            sat_sfCCv
                            sat_sfCCw
                            sat_sfCCx
                            sat_sfCCy];

Data.Semigroup.$fDataMax3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataMax4];

Data.Semigroup.$tcMax :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10813679156066679206##
                                    10491840004411982061##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataMax3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep5_rfC6R :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcMax
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Max1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep5_rfC6R];

Data.Semigroup.$tc'Max3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Max"#;

Data.Semigroup.$tc'Max2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Max3];

Data.Semigroup.$tc'Max :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9964620667386625613##
                                    8300955803911017019##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Max2
                                    1#
                                    Data.Semigroup.$tc'Max1];

Data.Semigroup.$fDataMax2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Max
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                10813679156066679206##
                10491840004411982061##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataMax3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCCA [Occ=Once]
                   ww9_sfCCB [Occ=Once]
                   ww10_sfCCC [Occ=Once]
                   ww11_sfCCD [Occ=Once]
                   ww12_sfCCE [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCCA
                                              ww9_sfCCB
                                              ww10_sfCCC
                                              ww11_sfCCD
                                              ww12_sfCCE];
        };

Data.Semigroup.$fDataMax8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Max a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCCF]
        case Data.Data.$p1Data $dData_sfCCF of sat_sfCCG {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp Data.Semigroup.$fDataMax2 sat_sfCCG;
        };

Data.Semigroup.$fDataMax_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Max a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCCH $dTypeable_sfCCI]
        let {
          lvl33_sfCCJ [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCCI] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCCI Data.Semigroup.$fDataMax2; } in
        let {
          sat_sfCCN [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afxI8 (t_afxI7 d))
               -> GHC.Base.Maybe (c_afxI8 (Data.Semigroup.Max a_Xfy9s))
          [LclId] =
              [$dData_sfCCH lvl33_sfCCJ] \r [f_sfCCK]
                  case lvl33_sfCCJ of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCCM [Occ=Once] :: c_afxI8 (Data.Semigroup.Max a_Xfy9s)
                          [LclId] =
                              [$dData_sfCCH f_sfCCK] \u [] f_sfCCK $dData_sfCCH;
                        } in  GHC.Base.Just [sat_sfCCM];
                  };
        } in  sat_sfCCN;

Data.Semigroup.$fDataMax1
  :: forall a. (a -> Data.Semigroup.Max a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataMax_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Max a -> m (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCCO $dMonadPlus_sfCCP ds_sfCCQ eta_sfCCR]
        let {
          lvl33_sfCCS [Occ=OnceL] :: m_afxKd (Data.Semigroup.Max a_Xfy9B)
          [LclId] =
              [$dMonadPlus_sfCCP] \u [] GHC.Base.mzero $dMonadPlus_sfCCP;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCCP
          of
          $dMonad_sfCCT [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCDf [Occ=Once]
                    :: (Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                       -> m_afxKd (Data.Semigroup.Max a_Xfy9B)
                  [LclId] =
                      [lvl33_sfCCS $dMonad_sfCCT] \r [ds1_sfCDa]
                          case ds1_sfCDa of {
                            (,) x'_sfCDc [Occ=Once] b_sfCDd [Occ=Once!] ->
                                case b_sfCDd of {
                                  GHC.Types.False -> lvl33_sfCCS;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCCT x'_sfCDc;
                                };
                          }; } in
                let {
                  sat_sfCD9 [Occ=Once]
                    :: m_afxKd (Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCCO
                       $dMonadPlus_sfCCP
                       ds_sfCCQ
                       eta_sfCCR
                       $dMonad_sfCCT] \u []
                          let {
                            lvl34_sfCCU [Occ=OnceL] :: m_afxKd a_Xfy9B
                            [LclId] =
                                [$dData_sfCCO ds_sfCCQ eta_sfCCR] \u []
                                    ds_sfCCQ $dData_sfCCO eta_sfCCR; } in
                          let {
                            sat_sfCD8 [Occ=Once]
                              :: (a_Xfy9B -> Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                                 -> m_afxKd (Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCCP
                                 eta_sfCCR
                                 $dMonad_sfCCT
                                 lvl34_sfCCU] \r [ds1_sfCCW]
                                    case ds1_sfCCW of {
                                      (,) h_sfCCY b1_sfCCZ [Occ=Once] ->
                                          let {
                                            sat_sfCD7 [Occ=Once]
                                              :: m_afxKd (Data.Semigroup.Max a_Xfy9B,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfCCR $dMonad_sfCCT h_sfCCY b1_sfCCZ] \u []
                                                    let {
                                                      sat_sfCD5 [Occ=Once]
                                                        :: Data.Semigroup.Max a_Xfy9B
                                                      [LclId] =
                                                          [eta_sfCCR h_sfCCY] \u []
                                                              h_sfCCY eta_sfCCR; } in
                                                    let {
                                                      sat_sfCD6 [Occ=Once]
                                                        :: (Data.Semigroup.Max a_Xfy9B,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfCD5 b1_sfCCZ];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfCCT sat_sfCD6; } in
                                          let {
                                            sat_sfCD4 [Occ=Once]
                                              :: m_afxKd (Data.Semigroup.Max a_Xfy9B,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfCCT lvl34_sfCCU h_sfCCY] \u []
                                                    let {
                                                      sat_sfCD3 [Occ=Once]
                                                        :: a_Xfy9B
                                                           -> m_afxKd (Data.Semigroup.Max a_Xfy9B,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfCCT h_sfCCY] \r [y'_sfCD0]
                                                              let {
                                                                sat_sfCD1 [Occ=Once]
                                                                  :: Data.Semigroup.Max a_Xfy9B
                                                                [LclId] =
                                                                    [h_sfCCY y'_sfCD0] \u []
                                                                        h_sfCCY y'_sfCD0; } in
                                                              let {
                                                                sat_sfCD2 [Occ=Once]
                                                                  :: (Data.Semigroup.Max a_Xfy9B,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfCD1
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfCCT sat_sfCD2;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfCCT lvl34_sfCCU sat_sfCD3;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfCCP sat_sfCD4 sat_sfCD7;
                                    }; } in
                          let {
                            sat_sfCCV [Occ=Once]
                              :: m_afxKd (a_Xfy9B -> Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCCT] \u []
                                    GHC.Base.return $dMonad_sfCCT Data.Semigroup.$fDataMax1;
                          } in  GHC.Base.>>= $dMonad_sfCCT sat_sfCCV sat_sfCD8;
                } in  GHC.Base.>>= $dMonad_sfCCT sat_sfCD9 sat_sfCDf;
          };

Data.Semigroup.$fDataMax_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Max a -> m (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCDg $dMonad_sfCDh ds_sfCDi eta_sfCDj]
        let {
          lvl33_sfCDk [Occ=OnceL] :: m_afxJX a_Xfy9A
          [LclId] =
              [$dData_sfCDg ds_sfCDi eta_sfCDj] \u []
                  ds_sfCDi $dData_sfCDg eta_sfCDj; } in
        let {
          sat_sfCDq [Occ=Once]
            :: (a_Xfy9A -> Data.Semigroup.Max a_Xfy9A)
               -> m_afxJX (Data.Semigroup.Max a_Xfy9A)
          [LclId] =
              [$dMonad_sfCDh lvl33_sfCDk] \r [c'_sfCDm]
                  let {
                    sat_sfCDp [Occ=Once]
                      :: a_Xfy9A -> m_afxJX (Data.Semigroup.Max a_Xfy9A)
                    [LclId] =
                        [$dMonad_sfCDh c'_sfCDm] \r [x'_sfCDn]
                            let {
                              sat_sfCDo [Occ=Once] :: Data.Semigroup.Max a_Xfy9A
                              [LclId] =
                                  [c'_sfCDm x'_sfCDn] \u [] c'_sfCDm x'_sfCDn;
                            } in  GHC.Base.return $dMonad_sfCDh sat_sfCDo;
                  } in  GHC.Base.>>= $dMonad_sfCDh lvl33_sfCDk sat_sfCDp; } in
        let {
          sat_sfCDl [Occ=Once]
            :: m_afxJX (a_Xfy9A -> Data.Semigroup.Max a_Xfy9A)
          [LclId] =
              [$dMonad_sfCDh] \u []
                  GHC.Base.return $dMonad_sfCDh Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfCDh sat_sfCDl sat_sfCDq;

Data.Semigroup.$fDataMax_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Max a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCDr ds_sfCDs ds1_sfCDt x_sfCDu]
        case ds_sfCDs of {
          GHC.Types.I# x1_sfCDw [Occ=Once!] ->
              case x1_sfCDw of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfCDt $dData_sfCDr x_sfCDu;
              };
        };

Data.Semigroup.$fDataMax_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Max a -> m (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCDy $dMonadPlus_sfCDz ds_sfCDA eta_sfCDB]
        let {
          lvl33_sfCDC [Occ=OnceL] :: m_afxKt (Data.Semigroup.Max a_Xfy9u)
          [LclId] =
              [$dMonadPlus_sfCDz] \u [] GHC.Base.mzero $dMonadPlus_sfCDz;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCDz
          of
          $dMonad_sfCDD [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCE2 [Occ=Once]
                    :: (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                       -> m_afxKt (Data.Semigroup.Max a_Xfy9u)
                  [LclId] =
                      [lvl33_sfCDC $dMonad_sfCDD] \r [ds1_sfCDX]
                          case ds1_sfCDX of {
                            (,) x'_sfCDZ [Occ=Once] b_sfCE0 [Occ=Once!] ->
                                case b_sfCE0 of {
                                  GHC.Types.False -> lvl33_sfCDC;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCDD x'_sfCDZ;
                                };
                          }; } in
                let {
                  sat_sfCDW [Occ=Once]
                    :: m_afxKt (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCDy
                       $dMonadPlus_sfCDz
                       ds_sfCDA
                       eta_sfCDB
                       $dMonad_sfCDD] \u []
                          let {
                            lvl34_sfCDE [Occ=OnceL] :: m_afxKt a_Xfy9u
                            [LclId] =
                                [$dData_sfCDy ds_sfCDA eta_sfCDB] \u []
                                    ds_sfCDA $dData_sfCDy eta_sfCDB; } in
                          let {
                            sat_sfCDV [Occ=Once]
                              :: (a_Xfy9u -> Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                                 -> m_afxKt (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCDz
                                 eta_sfCDB
                                 $dMonad_sfCDD
                                 lvl34_sfCDE] \r [ds1_sfCDG]
                                    case ds1_sfCDG of {
                                      (,) h_sfCDI b1_sfCDJ [Occ=Once!] ->
                                          case b1_sfCDJ of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfCDS [Occ=Once]
                                                    :: m_afxKt (Data.Semigroup.Max a_Xfy9u,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfCDB $dMonad_sfCDD h_sfCDI] \u []
                                                          let {
                                                            sat_sfCDQ [Occ=Once]
                                                              :: Data.Semigroup.Max a_Xfy9u
                                                            [LclId] =
                                                                [eta_sfCDB h_sfCDI] \u []
                                                                    h_sfCDI eta_sfCDB; } in
                                                          let {
                                                            sat_sfCDR [Occ=Once]
                                                              :: (Data.Semigroup.Max a_Xfy9u,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfCDQ
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfCDD sat_sfCDR; } in
                                                let {
                                                  sat_sfCDP [Occ=Once]
                                                    :: m_afxKt (Data.Semigroup.Max a_Xfy9u,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfCDD lvl34_sfCDE h_sfCDI] \u []
                                                          let {
                                                            sat_sfCDO [Occ=Once]
                                                              :: a_Xfy9u
                                                                 -> m_afxKt (Data.Semigroup.Max
                                                                               a_Xfy9u,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCDD
                                                                 h_sfCDI] \r [y'_sfCDL]
                                                                    let {
                                                                      sat_sfCDM [Occ=Once]
                                                                        :: Data.Semigroup.Max
                                                                             a_Xfy9u
                                                                      [LclId] =
                                                                          [h_sfCDI y'_sfCDL] \u []
                                                                              h_sfCDI y'_sfCDL; } in
                                                                    let {
                                                                      sat_sfCDN [Occ=Once]
                                                                        :: (Data.Semigroup.Max
                                                                              a_Xfy9u,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCDM
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCDD sat_sfCDN;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfCDD lvl34_sfCDE sat_sfCDO;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfCDz sat_sfCDP sat_sfCDS;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfCDT [Occ=Once] :: Data.Semigroup.Max a_Xfy9u
                                                  [LclId] =
                                                      [eta_sfCDB h_sfCDI] \u []
                                                          h_sfCDI eta_sfCDB; } in
                                                let {
                                                  sat_sfCDU [Occ=Once]
                                                    :: (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfCDT GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfCDD sat_sfCDU;
                                          };
                                    }; } in
                          let {
                            sat_sfCDF [Occ=Once]
                              :: m_afxKt (a_Xfy9u -> Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCDD] \u []
                                    GHC.Base.return $dMonad_sfCDD Data.Semigroup.$fDataMax1;
                          } in  GHC.Base.>>= $dMonad_sfCDD sat_sfCDF sat_sfCDV;
                } in  GHC.Base.>>= $dMonad_sfCDD sat_sfCDW sat_sfCE2;
          };

lvl15_rfC6S :: forall a. Data.Semigroup.Max a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCE3] Data.Semigroup.$cMax;

lvl16_rfC6T :: forall a. Data.Semigroup.Max a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCE4] Data.Semigroup.$tMax;

lvl17_rfC6U
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Max a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCE5 ds_sfCE6] GHC.Base.Nothing [];

Data.Semigroup.$fDataMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCE7]
        let {
          sat_sfCEC [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Max a_Xfy9t -> m (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfCE7] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapMo
                      $dData_sfCE7 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCEB [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Max a_Xfy9t -> m (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfCE7] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapMp
                      $dData_sfCE7 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCEA [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Max a_Xfy9t -> m (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfCE7] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapM
                      $dData_sfCE7 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCEz [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Max a_Xfy9t
               -> u
          [LclId] =
              [$dData_sfCE7] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapQi
                      $dData_sfCE7 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCEy [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Max a_Xfy9t -> [u]
          [LclId] =
              [$dData_sfCE7] \r [ds_sfCEv x0_sfCEw]
                  let {
                    sat_sfCEx [Occ=Once] :: u_afxJv
                    [LclId] =
                        [$dData_sfCE7 ds_sfCEv x0_sfCEw] \u []
                            ds_sfCEv $dData_sfCE7 x0_sfCEw;
                  } in  : [sat_sfCEx GHC.Types.[]]; } in
        let {
          sat_sfCEu [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Max a_Xfy9t
               -> r
          [LclId] =
              [$dData_sfCE7] \r [ds_sfCEp ds1_sfCEq ds2_sfCEr x0_sfCEs]
                  let {
                    sat_sfCEt [Occ=Once] :: r'_afxJf
                    [LclId] =
                        [$dData_sfCE7 ds2_sfCEr x0_sfCEs] \u []
                            ds2_sfCEr $dData_sfCE7 x0_sfCEs;
                  } in  ds_sfCEp sat_sfCEt ds1_sfCEq; } in
        let {
          sat_sfCEo [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Max a_Xfy9t
               -> r
          [LclId] =
              [$dData_sfCE7] \r [ds_sfCEj ds1_sfCEk ds2_sfCEl eta_sfCEm]
                  let {
                    sat_sfCEn [Occ=Once] :: r'_afxIY
                    [LclId] =
                        [$dData_sfCE7 ds2_sfCEl eta_sfCEm] \u []
                            ds2_sfCEl $dData_sfCE7 eta_sfCEm;
                  } in  ds_sfCEj ds1_sfCEk sat_sfCEn; } in
        let {
          sat_sfCEi [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Max a_Xfy9t -> Data.Semigroup.Max a_Xfy9t
          [LclId] =
              [$dData_sfCE7] \r [ds_sfCEg x0_sfCEh]
                  ds_sfCEg $dData_sfCE7 x0_sfCEh; } in
        let {
          sat_sfCEf [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Max a_Xfy9t))
          [LclId] =
              [$dData_sfCE7] \r [eta_B1]
                  Data.Semigroup.$fDataMax_$cdataCast1 $dData_sfCE7 eta_B1; } in
        let {
          sat_sfCEe [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfCE7] \r [k_sfCEa z_sfCEb ds_sfCEc]
                  let {
                    sat_sfCEd [Occ=Once]
                      :: c_afxHO (a_Xfy9t -> Data.Semigroup.Max a_Xfy9t)
                    [LclId] =
                        [z_sfCEb] \u [] z_sfCEb Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfCEa $dData_sfCE7 sat_sfCEd; } in
        let {
          sat_sfCE9 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Max a_Xfy9t
               -> c (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfCE7] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgfoldl
                      $dData_sfCE7 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCE8 [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfCE7] \u [] Data.Semigroup.$fDataMax8 $dData_sfCE7;
        } in 
          Data.Data.C:Data [sat_sfCE8
                            sat_sfCE9
                            sat_sfCEe
                            lvl15_rfC6S
                            lvl16_rfC6T
                            sat_sfCEf
                            lvl17_rfC6U
                            sat_sfCEi
                            sat_sfCEo
                            sat_sfCEu
                            sat_sfCEy
                            sat_sfCEz
                            sat_sfCEA
                            sat_sfCEB
                            sat_sfCEC];

Data.Semigroup.$fDataArg5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataArg6];

Data.Semigroup.$tcArg :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12181131229304595757##
                                    13964868205162960136##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataArg5
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep6_rfC6V :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rfC6J GHC.Types.[]];

$krep7_rfC6W :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rfC6K $krep6_rfC6V];

$krep8_rfC6X :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcArg
                                              $krep7_rfC6W];

$krep9_rfC6Y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rfC6J $krep8_rfC6X];

Data.Semigroup.$tc'Arg1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep9_rfC6Y];

Data.Semigroup.$tc'Arg3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Arg"#;

Data.Semigroup.$tc'Arg2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Arg3];

Data.Semigroup.$tc'Arg :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1079323530693211499##
                                    7260223244427450599##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Arg2
                                    2#
                                    Data.Semigroup.$tc'Arg1];

Data.Semigroup.$fDataArg4
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Arg
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                12181131229304595757##
                13964868205162960136##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataArg5
                0#
                GHC.Types.krep$*->*->*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCEE [Occ=Once]
                   ww9_sfCEF [Occ=Once]
                   ww10_sfCEG [Occ=Once]
                   ww11_sfCEH [Occ=Once]
                   ww12_sfCEI [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCEE
                                              ww9_sfCEF
                                              ww10_sfCEG
                                              ww11_sfCEH
                                              ww12_sfCEI];
        };

Data.Semigroup.$fDataArg10
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Arg a b)
[GblId,
 Arity=2,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCEJ $dData1_sfCEK]
        case Data.Data.$p1Data $dData1_sfCEK of sat_sfCEN {
          __DEFAULT ->
              case Data.Data.$p1Data $dData_sfCEJ of sat_sfCEL {
                __DEFAULT ->
                    case
                        Data.Typeable.Internal.mkTrApp Data.Semigroup.$fDataArg4 sat_sfCEL
                    of
                    sat_sfCEM
                    { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sfCEM sat_sfCEN;
                    };
              };
        };

Data.Semigroup.$fDataArg_$cdataCast2
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Arg a b))
[GblId, Arity=3, Str=<L,U><L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCEO $dData1_sfCEP $dTypeable_sfCEQ]
        let {
          lvl33_sfCER [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCEQ] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCEQ Data.Semigroup.$fDataArg4; } in
        let {
          sat_sfCEV [Occ=OnceT[0]]
            :: (forall d e.
                (Data.Data.Data d, Data.Data.Data e) =>
                c_afxP3 (t_afxP2 d e))
               -> GHC.Base.Maybe (c_afxP3 (Data.Semigroup.Arg a_Xfygm b_Xfygo))
          [LclId] =
              [$dData_sfCEO $dData1_sfCEP lvl33_sfCER] \r [f_sfCES]
                  case lvl33_sfCER of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCEU [Occ=Once]
                            :: c_afxP3 (Data.Semigroup.Arg a_Xfygm b_Xfygo)
                          [LclId] =
                              [$dData_sfCEO $dData1_sfCEP f_sfCES] \u []
                                  f_sfCES $dData_sfCEO $dData1_sfCEP;
                        } in  GHC.Base.Just [sat_sfCEU];
                  };
        } in  sat_sfCEV;

Data.Semigroup.$fDataArg1
  :: forall b a. (a -> b -> Data.Semigroup.Arg a b, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.Arg GHC.Types.False];

Data.Semigroup.$fDataArg_$cgmapMp
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Arg a b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCEW
           $dData1_sfCEX
           $dMonadPlus_sfCEY
           ds_sfCEZ
           eta_sfCF0]
        let {
          lvl33_sfCF1 [Occ=OnceL]
            :: m_afxQP (Data.Semigroup.Arg a_Xfygv b_Xfygx)
          [LclId] =
              [$dMonadPlus_sfCEY] \u [] GHC.Base.mzero $dMonadPlus_sfCEY;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCEY
          of
          $dMonad_sfCF2 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCFw [Occ=Once]
                    :: (Data.Semigroup.Arg a_Xfygv b_Xfygx, GHC.Types.Bool)
                       -> m_afxQP (Data.Semigroup.Arg a_Xfygv b_Xfygx)
                  [LclId] =
                      [lvl33_sfCF1 $dMonad_sfCF2] \r [ds1_sfCFr]
                          case ds1_sfCFr of {
                            (,) x'_sfCFt [Occ=Once] b1_sfCFu [Occ=Once!] ->
                                case b1_sfCFu of {
                                  GHC.Types.False -> lvl33_sfCF1;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCF2 x'_sfCFt;
                                };
                          }; } in
                let {
                  sat_sfCFq [Occ=Once]
                    :: m_afxQP (Data.Semigroup.Arg a_Xfygv b_Xfygx, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCEW
                       $dData1_sfCEX
                       $dMonadPlus_sfCEY
                       ds_sfCEZ
                       eta_sfCF0
                       $dMonad_sfCF2] \u []
                          case eta_sfCF0 of {
                            Data.Semigroup.Arg a1_sfCF4 [Occ=Once] a2_sfCF5 [Occ=Once] ->
                                let {
                                  k_sfCF6 [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b1.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_afxQP (d -> b1)
                                       -> d -> m_afxQP (b1, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sfCEY
                                                ds_sfCEZ
                                                $dMonad_sfCF2] \r [$dData2_sfCF7 ds1_sfCF8 y_sfCF9]
                                          let {
                                            lvl34_sfCFa [Occ=OnceL] :: m_afxQP d_ae2Ws
                                            [LclId] =
                                                [ds_sfCEZ $dData2_sfCF7 y_sfCF9] \u []
                                                    ds_sfCEZ $dData2_sfCF7 y_sfCF9; } in
                                          let {
                                            sat_sfCFn [Occ=Once]
                                              :: (d_ae2Ws -> b1_ae2Wt, GHC.Types.Bool)
                                                 -> m_afxQP (b1_ae2Wt, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sfCEY
                                                 $dMonad_sfCF2
                                                 y_sfCF9
                                                 lvl34_sfCFa] \r [ds2_sfCFb]
                                                    case ds2_sfCFb of {
                                                      (,) h_sfCFd b2_sfCFe [Occ=Once] ->
                                                          let {
                                                            sat_sfCFm [Occ=Once]
                                                              :: m_afxQP (b1_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCF2
                                                                 y_sfCF9
                                                                 h_sfCFd
                                                                 b2_sfCFe] \u []
                                                                    let {
                                                                      sat_sfCFk [Occ=Once]
                                                                        :: b1_ae2Wt
                                                                      [LclId] =
                                                                          [y_sfCF9 h_sfCFd] \u []
                                                                              h_sfCFd y_sfCF9; } in
                                                                    let {
                                                                      sat_sfCFl [Occ=Once]
                                                                        :: (b1_ae2Wt,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCFk
                                                                                     b2_sfCFe];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCF2
                                                                          sat_sfCFl; } in
                                                          let {
                                                            sat_sfCFj [Occ=Once]
                                                              :: m_afxQP (b1_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCF2
                                                                 lvl34_sfCFa
                                                                 h_sfCFd] \u []
                                                                    let {
                                                                      sat_sfCFi [Occ=Once]
                                                                        :: d_ae2Ws
                                                                           -> m_afxQP (b1_ae2Wt,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sfCF2
                                                                           h_sfCFd] \r [y'_sfCFf]
                                                                              let {
                                                                                sat_sfCFg [Occ=Once]
                                                                                  :: b1_ae2Wt
                                                                                [LclId] =
                                                                                    [h_sfCFd
                                                                                     y'_sfCFf] \u []
                                                                                        h_sfCFd
                                                                                            y'_sfCFf; } in
                                                                              let {
                                                                                sat_sfCFh [Occ=Once]
                                                                                  :: (b1_ae2Wt,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sfCFg
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sfCF2
                                                                                    sat_sfCFh;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sfCF2
                                                                          lvl34_sfCFa
                                                                          sat_sfCFi;
                                                          } in 
                                                            GHC.Base.mplus
                                                                $dMonadPlus_sfCEY
                                                                sat_sfCFj
                                                                sat_sfCFm;
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sfCF2 ds1_sfCF8 sat_sfCFn; } in
                                let {
                                  sat_sfCFp [Occ=Once]
                                    :: Data.Data.Mp
                                         m_afxQP (b_Xfygx -> Data.Semigroup.Arg a_Xfygv b_Xfygx)
                                  [LclId] =
                                      [$dData_sfCEW $dMonad_sfCF2 a1_sfCF4 k_sfCF6] \u []
                                          let {
                                            sat_sfCFo [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_afxQP
                                                   (a_Xfygv
                                                    -> b_Xfygx
                                                    -> Data.Semigroup.Arg a_Xfygv b_Xfygx)
                                            [LclId] =
                                                [$dMonad_sfCF2] \u []
                                                    GHC.Base.return
                                                        $dMonad_sfCF2 Data.Semigroup.$fDataArg1;
                                          } in  k_sfCF6 $dData_sfCEW sat_sfCFo a1_sfCF4;
                                } in  k_sfCF6 $dData1_sfCEX sat_sfCFp a2_sfCF5;
                          };
                } in  GHC.Base.>>= $dMonad_sfCF2 sat_sfCFq sat_sfCFw;
          };

Data.Semigroup.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> a -> b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfCFx w1_sfCFy w2_sfCFz w3_sfCFA ww_sfCFB ww1_sfCFC]
        let {
          k_sfCFD [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
            :: forall d b1.
               Data.Data.Data d =>
               m_sfBu8 (d -> b1) -> d -> m_sfBu8 b1
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w2_sfCFz w3_sfCFA] \r [$dData1_sfCFE c_sfCFF x_sfCFG]
                  let {
                    lvl33_sfCFH [Occ=OnceL] :: m_sfBu8 d_ae2Vh
                    [LclId] =
                        [w3_sfCFA $dData1_sfCFE x_sfCFG] \u []
                            w3_sfCFA $dData1_sfCFE x_sfCFG; } in
                  let {
                    sat_sfCFM [Occ=Once] :: (d_ae2Vh -> b1_ae2Vi) -> m_sfBu8 b1_ae2Vi
                    [LclId] =
                        [w2_sfCFz lvl33_sfCFH] \r [c'_sfCFI]
                            let {
                              sat_sfCFL [Occ=Once] :: d_ae2Vh -> m_sfBu8 b1_ae2Vi
                              [LclId] =
                                  [w2_sfCFz c'_sfCFI] \r [x'_sfCFJ]
                                      let {
                                        sat_sfCFK [Occ=Once] :: b1_ae2Vi
                                        [LclId] =
                                            [c'_sfCFI x'_sfCFJ] \u [] c'_sfCFI x'_sfCFJ;
                                      } in  GHC.Base.return w2_sfCFz sat_sfCFK;
                            } in  GHC.Base.>>= w2_sfCFz lvl33_sfCFH sat_sfCFL;
                  } in  GHC.Base.>>= w2_sfCFz c_sfCFF sat_sfCFM; } in
        let {
          sat_sfCFO [Occ=Once]
            :: m_sfBu8 (b_sfBu5 -> Data.Semigroup.Arg a_sfBu4 b_sfBu5)
          [LclId] =
              [w_sfCFx w2_sfCFz ww_sfCFB k_sfCFD] \u []
                  let {
                    sat_sfCFN [Occ=Once]
                      :: m_sfBu8 (a_sfBu4
                                  -> b_sfBu5 -> Data.Semigroup.Arg a_sfBu4 b_sfBu5)
                    [LclId] =
                        [w2_sfCFz] \u [] GHC.Base.return w2_sfCFz Data.Semigroup.Arg;
                  } in  k_sfCFD w_sfCFx sat_sfCFN ww_sfCFB;
        } in  k_sfCFD w1_sfCFy sat_sfCFO ww1_sfCFC;

Data.Semigroup.$fDataArg_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Arg a b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sfCFP w1_sfCFQ w2_sfCFR w3_sfCFS w4_sfCFT]
        case w4_sfCFT of {
          Data.Semigroup.Arg ww1_sfCFV [Occ=Once] ww2_sfCFW [Occ=Once] ->
              Data.Semigroup.$w$cgmapM
                  w_sfCFP w1_sfCFQ w2_sfCFR w3_sfCFS ww1_sfCFV ww2_sfCFW;
        };

Data.Semigroup.$fDataArg_$cgmapQi
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Arg a b
     -> u
[GblId,
 Arity=5,
 Str=<L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCFX $dData1_sfCFY ds_sfCFZ ds1_sfCG0 x_sfCG1]
        case x_sfCG1 of {
          Data.Semigroup.Arg a1_sfCG3 [Occ=Once] a2_sfCG4 [Occ=Once] ->
              case ds_sfCFZ of {
                GHC.Types.I# x1_sfCG6 [Occ=Once!] ->
                    case x1_sfCG6 of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sfCG0 $dData_sfCFX a1_sfCG3;
                      1# -> ds1_sfCG0 $dData1_sfCFY a2_sfCG4;
                    };
              };
        };

Data.Semigroup.$fDataArg_$cgmapQr
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Arg a b
     -> r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCG8
           $dData1_sfCG9
           ds_sfCGa
           ds1_sfCGb
           ds2_sfCGc
           x0_sfCGd]
        case x0_sfCGd of {
          Data.Semigroup.Arg a1_sfCGf [Occ=Once] a2_sfCGg [Occ=Once] ->
              let {
                sat_sfCGj [Occ=Once] :: r_afxPQ
                [LclId] =
                    [$dData1_sfCG9 ds_sfCGa ds1_sfCGb ds2_sfCGc a2_sfCGg] \u []
                        let {
                          sat_sfCGi [Occ=Once] :: r'_afxPR
                          [LclId] =
                              [$dData1_sfCG9 ds2_sfCGc a2_sfCGg] \u []
                                  ds2_sfCGc $dData1_sfCG9 a2_sfCGg;
                        } in  ds_sfCGa sat_sfCGi ds1_sfCGb; } in
              let {
                sat_sfCGh [Occ=Once] :: r'_afxPR
                [LclId] =
                    [$dData_sfCG8 ds2_sfCGc a1_sfCGf] \u []
                        ds2_sfCGc $dData_sfCG8 a1_sfCGf;
              } in  ds_sfCGa sat_sfCGh sat_sfCGj;
        };

Data.Semigroup.$fDataArg_$cgmapQ
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Arg a b -> [u]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,C(C1(U))><S,1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [$dData_sfCGk $dData1_sfCGl ds_sfCGm x0_sfCGn]
        case x0_sfCGn of {
          Data.Semigroup.Arg a1_sfCGp [Occ=Once] a2_sfCGq [Occ=Once] ->
              let {
                sat_sfCGs [Occ=Once] :: u_afxQ7
                [LclId] =
                    [$dData1_sfCGl ds_sfCGm a2_sfCGq] \u []
                        ds_sfCGm $dData1_sfCGl a2_sfCGq; } in
              let {
                sat_sfCGt [Occ=Once] :: [u_afxQ7]
                [LclId] =
                    CCCS :! [sat_sfCGs GHC.Types.[]]; } in
              let {
                sat_sfCGr [Occ=Once] :: u_afxQ7
                [LclId] =
                    [$dData_sfCGk ds_sfCGm a1_sfCGp] \u []
                        ds_sfCGm $dData_sfCGk a1_sfCGp;
              } in  : [sat_sfCGr sat_sfCGt];
        };

Data.Semigroup.$fDataArg2
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Arg a b
     -> Data.Functor.Const.Const r (Data.Semigroup.Arg a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCGu
           $dData1_sfCGv
           ds_sfCGw
           ds1_sfCGx
           ds2_sfCGy
           eta_sfCGz]
        case eta_sfCGz of {
          Data.Semigroup.Arg a1_sfCGB [Occ=Once] a2_sfCGC [Occ=Once] ->
              let {
                sat_sfCGF [Occ=Once] :: r'_afxPA
                [LclId] =
                    [$dData1_sfCGv ds2_sfCGy a2_sfCGC] \u []
                        ds2_sfCGy $dData1_sfCGv a2_sfCGC; } in
              let {
                sat_sfCGE [Occ=Once] :: r_afxPz
                [LclId] =
                    [$dData_sfCGu ds_sfCGw ds1_sfCGx ds2_sfCGy a1_sfCGB] \u []
                        let {
                          sat_sfCGD [Occ=Once] :: r'_afxPA
                          [LclId] =
                              [$dData_sfCGu ds2_sfCGy a1_sfCGB] \u []
                                  ds2_sfCGy $dData_sfCGu a1_sfCGB;
                        } in  ds_sfCGw ds1_sfCGx sat_sfCGD;
              } in  ds_sfCGw sat_sfCGE sat_sfCGF;
        };

Data.Semigroup.$fDataArg3
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     (forall b1. Data.Data.Data b1 => b1 -> b1)
     -> Data.Semigroup.Arg a b
     -> Data.Functor.Identity.Identity (Data.Semigroup.Arg a b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,C(C1(U))><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dData_sfCGG $dData1_sfCGH ds_sfCGI x0_sfCGJ]
        case x0_sfCGJ of {
          Data.Semigroup.Arg a1_sfCGL [Occ=Once] a2_sfCGM [Occ=Once] ->
              let {
                sat_sfCGO [Occ=Once] :: b_Xfygr
                [LclId] =
                    [$dData1_sfCGH ds_sfCGI a2_sfCGM] \u []
                        ds_sfCGI $dData1_sfCGH a2_sfCGM; } in
              let {
                sat_sfCGN [Occ=Once] :: a_Xfygp
                [LclId] =
                    [$dData_sfCGG ds_sfCGI a1_sfCGL] \u []
                        ds_sfCGI $dData_sfCGG a1_sfCGL;
              } in  Data.Semigroup.Arg [sat_sfCGN sat_sfCGO];
        };

Data.Semigroup.$fDataArg_$cgmapMo
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Arg a b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCGP
           $dData1_sfCGQ
           $dMonadPlus_sfCGR
           ds_sfCGS
           eta_sfCGT]
        let {
          lvl33_sfCGU [Occ=OnceL]
            :: m_afxR5 (Data.Semigroup.Arg a_Xfygo b_XfyDI)
          [LclId] =
              [$dMonadPlus_sfCGR] \u [] GHC.Base.mzero $dMonadPlus_sfCGR;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCGR
          of
          $dMonad_sfCGV [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCHs [Occ=Once]
                    :: (Data.Semigroup.Arg a_Xfygo b_XfyDI, GHC.Types.Bool)
                       -> m_afxR5 (Data.Semigroup.Arg a_Xfygo b_XfyDI)
                  [LclId] =
                      [lvl33_sfCGU $dMonad_sfCGV] \r [ds1_sfCHn]
                          case ds1_sfCHn of {
                            (,) x'_sfCHp [Occ=Once] b1_sfCHq [Occ=Once!] ->
                                case b1_sfCHq of {
                                  GHC.Types.False -> lvl33_sfCGU;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCGV x'_sfCHp;
                                };
                          }; } in
                let {
                  sat_sfCHm [Occ=Once]
                    :: m_afxR5 (Data.Semigroup.Arg a_Xfygo b_XfyDI, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCGP
                       $dData1_sfCGQ
                       $dMonadPlus_sfCGR
                       ds_sfCGS
                       eta_sfCGT
                       $dMonad_sfCGV] \u []
                          case eta_sfCGT of {
                            Data.Semigroup.Arg a1_sfCGX [Occ=Once] a2_sfCGY [Occ=Once] ->
                                let {
                                  k_sfCGZ [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b1.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_afxR5 (d -> b1)
                                       -> d -> m_afxR5 (b1, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sfCGR
                                                ds_sfCGS
                                                $dMonad_sfCGV] \r [$dData2_sfCH0 ds1_sfCH1 y_sfCH2]
                                          let {
                                            lvl34_sfCH3 [Occ=OnceL] :: m_afxR5 d_ae2Ya
                                            [LclId] =
                                                [ds_sfCGS $dData2_sfCH0 y_sfCH2] \u []
                                                    ds_sfCGS $dData2_sfCH0 y_sfCH2; } in
                                          let {
                                            sat_sfCHj [Occ=Once]
                                              :: (d_ae2Ya -> b1_ae2Yb, GHC.Types.Bool)
                                                 -> m_afxR5 (b1_ae2Yb, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sfCGR
                                                 $dMonad_sfCGV
                                                 y_sfCH2
                                                 lvl34_sfCH3] \r [ds2_sfCH4]
                                                    case ds2_sfCH4 of {
                                                      (,) h_sfCH6 b2_sfCH7 [Occ=Once!] ->
                                                          case b2_sfCH7 of {
                                                            GHC.Types.False ->
                                                                let {
                                                                  sat_sfCHg [Occ=Once]
                                                                    :: m_afxR5 (b1_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sfCGV
                                                                       y_sfCH2
                                                                       h_sfCH6] \u []
                                                                          let {
                                                                            sat_sfCHe [Occ=Once]
                                                                              :: b1_ae2Yb
                                                                            [LclId] =
                                                                                [y_sfCH2
                                                                                 h_sfCH6] \u []
                                                                                    h_sfCH6
                                                                                        y_sfCH2; } in
                                                                          let {
                                                                            sat_sfCHf [Occ=Once]
                                                                              :: (b1_ae2Yb,
                                                                                  GHC.Types.Bool)
                                                                            [LclId] =
                                                                                CCCS (,)! [sat_sfCHe
                                                                                           GHC.Types.False];
                                                                          } in 
                                                                            GHC.Base.return
                                                                                $dMonad_sfCGV
                                                                                sat_sfCHf; } in
                                                                let {
                                                                  sat_sfCHd [Occ=Once]
                                                                    :: m_afxR5 (b1_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sfCGV
                                                                       lvl34_sfCH3
                                                                       h_sfCH6] \u []
                                                                          let {
                                                                            sat_sfCHc [Occ=Once]
                                                                              :: d_ae2Ya
                                                                                 -> m_afxR5 (b1_ae2Yb,
                                                                                             GHC.Types.Bool)
                                                                            [LclId] =
                                                                                [$dMonad_sfCGV
                                                                                 h_sfCH6] \r [y'_sfCH9]
                                                                                    let {
                                                                                      sat_sfCHa [Occ=Once]
                                                                                        :: b1_ae2Yb
                                                                                      [LclId] =
                                                                                          [h_sfCH6
                                                                                           y'_sfCH9] \u []
                                                                                              h_sfCH6
                                                                                                  y'_sfCH9; } in
                                                                                    let {
                                                                                      sat_sfCHb [Occ=Once]
                                                                                        :: (b1_ae2Yb,
                                                                                            GHC.Types.Bool)
                                                                                      [LclId] =
                                                                                          CCCS (,)! [sat_sfCHa
                                                                                                     GHC.Types.True];
                                                                                    } in 
                                                                                      GHC.Base.return
                                                                                          $dMonad_sfCGV
                                                                                          sat_sfCHb;
                                                                          } in 
                                                                            GHC.Base.>>=
                                                                                $dMonad_sfCGV
                                                                                lvl34_sfCH3
                                                                                sat_sfCHc;
                                                                } in 
                                                                  GHC.Base.mplus
                                                                      $dMonadPlus_sfCGR
                                                                      sat_sfCHd
                                                                      sat_sfCHg;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_sfCHh [Occ=Once] :: b1_ae2Yb
                                                                  [LclId] =
                                                                      [y_sfCH2 h_sfCH6] \u []
                                                                          h_sfCH6 y_sfCH2; } in
                                                                let {
                                                                  sat_sfCHi [Occ=Once]
                                                                    :: (b1_ae2Yb, GHC.Types.Bool)
                                                                  [LclId] =
                                                                      CCCS (,)! [sat_sfCHh
                                                                                 GHC.Types.True];
                                                                } in 
                                                                  GHC.Base.return
                                                                      $dMonad_sfCGV sat_sfCHi;
                                                          };
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sfCGV ds1_sfCH1 sat_sfCHj; } in
                                let {
                                  sat_sfCHl [Occ=Once]
                                    :: Data.Data.Mp
                                         m_afxR5 (b_XfyDI -> Data.Semigroup.Arg a_Xfygo b_XfyDI)
                                  [LclId] =
                                      [$dData_sfCGP $dMonad_sfCGV a1_sfCGX k_sfCGZ] \u []
                                          let {
                                            sat_sfCHk [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_afxR5
                                                   (a_Xfygo
                                                    -> b_XfyDI
                                                    -> Data.Semigroup.Arg a_Xfygo b_XfyDI)
                                            [LclId] =
                                                [$dMonad_sfCGV] \u []
                                                    GHC.Base.return
                                                        $dMonad_sfCGV Data.Semigroup.$fDataArg1;
                                          } in  k_sfCGZ $dData_sfCGP sat_sfCHk a1_sfCGX;
                                } in  k_sfCGZ $dData1_sfCGQ sat_sfCHl a2_sfCGY;
                          };
                } in  GHC.Base.>>= $dMonad_sfCGV sat_sfCHm sat_sfCHs;
          };

lvl18_rfC6Z
  :: forall b a. Data.Semigroup.Arg a b -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_sfCHt]
        case ds_sfCHt of {
          Data.Semigroup.Arg _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Semigroup.$cArg;
        };

lvl19_rfC70
  :: forall a b. Data.Semigroup.Arg a b -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCHx] Data.Semigroup.$tArg;

lvl20_rfC71
  :: forall a b (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Arg a b))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCHy ds_sfCHz] GHC.Base.Nothing [];

Data.Semigroup.$fDataArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     Data.Data.Data (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCHA $dData1_sfCHB]
        let {
          sat_sfCHN [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> m (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapMo
                      $dData_sfCHA $dData1_sfCHB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHM [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> m (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapMp
                      $dData_sfCHA $dData1_sfCHB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHL [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> m (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapM
                      $dData_sfCHA $dData1_sfCHB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHK [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> u
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapQi
                      $dData_sfCHA $dData1_sfCHB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHJ [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI -> [u]
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapQ
                      $dData_sfCHA $dData1_sfCHB eta_B2 eta_B1; } in
        let {
          sat_sfCHI [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> r
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapQr
                      $dData_sfCHA $dData1_sfCHB eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHH [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> r
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg2
                      $dData_sfCHA $dData1_sfCHB eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHG [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg3
                      $dData_sfCHA $dData1_sfCHB eta_B2 eta_B1; } in
        let {
          sat_sfCHF [Occ=Once]
            :: forall (t :: * -> * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
               -> GHC.Base.Maybe (c (Data.Semigroup.Arg a_Xfygn b_XfyDI))
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B1]
                  Data.Semigroup.$fDataArg_$cdataCast2
                      $dData_sfCHA $dData1_sfCHB eta_B1; } in
        let {
          sat_sfCHE [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgunfold
                      $dData_sfCHA $dData1_sfCHB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHD [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> c (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgfoldl
                      $dData_sfCHA $dData1_sfCHB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCHC [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfCHA $dData1_sfCHB] \u []
                  Data.Semigroup.$fDataArg10 $dData_sfCHA $dData1_sfCHB;
        } in 
          Data.Data.C:Data [sat_sfCHC
                            sat_sfCHD
                            sat_sfCHE
                            lvl18_rfC6Z
                            lvl19_rfC70
                            lvl20_rfC71
                            sat_sfCHF
                            sat_sfCHG
                            sat_sfCHH
                            sat_sfCHI
                            sat_sfCHJ
                            sat_sfCHK
                            sat_sfCHL
                            sat_sfCHM
                            sat_sfCHN];

Data.Semigroup.$fDataFirst3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataFirst4];

Data.Semigroup.$tcFirst :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5289672677956055491##
                                    1507157566582617174##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataFirst3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep10_rfC72 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcFirst
                                              $krep2_rfC6L];

Data.Semigroup.$tc'First1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep10_rfC72];

Data.Semigroup.$tc'First3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'First"#;

Data.Semigroup.$tc'First2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'First3];

Data.Semigroup.$tc'First :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14746522314279732838##
                                    14022550265149674723##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'First2
                                    1#
                                    Data.Semigroup.$tc'First1];

Data.Semigroup.$fDataFirst2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.First
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                5289672677956055491##
                1507157566582617174##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataFirst3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCHP [Occ=Once]
                   ww9_sfCHQ [Occ=Once]
                   ww10_sfCHR [Occ=Once]
                   ww11_sfCHS [Occ=Once]
                   ww12_sfCHT [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCHP
                                              ww9_sfCHQ
                                              ww10_sfCHR
                                              ww11_sfCHS
                                              ww12_sfCHT];
        };

Data.Semigroup.$fDataFirst8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.First a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCHU]
        case Data.Data.$p1Data $dData_sfCHU of sat_sfCHV {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataFirst2 sat_sfCHV;
        };

Data.Semigroup.$fDataFirst_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.First a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCHW $dTypeable_sfCHX]
        let {
          lvl33_sfCHY [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCHX] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCHX Data.Semigroup.$fDataFirst2; } in
        let {
          sat_sfCI2 [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afxYL (t_afxYK d))
               -> GHC.Base.Maybe (c_afxYL (Data.Semigroup.First a_XfyqV))
          [LclId] =
              [$dData_sfCHW lvl33_sfCHY] \r [f_sfCHZ]
                  case lvl33_sfCHY of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCI1 [Occ=Once] :: c_afxYL (Data.Semigroup.First a_XfyqV)
                          [LclId] =
                              [$dData_sfCHW f_sfCHZ] \u [] f_sfCHZ $dData_sfCHW;
                        } in  GHC.Base.Just [sat_sfCI1];
                  };
        } in  sat_sfCI2;

Data.Semigroup.$fDataFirst1
  :: forall a. (a -> Data.Semigroup.First a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataFirst_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.First a -> m (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCI3 $dMonadPlus_sfCI4 ds_sfCI5 eta_sfCI6]
        let {
          lvl33_sfCI7 [Occ=OnceL] :: m_afy0Q (Data.Semigroup.First a_Xfyr4)
          [LclId] =
              [$dMonadPlus_sfCI4] \u [] GHC.Base.mzero $dMonadPlus_sfCI4;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCI4
          of
          $dMonad_sfCI8 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCIu [Occ=Once]
                    :: (Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                       -> m_afy0Q (Data.Semigroup.First a_Xfyr4)
                  [LclId] =
                      [lvl33_sfCI7 $dMonad_sfCI8] \r [ds1_sfCIp]
                          case ds1_sfCIp of {
                            (,) x'_sfCIr [Occ=Once] b_sfCIs [Occ=Once!] ->
                                case b_sfCIs of {
                                  GHC.Types.False -> lvl33_sfCI7;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCI8 x'_sfCIr;
                                };
                          }; } in
                let {
                  sat_sfCIo [Occ=Once]
                    :: m_afy0Q (Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCI3
                       $dMonadPlus_sfCI4
                       ds_sfCI5
                       eta_sfCI6
                       $dMonad_sfCI8] \u []
                          let {
                            lvl34_sfCI9 [Occ=OnceL] :: m_afy0Q a_Xfyr4
                            [LclId] =
                                [$dData_sfCI3 ds_sfCI5 eta_sfCI6] \u []
                                    ds_sfCI5 $dData_sfCI3 eta_sfCI6; } in
                          let {
                            sat_sfCIn [Occ=Once]
                              :: (a_Xfyr4 -> Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                                 -> m_afy0Q (Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCI4
                                 eta_sfCI6
                                 $dMonad_sfCI8
                                 lvl34_sfCI9] \r [ds1_sfCIb]
                                    case ds1_sfCIb of {
                                      (,) h_sfCId b1_sfCIe [Occ=Once] ->
                                          let {
                                            sat_sfCIm [Occ=Once]
                                              :: m_afy0Q (Data.Semigroup.First a_Xfyr4,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfCI6 $dMonad_sfCI8 h_sfCId b1_sfCIe] \u []
                                                    let {
                                                      sat_sfCIk [Occ=Once]
                                                        :: Data.Semigroup.First a_Xfyr4
                                                      [LclId] =
                                                          [eta_sfCI6 h_sfCId] \u []
                                                              h_sfCId eta_sfCI6; } in
                                                    let {
                                                      sat_sfCIl [Occ=Once]
                                                        :: (Data.Semigroup.First a_Xfyr4,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfCIk b1_sfCIe];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfCI8 sat_sfCIl; } in
                                          let {
                                            sat_sfCIj [Occ=Once]
                                              :: m_afy0Q (Data.Semigroup.First a_Xfyr4,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfCI8 lvl34_sfCI9 h_sfCId] \u []
                                                    let {
                                                      sat_sfCIi [Occ=Once]
                                                        :: a_Xfyr4
                                                           -> m_afy0Q (Data.Semigroup.First a_Xfyr4,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfCI8 h_sfCId] \r [y'_sfCIf]
                                                              let {
                                                                sat_sfCIg [Occ=Once]
                                                                  :: Data.Semigroup.First a_Xfyr4
                                                                [LclId] =
                                                                    [h_sfCId y'_sfCIf] \u []
                                                                        h_sfCId y'_sfCIf; } in
                                                              let {
                                                                sat_sfCIh [Occ=Once]
                                                                  :: (Data.Semigroup.First a_Xfyr4,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfCIg
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfCI8 sat_sfCIh;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfCI8 lvl34_sfCI9 sat_sfCIi;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfCI4 sat_sfCIj sat_sfCIm;
                                    }; } in
                          let {
                            sat_sfCIa [Occ=Once]
                              :: m_afy0Q (a_Xfyr4 -> Data.Semigroup.First a_Xfyr4,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCI8] \u []
                                    GHC.Base.return $dMonad_sfCI8 Data.Semigroup.$fDataFirst1;
                          } in  GHC.Base.>>= $dMonad_sfCI8 sat_sfCIa sat_sfCIn;
                } in  GHC.Base.>>= $dMonad_sfCI8 sat_sfCIo sat_sfCIu;
          };

Data.Semigroup.$fDataFirst_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.First a -> m (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCIv $dMonad_sfCIw ds_sfCIx eta_sfCIy]
        let {
          lvl33_sfCIz [Occ=OnceL] :: m_afy0A a_Xfyr3
          [LclId] =
              [$dData_sfCIv ds_sfCIx eta_sfCIy] \u []
                  ds_sfCIx $dData_sfCIv eta_sfCIy; } in
        let {
          sat_sfCIF [Occ=Once]
            :: (a_Xfyr3 -> Data.Semigroup.First a_Xfyr3)
               -> m_afy0A (Data.Semigroup.First a_Xfyr3)
          [LclId] =
              [$dMonad_sfCIw lvl33_sfCIz] \r [c'_sfCIB]
                  let {
                    sat_sfCIE [Occ=Once]
                      :: a_Xfyr3 -> m_afy0A (Data.Semigroup.First a_Xfyr3)
                    [LclId] =
                        [$dMonad_sfCIw c'_sfCIB] \r [x'_sfCIC]
                            let {
                              sat_sfCID [Occ=Once] :: Data.Semigroup.First a_Xfyr3
                              [LclId] =
                                  [c'_sfCIB x'_sfCIC] \u [] c'_sfCIB x'_sfCIC;
                            } in  GHC.Base.return $dMonad_sfCIw sat_sfCID;
                  } in  GHC.Base.>>= $dMonad_sfCIw lvl33_sfCIz sat_sfCIE; } in
        let {
          sat_sfCIA [Occ=Once]
            :: m_afy0A (a_Xfyr3 -> Data.Semigroup.First a_Xfyr3)
          [LclId] =
              [$dMonad_sfCIw] \u []
                  GHC.Base.return $dMonad_sfCIw Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfCIw sat_sfCIA sat_sfCIF;

Data.Semigroup.$fDataFirst_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.First a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCIG ds_sfCIH ds1_sfCII x_sfCIJ]
        case ds_sfCIH of {
          GHC.Types.I# x1_sfCIL [Occ=Once!] ->
              case x1_sfCIL of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfCII $dData_sfCIG x_sfCIJ;
              };
        };

Data.Semigroup.$fDataFirst_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.First a -> m (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCIN $dMonadPlus_sfCIO ds_sfCIP eta_sfCIQ]
        let {
          lvl33_sfCIR [Occ=OnceL] :: m_afy16 (Data.Semigroup.First a_XfyqX)
          [LclId] =
              [$dMonadPlus_sfCIO] \u [] GHC.Base.mzero $dMonadPlus_sfCIO;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCIO
          of
          $dMonad_sfCIS [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCJh [Occ=Once]
                    :: (Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                       -> m_afy16 (Data.Semigroup.First a_XfyqX)
                  [LclId] =
                      [lvl33_sfCIR $dMonad_sfCIS] \r [ds1_sfCJc]
                          case ds1_sfCJc of {
                            (,) x'_sfCJe [Occ=Once] b_sfCJf [Occ=Once!] ->
                                case b_sfCJf of {
                                  GHC.Types.False -> lvl33_sfCIR;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCIS x'_sfCJe;
                                };
                          }; } in
                let {
                  sat_sfCJb [Occ=Once]
                    :: m_afy16 (Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCIN
                       $dMonadPlus_sfCIO
                       ds_sfCIP
                       eta_sfCIQ
                       $dMonad_sfCIS] \u []
                          let {
                            lvl34_sfCIT [Occ=OnceL] :: m_afy16 a_XfyqX
                            [LclId] =
                                [$dData_sfCIN ds_sfCIP eta_sfCIQ] \u []
                                    ds_sfCIP $dData_sfCIN eta_sfCIQ; } in
                          let {
                            sat_sfCJa [Occ=Once]
                              :: (a_XfyqX -> Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                                 -> m_afy16 (Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCIO
                                 eta_sfCIQ
                                 $dMonad_sfCIS
                                 lvl34_sfCIT] \r [ds1_sfCIV]
                                    case ds1_sfCIV of {
                                      (,) h_sfCIX b1_sfCIY [Occ=Once!] ->
                                          case b1_sfCIY of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfCJ7 [Occ=Once]
                                                    :: m_afy16 (Data.Semigroup.First a_XfyqX,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfCIQ $dMonad_sfCIS h_sfCIX] \u []
                                                          let {
                                                            sat_sfCJ5 [Occ=Once]
                                                              :: Data.Semigroup.First a_XfyqX
                                                            [LclId] =
                                                                [eta_sfCIQ h_sfCIX] \u []
                                                                    h_sfCIX eta_sfCIQ; } in
                                                          let {
                                                            sat_sfCJ6 [Occ=Once]
                                                              :: (Data.Semigroup.First a_XfyqX,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfCJ5
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfCIS sat_sfCJ6; } in
                                                let {
                                                  sat_sfCJ4 [Occ=Once]
                                                    :: m_afy16 (Data.Semigroup.First a_XfyqX,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfCIS lvl34_sfCIT h_sfCIX] \u []
                                                          let {
                                                            sat_sfCJ3 [Occ=Once]
                                                              :: a_XfyqX
                                                                 -> m_afy16 (Data.Semigroup.First
                                                                               a_XfyqX,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCIS
                                                                 h_sfCIX] \r [y'_sfCJ0]
                                                                    let {
                                                                      sat_sfCJ1 [Occ=Once]
                                                                        :: Data.Semigroup.First
                                                                             a_XfyqX
                                                                      [LclId] =
                                                                          [h_sfCIX y'_sfCJ0] \u []
                                                                              h_sfCIX y'_sfCJ0; } in
                                                                    let {
                                                                      sat_sfCJ2 [Occ=Once]
                                                                        :: (Data.Semigroup.First
                                                                              a_XfyqX,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCJ1
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCIS sat_sfCJ2;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfCIS lvl34_sfCIT sat_sfCJ3;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfCIO sat_sfCJ4 sat_sfCJ7;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfCJ8 [Occ=Once]
                                                    :: Data.Semigroup.First a_XfyqX
                                                  [LclId] =
                                                      [eta_sfCIQ h_sfCIX] \u []
                                                          h_sfCIX eta_sfCIQ; } in
                                                let {
                                                  sat_sfCJ9 [Occ=Once]
                                                    :: (Data.Semigroup.First a_XfyqX,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfCJ8 GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfCIS sat_sfCJ9;
                                          };
                                    }; } in
                          let {
                            sat_sfCIU [Occ=Once]
                              :: m_afy16 (a_XfyqX -> Data.Semigroup.First a_XfyqX,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCIS] \u []
                                    GHC.Base.return $dMonad_sfCIS Data.Semigroup.$fDataFirst1;
                          } in  GHC.Base.>>= $dMonad_sfCIS sat_sfCIU sat_sfCJa;
                } in  GHC.Base.>>= $dMonad_sfCIS sat_sfCJb sat_sfCJh;
          };

lvl21_rfC73 :: forall a. Data.Semigroup.First a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCJi] Data.Semigroup.$cFirst;

lvl22_rfC74
  :: forall a. Data.Semigroup.First a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCJj] Data.Semigroup.$tFirst;

lvl23_rfC75
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.First a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCJk ds_sfCJl] GHC.Base.Nothing [];

Data.Semigroup.$fDataFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.First a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCJm]
        let {
          sat_sfCJR [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.First a_XfyqW -> m (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfCJm] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapMo
                      $dData_sfCJm eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCJQ [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.First a_XfyqW -> m (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfCJm] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapMp
                      $dData_sfCJm eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCJP [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.First a_XfyqW -> m (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfCJm] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapM
                      $dData_sfCJm eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCJO [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.First a_XfyqW
               -> u
          [LclId] =
              [$dData_sfCJm] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapQi
                      $dData_sfCJm eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCJN [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.First a_XfyqW -> [u]
          [LclId] =
              [$dData_sfCJm] \r [ds_sfCJK x0_sfCJL]
                  let {
                    sat_sfCJM [Occ=Once] :: u_afy08
                    [LclId] =
                        [$dData_sfCJm ds_sfCJK x0_sfCJL] \u []
                            ds_sfCJK $dData_sfCJm x0_sfCJL;
                  } in  : [sat_sfCJM GHC.Types.[]]; } in
        let {
          sat_sfCJJ [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.First a_XfyqW
               -> r
          [LclId] =
              [$dData_sfCJm] \r [ds_sfCJE ds1_sfCJF ds2_sfCJG x0_sfCJH]
                  let {
                    sat_sfCJI [Occ=Once] :: r'_afxZS
                    [LclId] =
                        [$dData_sfCJm ds2_sfCJG x0_sfCJH] \u []
                            ds2_sfCJG $dData_sfCJm x0_sfCJH;
                  } in  ds_sfCJE sat_sfCJI ds1_sfCJF; } in
        let {
          sat_sfCJD [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.First a_XfyqW
               -> r
          [LclId] =
              [$dData_sfCJm] \r [ds_sfCJy ds1_sfCJz ds2_sfCJA eta_sfCJB]
                  let {
                    sat_sfCJC [Occ=Once] :: r'_afxZB
                    [LclId] =
                        [$dData_sfCJm ds2_sfCJA eta_sfCJB] \u []
                            ds2_sfCJA $dData_sfCJm eta_sfCJB;
                  } in  ds_sfCJy ds1_sfCJz sat_sfCJC; } in
        let {
          sat_sfCJx [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.First a_XfyqW -> Data.Semigroup.First a_XfyqW
          [LclId] =
              [$dData_sfCJm] \r [ds_sfCJv x0_sfCJw]
                  ds_sfCJv $dData_sfCJm x0_sfCJw; } in
        let {
          sat_sfCJu [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.First a_XfyqW))
          [LclId] =
              [$dData_sfCJm] \r [eta_B1]
                  Data.Semigroup.$fDataFirst_$cdataCast1 $dData_sfCJm eta_B1; } in
        let {
          sat_sfCJt [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfCJm] \r [k_sfCJp z_sfCJq ds_sfCJr]
                  let {
                    sat_sfCJs [Occ=Once]
                      :: c_afxYr (a_XfyqW -> Data.Semigroup.First a_XfyqW)
                    [LclId] =
                        [z_sfCJq] \u [] z_sfCJq Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfCJp $dData_sfCJm sat_sfCJs; } in
        let {
          sat_sfCJo [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.First a_XfyqW
               -> c (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfCJm] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgfoldl
                      $dData_sfCJm eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCJn [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfCJm] \u [] Data.Semigroup.$fDataFirst8 $dData_sfCJm;
        } in 
          Data.Data.C:Data [sat_sfCJn
                            sat_sfCJo
                            sat_sfCJt
                            lvl21_rfC73
                            lvl22_rfC74
                            sat_sfCJu
                            lvl23_rfC75
                            sat_sfCJx
                            sat_sfCJD
                            sat_sfCJJ
                            sat_sfCJN
                            sat_sfCJO
                            sat_sfCJP
                            sat_sfCJQ
                            sat_sfCJR];

Data.Semigroup.$fDataLast3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataLast4];

Data.Semigroup.$tcLast :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11434676963974803827##
                                    15911814017027463598##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataLast3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep11_rfC76 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcLast
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Last1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep11_rfC76];

Data.Semigroup.$tc'Last3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Last"#;

Data.Semigroup.$tc'Last2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Last3];

Data.Semigroup.$tc'Last :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3320600960953447003##
                                    12383530634546204472##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Last2
                                    1#
                                    Data.Semigroup.$tc'Last1];

Data.Semigroup.$fDataLast2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Last
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                11434676963974803827##
                15911814017027463598##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataLast3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCJT [Occ=Once]
                   ww9_sfCJU [Occ=Once]
                   ww10_sfCJV [Occ=Once]
                   ww11_sfCJW [Occ=Once]
                   ww12_sfCJX [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCJT
                                              ww9_sfCJU
                                              ww10_sfCJV
                                              ww11_sfCJW
                                              ww12_sfCJX];
        };

Data.Semigroup.$fDataLast8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Last a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCJY]
        case Data.Data.$p1Data $dData_sfCJY of sat_sfCJZ {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataLast2 sat_sfCJZ;
        };

Data.Semigroup.$fDataLast_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Last a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCK0 $dTypeable_sfCK1]
        let {
          lvl33_sfCK2 [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCK1] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCK1 Data.Semigroup.$fDataLast2; } in
        let {
          sat_sfCK6 [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afy7N (t_afy7M d))
               -> GHC.Base.Maybe (c_afy7N (Data.Semigroup.Last a_XfyAl))
          [LclId] =
              [$dData_sfCK0 lvl33_sfCK2] \r [f_sfCK3]
                  case lvl33_sfCK2 of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCK5 [Occ=Once] :: c_afy7N (Data.Semigroup.Last a_XfyAl)
                          [LclId] =
                              [$dData_sfCK0 f_sfCK3] \u [] f_sfCK3 $dData_sfCK0;
                        } in  GHC.Base.Just [sat_sfCK5];
                  };
        } in  sat_sfCK6;

Data.Semigroup.$fDataLast1
  :: forall a. (a -> Data.Semigroup.Last a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataLast_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Last a -> m (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCK7 $dMonadPlus_sfCK8 ds_sfCK9 eta_sfCKa]
        let {
          lvl33_sfCKb [Occ=OnceL] :: m_afy9S (Data.Semigroup.Last a_XfyAu)
          [LclId] =
              [$dMonadPlus_sfCK8] \u [] GHC.Base.mzero $dMonadPlus_sfCK8;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCK8
          of
          $dMonad_sfCKc [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCKy [Occ=Once]
                    :: (Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                       -> m_afy9S (Data.Semigroup.Last a_XfyAu)
                  [LclId] =
                      [lvl33_sfCKb $dMonad_sfCKc] \r [ds1_sfCKt]
                          case ds1_sfCKt of {
                            (,) x'_sfCKv [Occ=Once] b_sfCKw [Occ=Once!] ->
                                case b_sfCKw of {
                                  GHC.Types.False -> lvl33_sfCKb;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCKc x'_sfCKv;
                                };
                          }; } in
                let {
                  sat_sfCKs [Occ=Once]
                    :: m_afy9S (Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCK7
                       $dMonadPlus_sfCK8
                       ds_sfCK9
                       eta_sfCKa
                       $dMonad_sfCKc] \u []
                          let {
                            lvl34_sfCKd [Occ=OnceL] :: m_afy9S a_XfyAu
                            [LclId] =
                                [$dData_sfCK7 ds_sfCK9 eta_sfCKa] \u []
                                    ds_sfCK9 $dData_sfCK7 eta_sfCKa; } in
                          let {
                            sat_sfCKr [Occ=Once]
                              :: (a_XfyAu -> Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                                 -> m_afy9S (Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCK8
                                 eta_sfCKa
                                 $dMonad_sfCKc
                                 lvl34_sfCKd] \r [ds1_sfCKf]
                                    case ds1_sfCKf of {
                                      (,) h_sfCKh b1_sfCKi [Occ=Once] ->
                                          let {
                                            sat_sfCKq [Occ=Once]
                                              :: m_afy9S (Data.Semigroup.Last a_XfyAu,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfCKa $dMonad_sfCKc h_sfCKh b1_sfCKi] \u []
                                                    let {
                                                      sat_sfCKo [Occ=Once]
                                                        :: Data.Semigroup.Last a_XfyAu
                                                      [LclId] =
                                                          [eta_sfCKa h_sfCKh] \u []
                                                              h_sfCKh eta_sfCKa; } in
                                                    let {
                                                      sat_sfCKp [Occ=Once]
                                                        :: (Data.Semigroup.Last a_XfyAu,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfCKo b1_sfCKi];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfCKc sat_sfCKp; } in
                                          let {
                                            sat_sfCKn [Occ=Once]
                                              :: m_afy9S (Data.Semigroup.Last a_XfyAu,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfCKc lvl34_sfCKd h_sfCKh] \u []
                                                    let {
                                                      sat_sfCKm [Occ=Once]
                                                        :: a_XfyAu
                                                           -> m_afy9S (Data.Semigroup.Last a_XfyAu,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfCKc h_sfCKh] \r [y'_sfCKj]
                                                              let {
                                                                sat_sfCKk [Occ=Once]
                                                                  :: Data.Semigroup.Last a_XfyAu
                                                                [LclId] =
                                                                    [h_sfCKh y'_sfCKj] \u []
                                                                        h_sfCKh y'_sfCKj; } in
                                                              let {
                                                                sat_sfCKl [Occ=Once]
                                                                  :: (Data.Semigroup.Last a_XfyAu,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfCKk
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfCKc sat_sfCKl;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfCKc lvl34_sfCKd sat_sfCKm;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfCK8 sat_sfCKn sat_sfCKq;
                                    }; } in
                          let {
                            sat_sfCKe [Occ=Once]
                              :: m_afy9S (a_XfyAu -> Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCKc] \u []
                                    GHC.Base.return $dMonad_sfCKc Data.Semigroup.$fDataLast1;
                          } in  GHC.Base.>>= $dMonad_sfCKc sat_sfCKe sat_sfCKr;
                } in  GHC.Base.>>= $dMonad_sfCKc sat_sfCKs sat_sfCKy;
          };

Data.Semigroup.$fDataLast_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Last a -> m (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCKz $dMonad_sfCKA ds_sfCKB eta_sfCKC]
        let {
          lvl33_sfCKD [Occ=OnceL] :: m_afy9C a_XfyAt
          [LclId] =
              [$dData_sfCKz ds_sfCKB eta_sfCKC] \u []
                  ds_sfCKB $dData_sfCKz eta_sfCKC; } in
        let {
          sat_sfCKJ [Occ=Once]
            :: (a_XfyAt -> Data.Semigroup.Last a_XfyAt)
               -> m_afy9C (Data.Semigroup.Last a_XfyAt)
          [LclId] =
              [$dMonad_sfCKA lvl33_sfCKD] \r [c'_sfCKF]
                  let {
                    sat_sfCKI [Occ=Once]
                      :: a_XfyAt -> m_afy9C (Data.Semigroup.Last a_XfyAt)
                    [LclId] =
                        [$dMonad_sfCKA c'_sfCKF] \r [x'_sfCKG]
                            let {
                              sat_sfCKH [Occ=Once] :: Data.Semigroup.Last a_XfyAt
                              [LclId] =
                                  [c'_sfCKF x'_sfCKG] \u [] c'_sfCKF x'_sfCKG;
                            } in  GHC.Base.return $dMonad_sfCKA sat_sfCKH;
                  } in  GHC.Base.>>= $dMonad_sfCKA lvl33_sfCKD sat_sfCKI; } in
        let {
          sat_sfCKE [Occ=Once]
            :: m_afy9C (a_XfyAt -> Data.Semigroup.Last a_XfyAt)
          [LclId] =
              [$dMonad_sfCKA] \u []
                  GHC.Base.return $dMonad_sfCKA Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfCKA sat_sfCKE sat_sfCKJ;

Data.Semigroup.$fDataLast_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Last a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCKK ds_sfCKL ds1_sfCKM x_sfCKN]
        case ds_sfCKL of {
          GHC.Types.I# x1_sfCKP [Occ=Once!] ->
              case x1_sfCKP of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfCKM $dData_sfCKK x_sfCKN;
              };
        };

Data.Semigroup.$fDataLast_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Last a -> m (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCKR $dMonadPlus_sfCKS ds_sfCKT eta_sfCKU]
        let {
          lvl33_sfCKV [Occ=OnceL] :: m_afya8 (Data.Semigroup.Last a_XfyAn)
          [LclId] =
              [$dMonadPlus_sfCKS] \u [] GHC.Base.mzero $dMonadPlus_sfCKS;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCKS
          of
          $dMonad_sfCKW [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCLl [Occ=Once]
                    :: (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                       -> m_afya8 (Data.Semigroup.Last a_XfyAn)
                  [LclId] =
                      [lvl33_sfCKV $dMonad_sfCKW] \r [ds1_sfCLg]
                          case ds1_sfCLg of {
                            (,) x'_sfCLi [Occ=Once] b_sfCLj [Occ=Once!] ->
                                case b_sfCLj of {
                                  GHC.Types.False -> lvl33_sfCKV;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCKW x'_sfCLi;
                                };
                          }; } in
                let {
                  sat_sfCLf [Occ=Once]
                    :: m_afya8 (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCKR
                       $dMonadPlus_sfCKS
                       ds_sfCKT
                       eta_sfCKU
                       $dMonad_sfCKW] \u []
                          let {
                            lvl34_sfCKX [Occ=OnceL] :: m_afya8 a_XfyAn
                            [LclId] =
                                [$dData_sfCKR ds_sfCKT eta_sfCKU] \u []
                                    ds_sfCKT $dData_sfCKR eta_sfCKU; } in
                          let {
                            sat_sfCLe [Occ=Once]
                              :: (a_XfyAn -> Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                                 -> m_afya8 (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCKS
                                 eta_sfCKU
                                 $dMonad_sfCKW
                                 lvl34_sfCKX] \r [ds1_sfCKZ]
                                    case ds1_sfCKZ of {
                                      (,) h_sfCL1 b1_sfCL2 [Occ=Once!] ->
                                          case b1_sfCL2 of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfCLb [Occ=Once]
                                                    :: m_afya8 (Data.Semigroup.Last a_XfyAn,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfCKU $dMonad_sfCKW h_sfCL1] \u []
                                                          let {
                                                            sat_sfCL9 [Occ=Once]
                                                              :: Data.Semigroup.Last a_XfyAn
                                                            [LclId] =
                                                                [eta_sfCKU h_sfCL1] \u []
                                                                    h_sfCL1 eta_sfCKU; } in
                                                          let {
                                                            sat_sfCLa [Occ=Once]
                                                              :: (Data.Semigroup.Last a_XfyAn,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfCL9
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfCKW sat_sfCLa; } in
                                                let {
                                                  sat_sfCL8 [Occ=Once]
                                                    :: m_afya8 (Data.Semigroup.Last a_XfyAn,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfCKW lvl34_sfCKX h_sfCL1] \u []
                                                          let {
                                                            sat_sfCL7 [Occ=Once]
                                                              :: a_XfyAn
                                                                 -> m_afya8 (Data.Semigroup.Last
                                                                               a_XfyAn,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCKW
                                                                 h_sfCL1] \r [y'_sfCL4]
                                                                    let {
                                                                      sat_sfCL5 [Occ=Once]
                                                                        :: Data.Semigroup.Last
                                                                             a_XfyAn
                                                                      [LclId] =
                                                                          [h_sfCL1 y'_sfCL4] \u []
                                                                              h_sfCL1 y'_sfCL4; } in
                                                                    let {
                                                                      sat_sfCL6 [Occ=Once]
                                                                        :: (Data.Semigroup.Last
                                                                              a_XfyAn,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCL5
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCKW sat_sfCL6;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfCKW lvl34_sfCKX sat_sfCL7;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfCKS sat_sfCL8 sat_sfCLb;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfCLc [Occ=Once]
                                                    :: Data.Semigroup.Last a_XfyAn
                                                  [LclId] =
                                                      [eta_sfCKU h_sfCL1] \u []
                                                          h_sfCL1 eta_sfCKU; } in
                                                let {
                                                  sat_sfCLd [Occ=Once]
                                                    :: (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfCLc GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfCKW sat_sfCLd;
                                          };
                                    }; } in
                          let {
                            sat_sfCKY [Occ=Once]
                              :: m_afya8 (a_XfyAn -> Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCKW] \u []
                                    GHC.Base.return $dMonad_sfCKW Data.Semigroup.$fDataLast1;
                          } in  GHC.Base.>>= $dMonad_sfCKW sat_sfCKY sat_sfCLe;
                } in  GHC.Base.>>= $dMonad_sfCKW sat_sfCLf sat_sfCLl;
          };

lvl24_rfC77 :: forall a. Data.Semigroup.Last a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCLm] Data.Semigroup.$cLast;

lvl25_rfC78
  :: forall a. Data.Semigroup.Last a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCLn] Data.Semigroup.$tLast;

lvl26_rfC79
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Last a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCLo ds_sfCLp] GHC.Base.Nothing [];

Data.Semigroup.$fDataLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Last a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCLq]
        let {
          sat_sfCLV [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Last a_XfyAm -> m (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfCLq] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapMo
                      $dData_sfCLq eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCLU [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Last a_XfyAm -> m (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfCLq] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapMp
                      $dData_sfCLq eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCLT [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Last a_XfyAm -> m (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfCLq] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapM
                      $dData_sfCLq eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCLS [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Last a_XfyAm
               -> u
          [LclId] =
              [$dData_sfCLq] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapQi
                      $dData_sfCLq eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCLR [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Last a_XfyAm -> [u]
          [LclId] =
              [$dData_sfCLq] \r [ds_sfCLO x0_sfCLP]
                  let {
                    sat_sfCLQ [Occ=Once] :: u_afy9a
                    [LclId] =
                        [$dData_sfCLq ds_sfCLO x0_sfCLP] \u []
                            ds_sfCLO $dData_sfCLq x0_sfCLP;
                  } in  : [sat_sfCLQ GHC.Types.[]]; } in
        let {
          sat_sfCLN [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Last a_XfyAm
               -> r
          [LclId] =
              [$dData_sfCLq] \r [ds_sfCLI ds1_sfCLJ ds2_sfCLK x0_sfCLL]
                  let {
                    sat_sfCLM [Occ=Once] :: r'_afy8U
                    [LclId] =
                        [$dData_sfCLq ds2_sfCLK x0_sfCLL] \u []
                            ds2_sfCLK $dData_sfCLq x0_sfCLL;
                  } in  ds_sfCLI sat_sfCLM ds1_sfCLJ; } in
        let {
          sat_sfCLH [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Last a_XfyAm
               -> r
          [LclId] =
              [$dData_sfCLq] \r [ds_sfCLC ds1_sfCLD ds2_sfCLE eta_sfCLF]
                  let {
                    sat_sfCLG [Occ=Once] :: r'_afy8D
                    [LclId] =
                        [$dData_sfCLq ds2_sfCLE eta_sfCLF] \u []
                            ds2_sfCLE $dData_sfCLq eta_sfCLF;
                  } in  ds_sfCLC ds1_sfCLD sat_sfCLG; } in
        let {
          sat_sfCLB [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Last a_XfyAm -> Data.Semigroup.Last a_XfyAm
          [LclId] =
              [$dData_sfCLq] \r [ds_sfCLz x0_sfCLA]
                  ds_sfCLz $dData_sfCLq x0_sfCLA; } in
        let {
          sat_sfCLy [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Last a_XfyAm))
          [LclId] =
              [$dData_sfCLq] \r [eta_B1]
                  Data.Semigroup.$fDataLast_$cdataCast1 $dData_sfCLq eta_B1; } in
        let {
          sat_sfCLx [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfCLq] \r [k_sfCLt z_sfCLu ds_sfCLv]
                  let {
                    sat_sfCLw [Occ=Once]
                      :: c_afy7t (a_XfyAm -> Data.Semigroup.Last a_XfyAm)
                    [LclId] =
                        [z_sfCLu] \u [] z_sfCLu Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfCLt $dData_sfCLq sat_sfCLw; } in
        let {
          sat_sfCLs [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Last a_XfyAm
               -> c (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfCLq] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgfoldl
                      $dData_sfCLq eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCLr [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfCLq] \u [] Data.Semigroup.$fDataLast8 $dData_sfCLq;
        } in 
          Data.Data.C:Data [sat_sfCLr
                            sat_sfCLs
                            sat_sfCLx
                            lvl24_rfC77
                            lvl25_rfC78
                            sat_sfCLy
                            lvl26_rfC79
                            sat_sfCLB
                            sat_sfCLH
                            sat_sfCLN
                            sat_sfCLR
                            sat_sfCLS
                            sat_sfCLT
                            sat_sfCLU
                            sat_sfCLV];

Data.Semigroup.$fDataWrappedMonoid3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataWrappedMonoid4];

Data.Semigroup.$tcWrappedMonoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3715640179151546043##
                                    2823802549020348832##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataWrappedMonoid3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep12_rfC7a :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcWrappedMonoid
                                              $krep2_rfC6L];

Data.Semigroup.$tc'WrapMonoid1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep12_rfC7a];

Data.Semigroup.$tc'WrapMonoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'WrapMonoid"#;

Data.Semigroup.$tc'WrapMonoid2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'WrapMonoid3];

Data.Semigroup.$tc'WrapMonoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4283841874858276090##
                                    3445460813926951313##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'WrapMonoid2
                                    1#
                                    Data.Semigroup.$tc'WrapMonoid1];

Data.Semigroup.$fDataWrappedMonoid2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.WrappedMonoid
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                3715640179151546043##
                2823802549020348832##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataWrappedMonoid3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCLX [Occ=Once]
                   ww9_sfCLY [Occ=Once]
                   ww10_sfCLZ [Occ=Once]
                   ww11_sfCM0 [Occ=Once]
                   ww12_sfCM1 [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCLX
                                              ww9_sfCLY
                                              ww10_sfCLZ
                                              ww11_sfCM0
                                              ww12_sfCM1];
        };

Data.Semigroup.$fDataWrappedMonoid8
  :: forall m.
     Data.Data.Data m =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCM2]
        case Data.Data.$p1Data $dData_sfCM2 of sat_sfCM3 {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataWrappedMonoid2 sat_sfCM3;
        };

Data.Semigroup.$fDataWrappedMonoid_$cdataCast1
  :: forall m.
     Data.Data.Data m =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.WrappedMonoid m))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCM4 $dTypeable_sfCM5]
        let {
          lvl33_sfCM6 [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCM5] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCM5 Data.Semigroup.$fDataWrappedMonoid2; } in
        let {
          sat_sfCMa [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afygP (t_afygO d))
               -> GHC.Base.Maybe (c_afygP (Data.Semigroup.WrappedMonoid m_XfyJL))
          [LclId] =
              [$dData_sfCM4 lvl33_sfCM6] \r [f_sfCM7]
                  case lvl33_sfCM6 of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCM9 [Occ=Once]
                            :: c_afygP (Data.Semigroup.WrappedMonoid m_XfyJL)
                          [LclId] =
                              [$dData_sfCM4 f_sfCM7] \u [] f_sfCM7 $dData_sfCM4;
                        } in  GHC.Base.Just [sat_sfCM9];
                  };
        } in  sat_sfCMa;

Data.Semigroup.$fDataWrappedMonoid1
  :: forall m. (m -> Data.Semigroup.WrappedMonoid m, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataWrappedMonoid_$cgmapMp
  :: forall m.
     Data.Data.Data m =>
     forall (m1 :: * -> *).
     GHC.Base.MonadPlus m1 =>
     (forall d. Data.Data.Data d => d -> m1 d)
     -> Data.Semigroup.WrappedMonoid m
     -> m1 (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCMb $dMonadPlus_sfCMc ds_sfCMd eta_sfCMe]
        let {
          lvl33_sfCMf [Occ=OnceL]
            :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU)
          [LclId] =
              [$dMonadPlus_sfCMc] \u [] GHC.Base.mzero $dMonadPlus_sfCMc;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCMc
          of
          $dMonad_sfCMg [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCMC [Occ=Once]
                    :: (Data.Semigroup.WrappedMonoid m_XfyJU, GHC.Types.Bool)
                       -> m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU)
                  [LclId] =
                      [lvl33_sfCMf $dMonad_sfCMg] \r [ds1_sfCMx]
                          case ds1_sfCMx of {
                            (,) x'_sfCMz [Occ=Once] b_sfCMA [Occ=Once!] ->
                                case b_sfCMA of {
                                  GHC.Types.False -> lvl33_sfCMf;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCMg x'_sfCMz;
                                };
                          }; } in
                let {
                  sat_sfCMw [Occ=Once]
                    :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCMb
                       $dMonadPlus_sfCMc
                       ds_sfCMd
                       eta_sfCMe
                       $dMonad_sfCMg] \u []
                          let {
                            lvl34_sfCMh [Occ=OnceL] :: m1_afyiU m_XfyJU
                            [LclId] =
                                [$dData_sfCMb ds_sfCMd eta_sfCMe] \u []
                                    ds_sfCMd $dData_sfCMb eta_sfCMe; } in
                          let {
                            sat_sfCMv [Occ=Once]
                              :: (m_XfyJU -> Data.Semigroup.WrappedMonoid m_XfyJU,
                                  GHC.Types.Bool)
                                 -> m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCMc
                                 eta_sfCMe
                                 $dMonad_sfCMg
                                 lvl34_sfCMh] \r [ds1_sfCMj]
                                    case ds1_sfCMj of {
                                      (,) h_sfCMl b1_sfCMm [Occ=Once] ->
                                          let {
                                            sat_sfCMu [Occ=Once]
                                              :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU,
                                                           GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfCMe $dMonad_sfCMg h_sfCMl b1_sfCMm] \u []
                                                    let {
                                                      sat_sfCMs [Occ=Once]
                                                        :: Data.Semigroup.WrappedMonoid m_XfyJU
                                                      [LclId] =
                                                          [eta_sfCMe h_sfCMl] \u []
                                                              h_sfCMl eta_sfCMe; } in
                                                    let {
                                                      sat_sfCMt [Occ=Once]
                                                        :: (Data.Semigroup.WrappedMonoid m_XfyJU,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfCMs b1_sfCMm];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfCMg sat_sfCMt; } in
                                          let {
                                            sat_sfCMr [Occ=Once]
                                              :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU,
                                                           GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfCMg lvl34_sfCMh h_sfCMl] \u []
                                                    let {
                                                      sat_sfCMq [Occ=Once]
                                                        :: m_XfyJU
                                                           -> m1_afyiU (Data.Semigroup.WrappedMonoid
                                                                          m_XfyJU,
                                                                        GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfCMg h_sfCMl] \r [y'_sfCMn]
                                                              let {
                                                                sat_sfCMo [Occ=Once]
                                                                  :: Data.Semigroup.WrappedMonoid
                                                                       m_XfyJU
                                                                [LclId] =
                                                                    [h_sfCMl y'_sfCMn] \u []
                                                                        h_sfCMl y'_sfCMn; } in
                                                              let {
                                                                sat_sfCMp [Occ=Once]
                                                                  :: (Data.Semigroup.WrappedMonoid
                                                                        m_XfyJU,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfCMo
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfCMg sat_sfCMp;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfCMg lvl34_sfCMh sat_sfCMq;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfCMc sat_sfCMr sat_sfCMu;
                                    }; } in
                          let {
                            sat_sfCMi [Occ=Once]
                              :: m1_afyiU (m_XfyJU -> Data.Semigroup.WrappedMonoid m_XfyJU,
                                           GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCMg] \u []
                                    GHC.Base.return
                                        $dMonad_sfCMg Data.Semigroup.$fDataWrappedMonoid1;
                          } in  GHC.Base.>>= $dMonad_sfCMg sat_sfCMi sat_sfCMv;
                } in  GHC.Base.>>= $dMonad_sfCMg sat_sfCMw sat_sfCMC;
          };

Data.Semigroup.$fDataWrappedMonoid_$cgmapM
  :: forall m.
     Data.Data.Data m =>
     forall (m1 :: * -> *).
     GHC.Base.Monad m1 =>
     (forall d. Data.Data.Data d => d -> m1 d)
     -> Data.Semigroup.WrappedMonoid m
     -> m1 (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCMD $dMonad_sfCME ds_sfCMF eta_sfCMG]
        let {
          lvl33_sfCMH [Occ=OnceL] :: m1_afyiE m_XfyJT
          [LclId] =
              [$dData_sfCMD ds_sfCMF eta_sfCMG] \u []
                  ds_sfCMF $dData_sfCMD eta_sfCMG; } in
        let {
          sat_sfCMN [Occ=Once]
            :: (m_XfyJT -> Data.Semigroup.WrappedMonoid m_XfyJT)
               -> m1_afyiE (Data.Semigroup.WrappedMonoid m_XfyJT)
          [LclId] =
              [$dMonad_sfCME lvl33_sfCMH] \r [c'_sfCMJ]
                  let {
                    sat_sfCMM [Occ=Once]
                      :: m_XfyJT -> m1_afyiE (Data.Semigroup.WrappedMonoid m_XfyJT)
                    [LclId] =
                        [$dMonad_sfCME c'_sfCMJ] \r [x'_sfCMK]
                            let {
                              sat_sfCML [Occ=Once] :: Data.Semigroup.WrappedMonoid m_XfyJT
                              [LclId] =
                                  [c'_sfCMJ x'_sfCMK] \u [] c'_sfCMJ x'_sfCMK;
                            } in  GHC.Base.return $dMonad_sfCME sat_sfCML;
                  } in  GHC.Base.>>= $dMonad_sfCME lvl33_sfCMH sat_sfCMM; } in
        let {
          sat_sfCMI [Occ=Once]
            :: m1_afyiE (m_XfyJT -> Data.Semigroup.WrappedMonoid m_XfyJT)
          [LclId] =
              [$dMonad_sfCME] \u []
                  GHC.Base.return $dMonad_sfCME Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfCME sat_sfCMI sat_sfCMN;

Data.Semigroup.$fDataWrappedMonoid_$cgmapQi
  :: forall m.
     Data.Data.Data m =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.WrappedMonoid m
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCMO ds_sfCMP ds1_sfCMQ x_sfCMR]
        case ds_sfCMP of {
          GHC.Types.I# x1_sfCMT [Occ=Once!] ->
              case x1_sfCMT of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfCMQ $dData_sfCMO x_sfCMR;
              };
        };

Data.Semigroup.$fDataWrappedMonoid_$cgmapMo
  :: forall m.
     Data.Data.Data m =>
     forall (m1 :: * -> *).
     GHC.Base.MonadPlus m1 =>
     (forall d. Data.Data.Data d => d -> m1 d)
     -> Data.Semigroup.WrappedMonoid m
     -> m1 (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCMV $dMonadPlus_sfCMW ds_sfCMX eta_sfCMY]
        let {
          lvl33_sfCMZ [Occ=OnceL]
            :: m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN)
          [LclId] =
              [$dMonadPlus_sfCMW] \u [] GHC.Base.mzero $dMonadPlus_sfCMW;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCMW
          of
          $dMonad_sfCN0 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCNp [Occ=Once]
                    :: (Data.Semigroup.WrappedMonoid m_XfyJN, GHC.Types.Bool)
                       -> m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN)
                  [LclId] =
                      [lvl33_sfCMZ $dMonad_sfCN0] \r [ds1_sfCNk]
                          case ds1_sfCNk of {
                            (,) x'_sfCNm [Occ=Once] b_sfCNn [Occ=Once!] ->
                                case b_sfCNn of {
                                  GHC.Types.False -> lvl33_sfCMZ;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCN0 x'_sfCNm;
                                };
                          }; } in
                let {
                  sat_sfCNj [Occ=Once]
                    :: m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCMV
                       $dMonadPlus_sfCMW
                       ds_sfCMX
                       eta_sfCMY
                       $dMonad_sfCN0] \u []
                          let {
                            lvl34_sfCN1 [Occ=OnceL] :: m1_afyja m_XfyJN
                            [LclId] =
                                [$dData_sfCMV ds_sfCMX eta_sfCMY] \u []
                                    ds_sfCMX $dData_sfCMV eta_sfCMY; } in
                          let {
                            sat_sfCNi [Occ=Once]
                              :: (m_XfyJN -> Data.Semigroup.WrappedMonoid m_XfyJN,
                                  GHC.Types.Bool)
                                 -> m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCMW
                                 eta_sfCMY
                                 $dMonad_sfCN0
                                 lvl34_sfCN1] \r [ds1_sfCN3]
                                    case ds1_sfCN3 of {
                                      (,) h_sfCN5 b1_sfCN6 [Occ=Once!] ->
                                          case b1_sfCN6 of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfCNf [Occ=Once]
                                                    :: m1_afyja (Data.Semigroup.WrappedMonoid
                                                                   m_XfyJN,
                                                                 GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfCMY $dMonad_sfCN0 h_sfCN5] \u []
                                                          let {
                                                            sat_sfCNd [Occ=Once]
                                                              :: Data.Semigroup.WrappedMonoid
                                                                   m_XfyJN
                                                            [LclId] =
                                                                [eta_sfCMY h_sfCN5] \u []
                                                                    h_sfCN5 eta_sfCMY; } in
                                                          let {
                                                            sat_sfCNe [Occ=Once]
                                                              :: (Data.Semigroup.WrappedMonoid
                                                                    m_XfyJN,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfCNd
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfCN0 sat_sfCNe; } in
                                                let {
                                                  sat_sfCNc [Occ=Once]
                                                    :: m1_afyja (Data.Semigroup.WrappedMonoid
                                                                   m_XfyJN,
                                                                 GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfCN0 lvl34_sfCN1 h_sfCN5] \u []
                                                          let {
                                                            sat_sfCNb [Occ=Once]
                                                              :: m_XfyJN
                                                                 -> m1_afyja (Data.Semigroup.WrappedMonoid
                                                                                m_XfyJN,
                                                                              GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCN0
                                                                 h_sfCN5] \r [y'_sfCN8]
                                                                    let {
                                                                      sat_sfCN9 [Occ=Once]
                                                                        :: Data.Semigroup.WrappedMonoid
                                                                             m_XfyJN
                                                                      [LclId] =
                                                                          [h_sfCN5 y'_sfCN8] \u []
                                                                              h_sfCN5 y'_sfCN8; } in
                                                                    let {
                                                                      sat_sfCNa [Occ=Once]
                                                                        :: (Data.Semigroup.WrappedMonoid
                                                                              m_XfyJN,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCN9
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCN0 sat_sfCNa;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfCN0 lvl34_sfCN1 sat_sfCNb;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfCMW sat_sfCNc sat_sfCNf;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfCNg [Occ=Once]
                                                    :: Data.Semigroup.WrappedMonoid m_XfyJN
                                                  [LclId] =
                                                      [eta_sfCMY h_sfCN5] \u []
                                                          h_sfCN5 eta_sfCMY; } in
                                                let {
                                                  sat_sfCNh [Occ=Once]
                                                    :: (Data.Semigroup.WrappedMonoid m_XfyJN,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfCNg GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfCN0 sat_sfCNh;
                                          };
                                    }; } in
                          let {
                            sat_sfCN2 [Occ=Once]
                              :: m1_afyja (m_XfyJN -> Data.Semigroup.WrappedMonoid m_XfyJN,
                                           GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCN0] \u []
                                    GHC.Base.return
                                        $dMonad_sfCN0 Data.Semigroup.$fDataWrappedMonoid1;
                          } in  GHC.Base.>>= $dMonad_sfCN0 sat_sfCN2 sat_sfCNi;
                } in  GHC.Base.>>= $dMonad_sfCN0 sat_sfCNj sat_sfCNp;
          };

lvl27_rfC7b
  :: forall m. Data.Semigroup.WrappedMonoid m -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCNq] Data.Semigroup.$cWrapMonoid;

lvl28_rfC7c
  :: forall m. Data.Semigroup.WrappedMonoid m -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCNr] Data.Semigroup.$tWrappedMonoid;

lvl29_rfC7d
  :: forall m (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.WrappedMonoid m))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCNs ds_sfCNt] GHC.Base.Nothing [];

Data.Semigroup.$fDataWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     Data.Data.Data m =>
     Data.Data.Data (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCNu]
        let {
          sat_sfCNZ [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> m (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfCNu] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapMo
                      $dData_sfCNu eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCNY [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> m (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfCNu] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapMp
                      $dData_sfCNu eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCNX [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> m (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfCNu] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapM
                      $dData_sfCNu eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCNW [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> u
          [LclId] =
              [$dData_sfCNu] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapQi
                      $dData_sfCNu eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCNV [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.WrappedMonoid m_XfyJM -> [u]
          [LclId] =
              [$dData_sfCNu] \r [ds_sfCNS x0_sfCNT]
                  let {
                    sat_sfCNU [Occ=Once] :: u_afyic
                    [LclId] =
                        [$dData_sfCNu ds_sfCNS x0_sfCNT] \u []
                            ds_sfCNS $dData_sfCNu x0_sfCNT;
                  } in  : [sat_sfCNU GHC.Types.[]]; } in
        let {
          sat_sfCNR [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> r
          [LclId] =
              [$dData_sfCNu] \r [ds_sfCNM ds1_sfCNN ds2_sfCNO x0_sfCNP]
                  let {
                    sat_sfCNQ [Occ=Once] :: r'_afyhW
                    [LclId] =
                        [$dData_sfCNu ds2_sfCNO x0_sfCNP] \u []
                            ds2_sfCNO $dData_sfCNu x0_sfCNP;
                  } in  ds_sfCNM sat_sfCNQ ds1_sfCNN; } in
        let {
          sat_sfCNL [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> r
          [LclId] =
              [$dData_sfCNu] \r [ds_sfCNG ds1_sfCNH ds2_sfCNI eta_sfCNJ]
                  let {
                    sat_sfCNK [Occ=Once] :: r'_afyhF
                    [LclId] =
                        [$dData_sfCNu ds2_sfCNI eta_sfCNJ] \u []
                            ds2_sfCNI $dData_sfCNu eta_sfCNJ;
                  } in  ds_sfCNG ds1_sfCNH sat_sfCNK; } in
        let {
          sat_sfCNF [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> Data.Semigroup.WrappedMonoid m_XfyJM
          [LclId] =
              [$dData_sfCNu] \r [ds_sfCND x0_sfCNE]
                  ds_sfCND $dData_sfCNu x0_sfCNE; } in
        let {
          sat_sfCNC [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.WrappedMonoid m_XfyJM))
          [LclId] =
              [$dData_sfCNu] \r [eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cdataCast1
                      $dData_sfCNu eta_B1; } in
        let {
          sat_sfCNB [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfCNu] \r [k_sfCNx z_sfCNy ds_sfCNz]
                  let {
                    sat_sfCNA [Occ=Once]
                      :: c_afygv (m_XfyJM -> Data.Semigroup.WrappedMonoid m_XfyJM)
                    [LclId] =
                        [z_sfCNy] \u [] z_sfCNy Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfCNx $dData_sfCNu sat_sfCNA; } in
        let {
          sat_sfCNw [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> c (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfCNu] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgfoldl
                      $dData_sfCNu eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCNv [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfCNu] \u []
                  Data.Semigroup.$fDataWrappedMonoid8 $dData_sfCNu;
        } in 
          Data.Data.C:Data [sat_sfCNv
                            sat_sfCNw
                            sat_sfCNB
                            lvl27_rfC7b
                            lvl28_rfC7c
                            sat_sfCNC
                            lvl29_rfC7d
                            sat_sfCNF
                            sat_sfCNL
                            sat_sfCNR
                            sat_sfCNV
                            sat_sfCNW
                            sat_sfCNX
                            sat_sfCNY
                            sat_sfCNZ];

Data.Semigroup.$fDataOption5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataOption6];

Data.Semigroup.$tcOption :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10723619047615802556##
                                    16447525423442151350##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataOption5
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep13_rfC7e :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcOption
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Option1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rfC6M $krep13_rfC7e];

Data.Semigroup.$tc'Option3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Option"#;

Data.Semigroup.$tc'Option2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Option3];

Data.Semigroup.$tc'Option :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10684524870560962689##
                                    6198254930115905464##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Option2
                                    1#
                                    Data.Semigroup.$tc'Option1];

Data.Semigroup.$fDataOption4
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Option
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                10723619047615802556##
                16447525423442151350##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataOption5
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfCO1 [Occ=Once]
                   ww9_sfCO2 [Occ=Once]
                   ww10_sfCO3 [Occ=Once]
                   ww11_sfCO4 [Occ=Once]
                   ww12_sfCO5 [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfCO1
                                              ww9_sfCO2
                                              ww10_sfCO3
                                              ww11_sfCO4
                                              ww12_sfCO5];
        };

Data.Semigroup.$fDataOption10
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCO6]
        case Data.Data.$p1Data $dData_sfCO6 of sat_sfCO7 {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataOption4 sat_sfCO7;
        };

Data.Semigroup.$fDataOption_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Option a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfCO8 $dTypeable_sfCO9]
        let {
          lvl33_sfCOa [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfCO9] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfCO9 Data.Semigroup.$fDataOption4; } in
        let {
          sat_sfCOe [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afypz (t_afypy d))
               -> GHC.Base.Maybe (c_afypz (Data.Semigroup.Option a_XfyST))
          [LclId] =
              [$dData_sfCO8 lvl33_sfCOa] \r [f_sfCOb]
                  case lvl33_sfCOa of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfCOd [Occ=Once] :: c_afypz (Data.Semigroup.Option a_XfyST)
                          [LclId] =
                              [$dData_sfCO8 f_sfCOb] \u [] f_sfCOb $dData_sfCO8;
                        } in  GHC.Base.Just [sat_sfCOd];
                  };
        } in  sat_sfCOe;

Data.Semigroup.$fDataOption1
  :: forall a.
     (GHC.Base.Maybe a -> Data.Semigroup.Option a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fDataOption2 GHC.Types.False];

Data.Semigroup.$fDataOption_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCOf $dMonadPlus_sfCOg ds_sfCOh eta_sfCOi]
        let {
          lvl33_sfCOj [Occ=OnceL] :: m_afyrE (Data.Semigroup.Option a_XfyT2)
          [LclId] =
              [$dMonadPlus_sfCOg] \u [] GHC.Base.mzero $dMonadPlus_sfCOg;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCOg
          of
          $dMonad_sfCOk [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCOH [Occ=Once]
                    :: (Data.Semigroup.Option a_XfyT2, GHC.Types.Bool)
                       -> m_afyrE (Data.Semigroup.Option a_XfyT2)
                  [LclId] =
                      [lvl33_sfCOj $dMonad_sfCOk] \r [ds1_sfCOC]
                          case ds1_sfCOC of {
                            (,) x'_sfCOE [Occ=Once] b_sfCOF [Occ=Once!] ->
                                case b_sfCOF of {
                                  GHC.Types.False -> lvl33_sfCOj;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCOk x'_sfCOE;
                                };
                          }; } in
                let {
                  sat_sfCOB [Occ=Once]
                    :: m_afyrE (Data.Semigroup.Option a_XfyT2, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCOf
                       $dMonadPlus_sfCOg
                       ds_sfCOh
                       eta_sfCOi
                       $dMonad_sfCOk] \u []
                          let {
                            lvl34_sfCOl [Occ=OnceL] :: m_afyrE (GHC.Base.Maybe a_XfyT2)
                            [LclId] =
                                [$dData_sfCOf ds_sfCOh eta_sfCOi] \u []
                                    let {
                                      sat_sfCOm [Occ=Once]
                                        :: Data.Data.Data (GHC.Base.Maybe a_XfyT2)
                                      [LclId] =
                                          [$dData_sfCOf] \u [] Data.Data.$fDataMaybe $dData_sfCOf;
                                    } in  ds_sfCOh sat_sfCOm eta_sfCOi; } in
                          let {
                            sat_sfCOA [Occ=Once]
                              :: (GHC.Base.Maybe a_XfyT2 -> Data.Semigroup.Option a_XfyT2,
                                  GHC.Types.Bool)
                                 -> m_afyrE (Data.Semigroup.Option a_XfyT2, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCOg
                                 eta_sfCOi
                                 $dMonad_sfCOk
                                 lvl34_sfCOl] \r [ds1_sfCOo]
                                    case ds1_sfCOo of {
                                      (,) h_sfCOq b1_sfCOr [Occ=Once] ->
                                          let {
                                            sat_sfCOz [Occ=Once]
                                              :: m_afyrE (Data.Semigroup.Option a_XfyT2,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfCOi $dMonad_sfCOk h_sfCOq b1_sfCOr] \u []
                                                    let {
                                                      sat_sfCOx [Occ=Once]
                                                        :: Data.Semigroup.Option a_XfyT2
                                                      [LclId] =
                                                          [eta_sfCOi h_sfCOq] \u []
                                                              h_sfCOq eta_sfCOi; } in
                                                    let {
                                                      sat_sfCOy [Occ=Once]
                                                        :: (Data.Semigroup.Option a_XfyT2,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfCOx b1_sfCOr];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfCOk sat_sfCOy; } in
                                          let {
                                            sat_sfCOw [Occ=Once]
                                              :: m_afyrE (Data.Semigroup.Option a_XfyT2,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfCOk lvl34_sfCOl h_sfCOq] \u []
                                                    let {
                                                      sat_sfCOv [Occ=Once]
                                                        :: GHC.Base.Maybe a_XfyT2
                                                           -> m_afyrE (Data.Semigroup.Option
                                                                         a_XfyT2,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfCOk h_sfCOq] \r [y'_sfCOs]
                                                              let {
                                                                sat_sfCOt [Occ=Once]
                                                                  :: Data.Semigroup.Option a_XfyT2
                                                                [LclId] =
                                                                    [h_sfCOq y'_sfCOs] \u []
                                                                        h_sfCOq y'_sfCOs; } in
                                                              let {
                                                                sat_sfCOu [Occ=Once]
                                                                  :: (Data.Semigroup.Option a_XfyT2,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfCOt
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfCOk sat_sfCOu;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfCOk lvl34_sfCOl sat_sfCOv;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfCOg sat_sfCOw sat_sfCOz;
                                    }; } in
                          let {
                            sat_sfCOn [Occ=Once]
                              :: m_afyrE (GHC.Base.Maybe a_XfyT2
                                          -> Data.Semigroup.Option a_XfyT2,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCOk] \u []
                                    GHC.Base.return $dMonad_sfCOk Data.Semigroup.$fDataOption1;
                          } in  GHC.Base.>>= $dMonad_sfCOk sat_sfCOn sat_sfCOA;
                } in  GHC.Base.>>= $dMonad_sfCOk sat_sfCOB sat_sfCOH;
          };

Data.Semigroup.$fDataOption_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option a)
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCOI $dMonad_sfCOJ ds_sfCOK]
        let {
          $dData1_sfCOL [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_XfyT1)
          [LclId] =
              [$dData_sfCOI] \u [] Data.Data.$fDataMaybe $dData_sfCOI; } in
        let {
          lvl33_sfCOM [Occ=OnceL]
            :: m_afyro (GHC.Base.Maybe a_XfyT1
                        -> Data.Semigroup.Option a_XfyT1)
          [LclId] =
              [$dMonad_sfCOJ] \u []
                  GHC.Base.return $dMonad_sfCOJ Data.Semigroup.$fDataOption2; } in
        let {
          sat_sfCOU [Occ=OnceT[0]]
            :: Data.Semigroup.Option a_XfyT1
               -> m_afyro (Data.Semigroup.Option a_XfyT1)
          [LclId] =
              [$dMonad_sfCOJ ds_sfCOK $dData1_sfCOL lvl33_sfCOM] \r [ds1_sfCON]
                  let {
                    lvl34_sfCOO [Occ=OnceL] :: m_afyro (GHC.Base.Maybe a_XfyT1)
                    [LclId] =
                        [ds_sfCOK $dData1_sfCOL ds1_sfCON] \u []
                            ds_sfCOK $dData1_sfCOL ds1_sfCON; } in
                  let {
                    sat_sfCOT [Occ=Once]
                      :: (GHC.Base.Maybe a_XfyT1 -> Data.Semigroup.Option a_XfyT1)
                         -> m_afyro (Data.Semigroup.Option a_XfyT1)
                    [LclId] =
                        [$dMonad_sfCOJ lvl34_sfCOO] \r [c'_sfCOP]
                            let {
                              sat_sfCOS [Occ=Once]
                                :: GHC.Base.Maybe a_XfyT1
                                   -> m_afyro (Data.Semigroup.Option a_XfyT1)
                              [LclId] =
                                  [$dMonad_sfCOJ c'_sfCOP] \r [x'_sfCOQ]
                                      let {
                                        sat_sfCOR [Occ=Once] :: Data.Semigroup.Option a_XfyT1
                                        [LclId] =
                                            [c'_sfCOP x'_sfCOQ] \u [] c'_sfCOP x'_sfCOQ;
                                      } in  GHC.Base.return $dMonad_sfCOJ sat_sfCOR;
                            } in  GHC.Base.>>= $dMonad_sfCOJ lvl34_sfCOO sat_sfCOS;
                  } in  GHC.Base.>>= $dMonad_sfCOJ lvl33_sfCOM sat_sfCOT;
        } in  sat_sfCOU;

Data.Semigroup.$fDataOption_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Option a
     -> u
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCOV ds_sfCOW ds1_sfCOX x_sfCOY]
        case ds_sfCOW of {
          GHC.Types.I# x1_sfCP0 [Occ=Once!] ->
              case x1_sfCP0 of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# ->
                    let {
                      sat_sfCP2 [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfyT0)
                      [LclId] =
                          [$dData_sfCOV] \u [] Data.Data.$fDataMaybe $dData_sfCOV;
                    } in  ds1_sfCOX sat_sfCP2 x_sfCOY;
              };
        };

Data.Semigroup.$fDataOption_$cgmapQr
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Option a
     -> r
[GblId,
 Arity=5,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCP3 ds_sfCP4 ds1_sfCP5 ds2_sfCP6 x0_sfCP7]
        let {
          sat_sfCP9 [Occ=Once] :: r'_afyqG
          [LclId] =
              [$dData_sfCP3 ds2_sfCP6 x0_sfCP7] \u []
                  let {
                    sat_sfCP8 [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfySY)
                    [LclId] =
                        [$dData_sfCP3] \u [] Data.Data.$fDataMaybe $dData_sfCP3;
                  } in  ds2_sfCP6 sat_sfCP8 x0_sfCP7;
        } in  ds_sfCP4 sat_sfCP9 ds1_sfCP5;

Data.Semigroup.$fDataOption_$cgmapQ
  :: forall a.
     Data.Data.Data a =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Option a -> [u]
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,1*C1(C1(U))><L,U>m2,
 Unf=OtherCon []] =
    [] \r [$dData_sfCPa ds_sfCPb x0_sfCPc]
        let {
          sat_sfCPe [Occ=Once] :: u_afyqW
          [LclId] =
              [$dData_sfCPa ds_sfCPb x0_sfCPc] \u []
                  let {
                    sat_sfCPd [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfySZ)
                    [LclId] =
                        [$dData_sfCPa] \u [] Data.Data.$fDataMaybe $dData_sfCPa;
                  } in  ds_sfCPb sat_sfCPd x0_sfCPc;
        } in  : [sat_sfCPe GHC.Types.[]];

Data.Semigroup.$fDataOption_$cgmapQl
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Option a
     -> r
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCPf ds_sfCPg ds1_sfCPh ds2_sfCPi]
        let {
          $dData1_sfCPj [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_XfySX)
          [LclId] =
              [$dData_sfCPf] \u [] Data.Data.$fDataMaybe $dData_sfCPf; } in
        let {
          sat_sfCPm [Occ=OnceT[0]]
            :: Data.Semigroup.Option a_XfySX -> r_afyqo
          [LclId] =
              [ds_sfCPg ds1_sfCPh ds2_sfCPi $dData1_sfCPj] \r [x_sfCPk]
                  let {
                    sat_sfCPl [Occ=Once] :: r'_afyqp
                    [LclId] =
                        [ds2_sfCPi $dData1_sfCPj x_sfCPk] \u []
                            ds2_sfCPi $dData1_sfCPj x_sfCPk;
                  } in  ds_sfCPg ds1_sfCPh sat_sfCPl;
        } in  sat_sfCPm;

Data.Semigroup.$fDataOption3
  :: forall a.
     Data.Data.Data a =>
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Semigroup.Option a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCPn ds_sfCPo x0_sfCPp]
        let {
          sat_sfCPq [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfySW)
          [LclId] =
              [$dData_sfCPn] \u [] Data.Data.$fDataMaybe $dData_sfCPn;
        } in  ds_sfCPo sat_sfCPq x0_sfCPp;

Data.Semigroup.$fDataOption_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfCPr $dMonadPlus_sfCPs ds_sfCPt eta_sfCPu]
        let {
          lvl33_sfCPv [Occ=OnceL] :: m_afyrU (Data.Semigroup.Option a_XfySV)
          [LclId] =
              [$dMonadPlus_sfCPs] \u [] GHC.Base.mzero $dMonadPlus_sfCPs;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfCPs
          of
          $dMonad_sfCPw [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfCPW [Occ=Once]
                    :: (Data.Semigroup.Option a_XfySV, GHC.Types.Bool)
                       -> m_afyrU (Data.Semigroup.Option a_XfySV)
                  [LclId] =
                      [lvl33_sfCPv $dMonad_sfCPw] \r [ds1_sfCPR]
                          case ds1_sfCPR of {
                            (,) x'_sfCPT [Occ=Once] b_sfCPU [Occ=Once!] ->
                                case b_sfCPU of {
                                  GHC.Types.False -> lvl33_sfCPv;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfCPw x'_sfCPT;
                                };
                          }; } in
                let {
                  sat_sfCPQ [Occ=Once]
                    :: m_afyrU (Data.Semigroup.Option a_XfySV, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfCPr
                       $dMonadPlus_sfCPs
                       ds_sfCPt
                       eta_sfCPu
                       $dMonad_sfCPw] \u []
                          let {
                            lvl34_sfCPx [Occ=OnceL] :: m_afyrU (GHC.Base.Maybe a_XfySV)
                            [LclId] =
                                [$dData_sfCPr ds_sfCPt eta_sfCPu] \u []
                                    let {
                                      sat_sfCPy [Occ=Once]
                                        :: Data.Data.Data (GHC.Base.Maybe a_XfySV)
                                      [LclId] =
                                          [$dData_sfCPr] \u [] Data.Data.$fDataMaybe $dData_sfCPr;
                                    } in  ds_sfCPt sat_sfCPy eta_sfCPu; } in
                          let {
                            sat_sfCPP [Occ=Once]
                              :: (GHC.Base.Maybe a_XfySV -> Data.Semigroup.Option a_XfySV,
                                  GHC.Types.Bool)
                                 -> m_afyrU (Data.Semigroup.Option a_XfySV, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfCPs
                                 eta_sfCPu
                                 $dMonad_sfCPw
                                 lvl34_sfCPx] \r [ds1_sfCPA]
                                    case ds1_sfCPA of {
                                      (,) h_sfCPC b1_sfCPD [Occ=Once!] ->
                                          case b1_sfCPD of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfCPM [Occ=Once]
                                                    :: m_afyrU (Data.Semigroup.Option a_XfySV,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfCPu $dMonad_sfCPw h_sfCPC] \u []
                                                          let {
                                                            sat_sfCPK [Occ=Once]
                                                              :: Data.Semigroup.Option a_XfySV
                                                            [LclId] =
                                                                [eta_sfCPu h_sfCPC] \u []
                                                                    h_sfCPC eta_sfCPu; } in
                                                          let {
                                                            sat_sfCPL [Occ=Once]
                                                              :: (Data.Semigroup.Option a_XfySV,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfCPK
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfCPw sat_sfCPL; } in
                                                let {
                                                  sat_sfCPJ [Occ=Once]
                                                    :: m_afyrU (Data.Semigroup.Option a_XfySV,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfCPw lvl34_sfCPx h_sfCPC] \u []
                                                          let {
                                                            sat_sfCPI [Occ=Once]
                                                              :: GHC.Base.Maybe a_XfySV
                                                                 -> m_afyrU (Data.Semigroup.Option
                                                                               a_XfySV,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfCPw
                                                                 h_sfCPC] \r [y'_sfCPF]
                                                                    let {
                                                                      sat_sfCPG [Occ=Once]
                                                                        :: Data.Semigroup.Option
                                                                             a_XfySV
                                                                      [LclId] =
                                                                          [h_sfCPC y'_sfCPF] \u []
                                                                              h_sfCPC y'_sfCPF; } in
                                                                    let {
                                                                      sat_sfCPH [Occ=Once]
                                                                        :: (Data.Semigroup.Option
                                                                              a_XfySV,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfCPG
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfCPw sat_sfCPH;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfCPw lvl34_sfCPx sat_sfCPI;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfCPs sat_sfCPJ sat_sfCPM;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfCPN [Occ=Once]
                                                    :: Data.Semigroup.Option a_XfySV
                                                  [LclId] =
                                                      [eta_sfCPu h_sfCPC] \u []
                                                          h_sfCPC eta_sfCPu; } in
                                                let {
                                                  sat_sfCPO [Occ=Once]
                                                    :: (Data.Semigroup.Option a_XfySV,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfCPN GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfCPw sat_sfCPO;
                                          };
                                    }; } in
                          let {
                            sat_sfCPz [Occ=Once]
                              :: m_afyrU (GHC.Base.Maybe a_XfySV
                                          -> Data.Semigroup.Option a_XfySV,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfCPw] \u []
                                    GHC.Base.return $dMonad_sfCPw Data.Semigroup.$fDataOption1;
                          } in  GHC.Base.>>= $dMonad_sfCPw sat_sfCPz sat_sfCPP;
                } in  GHC.Base.>>= $dMonad_sfCPw sat_sfCPQ sat_sfCPW;
          };

lvl30_rfC7f
  :: forall a. Data.Semigroup.Option a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCPX] Data.Semigroup.$cOption;

lvl31_rfC7g
  :: forall a. Data.Semigroup.Option a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfCPY] Data.Semigroup.$tOption;

lvl32_rfC7h
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Option a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfCPZ ds_sfCQ0] GHC.Base.Nothing [];

Data.Semigroup.$fDataOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Option a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfCQ1]
        let {
          sat_sfCQd [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Option a_XfySU
               -> m (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfCQ1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapMo
                      $dData_sfCQ1 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCQc [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Option a_XfySU
               -> m (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfCQ1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapMp
                      $dData_sfCQ1 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCQb [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Option a_XfySU
               -> m (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfCQ1] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapM
                      $dData_sfCQ1 eta_B2 eta_B1; } in
        let {
          sat_sfCQa [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Option a_XfySU
               -> u
          [LclId] =
              [$dData_sfCQ1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQi
                      $dData_sfCQ1 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCQ9 [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Option a_XfySU -> [u]
          [LclId] =
              [$dData_sfCQ1] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQ
                      $dData_sfCQ1 eta_B2 eta_B1; } in
        let {
          sat_sfCQ8 [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Option a_XfySU
               -> r
          [LclId] =
              [$dData_sfCQ1] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQr
                      $dData_sfCQ1 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCQ7 [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Option a_XfySU
               -> r
          [LclId] =
              [$dData_sfCQ1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQl
                      $dData_sfCQ1 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfCQ6 [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Option a_XfySU -> Data.Semigroup.Option a_XfySU
          [LclId] =
              [$dData_sfCQ1] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption3 $dData_sfCQ1 eta_B2 eta_B1; } in
        let {
          sat_sfCQ5 [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Option a_XfySU))
          [LclId] =
              [$dData_sfCQ1] \r [eta_B1]
                  Data.Semigroup.$fDataOption_$cdataCast1 $dData_sfCQ1 eta_B1; } in
        let {
          sat_sfCQ4 [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfCQ1] \u []
                  Data.Semigroup.$fDataOption_$cgunfold $dData_sfCQ1; } in
        let {
          sat_sfCQ3 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Option a_XfySU
               -> c (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfCQ1] \u []
                  Data.Semigroup.$fDataOption_$cgfoldl $dData_sfCQ1; } in
        let {
          sat_sfCQ2 [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfCQ1] \u [] Data.Semigroup.$fDataOption10 $dData_sfCQ1;
        } in 
          Data.Data.C:Data [sat_sfCQ2
                            sat_sfCQ3
                            sat_sfCQ4
                            lvl30_rfC7f
                            lvl31_rfC7g
                            sat_sfCQ5
                            lvl32_rfC7h
                            sat_sfCQ6
                            sat_sfCQ7
                            sat_sfCQ8
                            sat_sfCQ9
                            sat_sfCQa
                            sat_sfCQb
                            sat_sfCQc
                            sat_sfCQd];

Data.Semigroup.Arg :: forall a b. a -> b -> Data.Semigroup.Arg a b
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Semigroup.Arg [eta_B2 eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:11:40.098866853 UTC

Data.Semigroup.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Min a
     -> [Data.Semigroup.Min a] -> Data.Semigroup.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfORT ww_sfORU ww1_sfORV]
        let {
          go_sfORW [Occ=LoopBreaker]
            :: Data.Semigroup.Min a_sfBoZ
               -> [Data.Semigroup.Min a_sfBoZ] -> Data.Semigroup.Min a_sfBoZ
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfORT go_sfORW] \r [b_sfORX ds1_sfORY]
                  case ds1_sfORY of {
                    [] -> b_sfORX;
                    : c_sfOS0 [Occ=Once] cs_sfOS1 [Occ=Once] ->
                        let {
                          sat_sfOS2 [Occ=Once] :: a_sfBoZ
                          [LclId] =
                              [go_sfORW c_sfOS0 cs_sfOS1] \u [] go_sfORW c_sfOS0 cs_sfOS1;
                        } in  GHC.Classes.min w_sfORT b_sfORX sat_sfOS2;
                  };
        } in  go_sfORW ww_sfORU ww1_sfORV;

Data.Semigroup.$fSemigroupMin_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Semigroup.Min a) -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfOS3 w1_sfOS4]
        case w1_sfOS4 of {
          GHC.Base.:| ww1_sfOS6 [Occ=Once] ww2_sfOS7 [Occ=Once] ->
              Data.Semigroup.$w$csconcat1 w_sfOS3 ww1_sfOS6 ww2_sfOS7;
        };

lvl_rfC66
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfOS8 eta_sfOS9 eta1_sfOSa]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfOS8 eta_sfOS9 eta1_sfOSa;

Data.Semigroup.$fSemigroupMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,A,A,U)>m] =
    [] \r [$dOrd_sfOSb]
        let {
          sat_sfOSd [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Min a_afzf5)
               -> Data.Semigroup.Min a_afzf5
          [LclId] =
              [$dOrd_sfOSb] \r [eta_B1]
                  Data.Semigroup.$fSemigroupMin_$csconcat $dOrd_sfOSb eta_B1; } in
        let {
          sat_sfOSc [Occ=Once]
            :: Data.Semigroup.Min a_afzf5
               -> Data.Semigroup.Min a_afzf5 -> Data.Semigroup.Min a_afzf5
          [LclId] =
              [$dOrd_sfOSb] \u [] GHC.Classes.min $dOrd_sfOSb;
        } in  GHC.Base.C:Semigroup [sat_sfOSc sat_sfOSd lvl_rfC66];

Data.Semigroup.$fFunctorMin2
  :: forall a b. (a -> b) -> Data.Semigroup.Min a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOSe ds_sfOSf] f_sfOSe ds_sfOSf;

Data.Semigroup.$fFunctorMin1
  :: forall b a. a -> Data.Semigroup.Min b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sfOSg ds_sfOSh] x_sfOSg;

Data.Semigroup.$fFunctorMin [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorMin2
                                       Data.Semigroup.$fFunctorMin1];

Data.Semigroup.$fFoldableMin_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Min a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOSi f_sfOSj ds_sfOSk] f_sfOSj ds_sfOSk;

Data.Semigroup.$fFoldableMin4
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.Min m -> Data.Semigroup.Min m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOSl ds_sfOSm] ds_sfOSm;

Data.Semigroup.$fFoldableMin1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfOSn eta_sfOSo] eta_sfOSo;

Data.Semigroup.$fFoldableMin2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOSp x_sfOSq] x_sfOSq;

Data.Semigroup.$fFoldableMin_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Min a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfOSr eta_sfOSs]
        let {
          f_sfOSt [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afzdA -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfOSr eta_sfOSs] \u []
                  GHC.Classes.== $dEq_sfOSr eta_sfOSs; } in
        let {
          sat_sfOSv [Occ=OnceT[0]]
            :: Data.Semigroup.Min a_afzdA -> GHC.Types.Bool
          [LclId] =
              [f_sfOSt] \r [ds_sfOSu] f_sfOSt ds_sfOSu;
        } in  sat_sfOSv;

Data.Semigroup.$fFoldableMin_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Min a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOSw z_sfOSx t1_sfOSy] f_sfOSw z_sfOSx t1_sfOSy;

Data.Semigroup.$fFoldableMin3
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfOSz xs_sfOSA] xs_sfOSA;

Data.Semigroup.$fFoldableMin_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Min a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOSB z0_sfOSC xs_sfOSD] f_sfOSB xs_sfOSD z0_sfOSC;

Data.Semigroup.$fFoldableFirst3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Semigroup.$fFoldableMin_$clength
  :: forall a. Data.Semigroup.Min a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfOSE] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableMin_$cnull
  :: forall a. Data.Semigroup.Min a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfOSF] GHC.Types.False [];

Data.Semigroup.$fFoldableMin_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Min a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfOSG] : [eta_sfOSG GHC.Types.[]];

Data.Semigroup.$fFoldableMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Min
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableMin4
                                             Data.Semigroup.$fFoldableMin_$cfoldMap
                                             Data.Semigroup.$fFoldableMin_$cfoldr'
                                             Data.Semigroup.$fFoldableMin_$cfoldr'
                                             Data.Semigroup.$fFoldableMin_$cfoldl
                                             Data.Semigroup.$fFoldableMin_$cfoldl
                                             Data.Semigroup.$fFoldableMin3
                                             Data.Semigroup.$fFoldableMin3
                                             Data.Semigroup.$fFoldableMin_$ctoList
                                             Data.Semigroup.$fFoldableMin_$cnull
                                             Data.Semigroup.$fFoldableMin_$clength
                                             Data.Semigroup.$fFoldableMin_$celem
                                             Data.Semigroup.$fFoldableMin2
                                             Data.Semigroup.$fFoldableMin2
                                             Data.Semigroup.$fFoldableMin1
                                             Data.Semigroup.$fFoldableMin1];

Data.Semigroup.$fApplicativeFirst3 :: forall b. b -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfOSH] v_sfOSH;

Data.Semigroup.$fTraversableMin_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.Min a -> f (Data.Semigroup.Min b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfOSI eta_sfOSJ eta1_sfOSK]
        let {
          sat_sfOSM [Occ=Once] :: f_afzb8 b_afzba
          [LclId] =
              [eta_sfOSJ eta1_sfOSK] \u [] eta_sfOSJ eta1_sfOSK;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfOSI of sat_sfOSL {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfOSL Data.Semigroup.$fApplicativeFirst3 sat_sfOSM;
          };

Data.Semigroup.$fTraversableMin_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Min (f a) -> f (Data.Semigroup.Min a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfOSN eta_sfOSO]
        case GHC.Base.$p1Applicative $dApplicative_sfOSN of sat_sfOSP {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfOSP Data.Semigroup.$fApplicativeFirst3 eta_sfOSO;
        };

Data.Semigroup.$fTraversableMin_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.Min a -> m (Data.Semigroup.Min b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfOSQ eta_sfOSR eta1_sfOSS]
        let {
          sat_sfOSV [Occ=Once] :: m_afzby b_afzbA
          [LclId] =
              [eta_sfOSR eta1_sfOSS] \u [] eta_sfOSR eta1_sfOSS;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfOSQ of sat_sfOST {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfOST of sat_sfOSU {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfOSU Data.Semigroup.$fApplicativeFirst3 sat_sfOSV;
                };
          };

Data.Semigroup.$fTraversableMin_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Min (m a) -> m (Data.Semigroup.Min a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfOSW eta_sfOSX]
        case GHC.Base.$p1Monad $dMonad_sfOSW of sat_sfOSY {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfOSY of sat_sfOSZ {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfOSZ Data.Semigroup.$fApplicativeFirst3 eta_sfOSX;
              };
        };

Data.Semigroup.$fTraversableMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorMin
                                                   Data.Semigroup.$fFoldableMin
                                                   Data.Semigroup.$fTraversableMin_$ctraverse
                                                   Data.Semigroup.$fTraversableMin_$csequenceA
                                                   Data.Semigroup.$fTraversableMin_$cmapM
                                                   Data.Semigroup.$fTraversableMin_$csequence];

Data.Semigroup.$fApplicativeMin_$c<*
  :: forall a b.
     Data.Semigroup.Min a
     -> Data.Semigroup.Min b -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfOT0 ds_sfOT1] a1_sfOT0;

Data.Semigroup.$fApplicativeMin_$c*>
  :: forall a b.
     Data.Semigroup.Min a
     -> Data.Semigroup.Min b -> Data.Semigroup.Min b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfOT2 a1_sfOT3] a1_sfOT3;

Data.Semigroup.$fApplicativeFirst1
  :: forall a b c. (a -> b -> c) -> a -> b -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfOT4] v_sfOT4;

Data.Semigroup.$fApplicativeMin1
  :: forall a b.
     Data.Semigroup.Min (a -> b) -> Data.Semigroup.Min (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfOT5] v_sfOT5;

Data.Semigroup.$fApplicativeMin [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorMin
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeMin1
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeMin_$c*>
                                           Data.Semigroup.$fApplicativeMin_$c<*];

Data.Semigroup.$fMonadMin_$c>>=
  :: forall a b.
     Data.Semigroup.Min a
     -> (a -> Data.Semigroup.Min b) -> Data.Semigroup.Min b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfOT6 f_sfOT7] f_sfOT7 ds_sfOT6;

lvl1_rfC67 :: forall a. [GHC.Types.Char] -> Data.Semigroup.Min a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfOT8] GHC.Err.errorWithoutStackTrace eta_sfOT8;

Data.Semigroup.$fMonadMin [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeMin
                                     Data.Semigroup.$fMonadMin_$c>>=
                                     Data.Semigroup.$fApplicativeMin_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl1_rfC67];

Data.Semigroup.$fNumMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U))>m] =
    [] \r [$dNum_sfOT9]
        let {
          sat_sfOTq [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [eta_sfOTp]
                  GHC.Num.fromInteger $dNum_sfOT9 eta_sfOTp; } in
        let {
          sat_sfOTo [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [ds_sfOTn]
                  GHC.Num.signum $dNum_sfOT9 ds_sfOTn; } in
        let {
          sat_sfOTm [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [ds_sfOTl] GHC.Num.abs $dNum_sfOT9 ds_sfOTl; } in
        let {
          sat_sfOTk [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [ds_sfOTj]
                  GHC.Num.negate $dNum_sfOT9 ds_sfOTj; } in
        let {
          sat_sfOTi [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK
               -> Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [ds_sfOTg ds1_sfOTh]
                  GHC.Num.* $dNum_sfOT9 ds_sfOTg ds1_sfOTh; } in
        let {
          sat_sfOTf [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK
               -> Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [ds_sfOTd ds1_sfOTe]
                  GHC.Num.- $dNum_sfOT9 ds_sfOTd ds1_sfOTe; } in
        let {
          sat_sfOTc [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK
               -> Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [ds_sfOTa ds1_sfOTb]
                  GHC.Num.+ $dNum_sfOT9 ds_sfOTa ds1_sfOTb;
        } in 
          GHC.Num.C:Num [sat_sfOTc
                         sat_sfOTf
                         sat_sfOTi
                         sat_sfOTk
                         sat_sfOTm
                         sat_sfOTo
                         sat_sfOTq];

Data.Semigroup.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Max a
     -> [Data.Semigroup.Max a] -> Data.Semigroup.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfOTr ww_sfOTs ww1_sfOTt]
        let {
          go_sfOTu [Occ=LoopBreaker]
            :: Data.Semigroup.Max a_sfBpa
               -> [Data.Semigroup.Max a_sfBpa] -> Data.Semigroup.Max a_sfBpa
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfOTr go_sfOTu] \r [b_sfOTv ds1_sfOTw]
                  case ds1_sfOTw of {
                    [] -> b_sfOTv;
                    : c_sfOTy [Occ=Once] cs_sfOTz [Occ=Once] ->
                        let {
                          sat_sfOTA [Occ=Once] :: a_sfBpa
                          [LclId] =
                              [go_sfOTu c_sfOTy cs_sfOTz] \u [] go_sfOTu c_sfOTy cs_sfOTz;
                        } in  GHC.Classes.max w_sfOTr b_sfOTv sat_sfOTA;
                  };
        } in  go_sfOTu ww_sfOTs ww1_sfOTt;

Data.Semigroup.$fSemigroupMax_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Semigroup.Max a) -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfOTB w1_sfOTC]
        case w1_sfOTC of {
          GHC.Base.:| ww1_sfOTE [Occ=Once] ww2_sfOTF [Occ=Once] ->
              Data.Semigroup.$w$csconcat w_sfOTB ww1_sfOTE ww2_sfOTF;
        };

lvl2_rfC68
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfOTG eta_sfOTH eta1_sfOTI]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfOTG eta_sfOTH eta1_sfOTI;

Data.Semigroup.$fSemigroupMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,A,U,A)>m] =
    [] \r [$dOrd_sfOTJ]
        let {
          sat_sfOTL [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Max a_afz6w)
               -> Data.Semigroup.Max a_afz6w
          [LclId] =
              [$dOrd_sfOTJ] \r [eta_B1]
                  Data.Semigroup.$fSemigroupMax_$csconcat $dOrd_sfOTJ eta_B1; } in
        let {
          sat_sfOTK [Occ=Once]
            :: Data.Semigroup.Max a_afz6w
               -> Data.Semigroup.Max a_afz6w -> Data.Semigroup.Max a_afz6w
          [LclId] =
              [$dOrd_sfOTJ] \u [] GHC.Classes.max $dOrd_sfOTJ;
        } in  GHC.Base.C:Semigroup [sat_sfOTK sat_sfOTL lvl2_rfC68];

Data.Semigroup.$fFunctorMax2
  :: forall a b. (a -> b) -> Data.Semigroup.Max a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOTM ds_sfOTN] f_sfOTM ds_sfOTN;

Data.Semigroup.$fFunctorMax1
  :: forall b a. a -> Data.Semigroup.Max b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sfOTO ds_sfOTP] x_sfOTO;

Data.Semigroup.$fFunctorMax [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorMax2
                                       Data.Semigroup.$fFunctorMax1];

Data.Semigroup.$fFoldableMax_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Max a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOTQ f_sfOTR ds_sfOTS] f_sfOTR ds_sfOTS;

Data.Semigroup.$fFoldableMax4
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.Max m -> Data.Semigroup.Max m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOTT ds_sfOTU] ds_sfOTU;

Data.Semigroup.$fFoldableMax1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfOTV eta_sfOTW] eta_sfOTW;

Data.Semigroup.$fFoldableMax2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOTX x_sfOTY] x_sfOTY;

Data.Semigroup.$fFoldableMax_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Max a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfOTZ eta_sfOU0]
        let {
          f_sfOU1 [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afz51 -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfOTZ eta_sfOU0] \u []
                  GHC.Classes.== $dEq_sfOTZ eta_sfOU0; } in
        let {
          sat_sfOU3 [Occ=OnceT[0]]
            :: Data.Semigroup.Max a_afz51 -> GHC.Types.Bool
          [LclId] =
              [f_sfOU1] \r [ds_sfOU2] f_sfOU1 ds_sfOU2;
        } in  sat_sfOU3;

Data.Semigroup.$fFoldableMax_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Max a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOU4 z_sfOU5 t1_sfOU6] f_sfOU4 z_sfOU5 t1_sfOU6;

Data.Semigroup.$fFoldableMax3
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfOU7 xs_sfOU8] xs_sfOU8;

Data.Semigroup.$fFoldableMax_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Max a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOU9 z0_sfOUa xs_sfOUb] f_sfOU9 xs_sfOUb z0_sfOUa;

Data.Semigroup.$fFoldableMax_$clength
  :: forall a. Data.Semigroup.Max a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfOUc] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableMax_$cnull
  :: forall a. Data.Semigroup.Max a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfOUd] GHC.Types.False [];

Data.Semigroup.$fFoldableMax_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Max a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfOUe] : [eta_sfOUe GHC.Types.[]];

Data.Semigroup.$fFoldableMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Max
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableMax4
                                             Data.Semigroup.$fFoldableMax_$cfoldMap
                                             Data.Semigroup.$fFoldableMax_$cfoldr'
                                             Data.Semigroup.$fFoldableMax_$cfoldr'
                                             Data.Semigroup.$fFoldableMax_$cfoldl
                                             Data.Semigroup.$fFoldableMax_$cfoldl
                                             Data.Semigroup.$fFoldableMax3
                                             Data.Semigroup.$fFoldableMax3
                                             Data.Semigroup.$fFoldableMax_$ctoList
                                             Data.Semigroup.$fFoldableMax_$cnull
                                             Data.Semigroup.$fFoldableMax_$clength
                                             Data.Semigroup.$fFoldableMax_$celem
                                             Data.Semigroup.$fFoldableMax2
                                             Data.Semigroup.$fFoldableMax2
                                             Data.Semigroup.$fFoldableMax1
                                             Data.Semigroup.$fFoldableMax1];

Data.Semigroup.$fTraversableMax_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.Max a -> f (Data.Semigroup.Max b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfOUf eta_sfOUg eta1_sfOUh]
        let {
          sat_sfOUj [Occ=Once] :: f_afz2z b_afz2B
          [LclId] =
              [eta_sfOUg eta1_sfOUh] \u [] eta_sfOUg eta1_sfOUh;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfOUf of sat_sfOUi {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfOUi Data.Semigroup.$fApplicativeFirst3 sat_sfOUj;
          };

Data.Semigroup.$fTraversableMax_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Max (f a) -> f (Data.Semigroup.Max a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfOUk eta_sfOUl]
        case GHC.Base.$p1Applicative $dApplicative_sfOUk of sat_sfOUm {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfOUm Data.Semigroup.$fApplicativeFirst3 eta_sfOUl;
        };

Data.Semigroup.$fTraversableMax_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.Max a -> m (Data.Semigroup.Max b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfOUn eta_sfOUo eta1_sfOUp]
        let {
          sat_sfOUs [Occ=Once] :: m_afz2Z b_afz31
          [LclId] =
              [eta_sfOUo eta1_sfOUp] \u [] eta_sfOUo eta1_sfOUp;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfOUn of sat_sfOUq {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfOUq of sat_sfOUr {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfOUr Data.Semigroup.$fApplicativeFirst3 sat_sfOUs;
                };
          };

Data.Semigroup.$fTraversableMax_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Max (m a) -> m (Data.Semigroup.Max a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfOUt eta_sfOUu]
        case GHC.Base.$p1Monad $dMonad_sfOUt of sat_sfOUv {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfOUv of sat_sfOUw {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfOUw Data.Semigroup.$fApplicativeFirst3 eta_sfOUu;
              };
        };

Data.Semigroup.$fTraversableMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorMax
                                                   Data.Semigroup.$fFoldableMax
                                                   Data.Semigroup.$fTraversableMax_$ctraverse
                                                   Data.Semigroup.$fTraversableMax_$csequenceA
                                                   Data.Semigroup.$fTraversableMax_$cmapM
                                                   Data.Semigroup.$fTraversableMax_$csequence];

Data.Semigroup.$fApplicativeMax_$c<*
  :: forall a b.
     Data.Semigroup.Max a
     -> Data.Semigroup.Max b -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfOUx ds_sfOUy] a1_sfOUx;

Data.Semigroup.$fApplicativeMax_$c*>
  :: forall a b.
     Data.Semigroup.Max a
     -> Data.Semigroup.Max b -> Data.Semigroup.Max b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfOUz a1_sfOUA] a1_sfOUA;

Data.Semigroup.$fApplicativeMax1
  :: forall a b.
     Data.Semigroup.Max (a -> b) -> Data.Semigroup.Max (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfOUB] v_sfOUB;

Data.Semigroup.$fApplicativeMax [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorMax
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeMax1
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeMax_$c*>
                                           Data.Semigroup.$fApplicativeMax_$c<*];

Data.Semigroup.$fMonadMax_$c>>=
  :: forall a b.
     Data.Semigroup.Max a
     -> (a -> Data.Semigroup.Max b) -> Data.Semigroup.Max b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfOUC f_sfOUD] f_sfOUD ds_sfOUC;

lvl3_rfC69 :: forall a. [GHC.Types.Char] -> Data.Semigroup.Max a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfOUE] GHC.Err.errorWithoutStackTrace eta_sfOUE;

Data.Semigroup.$fMonadMax [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeMax
                                     Data.Semigroup.$fMonadMax_$c>>=
                                     Data.Semigroup.$fApplicativeMax_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl3_rfC69];

Data.Semigroup.$fNumMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U))>m] =
    [] \r [$dNum_sfOUF]
        let {
          sat_sfOUW [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [eta_sfOUV]
                  GHC.Num.fromInteger $dNum_sfOUF eta_sfOUV; } in
        let {
          sat_sfOUU [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [ds_sfOUT]
                  GHC.Num.signum $dNum_sfOUF ds_sfOUT; } in
        let {
          sat_sfOUS [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [ds_sfOUR] GHC.Num.abs $dNum_sfOUF ds_sfOUR; } in
        let {
          sat_sfOUQ [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [ds_sfOUP]
                  GHC.Num.negate $dNum_sfOUF ds_sfOUP; } in
        let {
          sat_sfOUO [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3
               -> Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [ds_sfOUM ds1_sfOUN]
                  GHC.Num.* $dNum_sfOUF ds_sfOUM ds1_sfOUN; } in
        let {
          sat_sfOUL [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3
               -> Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [ds_sfOUJ ds1_sfOUK]
                  GHC.Num.- $dNum_sfOUF ds_sfOUJ ds1_sfOUK; } in
        let {
          sat_sfOUI [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3
               -> Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [ds_sfOUG ds1_sfOUH]
                  GHC.Num.+ $dNum_sfOUF ds_sfOUG ds1_sfOUH;
        } in 
          GHC.Num.C:Num [sat_sfOUI
                         sat_sfOUL
                         sat_sfOUO
                         sat_sfOUQ
                         sat_sfOUS
                         sat_sfOUU
                         sat_sfOUW];

Data.Semigroup.$fFunctorArg_$cfmap
  :: forall a1 a2 b.
     (a2 -> b) -> Data.Semigroup.Arg a1 a2 -> Data.Semigroup.Arg a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sfOUX ds_sfOUY]
        case ds_sfOUY of {
          Data.Semigroup.Arg x_sfOV0 [Occ=Once] a2_sfOV1 [Occ=Once] ->
              let {
                sat_sfOV2 [Occ=Once] :: b_afyZC
                [LclId] =
                    [f_sfOUX a2_sfOV1] \u [] f_sfOUX a2_sfOV1;
              } in  Data.Semigroup.Arg [x_sfOV0 sat_sfOV2];
        };

Data.Semigroup.$fFunctorArg_$c<$
  :: forall a1 a2 b.
     a2 -> Data.Semigroup.Arg a1 b -> Data.Semigroup.Arg a1 a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [x_sfOV3 ds_sfOV4]
        case ds_sfOV4 of {
          Data.Semigroup.Arg x1_sfOV6 [Occ=Once] _ [Occ=Dead] ->
              Data.Semigroup.Arg [x1_sfOV6 x_sfOV3];
        };

Data.Semigroup.$fFunctorArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Functor (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorArg_$cfmap
                                       Data.Semigroup.$fFunctorArg_$c<$];

Data.Semigroup.$fFoldableArg_$cfoldMap
  :: forall a1 m a2.
     GHC.Base.Monoid m =>
     (a2 -> m) -> Data.Semigroup.Arg a1 a2 -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOV8 f_sfOV9 ds_sfOVa]
        case ds_sfOVa of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVd [Occ=Once] ->
              f_sfOV9 a2_sfOVd;
        };

Data.Semigroup.$fFoldableArg_$cfold
  :: forall a m. GHC.Base.Monoid m => Data.Semigroup.Arg a m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOVe ds_sfOVf]
        case ds_sfOVf of {
          Data.Semigroup.Arg _ [Occ=Dead] a1_sfOVi [Occ=Once] -> a1_sfOVi;
        };

Data.Semigroup.$fFoldableArg2
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Semigroup.Arg a1 a2 -> Data.Semigroup.Internal.Sum a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfOVj eta_sfOVk]
        case eta_sfOVk of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVn [Occ=Once] -> a2_sfOVn;
        };

Data.Semigroup.$fFoldableArg3
  :: forall a1 a2. Data.Semigroup.Arg a2 a1 -> a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [x_sfOVo]
        case x_sfOVo of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVr [Occ=Once] -> a2_sfOVr;
        };

Data.Semigroup.$fFoldableArg_$cminimum
  :: forall a1 a2.
     GHC.Classes.Ord a2 =>
     Data.Semigroup.Arg a1 a2 -> a2
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sfOVs eta_B1] Data.Semigroup.$fFoldableArg3 eta_B1;

Data.Semigroup.$fFoldableArg_$celem
  :: forall a1 a2.
     GHC.Classes.Eq a2 =>
     a2 -> Data.Semigroup.Arg a1 a2 -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfOVt eta_sfOVu]
        let {
          f_sfOVv [Occ=OnceL!, Dmd=<L,C(U)>] :: a1_afyYK -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfOVt eta_sfOVu] \u []
                  GHC.Classes.== $dEq_sfOVt eta_sfOVu; } in
        let {
          sat_sfOVA [Occ=Once]
            :: Data.Semigroup.Arg a_XfzaV a1_afyYK
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_sfOVv] \r [ds_sfOVw]
                  case ds_sfOVw of {
                    Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVz [Occ=Once] ->
                        f_sfOVv a2_sfOVz;
                  };
        } in  sat_sfOVA;

Data.Semigroup.$fFoldableArg_$cfoldl
  :: forall a1 b a2.
     (b -> a2 -> b) -> b -> Data.Semigroup.Arg a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfOVB z_sfOVC t1_sfOVD]
        case t1_sfOVD of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVG [Occ=Once] ->
              f_sfOVB z_sfOVC a2_sfOVG;
        };

Data.Semigroup.$fFoldableArg_$cfoldl1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Data.Semigroup.Arg a1 a2 -> a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sfOVH xs_sfOVI]
        case xs_sfOVI of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVL [Occ=Once] -> a2_sfOVL;
        };

Data.Semigroup.$fFoldableArg_$cfoldr'
  :: forall a1 a2 b.
     (a2 -> b -> b) -> b -> Data.Semigroup.Arg a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfOVM z0_sfOVN xs_sfOVO]
        case xs_sfOVO of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVR [Occ=Once] ->
              f_sfOVM a2_sfOVR z0_sfOVN;
        };

Data.Semigroup.$fFoldableArg_$clength
  :: forall a1 a2. Data.Semigroup.Arg a1 a2 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_sfOVS]
        case xs_sfOVS of {
          Data.Semigroup.Arg _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Semigroup.$fFoldableFirst3;
        };

Data.Semigroup.$fFoldableArg_$cnull
  :: forall a1 a2. Data.Semigroup.Arg a1 a2 -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [t1_sfOVW]
        case t1_sfOVW of {
          Data.Semigroup.Arg _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Semigroup.$fFoldableArg1
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Semigroup.Arg a1 a2 -> Data.Semigroup.Internal.Product a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfOW0 eta_sfOW1]
        case eta_sfOW1 of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOW4 [Occ=Once] -> a2_sfOW4;
        };

Data.Semigroup.$fFoldableArg_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. Data.Semigroup.Arg a1 a2 -> [a2]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_sfOW5]
        case eta_sfOW5 of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOW8 [Occ=Once] ->
              : [a2_sfOW8 GHC.Types.[]];
        };

Data.Semigroup.$fFoldableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Foldable.Foldable (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableArg_$cfold
                                             Data.Semigroup.$fFoldableArg_$cfoldMap
                                             Data.Semigroup.$fFoldableArg_$cfoldr'
                                             Data.Semigroup.$fFoldableArg_$cfoldr'
                                             Data.Semigroup.$fFoldableArg_$cfoldl
                                             Data.Semigroup.$fFoldableArg_$cfoldl
                                             Data.Semigroup.$fFoldableArg_$cfoldl1
                                             Data.Semigroup.$fFoldableArg_$cfoldl1
                                             Data.Semigroup.$fFoldableArg_$ctoList
                                             Data.Semigroup.$fFoldableArg_$cnull
                                             Data.Semigroup.$fFoldableArg_$clength
                                             Data.Semigroup.$fFoldableArg_$celem
                                             Data.Semigroup.$fFoldableArg_$cminimum
                                             Data.Semigroup.$fFoldableArg_$cminimum
                                             Data.Semigroup.$fFoldableArg2
                                             Data.Semigroup.$fFoldableArg1];

Data.Semigroup.$fTraversableArg_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     GHC.Base.Applicative f =>
     (a2 -> f b)
     -> Data.Semigroup.Arg a1 a2 -> f (Data.Semigroup.Arg a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfOW9 eta_sfOWa eta1_sfOWb]
        case eta1_sfOWb of {
          Data.Semigroup.Arg x_sfOWd [Occ=OnceL] a2_sfOWe [Occ=Once] ->
              let {
                sat_sfOWh [Occ=Once] :: f_afyWg b_afyWi
                [LclId] =
                    [eta_sfOWa a2_sfOWe] \u [] eta_sfOWa a2_sfOWe; } in
              let {
                sat_sfOWg [Occ=Once]
                  :: b_afyWi -> Data.Semigroup.Arg a_afyW4 b_afyWi
                [LclId] =
                    [x_sfOWd] \r [eta_B1] Data.Semigroup.Arg [x_sfOWd eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfOW9 of sat_sfOWf {
                  __DEFAULT -> GHC.Base.fmap sat_sfOWf sat_sfOWg sat_sfOWh;
                };
        };

Data.Semigroup.$fTraversableArg_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     GHC.Base.Applicative f =>
     Data.Semigroup.Arg a1 (f a2) -> f (Data.Semigroup.Arg a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfOWi eta_sfOWj]
        case eta_sfOWj of {
          Data.Semigroup.Arg x_sfOWl [Occ=OnceL] a2_sfOWm [Occ=Once] ->
              let {
                sat_sfOWo [Occ=Once]
                  :: a1_afyWw -> Data.Semigroup.Arg a_afyW4 a1_afyWw
                [LclId] =
                    [x_sfOWl] \r [eta_B1] Data.Semigroup.Arg [x_sfOWl eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfOWi of sat_sfOWn {
                  __DEFAULT -> GHC.Base.fmap sat_sfOWn sat_sfOWo a2_sfOWm;
                };
        };

Data.Semigroup.$fTraversableArg_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     GHC.Base.Monad m =>
     (a2 -> m b)
     -> Data.Semigroup.Arg a1 a2 -> m (Data.Semigroup.Arg a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfOWp eta_sfOWq eta1_sfOWr]
        case eta1_sfOWr of {
          Data.Semigroup.Arg x_sfOWt [Occ=OnceL] a2_sfOWu [Occ=Once] ->
              let {
                sat_sfOWy [Occ=Once] :: m_afyWH b_afyWJ
                [LclId] =
                    [eta_sfOWq a2_sfOWu] \u [] eta_sfOWq a2_sfOWu; } in
              let {
                sat_sfOWx [Occ=Once]
                  :: b_afyWJ -> Data.Semigroup.Arg a_afyW4 b_afyWJ
                [LclId] =
                    [x_sfOWt] \r [eta_B1] Data.Semigroup.Arg [x_sfOWt eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sfOWp of sat_sfOWv {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sfOWv of sat_sfOWw {
                        __DEFAULT -> GHC.Base.fmap sat_sfOWw sat_sfOWx sat_sfOWy;
                      };
                };
        };

Data.Semigroup.$fTraversableArg_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     GHC.Base.Monad m =>
     Data.Semigroup.Arg a1 (m a2) -> m (Data.Semigroup.Arg a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfOWz eta_sfOWA]
        case eta_sfOWA of {
          Data.Semigroup.Arg x_sfOWC [Occ=OnceL] a2_sfOWD [Occ=Once] ->
              let {
                sat_sfOWG [Occ=Once]
                  :: a1_afyWW -> Data.Semigroup.Arg a_afyW4 a1_afyWW
                [LclId] =
                    [x_sfOWC] \r [eta_B1] Data.Semigroup.Arg [x_sfOWC eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sfOWz of sat_sfOWE {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sfOWE of sat_sfOWF {
                        __DEFAULT -> GHC.Base.fmap sat_sfOWF sat_sfOWG a2_sfOWD;
                      };
                };
        };

Data.Semigroup.$fTraversableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Traversable.Traversable (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorArg
                                                   Data.Semigroup.$fFoldableArg
                                                   Data.Semigroup.$fTraversableArg_$ctraverse
                                                   Data.Semigroup.$fTraversableArg_$csequenceA
                                                   Data.Semigroup.$fTraversableArg_$cmapM
                                                   Data.Semigroup.$fTraversableArg_$csequence];

Data.Semigroup.$fEqArg_$c==
  :: forall a b.
     GHC.Classes.Eq a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfOWH ds_sfOWI ds1_sfOWJ]
        case ds_sfOWI of {
          Data.Semigroup.Arg a1_sfOWL [Occ=Once] _ [Occ=Dead] ->
              case ds1_sfOWJ of {
                Data.Semigroup.Arg b1_sfOWO [Occ=Once] _ [Occ=Dead] ->
                    GHC.Classes.== $dEq_sfOWH a1_sfOWL b1_sfOWO;
              };
        };

Data.Semigroup.$fEqArg_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     GHC.Classes.Eq a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfOWQ eta_sfOWR eta1_sfOWS]
        case eta_sfOWR of {
          Data.Semigroup.Arg a1_sfOWU [Occ=Once] _ [Occ=Dead] ->
              case eta1_sfOWS of {
                Data.Semigroup.Arg b1_sfOWX [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.== $dEq_sfOWQ a1_sfOWU b1_sfOWX of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Semigroup.$fEqArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Arg a b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sfOX0]
        let {
          sat_sfOX2 [Occ=Once]
            :: Data.Semigroup.Arg a_afyVO b_afyVP
               -> Data.Semigroup.Arg a_afyVO b_afyVP -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfOX0] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fEqArg_$c/= $dEq_sfOX0 eta_B2 eta_B1; } in
        let {
          sat_sfOX1 [Occ=Once]
            :: Data.Semigroup.Arg a_afyVO b_afyVP
               -> Data.Semigroup.Arg a_afyVO b_afyVP -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfOX0] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fEqArg_$c== $dEq_sfOX0 eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sfOX1 sat_sfOX2];

Data.Semigroup.$fOrdArg_$cmin
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b
     -> Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOX3 x_sfOX4 y_sfOX5]
        case x_sfOX4 of wild_sfOX6 {
          Data.Semigroup.Arg a1_sfOX7 [Occ=Once] _ [Occ=Dead] ->
              case y_sfOX5 of wild1_sfOX9 {
                Data.Semigroup.Arg b1_sfOXa [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.<= $dOrd_sfOX3 a1_sfOX7 b1_sfOXa of {
                      GHC.Types.False -> wild1_sfOX9;
                      GHC.Types.True -> wild_sfOX6;
                    };
              };
        };

Data.Semigroup.$fOrdArg_$cmax
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b
     -> Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOXd x_sfOXe y_sfOXf]
        case x_sfOXe of wild_sfOXg {
          Data.Semigroup.Arg a1_sfOXh [Occ=Once] _ [Occ=Dead] ->
              case y_sfOXf of wild1_sfOXj {
                Data.Semigroup.Arg b1_sfOXk [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.>= $dOrd_sfOXd a1_sfOXh b1_sfOXk of {
                      GHC.Types.False -> wild1_sfOXj;
                      GHC.Types.True -> wild_sfOXg;
                    };
              };
        };

Data.Semigroup.$fOrdArg_$ccompare
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b
     -> Data.Semigroup.Arg a b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOXn ds_sfOXo ds1_sfOXp]
        case ds_sfOXo of {
          Data.Semigroup.Arg a1_sfOXr [Occ=Once] _ [Occ=Dead] ->
              case ds1_sfOXp of {
                Data.Semigroup.Arg b1_sfOXu [Occ=Once] _ [Occ=Dead] ->
                    GHC.Classes.compare $dOrd_sfOXn a1_sfOXr b1_sfOXu;
              };
        };

Data.Semigroup.$fOrdArg_$cp1Ord
  :: forall a b.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Arg a b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOXw]
        let {
          sat_sfOXx [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_afyV3
          [LclId] =
              [$dOrd_sfOXw] \u [] GHC.Classes.$p1Ord $dOrd_sfOXw;
        } in  Data.Semigroup.$fEqArg sat_sfOXx;

Data.Semigroup.$fOrdArg_$c<
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOXy x_sfOXz y_sfOXA]
        case x_sfOXz of {
          Data.Semigroup.Arg a1_sfOXC [Occ=Once] _ [Occ=Dead] ->
              case y_sfOXA of {
                Data.Semigroup.Arg b1_sfOXF [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfOXy a1_sfOXC b1_sfOXF of {
                      __DEFAULT -> GHC.Types.False [];
                      GHC.Types.LT -> GHC.Types.True [];
                    };
              };
        };

Data.Semigroup.$fOrdArg_$c>
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOXI x_sfOXJ y_sfOXK]
        case x_sfOXJ of {
          Data.Semigroup.Arg a1_sfOXM [Occ=Once] _ [Occ=Dead] ->
              case y_sfOXK of {
                Data.Semigroup.Arg b1_sfOXP [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfOXI a1_sfOXM b1_sfOXP of {
                      __DEFAULT -> GHC.Types.False [];
                      GHC.Types.GT -> GHC.Types.True [];
                    };
              };
        };

Data.Semigroup.$fOrdArg_$c<=
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOXS x_sfOXT y_sfOXU]
        case x_sfOXT of {
          Data.Semigroup.Arg a1_sfOXW [Occ=Once] _ [Occ=Dead] ->
              case y_sfOXU of {
                Data.Semigroup.Arg b1_sfOXZ [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfOXS a1_sfOXW b1_sfOXZ of {
                      __DEFAULT -> GHC.Types.True [];
                      GHC.Types.GT -> GHC.Types.False [];
                    };
              };
        };

Data.Semigroup.$fOrdArg_$c>=
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOY2 x_sfOY3 y_sfOY4]
        case x_sfOY3 of {
          Data.Semigroup.Arg a1_sfOY6 [Occ=Once] _ [Occ=Dead] ->
              case y_sfOY4 of {
                Data.Semigroup.Arg b1_sfOY9 [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfOY2 a1_sfOY6 b1_sfOY9 of {
                      __DEFAULT -> GHC.Types.True [];
                      GHC.Types.LT -> GHC.Types.False [];
                    };
              };
        };

Data.Semigroup.$fOrdArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,C(C1(U)),A,C(C1(U)),A,A)>m] =
    [] \r [$dOrd_sfOYc]
        let {
          sat_sfOYk [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$cmin $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYj [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$cmax $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYi [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c>= $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYh [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c> $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYg [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c<= $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYf [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c< $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYe [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$ccompare $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYd [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Arg a_afyV3 b_afyV4)
          [LclId] =
              [$dOrd_sfOYc] \u [] Data.Semigroup.$fOrdArg_$cp1Ord $dOrd_sfOYc;
        } in 
          GHC.Classes.C:Ord [sat_sfOYd
                             sat_sfOYe
                             sat_sfOYf
                             sat_sfOYg
                             sat_sfOYh
                             sat_sfOYi
                             sat_sfOYj
                             sat_sfOYk];

Data.Semigroup.$fBifunctorArg_$cbimap
  :: forall a b c d.
     (a -> b)
     -> (c -> d) -> Data.Semigroup.Arg a c -> Data.Semigroup.Arg b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sfOYl g_sfOYm ds_sfOYn]
        case ds_sfOYn of {
          Data.Semigroup.Arg a1_sfOYp [Occ=Once] b1_sfOYq [Occ=Once] ->
              let {
                sat_sfOYs [Occ=Once] :: d_afyUz
                [LclId] =
                    [g_sfOYm b1_sfOYq] \u [] g_sfOYm b1_sfOYq; } in
              let {
                sat_sfOYr [Occ=Once] :: b_afyUx
                [LclId] =
                    [f_sfOYl a1_sfOYp] \u [] f_sfOYl a1_sfOYp;
              } in  Data.Semigroup.Arg [sat_sfOYr sat_sfOYs];
        };

Data.Semigroup.$fBifunctorArg_$cfirst
  :: forall a b c.
     (a -> b) -> Data.Semigroup.Arg a c -> Data.Semigroup.Arg b c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sfOYt ds_sfOYu]
        case ds_sfOYu of {
          Data.Semigroup.Arg a1_sfOYw [Occ=Once] b1_sfOYx [Occ=Once] ->
              let {
                sat_sfOYy [Occ=Once] :: b_afyUH
                [LclId] =
                    [f_sfOYt a1_sfOYw] \u [] f_sfOYt a1_sfOYw;
              } in  Data.Semigroup.Arg [sat_sfOYy b1_sfOYx];
        };

Data.Semigroup.$fBifunctorArg_$csecond
  :: forall b c a.
     (b -> c) -> Data.Semigroup.Arg a b -> Data.Semigroup.Arg a c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [g_sfOYz ds_sfOYA]
        case ds_sfOYA of {
          Data.Semigroup.Arg a1_sfOYC [Occ=Once] b1_sfOYD [Occ=Once] ->
              let {
                sat_sfOYE [Occ=Once] :: c_afyUT
                [LclId] =
                    [g_sfOYz b1_sfOYD] \u [] g_sfOYz b1_sfOYD;
              } in  Data.Semigroup.Arg [a1_sfOYC sat_sfOYE];
        };

Data.Semigroup.$fBifunctorArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor Data.Semigroup.Arg
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Semigroup.$fBifunctorArg_$cbimap
                                               Data.Semigroup.$fBifunctorArg_$cfirst
                                               Data.Semigroup.$fBifunctorArg_$csecond];

Data.Semigroup.$fBifoldableArg_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> Data.Semigroup.Arg a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOYF eta_sfOYG eta1_sfOYH eta2_sfOYI]
        case eta2_sfOYI of {
          Data.Semigroup.Arg a1_sfOYK [Occ=Once] b1_sfOYL [Occ=Once] ->
              let {
                sat_sfOYO [Occ=Once] :: m_afyTV
                [LclId] =
                    [eta1_sfOYH b1_sfOYL] \u [] eta1_sfOYH b1_sfOYL; } in
              let {
                sat_sfOYN [Occ=Once] :: m_afyTV
                [LclId] =
                    [eta_sfOYG a1_sfOYK] \u [] eta_sfOYG a1_sfOYK;
              } in 
                case GHC.Base.$p1Monoid $dMonoid_sfOYF of sat_sfOYM {
                  __DEFAULT -> GHC.Base.<> sat_sfOYM sat_sfOYN sat_sfOYO;
                };
        };

Data.Semigroup.$fBifoldableArg_$cbifold
  :: forall m. GHC.Base.Monoid m => Data.Semigroup.Arg m m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOYP eta_sfOYQ]
        case eta_sfOYQ of {
          Data.Semigroup.Arg a_sfOYS [Occ=Once] b_sfOYT [Occ=Once] ->
              case GHC.Base.$p1Monoid $dMonoid_sfOYP of sat_sfOYU {
                __DEFAULT -> GHC.Base.<> sat_sfOYU a_sfOYS b_sfOYT;
              };
        };

Data.Semigroup.$fBifoldableArg_$cbifoldr
  :: forall a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> Data.Semigroup.Arg a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfOYV g_sfOYW z_sfOYX t_sfOYY]
        case t_sfOYY of {
          Data.Semigroup.Arg a1_sfOZ0 [Occ=Once] b1_sfOZ1 [Occ=Once] ->
              let {
                sat_sfOZ2 [Occ=Once] :: c_afyU7
                [LclId] =
                    [g_sfOYW z_sfOYX b1_sfOZ1] \u [] g_sfOYW b1_sfOZ1 z_sfOYX;
              } in  f_sfOYV a1_sfOZ0 sat_sfOZ2;
        };

Data.Semigroup.$fBifoldableArg_$cbifoldl
  :: forall c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> Data.Semigroup.Arg a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfOZ3 g_sfOZ4 z_sfOZ5 t_sfOZ6]
        case t_sfOZ6 of {
          Data.Semigroup.Arg a1_sfOZ8 [Occ=Once] b1_sfOZ9 [Occ=Once] ->
              let {
                sat_sfOZa [Occ=Once] :: c_afyUi
                [LclId] =
                    [f_sfOZ3 z_sfOZ5 a1_sfOZ8] \u [] f_sfOZ3 z_sfOZ5 a1_sfOZ8;
              } in  g_sfOZ4 sat_sfOZa b1_sfOZ9;
        };

Data.Semigroup.$fBifoldableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable Data.Semigroup.Arg
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Semigroup.$fBifoldableArg_$cbifold
                                                 Data.Semigroup.$fBifoldableArg_$cbifoldMap
                                                 Data.Semigroup.$fBifoldableArg_$cbifoldr
                                                 Data.Semigroup.$fBifoldableArg_$cbifoldl];

Data.Semigroup.$w$cbitraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> a -> b -> f (Data.Semigroup.Arg c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfOZb w1_sfOZc w2_sfOZd ww_sfOZe ww1_sfOZf]
        let {
          sat_sfOZj [Occ=Once] :: f_sfBpj d_sfBpn
          [LclId] =
              [w2_sfOZd ww1_sfOZf] \u [] w2_sfOZd ww1_sfOZf; } in
        let {
          sat_sfOZi [Occ=Once]
            :: f_sfBpj (d_sfBpn -> Data.Semigroup.Arg c_sfBpl d_sfBpn)
          [LclId] =
              [w_sfOZb w1_sfOZc ww_sfOZe] \u []
                  let {
                    sat_sfOZh [Occ=Once] :: f_sfBpj c_sfBpl
                    [LclId] =
                        [w1_sfOZc ww_sfOZe] \u [] w1_sfOZc ww_sfOZe;
                  } in 
                    case GHC.Base.$p1Applicative w_sfOZb of sat_sfOZg {
                      __DEFAULT -> GHC.Base.fmap sat_sfOZg Data.Semigroup.Arg sat_sfOZh;
                    };
        } in  GHC.Base.<*> w_sfOZb sat_sfOZi sat_sfOZj;

Data.Semigroup.$fBitraversableArg_$cbitraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d)
     -> Data.Semigroup.Arg a b
     -> f (Data.Semigroup.Arg c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sfOZk w1_sfOZl w2_sfOZm w3_sfOZn]
        case w3_sfOZn of {
          Data.Semigroup.Arg ww1_sfOZp [Occ=Once] ww2_sfOZq [Occ=Once] ->
              Data.Semigroup.$w$cbitraverse
                  w_sfOZk w1_sfOZl w2_sfOZm ww1_sfOZp ww2_sfOZq;
        };

Data.Semigroup.$fBitraversableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable Data.Semigroup.Arg
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Semigroup.$fBifunctorArg
                                                       Data.Semigroup.$fBifoldableArg
                                                       Data.Semigroup.$fBitraversableArg_$cbitraverse];

Data.Semigroup.$fSemigroupFirst_$cstimes
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfOZr eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfOZr eta_B2 eta_B1;

Data.Semigroup.$fSemigroupFirst_$c<>
  :: forall a.
     Data.Semigroup.First a
     -> Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfOZs ds_sfOZt] a1_sfOZs;

Data.Semigroup.$fSemigroupFirst_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Semigroup.First a)
     -> Data.Semigroup.First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfOZu]
        case ds_sfOZu of {
          GHC.Base.:| a1_sfOZw [Occ=Once] as_sfOZx [Occ=Once] ->
              case as_sfOZx of { __DEFAULT -> a1_sfOZw; };
        };

Data.Semigroup.$fSemigroupFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Semigroup.First a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Semigroup.$fSemigroupFirst_$c<>
                                         Data.Semigroup.$fSemigroupFirst_$csconcat
                                         Data.Semigroup.$fSemigroupFirst_$cstimes];

Data.Semigroup.$fFunctorFirst2
  :: forall a b. (a -> b) -> Data.Semigroup.First a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOZz ds_sfOZA] f_sfOZz ds_sfOZA;

Data.Semigroup.$fFunctorFirst1
  :: forall b a. a -> Data.Semigroup.First b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sfOZB ds_sfOZC] x_sfOZB;

Data.Semigroup.$fFunctorFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorFirst2
                                       Data.Semigroup.$fFunctorFirst1];

Data.Semigroup.$fFoldableFirst_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.First a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOZD f_sfOZE ds_sfOZF] f_sfOZE ds_sfOZF;

Data.Semigroup.$fFoldableFirst5
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.First m -> Data.Semigroup.First m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOZG ds_sfOZH] ds_sfOZH;

Data.Semigroup.$fFoldableFirst1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfOZI eta_sfOZJ] eta_sfOZJ;

Data.Semigroup.$fFoldableFirst2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOZK x_sfOZL] x_sfOZL;

Data.Semigroup.$fFoldableFirst_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.First a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfOZM eta_sfOZN]
        let {
          f_sfOZO [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afyQr -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfOZM eta_sfOZN] \u []
                  GHC.Classes.== $dEq_sfOZM eta_sfOZN; } in
        let {
          sat_sfOZQ [Occ=OnceT[0]]
            :: Data.Semigroup.First a_afyQr -> GHC.Types.Bool
          [LclId] =
              [f_sfOZO] \r [ds_sfOZP] f_sfOZO ds_sfOZP;
        } in  sat_sfOZQ;

Data.Semigroup.$fFoldableFirst_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOZR z_sfOZS t1_sfOZT] f_sfOZR z_sfOZS t1_sfOZT;

Data.Semigroup.$fFoldableFirst4
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfOZU xs_sfOZV] xs_sfOZV;

Data.Semigroup.$fFoldableFirst_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOZW z0_sfOZX xs_sfOZY] f_sfOZW xs_sfOZY z0_sfOZX;

Data.Semigroup.$fFoldableFirst_$clength
  :: forall a. Data.Semigroup.First a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfOZZ] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableFirst_$cnull
  :: forall a. Data.Semigroup.First a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfP00] GHC.Types.False [];

Data.Semigroup.$fFoldableFirst_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.First a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfP01] : [eta_sfP01 GHC.Types.[]];

Data.Semigroup.$fFoldableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.First
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableFirst5
                                             Data.Semigroup.$fFoldableFirst_$cfoldMap
                                             Data.Semigroup.$fFoldableFirst_$cfoldr'
                                             Data.Semigroup.$fFoldableFirst_$cfoldr'
                                             Data.Semigroup.$fFoldableFirst_$cfoldl
                                             Data.Semigroup.$fFoldableFirst_$cfoldl
                                             Data.Semigroup.$fFoldableFirst4
                                             Data.Semigroup.$fFoldableFirst4
                                             Data.Semigroup.$fFoldableFirst_$ctoList
                                             Data.Semigroup.$fFoldableFirst_$cnull
                                             Data.Semigroup.$fFoldableFirst_$clength
                                             Data.Semigroup.$fFoldableFirst_$celem
                                             Data.Semigroup.$fFoldableFirst2
                                             Data.Semigroup.$fFoldableFirst2
                                             Data.Semigroup.$fFoldableFirst1
                                             Data.Semigroup.$fFoldableFirst1];

Data.Semigroup.$fTraversableFirst_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.First a -> f (Data.Semigroup.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfP02 eta_sfP03 eta1_sfP04]
        let {
          sat_sfP06 [Occ=Once] :: f_afyNZ b_afyO1
          [LclId] =
              [eta_sfP03 eta1_sfP04] \u [] eta_sfP03 eta1_sfP04;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfP02 of sat_sfP05 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfP05 Data.Semigroup.$fApplicativeFirst3 sat_sfP06;
          };

Data.Semigroup.$fTraversableFirst_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.First (f a) -> f (Data.Semigroup.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfP07 eta_sfP08]
        case GHC.Base.$p1Applicative $dApplicative_sfP07 of sat_sfP09 {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfP09 Data.Semigroup.$fApplicativeFirst3 eta_sfP08;
        };

Data.Semigroup.$fTraversableFirst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.First a -> m (Data.Semigroup.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfP0a eta_sfP0b eta1_sfP0c]
        let {
          sat_sfP0f [Occ=Once] :: m_afyOp b_afyOr
          [LclId] =
              [eta_sfP0b eta1_sfP0c] \u [] eta_sfP0b eta1_sfP0c;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfP0a of sat_sfP0d {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfP0d of sat_sfP0e {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfP0e Data.Semigroup.$fApplicativeFirst3 sat_sfP0f;
                };
          };

Data.Semigroup.$fTraversableFirst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.First (m a) -> m (Data.Semigroup.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfP0g eta_sfP0h]
        case GHC.Base.$p1Monad $dMonad_sfP0g of sat_sfP0i {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfP0i of sat_sfP0j {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfP0j Data.Semigroup.$fApplicativeFirst3 eta_sfP0h;
              };
        };

Data.Semigroup.$fTraversableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorFirst
                                                   Data.Semigroup.$fFoldableFirst
                                                   Data.Semigroup.$fTraversableFirst_$ctraverse
                                                   Data.Semigroup.$fTraversableFirst_$csequenceA
                                                   Data.Semigroup.$fTraversableFirst_$cmapM
                                                   Data.Semigroup.$fTraversableFirst_$csequence];

Data.Semigroup.$fApplicativeFirst_$c<*
  :: forall a b.
     Data.Semigroup.First a
     -> Data.Semigroup.First b -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfP0k ds_sfP0l] a1_sfP0k;

Data.Semigroup.$fApplicativeFirst_$c*>
  :: forall a b.
     Data.Semigroup.First a
     -> Data.Semigroup.First b -> Data.Semigroup.First b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfP0m a1_sfP0n] a1_sfP0n;

Data.Semigroup.$fApplicativeFirst2
  :: forall a b.
     Data.Semigroup.First (a -> b) -> Data.Semigroup.First (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfP0o] v_sfP0o;

Data.Semigroup.$fApplicativeFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorFirst
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeFirst2
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeFirst_$c*>
                                           Data.Semigroup.$fApplicativeFirst_$c<*];

Data.Semigroup.$fMonadFirst_$c>>=
  :: forall a b.
     Data.Semigroup.First a
     -> (a -> Data.Semigroup.First b) -> Data.Semigroup.First b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfP0p f_sfP0q] f_sfP0q ds_sfP0p;

lvl4_rfC6a :: forall a. [GHC.Types.Char] -> Data.Semigroup.First a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfP0r] GHC.Err.errorWithoutStackTrace eta_sfP0r;

Data.Semigroup.$fMonadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeFirst
                                     Data.Semigroup.$fMonadFirst_$c>>=
                                     Data.Semigroup.$fApplicativeFirst_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl4_rfC6a];

Data.Semigroup.$fSemigroupLast_$cstimes
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfP0s eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfP0s eta_B2 eta_B1;

Data.Semigroup.$fSemigroupLast_$c<>
  :: forall a.
     Data.Semigroup.Last a
     -> Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfP0t b_sfP0u] b_sfP0u;

Data.Semigroup.$fSemigroupLast1 [Occ=LoopBreaker]
  :: forall a.
     Data.Semigroup.Last a
     -> [Data.Semigroup.Last a] -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sfP0v ds1_sfP0w]
        case ds1_sfP0w of {
          [] -> b_sfP0v;
          : c_sfP0y [Occ=Once] cs_sfP0z [Occ=Once] ->
              Data.Semigroup.$fSemigroupLast1 c_sfP0y cs_sfP0z;
        };

Data.Semigroup.$fSemigroupLast_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Semigroup.Last a) -> Data.Semigroup.Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfP0A]
        case ds_sfP0A of {
          GHC.Base.:| a1_sfP0C [Occ=Once] as_sfP0D [Occ=Once] ->
              Data.Semigroup.$fSemigroupLast1 a1_sfP0C as_sfP0D;
        };

Data.Semigroup.$fSemigroupLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Semigroup.Last a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Semigroup.$fSemigroupLast_$c<>
                                         Data.Semigroup.$fSemigroupLast_$csconcat
                                         Data.Semigroup.$fSemigroupLast_$cstimes];

Data.Semigroup.$fFunctorLast1
  :: forall a b. a -> Data.Semigroup.Last b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfP0E ds_sfP0F] a1_sfP0E;

Data.Semigroup.$fFunctorLast2
  :: forall a b. (a -> b) -> Data.Semigroup.Last a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfP0G ds_sfP0H] f_sfP0G ds_sfP0H;

Data.Semigroup.$fFunctorLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorLast2
                                       Data.Semigroup.$fFunctorLast1];

Data.Semigroup.$fFoldableLast_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Last a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfP0I f_sfP0J ds_sfP0K] f_sfP0J ds_sfP0K;

Data.Semigroup.$fFoldableLast4
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.Last m -> Data.Semigroup.Last m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfP0L ds_sfP0M] ds_sfP0M;

Data.Semigroup.$fFoldableLast1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfP0N eta_sfP0O] eta_sfP0O;

Data.Semigroup.$fFoldableLast2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfP0P x_sfP0Q] x_sfP0Q;

Data.Semigroup.$fFoldableLast_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Last a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfP0R eta_sfP0S]
        let {
          f_sfP0T [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afyJq -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP0R eta_sfP0S] \u []
                  GHC.Classes.== $dEq_sfP0R eta_sfP0S; } in
        let {
          sat_sfP0V [Occ=OnceT[0]]
            :: Data.Semigroup.Last a_afyJq -> GHC.Types.Bool
          [LclId] =
              [f_sfP0T] \r [ds_sfP0U] f_sfP0T ds_sfP0U;
        } in  sat_sfP0V;

Data.Semigroup.$fFoldableLast_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfP0W z_sfP0X t1_sfP0Y] f_sfP0W z_sfP0X t1_sfP0Y;

Data.Semigroup.$fFoldableLast3
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfP0Z xs_sfP10] xs_sfP10;

Data.Semigroup.$fFoldableLast_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfP11 z0_sfP12 xs_sfP13] f_sfP11 xs_sfP13 z0_sfP12;

Data.Semigroup.$fFoldableLast_$clength
  :: forall a. Data.Semigroup.Last a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfP14] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableLast_$cnull
  :: forall a. Data.Semigroup.Last a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfP15] GHC.Types.False [];

Data.Semigroup.$fFoldableLast_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Last a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfP16] : [eta_sfP16 GHC.Types.[]];

Data.Semigroup.$fFoldableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableLast4
                                             Data.Semigroup.$fFoldableLast_$cfoldMap
                                             Data.Semigroup.$fFoldableLast_$cfoldr'
                                             Data.Semigroup.$fFoldableLast_$cfoldr'
                                             Data.Semigroup.$fFoldableLast_$cfoldl
                                             Data.Semigroup.$fFoldableLast_$cfoldl
                                             Data.Semigroup.$fFoldableLast3
                                             Data.Semigroup.$fFoldableLast3
                                             Data.Semigroup.$fFoldableLast_$ctoList
                                             Data.Semigroup.$fFoldableLast_$cnull
                                             Data.Semigroup.$fFoldableLast_$clength
                                             Data.Semigroup.$fFoldableLast_$celem
                                             Data.Semigroup.$fFoldableLast2
                                             Data.Semigroup.$fFoldableLast2
                                             Data.Semigroup.$fFoldableLast1
                                             Data.Semigroup.$fFoldableLast1];

Data.Semigroup.$fTraversableLast_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.Last a -> f (Data.Semigroup.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfP17 eta_sfP18 eta1_sfP19]
        let {
          sat_sfP1b [Occ=Once] :: f_afyGY b_afyH0
          [LclId] =
              [eta_sfP18 eta1_sfP19] \u [] eta_sfP18 eta1_sfP19;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfP17 of sat_sfP1a {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfP1a Data.Semigroup.$fApplicativeFirst3 sat_sfP1b;
          };

Data.Semigroup.$fTraversableLast_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Last (f a) -> f (Data.Semigroup.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfP1c eta_sfP1d]
        case GHC.Base.$p1Applicative $dApplicative_sfP1c of sat_sfP1e {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfP1e Data.Semigroup.$fApplicativeFirst3 eta_sfP1d;
        };

Data.Semigroup.$fTraversableLast_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.Last a -> m (Data.Semigroup.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfP1f eta_sfP1g eta1_sfP1h]
        let {
          sat_sfP1k [Occ=Once] :: m_afyHo b_afyHq
          [LclId] =
              [eta_sfP1g eta1_sfP1h] \u [] eta_sfP1g eta1_sfP1h;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfP1f of sat_sfP1i {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfP1i of sat_sfP1j {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfP1j Data.Semigroup.$fApplicativeFirst3 sat_sfP1k;
                };
          };

Data.Semigroup.$fTraversableLast_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Last (m a) -> m (Data.Semigroup.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfP1l eta_sfP1m]
        case GHC.Base.$p1Monad $dMonad_sfP1l of sat_sfP1n {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfP1n of sat_sfP1o {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfP1o Data.Semigroup.$fApplicativeFirst3 eta_sfP1m;
              };
        };

Data.Semigroup.$fTraversableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorLast
                                                   Data.Semigroup.$fFoldableLast
                                                   Data.Semigroup.$fTraversableLast_$ctraverse
                                                   Data.Semigroup.$fTraversableLast_$csequenceA
                                                   Data.Semigroup.$fTraversableLast_$cmapM
                                                   Data.Semigroup.$fTraversableLast_$csequence];

Data.Semigroup.$fApplicativeLast_$c<*
  :: forall a b.
     Data.Semigroup.Last a
     -> Data.Semigroup.Last b -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfP1p ds_sfP1q] a1_sfP1p;

Data.Semigroup.$fApplicativeLast_$c*>
  :: forall a b.
     Data.Semigroup.Last a
     -> Data.Semigroup.Last b -> Data.Semigroup.Last b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfP1r a1_sfP1s] a1_sfP1s;

Data.Semigroup.$fApplicativeLast1
  :: forall a b.
     Data.Semigroup.Last (a -> b) -> Data.Semigroup.Last (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfP1t] v_sfP1t;

Data.Semigroup.$fApplicativeLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorLast
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeLast1
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeLast_$c*>
                                           Data.Semigroup.$fApplicativeLast_$c<*];

Data.Semigroup.$fMonadLast_$c>>=
  :: forall a b.
     Data.Semigroup.Last a
     -> (a -> Data.Semigroup.Last b) -> Data.Semigroup.Last b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfP1u f_sfP1v] f_sfP1v ds_sfP1u;

lvl5_rfC6b :: forall a. [GHC.Types.Char] -> Data.Semigroup.Last a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfP1w] GHC.Err.errorWithoutStackTrace eta_sfP1w;

Data.Semigroup.$fMonadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeLast
                                     Data.Semigroup.$fMonadLast_$c>>=
                                     Data.Semigroup.$fApplicativeLast_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl5_rfC6b];

Data.Semigroup.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.WrappedMonoid m
     -> [Data.Semigroup.WrappedMonoid m]
     -> Data.Semigroup.WrappedMonoid m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfP1x ww_sfP1y ww1_sfP1z]
        let {
          go_sfP1A [Occ=LoopBreaker]
            :: Data.Semigroup.WrappedMonoid m_sfBpD
               -> [Data.Semigroup.WrappedMonoid m_sfBpD]
               -> Data.Semigroup.WrappedMonoid m_sfBpD
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfP1x go_sfP1A] \r [b_sfP1B ds1_sfP1C]
                  case ds1_sfP1C of {
                    [] -> b_sfP1B;
                    : c_sfP1E [Occ=Once] cs_sfP1F [Occ=Once] ->
                        let {
                          sat_sfP1G [Occ=Once] :: m_sfBpD
                          [LclId] =
                              [go_sfP1A c_sfP1E cs_sfP1F] \u [] go_sfP1A c_sfP1E cs_sfP1F;
                        } in  GHC.Base.mappend w_sfP1x b_sfP1B sat_sfP1G;
                  };
        } in  go_sfP1A ww_sfP1y ww1_sfP1z;

Data.Semigroup.$fSemigroupWrappedMonoid_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Base.NonEmpty (Data.Semigroup.WrappedMonoid m)
     -> Data.Semigroup.WrappedMonoid m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfP1H w1_sfP1I]
        case w1_sfP1I of {
          GHC.Base.:| ww1_sfP1K [Occ=Once] ww2_sfP1L [Occ=Once] ->
              Data.Semigroup.$w$csconcat3 w_sfP1H ww1_sfP1K ww2_sfP1L;
        };

Data.Semigroup.$fSemigroupWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,U,A)>m] =
    [] \r [$dMonoid_sfP1M]
        let {
          sat_sfP1P [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.WrappedMonoid m_afyEA
               -> Data.Semigroup.WrappedMonoid m_afyEA
          [LclId] =
              [$dMonoid_sfP1M] \r [eta_B1]
                  Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes
                      $dMonoid_sfP1M eta_B1; } in
        let {
          sat_sfP1O [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.WrappedMonoid m_afyEA)
               -> Data.Semigroup.WrappedMonoid m_afyEA
          [LclId] =
              [$dMonoid_sfP1M] \r [eta_B1]
                  Data.Semigroup.$fSemigroupWrappedMonoid_$csconcat
                      $dMonoid_sfP1M eta_B1; } in
        let {
          sat_sfP1N [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyEA
               -> Data.Semigroup.WrappedMonoid m_afyEA
               -> Data.Semigroup.WrappedMonoid m_afyEA
          [LclId] =
              [$dMonoid_sfP1M] \u [] GHC.Base.mappend $dMonoid_sfP1M;
        } in  GHC.Base.C:Semigroup [sat_sfP1N sat_sfP1O sat_sfP1P];
Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes [Occ=LoopBreaker]
  :: forall m.
     GHC.Base.Monoid m =>
     forall b.
     GHC.Real.Integral b =>
     b
     -> Data.Semigroup.WrappedMonoid m -> Data.Semigroup.WrappedMonoid m
[GblId, Arity=2, Str=<L,U(A,A,U,A)><L,U>, Unf=OtherCon []] =
    [] \r [$dMonoid_sfP1Q $dIntegral_sfP1R]
        let {
          sat_sfP1S [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m_afyEA)
          [LclId] =
              [$dMonoid_sfP1Q] \u []
                  Data.Semigroup.$fSemigroupWrappedMonoid $dMonoid_sfP1Q;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_sfP1R sat_sfP1S;

Data.Semigroup.$fMonoidWrappedMonoid_$cmconcat
  :: forall m.
     GHC.Base.Monoid m =>
     [Data.Semigroup.WrappedMonoid m] -> Data.Semigroup.WrappedMonoid m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfP1T eta_sfP1U]
        let {
          z_sfP1V [Occ=OnceL] :: m_afyEb
          [LclId] =
              [$dMonoid_sfP1T] \u [] GHC.Base.mempty $dMonoid_sfP1T; } in
        let {
          go_sfP1W [Occ=LoopBreaker]
            :: [Data.Semigroup.WrappedMonoid m_afyEb]
               -> Data.Semigroup.WrappedMonoid m_afyEb
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_sfP1T z_sfP1V go_sfP1W] \r [ds_sfP1X]
                  case ds_sfP1X of {
                    [] -> z_sfP1V;
                    : y_sfP1Z [Occ=Once] ys_sfP20 [Occ=Once] ->
                        let {
                          sat_sfP21 [Occ=Once] :: m_afyEb
                          [LclId] =
                              [go_sfP1W ys_sfP20] \u [] go_sfP1W ys_sfP20;
                        } in  GHC.Base.mappend $dMonoid_sfP1T y_sfP1Z sat_sfP21;
                  };
        } in  go_sfP1W eta_sfP1U;

Data.Semigroup.$fMonoidWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Base.Monoid (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(A,U,U,A)>m] =
    [] \r [$dMonoid_sfP22]
        let {
          sat_sfP26 [Occ=Once]
            :: [Data.Semigroup.WrappedMonoid m_afyEb]
               -> Data.Semigroup.WrappedMonoid m_afyEb
          [LclId] =
              [$dMonoid_sfP22] \r [eta_B1]
                  Data.Semigroup.$fMonoidWrappedMonoid_$cmconcat
                      $dMonoid_sfP22 eta_B1; } in
        let {
          sat_sfP25 [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyEb
               -> Data.Semigroup.WrappedMonoid m_afyEb
               -> Data.Semigroup.WrappedMonoid m_afyEb
          [LclId] =
              [$dMonoid_sfP22] \u [] GHC.Base.mappend $dMonoid_sfP22; } in
        let {
          sat_sfP24 [Occ=Once] :: Data.Semigroup.WrappedMonoid m_afyEb
          [LclId] =
              [$dMonoid_sfP22] \u [] GHC.Base.mempty $dMonoid_sfP22; } in
        let {
          sat_sfP23 [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m_afyEb)
          [LclId] =
              [$dMonoid_sfP22] \u []
                  Data.Semigroup.$fSemigroupWrappedMonoid $dMonoid_sfP22;
        } in  GHC.Base.C:Monoid [sat_sfP23 sat_sfP24 sat_sfP25 sat_sfP26];

Data.Semigroup.$fFunctorOption1
  :: forall a b. a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sfP27 ds1_sfP28]
        case ds1_sfP28 of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Base.Just [x_sfP27];
        };

Data.Semigroup.$fFunctorOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       Data.Semigroup.$fFunctorOption1];

Data.Semigroup.$fApplicativeOption_$c*>
  :: forall a b.
     Data.Semigroup.Option a
     -> Data.Semigroup.Option b -> Data.Semigroup.Option b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfP2b ds1_sfP2c]
        case ds_sfP2b of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> ds1_sfP2c;
        };

Data.Semigroup.$fApplicativeOption1
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfP2f ds1_sfP2g]
        case ds_sfP2f of wild_sfP2h {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] ->
              case ds1_sfP2g of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just _ [Occ=Dead] -> wild_sfP2h;
              };
        };

Data.Semigroup.$fApplicativeOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorOption
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           Data.Semigroup.$fApplicativeOption_$c*>
                                           Data.Semigroup.$fApplicativeOption1];

Data.Semigroup.$fMonadOption_$c>>=
  :: forall a b.
     Data.Semigroup.Option a
     -> (a -> Data.Semigroup.Option b) -> Data.Semigroup.Option b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfP2l k_sfP2m]
        case ds_sfP2l of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_sfP2o [Occ=Once] -> k_sfP2m a1_sfP2o;
        };

lvl6_rfC6c :: forall a. [GHC.Types.Char] -> Data.Semigroup.Option a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfP2p] GHC.Err.errorWithoutStackTrace eta_sfP2p;

Data.Semigroup.$fMonadOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeOption
                                     Data.Semigroup.$fMonadOption_$c>>=
                                     Data.Semigroup.$fApplicativeOption_$c*>
                                     GHC.Base.Just
                                     lvl6_rfC6c];

Data.Semigroup.$fAlternativeOption_$c<|>
  :: forall a.
     Data.Semigroup.Option a
     -> Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfP2q b_sfP2r]
        case ds_sfP2q of wild_sfP2s {
          GHC.Base.Nothing -> b_sfP2r;
          GHC.Base.Just _ [Occ=Dead] -> wild_sfP2s;
        };

Data.Semigroup.$fAlternativeOption_$csome
  :: forall a. Data.Semigroup.Option a -> Data.Semigroup.Option [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sfP2u]
        let {
          some_v_sfP2v [Occ=LoopBreaker] :: GHC.Base.Maybe [a_afyAE]
          [LclId] =
              [v_sfP2u some_v_sfP2v] \u []
                  case v_sfP2u of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sfP2x [Occ=Once*] ->
                        case some_v_sfP2v of {
                          GHC.Base.Nothing ->
                              let {
                                sat_sfP2z [Occ=Once] :: [a_afyAE]
                                [LclId] =
                                    CCCS :! [x_sfP2x GHC.Types.[]];
                              } in  GHC.Base.Just [sat_sfP2z];
                          GHC.Base.Just ipv_sfP2A [Occ=Once] ->
                              let {
                                sat_sfP2B [Occ=Once] :: [a_afyAE]
                                [LclId] =
                                    CCCS :! [x_sfP2x ipv_sfP2A];
                              } in  GHC.Base.Just [sat_sfP2B];
                        };
                  };
        } in  some_v_sfP2v;

Data.Semigroup.$fAlternativeOption1 :: forall a. GHC.Base.Maybe [a]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [GHC.Types.[]];

Data.Semigroup.$fAlternativeOption_$cmany
  :: forall a. Data.Semigroup.Option a -> Data.Semigroup.Option [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sfP2C]
        let {
          many_v_sfP2D [Occ=LoopBreaker] :: Data.Semigroup.Option [a_afyAM]
          [LclId] =
              [v_sfP2C many_v_sfP2D] \u []
                  case v_sfP2C of {
                    GHC.Base.Nothing -> Data.Semigroup.$fAlternativeOption1;
                    GHC.Base.Just x_sfP2F [Occ=Once] ->
                        case many_v_sfP2D of {
                          GHC.Base.Nothing -> Data.Semigroup.$fAlternativeOption1;
                          GHC.Base.Just y_sfP2H [Occ=Once] ->
                              let {
                                sat_sfP2I [Occ=Once] :: [a_afyAM]
                                [LclId] =
                                    CCCS :! [x_sfP2F y_sfP2H];
                              } in  GHC.Base.Just [sat_sfP2I];
                        };
                  };
        } in  many_v_sfP2D;

Data.Semigroup.$fAlternativeOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Data.Semigroup.$fApplicativeOption
                                           GHC.Base.Nothing
                                           Data.Semigroup.$fAlternativeOption_$c<|>
                                           Data.Semigroup.$fAlternativeOption_$csome
                                           Data.Semigroup.$fAlternativeOption_$cmany];

Data.Semigroup.$fMonadPlusOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Data.Semigroup.$fAlternativeOption
                                         Data.Semigroup.$fMonadOption
                                         GHC.Base.Nothing
                                         Data.Semigroup.$fAlternativeOption_$c<|>];

Data.Semigroup.$fFoldableOption_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Option a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfP2J f_sfP2K ds_sfP2L]
        case ds_sfP2L of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_sfP2J;
          GHC.Base.Just m1_sfP2N [Occ=Once] -> f_sfP2K m1_sfP2N;
        };

Data.Semigroup.$fFoldableOption_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Semigroup.Option m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfP2O ds_sfP2P]
        case ds_sfP2P of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_sfP2O;
          GHC.Base.Just m1_sfP2R [Occ=Once] -> m1_sfP2R;
        };

Data.Semigroup.$fFoldableOption2
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Option a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfP2S ds_sfP2T]
        case ds_sfP2T of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_sfP2S;
          GHC.Base.Just m_sfP2V [Occ=Once] -> m_sfP2V;
        };

lvl7_rfC6d :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Semigroup.$fFoldableOption4 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl7_rfC6d of sat_sfP2W {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfP2W;
        };

Data.Semigroup.$fFoldableOption3
  :: forall a. Data.Semigroup.Option a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfP2X]
        case x_sfP2X of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption4;
          GHC.Base.Just v_sfP2Z [Occ=Once] -> v_sfP2Z;
        };

Data.Semigroup.$fFoldableOption_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sfP30 eta_B1] Data.Semigroup.$fFoldableOption3 eta_B1;

lvl8_rfC6e :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Semigroup.$fFoldableOption6 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl8_rfC6e of sat_sfP31 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfP31;
        };

Data.Semigroup.$fFoldableOption5
  :: forall a. Data.Semigroup.Option a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfP32]
        case x_sfP32 of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption6;
          GHC.Base.Just v_sfP34 [Occ=Once] -> v_sfP34;
        };

Data.Semigroup.$fFoldableOption_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sfP35 eta_B1] Data.Semigroup.$fFoldableOption5 eta_B1;

Data.Semigroup.$fFoldableOption_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Option a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfP36 eta_sfP37]
        let {
          f_sfP38 [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afyyC -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP36 eta_sfP37] \u []
                  GHC.Classes.== $dEq_sfP36 eta_sfP37; } in
        let {
          sat_sfP3c [Occ=Once]
            :: Data.Semigroup.Option a_afyyC -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_sfP38] \r [ds_sfP39]
                  case ds_sfP39 of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just m_sfP3b [Occ=Once] -> f_sfP38 m_sfP3b;
                  };
        } in  sat_sfP3c;

Data.Semigroup.$fFoldableOption7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Semigroup.$fFoldableOption_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfP3d z_sfP3e t1_sfP3f]
        case t1_sfP3f of {
          GHC.Base.Nothing -> z_sfP3e;
          GHC.Base.Just m_sfP3h [Occ=Once] -> f_sfP3d z_sfP3e m_sfP3h;
        };

lvl9_rfC6f :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Semigroup.$fFoldableOption8 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl9_rfC6f of sat_sfP3i {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfP3i;
        };

Data.Semigroup.$fFoldableOption_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sfP3j xs_sfP3k]
        case xs_sfP3k of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption8;
          GHC.Base.Just m_sfP3m [Occ=Once] -> m_sfP3m;
        };

Data.Semigroup.$fFoldableOption_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfP3n z0_sfP3o xs_sfP3p]
        case xs_sfP3p of {
          GHC.Base.Nothing -> z0_sfP3o;
          GHC.Base.Just m_sfP3r [Occ=Once] -> f_sfP3n m_sfP3r z0_sfP3o;
        };

Data.Semigroup.$fFoldableOption_$clength
  :: forall a. Data.Semigroup.Option a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_sfP3s]
        case xs_sfP3s of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption7;
          GHC.Base.Just _ [Occ=Dead] -> Data.Semigroup.$fFoldableFirst3;
        };

lvl10_rfC6g :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Semigroup.$fFoldableOption9 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl10_rfC6g of sat_sfP3v {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfP3v;
        };

Data.Semigroup.$fFoldableOption_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sfP3w xs_sfP3x]
        case xs_sfP3x of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption9;
          GHC.Base.Just m_sfP3z [Occ=Once] -> m_sfP3z;
        };

Data.Semigroup.$fFoldableOption_$cnull
  :: forall a. Data.Semigroup.Option a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [t1_sfP3A]
        case t1_sfP3A of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Semigroup.$fFoldableOption1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Option a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfP3D ds_sfP3E]
        case ds_sfP3E of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_sfP3D;
          GHC.Base.Just m_sfP3G [Occ=Once] -> m_sfP3G;
        };

Data.Semigroup.$fFoldableOption_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Option a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_sfP3H]
        case eta_sfP3H of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just m_sfP3J [Occ=Once] -> : [m_sfP3J GHC.Types.[]];
        };

Data.Semigroup.$fFoldableOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Option
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableOption_$cfold
                                             Data.Semigroup.$fFoldableOption_$cfoldMap
                                             Data.Semigroup.$fFoldableOption_$cfoldr'
                                             Data.Semigroup.$fFoldableOption_$cfoldr'
                                             Data.Semigroup.$fFoldableOption_$cfoldl
                                             Data.Semigroup.$fFoldableOption_$cfoldl
                                             Data.Semigroup.$fFoldableOption_$cfoldr1
                                             Data.Semigroup.$fFoldableOption_$cfoldl1
                                             Data.Semigroup.$fFoldableOption_$ctoList
                                             Data.Semigroup.$fFoldableOption_$cnull
                                             Data.Semigroup.$fFoldableOption_$clength
                                             Data.Semigroup.$fFoldableOption_$celem
                                             Data.Semigroup.$fFoldableOption_$cmaximum
                                             Data.Semigroup.$fFoldableOption_$cminimum
                                             Data.Semigroup.$fFoldableOption2
                                             Data.Semigroup.$fFoldableOption1];

Data.Semigroup.$fTraversableOption_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Option a -> f (Data.Semigroup.Option b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfP3K eta_sfP3L eta1_sfP3M]
        case eta1_sfP3M of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sfP3K GHC.Base.Nothing;
          GHC.Base.Just a1_sfP3O [Occ=Once] ->
              let {
                sat_sfP3Q [Occ=Once] :: f_afyvr b_afyvt
                [LclId] =
                    [eta_sfP3L a1_sfP3O] \u [] eta_sfP3L a1_sfP3O;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfP3K of sat_sfP3P {
                  __DEFAULT -> GHC.Base.fmap sat_sfP3P GHC.Base.Just sat_sfP3Q;
                };
        };

Data.Semigroup.$fTraversableOption_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Option (f a) -> f (Data.Semigroup.Option a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfP3R eta_sfP3S]
        case eta_sfP3S of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sfP3R GHC.Base.Nothing;
          GHC.Base.Just a1_sfP3U [Occ=Once] ->
              case GHC.Base.$p1Applicative $dApplicative_sfP3R of sat_sfP3V {
                __DEFAULT -> GHC.Base.fmap sat_sfP3V GHC.Base.Just a1_sfP3U;
              };
        };

Data.Semigroup.$fTraversableOption_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfP3W eta_sfP3X eta1_sfP3Y]
        case GHC.Base.$p1Monad $dMonad_sfP3W of sat_sfP3Z {
          __DEFAULT ->
              Data.Semigroup.$fTraversableOption_$ctraverse
                  sat_sfP3Z eta_sfP3X eta1_sfP3Y;
        };

Data.Semigroup.$fTraversableOption_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Option (m a) -> m (Data.Semigroup.Option a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfP40 eta_sfP41]
        case eta_sfP41 of {
          GHC.Base.Nothing ->
              case GHC.Base.$p1Monad $dMonad_sfP40 of sat_sfP43 {
                __DEFAULT -> GHC.Base.pure sat_sfP43 GHC.Base.Nothing;
              };
          GHC.Base.Just a1_sfP44 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sfP40 of sat_sfP45 {
                __DEFAULT ->
                    case GHC.Base.$p1Applicative sat_sfP45 of sat_sfP46 {
                      __DEFAULT -> GHC.Base.fmap sat_sfP46 GHC.Base.Just a1_sfP44;
                    };
              };
        };

Data.Semigroup.$fTraversableOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorOption
                                                   Data.Semigroup.$fFoldableOption
                                                   Data.Semigroup.$fTraversableOption_$ctraverse
                                                   Data.Semigroup.$fTraversableOption_$csequenceA
                                                   Data.Semigroup.$fTraversableOption_$cmapM
                                                   Data.Semigroup.$fTraversableOption_$csequence];

lvl11_rfC6h :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: Option, negative multiplier"#;

Data.Semigroup.$fSemigroupOption1
  :: forall a. Data.Semigroup.Option a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl11_rfC6h of sat_sfP47 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfP47;
        };

Data.Semigroup.$fSemigroupOption2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Semigroup.$fSemigroupOption_$cstimes
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,U(U(U(U,U,U,U,U,U,U),U(U,U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfP48 $dIntegral_sfP49 eta_sfP4a eta1_sfP4b]
        case eta1_sfP4b of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_sfP4d [Occ=Once] ->
              case
                  GHC.Real.$p1Integral $dIntegral_sfP49
              of
              $dReal_sfP4e [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      sat_sfP4h [Occ=Once] :: b_afyuS
                      [LclId] =
                          [$dReal_sfP4e] \u []
                              case GHC.Real.$p1Real $dReal_sfP4e of sat_sfP4g {
                                __DEFAULT ->
                                    GHC.Num.fromInteger sat_sfP4g Data.Semigroup.$fSemigroupOption2;
                              };
                    } in 
                      case GHC.Real.$p2Real $dReal_sfP4e of sat_sfP4f {
                        __DEFAULT ->
                            case GHC.Classes.compare sat_sfP4f eta_sfP4a sat_sfP4h of {
                              GHC.Types.LT -> Data.Semigroup.$fSemigroupOption1;
                              GHC.Types.EQ -> GHC.Base.Nothing [];
                              GHC.Types.GT ->
                                  let {
                                    sat_sfP4j [Occ=Once] :: a_afyuq
                                    [LclId] =
                                        [$dSemigroup_sfP48
                                         $dIntegral_sfP49
                                         eta_sfP4a
                                         a1_sfP4d] \u []
                                            GHC.Base.stimes
                                                $dSemigroup_sfP48
                                                $dIntegral_sfP49
                                                eta_sfP4a
                                                a1_sfP4d;
                                  } in  GHC.Base.Just [sat_sfP4j];
                            };
                      };
              };
        };

Data.Semigroup.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     Data.Semigroup.Option a
     -> [Data.Semigroup.Option a] -> Data.Semigroup.Option a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfP4k ww_sfP4l ww1_sfP4m]
        let {
          go_sfP4n [Occ=LoopBreaker]
            :: Data.Semigroup.Option a_sfBqa
               -> [Data.Semigroup.Option a_sfBqa] -> Data.Semigroup.Option a_sfBqa
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfP4k go_sfP4n] \r [b_sfP4o ds1_sfP4p]
                  case ds1_sfP4p of {
                    [] -> b_sfP4o;
                    : c_sfP4r [Occ=Once*] cs_sfP4s [Occ=Once*] ->
                        case b_sfP4o of wild_sfP4t {
                          GHC.Base.Nothing -> go_sfP4n c_sfP4r cs_sfP4s;
                          GHC.Base.Just ipv_sfP4u [Occ=Once] ->
                              case go_sfP4n c_sfP4r cs_sfP4s of {
                                GHC.Base.Nothing -> wild_sfP4t;
                                GHC.Base.Just ipv1_sfP4w [Occ=Once] ->
                                    let {
                                      sat_sfP4x [Occ=Once] :: a_sfBqa
                                      [LclId] =
                                          [w_sfP4k ipv_sfP4u ipv1_sfP4w] \u []
                                              GHC.Base.<> w_sfP4k ipv_sfP4u ipv1_sfP4w;
                                    } in  GHC.Base.Just [sat_sfP4x];
                              };
                        };
                  };
        } in  go_sfP4n ww_sfP4l ww1_sfP4m;

Data.Semigroup.$fSemigroupOption_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (Data.Semigroup.Option a)
     -> Data.Semigroup.Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfP4y w1_sfP4z]
        case w1_sfP4z of {
          GHC.Base.:| ww1_sfP4B [Occ=Once] ww2_sfP4C [Occ=Once] ->
              Data.Semigroup.$w$csconcat2 w_sfP4y ww1_sfP4B ww2_sfP4C;
        };

Data.Semigroup.$fSemigroupOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_sfP4D]
        let {
          sat_sfP4G [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> Data.Semigroup.Option a_afyuq -> Data.Semigroup.Option a_afyuq
          [LclId] =
              [$dSemigroup_sfP4D] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fSemigroupOption_$cstimes
                      $dSemigroup_sfP4D eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfP4F [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Option a_afyuq)
               -> Data.Semigroup.Option a_afyuq
          [LclId] =
              [$dSemigroup_sfP4D] \r [eta_B1]
                  Data.Semigroup.$fSemigroupOption_$csconcat
                      $dSemigroup_sfP4D eta_B1; } in
        let {
          sat_sfP4E [Occ=Once]
            :: Data.Semigroup.Option a_afyuq
               -> Data.Semigroup.Option a_afyuq -> Data.Semigroup.Option a_afyuq
          [LclId] =
              [$dSemigroup_sfP4D] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_sfP4D eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_sfP4E sat_sfP4F sat_sfP4G];

Data.Semigroup.$fMonoidOption_$cmconcat
  :: forall a.
     GHC.Base.Semigroup a =>
     [Data.Semigroup.Option a] -> Data.Semigroup.Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfP4H eta_sfP4I]
        let {
          go_sfP4J [Occ=LoopBreaker]
            :: [Data.Semigroup.Option a_XfyO3] -> Data.Semigroup.Option a_XfyO3
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_sfP4H go_sfP4J] \r [ds_sfP4K]
                  case ds_sfP4K of {
                    [] -> GHC.Base.Nothing [];
                    : y_sfP4M [Occ=Once] ys_sfP4N [Occ=Once*] ->
                        case y_sfP4M of wild1_sfP4O {
                          GHC.Base.Nothing -> go_sfP4J ys_sfP4N;
                          GHC.Base.Just ipv_sfP4P [Occ=Once] ->
                              case go_sfP4J ys_sfP4N of {
                                GHC.Base.Nothing -> wild1_sfP4O;
                                GHC.Base.Just ipv1_sfP4R [Occ=Once] ->
                                    let {
                                      sat_sfP4S [Occ=Once] :: a_XfyO3
                                      [LclId] =
                                          [$dSemigroup_sfP4H ipv_sfP4P ipv1_sfP4R] \u []
                                              GHC.Base.<> $dSemigroup_sfP4H ipv_sfP4P ipv1_sfP4R;
                                    } in  GHC.Base.Just [sat_sfP4S];
                              };
                        };
                  };
        } in  go_sfP4J eta_sfP4I;

Data.Semigroup.$fMonoidOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Monoid (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_sfP4T]
        let {
          sat_sfP4W [Occ=Once]
            :: [Data.Semigroup.Option a_XfyO1] -> Data.Semigroup.Option a_XfyO1
          [LclId] =
              [$dSemigroup_sfP4T] \r [eta_B1]
                  Data.Semigroup.$fMonoidOption_$cmconcat
                      $dSemigroup_sfP4T eta_B1; } in
        let {
          sat_sfP4V [Occ=Once]
            :: Data.Semigroup.Option a_XfyO1
               -> Data.Semigroup.Option a_XfyO1 -> Data.Semigroup.Option a_XfyO1
          [LclId] =
              [$dSemigroup_sfP4T] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_sfP4T eta_B2 eta_B1; } in
        let {
          sat_sfP4U [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Option a_XfyO1)
          [LclId] =
              [$dSemigroup_sfP4T] \u []
                  Data.Semigroup.$fSemigroupOption $dSemigroup_sfP4T;
        } in 
          GHC.Base.C:Monoid [sat_sfP4U GHC.Base.Nothing sat_sfP4V sat_sfP4W];

Data.Semigroup.$fGeneric1Option1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Option a
     -> GHC.Generics.Rep1 Data.Semigroup.Option a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP4X] ds_sfP4X;

Data.Semigroup.$fGeneric1Option2
  :: forall a. Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfP4Y] x_sfP4Y;

Data.Semigroup.$fGeneric1Option [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Option2
                                            Data.Semigroup.$fGeneric1Option1];

Data.Semigroup.$fGenericOption1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Option a) x
     -> GHC.Generics.Rep (Data.Semigroup.Option a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP4Z] ds_sfP4Z;

Data.Semigroup.$fGenericOption2
  :: forall a x. Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfP50] x1_sfP50;

Data.Semigroup.$fGenericOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Option a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericOption2
                                           Data.Semigroup.$fGenericOption1];

Data.Semigroup.$fDataOption2
  :: forall a. GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfP51] v_sfP51;

Data.Semigroup.$fDataOption_$cgunfold
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfP52]
        let {
          $dData1_sfP53 [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_afyoV)
          [LclId] =
              [$dData_sfP52] \u [] Data.Data.$fDataMaybe $dData_sfP52; } in
        let {
          sat_sfP58 [Occ=OnceT[0]]
            :: (forall b r. Data.Data.Data b => c_afypf (b -> r) -> c_afypf r)
               -> (forall r. r -> c_afypf r)
               -> Data.Data.Constr
               -> c_afypf (Data.Semigroup.Option a_afyoV)
          [LclId] =
              [$dData1_sfP53] \r [k_sfP54 z_sfP55 ds_sfP56]
                  let {
                    sat_sfP57 [Occ=Once]
                      :: c_afypf (GHC.Base.Maybe a_afyoV
                                  -> Data.Semigroup.Option a_afyoV)
                    [LclId] =
                        [z_sfP55] \u [] z_sfP55 Data.Semigroup.$fDataOption2;
                  } in  k_sfP54 $dData1_sfP53 sat_sfP57;
        } in  sat_sfP58;

Data.Semigroup.$fDataOption_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Option a
     -> c (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfP59]
        let {
          $dData1_sfP5a [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_afyoV)
          [LclId] =
              [$dData_sfP59] \u [] Data.Data.$fDataMaybe $dData_sfP59; } in
        let {
          sat_sfP5f [Occ=OnceT[0]]
            :: (forall d b.
                Data.Data.Data d =>
                c_afyp4 (d -> b) -> d -> c_afyp4 b)
               -> (forall g. g -> c_afyp4 g)
               -> Data.Semigroup.Option a_afyoV
               -> c_afyp4 (Data.Semigroup.Option a_afyoV)
          [LclId] =
              [$dData1_sfP5a] \r [k_sfP5b z_sfP5c ds_sfP5d]
                  let {
                    sat_sfP5e [Occ=Once]
                      :: c_afyp4 (GHC.Base.Maybe a_afyoV
                                  -> Data.Semigroup.Option a_afyoV)
                    [LclId] =
                        [z_sfP5c] \u [] z_sfP5c Data.Semigroup.$fDataOption2;
                  } in  k_sfP5b $dData1_sfP5a sat_sfP5e ds_sfP5d;
        } in  sat_sfP5f;

Data.Semigroup.$fDataOption6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Option"#;

Data.Semigroup.$fDataOption9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataOption6;

Data.Semigroup.$fReadOption_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataOption9];

Data.Semigroup.$fReadFirst8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Data.Semigroup.$fReadFirst7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadFirst8;

Data.Semigroup.$fReadFirst_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.$fReadFirst7];

Data.Semigroup.$fReadOption3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getOption"#;

Data.Semigroup.$fReadOption2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadOption3;

Data.Semigroup.$fReadArg2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Semigroup.$fReadFirst4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Data.Semigroup.$fReadFirst3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadFirst4;

Data.Semigroup.$fReadFirst2 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.$fReadFirst3];

Data.Semigroup.$fReadOption1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Option a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfP5g eta_sfP5h eta1_sfP5i]
        let {
          ds_sfP5j [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (GHC.Base.Maybe a_afyo6 -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
              [$dRead_sfP5g] \r [ds1_sfP5k eta2_sfP5l]
                  GHC.Read.$fReadMaybe1
                      $dRead_sfP5g
                      Text.ParserCombinators.ReadPrec.minPrec
                      eta2_sfP5l; } in
        let {
          sat_sfP5F [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Option a_afyo6)
          [LclId] =
              [ds_sfP5j] \r [c_sfP5m eta2_sfP5n]
                  case c_sfP5m of {
                    GHC.Types.I# x_sfP5p [Occ=Once] ->
                        case <=# [x_sfP5p 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfP5C [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                [LclId] =
                                    [ds_sfP5j eta2_sfP5n] \r [a1_sfP5r]
                                        let {
                                          sat_sfP5z [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                          [LclId] =
                                              [ds_sfP5j eta2_sfP5n] \r [a2_sfP5s]
                                                  let {
                                                    sat_sfP5y [Occ=Once]
                                                      :: GHC.Base.Maybe a_afyo6
                                                         -> Text.ParserCombinators.ReadP.P b1_i815E
                                                    [LclId] =
                                                        [eta2_sfP5n] \r [a3_sfP5t]
                                                            let {
                                                              sat_sfP5v [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b1_i815E
                                                              [LclId] =
                                                                  [eta2_sfP5n
                                                                   a3_sfP5t] \r [a4_sfP5u]
                                                                      eta2_sfP5n a3_sfP5t;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfP5v
                                                              of
                                                              { Unit# ww1_sfP5x [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfP5x];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadOption2
                                                        ds_sfP5j
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfP5y;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfP5z
                                          of
                                          { Unit# ww1_sfP5B [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfP5B];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadOption_lexeme sat_sfP5C
                                of
                                { Unit# ww1_sfP5E [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfP5E];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfP5F eta_sfP5h eta1_sfP5i;

Data.Semigroup.$fReadOption_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Option a)
[GblId, Arity=2, Str=<L,U(A,A,C(C1(U)),A)><L,U>, Unf=OtherCon []] =
    [] \r [$dRead_sfP5G n_sfP5H]
        let {
          sat_sfP5I [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Option a_XfyIB)
          [LclId] =
              [$dRead_sfP5G n_sfP5H] \u []
                  Data.Semigroup.$fReadOption1
                      $dRead_sfP5G
                      n_sfP5H
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfP5I;

Data.Semigroup.$fReadOption_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Option a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP5J]
        let {
          sat_sfP5K [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Option a_XfyIz)
          [LclId] =
              [$dRead_sfP5J] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadOption1 $dRead_sfP5J eta_B2 eta_B1;
        } in  GHC.Read.list sat_sfP5K;

Data.Semigroup.$fReadOption_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Option a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP5L]
        let {
          sat_sfP5N [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Option a_XfyIA]
          [LclId] =
              [$dRead_sfP5L] \u []
                  let {
                    sat_sfP5M [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Option a_XfyIA)
                    [LclId] =
                        [$dRead_sfP5L] \r [eta_B2 eta_B1]
                            Data.Semigroup.$fReadOption1 $dRead_sfP5L eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sfP5M
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfP5N;

Data.Semigroup.$fReadOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sfP5O]
        let {
          sat_sfP5S [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Option a_XfyIy]
          [LclId] =
              [$dRead_sfP5O] \u []
                  Data.Semigroup.$fReadOption_$creadListPrec $dRead_sfP5O; } in
        let {
          sat_sfP5R [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Option a_XfyIy)
          [LclId] =
              [$dRead_sfP5O] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadOption1 $dRead_sfP5O eta_B2 eta_B1; } in
        let {
          sat_sfP5Q [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Option a_XfyIy]
          [LclId] =
              [$dRead_sfP5O] \u []
                  Data.Semigroup.$fReadOption_$creadList $dRead_sfP5O; } in
        let {
          sat_sfP5P [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Option a_XfyIy)
          [LclId] =
              [$dRead_sfP5O] \r [eta_B1]
                  Data.Semigroup.$fReadOption_$creadsPrec $dRead_sfP5O eta_B1;
        } in  GHC.Read.C:Read [sat_sfP5P sat_sfP5Q sat_sfP5R sat_sfP5S];

Data.Semigroup.$fShowOption2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Option {"#;

Data.Semigroup.$fShowOption1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getOption = "#;

Data.Semigroup.$w$cshowsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Option a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfP5T ww_sfP5U w1_sfP5V]
        let {
          f_sfP5W [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfP5T w1_sfP5V] \u []
                  GHC.Show.$fShowMaybe_$cshowsPrec
                      w_sfP5T Data.Semigroup.$fFoldableOption7 w1_sfP5V;
        } in 
          case >=# [ww_sfP5U 11#] of {
            __DEFAULT ->
                let {
                  sat_sfP62 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfP5W] \r [x_sfP5Y]
                          let {
                            sat_sfP61 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfP5W x_sfP5Y] \u []
                                    let {
                                      sat_sfP60 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfP5W x_sfP5Y] \u []
                                              let {
                                                sat_sfP5Z [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfP5Y] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfP5Y;
                                              } in  f_sfP5W sat_sfP5Z;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowOption1 sat_sfP60;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowOption2 sat_sfP61;
                } in  sat_sfP62;
            1# ->
                let {
                  sat_sfP69 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfP5W] \r [x_sfP63]
                          let {
                            sat_sfP68 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfP5W x_sfP63] \u []
                                    let {
                                      sat_sfP67 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfP5W x_sfP63] \u []
                                              let {
                                                sat_sfP66 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfP5W x_sfP63] \u []
                                                        let {
                                                          sat_sfP65 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfP63] \u []
                                                                  let {
                                                                    sat_sfP64 [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfP63];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfP64;
                                                        } in  f_sfP5W sat_sfP65;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowOption1 sat_sfP66;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowOption2 sat_sfP67;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfP68];
                } in  sat_sfP69;
          };

Data.Semigroup.$fShowOption_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Option a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfP6a w1_sfP6b w2_sfP6c]
        case w1_sfP6b of {
          GHC.Types.I# ww1_sfP6e [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec5 w_sfP6a ww1_sfP6e w2_sfP6c;
        };

Data.Semigroup.$fShowOption3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++ GHC.Show.$fShowMaybe4 Data.Semigroup.$fReadFirst3;

Data.Semigroup.$fShowOption_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Option a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfP6f x_sfP6g]
        let {
          sat_sfP6l [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfP6f x_sfP6g] \u []
                  let {
                    sat_sfP6k [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfP6f x_sfP6g] \u []
                            case x_sfP6g of {
                              GHC.Base.Nothing -> Data.Semigroup.$fShowOption3;
                              GHC.Base.Just b1_sfP6i [Occ=Once] ->
                                  let {
                                    sat_sfP6j [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [$dShow_sfP6f b1_sfP6i] \s []
                                            GHC.Show.showsPrec
                                                $dShow_sfP6f
                                                GHC.Show.appPrec1
                                                b1_sfP6i
                                                Data.Semigroup.$fReadFirst3;
                                  } in  GHC.Base.++ GHC.Show.$fShowMaybe1 sat_sfP6j;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowOption1 sat_sfP6k;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowOption2 sat_sfP6l;

Data.Semigroup.$fShowOption_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Option a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfP6m ls_sfP6n s_sfP6o]
        let {
          sat_sfP6q [Occ=Once]
            :: Data.Semigroup.Option a_afynB -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP6m] \r [w_sfP6p]
                  Data.Semigroup.$w$cshowsPrec5 $dShow_sfP6m 0# w_sfP6p;
        } in  GHC.Show.showList__ sat_sfP6q ls_sfP6n s_sfP6o;

Data.Semigroup.$fShowOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfP6r]
        let {
          sat_sfP6u [Occ=Once]
            :: [Data.Semigroup.Option a_afynB] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP6r] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowOption_$cshowList
                      $dShow_sfP6r eta_B2 eta_B1; } in
        let {
          sat_sfP6t [Occ=Once]
            :: Data.Semigroup.Option a_afynB -> GHC.Base.String
          [LclId] =
              [$dShow_sfP6r] \r [eta_B1]
                  Data.Semigroup.$fShowOption_$cshow $dShow_sfP6r eta_B1; } in
        let {
          sat_sfP6s [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Option a_afynB -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP6r] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowOption_$cshowsPrec $dShow_sfP6r eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfP6s sat_sfP6t sat_sfP6u];

Data.Semigroup.$fEqOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sfP6v]
        let {
          sat_sfP6x [Occ=Once]
            :: Data.Semigroup.Option a_afyle
               -> Data.Semigroup.Option a_afyle -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP6v] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_sfP6v eta_B2 eta_B1; } in
        let {
          sat_sfP6w [Occ=Once]
            :: Data.Semigroup.Option a_afyle
               -> Data.Semigroup.Option a_afyle -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP6v] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_sfP6v eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sfP6w sat_sfP6x];

Data.Semigroup.$fOrdOption_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfP6y]
        let {
          sat_sfP6z [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_XfyGz
          [LclId] =
              [$dOrd_sfP6y] \u [] GHC.Classes.$p1Ord $dOrd_sfP6y;
        } in  Data.Semigroup.$fEqOption sat_sfP6z;

Data.Semigroup.$fOrdOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Option a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_sfP6A]
        let {
          sat_sfP6K [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> Data.Semigroup.Option a_XfyGA
          [LclId] =
              [$dOrd_sfP6A] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_sfP6A eta_B2 eta_B1; } in
        let {
          sat_sfP6J [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> Data.Semigroup.Option a_XfyGA
          [LclId] =
              [$dOrd_sfP6A] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_sfP6A eta_B2 eta_B1; } in
        let {
          sat_sfP6I [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP6A] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_sfP6A eta_B2 eta_B1; } in
        let {
          sat_sfP6H [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP6A] \r [a1_sfP6F b_sfP6G]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_sfP6A b_sfP6G a1_sfP6F; } in
        let {
          sat_sfP6E [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP6A] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_sfP6A eta_B2 eta_B1; } in
        let {
          sat_sfP6D [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP6A] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_sfP6A eta_B2 eta_B1; } in
        let {
          sat_sfP6C [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfP6A] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_sfP6A eta_B2 eta_B1; } in
        let {
          sat_sfP6B [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Option a_XfyGA)
          [LclId] =
              [$dOrd_sfP6A] \u [] Data.Semigroup.$fOrdOption_$cp1Ord $dOrd_sfP6A;
        } in 
          GHC.Classes.C:Ord [sat_sfP6B
                             sat_sfP6C
                             sat_sfP6D
                             sat_sfP6E
                             sat_sfP6H
                             sat_sfP6I
                             sat_sfP6J
                             sat_sfP6K];

Data.Semigroup.$fGeneric1WrappedMonoid1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.WrappedMonoid a
     -> GHC.Generics.Rep1 Data.Semigroup.WrappedMonoid a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP6L] ds_sfP6L;

Data.Semigroup.$fGeneric1WrappedMonoid2
  :: forall a.
     Data.Semigroup.WrappedMonoid a -> Data.Semigroup.WrappedMonoid a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfP6M] x_sfP6M;

Data.Semigroup.$fGeneric1WrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.WrappedMonoid
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1WrappedMonoid2
                                            Data.Semigroup.$fGeneric1WrappedMonoid1];

Data.Semigroup.$fGenericWrappedMonoid1
  :: forall m x.
     GHC.Generics.Rep (Data.Semigroup.WrappedMonoid m) x
     -> GHC.Generics.Rep (Data.Semigroup.WrappedMonoid m) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP6N] ds_sfP6N;

Data.Semigroup.$fGenericWrappedMonoid2
  :: forall m x.
     Data.Semigroup.WrappedMonoid m -> Data.Semigroup.WrappedMonoid m
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfP6O] x1_sfP6O;

Data.Semigroup.$fGenericWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. GHC.Generics.Generic (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericWrappedMonoid2
                                           Data.Semigroup.$fGenericWrappedMonoid1];

Data.Semigroup.$fDataWrappedMonoid_$cgfoldl
  :: forall m.
     Data.Data.Data m =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.WrappedMonoid m
     -> c (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfP6P k_sfP6Q z_sfP6R ds_sfP6S]
        let {
          sat_sfP6T [Occ=Once]
            :: c_afygk (m_afygb -> Data.Semigroup.WrappedMonoid m_afygb)
          [LclId] =
              [z_sfP6R] \u [] z_sfP6R Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfP6Q $dData_sfP6P sat_sfP6T ds_sfP6S;

Data.Semigroup.$fReadWrappedMonoid5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrapMonoid"#;

Data.Semigroup.$fReadWrappedMonoid4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.$fReadWrappedMonoid5;

Data.Semigroup.$fReadWrappedMonoid_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fReadWrappedMonoid4];

Data.Semigroup.$fReadWrappedMonoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "unwrapMonoid"#;

Data.Semigroup.$fReadWrappedMonoid2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.$fReadWrappedMonoid3;

Data.Semigroup.$fReadWrappedMonoid1
  :: forall m.
     GHC.Read.Read m =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.WrappedMonoid m
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP6U]
        let {
          lvl33_sfP6V [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP m_afyfm
          [LclId] =
              [$dRead_sfP6U] \u []
                  GHC.Read.readPrec
                      $dRead_sfP6U Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfP6W [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP m_afyfm
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfP6V] \r [ds1_sfP6X] lvl33_sfP6V; } in
        let {
          sat_sfP7h [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.WrappedMonoid m_afyfm)
          [LclId] =
              [ds_sfP6W] \r [c_sfP6Y eta_sfP6Z]
                  case c_sfP6Y of {
                    GHC.Types.I# x_sfP71 [Occ=Once] ->
                        case <=# [x_sfP71 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfP7e [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfP6W eta_sfP6Z] \r [a1_sfP73]
                                        let {
                                          sat_sfP7b [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfP6W eta_sfP6Z] \r [a2_sfP74]
                                                  let {
                                                    sat_sfP7a [Occ=Once]
                                                      :: m_afyfm
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfP6Z] \r [a3_sfP75]
                                                            let {
                                                              sat_sfP77 [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfP6Z a3_sfP75] \r [a4_sfP76]
                                                                      eta_sfP6Z a3_sfP75;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfP77
                                                              of
                                                              { Unit# ww1_sfP79 [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfP79];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadWrappedMonoid2
                                                        ds_sfP6W
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfP7a;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfP7b
                                          of
                                          { Unit# ww1_sfP7d [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfP7d];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadWrappedMonoid_lexeme sat_sfP7e
                                of
                                { Unit# ww1_sfP7g [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfP7g];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfP7h;

Data.Semigroup.$fReadWrappedMonoid_$creadsPrec
  :: forall m.
     GHC.Read.Read m =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.WrappedMonoid m)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP7i]
        let {
          ds_sfP7j [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.WrappedMonoid m_XfyAE
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfP7i] \u []
                  Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfP7i; } in
        let {
          sat_sfP7m [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.WrappedMonoid m_XfyAE)
          [LclId] =
              [ds_sfP7j] \r [n_sfP7k]
                  let {
                    sat_sfP7l [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.WrappedMonoid m_XfyAE)
                    [LclId] =
                        [ds_sfP7j n_sfP7k] \u []
                            ds_sfP7j
                                n_sfP7k Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfP7l;
        } in  sat_sfP7m;

Data.Semigroup.$fReadWrappedMonoid_$creadListPrec
  :: forall m.
     GHC.Read.Read m =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.WrappedMonoid m]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP7n]
        let {
          sat_sfP7o [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.WrappedMonoid m_XfyAC)
          [LclId] =
              [$dRead_sfP7n] \s []
                  Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfP7n;
        } in  GHC.Read.list sat_sfP7o;

Data.Semigroup.$fReadWrappedMonoid_$creadList
  :: forall m.
     GHC.Read.Read m =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.WrappedMonoid m]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP7p]
        let {
          sat_sfP7r [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.WrappedMonoid m_XfyAD]
          [LclId] =
              [$dRead_sfP7p] \u []
                  let {
                    sat_sfP7q [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.WrappedMonoid m_XfyAD)
                    [LclId] =
                        [$dRead_sfP7p] \s []
                            Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfP7p;
                  } in 
                    GHC.Read.list
                        sat_sfP7q
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfP7r;

Data.Semigroup.$fReadWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Read.Read m =>
     GHC.Read.Read (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfP7s]
        let {
          sat_sfP7w [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.WrappedMonoid m_XfyAB]
          [LclId] =
              [$dRead_sfP7s] \u []
                  Data.Semigroup.$fReadWrappedMonoid_$creadListPrec
                      $dRead_sfP7s; } in
        let {
          sat_sfP7v [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.WrappedMonoid m_XfyAB)
          [LclId] =
              [$dRead_sfP7s] \u []
                  Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfP7s; } in
        let {
          sat_sfP7u [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.WrappedMonoid m_XfyAB]
          [LclId] =
              [$dRead_sfP7s] \u []
                  Data.Semigroup.$fReadWrappedMonoid_$creadList $dRead_sfP7s; } in
        let {
          sat_sfP7t [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.WrappedMonoid m_XfyAB)
          [LclId] =
              [$dRead_sfP7s] \u []
                  Data.Semigroup.$fReadWrappedMonoid_$creadsPrec $dRead_sfP7s;
        } in  GHC.Read.C:Read [sat_sfP7t sat_sfP7u sat_sfP7v sat_sfP7w];

Data.Semigroup.$fShowWrappedMonoid2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrapMonoid {"#;

Data.Semigroup.$fShowWrappedMonoid1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "unwrapMonoid = "#;

Data.Semigroup.$w$cshowsPrec6 [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Show.Show m =>
     GHC.Prim.Int# -> Data.Semigroup.WrappedMonoid m -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfP7x ww_sfP7y w1_sfP7z]
        let {
          f_sfP7A [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfP7x w1_sfP7z] \u []
                  GHC.Show.showsPrec
                      w_sfP7x Data.Semigroup.$fFoldableOption7 w1_sfP7z;
        } in 
          case >=# [ww_sfP7y 11#] of {
            __DEFAULT ->
                let {
                  sat_sfP7G [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfP7A] \r [x_sfP7C]
                          let {
                            sat_sfP7F [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfP7A x_sfP7C] \u []
                                    let {
                                      sat_sfP7E [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfP7A x_sfP7C] \u []
                                              let {
                                                sat_sfP7D [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfP7C] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfP7C;
                                              } in  f_sfP7A sat_sfP7D;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowWrappedMonoid1 sat_sfP7E;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowWrappedMonoid2 sat_sfP7F;
                } in  sat_sfP7G;
            1# ->
                let {
                  sat_sfP7N [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfP7A] \r [x_sfP7H]
                          let {
                            sat_sfP7M [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfP7A x_sfP7H] \u []
                                    let {
                                      sat_sfP7L [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfP7A x_sfP7H] \u []
                                              let {
                                                sat_sfP7K [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfP7A x_sfP7H] \u []
                                                        let {
                                                          sat_sfP7J [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfP7H] \u []
                                                                  let {
                                                                    sat_sfP7I [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfP7H];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfP7I;
                                                        } in  f_sfP7A sat_sfP7J;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowWrappedMonoid1 sat_sfP7K;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowWrappedMonoid2 sat_sfP7L;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfP7M];
                } in  sat_sfP7N;
          };

Data.Semigroup.$fShowWrappedMonoid_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Show.Show m =>
     GHC.Types.Int -> Data.Semigroup.WrappedMonoid m -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfP7O w1_sfP7P w2_sfP7Q]
        case w1_sfP7P of {
          GHC.Types.I# ww1_sfP7S [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec6 w_sfP7O ww1_sfP7S w2_sfP7Q;
        };

Data.Semigroup.$fShowWrappedMonoid_$cshow
  :: forall m.
     GHC.Show.Show m =>
     Data.Semigroup.WrappedMonoid m -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfP7T x_sfP7U]
        let {
          sat_sfP7W [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfP7T x_sfP7U] \u []
                  let {
                    sat_sfP7V [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfP7T x_sfP7U] \u []
                            GHC.Show.showsPrec
                                $dShow_sfP7T
                                Data.Semigroup.$fFoldableOption7
                                x_sfP7U
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowWrappedMonoid1 sat_sfP7V;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowWrappedMonoid2 sat_sfP7W;

Data.Semigroup.$fShowWrappedMonoid_$cshowList
  :: forall m.
     GHC.Show.Show m =>
     [Data.Semigroup.WrappedMonoid m] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfP7X ls_sfP7Y s_sfP7Z]
        let {
          sat_sfP81 [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyeR -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP7X] \r [w_sfP80]
                  Data.Semigroup.$w$cshowsPrec6 $dShow_sfP7X 0# w_sfP80;
        } in  GHC.Show.showList__ sat_sfP81 ls_sfP7Y s_sfP7Z;

Data.Semigroup.$fShowWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Show.Show m =>
     GHC.Show.Show (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfP82]
        let {
          sat_sfP85 [Occ=Once]
            :: [Data.Semigroup.WrappedMonoid m_afyeR] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP82] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowWrappedMonoid_$cshowList
                      $dShow_sfP82 eta_B2 eta_B1; } in
        let {
          sat_sfP84 [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyeR -> GHC.Base.String
          [LclId] =
              [$dShow_sfP82] \r [eta_B1]
                  Data.Semigroup.$fShowWrappedMonoid_$cshow $dShow_sfP82 eta_B1; } in
        let {
          sat_sfP83 [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.WrappedMonoid m_afyeR -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP82] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowWrappedMonoid_$cshowsPrec
                      $dShow_sfP82 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfP83 sat_sfP84 sat_sfP85];

Data.Semigroup.$fEqWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Classes.Eq m =>
     GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfP86]
        let {
          sat_sfP88 [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afycu
               -> Data.Semigroup.WrappedMonoid m_afycu -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP86] \u [] GHC.Classes./= $dEq_sfP86; } in
        let {
          sat_sfP87 [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afycu
               -> Data.Semigroup.WrappedMonoid m_afycu -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP86] \u [] GHC.Classes.== $dEq_sfP86;
        } in  GHC.Classes.C:Eq [sat_sfP87 sat_sfP88];

Data.Semigroup.$fOrdWrappedMonoid_$cp1Ord
  :: forall m.
     GHC.Classes.Ord m =>
     GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfP89]
        let {
          sat_sfP8a [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq m_afyd2
          [LclId] =
              [$dOrd_sfP89] \u [] GHC.Classes.$p1Ord $dOrd_sfP89;
        } in  Data.Semigroup.$fEqWrappedMonoid sat_sfP8a;

Data.Semigroup.$fOrdWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Classes.Ord m =>
     GHC.Classes.Ord (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfP8b]
        let {
          sat_sfP8j [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.min $dOrd_sfP8b; } in
        let {
          sat_sfP8i [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.max $dOrd_sfP8b; } in
        let {
          sat_sfP8h [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.>= $dOrd_sfP8b; } in
        let {
          sat_sfP8g [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.> $dOrd_sfP8b; } in
        let {
          sat_sfP8f [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.<= $dOrd_sfP8b; } in
        let {
          sat_sfP8e [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.< $dOrd_sfP8b; } in
        let {
          sat_sfP8d [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.compare $dOrd_sfP8b; } in
        let {
          sat_sfP8c [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m_afyd2)
          [LclId] =
              [$dOrd_sfP8b] \u []
                  Data.Semigroup.$fOrdWrappedMonoid_$cp1Ord $dOrd_sfP8b;
        } in 
          GHC.Classes.C:Ord [sat_sfP8c
                             sat_sfP8d
                             sat_sfP8e
                             sat_sfP8f
                             sat_sfP8g
                             sat_sfP8h
                             sat_sfP8i
                             sat_sfP8j];

Data.Semigroup.$fBoundedWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Enum.Bounded m =>
     GHC.Enum.Bounded (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfP8k]
        let {
          sat_sfP8m [Occ=Once] :: Data.Semigroup.WrappedMonoid m_afycc
          [LclId] =
              [$dBounded_sfP8k] \u [] GHC.Enum.maxBound $dBounded_sfP8k; } in
        let {
          sat_sfP8l [Occ=Once] :: Data.Semigroup.WrappedMonoid m_afycc
          [LclId] =
              [$dBounded_sfP8k] \u [] GHC.Enum.minBound $dBounded_sfP8k;
        } in  GHC.Enum.C:Bounded [sat_sfP8l sat_sfP8m];

Data.Semigroup.$fGeneric1Last1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Last a
     -> GHC.Generics.Rep1 Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP8n] ds_sfP8n;

Data.Semigroup.$fGeneric1Last2
  :: forall a. Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfP8o] x_sfP8o;

Data.Semigroup.$fGeneric1Last [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Last2
                                            Data.Semigroup.$fGeneric1Last1];

Data.Semigroup.$fGenericLast1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Last a) x
     -> GHC.Generics.Rep (Data.Semigroup.Last a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP8p] ds_sfP8p;

Data.Semigroup.$fGenericLast2
  :: forall a x. Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfP8q] x1_sfP8q;

Data.Semigroup.$fGenericLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Last a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericLast2
                                           Data.Semigroup.$fGenericLast1];

Data.Semigroup.$fDataLast_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Last a
     -> c (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfP8r k_sfP8s z_sfP8t ds_sfP8u]
        let {
          sat_sfP8v [Occ=Once]
            :: c_afy7i (a_afy79 -> Data.Semigroup.Last a_afy79)
          [LclId] =
              [z_sfP8t] \u [] z_sfP8t Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfP8s $dData_sfP8r sat_sfP8v ds_sfP8u;

Data.Semigroup.$fDataLast4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last"#;

Data.Semigroup.$fDataLast7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataLast4;

Data.Semigroup.$fReadLast_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataLast7];

Data.Semigroup.$fReadLast3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast"#;

Data.Semigroup.$fReadLast2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadLast3;

Data.Semigroup.$fReadLast1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Last a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP8w]
        let {
          lvl33_sfP8x [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afy6k
          [LclId] =
              [$dRead_sfP8w] \u []
                  GHC.Read.readPrec
                      $dRead_sfP8w Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfP8y [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afy6k
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfP8x] \r [ds1_sfP8z] lvl33_sfP8x; } in
        let {
          sat_sfP8T [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Last a_afy6k)
          [LclId] =
              [ds_sfP8y] \r [c_sfP8A eta_sfP8B]
                  case c_sfP8A of {
                    GHC.Types.I# x_sfP8D [Occ=Once] ->
                        case <=# [x_sfP8D 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfP8Q [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfP8y eta_sfP8B] \r [a1_sfP8F]
                                        let {
                                          sat_sfP8N [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfP8y eta_sfP8B] \r [a2_sfP8G]
                                                  let {
                                                    sat_sfP8M [Occ=Once]
                                                      :: a_afy6k
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfP8B] \r [a3_sfP8H]
                                                            let {
                                                              sat_sfP8J [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfP8B a3_sfP8H] \r [a4_sfP8I]
                                                                      eta_sfP8B a3_sfP8H;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfP8J
                                                              of
                                                              { Unit# ww1_sfP8L [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfP8L];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadLast2
                                                        ds_sfP8y
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfP8M;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfP8N
                                          of
                                          { Unit# ww1_sfP8P [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfP8P];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadLast_lexeme sat_sfP8Q
                                of
                                { Unit# ww1_sfP8S [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfP8S];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfP8T;

Data.Semigroup.$fReadLast_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Last a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP8U]
        let {
          ds_sfP8V [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Last a_Xfysp -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfP8U] \u [] Data.Semigroup.$fReadLast1 $dRead_sfP8U; } in
        let {
          sat_sfP8Y [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Last a_Xfysp)
          [LclId] =
              [ds_sfP8V] \r [n_sfP8W]
                  let {
                    sat_sfP8X [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Last a_Xfysp)
                    [LclId] =
                        [ds_sfP8V n_sfP8W] \u []
                            ds_sfP8V
                                n_sfP8W Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfP8X;
        } in  sat_sfP8Y;

Data.Semigroup.$fReadLast_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Last a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP8Z]
        let {
          sat_sfP90 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Last a_Xfysn)
          [LclId] =
              [$dRead_sfP8Z] \s [] Data.Semigroup.$fReadLast1 $dRead_sfP8Z;
        } in  GHC.Read.list sat_sfP90;

Data.Semigroup.$fReadLast_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Last a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP91]
        let {
          sat_sfP93 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Last a_Xfyso]
          [LclId] =
              [$dRead_sfP91] \u []
                  let {
                    sat_sfP92 [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Last a_Xfyso)
                    [LclId] =
                        [$dRead_sfP91] \s [] Data.Semigroup.$fReadLast1 $dRead_sfP91;
                  } in 
                    GHC.Read.list
                        sat_sfP92
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfP93;

Data.Semigroup.$fReadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfP94]
        let {
          sat_sfP98 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Last a_Xfysm]
          [LclId] =
              [$dRead_sfP94] \u []
                  Data.Semigroup.$fReadLast_$creadListPrec $dRead_sfP94; } in
        let {
          sat_sfP97 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Last a_Xfysm)
          [LclId] =
              [$dRead_sfP94] \u [] Data.Semigroup.$fReadLast1 $dRead_sfP94; } in
        let {
          sat_sfP96 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Last a_Xfysm]
          [LclId] =
              [$dRead_sfP94] \u []
                  Data.Semigroup.$fReadLast_$creadList $dRead_sfP94; } in
        let {
          sat_sfP95 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Last a_Xfysm)
          [LclId] =
              [$dRead_sfP94] \u []
                  Data.Semigroup.$fReadLast_$creadsPrec $dRead_sfP94;
        } in  GHC.Read.C:Read [sat_sfP95 sat_sfP96 sat_sfP97 sat_sfP98];

Data.Semigroup.$fShowLast2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last {"#;

Data.Semigroup.$fShowLast1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast = "#;

Data.Semigroup.$w$cshowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfP99 ww_sfP9a w1_sfP9b]
        let {
          f_sfP9c [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfP99 w1_sfP9b] \u []
                  GHC.Show.showsPrec
                      w_sfP99 Data.Semigroup.$fFoldableOption7 w1_sfP9b;
        } in 
          case >=# [ww_sfP9a 11#] of {
            __DEFAULT ->
                let {
                  sat_sfP9i [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfP9c] \r [x_sfP9e]
                          let {
                            sat_sfP9h [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfP9c x_sfP9e] \u []
                                    let {
                                      sat_sfP9g [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfP9c x_sfP9e] \u []
                                              let {
                                                sat_sfP9f [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfP9e] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfP9e;
                                              } in  f_sfP9c sat_sfP9f;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowLast1 sat_sfP9g;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowLast2 sat_sfP9h;
                } in  sat_sfP9i;
            1# ->
                let {
                  sat_sfP9p [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfP9c] \r [x_sfP9j]
                          let {
                            sat_sfP9o [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfP9c x_sfP9j] \u []
                                    let {
                                      sat_sfP9n [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfP9c x_sfP9j] \u []
                                              let {
                                                sat_sfP9m [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfP9c x_sfP9j] \u []
                                                        let {
                                                          sat_sfP9l [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfP9j] \u []
                                                                  let {
                                                                    sat_sfP9k [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfP9j];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfP9k;
                                                        } in  f_sfP9c sat_sfP9l;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowLast1 sat_sfP9m;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowLast2 sat_sfP9n;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfP9o];
                } in  sat_sfP9p;
          };

Data.Semigroup.$fShowLast_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfP9q w1_sfP9r w2_sfP9s]
        case w1_sfP9r of {
          GHC.Types.I# ww1_sfP9u [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec2 w_sfP9q ww1_sfP9u w2_sfP9s;
        };

Data.Semigroup.$fShowLast_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Last a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfP9v x_sfP9w]
        let {
          sat_sfP9y [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfP9v x_sfP9w] \u []
                  let {
                    sat_sfP9x [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfP9v x_sfP9w] \u []
                            GHC.Show.showsPrec
                                $dShow_sfP9v
                                Data.Semigroup.$fFoldableOption7
                                x_sfP9w
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowLast1 sat_sfP9x;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowLast2 sat_sfP9y;

Data.Semigroup.$fShowLast_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Last a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfP9z ls_sfP9A s_sfP9B]
        let {
          sat_sfP9D [Occ=Once]
            :: Data.Semigroup.Last a_afy5P -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP9z] \r [w_sfP9C]
                  Data.Semigroup.$w$cshowsPrec2 $dShow_sfP9z 0# w_sfP9C;
        } in  GHC.Show.showList__ sat_sfP9D ls_sfP9A s_sfP9B;

Data.Semigroup.$fShowLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfP9E]
        let {
          sat_sfP9H [Occ=Once]
            :: [Data.Semigroup.Last a_afy5P] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP9E] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowLast_$cshowList
                      $dShow_sfP9E eta_B2 eta_B1; } in
        let {
          sat_sfP9G [Occ=Once]
            :: Data.Semigroup.Last a_afy5P -> GHC.Base.String
          [LclId] =
              [$dShow_sfP9E] \r [eta_B1]
                  Data.Semigroup.$fShowLast_$cshow $dShow_sfP9E eta_B1; } in
        let {
          sat_sfP9F [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Last a_afy5P -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP9E] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowLast_$cshowsPrec $dShow_sfP9E eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfP9F sat_sfP9G sat_sfP9H];

Data.Semigroup.$fEqLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfP9I]
        let {
          sat_sfP9K [Occ=Once]
            :: Data.Semigroup.Last a_afy3s
               -> Data.Semigroup.Last a_afy3s -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP9I] \u [] GHC.Classes./= $dEq_sfP9I; } in
        let {
          sat_sfP9J [Occ=Once]
            :: Data.Semigroup.Last a_afy3s
               -> Data.Semigroup.Last a_afy3s -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP9I] \u [] GHC.Classes.== $dEq_sfP9I;
        } in  GHC.Classes.C:Eq [sat_sfP9J sat_sfP9K];

Data.Semigroup.$fOrdLast_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Last a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfP9L]
        let {
          sat_sfP9M [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afy40
          [LclId] =
              [$dOrd_sfP9L] \u [] GHC.Classes.$p1Ord $dOrd_sfP9L;
        } in  Data.Semigroup.$fEqLast sat_sfP9M;

Data.Semigroup.$fOrdLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfP9N]
        let {
          sat_sfP9V [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> Data.Semigroup.Last a_afy40
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.min $dOrd_sfP9N; } in
        let {
          sat_sfP9U [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> Data.Semigroup.Last a_afy40
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.max $dOrd_sfP9N; } in
        let {
          sat_sfP9T [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.>= $dOrd_sfP9N; } in
        let {
          sat_sfP9S [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.> $dOrd_sfP9N; } in
        let {
          sat_sfP9R [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.<= $dOrd_sfP9N; } in
        let {
          sat_sfP9Q [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.< $dOrd_sfP9N; } in
        let {
          sat_sfP9P [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.compare $dOrd_sfP9N; } in
        let {
          sat_sfP9O [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Last a_afy40)
          [LclId] =
              [$dOrd_sfP9N] \u [] Data.Semigroup.$fOrdLast_$cp1Ord $dOrd_sfP9N;
        } in 
          GHC.Classes.C:Ord [sat_sfP9O
                             sat_sfP9P
                             sat_sfP9Q
                             sat_sfP9R
                             sat_sfP9S
                             sat_sfP9T
                             sat_sfP9U
                             sat_sfP9V];

Data.Semigroup.$fBoundedLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfP9W]
        let {
          sat_sfP9Y [Occ=Once] :: Data.Semigroup.Last a_afy3a
          [LclId] =
              [$dBounded_sfP9W] \u [] GHC.Enum.maxBound $dBounded_sfP9W; } in
        let {
          sat_sfP9X [Occ=Once] :: Data.Semigroup.Last a_afy3a
          [LclId] =
              [$dBounded_sfP9W] \u [] GHC.Enum.minBound $dBounded_sfP9W;
        } in  GHC.Enum.C:Bounded [sat_sfP9X sat_sfP9Y];

Data.Semigroup.$fGeneric1First1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.First a
     -> GHC.Generics.Rep1 Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP9Z] ds_sfP9Z;

Data.Semigroup.$fGeneric1First2
  :: forall a. Data.Semigroup.First a -> Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfPa0] x_sfPa0;

Data.Semigroup.$fGeneric1First [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1First2
                                            Data.Semigroup.$fGeneric1First1];

Data.Semigroup.$fGenericFirst1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.First a) x
     -> GHC.Generics.Rep (Data.Semigroup.First a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfPa1] ds_sfPa1;

Data.Semigroup.$fGenericFirst2
  :: forall a x. Data.Semigroup.First a -> Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfPa2] x1_sfPa2;

Data.Semigroup.$fGenericFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.First a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericFirst2
                                           Data.Semigroup.$fGenericFirst1];

Data.Semigroup.$fDataFirst_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.First a
     -> c (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPa3 k_sfPa4 z_sfPa5 ds_sfPa6]
        let {
          sat_sfPa7 [Occ=Once]
            :: c_afxYg (a_afxY7 -> Data.Semigroup.First a_afxY7)
          [LclId] =
              [z_sfPa5] \u [] z_sfPa5 Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfPa4 $dData_sfPa3 sat_sfPa7 ds_sfPa6;

Data.Semigroup.$fDataFirst4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First"#;

Data.Semigroup.$fDataFirst7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataFirst4;

Data.Semigroup.$fReadFirst_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataFirst7];

Data.Semigroup.$fReadFirst6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst"#;

Data.Semigroup.$fReadFirst5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadFirst6;

Data.Semigroup.$fReadFirst1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.First a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPa8]
        let {
          lvl33_sfPa9 [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afxXi
          [LclId] =
              [$dRead_sfPa8] \u []
                  GHC.Read.readPrec
                      $dRead_sfPa8 Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfPaa [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afxXi
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfPa9] \r [ds1_sfPab] lvl33_sfPa9; } in
        let {
          sat_sfPav [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.First a_afxXi)
          [LclId] =
              [ds_sfPaa] \r [c_sfPac eta_sfPad]
                  case c_sfPac of {
                    GHC.Types.I# x_sfPaf [Occ=Once] ->
                        case <=# [x_sfPaf 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfPas [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfPaa eta_sfPad] \r [a1_sfPah]
                                        let {
                                          sat_sfPap [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfPaa eta_sfPad] \r [a2_sfPai]
                                                  let {
                                                    sat_sfPao [Occ=Once]
                                                      :: a_afxXi
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfPad] \r [a3_sfPaj]
                                                            let {
                                                              sat_sfPal [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfPad a3_sfPaj] \r [a4_sfPak]
                                                                      eta_sfPad a3_sfPaj;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfPal
                                                              of
                                                              { Unit# ww1_sfPan [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfPan];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadFirst5
                                                        ds_sfPaa
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfPao;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfPap
                                          of
                                          { Unit# ww1_sfPar [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfPar];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadFirst_lexeme1 sat_sfPas
                                of
                                { Unit# ww1_sfPau [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfPau];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfPav;

Data.Semigroup.$fReadFirst_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.First a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPaw]
        let {
          ds_sfPax [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.First a_Xfyka -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfPaw] \u [] Data.Semigroup.$fReadFirst1 $dRead_sfPaw; } in
        let {
          sat_sfPaA [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.First a_Xfyka)
          [LclId] =
              [ds_sfPax] \r [n_sfPay]
                  let {
                    sat_sfPaz [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.First a_Xfyka)
                    [LclId] =
                        [ds_sfPax n_sfPay] \u []
                            ds_sfPax
                                n_sfPay Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfPaz;
        } in  sat_sfPaA;

Data.Semigroup.$fReadFirst_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.First a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPaB]
        let {
          sat_sfPaC [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.First a_Xfyk8)
          [LclId] =
              [$dRead_sfPaB] \s [] Data.Semigroup.$fReadFirst1 $dRead_sfPaB;
        } in  GHC.Read.list sat_sfPaC;

Data.Semigroup.$fReadFirst_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.First a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPaD]
        let {
          sat_sfPaF [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.First a_Xfyk9]
          [LclId] =
              [$dRead_sfPaD] \u []
                  let {
                    sat_sfPaE [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.First a_Xfyk9)
                    [LclId] =
                        [$dRead_sfPaD] \s [] Data.Semigroup.$fReadFirst1 $dRead_sfPaD;
                  } in 
                    GHC.Read.list
                        sat_sfPaE
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfPaF;

Data.Semigroup.$fReadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfPaG]
        let {
          sat_sfPaK [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.First a_Xfyk7]
          [LclId] =
              [$dRead_sfPaG] \u []
                  Data.Semigroup.$fReadFirst_$creadListPrec $dRead_sfPaG; } in
        let {
          sat_sfPaJ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.First a_Xfyk7)
          [LclId] =
              [$dRead_sfPaG] \u [] Data.Semigroup.$fReadFirst1 $dRead_sfPaG; } in
        let {
          sat_sfPaI [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.First a_Xfyk7]
          [LclId] =
              [$dRead_sfPaG] \u []
                  Data.Semigroup.$fReadFirst_$creadList $dRead_sfPaG; } in
        let {
          sat_sfPaH [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.First a_Xfyk7)
          [LclId] =
              [$dRead_sfPaG] \u []
                  Data.Semigroup.$fReadFirst_$creadsPrec $dRead_sfPaG;
        } in  GHC.Read.C:Read [sat_sfPaH sat_sfPaI sat_sfPaJ sat_sfPaK];

Data.Semigroup.$fShowFirst2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First {"#;

Data.Semigroup.$fShowFirst1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst = "#;

Data.Semigroup.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPaL ww_sfPaM w1_sfPaN]
        let {
          f_sfPaO [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfPaL w1_sfPaN] \u []
                  GHC.Show.showsPrec
                      w_sfPaL Data.Semigroup.$fFoldableOption7 w1_sfPaN;
        } in 
          case >=# [ww_sfPaM 11#] of {
            __DEFAULT ->
                let {
                  sat_sfPaU [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPaO] \r [x_sfPaQ]
                          let {
                            sat_sfPaT [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPaO x_sfPaQ] \u []
                                    let {
                                      sat_sfPaS [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPaO x_sfPaQ] \u []
                                              let {
                                                sat_sfPaR [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfPaQ] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfPaQ;
                                              } in  f_sfPaO sat_sfPaR;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowFirst1 sat_sfPaS;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowFirst2 sat_sfPaT;
                } in  sat_sfPaU;
            1# ->
                let {
                  sat_sfPb1 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPaO] \r [x_sfPaV]
                          let {
                            sat_sfPb0 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPaO x_sfPaV] \u []
                                    let {
                                      sat_sfPaZ [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPaO x_sfPaV] \u []
                                              let {
                                                sat_sfPaY [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfPaO x_sfPaV] \u []
                                                        let {
                                                          sat_sfPaX [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfPaV] \u []
                                                                  let {
                                                                    sat_sfPaW [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfPaV];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfPaW;
                                                        } in  f_sfPaO sat_sfPaX;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowFirst1 sat_sfPaY;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowFirst2 sat_sfPaZ;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfPb0];
                } in  sat_sfPb1;
          };

Data.Semigroup.$fShowFirst_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPb2 w1_sfPb3 w2_sfPb4]
        case w1_sfPb3 of {
          GHC.Types.I# ww1_sfPb6 [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec1 w_sfPb2 ww1_sfPb6 w2_sfPb4;
        };

Data.Semigroup.$fShowFirst_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.First a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPb7 x_sfPb8]
        let {
          sat_sfPba [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfPb7 x_sfPb8] \u []
                  let {
                    sat_sfPb9 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfPb7 x_sfPb8] \u []
                            GHC.Show.showsPrec
                                $dShow_sfPb7
                                Data.Semigroup.$fFoldableOption7
                                x_sfPb8
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowFirst1 sat_sfPb9;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowFirst2 sat_sfPba;

Data.Semigroup.$fShowFirst_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.First a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPbb ls_sfPbc s_sfPbd]
        let {
          sat_sfPbf [Occ=Once]
            :: Data.Semigroup.First a_afxWN -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPbb] \r [w_sfPbe]
                  Data.Semigroup.$w$cshowsPrec1 $dShow_sfPbb 0# w_sfPbe;
        } in  GHC.Show.showList__ sat_sfPbf ls_sfPbc s_sfPbd;

Data.Semigroup.$fShowFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfPbg]
        let {
          sat_sfPbj [Occ=Once]
            :: [Data.Semigroup.First a_afxWN] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPbg] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowFirst_$cshowList
                      $dShow_sfPbg eta_B2 eta_B1; } in
        let {
          sat_sfPbi [Occ=Once]
            :: Data.Semigroup.First a_afxWN -> GHC.Base.String
          [LclId] =
              [$dShow_sfPbg] \r [eta_B1]
                  Data.Semigroup.$fShowFirst_$cshow $dShow_sfPbg eta_B1; } in
        let {
          sat_sfPbh [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.First a_afxWN -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPbg] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowFirst_$cshowsPrec $dShow_sfPbg eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfPbh sat_sfPbi sat_sfPbj];

Data.Semigroup.$fEqFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfPbk]
        let {
          sat_sfPbm [Occ=Once]
            :: Data.Semigroup.First a_afxUq
               -> Data.Semigroup.First a_afxUq -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfPbk] \u [] GHC.Classes./= $dEq_sfPbk; } in
        let {
          sat_sfPbl [Occ=Once]
            :: Data.Semigroup.First a_afxUq
               -> Data.Semigroup.First a_afxUq -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfPbk] \u [] GHC.Classes.== $dEq_sfPbk;
        } in  GHC.Classes.C:Eq [sat_sfPbl sat_sfPbm];

Data.Semigroup.$fOrdFirst_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.First a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfPbn]
        let {
          sat_sfPbo [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afxUY
          [LclId] =
              [$dOrd_sfPbn] \u [] GHC.Classes.$p1Ord $dOrd_sfPbn;
        } in  Data.Semigroup.$fEqFirst sat_sfPbo;

Data.Semigroup.$fOrdFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfPbp]
        let {
          sat_sfPbx [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> Data.Semigroup.First a_afxUY
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.min $dOrd_sfPbp; } in
        let {
          sat_sfPbw [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> Data.Semigroup.First a_afxUY
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.max $dOrd_sfPbp; } in
        let {
          sat_sfPbv [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.>= $dOrd_sfPbp; } in
        let {
          sat_sfPbu [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.> $dOrd_sfPbp; } in
        let {
          sat_sfPbt [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.<= $dOrd_sfPbp; } in
        let {
          sat_sfPbs [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.< $dOrd_sfPbp; } in
        let {
          sat_sfPbr [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.compare $dOrd_sfPbp; } in
        let {
          sat_sfPbq [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.First a_afxUY)
          [LclId] =
              [$dOrd_sfPbp] \u [] Data.Semigroup.$fOrdFirst_$cp1Ord $dOrd_sfPbp;
        } in 
          GHC.Classes.C:Ord [sat_sfPbq
                             sat_sfPbr
                             sat_sfPbs
                             sat_sfPbt
                             sat_sfPbu
                             sat_sfPbv
                             sat_sfPbw
                             sat_sfPbx];

Data.Semigroup.$fBoundedFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfPby]
        let {
          sat_sfPbA [Occ=Once] :: Data.Semigroup.First a_afxU8
          [LclId] =
              [$dBounded_sfPby] \u [] GHC.Enum.maxBound $dBounded_sfPby; } in
        let {
          sat_sfPbz [Occ=Once] :: Data.Semigroup.First a_afxU8
          [LclId] =
              [$dBounded_sfPby] \u [] GHC.Enum.minBound $dBounded_sfPby;
        } in  GHC.Enum.C:Bounded [sat_sfPbz sat_sfPbA];

Data.Semigroup.$fGeneric1Arg_$cto1
  :: forall a1 a2.
     GHC.Generics.Rep1 (Data.Semigroup.Arg a1) a2
     -> Data.Semigroup.Arg a1 a2
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sfPbB]
        case ds_sfPbB of {
          GHC.Generics.:*: ds1_sfPbD [Occ=Once] ds2_sfPbE [Occ=Once] ->
              Data.Semigroup.Arg [ds1_sfPbD ds2_sfPbE];
        };

Data.Semigroup.$fGeneric1Arg1
  :: forall a1 a2.
     Data.Semigroup.Arg a1 a2
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Arg" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R a1)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              GHC.Generics.Par1)
          a2
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_sfPbF]
        case x_sfPbF of {
          Data.Semigroup.Arg g1_sfPbH [Occ=Once] g2_sfPbI [Occ=Once] ->
              GHC.Generics.:*: [g1_sfPbH g2_sfPbI];
        };

Data.Semigroup.$fGeneric1Arg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic1 (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Arg1
                                            Data.Semigroup.$fGeneric1Arg_$cto1];

Data.Semigroup.$fGenericArg_$cto
  :: forall a b x.
     GHC.Generics.Rep (Data.Semigroup.Arg a b) x
     -> Data.Semigroup.Arg a b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sfPbJ]
        case ds_sfPbJ of {
          GHC.Generics.:*: ds1_sfPbL [Occ=Once] ds2_sfPbM [Occ=Once] ->
              Data.Semigroup.Arg [ds1_sfPbL ds2_sfPbM];
        };

Data.Semigroup.$fGenericArg1
  :: forall a b x.
     Data.Semigroup.Arg a b
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Arg" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R a)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.K1 GHC.Generics.R b))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x1_sfPbN]
        case x1_sfPbN of {
          Data.Semigroup.Arg g1_sfPbP [Occ=Once] g2_sfPbQ [Occ=Once] ->
              GHC.Generics.:*: [g1_sfPbP g2_sfPbQ];
        };

Data.Semigroup.$fGenericArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. GHC.Generics.Generic (Data.Semigroup.Arg a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericArg1
                                           Data.Semigroup.$fGenericArg_$cto];

Data.Semigroup.$fDataArg_$cgunfold
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (c :: * -> *).
     (forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPbR $dData1_sfPbS k_sfPbT z_sfPbU ds_sfPbV]
        let {
          sat_sfPbX [Occ=Once]
            :: c_afxOm (b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
          [LclId] =
              [$dData_sfPbR k_sfPbT z_sfPbU] \u []
                  let {
                    sat_sfPbW [Occ=Once]
                      :: c_afxOm (a_afxNW
                                  -> b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
                    [LclId] =
                        [z_sfPbU] \u [] z_sfPbU Data.Semigroup.Arg;
                  } in  k_sfPbT $dData_sfPbR sat_sfPbW;
        } in  k_sfPbT $dData1_sfPbS sat_sfPbX;

Data.Semigroup.$fDataArg_$cgfoldl
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (c :: * -> *).
     (forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Arg a b
     -> c (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPbY $dData1_sfPbZ k_sfPc0 z_sfPc1 ds_sfPc2]
        case ds_sfPc2 of {
          Data.Semigroup.Arg a1_sfPc4 [Occ=Once] a2_sfPc5 [Occ=Once] ->
              let {
                sat_sfPc7 [Occ=Once]
                  :: c_afxO7 (b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
                [LclId] =
                    [$dData_sfPbY k_sfPc0 z_sfPc1 a1_sfPc4] \u []
                        let {
                          sat_sfPc6 [Occ=Once]
                            :: c_afxO7 (a_afxNW
                                        -> b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
                          [LclId] =
                              [z_sfPc1] \u [] z_sfPc1 Data.Semigroup.Arg;
                        } in  k_sfPc0 $dData_sfPbY sat_sfPc6 a1_sfPc4;
              } in  k_sfPc0 $dData1_sfPbZ sat_sfPc7 a2_sfPc5;
        };

Data.Semigroup.$fDataArg6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Arg"#;

Data.Semigroup.$fDataArg9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataArg6;

Data.Semigroup.$fReadArg_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataArg9];

Data.Semigroup.$fReadArg1
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Semigroup.Arg a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfPc8 $dRead1_sfPc9 eta_sfPca eta1_sfPcb]
        let {
          sat_sfPcq [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Arg a_afxN6 b_afxN7)
          [LclId] =
              [$dRead_sfPc8 $dRead1_sfPc9] \r [c_sfPcc eta2_sfPcd]
                  case c_sfPcc of {
                    GHC.Types.I# x_sfPcf [Occ=Once] ->
                        case <=# [x_sfPcf 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfPcn [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b2_i815E
                                [LclId] =
                                    [$dRead_sfPc8 $dRead1_sfPc9 eta2_sfPcd] \r [a1_sfPch]
                                        let {
                                          sat_sfPcm [Occ=Once]
                                            :: a_afxN6 -> Text.ParserCombinators.ReadP.P b2_i815E
                                          [LclId] =
                                              [$dRead1_sfPc9 eta2_sfPcd] \r [a2_sfPci]
                                                  let {
                                                    sat_sfPcl [Occ=Once]
                                                      :: b_afxN7
                                                         -> Text.ParserCombinators.ReadP.P b2_i815E
                                                    [LclId] =
                                                        [eta2_sfPcd a2_sfPci] \r [a3_sfPcj]
                                                            let {
                                                              sat_sfPck [Occ=Once]
                                                                :: Data.Semigroup.Arg
                                                                     a_afxN6 b_afxN7
                                                              [LclId] =
                                                                  CCCS Data.Semigroup.Arg! [a2_sfPci
                                                                                            a3_sfPcj];
                                                            } in  eta2_sfPcd sat_sfPck;
                                                  } in 
                                                    GHC.Read.readPrec
                                                        $dRead1_sfPc9
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfPcl;
                                        } in 
                                          GHC.Read.readPrec
                                              $dRead_sfPc8 Data.Semigroup.$fReadArg2 sat_sfPcm;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Semigroup.$fReadArg_lexeme sat_sfPcn
                                of
                                { Unit# ww1_sfPcp [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfPcp];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfPcq eta_sfPca eta1_sfPcb;

Data.Semigroup.$fReadArg_$creadsPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Arg a b)
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfPcr $dRead1_sfPcs n_sfPct]
        let {
          sat_sfPcu [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Semigroup.Arg a_XfyaI b_XfyaK)
          [LclId] =
              [$dRead_sfPcr $dRead1_sfPcs n_sfPct] \u []
                  Data.Semigroup.$fReadArg1
                      $dRead_sfPcr
                      $dRead1_sfPcs
                      n_sfPct
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfPcu;

Data.Semigroup.$fReadArg_$creadListPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Arg a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfPcv $dRead1_sfPcw]
        let {
          sat_sfPcx [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Arg a_XfyaG b_XfyaI)
          [LclId] =
              [$dRead_sfPcv $dRead1_sfPcw] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadArg1 $dRead_sfPcv $dRead1_sfPcw eta_B2 eta_B1;
        } in  GHC.Read.list sat_sfPcx;

Data.Semigroup.$fReadArg_$creadList
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Arg a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfPcy $dRead1_sfPcz]
        let {
          sat_sfPcB [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Arg a_XfyaH b_XfyaJ]
          [LclId] =
              [$dRead_sfPcy $dRead1_sfPcz] \u []
                  let {
                    sat_sfPcA [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Arg a_XfyaH b_XfyaJ)
                    [LclId] =
                        [$dRead_sfPcy $dRead1_sfPcz] \r [eta_B2 eta_B1]
                            Data.Semigroup.$fReadArg1 $dRead_sfPcy $dRead1_sfPcz eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sfPcA
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfPcB;

Data.Semigroup.$fReadArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Read.Read (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sfPcC $dRead1_sfPcD]
        let {
          sat_sfPcH [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Arg a_XfyaF b_XfyaH]
          [LclId] =
              [$dRead_sfPcC $dRead1_sfPcD] \u []
                  Data.Semigroup.$fReadArg_$creadListPrec
                      $dRead_sfPcC $dRead1_sfPcD; } in
        let {
          sat_sfPcG [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Arg a_XfyaF b_XfyaH)
          [LclId] =
              [$dRead_sfPcC $dRead1_sfPcD] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadArg1
                      $dRead_sfPcC $dRead1_sfPcD eta_B2 eta_B1; } in
        let {
          sat_sfPcF [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Arg a_XfyaF b_XfyaH]
          [LclId] =
              [$dRead_sfPcC $dRead1_sfPcD] \u []
                  Data.Semigroup.$fReadArg_$creadList
                      $dRead_sfPcC $dRead1_sfPcD; } in
        let {
          sat_sfPcE [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Arg a_XfyaF b_XfyaH)
          [LclId] =
              [$dRead_sfPcC $dRead1_sfPcD] \r [eta_B1]
                  Data.Semigroup.$fReadArg_$creadsPrec
                      $dRead_sfPcC $dRead1_sfPcD eta_B1;
        } in  GHC.Read.C:Read [sat_sfPcE sat_sfPcF sat_sfPcG sat_sfPcH];

Data.Semigroup.$fShowArg1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Arg "#;

Data.Semigroup.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Prim.Int# -> a -> b -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPcI w1_sfPcJ ww_sfPcK ww1_sfPcL ww2_sfPcM]
        let {
          f_sfPcN [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfPcI ww1_sfPcL] \u []
                  GHC.Show.showsPrec
                      w_sfPcI Data.Semigroup.$fReadArg2 ww1_sfPcL; } in
        let {
          g_sfPcO [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sfPcJ ww2_sfPcM] \u []
                  GHC.Show.showsPrec w1_sfPcJ Data.Semigroup.$fReadArg2 ww2_sfPcM;
        } in 
          case >=# [ww_sfPcK 11#] of {
            __DEFAULT ->
                let {
                  sat_sfPcU [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPcN g_sfPcO] \r [x_sfPcQ]
                          let {
                            sat_sfPcT [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPcN g_sfPcO x_sfPcQ] \u []
                                    let {
                                      sat_sfPcR [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sfPcO x_sfPcQ] \u [] g_sfPcO x_sfPcQ; } in
                                    let {
                                      sat_sfPcS [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          CCCS :! [GHC.Show.showSpace1 sat_sfPcR];
                                    } in  f_sfPcN sat_sfPcS;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowArg1 sat_sfPcT;
                } in  sat_sfPcU;
            1# ->
                let {
                  sat_sfPd1 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPcN g_sfPcO] \r [x_sfPcV]
                          let {
                            sat_sfPd0 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPcN g_sfPcO x_sfPcV] \u []
                                    let {
                                      sat_sfPcZ [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPcN g_sfPcO x_sfPcV] \u []
                                              let {
                                                sat_sfPcX [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sfPcO x_sfPcV] \u []
                                                        let {
                                                          sat_sfPcW [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sfPcV];
                                                        } in  g_sfPcO sat_sfPcW; } in
                                              let {
                                                sat_sfPcY [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.showSpace1 sat_sfPcX];
                                              } in  f_sfPcN sat_sfPcY;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowArg1 sat_sfPcZ;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfPd0];
                } in  sat_sfPd1;
          };

Data.Semigroup.$fShowArg_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Types.Int -> Data.Semigroup.Arg a b -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sfPd2 w1_sfPd3 w2_sfPd4 w3_sfPd5]
        case w2_sfPd4 of {
          GHC.Types.I# ww1_sfPd7 [Occ=Once] ->
              case w3_sfPd5 of {
                Data.Semigroup.Arg ww3_sfPd9 [Occ=Once] ww4_sfPda [Occ=Once] ->
                    Data.Semigroup.$w$cshowsPrec
                        w_sfPd2 w1_sfPd3 ww1_sfPd7 ww3_sfPd9 ww4_sfPda;
              };
        };

Data.Semigroup.$fShowArg_$cshow
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     Data.Semigroup.Arg a b -> GHC.Base.String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPdb $dShow1_sfPdc x_sfPdd]
        case x_sfPdd of {
          Data.Semigroup.Arg ww1_sfPdf [Occ=Once] ww2_sfPdg [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec
                  $dShow_sfPdb $dShow1_sfPdc 0# ww1_sfPdf ww2_sfPdg GHC.Types.[];
        };

Data.Semigroup.$fShowArg_$cshowList
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     [Data.Semigroup.Arg a b] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPdh $dShow1_sfPdi ls_sfPdj s_sfPdk]
        let {
          sat_sfPdp [Occ=Once]
            :: Data.Semigroup.Arg a_afxMx b_afxMy -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPdh $dShow1_sfPdi] \r [w_sfPdl]
                  case w_sfPdl of {
                    Data.Semigroup.Arg ww1_sfPdn [Occ=Once] ww2_sfPdo [Occ=Once] ->
                        Data.Semigroup.$w$cshowsPrec
                            $dShow_sfPdh $dShow1_sfPdi 0# ww1_sfPdn ww2_sfPdo;
                  };
        } in  GHC.Show.showList__ sat_sfPdp ls_sfPdj s_sfPdk;

Data.Semigroup.$fShowArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Show.Show (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfPdq $dShow1_sfPdr]
        let {
          sat_sfPdu [Occ=Once]
            :: [Data.Semigroup.Arg a_afxMx b_afxMy] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPdq $dShow1_sfPdr] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowArg_$cshowList
                      $dShow_sfPdq $dShow1_sfPdr eta_B2 eta_B1; } in
        let {
          sat_sfPdt [Occ=Once]
            :: Data.Semigroup.Arg a_afxMx b_afxMy -> GHC.Base.String
          [LclId] =
              [$dShow_sfPdq $dShow1_sfPdr] \r [eta_B1]
                  Data.Semigroup.$fShowArg_$cshow
                      $dShow_sfPdq $dShow1_sfPdr eta_B1; } in
        let {
          sat_sfPds [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Arg a_afxMx b_afxMy -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPdq $dShow1_sfPdr] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowArg_$cshowsPrec
                      $dShow_sfPdq $dShow1_sfPdr eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfPds sat_sfPdt sat_sfPdu];

Data.Semigroup.$fGeneric1Max1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Max a
     -> GHC.Generics.Rep1 Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfPdv] ds_sfPdv;

Data.Semigroup.$fGeneric1Max2
  :: forall a. Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfPdw] x_sfPdw;

Data.Semigroup.$fGeneric1Max [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Max
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Max2
                                            Data.Semigroup.$fGeneric1Max1];

Data.Semigroup.$fGenericMax1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Max a) x
     -> GHC.Generics.Rep (Data.Semigroup.Max a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfPdx] ds_sfPdx;

Data.Semigroup.$fGenericMax2
  :: forall a x. Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfPdy] x1_sfPdy;

Data.Semigroup.$fGenericMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Max a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericMax2
                                           Data.Semigroup.$fGenericMax1];

Data.Semigroup.$fDataMax_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Max a
     -> c (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPdz k_sfPdA z_sfPdB ds_sfPdC]
        let {
          sat_sfPdD [Occ=Once]
            :: c_afxHD (a_afxHu -> Data.Semigroup.Max a_afxHu)
          [LclId] =
              [z_sfPdB] \u [] z_sfPdB Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfPdA $dData_sfPdz sat_sfPdD ds_sfPdC;

Data.Semigroup.$fDataMax4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Max"#;

Data.Semigroup.$fDataMax7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataMax4;

Data.Semigroup.$fReadMax_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataMax7];

Data.Semigroup.$fReadMax3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMax"#;

Data.Semigroup.$fReadMax2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadMax3;

Data.Semigroup.$fReadMax1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Max a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPdE]
        let {
          lvl33_sfPdF [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afxGF
          [LclId] =
              [$dRead_sfPdE] \u []
                  GHC.Read.readPrec
                      $dRead_sfPdE Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfPdG [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afxGF
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfPdF] \r [ds1_sfPdH] lvl33_sfPdF; } in
        let {
          sat_sfPe1 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Max a_afxGF)
          [LclId] =
              [ds_sfPdG] \r [c_sfPdI eta_sfPdJ]
                  case c_sfPdI of {
                    GHC.Types.I# x_sfPdL [Occ=Once] ->
                        case <=# [x_sfPdL 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfPdY [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfPdG eta_sfPdJ] \r [a1_sfPdN]
                                        let {
                                          sat_sfPdV [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfPdG eta_sfPdJ] \r [a2_sfPdO]
                                                  let {
                                                    sat_sfPdU [Occ=Once]
                                                      :: a_afxGF
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfPdJ] \r [a3_sfPdP]
                                                            let {
                                                              sat_sfPdR [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfPdJ a3_sfPdP] \r [a4_sfPdQ]
                                                                      eta_sfPdJ a3_sfPdP;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfPdR
                                                              of
                                                              { Unit# ww1_sfPdT [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfPdT];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadMax2
                                                        ds_sfPdG
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfPdU;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfPdV
                                          of
                                          { Unit# ww1_sfPdX [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfPdX];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Semigroup.$fReadMax_lexeme sat_sfPdY
                                of
                                { Unit# ww1_sfPe0 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfPe0];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfPe1;

Data.Semigroup.$fReadMax_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Max a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPe2]
        let {
          ds_sfPe3 [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Max a_Xfy4P -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfPe2] \u [] Data.Semigroup.$fReadMax1 $dRead_sfPe2; } in
        let {
          sat_sfPe6 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Max a_Xfy4P)
          [LclId] =
              [ds_sfPe3] \r [n_sfPe4]
                  let {
                    sat_sfPe5 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Max a_Xfy4P)
                    [LclId] =
                        [ds_sfPe3 n_sfPe4] \u []
                            ds_sfPe3
                                n_sfPe4 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfPe5;
        } in  sat_sfPe6;

Data.Semigroup.$fReadMax_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Max a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPe7]
        let {
          sat_sfPe8 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Max a_Xfy4N)
          [LclId] =
              [$dRead_sfPe7] \s [] Data.Semigroup.$fReadMax1 $dRead_sfPe7;
        } in  GHC.Read.list sat_sfPe8;

Data.Semigroup.$fReadMax_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Max a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPe9]
        let {
          sat_sfPeb [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Max a_Xfy4O]
          [LclId] =
              [$dRead_sfPe9] \u []
                  let {
                    sat_sfPea [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Max a_Xfy4O)
                    [LclId] =
                        [$dRead_sfPe9] \s [] Data.Semigroup.$fReadMax1 $dRead_sfPe9;
                  } in 
                    GHC.Read.list
                        sat_sfPea
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfPeb;

Data.Semigroup.$fReadMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfPec]
        let {
          sat_sfPeg [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Max a_Xfy4M]
          [LclId] =
              [$dRead_sfPec] \u []
                  Data.Semigroup.$fReadMax_$creadListPrec $dRead_sfPec; } in
        let {
          sat_sfPef [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Max a_Xfy4M)
          [LclId] =
              [$dRead_sfPec] \u [] Data.Semigroup.$fReadMax1 $dRead_sfPec; } in
        let {
          sat_sfPee [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Max a_Xfy4M]
          [LclId] =
              [$dRead_sfPec] \u []
                  Data.Semigroup.$fReadMax_$creadList $dRead_sfPec; } in
        let {
          sat_sfPed [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Max a_Xfy4M)
          [LclId] =
              [$dRead_sfPec] \u []
                  Data.Semigroup.$fReadMax_$creadsPrec $dRead_sfPec;
        } in  GHC.Read.C:Read [sat_sfPed sat_sfPee sat_sfPef sat_sfPeg];

Data.Semigroup.$fShowMax2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Max {"#;

Data.Semigroup.$fShowMax1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMax = "#;

Data.Semigroup.$w$cshowsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Max a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPeh ww_sfPei w1_sfPej]
        let {
          f_sfPek [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfPeh w1_sfPej] \u []
                  GHC.Show.showsPrec
                      w_sfPeh Data.Semigroup.$fFoldableOption7 w1_sfPej;
        } in 
          case >=# [ww_sfPei 11#] of {
            __DEFAULT ->
                let {
                  sat_sfPeq [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPek] \r [x_sfPem]
                          let {
                            sat_sfPep [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPek x_sfPem] \u []
                                    let {
                                      sat_sfPeo [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPek x_sfPem] \u []
                                              let {
                                                sat_sfPen [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfPem] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfPem;
                                              } in  f_sfPek sat_sfPen;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMax1 sat_sfPeo;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowMax2 sat_sfPep;
                } in  sat_sfPeq;
            1# ->
                let {
                  sat_sfPex [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPek] \r [x_sfPer]
                          let {
                            sat_sfPew [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPek x_sfPer] \u []
                                    let {
                                      sat_sfPev [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPek x_sfPer] \u []
                                              let {
                                                sat_sfPeu [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfPek x_sfPer] \u []
                                                        let {
                                                          sat_sfPet [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfPer] \u []
                                                                  let {
                                                                    sat_sfPes [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfPer];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfPes;
                                                        } in  f_sfPek sat_sfPet;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowMax1 sat_sfPeu;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMax2 sat_sfPev;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfPew];
                } in  sat_sfPex;
          };

Data.Semigroup.$fShowMax_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Max a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPey w1_sfPez w2_sfPeA]
        case w1_sfPez of {
          GHC.Types.I# ww1_sfPeC [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec3 w_sfPey ww1_sfPeC w2_sfPeA;
        };

Data.Semigroup.$fShowMax_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Max a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPeD x_sfPeE]
        let {
          sat_sfPeG [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfPeD x_sfPeE] \u []
                  let {
                    sat_sfPeF [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfPeD x_sfPeE] \u []
                            GHC.Show.showsPrec
                                $dShow_sfPeD
                                Data.Semigroup.$fFoldableOption7
                                x_sfPeE
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowMax1 sat_sfPeF;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowMax2 sat_sfPeG;

Data.Semigroup.$fShowMax_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Max a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPeH ls_sfPeI s_sfPeJ]
        let {
          sat_sfPeL [Occ=Once]
            :: Data.Semigroup.Max a_afxGa -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPeH] \r [w_sfPeK]
                  Data.Semigroup.$w$cshowsPrec3 $dShow_sfPeH 0# w_sfPeK;
        } in  GHC.Show.showList__ sat_sfPeL ls_sfPeI s_sfPeJ;

Data.Semigroup.$fShowMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfPeM]
        let {
          sat_sfPeP [Occ=Once]
            :: [Data.Semigroup.Max a_afxGa] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPeM] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMax_$cshowList
                      $dShow_sfPeM eta_B2 eta_B1; } in
        let {
          sat_sfPeO [Occ=Once]
            :: Data.Semigroup.Max a_afxGa -> GHC.Base.String
          [LclId] =
              [$dShow_sfPeM] \r [eta_B1]
                  Data.Semigroup.$fShowMax_$cshow $dShow_sfPeM eta_B1; } in
        let {
          sat_sfPeN [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Max a_afxGa -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPeM] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMax_$cshowsPrec $dShow_sfPeM eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfPeN sat_sfPeO sat_sfPeP];

Data.Semigroup.$fEqMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfPeQ]
        let {
          sat_sfPeS [Occ=Once]
            :: Data.Semigroup.Max a_afxDN
               -> Data.Semigroup.Max a_afxDN -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfPeQ] \u [] GHC.Classes./= $dEq_sfPeQ; } in
        let {
          sat_sfPeR [Occ=Once]
            :: Data.Semigroup.Max a_afxDN
               -> Data.Semigroup.Max a_afxDN -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfPeQ] \u [] GHC.Classes.== $dEq_sfPeQ;
        } in  GHC.Classes.C:Eq [sat_sfPeR sat_sfPeS];

Data.Semigroup.$fOrdMax_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Max a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfPeT]
        let {
          sat_sfPeU [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afxEl
          [LclId] =
              [$dOrd_sfPeT] \u [] GHC.Classes.$p1Ord $dOrd_sfPeT;
        } in  Data.Semigroup.$fEqMax sat_sfPeU;

Data.Semigroup.$fOrdMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfPeV]
        let {
          sat_sfPf3 [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> Data.Semigroup.Max a_afxEl
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.min $dOrd_sfPeV; } in
        let {
          sat_sfPf2 [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> Data.Semigroup.Max a_afxEl
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.max $dOrd_sfPeV; } in
        let {
          sat_sfPf1 [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.>= $dOrd_sfPeV; } in
        let {
          sat_sfPf0 [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.> $dOrd_sfPeV; } in
        let {
          sat_sfPeZ [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.<= $dOrd_sfPeV; } in
        let {
          sat_sfPeY [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.< $dOrd_sfPeV; } in
        let {
          sat_sfPeX [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.compare $dOrd_sfPeV; } in
        let {
          sat_sfPeW [Occ=Once] :: GHC.Classes.Eq (Data.Semigroup.Max a_afxEl)
          [LclId] =
              [$dOrd_sfPeV] \u [] Data.Semigroup.$fOrdMax_$cp1Ord $dOrd_sfPeV;
        } in 
          GHC.Classes.C:Ord [sat_sfPeW
                             sat_sfPeX
                             sat_sfPeY
                             sat_sfPeZ
                             sat_sfPf0
                             sat_sfPf1
                             sat_sfPf2
                             sat_sfPf3];

Data.Semigroup.$fBoundedMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfPf4]
        let {
          sat_sfPf6 [Occ=Once] :: Data.Semigroup.Max a_afxDv
          [LclId] =
              [$dBounded_sfPf4] \u [] GHC.Enum.maxBound $dBounded_sfPf4; } in
        let {
          sat_sfPf5 [Occ=Once] :: Data.Semigroup.Max a_afxDv
          [LclId] =
              [$dBounded_sfPf4] \u [] GHC.Enum.minBound $dBounded_sfPf4;
        } in  GHC.Enum.C:Bounded [sat_sfPf5 sat_sfPf6];

Data.Semigroup.$fMonoidMax_$cmconcat
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     [Data.Semigroup.Max a] -> Data.Semigroup.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><L,1*U(1*U,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfPf7 $dBounded_sfPf8 eta_sfPf9]
        let {
          z_sfPfa [Occ=OnceL] :: a_XfzuM
          [LclId] =
              [$dBounded_sfPf8] \u [] GHC.Enum.minBound $dBounded_sfPf8; } in
        let {
          go_sfPfb [Occ=LoopBreaker]
            :: [Data.Semigroup.Max a_XfzuM] -> Data.Semigroup.Max a_XfzuM
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_sfPf7 z_sfPfa go_sfPfb] \r [ds_sfPfc]
                  case ds_sfPfc of {
                    [] -> z_sfPfa;
                    : y_sfPfe [Occ=Once] ys_sfPff [Occ=Once] ->
                        let {
                          sat_sfPfg [Occ=Once] :: a_XfzuM
                          [LclId] =
                              [go_sfPfb ys_sfPff] \u [] go_sfPfb ys_sfPff;
                        } in  GHC.Classes.max $dOrd_sfPf7 y_sfPfe sat_sfPfg;
                  };
        } in  go_sfPfb eta_sfPf9;

Data.Semigroup.$fMonoidMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     GHC.Base.Monoid (Data.Semigroup.Max a)
[GblId[DFunId], Arity=2, Str=<L,U(A,A,A,A,A,A,U,A)><L,U(U,A)>m] =
    [] \r [$dOrd_sfPfh $dBounded_sfPfi]
        let {
          sat_sfPfm [Occ=Once]
            :: [Data.Semigroup.Max a_XfzuG] -> Data.Semigroup.Max a_XfzuG
          [LclId] =
              [$dOrd_sfPfh $dBounded_sfPfi] \r [eta_B1]
                  Data.Semigroup.$fMonoidMax_$cmconcat
                      $dOrd_sfPfh $dBounded_sfPfi eta_B1; } in
        let {
          sat_sfPfl [Occ=Once]
            :: Data.Semigroup.Max a_XfzuG
               -> Data.Semigroup.Max a_XfzuG -> Data.Semigroup.Max a_XfzuG
          [LclId] =
              [$dOrd_sfPfh] \u [] GHC.Classes.max $dOrd_sfPfh; } in
        let {
          sat_sfPfk [Occ=Once] :: Data.Semigroup.Max a_XfzuG
          [LclId] =
              [$dBounded_sfPfi] \u [] GHC.Enum.minBound $dBounded_sfPfi; } in
        let {
          sat_sfPfj [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Max a_XfzuG)
          [LclId] =
              [$dOrd_sfPfh] \u [] Data.Semigroup.$fSemigroupMax $dOrd_sfPfh;
        } in  GHC.Base.C:Monoid [sat_sfPfj sat_sfPfk sat_sfPfl sat_sfPfm];

Data.Semigroup.$fGeneric1Min1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Min a
     -> GHC.Generics.Rep1 Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfPfn] ds_sfPfn;

Data.Semigroup.$fGeneric1Min2
  :: forall a. Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfPfo] x_sfPfo;

Data.Semigroup.$fGeneric1Min [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Min
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Min2
                                            Data.Semigroup.$fGeneric1Min1];

Data.Semigroup.$fGenericMin1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Min a) x
     -> GHC.Generics.Rep (Data.Semigroup.Min a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfPfp] ds_sfPfp;

Data.Semigroup.$fGenericMin2
  :: forall a x. Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfPfq] x1_sfPfq;

Data.Semigroup.$fGenericMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Min a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericMin2
                                           Data.Semigroup.$fGenericMin1];

Data.Semigroup.$fDataMin_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Min a
     -> c (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPfr k_sfPfs z_sfPft ds_sfPfu]
        let {
          sat_sfPfv [Occ=Once]
            :: c_afxyB (a_afxys -> Data.Semigroup.Min a_afxys)
          [LclId] =
              [z_sfPft] \u [] z_sfPft Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfPfs $dData_sfPfr sat_sfPfv ds_sfPfu;

Data.Semigroup.$fDataMin4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Min"#;

Data.Semigroup.$fDataMin7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataMin4;

Data.Semigroup.$fReadMin_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataMin7];

Data.Semigroup.$fReadMin3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMin"#;

Data.Semigroup.$fReadMin2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadMin3;

Data.Semigroup.$fReadMin1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Min a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPfw]
        let {
          lvl33_sfPfx [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afxxD
          [LclId] =
              [$dRead_sfPfw] \u []
                  GHC.Read.readPrec
                      $dRead_sfPfw Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfPfy [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afxxD
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfPfx] \r [ds1_sfPfz] lvl33_sfPfx; } in
        let {
          sat_sfPfT [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Min a_afxxD)
          [LclId] =
              [ds_sfPfy] \r [c_sfPfA eta_sfPfB]
                  case c_sfPfA of {
                    GHC.Types.I# x_sfPfD [Occ=Once] ->
                        case <=# [x_sfPfD 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfPfQ [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfPfy eta_sfPfB] \r [a1_sfPfF]
                                        let {
                                          sat_sfPfN [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfPfy eta_sfPfB] \r [a2_sfPfG]
                                                  let {
                                                    sat_sfPfM [Occ=Once]
                                                      :: a_afxxD
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfPfB] \r [a3_sfPfH]
                                                            let {
                                                              sat_sfPfJ [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfPfB a3_sfPfH] \r [a4_sfPfI]
                                                                      eta_sfPfB a3_sfPfH;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfPfJ
                                                              of
                                                              { Unit# ww1_sfPfL [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfPfL];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadMin2
                                                        ds_sfPfy
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfPfM;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfPfN
                                          of
                                          { Unit# ww1_sfPfP [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfPfP];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Semigroup.$fReadMin_lexeme sat_sfPfQ
                                of
                                { Unit# ww1_sfPfS [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfPfS];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfPfT;

Data.Semigroup.$fReadMin_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Min a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPfU]
        let {
          ds_sfPfV [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Min a_XfxWM -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfPfU] \u [] Data.Semigroup.$fReadMin1 $dRead_sfPfU; } in
        let {
          sat_sfPfY [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Min a_XfxWM)
          [LclId] =
              [ds_sfPfV] \r [n_sfPfW]
                  let {
                    sat_sfPfX [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Min a_XfxWM)
                    [LclId] =
                        [ds_sfPfV n_sfPfW] \u []
                            ds_sfPfV
                                n_sfPfW Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfPfX;
        } in  sat_sfPfY;

Data.Semigroup.$fReadMin_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Min a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPfZ]
        let {
          sat_sfPg0 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Min a_XfxWK)
          [LclId] =
              [$dRead_sfPfZ] \s [] Data.Semigroup.$fReadMin1 $dRead_sfPfZ;
        } in  GHC.Read.list sat_sfPg0;

Data.Semigroup.$fReadMin_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Min a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPg1]
        let {
          sat_sfPg3 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Min a_XfxWL]
          [LclId] =
              [$dRead_sfPg1] \u []
                  let {
                    sat_sfPg2 [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Min a_XfxWL)
                    [LclId] =
                        [$dRead_sfPg1] \s [] Data.Semigroup.$fReadMin1 $dRead_sfPg1;
                  } in 
                    GHC.Read.list
                        sat_sfPg2
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfPg3;

Data.Semigroup.$fReadMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfPg4]
        let {
          sat_sfPg8 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Min a_XfxWJ]
          [LclId] =
              [$dRead_sfPg4] \u []
                  Data.Semigroup.$fReadMin_$creadListPrec $dRead_sfPg4; } in
        let {
          sat_sfPg7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Min a_XfxWJ)
          [LclId] =
              [$dRead_sfPg4] \u [] Data.Semigroup.$fReadMin1 $dRead_sfPg4; } in
        let {
          sat_sfPg6 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Min a_XfxWJ]
          [LclId] =
              [$dRead_sfPg4] \u []
                  Data.Semigroup.$fReadMin_$creadList $dRead_sfPg4; } in
        let {
          sat_sfPg5 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Min a_XfxWJ)
          [LclId] =
              [$dRead_sfPg4] \u []
                  Data.Semigroup.$fReadMin_$creadsPrec $dRead_sfPg4;
        } in  GHC.Read.C:Read [sat_sfPg5 sat_sfPg6 sat_sfPg7 sat_sfPg8];

Data.Semigroup.$fShowMin2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Min {"#;

Data.Semigroup.$fShowMin1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMin = "#;

Data.Semigroup.$w$cshowsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Min a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPg9 ww_sfPga w1_sfPgb]
        let {
          f_sfPgc [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfPg9 w1_sfPgb] \u []
                  GHC.Show.showsPrec
                      w_sfPg9 Data.Semigroup.$fFoldableOption7 w1_sfPgb;
        } in 
          case >=# [ww_sfPga 11#] of {
            __DEFAULT ->
                let {
                  sat_sfPgi [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPgc] \r [x_sfPge]
                          let {
                            sat_sfPgh [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPgc x_sfPge] \u []
                                    let {
                                      sat_sfPgg [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPgc x_sfPge] \u []
                                              let {
                                                sat_sfPgf [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfPge] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfPge;
                                              } in  f_sfPgc sat_sfPgf;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMin1 sat_sfPgg;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowMin2 sat_sfPgh;
                } in  sat_sfPgi;
            1# ->
                let {
                  sat_sfPgp [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPgc] \r [x_sfPgj]
                          let {
                            sat_sfPgo [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPgc x_sfPgj] \u []
                                    let {
                                      sat_sfPgn [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPgc x_sfPgj] \u []
                                              let {
                                                sat_sfPgm [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfPgc x_sfPgj] \u []
                                                        let {
                                                          sat_sfPgl [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfPgj] \u []
                                                                  let {
                                                                    sat_sfPgk [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfPgj];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfPgk;
                                                        } in  f_sfPgc sat_sfPgl;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowMin1 sat_sfPgm;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMin2 sat_sfPgn;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfPgo];
                } in  sat_sfPgp;
          };

Data.Semigroup.$fShowMin_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Min a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPgq w1_sfPgr w2_sfPgs]
        case w1_sfPgr of {
          GHC.Types.I# ww1_sfPgu [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec4 w_sfPgq ww1_sfPgu w2_sfPgs;
        };

Data.Semigroup.$fShowMin_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Min a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPgv x_sfPgw]
        let {
          sat_sfPgy [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfPgv x_sfPgw] \u []
                  let {
                    sat_sfPgx [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfPgv x_sfPgw] \u []
                            GHC.Show.showsPrec
                                $dShow_sfPgv
                                Data.Semigroup.$fFoldableOption7
                                x_sfPgw
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowMin1 sat_sfPgx;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowMin2 sat_sfPgy;

Data.Semigroup.$fShowMin_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Min a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPgz ls_sfPgA s_sfPgB]
        let {
          sat_sfPgD [Occ=Once]
            :: Data.Semigroup.Min a_afxx8 -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPgz] \r [w_sfPgC]
                  Data.Semigroup.$w$cshowsPrec4 $dShow_sfPgz 0# w_sfPgC;
        } in  GHC.Show.showList__ sat_sfPgD ls_sfPgA s_sfPgB;

Data.Semigroup.$fShowMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfPgE]
        let {
          sat_sfPgH [Occ=Once]
            :: [Data.Semigroup.Min a_afxx8] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPgE] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMin_$cshowList
                      $dShow_sfPgE eta_B2 eta_B1; } in
        let {
          sat_sfPgG [Occ=Once]
            :: Data.Semigroup.Min a_afxx8 -> GHC.Base.String
          [LclId] =
              [$dShow_sfPgE] \r [eta_B1]
                  Data.Semigroup.$fShowMin_$cshow $dShow_sfPgE eta_B1; } in
        let {
          sat_sfPgF [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Min a_afxx8 -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPgE] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMin_$cshowsPrec $dShow_sfPgE eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfPgF sat_sfPgG sat_sfPgH];

Data.Semigroup.$fEqMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfPgI]
        let {
          sat_sfPgK [Occ=Once]
            :: Data.Semigroup.Min a_afxuL
               -> Data.Semigroup.Min a_afxuL -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfPgI] \u [] GHC.Classes./= $dEq_sfPgI; } in
        let {
          sat_sfPgJ [Occ=Once]
            :: Data.Semigroup.Min a_afxuL
               -> Data.Semigroup.Min a_afxuL -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfPgI] \u [] GHC.Classes.== $dEq_sfPgI;
        } in  GHC.Classes.C:Eq [sat_sfPgJ sat_sfPgK];

Data.Semigroup.$fOrdMin_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Min a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfPgL]
        let {
          sat_sfPgM [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afxvj
          [LclId] =
              [$dOrd_sfPgL] \u [] GHC.Classes.$p1Ord $dOrd_sfPgL;
        } in  Data.Semigroup.$fEqMin sat_sfPgM;

Data.Semigroup.$fOrdMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfPgN]
        let {
          sat_sfPgV [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> Data.Semigroup.Min a_afxvj
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.min $dOrd_sfPgN; } in
        let {
          sat_sfPgU [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> Data.Semigroup.Min a_afxvj
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.max $dOrd_sfPgN; } in
        let {
          sat_sfPgT [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.>= $dOrd_sfPgN; } in
        let {
          sat_sfPgS [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.> $dOrd_sfPgN; } in
        let {
          sat_sfPgR [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.<= $dOrd_sfPgN; } in
        let {
          sat_sfPgQ [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.< $dOrd_sfPgN; } in
        let {
          sat_sfPgP [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.compare $dOrd_sfPgN; } in
        let {
          sat_sfPgO [Occ=Once] :: GHC.Classes.Eq (Data.Semigroup.Min a_afxvj)
          [LclId] =
              [$dOrd_sfPgN] \u [] Data.Semigroup.$fOrdMin_$cp1Ord $dOrd_sfPgN;
        } in 
          GHC.Classes.C:Ord [sat_sfPgO
                             sat_sfPgP
                             sat_sfPgQ
                             sat_sfPgR
                             sat_sfPgS
                             sat_sfPgT
                             sat_sfPgU
                             sat_sfPgV];

Data.Semigroup.$fBoundedMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfPgW]
        let {
          sat_sfPgY [Occ=Once] :: Data.Semigroup.Min a_afxut
          [LclId] =
              [$dBounded_sfPgW] \u [] GHC.Enum.maxBound $dBounded_sfPgW; } in
        let {
          sat_sfPgX [Occ=Once] :: Data.Semigroup.Min a_afxut
          [LclId] =
              [$dBounded_sfPgW] \u [] GHC.Enum.minBound $dBounded_sfPgW;
        } in  GHC.Enum.C:Bounded [sat_sfPgX sat_sfPgY];

Data.Semigroup.$fMonoidMin_$cmconcat
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     [Data.Semigroup.Min a] -> Data.Semigroup.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><L,1*U(A,1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfPgZ $dBounded_sfPh0 eta_sfPh1]
        let {
          z_sfPh2 [Occ=OnceL] :: a_XfzEk
          [LclId] =
              [$dBounded_sfPh0] \u [] GHC.Enum.maxBound $dBounded_sfPh0; } in
        let {
          go_sfPh3 [Occ=LoopBreaker]
            :: [Data.Semigroup.Min a_XfzEk] -> Data.Semigroup.Min a_XfzEk
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_sfPgZ z_sfPh2 go_sfPh3] \r [ds_sfPh4]
                  case ds_sfPh4 of {
                    [] -> z_sfPh2;
                    : y_sfPh6 [Occ=Once] ys_sfPh7 [Occ=Once] ->
                        let {
                          sat_sfPh8 [Occ=Once] :: a_XfzEk
                          [LclId] =
                              [go_sfPh3 ys_sfPh7] \u [] go_sfPh3 ys_sfPh7;
                        } in  GHC.Classes.min $dOrd_sfPgZ y_sfPh6 sat_sfPh8;
                  };
        } in  go_sfPh3 eta_sfPh1;

Data.Semigroup.$fMonoidMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     GHC.Base.Monoid (Data.Semigroup.Min a)
[GblId[DFunId], Arity=2, Str=<L,U(A,A,A,A,A,A,A,U)><L,U(A,U)>m] =
    [] \r [$dOrd_sfPh9 $dBounded_sfPha]
        let {
          sat_sfPhe [Occ=Once]
            :: [Data.Semigroup.Min a_XfzEe] -> Data.Semigroup.Min a_XfzEe
          [LclId] =
              [$dOrd_sfPh9 $dBounded_sfPha] \r [eta_B1]
                  Data.Semigroup.$fMonoidMin_$cmconcat
                      $dOrd_sfPh9 $dBounded_sfPha eta_B1; } in
        let {
          sat_sfPhd [Occ=Once]
            :: Data.Semigroup.Min a_XfzEe
               -> Data.Semigroup.Min a_XfzEe -> Data.Semigroup.Min a_XfzEe
          [LclId] =
              [$dOrd_sfPh9] \u [] GHC.Classes.min $dOrd_sfPh9; } in
        let {
          sat_sfPhc [Occ=Once] :: Data.Semigroup.Min a_XfzEe
          [LclId] =
              [$dBounded_sfPha] \u [] GHC.Enum.maxBound $dBounded_sfPha; } in
        let {
          sat_sfPhb [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Min a_XfzEe)
          [LclId] =
              [$dOrd_sfPh9] \u [] Data.Semigroup.$fSemigroupMin $dOrd_sfPh9;
        } in  GHC.Base.C:Monoid [sat_sfPhb sat_sfPhc sat_sfPhd sat_sfPhe];

Data.Semigroup.getMin :: forall a. Data.Semigroup.Min a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Min2 eta_B1;

Data.Semigroup.$fMonadFixMin_$cmfix
  :: forall a. (a -> Data.Semigroup.Min a) -> Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfPhf]
        let {
          x_sfPhg [Occ=LoopBreaker] :: Data.Semigroup.Min a_afz9s
          [LclId] =
              [f_sfPhf x_sfPhg] \u [] f_sfPhf x_sfPhg;
        } in  x_sfPhg;

Data.Semigroup.$fMonadFixMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadMin
                                                 Data.Semigroup.$fMonadFixMin_$cmfix];

Data.Semigroup.$fEnumMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfPhh]
        let {
          sat_sfPhB [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs
               -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfPhh] \r [ds_sfPhy ds1_sfPhz ds2_sfPhA]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfPhh ds_sfPhy ds1_sfPhz ds2_sfPhA; } in
        let {
          sat_sfPhx [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfPhh] \r [ds_sfPhv ds1_sfPhw]
                  GHC.Enum.enumFromTo $dEnum_sfPhh ds_sfPhv ds1_sfPhw; } in
        let {
          sat_sfPhu [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfPhh] \r [ds_sfPhs ds1_sfPht]
                  GHC.Enum.enumFromThen $dEnum_sfPhh ds_sfPhs ds1_sfPht; } in
        let {
          sat_sfPhr [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfPhh] \r [ds_sfPhq]
                  GHC.Enum.enumFrom $dEnum_sfPhh ds_sfPhq; } in
        let {
          sat_sfPhp [Occ=Once] :: Data.Semigroup.Min a_XfzFs -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfPhh] \r [eta_sfPho]
                  GHC.Enum.fromEnum $dEnum_sfPhh eta_sfPho; } in
        let {
          sat_sfPhn [Occ=Once] :: GHC.Types.Int -> Data.Semigroup.Min a_XfzFs
          [LclId] =
              [$dEnum_sfPhh] \r [eta_sfPhm]
                  GHC.Enum.toEnum $dEnum_sfPhh eta_sfPhm; } in
        let {
          sat_sfPhl [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs -> Data.Semigroup.Min a_XfzFs
          [LclId] =
              [$dEnum_sfPhh] \r [ds_sfPhk]
                  GHC.Enum.pred $dEnum_sfPhh ds_sfPhk; } in
        let {
          sat_sfPhj [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs -> Data.Semigroup.Min a_XfzFs
          [LclId] =
              [$dEnum_sfPhh] \r [ds_sfPhi] GHC.Enum.succ $dEnum_sfPhh ds_sfPhi;
        } in 
          GHC.Enum.C:Enum [sat_sfPhj
                           sat_sfPhl
                           sat_sfPhn
                           sat_sfPhp
                           sat_sfPhr
                           sat_sfPhu
                           sat_sfPhx
                           sat_sfPhB];

Data.Semigroup.getMax :: forall a. Data.Semigroup.Max a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Max2 eta_B1;

Data.Semigroup.$fMonadFixMax_$cmfix
  :: forall a. (a -> Data.Semigroup.Max a) -> Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfPhC]
        let {
          x_sfPhD [Occ=LoopBreaker] :: Data.Semigroup.Max a_afz0T
          [LclId] =
              [f_sfPhC x_sfPhD] \u [] f_sfPhC x_sfPhD;
        } in  x_sfPhD;

Data.Semigroup.$fMonadFixMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadMax
                                                 Data.Semigroup.$fMonadFixMax_$cmfix];

Data.Semigroup.$fEnumMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfPhE]
        let {
          sat_sfPhY [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1
               -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfPhE] \r [ds_sfPhV ds1_sfPhW ds2_sfPhX]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfPhE ds_sfPhV ds1_sfPhW ds2_sfPhX; } in
        let {
          sat_sfPhU [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1 -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfPhE] \r [ds_sfPhS ds1_sfPhT]
                  GHC.Enum.enumFromTo $dEnum_sfPhE ds_sfPhS ds1_sfPhT; } in
        let {
          sat_sfPhR [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1 -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfPhE] \r [ds_sfPhP ds1_sfPhQ]
                  GHC.Enum.enumFromThen $dEnum_sfPhE ds_sfPhP ds1_sfPhQ; } in
        let {
          sat_sfPhO [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1 -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfPhE] \r [ds_sfPhN]
                  GHC.Enum.enumFrom $dEnum_sfPhE ds_sfPhN; } in
        let {
          sat_sfPhM [Occ=Once] :: Data.Semigroup.Max a_Xfzx1 -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfPhE] \r [eta_sfPhL]
                  GHC.Enum.fromEnum $dEnum_sfPhE eta_sfPhL; } in
        let {
          sat_sfPhK [Occ=Once] :: GHC.Types.Int -> Data.Semigroup.Max a_Xfzx1
          [LclId] =
              [$dEnum_sfPhE] \r [eta_sfPhJ]
                  GHC.Enum.toEnum $dEnum_sfPhE eta_sfPhJ; } in
        let {
          sat_sfPhI [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1 -> Data.Semigroup.Max a_Xfzx1
          [LclId] =
              [$dEnum_sfPhE] \r [ds_sfPhH]
                  GHC.Enum.pred $dEnum_sfPhE ds_sfPhH; } in
        let {
          sat_sfPhG [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1 -> Data.Semigroup.Max a_Xfzx1
          [LclId] =
              [$dEnum_sfPhE] \r [ds_sfPhF] GHC.Enum.succ $dEnum_sfPhE ds_sfPhF;
        } in 
          GHC.Enum.C:Enum [sat_sfPhG
                           sat_sfPhI
                           sat_sfPhK
                           sat_sfPhM
                           sat_sfPhO
                           sat_sfPhR
                           sat_sfPhU
                           sat_sfPhY];

Data.Semigroup.getFirst :: forall a. Data.Semigroup.First a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1First2 eta_B1;

Data.Semigroup.$fMonadFixFirst_$cmfix
  :: forall a.
     (a -> Data.Semigroup.First a) -> Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfPhZ]
        let {
          x_sfPi0 [Occ=LoopBreaker] :: Data.Semigroup.First a_afyMj
          [LclId] =
              [f_sfPhZ x_sfPi0] \u [] f_sfPhZ x_sfPi0;
        } in  x_sfPi0;

Data.Semigroup.$fMonadFixFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadFirst
                                                 Data.Semigroup.$fMonadFixFirst_$cmfix];

Data.Semigroup.$fEnumFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfPi1]
        let {
          sat_sfPil [Occ=Once]
            :: Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV
               -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfPi1] \r [ds_sfPii ds1_sfPij ds2_sfPik]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfPi1 ds_sfPii ds1_sfPij ds2_sfPik; } in
        let {
          sat_sfPih [Occ=Once]
            :: Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfPi1] \r [ds_sfPif ds1_sfPig]
                  GHC.Enum.enumFromTo $dEnum_sfPi1 ds_sfPif ds1_sfPig; } in
        let {
          sat_sfPie [Occ=Once]
            :: Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfPi1] \r [ds_sfPic ds1_sfPid]
                  GHC.Enum.enumFromThen $dEnum_sfPi1 ds_sfPic ds1_sfPid; } in
        let {
          sat_sfPib [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfPi1] \r [ds_sfPia]
                  GHC.Enum.enumFrom $dEnum_sfPi1 ds_sfPia; } in
        let {
          sat_sfPi9 [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfPi1] \r [eta_sfPi8]
                  GHC.Enum.fromEnum $dEnum_sfPi1 eta_sfPi8; } in
        let {
          sat_sfPi7 [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.First a_XfzhV
          [LclId] =
              [$dEnum_sfPi1] \r [eta_sfPi6]
                  GHC.Enum.toEnum $dEnum_sfPi1 eta_sfPi6; } in
        let {
          sat_sfPi5 [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> Data.Semigroup.First a_XfzhV
          [LclId] =
              [$dEnum_sfPi1] \r [ds_sfPi4]
                  GHC.Enum.pred $dEnum_sfPi1 ds_sfPi4; } in
        let {
          sat_sfPi3 [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> Data.Semigroup.First a_XfzhV
          [LclId] =
              [$dEnum_sfPi1] \r [ds_sfPi2] GHC.Enum.succ $dEnum_sfPi1 ds_sfPi2;
        } in 
          GHC.Enum.C:Enum [sat_sfPi3
                           sat_sfPi5
                           sat_sfPi7
                           sat_sfPi9
                           sat_sfPib
                           sat_sfPie
                           sat_sfPih
                           sat_sfPil];

Data.Semigroup.getLast :: forall a. Data.Semigroup.Last a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Last2 eta_B1;

Data.Semigroup.$fMonadFixLast_$cmfix
  :: forall a. (a -> Data.Semigroup.Last a) -> Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfPim]
        let {
          x_sfPin [Occ=LoopBreaker] :: Data.Semigroup.Last a_afyFi
          [LclId] =
              [f_sfPim x_sfPin] \u [] f_sfPim x_sfPin;
        } in  x_sfPin;

Data.Semigroup.$fMonadFixLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadLast
                                                 Data.Semigroup.$fMonadFixLast_$cmfix];

Data.Semigroup.$fEnumLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfPio]
        let {
          sat_sfPiI [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2
               -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfPio] \r [ds_sfPiF ds1_sfPiG ds2_sfPiH]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfPio ds_sfPiF ds1_sfPiG ds2_sfPiH; } in
        let {
          sat_sfPiE [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2 -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfPio] \r [ds_sfPiC ds1_sfPiD]
                  GHC.Enum.enumFromTo $dEnum_sfPio ds_sfPiC ds1_sfPiD; } in
        let {
          sat_sfPiB [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2 -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfPio] \r [ds_sfPiz ds1_sfPiA]
                  GHC.Enum.enumFromThen $dEnum_sfPio ds_sfPiz ds1_sfPiA; } in
        let {
          sat_sfPiy [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfPio] \r [ds_sfPix]
                  GHC.Enum.enumFrom $dEnum_sfPio ds_sfPix; } in
        let {
          sat_sfPiw [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfPio] \r [eta_sfPiv]
                  GHC.Enum.fromEnum $dEnum_sfPio eta_sfPiv; } in
        let {
          sat_sfPiu [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Last a_Xfzb2
          [LclId] =
              [$dEnum_sfPio] \r [eta_sfPit]
                  GHC.Enum.toEnum $dEnum_sfPio eta_sfPit; } in
        let {
          sat_sfPis [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> Data.Semigroup.Last a_Xfzb2
          [LclId] =
              [$dEnum_sfPio] \r [ds_sfPir]
                  GHC.Enum.pred $dEnum_sfPio ds_sfPir; } in
        let {
          sat_sfPiq [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> Data.Semigroup.Last a_Xfzb2
          [LclId] =
              [$dEnum_sfPio] \r [ds_sfPip] GHC.Enum.succ $dEnum_sfPio ds_sfPip;
        } in 
          GHC.Enum.C:Enum [sat_sfPiq
                           sat_sfPis
                           sat_sfPiu
                           sat_sfPiw
                           sat_sfPiy
                           sat_sfPiB
                           sat_sfPiE
                           sat_sfPiI];

Data.Semigroup.unwrapMonoid
  :: forall m. Data.Semigroup.WrappedMonoid m -> m
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1WrappedMonoid2 eta_B1;

Data.Semigroup.$fEnumWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.WrappedMonoid a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfPiJ]
        let {
          sat_sfPj3 [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfPiJ] \r [ds_sfPj0 ds1_sfPj1 ds2_sfPj2]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfPiJ ds_sfPj0 ds1_sfPj1 ds2_sfPj2; } in
        let {
          sat_sfPiZ [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfPiJ] \r [ds_sfPiX ds1_sfPiY]
                  GHC.Enum.enumFromTo $dEnum_sfPiJ ds_sfPiX ds1_sfPiY; } in
        let {
          sat_sfPiW [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfPiJ] \r [ds_sfPiU ds1_sfPiV]
                  GHC.Enum.enumFromThen $dEnum_sfPiJ ds_sfPiU ds1_sfPiV; } in
        let {
          sat_sfPiT [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfPiJ] \r [ds_sfPiS]
                  GHC.Enum.enumFrom $dEnum_sfPiJ ds_sfPiS; } in
        let {
          sat_sfPiR [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37 -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfPiJ] \r [eta_sfPiQ]
                  GHC.Enum.fromEnum $dEnum_sfPiJ eta_sfPiQ; } in
        let {
          sat_sfPiP [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.WrappedMonoid a_Xfz37
          [LclId] =
              [$dEnum_sfPiJ] \r [eta_sfPiO]
                  GHC.Enum.toEnum $dEnum_sfPiJ eta_sfPiO; } in
        let {
          sat_sfPiN [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
          [LclId] =
              [$dEnum_sfPiJ] \r [ds_sfPiM]
                  GHC.Enum.pred $dEnum_sfPiJ ds_sfPiM; } in
        let {
          sat_sfPiL [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
          [LclId] =
              [$dEnum_sfPiJ] \r [ds_sfPiK] GHC.Enum.succ $dEnum_sfPiJ ds_sfPiK;
        } in 
          GHC.Enum.C:Enum [sat_sfPiL
                           sat_sfPiN
                           sat_sfPiP
                           sat_sfPiR
                           sat_sfPiT
                           sat_sfPiW
                           sat_sfPiZ
                           sat_sfPj3];

Data.Semigroup.getOption
  :: forall a. Data.Semigroup.Option a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Option2 eta_B1;

Data.Semigroup.$fMonadFixOption_$cmfix
  :: forall a.
     (a -> Data.Semigroup.Option a) -> Data.Semigroup.Option a
[GblId, Arity=1, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfPj4]
        let {
          a1_sfPj5 [Occ=LoopBreaker] :: Data.Semigroup.Option a_afyzI
          [LclId] =
              [f_sfPj4 a1_sfPj5] \u []
                  let {
                    sat_sfPj8 [Occ=Once] :: a_afyzI
                    [LclId] =
                        [a1_sfPj5] \u []
                            case a1_sfPj5 of {
                              GHC.Base.Nothing -> Control.Monad.Fix.$fMonadFixFirst1;
                              GHC.Base.Just x_sfPj7 [Occ=Once] -> x_sfPj7;
                            };
                  } in  f_sfPj4 sat_sfPj8;
        } in  a1_sfPj5;

Data.Semigroup.$fMonadFixOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadOption
                                                 Data.Semigroup.$fMonadFixOption_$cmfix];

Data.Semigroup.cycle1 :: forall m. GHC.Base.Semigroup m => m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),U(C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfPj9 xs_sfPja]
        let {
          xs'_sfPjb [Occ=LoopBreaker] :: m_afxsV
          [LclId] =
              [$dSemigroup_sfPj9 xs_sfPja xs'_sfPjb] \u []
                  GHC.Base.<> $dSemigroup_sfPj9 xs_sfPja xs'_sfPjb;
        } in  xs'_sfPjb;

Data.Semigroup.diff1
  :: forall m. GHC.Base.Semigroup m => m -> m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfPjc eta_sfPjd]
        GHC.Base.<> $dSemigroup_sfPjc eta_sfPjd;

Data.Semigroup.diff
  :: forall m.
     GHC.Base.Semigroup m =>
     m -> Data.Semigroup.Internal.Endo m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Semigroup.diff1 eta_B2 eta_B1;

Data.Semigroup.mtimesDefault
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Monoid a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(U,U,U,U,U,U,U),U(U(U,U),U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U(A,1*U,U,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfPje $dMonoid_sfPjf eta_sfPjg eta1_sfPjh]
        case
            GHC.Real.$p1Integral $dIntegral_sfPje
        of
        $dReal_sfPji [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_sfPjm [Occ=Once] :: b_afxst
                [LclId] =
                    [$dReal_sfPji] \u []
                        case GHC.Real.$p1Real $dReal_sfPji of sat_sfPjl {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_sfPjl Data.Semigroup.$fSemigroupOption2;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_sfPji of sat_sfPjj {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_sfPjj of sat_sfPjk {
                        __DEFAULT ->
                            case GHC.Classes.== sat_sfPjk eta_sfPjg sat_sfPjm of {
                              GHC.Types.False ->
                                  Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes
                                      $dMonoid_sfPjf $dIntegral_sfPje eta_sfPjg eta1_sfPjh;
                              GHC.Types.True -> GHC.Base.mempty $dMonoid_sfPjf;
                            };
                      };
                };
        };

Data.Semigroup.option
  :: forall b a. b -> (a -> b) -> Data.Semigroup.Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] Data.Maybe.maybe eta_B3 eta_B2 eta_B1;

$cMin1_rfC6i :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadMin2 GHC.Types.[]];

go61_rfC6j
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPjo _ys_sfPjp]
        case ds2_sfPjo of {
          [] -> GHC.List.badHead;
          : ipv_sfPjr [Occ=Once!] ipv1_sfPjs [Occ=Once] ->
              case _ys_sfPjp of {
                [] -> GHC.List.badHead;
                : ipv2_sfPju [Occ=Once] ipv3_sfPjv [Occ=Once] ->
                    case ipv_sfPjr of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPjy [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfPjy Data.Semigroup.$fDataMin7 of {
                            GHC.Types.False -> go61_rfC6j ipv1_sfPjs ipv3_sfPjv;
                            GHC.Types.True -> ipv2_sfPju;
                          };
                    };
              };
        };

$cMin2_rfC6k :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cMin3_rfC6l];
Data.Semigroup.$fDataMin6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cMin GHC.Types.[]];
Data.Semigroup.$fDataMin5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataMin6];
Data.Semigroup.$tMin :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataMin7
                                       Data.Semigroup.$fDataMin5];
Data.Semigroup.$cMin [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cMin2_rfC6k
                                     Data.Semigroup.$fDataMin7
                                     $cMin1_rfC6i
                                     Data.Data.Prefix
                                     Data.Semigroup.$tMin];
$cMin3_rfC6l :: Data.Data.ConIndex
[GblId] =
    [] \u [] go61_rfC6j Data.Semigroup.$fDataMin6 Data.Data.mkConstr1;

$cMax1_rfC6m :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadMax2 GHC.Types.[]];

go1_rfC6n
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPjD _ys_sfPjE]
        case ds2_sfPjD of {
          [] -> GHC.List.badHead;
          : ipv_sfPjG [Occ=Once!] ipv1_sfPjH [Occ=Once] ->
              case _ys_sfPjE of {
                [] -> GHC.List.badHead;
                : ipv2_sfPjJ [Occ=Once] ipv3_sfPjK [Occ=Once] ->
                    case ipv_sfPjG of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPjN [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfPjN Data.Semigroup.$fDataMax7 of {
                            GHC.Types.False -> go1_rfC6n ipv1_sfPjH ipv3_sfPjK;
                            GHC.Types.True -> ipv2_sfPjJ;
                          };
                    };
              };
        };

$cMax2_rfC6o :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cMax3_rfC6p];
Data.Semigroup.$fDataMax6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cMax GHC.Types.[]];
Data.Semigroup.$fDataMax5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataMax6];
Data.Semigroup.$tMax :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataMax7
                                       Data.Semigroup.$fDataMax5];
Data.Semigroup.$cMax [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cMax2_rfC6o
                                     Data.Semigroup.$fDataMax7
                                     $cMax1_rfC6m
                                     Data.Data.Prefix
                                     Data.Semigroup.$tMax];
$cMax3_rfC6p :: Data.Data.ConIndex
[GblId] =
    [] \u [] go1_rfC6n Data.Semigroup.$fDataMax6 Data.Data.mkConstr1;

go2_rfC6q
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPjS _ys_sfPjT]
        case ds2_sfPjS of {
          [] -> GHC.List.badHead;
          : ipv_sfPjV [Occ=Once!] ipv1_sfPjW [Occ=Once] ->
              case _ys_sfPjT of {
                [] -> GHC.List.badHead;
                : ipv2_sfPjY [Occ=Once] ipv3_sfPjZ [Occ=Once] ->
                    case ipv_sfPjV of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPk2 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfPk2 Data.Semigroup.$fDataArg9 of {
                            GHC.Types.False -> go2_rfC6q ipv1_sfPjW ipv3_sfPjZ;
                            GHC.Types.True -> ipv2_sfPjY;
                          };
                    };
              };
        };

$cArg1_rfC6r :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cArg2_rfC6s];
Data.Semigroup.$fDataArg8 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cArg GHC.Types.[]];
Data.Semigroup.$fDataArg7 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataArg8];
Data.Semigroup.$tArg :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataArg9
                                       Data.Semigroup.$fDataArg7];
Data.Semigroup.$cArg [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cArg1_rfC6r
                                     Data.Semigroup.$fDataArg9
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Semigroup.$tArg];
$cArg2_rfC6s :: Data.Data.ConIndex
[GblId] =
    [] \u [] go2_rfC6q Data.Semigroup.$fDataArg8 Data.Data.mkConstr1;

$cFirst1_rfC6t :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadFirst5 GHC.Types.[]];

go3_rfC6u
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPk7 _ys_sfPk8]
        case ds2_sfPk7 of {
          [] -> GHC.List.badHead;
          : ipv_sfPka [Occ=Once!] ipv1_sfPkb [Occ=Once] ->
              case _ys_sfPk8 of {
                [] -> GHC.List.badHead;
                : ipv2_sfPkd [Occ=Once] ipv3_sfPke [Occ=Once] ->
                    case ipv_sfPka of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPkh [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfPkh Data.Semigroup.$fDataFirst7 of {
                            GHC.Types.False -> go3_rfC6u ipv1_sfPkb ipv3_sfPke;
                            GHC.Types.True -> ipv2_sfPkd;
                          };
                    };
              };
        };

$cFirst2_rfC6v :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cFirst3_rfC6w];
Data.Semigroup.$fDataFirst6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cFirst GHC.Types.[]];
Data.Semigroup.$fDataFirst5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataFirst6];
Data.Semigroup.$tFirst :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataFirst7
                                       Data.Semigroup.$fDataFirst5];
Data.Semigroup.$cFirst [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cFirst2_rfC6v
                                     Data.Semigroup.$fDataFirst7
                                     $cFirst1_rfC6t
                                     Data.Data.Prefix
                                     Data.Semigroup.$tFirst];
$cFirst3_rfC6w :: Data.Data.ConIndex
[GblId] =
    [] \u [] go3_rfC6u Data.Semigroup.$fDataFirst6 Data.Data.mkConstr1;

$cLast1_rfC6x :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadLast2 GHC.Types.[]];

go4_rfC6y
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPkm _ys_sfPkn]
        case ds2_sfPkm of {
          [] -> GHC.List.badHead;
          : ipv_sfPkp [Occ=Once!] ipv1_sfPkq [Occ=Once] ->
              case _ys_sfPkn of {
                [] -> GHC.List.badHead;
                : ipv2_sfPks [Occ=Once] ipv3_sfPkt [Occ=Once] ->
                    case ipv_sfPkp of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPkw [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfPkw Data.Semigroup.$fDataLast7 of {
                            GHC.Types.False -> go4_rfC6y ipv1_sfPkq ipv3_sfPkt;
                            GHC.Types.True -> ipv2_sfPks;
                          };
                    };
              };
        };

$cLast2_rfC6z :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cLast3_rfC6A];
Data.Semigroup.$fDataLast6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cLast GHC.Types.[]];
Data.Semigroup.$fDataLast5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataLast6];
Data.Semigroup.$tLast :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataLast7
                                       Data.Semigroup.$fDataLast5];
Data.Semigroup.$cLast [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cLast2_rfC6z
                                     Data.Semigroup.$fDataLast7
                                     $cLast1_rfC6x
                                     Data.Data.Prefix
                                     Data.Semigroup.$tLast];
$cLast3_rfC6A :: Data.Data.ConIndex
[GblId] =
    [] \u [] go4_rfC6y Data.Semigroup.$fDataLast6 Data.Data.mkConstr1;

Data.Semigroup.$fDataWrappedMonoid4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrappedMonoid"#;

Data.Semigroup.$fDataWrappedMonoid7 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.$fDataWrappedMonoid4;

$cWrapMonoid1_rfC6B :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadWrappedMonoid2
                      GHC.Types.[]];

go5_rfC6C
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPkB _ys_sfPkC]
        case ds2_sfPkB of {
          [] -> GHC.List.badHead;
          : ipv_sfPkE [Occ=Once!] ipv1_sfPkF [Occ=Once] ->
              case _ys_sfPkC of {
                [] -> GHC.List.badHead;
                : ipv2_sfPkH [Occ=Once] ipv3_sfPkI [Occ=Once] ->
                    case ipv_sfPkE of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPkL [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case
                              GHC.Base.eqString ds4_sfPkL Data.Semigroup.$fReadWrappedMonoid4
                          of
                          { GHC.Types.False -> go5_rfC6C ipv1_sfPkF ipv3_sfPkI;
                            GHC.Types.True -> ipv2_sfPkH;
                          };
                    };
              };
        };

$cWrapMonoid2_rfC6D :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cWrapMonoid3_rfC6E];
Data.Semigroup.$fDataWrappedMonoid6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cWrapMonoid GHC.Types.[]];
Data.Semigroup.$fDataWrappedMonoid5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataWrappedMonoid6];
Data.Semigroup.$tWrappedMonoid :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataWrappedMonoid7
                                       Data.Semigroup.$fDataWrappedMonoid5];
Data.Semigroup.$cWrapMonoid [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cWrapMonoid2_rfC6D
                                     Data.Semigroup.$fReadWrappedMonoid4
                                     $cWrapMonoid1_rfC6B
                                     Data.Data.Prefix
                                     Data.Semigroup.$tWrappedMonoid];
$cWrapMonoid3_rfC6E :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go5_rfC6C Data.Semigroup.$fDataWrappedMonoid6 Data.Data.mkConstr1;

$cOption1_rfC6F :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadOption2 GHC.Types.[]];

go6_rfC6G
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPkQ _ys_sfPkR]
        case ds2_sfPkQ of {
          [] -> GHC.List.badHead;
          : ipv_sfPkT [Occ=Once!] ipv1_sfPkU [Occ=Once] ->
              case _ys_sfPkR of {
                [] -> GHC.List.badHead;
                : ipv2_sfPkW [Occ=Once] ipv3_sfPkX [Occ=Once] ->
                    case ipv_sfPkT of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPl0 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfPl0 Data.Semigroup.$fDataOption9 of {
                            GHC.Types.False -> go6_rfC6G ipv1_sfPkU ipv3_sfPkX;
                            GHC.Types.True -> ipv2_sfPkW;
                          };
                    };
              };
        };

$cOption2_rfC6H :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cOption3_rfC6I];
Data.Semigroup.$fDataOption8 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cOption GHC.Types.[]];
Data.Semigroup.$fDataOption7 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataOption8];
Data.Semigroup.$tOption :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataOption9
                                       Data.Semigroup.$fDataOption7];
Data.Semigroup.$cOption [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cOption2_rfC6H
                                     Data.Semigroup.$fDataOption9
                                     $cOption1_rfC6F
                                     Data.Data.Prefix
                                     Data.Semigroup.$tOption];
$cOption3_rfC6I :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go6_rfC6G Data.Semigroup.$fDataOption8 Data.Data.mkConstr1;

Data.Semigroup.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Semigroup.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$trModule4];

Data.Semigroup.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Semigroup"#;

Data.Semigroup.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$trModule2];

Data.Semigroup.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Semigroup.$trModule3
                                     Data.Semigroup.$trModule1];

$krep_rfC6J :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_rfC6K :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_rfC6L :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rfC6K GHC.Types.[]];

$krep3_rfC6M :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep2_rfC6L];

Data.Semigroup.$fDataMin3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataMin4];

Data.Semigroup.$tcMin :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2898124504153588682##
                                    15185633012309158566##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataMin3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep4_rfC6N :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcMin
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Min1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep4_rfC6N];

Data.Semigroup.$tc'Min3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Min"#;

Data.Semigroup.$tc'Min2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Min3];

Data.Semigroup.$tc'Min :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7769702422559516318##
                                    9758175179672887730##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Min2
                                    1#
                                    Data.Semigroup.$tc'Min1];

Data.Semigroup.$fDataMin2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Min
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                2898124504153588682##
                15185633012309158566##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataMin3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPl6 [Occ=Once]
                   ww9_sfPl7 [Occ=Once]
                   ww10_sfPl8 [Occ=Once]
                   ww11_sfPl9 [Occ=Once]
                   ww12_sfPla [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPl6
                                              ww9_sfPl7
                                              ww10_sfPl8
                                              ww11_sfPl9
                                              ww12_sfPla];
        };

Data.Semigroup.$fDataMin8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Min a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPlb]
        case Data.Data.$p1Data $dData_sfPlb of sat_sfPlc {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp Data.Semigroup.$fDataMin2 sat_sfPlc;
        };

Data.Semigroup.$fDataMin_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Min a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPld $dTypeable_sfPle]
        let {
          lvl33_sfPlf [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPle] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPle Data.Semigroup.$fDataMin2; } in
        let {
          sat_sfPlj [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afxz6 (t_afxz5 d))
               -> GHC.Base.Maybe (c_afxz6 (Data.Semigroup.Min a_Xfy02))
          [LclId] =
              [$dData_sfPld lvl33_sfPlf] \r [f_sfPlg]
                  case lvl33_sfPlf of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPli [Occ=Once] :: c_afxz6 (Data.Semigroup.Min a_Xfy02)
                          [LclId] =
                              [$dData_sfPld f_sfPlg] \u [] f_sfPlg $dData_sfPld;
                        } in  GHC.Base.Just [sat_sfPli];
                  };
        } in  sat_sfPlj;

Data.Semigroup.$fDataMin1
  :: forall a. (a -> Data.Semigroup.Min a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataMin_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Min a -> m (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPlk $dMonadPlus_sfPll ds_sfPlm eta_sfPln]
        let {
          lvl33_sfPlo [Occ=OnceL] :: m_afxBb (Data.Semigroup.Min a_Xfy0b)
          [LclId] =
              [$dMonadPlus_sfPll] \u [] GHC.Base.mzero $dMonadPlus_sfPll;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPll
          of
          $dMonad_sfPlp [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPlL [Occ=Once]
                    :: (Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                       -> m_afxBb (Data.Semigroup.Min a_Xfy0b)
                  [LclId] =
                      [lvl33_sfPlo $dMonad_sfPlp] \r [ds1_sfPlG]
                          case ds1_sfPlG of {
                            (,) x'_sfPlI [Occ=Once] b_sfPlJ [Occ=Once!] ->
                                case b_sfPlJ of {
                                  GHC.Types.False -> lvl33_sfPlo;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPlp x'_sfPlI;
                                };
                          }; } in
                let {
                  sat_sfPlF [Occ=Once]
                    :: m_afxBb (Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPlk
                       $dMonadPlus_sfPll
                       ds_sfPlm
                       eta_sfPln
                       $dMonad_sfPlp] \u []
                          let {
                            lvl34_sfPlq [Occ=OnceL] :: m_afxBb a_Xfy0b
                            [LclId] =
                                [$dData_sfPlk ds_sfPlm eta_sfPln] \u []
                                    ds_sfPlm $dData_sfPlk eta_sfPln; } in
                          let {
                            sat_sfPlE [Occ=Once]
                              :: (a_Xfy0b -> Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                                 -> m_afxBb (Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPll
                                 eta_sfPln
                                 $dMonad_sfPlp
                                 lvl34_sfPlq] \r [ds1_sfPls]
                                    case ds1_sfPls of {
                                      (,) h_sfPlu b1_sfPlv [Occ=Once] ->
                                          let {
                                            sat_sfPlD [Occ=Once]
                                              :: m_afxBb (Data.Semigroup.Min a_Xfy0b,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfPln $dMonad_sfPlp h_sfPlu b1_sfPlv] \u []
                                                    let {
                                                      sat_sfPlB [Occ=Once]
                                                        :: Data.Semigroup.Min a_Xfy0b
                                                      [LclId] =
                                                          [eta_sfPln h_sfPlu] \u []
                                                              h_sfPlu eta_sfPln; } in
                                                    let {
                                                      sat_sfPlC [Occ=Once]
                                                        :: (Data.Semigroup.Min a_Xfy0b,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfPlB b1_sfPlv];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfPlp sat_sfPlC; } in
                                          let {
                                            sat_sfPlA [Occ=Once]
                                              :: m_afxBb (Data.Semigroup.Min a_Xfy0b,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfPlp lvl34_sfPlq h_sfPlu] \u []
                                                    let {
                                                      sat_sfPlz [Occ=Once]
                                                        :: a_Xfy0b
                                                           -> m_afxBb (Data.Semigroup.Min a_Xfy0b,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfPlp h_sfPlu] \r [y'_sfPlw]
                                                              let {
                                                                sat_sfPlx [Occ=Once]
                                                                  :: Data.Semigroup.Min a_Xfy0b
                                                                [LclId] =
                                                                    [h_sfPlu y'_sfPlw] \u []
                                                                        h_sfPlu y'_sfPlw; } in
                                                              let {
                                                                sat_sfPly [Occ=Once]
                                                                  :: (Data.Semigroup.Min a_Xfy0b,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfPlx
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfPlp sat_sfPly;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfPlp lvl34_sfPlq sat_sfPlz;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfPll sat_sfPlA sat_sfPlD;
                                    }; } in
                          let {
                            sat_sfPlr [Occ=Once]
                              :: m_afxBb (a_Xfy0b -> Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPlp] \u []
                                    GHC.Base.return $dMonad_sfPlp Data.Semigroup.$fDataMin1;
                          } in  GHC.Base.>>= $dMonad_sfPlp sat_sfPlr sat_sfPlE;
                } in  GHC.Base.>>= $dMonad_sfPlp sat_sfPlF sat_sfPlL;
          };

Data.Semigroup.$fDataMin_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Min a -> m (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPlM $dMonad_sfPlN ds_sfPlO eta_sfPlP]
        let {
          lvl33_sfPlQ [Occ=OnceL] :: m_afxAV a_Xfy0a
          [LclId] =
              [$dData_sfPlM ds_sfPlO eta_sfPlP] \u []
                  ds_sfPlO $dData_sfPlM eta_sfPlP; } in
        let {
          sat_sfPlW [Occ=Once]
            :: (a_Xfy0a -> Data.Semigroup.Min a_Xfy0a)
               -> m_afxAV (Data.Semigroup.Min a_Xfy0a)
          [LclId] =
              [$dMonad_sfPlN lvl33_sfPlQ] \r [c'_sfPlS]
                  let {
                    sat_sfPlV [Occ=Once]
                      :: a_Xfy0a -> m_afxAV (Data.Semigroup.Min a_Xfy0a)
                    [LclId] =
                        [$dMonad_sfPlN c'_sfPlS] \r [x'_sfPlT]
                            let {
                              sat_sfPlU [Occ=Once] :: Data.Semigroup.Min a_Xfy0a
                              [LclId] =
                                  [c'_sfPlS x'_sfPlT] \u [] c'_sfPlS x'_sfPlT;
                            } in  GHC.Base.return $dMonad_sfPlN sat_sfPlU;
                  } in  GHC.Base.>>= $dMonad_sfPlN lvl33_sfPlQ sat_sfPlV; } in
        let {
          sat_sfPlR [Occ=Once]
            :: m_afxAV (a_Xfy0a -> Data.Semigroup.Min a_Xfy0a)
          [LclId] =
              [$dMonad_sfPlN] \u []
                  GHC.Base.return $dMonad_sfPlN Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfPlN sat_sfPlR sat_sfPlW;

Data.Semigroup.$fDataMin_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Min a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPlX ds_sfPlY ds1_sfPlZ x_sfPm0]
        case ds_sfPlY of {
          GHC.Types.I# x1_sfPm2 [Occ=Once!] ->
              case x1_sfPm2 of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfPlZ $dData_sfPlX x_sfPm0;
              };
        };

Data.Semigroup.$fDataMin_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Min a -> m (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPm4 $dMonadPlus_sfPm5 ds_sfPm6 eta_sfPm7]
        let {
          lvl33_sfPm8 [Occ=OnceL] :: m_afxBr (Data.Semigroup.Min a_Xfy04)
          [LclId] =
              [$dMonadPlus_sfPm5] \u [] GHC.Base.mzero $dMonadPlus_sfPm5;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPm5
          of
          $dMonad_sfPm9 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPmy [Occ=Once]
                    :: (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                       -> m_afxBr (Data.Semigroup.Min a_Xfy04)
                  [LclId] =
                      [lvl33_sfPm8 $dMonad_sfPm9] \r [ds1_sfPmt]
                          case ds1_sfPmt of {
                            (,) x'_sfPmv [Occ=Once] b_sfPmw [Occ=Once!] ->
                                case b_sfPmw of {
                                  GHC.Types.False -> lvl33_sfPm8;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPm9 x'_sfPmv;
                                };
                          }; } in
                let {
                  sat_sfPms [Occ=Once]
                    :: m_afxBr (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPm4
                       $dMonadPlus_sfPm5
                       ds_sfPm6
                       eta_sfPm7
                       $dMonad_sfPm9] \u []
                          let {
                            lvl34_sfPma [Occ=OnceL] :: m_afxBr a_Xfy04
                            [LclId] =
                                [$dData_sfPm4 ds_sfPm6 eta_sfPm7] \u []
                                    ds_sfPm6 $dData_sfPm4 eta_sfPm7; } in
                          let {
                            sat_sfPmr [Occ=Once]
                              :: (a_Xfy04 -> Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                                 -> m_afxBr (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPm5
                                 eta_sfPm7
                                 $dMonad_sfPm9
                                 lvl34_sfPma] \r [ds1_sfPmc]
                                    case ds1_sfPmc of {
                                      (,) h_sfPme b1_sfPmf [Occ=Once!] ->
                                          case b1_sfPmf of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfPmo [Occ=Once]
                                                    :: m_afxBr (Data.Semigroup.Min a_Xfy04,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfPm7 $dMonad_sfPm9 h_sfPme] \u []
                                                          let {
                                                            sat_sfPmm [Occ=Once]
                                                              :: Data.Semigroup.Min a_Xfy04
                                                            [LclId] =
                                                                [eta_sfPm7 h_sfPme] \u []
                                                                    h_sfPme eta_sfPm7; } in
                                                          let {
                                                            sat_sfPmn [Occ=Once]
                                                              :: (Data.Semigroup.Min a_Xfy04,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfPmm
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfPm9 sat_sfPmn; } in
                                                let {
                                                  sat_sfPml [Occ=Once]
                                                    :: m_afxBr (Data.Semigroup.Min a_Xfy04,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfPm9 lvl34_sfPma h_sfPme] \u []
                                                          let {
                                                            sat_sfPmk [Occ=Once]
                                                              :: a_Xfy04
                                                                 -> m_afxBr (Data.Semigroup.Min
                                                                               a_Xfy04,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPm9
                                                                 h_sfPme] \r [y'_sfPmh]
                                                                    let {
                                                                      sat_sfPmi [Occ=Once]
                                                                        :: Data.Semigroup.Min
                                                                             a_Xfy04
                                                                      [LclId] =
                                                                          [h_sfPme y'_sfPmh] \u []
                                                                              h_sfPme y'_sfPmh; } in
                                                                    let {
                                                                      sat_sfPmj [Occ=Once]
                                                                        :: (Data.Semigroup.Min
                                                                              a_Xfy04,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPmi
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPm9 sat_sfPmj;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfPm9 lvl34_sfPma sat_sfPmk;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfPm5 sat_sfPml sat_sfPmo;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfPmp [Occ=Once] :: Data.Semigroup.Min a_Xfy04
                                                  [LclId] =
                                                      [eta_sfPm7 h_sfPme] \u []
                                                          h_sfPme eta_sfPm7; } in
                                                let {
                                                  sat_sfPmq [Occ=Once]
                                                    :: (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfPmp GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfPm9 sat_sfPmq;
                                          };
                                    }; } in
                          let {
                            sat_sfPmb [Occ=Once]
                              :: m_afxBr (a_Xfy04 -> Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPm9] \u []
                                    GHC.Base.return $dMonad_sfPm9 Data.Semigroup.$fDataMin1;
                          } in  GHC.Base.>>= $dMonad_sfPm9 sat_sfPmb sat_sfPmr;
                } in  GHC.Base.>>= $dMonad_sfPm9 sat_sfPms sat_sfPmy;
          };

lvl12_rfC6O :: forall a. Data.Semigroup.Min a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPmz] Data.Semigroup.$cMin;

lvl13_rfC6P :: forall a. Data.Semigroup.Min a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPmA] Data.Semigroup.$tMin;

lvl14_rfC6Q
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Min a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPmB ds_sfPmC] GHC.Base.Nothing [];

Data.Semigroup.$fDataMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPmD]
        let {
          sat_sfPn8 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Min a_Xfy03 -> m (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfPmD] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapMo
                      $dData_sfPmD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPn7 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Min a_Xfy03 -> m (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfPmD] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapMp
                      $dData_sfPmD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPn6 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Min a_Xfy03 -> m (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfPmD] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapM
                      $dData_sfPmD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPn5 [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Min a_Xfy03
               -> u
          [LclId] =
              [$dData_sfPmD] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapQi
                      $dData_sfPmD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPn4 [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Min a_Xfy03 -> [u]
          [LclId] =
              [$dData_sfPmD] \r [ds_sfPn1 x0_sfPn2]
                  let {
                    sat_sfPn3 [Occ=Once] :: u_afxAt
                    [LclId] =
                        [$dData_sfPmD ds_sfPn1 x0_sfPn2] \u []
                            ds_sfPn1 $dData_sfPmD x0_sfPn2;
                  } in  : [sat_sfPn3 GHC.Types.[]]; } in
        let {
          sat_sfPn0 [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Min a_Xfy03
               -> r
          [LclId] =
              [$dData_sfPmD] \r [ds_sfPmV ds1_sfPmW ds2_sfPmX x0_sfPmY]
                  let {
                    sat_sfPmZ [Occ=Once] :: r'_afxAd
                    [LclId] =
                        [$dData_sfPmD ds2_sfPmX x0_sfPmY] \u []
                            ds2_sfPmX $dData_sfPmD x0_sfPmY;
                  } in  ds_sfPmV sat_sfPmZ ds1_sfPmW; } in
        let {
          sat_sfPmU [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Min a_Xfy03
               -> r
          [LclId] =
              [$dData_sfPmD] \r [ds_sfPmP ds1_sfPmQ ds2_sfPmR eta_sfPmS]
                  let {
                    sat_sfPmT [Occ=Once] :: r'_afxzW
                    [LclId] =
                        [$dData_sfPmD ds2_sfPmR eta_sfPmS] \u []
                            ds2_sfPmR $dData_sfPmD eta_sfPmS;
                  } in  ds_sfPmP ds1_sfPmQ sat_sfPmT; } in
        let {
          sat_sfPmO [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Min a_Xfy03 -> Data.Semigroup.Min a_Xfy03
          [LclId] =
              [$dData_sfPmD] \r [ds_sfPmM x0_sfPmN]
                  ds_sfPmM $dData_sfPmD x0_sfPmN; } in
        let {
          sat_sfPmL [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Min a_Xfy03))
          [LclId] =
              [$dData_sfPmD] \r [eta_B1]
                  Data.Semigroup.$fDataMin_$cdataCast1 $dData_sfPmD eta_B1; } in
        let {
          sat_sfPmK [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfPmD] \r [k_sfPmG z_sfPmH ds_sfPmI]
                  let {
                    sat_sfPmJ [Occ=Once]
                      :: c_afxyM (a_Xfy03 -> Data.Semigroup.Min a_Xfy03)
                    [LclId] =
                        [z_sfPmH] \u [] z_sfPmH Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfPmG $dData_sfPmD sat_sfPmJ; } in
        let {
          sat_sfPmF [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Min a_Xfy03
               -> c (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfPmD] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgfoldl
                      $dData_sfPmD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPmE [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfPmD] \u [] Data.Semigroup.$fDataMin8 $dData_sfPmD;
        } in 
          Data.Data.C:Data [sat_sfPmE
                            sat_sfPmF
                            sat_sfPmK
                            lvl12_rfC6O
                            lvl13_rfC6P
                            sat_sfPmL
                            lvl14_rfC6Q
                            sat_sfPmO
                            sat_sfPmU
                            sat_sfPn0
                            sat_sfPn4
                            sat_sfPn5
                            sat_sfPn6
                            sat_sfPn7
                            sat_sfPn8];

Data.Semigroup.$fDataMax3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataMax4];

Data.Semigroup.$tcMax :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10813679156066679206##
                                    10491840004411982061##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataMax3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep5_rfC6R :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcMax
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Max1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep5_rfC6R];

Data.Semigroup.$tc'Max3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Max"#;

Data.Semigroup.$tc'Max2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Max3];

Data.Semigroup.$tc'Max :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9964620667386625613##
                                    8300955803911017019##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Max2
                                    1#
                                    Data.Semigroup.$tc'Max1];

Data.Semigroup.$fDataMax2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Max
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                10813679156066679206##
                10491840004411982061##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataMax3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPna [Occ=Once]
                   ww9_sfPnb [Occ=Once]
                   ww10_sfPnc [Occ=Once]
                   ww11_sfPnd [Occ=Once]
                   ww12_sfPne [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPna
                                              ww9_sfPnb
                                              ww10_sfPnc
                                              ww11_sfPnd
                                              ww12_sfPne];
        };

Data.Semigroup.$fDataMax8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Max a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPnf]
        case Data.Data.$p1Data $dData_sfPnf of sat_sfPng {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp Data.Semigroup.$fDataMax2 sat_sfPng;
        };

Data.Semigroup.$fDataMax_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Max a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPnh $dTypeable_sfPni]
        let {
          lvl33_sfPnj [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPni] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPni Data.Semigroup.$fDataMax2; } in
        let {
          sat_sfPnn [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afxI8 (t_afxI7 d))
               -> GHC.Base.Maybe (c_afxI8 (Data.Semigroup.Max a_Xfy9s))
          [LclId] =
              [$dData_sfPnh lvl33_sfPnj] \r [f_sfPnk]
                  case lvl33_sfPnj of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPnm [Occ=Once] :: c_afxI8 (Data.Semigroup.Max a_Xfy9s)
                          [LclId] =
                              [$dData_sfPnh f_sfPnk] \u [] f_sfPnk $dData_sfPnh;
                        } in  GHC.Base.Just [sat_sfPnm];
                  };
        } in  sat_sfPnn;

Data.Semigroup.$fDataMax1
  :: forall a. (a -> Data.Semigroup.Max a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataMax_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Max a -> m (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPno $dMonadPlus_sfPnp ds_sfPnq eta_sfPnr]
        let {
          lvl33_sfPns [Occ=OnceL] :: m_afxKd (Data.Semigroup.Max a_Xfy9B)
          [LclId] =
              [$dMonadPlus_sfPnp] \u [] GHC.Base.mzero $dMonadPlus_sfPnp;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPnp
          of
          $dMonad_sfPnt [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPnP [Occ=Once]
                    :: (Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                       -> m_afxKd (Data.Semigroup.Max a_Xfy9B)
                  [LclId] =
                      [lvl33_sfPns $dMonad_sfPnt] \r [ds1_sfPnK]
                          case ds1_sfPnK of {
                            (,) x'_sfPnM [Occ=Once] b_sfPnN [Occ=Once!] ->
                                case b_sfPnN of {
                                  GHC.Types.False -> lvl33_sfPns;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPnt x'_sfPnM;
                                };
                          }; } in
                let {
                  sat_sfPnJ [Occ=Once]
                    :: m_afxKd (Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPno
                       $dMonadPlus_sfPnp
                       ds_sfPnq
                       eta_sfPnr
                       $dMonad_sfPnt] \u []
                          let {
                            lvl34_sfPnu [Occ=OnceL] :: m_afxKd a_Xfy9B
                            [LclId] =
                                [$dData_sfPno ds_sfPnq eta_sfPnr] \u []
                                    ds_sfPnq $dData_sfPno eta_sfPnr; } in
                          let {
                            sat_sfPnI [Occ=Once]
                              :: (a_Xfy9B -> Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                                 -> m_afxKd (Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPnp
                                 eta_sfPnr
                                 $dMonad_sfPnt
                                 lvl34_sfPnu] \r [ds1_sfPnw]
                                    case ds1_sfPnw of {
                                      (,) h_sfPny b1_sfPnz [Occ=Once] ->
                                          let {
                                            sat_sfPnH [Occ=Once]
                                              :: m_afxKd (Data.Semigroup.Max a_Xfy9B,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfPnr $dMonad_sfPnt h_sfPny b1_sfPnz] \u []
                                                    let {
                                                      sat_sfPnF [Occ=Once]
                                                        :: Data.Semigroup.Max a_Xfy9B
                                                      [LclId] =
                                                          [eta_sfPnr h_sfPny] \u []
                                                              h_sfPny eta_sfPnr; } in
                                                    let {
                                                      sat_sfPnG [Occ=Once]
                                                        :: (Data.Semigroup.Max a_Xfy9B,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfPnF b1_sfPnz];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfPnt sat_sfPnG; } in
                                          let {
                                            sat_sfPnE [Occ=Once]
                                              :: m_afxKd (Data.Semigroup.Max a_Xfy9B,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfPnt lvl34_sfPnu h_sfPny] \u []
                                                    let {
                                                      sat_sfPnD [Occ=Once]
                                                        :: a_Xfy9B
                                                           -> m_afxKd (Data.Semigroup.Max a_Xfy9B,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfPnt h_sfPny] \r [y'_sfPnA]
                                                              let {
                                                                sat_sfPnB [Occ=Once]
                                                                  :: Data.Semigroup.Max a_Xfy9B
                                                                [LclId] =
                                                                    [h_sfPny y'_sfPnA] \u []
                                                                        h_sfPny y'_sfPnA; } in
                                                              let {
                                                                sat_sfPnC [Occ=Once]
                                                                  :: (Data.Semigroup.Max a_Xfy9B,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfPnB
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfPnt sat_sfPnC;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfPnt lvl34_sfPnu sat_sfPnD;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfPnp sat_sfPnE sat_sfPnH;
                                    }; } in
                          let {
                            sat_sfPnv [Occ=Once]
                              :: m_afxKd (a_Xfy9B -> Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPnt] \u []
                                    GHC.Base.return $dMonad_sfPnt Data.Semigroup.$fDataMax1;
                          } in  GHC.Base.>>= $dMonad_sfPnt sat_sfPnv sat_sfPnI;
                } in  GHC.Base.>>= $dMonad_sfPnt sat_sfPnJ sat_sfPnP;
          };

Data.Semigroup.$fDataMax_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Max a -> m (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPnQ $dMonad_sfPnR ds_sfPnS eta_sfPnT]
        let {
          lvl33_sfPnU [Occ=OnceL] :: m_afxJX a_Xfy9A
          [LclId] =
              [$dData_sfPnQ ds_sfPnS eta_sfPnT] \u []
                  ds_sfPnS $dData_sfPnQ eta_sfPnT; } in
        let {
          sat_sfPo0 [Occ=Once]
            :: (a_Xfy9A -> Data.Semigroup.Max a_Xfy9A)
               -> m_afxJX (Data.Semigroup.Max a_Xfy9A)
          [LclId] =
              [$dMonad_sfPnR lvl33_sfPnU] \r [c'_sfPnW]
                  let {
                    sat_sfPnZ [Occ=Once]
                      :: a_Xfy9A -> m_afxJX (Data.Semigroup.Max a_Xfy9A)
                    [LclId] =
                        [$dMonad_sfPnR c'_sfPnW] \r [x'_sfPnX]
                            let {
                              sat_sfPnY [Occ=Once] :: Data.Semigroup.Max a_Xfy9A
                              [LclId] =
                                  [c'_sfPnW x'_sfPnX] \u [] c'_sfPnW x'_sfPnX;
                            } in  GHC.Base.return $dMonad_sfPnR sat_sfPnY;
                  } in  GHC.Base.>>= $dMonad_sfPnR lvl33_sfPnU sat_sfPnZ; } in
        let {
          sat_sfPnV [Occ=Once]
            :: m_afxJX (a_Xfy9A -> Data.Semigroup.Max a_Xfy9A)
          [LclId] =
              [$dMonad_sfPnR] \u []
                  GHC.Base.return $dMonad_sfPnR Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfPnR sat_sfPnV sat_sfPo0;

Data.Semigroup.$fDataMax_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Max a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPo1 ds_sfPo2 ds1_sfPo3 x_sfPo4]
        case ds_sfPo2 of {
          GHC.Types.I# x1_sfPo6 [Occ=Once!] ->
              case x1_sfPo6 of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfPo3 $dData_sfPo1 x_sfPo4;
              };
        };

Data.Semigroup.$fDataMax_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Max a -> m (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPo8 $dMonadPlus_sfPo9 ds_sfPoa eta_sfPob]
        let {
          lvl33_sfPoc [Occ=OnceL] :: m_afxKt (Data.Semigroup.Max a_Xfy9u)
          [LclId] =
              [$dMonadPlus_sfPo9] \u [] GHC.Base.mzero $dMonadPlus_sfPo9;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPo9
          of
          $dMonad_sfPod [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPoC [Occ=Once]
                    :: (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                       -> m_afxKt (Data.Semigroup.Max a_Xfy9u)
                  [LclId] =
                      [lvl33_sfPoc $dMonad_sfPod] \r [ds1_sfPox]
                          case ds1_sfPox of {
                            (,) x'_sfPoz [Occ=Once] b_sfPoA [Occ=Once!] ->
                                case b_sfPoA of {
                                  GHC.Types.False -> lvl33_sfPoc;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPod x'_sfPoz;
                                };
                          }; } in
                let {
                  sat_sfPow [Occ=Once]
                    :: m_afxKt (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPo8
                       $dMonadPlus_sfPo9
                       ds_sfPoa
                       eta_sfPob
                       $dMonad_sfPod] \u []
                          let {
                            lvl34_sfPoe [Occ=OnceL] :: m_afxKt a_Xfy9u
                            [LclId] =
                                [$dData_sfPo8 ds_sfPoa eta_sfPob] \u []
                                    ds_sfPoa $dData_sfPo8 eta_sfPob; } in
                          let {
                            sat_sfPov [Occ=Once]
                              :: (a_Xfy9u -> Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                                 -> m_afxKt (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPo9
                                 eta_sfPob
                                 $dMonad_sfPod
                                 lvl34_sfPoe] \r [ds1_sfPog]
                                    case ds1_sfPog of {
                                      (,) h_sfPoi b1_sfPoj [Occ=Once!] ->
                                          case b1_sfPoj of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfPos [Occ=Once]
                                                    :: m_afxKt (Data.Semigroup.Max a_Xfy9u,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfPob $dMonad_sfPod h_sfPoi] \u []
                                                          let {
                                                            sat_sfPoq [Occ=Once]
                                                              :: Data.Semigroup.Max a_Xfy9u
                                                            [LclId] =
                                                                [eta_sfPob h_sfPoi] \u []
                                                                    h_sfPoi eta_sfPob; } in
                                                          let {
                                                            sat_sfPor [Occ=Once]
                                                              :: (Data.Semigroup.Max a_Xfy9u,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfPoq
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfPod sat_sfPor; } in
                                                let {
                                                  sat_sfPop [Occ=Once]
                                                    :: m_afxKt (Data.Semigroup.Max a_Xfy9u,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfPod lvl34_sfPoe h_sfPoi] \u []
                                                          let {
                                                            sat_sfPoo [Occ=Once]
                                                              :: a_Xfy9u
                                                                 -> m_afxKt (Data.Semigroup.Max
                                                                               a_Xfy9u,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPod
                                                                 h_sfPoi] \r [y'_sfPol]
                                                                    let {
                                                                      sat_sfPom [Occ=Once]
                                                                        :: Data.Semigroup.Max
                                                                             a_Xfy9u
                                                                      [LclId] =
                                                                          [h_sfPoi y'_sfPol] \u []
                                                                              h_sfPoi y'_sfPol; } in
                                                                    let {
                                                                      sat_sfPon [Occ=Once]
                                                                        :: (Data.Semigroup.Max
                                                                              a_Xfy9u,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPom
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPod sat_sfPon;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfPod lvl34_sfPoe sat_sfPoo;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfPo9 sat_sfPop sat_sfPos;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfPot [Occ=Once] :: Data.Semigroup.Max a_Xfy9u
                                                  [LclId] =
                                                      [eta_sfPob h_sfPoi] \u []
                                                          h_sfPoi eta_sfPob; } in
                                                let {
                                                  sat_sfPou [Occ=Once]
                                                    :: (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfPot GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfPod sat_sfPou;
                                          };
                                    }; } in
                          let {
                            sat_sfPof [Occ=Once]
                              :: m_afxKt (a_Xfy9u -> Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPod] \u []
                                    GHC.Base.return $dMonad_sfPod Data.Semigroup.$fDataMax1;
                          } in  GHC.Base.>>= $dMonad_sfPod sat_sfPof sat_sfPov;
                } in  GHC.Base.>>= $dMonad_sfPod sat_sfPow sat_sfPoC;
          };

lvl15_rfC6S :: forall a. Data.Semigroup.Max a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPoD] Data.Semigroup.$cMax;

lvl16_rfC6T :: forall a. Data.Semigroup.Max a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPoE] Data.Semigroup.$tMax;

lvl17_rfC6U
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Max a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPoF ds_sfPoG] GHC.Base.Nothing [];

Data.Semigroup.$fDataMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPoH]
        let {
          sat_sfPpc [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Max a_Xfy9t -> m (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfPoH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapMo
                      $dData_sfPoH eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPpb [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Max a_Xfy9t -> m (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfPoH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapMp
                      $dData_sfPoH eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPpa [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Max a_Xfy9t -> m (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfPoH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapM
                      $dData_sfPoH eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPp9 [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Max a_Xfy9t
               -> u
          [LclId] =
              [$dData_sfPoH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapQi
                      $dData_sfPoH eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPp8 [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Max a_Xfy9t -> [u]
          [LclId] =
              [$dData_sfPoH] \r [ds_sfPp5 x0_sfPp6]
                  let {
                    sat_sfPp7 [Occ=Once] :: u_afxJv
                    [LclId] =
                        [$dData_sfPoH ds_sfPp5 x0_sfPp6] \u []
                            ds_sfPp5 $dData_sfPoH x0_sfPp6;
                  } in  : [sat_sfPp7 GHC.Types.[]]; } in
        let {
          sat_sfPp4 [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Max a_Xfy9t
               -> r
          [LclId] =
              [$dData_sfPoH] \r [ds_sfPoZ ds1_sfPp0 ds2_sfPp1 x0_sfPp2]
                  let {
                    sat_sfPp3 [Occ=Once] :: r'_afxJf
                    [LclId] =
                        [$dData_sfPoH ds2_sfPp1 x0_sfPp2] \u []
                            ds2_sfPp1 $dData_sfPoH x0_sfPp2;
                  } in  ds_sfPoZ sat_sfPp3 ds1_sfPp0; } in
        let {
          sat_sfPoY [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Max a_Xfy9t
               -> r
          [LclId] =
              [$dData_sfPoH] \r [ds_sfPoT ds1_sfPoU ds2_sfPoV eta_sfPoW]
                  let {
                    sat_sfPoX [Occ=Once] :: r'_afxIY
                    [LclId] =
                        [$dData_sfPoH ds2_sfPoV eta_sfPoW] \u []
                            ds2_sfPoV $dData_sfPoH eta_sfPoW;
                  } in  ds_sfPoT ds1_sfPoU sat_sfPoX; } in
        let {
          sat_sfPoS [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Max a_Xfy9t -> Data.Semigroup.Max a_Xfy9t
          [LclId] =
              [$dData_sfPoH] \r [ds_sfPoQ x0_sfPoR]
                  ds_sfPoQ $dData_sfPoH x0_sfPoR; } in
        let {
          sat_sfPoP [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Max a_Xfy9t))
          [LclId] =
              [$dData_sfPoH] \r [eta_B1]
                  Data.Semigroup.$fDataMax_$cdataCast1 $dData_sfPoH eta_B1; } in
        let {
          sat_sfPoO [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfPoH] \r [k_sfPoK z_sfPoL ds_sfPoM]
                  let {
                    sat_sfPoN [Occ=Once]
                      :: c_afxHO (a_Xfy9t -> Data.Semigroup.Max a_Xfy9t)
                    [LclId] =
                        [z_sfPoL] \u [] z_sfPoL Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfPoK $dData_sfPoH sat_sfPoN; } in
        let {
          sat_sfPoJ [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Max a_Xfy9t
               -> c (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfPoH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgfoldl
                      $dData_sfPoH eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPoI [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfPoH] \u [] Data.Semigroup.$fDataMax8 $dData_sfPoH;
        } in 
          Data.Data.C:Data [sat_sfPoI
                            sat_sfPoJ
                            sat_sfPoO
                            lvl15_rfC6S
                            lvl16_rfC6T
                            sat_sfPoP
                            lvl17_rfC6U
                            sat_sfPoS
                            sat_sfPoY
                            sat_sfPp4
                            sat_sfPp8
                            sat_sfPp9
                            sat_sfPpa
                            sat_sfPpb
                            sat_sfPpc];

Data.Semigroup.$fDataArg5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataArg6];

Data.Semigroup.$tcArg :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12181131229304595757##
                                    13964868205162960136##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataArg5
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep6_rfC6V :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rfC6J GHC.Types.[]];

$krep7_rfC6W :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rfC6K $krep6_rfC6V];

$krep8_rfC6X :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcArg
                                              $krep7_rfC6W];

$krep9_rfC6Y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rfC6J $krep8_rfC6X];

Data.Semigroup.$tc'Arg1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep9_rfC6Y];

Data.Semigroup.$tc'Arg3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Arg"#;

Data.Semigroup.$tc'Arg2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Arg3];

Data.Semigroup.$tc'Arg :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1079323530693211499##
                                    7260223244427450599##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Arg2
                                    2#
                                    Data.Semigroup.$tc'Arg1];

Data.Semigroup.$fDataArg4
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Arg
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                12181131229304595757##
                13964868205162960136##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataArg5
                0#
                GHC.Types.krep$*->*->*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPpe [Occ=Once]
                   ww9_sfPpf [Occ=Once]
                   ww10_sfPpg [Occ=Once]
                   ww11_sfPph [Occ=Once]
                   ww12_sfPpi [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPpe
                                              ww9_sfPpf
                                              ww10_sfPpg
                                              ww11_sfPph
                                              ww12_sfPpi];
        };

Data.Semigroup.$fDataArg10
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Arg a b)
[GblId,
 Arity=2,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPpj $dData1_sfPpk]
        case Data.Data.$p1Data $dData1_sfPpk of sat_sfPpn {
          __DEFAULT ->
              case Data.Data.$p1Data $dData_sfPpj of sat_sfPpl {
                __DEFAULT ->
                    case
                        Data.Typeable.Internal.mkTrApp Data.Semigroup.$fDataArg4 sat_sfPpl
                    of
                    sat_sfPpm
                    { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sfPpm sat_sfPpn;
                    };
              };
        };

Data.Semigroup.$fDataArg_$cdataCast2
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Arg a b))
[GblId, Arity=3, Str=<L,U><L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPpo $dData1_sfPpp $dTypeable_sfPpq]
        let {
          lvl33_sfPpr [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPpq] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPpq Data.Semigroup.$fDataArg4; } in
        let {
          sat_sfPpv [Occ=OnceT[0]]
            :: (forall d e.
                (Data.Data.Data d, Data.Data.Data e) =>
                c_afxP3 (t_afxP2 d e))
               -> GHC.Base.Maybe (c_afxP3 (Data.Semigroup.Arg a_Xfygm b_Xfygo))
          [LclId] =
              [$dData_sfPpo $dData1_sfPpp lvl33_sfPpr] \r [f_sfPps]
                  case lvl33_sfPpr of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPpu [Occ=Once]
                            :: c_afxP3 (Data.Semigroup.Arg a_Xfygm b_Xfygo)
                          [LclId] =
                              [$dData_sfPpo $dData1_sfPpp f_sfPps] \u []
                                  f_sfPps $dData_sfPpo $dData1_sfPpp;
                        } in  GHC.Base.Just [sat_sfPpu];
                  };
        } in  sat_sfPpv;

Data.Semigroup.$fDataArg1
  :: forall b a. (a -> b -> Data.Semigroup.Arg a b, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.Arg GHC.Types.False];

Data.Semigroup.$fDataArg_$cgmapMp
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Arg a b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPpw
           $dData1_sfPpx
           $dMonadPlus_sfPpy
           ds_sfPpz
           eta_sfPpA]
        let {
          lvl33_sfPpB [Occ=OnceL]
            :: m_afxQP (Data.Semigroup.Arg a_Xfygv b_Xfygx)
          [LclId] =
              [$dMonadPlus_sfPpy] \u [] GHC.Base.mzero $dMonadPlus_sfPpy;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPpy
          of
          $dMonad_sfPpC [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPq6 [Occ=Once]
                    :: (Data.Semigroup.Arg a_Xfygv b_Xfygx, GHC.Types.Bool)
                       -> m_afxQP (Data.Semigroup.Arg a_Xfygv b_Xfygx)
                  [LclId] =
                      [lvl33_sfPpB $dMonad_sfPpC] \r [ds1_sfPq1]
                          case ds1_sfPq1 of {
                            (,) x'_sfPq3 [Occ=Once] b1_sfPq4 [Occ=Once!] ->
                                case b1_sfPq4 of {
                                  GHC.Types.False -> lvl33_sfPpB;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPpC x'_sfPq3;
                                };
                          }; } in
                let {
                  sat_sfPq0 [Occ=Once]
                    :: m_afxQP (Data.Semigroup.Arg a_Xfygv b_Xfygx, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPpw
                       $dData1_sfPpx
                       $dMonadPlus_sfPpy
                       ds_sfPpz
                       eta_sfPpA
                       $dMonad_sfPpC] \u []
                          case eta_sfPpA of {
                            Data.Semigroup.Arg a1_sfPpE [Occ=Once] a2_sfPpF [Occ=Once] ->
                                let {
                                  k_sfPpG [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b1.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_afxQP (d -> b1)
                                       -> d -> m_afxQP (b1, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sfPpy
                                                ds_sfPpz
                                                $dMonad_sfPpC] \r [$dData2_sfPpH ds1_sfPpI y_sfPpJ]
                                          let {
                                            lvl34_sfPpK [Occ=OnceL] :: m_afxQP d_ae2Ws
                                            [LclId] =
                                                [ds_sfPpz $dData2_sfPpH y_sfPpJ] \u []
                                                    ds_sfPpz $dData2_sfPpH y_sfPpJ; } in
                                          let {
                                            sat_sfPpX [Occ=Once]
                                              :: (d_ae2Ws -> b1_ae2Wt, GHC.Types.Bool)
                                                 -> m_afxQP (b1_ae2Wt, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sfPpy
                                                 $dMonad_sfPpC
                                                 y_sfPpJ
                                                 lvl34_sfPpK] \r [ds2_sfPpL]
                                                    case ds2_sfPpL of {
                                                      (,) h_sfPpN b2_sfPpO [Occ=Once] ->
                                                          let {
                                                            sat_sfPpW [Occ=Once]
                                                              :: m_afxQP (b1_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPpC
                                                                 y_sfPpJ
                                                                 h_sfPpN
                                                                 b2_sfPpO] \u []
                                                                    let {
                                                                      sat_sfPpU [Occ=Once]
                                                                        :: b1_ae2Wt
                                                                      [LclId] =
                                                                          [y_sfPpJ h_sfPpN] \u []
                                                                              h_sfPpN y_sfPpJ; } in
                                                                    let {
                                                                      sat_sfPpV [Occ=Once]
                                                                        :: (b1_ae2Wt,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPpU
                                                                                     b2_sfPpO];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPpC
                                                                          sat_sfPpV; } in
                                                          let {
                                                            sat_sfPpT [Occ=Once]
                                                              :: m_afxQP (b1_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPpC
                                                                 lvl34_sfPpK
                                                                 h_sfPpN] \u []
                                                                    let {
                                                                      sat_sfPpS [Occ=Once]
                                                                        :: d_ae2Ws
                                                                           -> m_afxQP (b1_ae2Wt,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sfPpC
                                                                           h_sfPpN] \r [y'_sfPpP]
                                                                              let {
                                                                                sat_sfPpQ [Occ=Once]
                                                                                  :: b1_ae2Wt
                                                                                [LclId] =
                                                                                    [h_sfPpN
                                                                                     y'_sfPpP] \u []
                                                                                        h_sfPpN
                                                                                            y'_sfPpP; } in
                                                                              let {
                                                                                sat_sfPpR [Occ=Once]
                                                                                  :: (b1_ae2Wt,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sfPpQ
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sfPpC
                                                                                    sat_sfPpR;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sfPpC
                                                                          lvl34_sfPpK
                                                                          sat_sfPpS;
                                                          } in 
                                                            GHC.Base.mplus
                                                                $dMonadPlus_sfPpy
                                                                sat_sfPpT
                                                                sat_sfPpW;
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sfPpC ds1_sfPpI sat_sfPpX; } in
                                let {
                                  sat_sfPpZ [Occ=Once]
                                    :: Data.Data.Mp
                                         m_afxQP (b_Xfygx -> Data.Semigroup.Arg a_Xfygv b_Xfygx)
                                  [LclId] =
                                      [$dData_sfPpw $dMonad_sfPpC a1_sfPpE k_sfPpG] \u []
                                          let {
                                            sat_sfPpY [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_afxQP
                                                   (a_Xfygv
                                                    -> b_Xfygx
                                                    -> Data.Semigroup.Arg a_Xfygv b_Xfygx)
                                            [LclId] =
                                                [$dMonad_sfPpC] \u []
                                                    GHC.Base.return
                                                        $dMonad_sfPpC Data.Semigroup.$fDataArg1;
                                          } in  k_sfPpG $dData_sfPpw sat_sfPpY a1_sfPpE;
                                } in  k_sfPpG $dData1_sfPpx sat_sfPpZ a2_sfPpF;
                          };
                } in  GHC.Base.>>= $dMonad_sfPpC sat_sfPq0 sat_sfPq6;
          };

Data.Semigroup.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> a -> b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPq7 w1_sfPq8 w2_sfPq9 w3_sfPqa ww_sfPqb ww1_sfPqc]
        let {
          k_sfPqd [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
            :: forall d b1.
               Data.Data.Data d =>
               m_sfBu8 (d -> b1) -> d -> m_sfBu8 b1
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w2_sfPq9 w3_sfPqa] \r [$dData1_sfPqe c_sfPqf x_sfPqg]
                  let {
                    lvl33_sfPqh [Occ=OnceL] :: m_sfBu8 d_ae2Vh
                    [LclId] =
                        [w3_sfPqa $dData1_sfPqe x_sfPqg] \u []
                            w3_sfPqa $dData1_sfPqe x_sfPqg; } in
                  let {
                    sat_sfPqm [Occ=Once] :: (d_ae2Vh -> b1_ae2Vi) -> m_sfBu8 b1_ae2Vi
                    [LclId] =
                        [w2_sfPq9 lvl33_sfPqh] \r [c'_sfPqi]
                            let {
                              sat_sfPql [Occ=Once] :: d_ae2Vh -> m_sfBu8 b1_ae2Vi
                              [LclId] =
                                  [w2_sfPq9 c'_sfPqi] \r [x'_sfPqj]
                                      let {
                                        sat_sfPqk [Occ=Once] :: b1_ae2Vi
                                        [LclId] =
                                            [c'_sfPqi x'_sfPqj] \u [] c'_sfPqi x'_sfPqj;
                                      } in  GHC.Base.return w2_sfPq9 sat_sfPqk;
                            } in  GHC.Base.>>= w2_sfPq9 lvl33_sfPqh sat_sfPql;
                  } in  GHC.Base.>>= w2_sfPq9 c_sfPqf sat_sfPqm; } in
        let {
          sat_sfPqo [Occ=Once]
            :: m_sfBu8 (b_sfBu5 -> Data.Semigroup.Arg a_sfBu4 b_sfBu5)
          [LclId] =
              [w_sfPq7 w2_sfPq9 ww_sfPqb k_sfPqd] \u []
                  let {
                    sat_sfPqn [Occ=Once]
                      :: m_sfBu8 (a_sfBu4
                                  -> b_sfBu5 -> Data.Semigroup.Arg a_sfBu4 b_sfBu5)
                    [LclId] =
                        [w2_sfPq9] \u [] GHC.Base.return w2_sfPq9 Data.Semigroup.Arg;
                  } in  k_sfPqd w_sfPq7 sat_sfPqn ww_sfPqb;
        } in  k_sfPqd w1_sfPq8 sat_sfPqo ww1_sfPqc;

Data.Semigroup.$fDataArg_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Arg a b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sfPqp w1_sfPqq w2_sfPqr w3_sfPqs w4_sfPqt]
        case w4_sfPqt of {
          Data.Semigroup.Arg ww1_sfPqv [Occ=Once] ww2_sfPqw [Occ=Once] ->
              Data.Semigroup.$w$cgmapM
                  w_sfPqp w1_sfPqq w2_sfPqr w3_sfPqs ww1_sfPqv ww2_sfPqw;
        };

Data.Semigroup.$fDataArg_$cgmapQi
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Arg a b
     -> u
[GblId,
 Arity=5,
 Str=<L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPqx $dData1_sfPqy ds_sfPqz ds1_sfPqA x_sfPqB]
        case x_sfPqB of {
          Data.Semigroup.Arg a1_sfPqD [Occ=Once] a2_sfPqE [Occ=Once] ->
              case ds_sfPqz of {
                GHC.Types.I# x1_sfPqG [Occ=Once!] ->
                    case x1_sfPqG of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sfPqA $dData_sfPqx a1_sfPqD;
                      1# -> ds1_sfPqA $dData1_sfPqy a2_sfPqE;
                    };
              };
        };

Data.Semigroup.$fDataArg_$cgmapQr
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Arg a b
     -> r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPqI
           $dData1_sfPqJ
           ds_sfPqK
           ds1_sfPqL
           ds2_sfPqM
           x0_sfPqN]
        case x0_sfPqN of {
          Data.Semigroup.Arg a1_sfPqP [Occ=Once] a2_sfPqQ [Occ=Once] ->
              let {
                sat_sfPqT [Occ=Once] :: r_afxPQ
                [LclId] =
                    [$dData1_sfPqJ ds_sfPqK ds1_sfPqL ds2_sfPqM a2_sfPqQ] \u []
                        let {
                          sat_sfPqS [Occ=Once] :: r'_afxPR
                          [LclId] =
                              [$dData1_sfPqJ ds2_sfPqM a2_sfPqQ] \u []
                                  ds2_sfPqM $dData1_sfPqJ a2_sfPqQ;
                        } in  ds_sfPqK sat_sfPqS ds1_sfPqL; } in
              let {
                sat_sfPqR [Occ=Once] :: r'_afxPR
                [LclId] =
                    [$dData_sfPqI ds2_sfPqM a1_sfPqP] \u []
                        ds2_sfPqM $dData_sfPqI a1_sfPqP;
              } in  ds_sfPqK sat_sfPqR sat_sfPqT;
        };

Data.Semigroup.$fDataArg_$cgmapQ
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Arg a b -> [u]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,C(C1(U))><S,1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [$dData_sfPqU $dData1_sfPqV ds_sfPqW x0_sfPqX]
        case x0_sfPqX of {
          Data.Semigroup.Arg a1_sfPqZ [Occ=Once] a2_sfPr0 [Occ=Once] ->
              let {
                sat_sfPr2 [Occ=Once] :: u_afxQ7
                [LclId] =
                    [$dData1_sfPqV ds_sfPqW a2_sfPr0] \u []
                        ds_sfPqW $dData1_sfPqV a2_sfPr0; } in
              let {
                sat_sfPr3 [Occ=Once] :: [u_afxQ7]
                [LclId] =
                    CCCS :! [sat_sfPr2 GHC.Types.[]]; } in
              let {
                sat_sfPr1 [Occ=Once] :: u_afxQ7
                [LclId] =
                    [$dData_sfPqU ds_sfPqW a1_sfPqZ] \u []
                        ds_sfPqW $dData_sfPqU a1_sfPqZ;
              } in  : [sat_sfPr1 sat_sfPr3];
        };

Data.Semigroup.$fDataArg2
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Arg a b
     -> Data.Functor.Const.Const r (Data.Semigroup.Arg a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPr4
           $dData1_sfPr5
           ds_sfPr6
           ds1_sfPr7
           ds2_sfPr8
           eta_sfPr9]
        case eta_sfPr9 of {
          Data.Semigroup.Arg a1_sfPrb [Occ=Once] a2_sfPrc [Occ=Once] ->
              let {
                sat_sfPrf [Occ=Once] :: r'_afxPA
                [LclId] =
                    [$dData1_sfPr5 ds2_sfPr8 a2_sfPrc] \u []
                        ds2_sfPr8 $dData1_sfPr5 a2_sfPrc; } in
              let {
                sat_sfPre [Occ=Once] :: r_afxPz
                [LclId] =
                    [$dData_sfPr4 ds_sfPr6 ds1_sfPr7 ds2_sfPr8 a1_sfPrb] \u []
                        let {
                          sat_sfPrd [Occ=Once] :: r'_afxPA
                          [LclId] =
                              [$dData_sfPr4 ds2_sfPr8 a1_sfPrb] \u []
                                  ds2_sfPr8 $dData_sfPr4 a1_sfPrb;
                        } in  ds_sfPr6 ds1_sfPr7 sat_sfPrd;
              } in  ds_sfPr6 sat_sfPre sat_sfPrf;
        };

Data.Semigroup.$fDataArg3
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     (forall b1. Data.Data.Data b1 => b1 -> b1)
     -> Data.Semigroup.Arg a b
     -> Data.Functor.Identity.Identity (Data.Semigroup.Arg a b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,C(C1(U))><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dData_sfPrg $dData1_sfPrh ds_sfPri x0_sfPrj]
        case x0_sfPrj of {
          Data.Semigroup.Arg a1_sfPrl [Occ=Once] a2_sfPrm [Occ=Once] ->
              let {
                sat_sfPro [Occ=Once] :: b_Xfygr
                [LclId] =
                    [$dData1_sfPrh ds_sfPri a2_sfPrm] \u []
                        ds_sfPri $dData1_sfPrh a2_sfPrm; } in
              let {
                sat_sfPrn [Occ=Once] :: a_Xfygp
                [LclId] =
                    [$dData_sfPrg ds_sfPri a1_sfPrl] \u []
                        ds_sfPri $dData_sfPrg a1_sfPrl;
              } in  Data.Semigroup.Arg [sat_sfPrn sat_sfPro];
        };

Data.Semigroup.$fDataArg_$cgmapMo
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Arg a b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPrp
           $dData1_sfPrq
           $dMonadPlus_sfPrr
           ds_sfPrs
           eta_sfPrt]
        let {
          lvl33_sfPru [Occ=OnceL]
            :: m_afxR5 (Data.Semigroup.Arg a_Xfygo b_XfyDI)
          [LclId] =
              [$dMonadPlus_sfPrr] \u [] GHC.Base.mzero $dMonadPlus_sfPrr;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPrr
          of
          $dMonad_sfPrv [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPs2 [Occ=Once]
                    :: (Data.Semigroup.Arg a_Xfygo b_XfyDI, GHC.Types.Bool)
                       -> m_afxR5 (Data.Semigroup.Arg a_Xfygo b_XfyDI)
                  [LclId] =
                      [lvl33_sfPru $dMonad_sfPrv] \r [ds1_sfPrX]
                          case ds1_sfPrX of {
                            (,) x'_sfPrZ [Occ=Once] b1_sfPs0 [Occ=Once!] ->
                                case b1_sfPs0 of {
                                  GHC.Types.False -> lvl33_sfPru;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPrv x'_sfPrZ;
                                };
                          }; } in
                let {
                  sat_sfPrW [Occ=Once]
                    :: m_afxR5 (Data.Semigroup.Arg a_Xfygo b_XfyDI, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPrp
                       $dData1_sfPrq
                       $dMonadPlus_sfPrr
                       ds_sfPrs
                       eta_sfPrt
                       $dMonad_sfPrv] \u []
                          case eta_sfPrt of {
                            Data.Semigroup.Arg a1_sfPrx [Occ=Once] a2_sfPry [Occ=Once] ->
                                let {
                                  k_sfPrz [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b1.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_afxR5 (d -> b1)
                                       -> d -> m_afxR5 (b1, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sfPrr
                                                ds_sfPrs
                                                $dMonad_sfPrv] \r [$dData2_sfPrA ds1_sfPrB y_sfPrC]
                                          let {
                                            lvl34_sfPrD [Occ=OnceL] :: m_afxR5 d_ae2Ya
                                            [LclId] =
                                                [ds_sfPrs $dData2_sfPrA y_sfPrC] \u []
                                                    ds_sfPrs $dData2_sfPrA y_sfPrC; } in
                                          let {
                                            sat_sfPrT [Occ=Once]
                                              :: (d_ae2Ya -> b1_ae2Yb, GHC.Types.Bool)
                                                 -> m_afxR5 (b1_ae2Yb, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sfPrr
                                                 $dMonad_sfPrv
                                                 y_sfPrC
                                                 lvl34_sfPrD] \r [ds2_sfPrE]
                                                    case ds2_sfPrE of {
                                                      (,) h_sfPrG b2_sfPrH [Occ=Once!] ->
                                                          case b2_sfPrH of {
                                                            GHC.Types.False ->
                                                                let {
                                                                  sat_sfPrQ [Occ=Once]
                                                                    :: m_afxR5 (b1_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sfPrv
                                                                       y_sfPrC
                                                                       h_sfPrG] \u []
                                                                          let {
                                                                            sat_sfPrO [Occ=Once]
                                                                              :: b1_ae2Yb
                                                                            [LclId] =
                                                                                [y_sfPrC
                                                                                 h_sfPrG] \u []
                                                                                    h_sfPrG
                                                                                        y_sfPrC; } in
                                                                          let {
                                                                            sat_sfPrP [Occ=Once]
                                                                              :: (b1_ae2Yb,
                                                                                  GHC.Types.Bool)
                                                                            [LclId] =
                                                                                CCCS (,)! [sat_sfPrO
                                                                                           GHC.Types.False];
                                                                          } in 
                                                                            GHC.Base.return
                                                                                $dMonad_sfPrv
                                                                                sat_sfPrP; } in
                                                                let {
                                                                  sat_sfPrN [Occ=Once]
                                                                    :: m_afxR5 (b1_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sfPrv
                                                                       lvl34_sfPrD
                                                                       h_sfPrG] \u []
                                                                          let {
                                                                            sat_sfPrM [Occ=Once]
                                                                              :: d_ae2Ya
                                                                                 -> m_afxR5 (b1_ae2Yb,
                                                                                             GHC.Types.Bool)
                                                                            [LclId] =
                                                                                [$dMonad_sfPrv
                                                                                 h_sfPrG] \r [y'_sfPrJ]
                                                                                    let {
                                                                                      sat_sfPrK [Occ=Once]
                                                                                        :: b1_ae2Yb
                                                                                      [LclId] =
                                                                                          [h_sfPrG
                                                                                           y'_sfPrJ] \u []
                                                                                              h_sfPrG
                                                                                                  y'_sfPrJ; } in
                                                                                    let {
                                                                                      sat_sfPrL [Occ=Once]
                                                                                        :: (b1_ae2Yb,
                                                                                            GHC.Types.Bool)
                                                                                      [LclId] =
                                                                                          CCCS (,)! [sat_sfPrK
                                                                                                     GHC.Types.True];
                                                                                    } in 
                                                                                      GHC.Base.return
                                                                                          $dMonad_sfPrv
                                                                                          sat_sfPrL;
                                                                          } in 
                                                                            GHC.Base.>>=
                                                                                $dMonad_sfPrv
                                                                                lvl34_sfPrD
                                                                                sat_sfPrM;
                                                                } in 
                                                                  GHC.Base.mplus
                                                                      $dMonadPlus_sfPrr
                                                                      sat_sfPrN
                                                                      sat_sfPrQ;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_sfPrR [Occ=Once] :: b1_ae2Yb
                                                                  [LclId] =
                                                                      [y_sfPrC h_sfPrG] \u []
                                                                          h_sfPrG y_sfPrC; } in
                                                                let {
                                                                  sat_sfPrS [Occ=Once]
                                                                    :: (b1_ae2Yb, GHC.Types.Bool)
                                                                  [LclId] =
                                                                      CCCS (,)! [sat_sfPrR
                                                                                 GHC.Types.True];
                                                                } in 
                                                                  GHC.Base.return
                                                                      $dMonad_sfPrv sat_sfPrS;
                                                          };
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sfPrv ds1_sfPrB sat_sfPrT; } in
                                let {
                                  sat_sfPrV [Occ=Once]
                                    :: Data.Data.Mp
                                         m_afxR5 (b_XfyDI -> Data.Semigroup.Arg a_Xfygo b_XfyDI)
                                  [LclId] =
                                      [$dData_sfPrp $dMonad_sfPrv a1_sfPrx k_sfPrz] \u []
                                          let {
                                            sat_sfPrU [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_afxR5
                                                   (a_Xfygo
                                                    -> b_XfyDI
                                                    -> Data.Semigroup.Arg a_Xfygo b_XfyDI)
                                            [LclId] =
                                                [$dMonad_sfPrv] \u []
                                                    GHC.Base.return
                                                        $dMonad_sfPrv Data.Semigroup.$fDataArg1;
                                          } in  k_sfPrz $dData_sfPrp sat_sfPrU a1_sfPrx;
                                } in  k_sfPrz $dData1_sfPrq sat_sfPrV a2_sfPry;
                          };
                } in  GHC.Base.>>= $dMonad_sfPrv sat_sfPrW sat_sfPs2;
          };

lvl18_rfC6Z
  :: forall b a. Data.Semigroup.Arg a b -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_sfPs3]
        case ds_sfPs3 of {
          Data.Semigroup.Arg _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Semigroup.$cArg;
        };

lvl19_rfC70
  :: forall a b. Data.Semigroup.Arg a b -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPs7] Data.Semigroup.$tArg;

lvl20_rfC71
  :: forall a b (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Arg a b))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPs8 ds_sfPs9] GHC.Base.Nothing [];

Data.Semigroup.$fDataArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     Data.Data.Data (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPsa $dData1_sfPsb]
        let {
          sat_sfPsn [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> m (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapMo
                      $dData_sfPsa $dData1_sfPsb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsm [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> m (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapMp
                      $dData_sfPsa $dData1_sfPsb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsl [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> m (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapM
                      $dData_sfPsa $dData1_sfPsb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsk [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> u
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapQi
                      $dData_sfPsa $dData1_sfPsb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsj [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI -> [u]
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapQ
                      $dData_sfPsa $dData1_sfPsb eta_B2 eta_B1; } in
        let {
          sat_sfPsi [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> r
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapQr
                      $dData_sfPsa $dData1_sfPsb eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsh [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> r
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg2
                      $dData_sfPsa $dData1_sfPsb eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsg [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg3
                      $dData_sfPsa $dData1_sfPsb eta_B2 eta_B1; } in
        let {
          sat_sfPsf [Occ=Once]
            :: forall (t :: * -> * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
               -> GHC.Base.Maybe (c (Data.Semigroup.Arg a_Xfygn b_XfyDI))
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B1]
                  Data.Semigroup.$fDataArg_$cdataCast2
                      $dData_sfPsa $dData1_sfPsb eta_B1; } in
        let {
          sat_sfPse [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgunfold
                      $dData_sfPsa $dData1_sfPsb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsd [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> c (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgfoldl
                      $dData_sfPsa $dData1_sfPsb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsc [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \u []
                  Data.Semigroup.$fDataArg10 $dData_sfPsa $dData1_sfPsb;
        } in 
          Data.Data.C:Data [sat_sfPsc
                            sat_sfPsd
                            sat_sfPse
                            lvl18_rfC6Z
                            lvl19_rfC70
                            lvl20_rfC71
                            sat_sfPsf
                            sat_sfPsg
                            sat_sfPsh
                            sat_sfPsi
                            sat_sfPsj
                            sat_sfPsk
                            sat_sfPsl
                            sat_sfPsm
                            sat_sfPsn];

Data.Semigroup.$fDataFirst3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataFirst4];

Data.Semigroup.$tcFirst :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5289672677956055491##
                                    1507157566582617174##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataFirst3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep10_rfC72 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcFirst
                                              $krep2_rfC6L];

Data.Semigroup.$tc'First1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep10_rfC72];

Data.Semigroup.$tc'First3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'First"#;

Data.Semigroup.$tc'First2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'First3];

Data.Semigroup.$tc'First :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14746522314279732838##
                                    14022550265149674723##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'First2
                                    1#
                                    Data.Semigroup.$tc'First1];

Data.Semigroup.$fDataFirst2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.First
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                5289672677956055491##
                1507157566582617174##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataFirst3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPsp [Occ=Once]
                   ww9_sfPsq [Occ=Once]
                   ww10_sfPsr [Occ=Once]
                   ww11_sfPss [Occ=Once]
                   ww12_sfPst [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPsp
                                              ww9_sfPsq
                                              ww10_sfPsr
                                              ww11_sfPss
                                              ww12_sfPst];
        };

Data.Semigroup.$fDataFirst8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.First a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPsu]
        case Data.Data.$p1Data $dData_sfPsu of sat_sfPsv {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataFirst2 sat_sfPsv;
        };

Data.Semigroup.$fDataFirst_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.First a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPsw $dTypeable_sfPsx]
        let {
          lvl33_sfPsy [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPsx] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPsx Data.Semigroup.$fDataFirst2; } in
        let {
          sat_sfPsC [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afxYL (t_afxYK d))
               -> GHC.Base.Maybe (c_afxYL (Data.Semigroup.First a_XfyqV))
          [LclId] =
              [$dData_sfPsw lvl33_sfPsy] \r [f_sfPsz]
                  case lvl33_sfPsy of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPsB [Occ=Once] :: c_afxYL (Data.Semigroup.First a_XfyqV)
                          [LclId] =
                              [$dData_sfPsw f_sfPsz] \u [] f_sfPsz $dData_sfPsw;
                        } in  GHC.Base.Just [sat_sfPsB];
                  };
        } in  sat_sfPsC;

Data.Semigroup.$fDataFirst1
  :: forall a. (a -> Data.Semigroup.First a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataFirst_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.First a -> m (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPsD $dMonadPlus_sfPsE ds_sfPsF eta_sfPsG]
        let {
          lvl33_sfPsH [Occ=OnceL] :: m_afy0Q (Data.Semigroup.First a_Xfyr4)
          [LclId] =
              [$dMonadPlus_sfPsE] \u [] GHC.Base.mzero $dMonadPlus_sfPsE;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPsE
          of
          $dMonad_sfPsI [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPt4 [Occ=Once]
                    :: (Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                       -> m_afy0Q (Data.Semigroup.First a_Xfyr4)
                  [LclId] =
                      [lvl33_sfPsH $dMonad_sfPsI] \r [ds1_sfPsZ]
                          case ds1_sfPsZ of {
                            (,) x'_sfPt1 [Occ=Once] b_sfPt2 [Occ=Once!] ->
                                case b_sfPt2 of {
                                  GHC.Types.False -> lvl33_sfPsH;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPsI x'_sfPt1;
                                };
                          }; } in
                let {
                  sat_sfPsY [Occ=Once]
                    :: m_afy0Q (Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPsD
                       $dMonadPlus_sfPsE
                       ds_sfPsF
                       eta_sfPsG
                       $dMonad_sfPsI] \u []
                          let {
                            lvl34_sfPsJ [Occ=OnceL] :: m_afy0Q a_Xfyr4
                            [LclId] =
                                [$dData_sfPsD ds_sfPsF eta_sfPsG] \u []
                                    ds_sfPsF $dData_sfPsD eta_sfPsG; } in
                          let {
                            sat_sfPsX [Occ=Once]
                              :: (a_Xfyr4 -> Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                                 -> m_afy0Q (Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPsE
                                 eta_sfPsG
                                 $dMonad_sfPsI
                                 lvl34_sfPsJ] \r [ds1_sfPsL]
                                    case ds1_sfPsL of {
                                      (,) h_sfPsN b1_sfPsO [Occ=Once] ->
                                          let {
                                            sat_sfPsW [Occ=Once]
                                              :: m_afy0Q (Data.Semigroup.First a_Xfyr4,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfPsG $dMonad_sfPsI h_sfPsN b1_sfPsO] \u []
                                                    let {
                                                      sat_sfPsU [Occ=Once]
                                                        :: Data.Semigroup.First a_Xfyr4
                                                      [LclId] =
                                                          [eta_sfPsG h_sfPsN] \u []
                                                              h_sfPsN eta_sfPsG; } in
                                                    let {
                                                      sat_sfPsV [Occ=Once]
                                                        :: (Data.Semigroup.First a_Xfyr4,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfPsU b1_sfPsO];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfPsI sat_sfPsV; } in
                                          let {
                                            sat_sfPsT [Occ=Once]
                                              :: m_afy0Q (Data.Semigroup.First a_Xfyr4,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfPsI lvl34_sfPsJ h_sfPsN] \u []
                                                    let {
                                                      sat_sfPsS [Occ=Once]
                                                        :: a_Xfyr4
                                                           -> m_afy0Q (Data.Semigroup.First a_Xfyr4,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfPsI h_sfPsN] \r [y'_sfPsP]
                                                              let {
                                                                sat_sfPsQ [Occ=Once]
                                                                  :: Data.Semigroup.First a_Xfyr4
                                                                [LclId] =
                                                                    [h_sfPsN y'_sfPsP] \u []
                                                                        h_sfPsN y'_sfPsP; } in
                                                              let {
                                                                sat_sfPsR [Occ=Once]
                                                                  :: (Data.Semigroup.First a_Xfyr4,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfPsQ
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfPsI sat_sfPsR;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfPsI lvl34_sfPsJ sat_sfPsS;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfPsE sat_sfPsT sat_sfPsW;
                                    }; } in
                          let {
                            sat_sfPsK [Occ=Once]
                              :: m_afy0Q (a_Xfyr4 -> Data.Semigroup.First a_Xfyr4,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPsI] \u []
                                    GHC.Base.return $dMonad_sfPsI Data.Semigroup.$fDataFirst1;
                          } in  GHC.Base.>>= $dMonad_sfPsI sat_sfPsK sat_sfPsX;
                } in  GHC.Base.>>= $dMonad_sfPsI sat_sfPsY sat_sfPt4;
          };

Data.Semigroup.$fDataFirst_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.First a -> m (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPt5 $dMonad_sfPt6 ds_sfPt7 eta_sfPt8]
        let {
          lvl33_sfPt9 [Occ=OnceL] :: m_afy0A a_Xfyr3
          [LclId] =
              [$dData_sfPt5 ds_sfPt7 eta_sfPt8] \u []
                  ds_sfPt7 $dData_sfPt5 eta_sfPt8; } in
        let {
          sat_sfPtf [Occ=Once]
            :: (a_Xfyr3 -> Data.Semigroup.First a_Xfyr3)
               -> m_afy0A (Data.Semigroup.First a_Xfyr3)
          [LclId] =
              [$dMonad_sfPt6 lvl33_sfPt9] \r [c'_sfPtb]
                  let {
                    sat_sfPte [Occ=Once]
                      :: a_Xfyr3 -> m_afy0A (Data.Semigroup.First a_Xfyr3)
                    [LclId] =
                        [$dMonad_sfPt6 c'_sfPtb] \r [x'_sfPtc]
                            let {
                              sat_sfPtd [Occ=Once] :: Data.Semigroup.First a_Xfyr3
                              [LclId] =
                                  [c'_sfPtb x'_sfPtc] \u [] c'_sfPtb x'_sfPtc;
                            } in  GHC.Base.return $dMonad_sfPt6 sat_sfPtd;
                  } in  GHC.Base.>>= $dMonad_sfPt6 lvl33_sfPt9 sat_sfPte; } in
        let {
          sat_sfPta [Occ=Once]
            :: m_afy0A (a_Xfyr3 -> Data.Semigroup.First a_Xfyr3)
          [LclId] =
              [$dMonad_sfPt6] \u []
                  GHC.Base.return $dMonad_sfPt6 Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfPt6 sat_sfPta sat_sfPtf;

Data.Semigroup.$fDataFirst_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.First a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPtg ds_sfPth ds1_sfPti x_sfPtj]
        case ds_sfPth of {
          GHC.Types.I# x1_sfPtl [Occ=Once!] ->
              case x1_sfPtl of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfPti $dData_sfPtg x_sfPtj;
              };
        };

Data.Semigroup.$fDataFirst_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.First a -> m (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPtn $dMonadPlus_sfPto ds_sfPtp eta_sfPtq]
        let {
          lvl33_sfPtr [Occ=OnceL] :: m_afy16 (Data.Semigroup.First a_XfyqX)
          [LclId] =
              [$dMonadPlus_sfPto] \u [] GHC.Base.mzero $dMonadPlus_sfPto;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPto
          of
          $dMonad_sfPts [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPtR [Occ=Once]
                    :: (Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                       -> m_afy16 (Data.Semigroup.First a_XfyqX)
                  [LclId] =
                      [lvl33_sfPtr $dMonad_sfPts] \r [ds1_sfPtM]
                          case ds1_sfPtM of {
                            (,) x'_sfPtO [Occ=Once] b_sfPtP [Occ=Once!] ->
                                case b_sfPtP of {
                                  GHC.Types.False -> lvl33_sfPtr;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPts x'_sfPtO;
                                };
                          }; } in
                let {
                  sat_sfPtL [Occ=Once]
                    :: m_afy16 (Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPtn
                       $dMonadPlus_sfPto
                       ds_sfPtp
                       eta_sfPtq
                       $dMonad_sfPts] \u []
                          let {
                            lvl34_sfPtt [Occ=OnceL] :: m_afy16 a_XfyqX
                            [LclId] =
                                [$dData_sfPtn ds_sfPtp eta_sfPtq] \u []
                                    ds_sfPtp $dData_sfPtn eta_sfPtq; } in
                          let {
                            sat_sfPtK [Occ=Once]
                              :: (a_XfyqX -> Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                                 -> m_afy16 (Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPto
                                 eta_sfPtq
                                 $dMonad_sfPts
                                 lvl34_sfPtt] \r [ds1_sfPtv]
                                    case ds1_sfPtv of {
                                      (,) h_sfPtx b1_sfPty [Occ=Once!] ->
                                          case b1_sfPty of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfPtH [Occ=Once]
                                                    :: m_afy16 (Data.Semigroup.First a_XfyqX,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfPtq $dMonad_sfPts h_sfPtx] \u []
                                                          let {
                                                            sat_sfPtF [Occ=Once]
                                                              :: Data.Semigroup.First a_XfyqX
                                                            [LclId] =
                                                                [eta_sfPtq h_sfPtx] \u []
                                                                    h_sfPtx eta_sfPtq; } in
                                                          let {
                                                            sat_sfPtG [Occ=Once]
                                                              :: (Data.Semigroup.First a_XfyqX,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfPtF
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfPts sat_sfPtG; } in
                                                let {
                                                  sat_sfPtE [Occ=Once]
                                                    :: m_afy16 (Data.Semigroup.First a_XfyqX,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfPts lvl34_sfPtt h_sfPtx] \u []
                                                          let {
                                                            sat_sfPtD [Occ=Once]
                                                              :: a_XfyqX
                                                                 -> m_afy16 (Data.Semigroup.First
                                                                               a_XfyqX,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPts
                                                                 h_sfPtx] \r [y'_sfPtA]
                                                                    let {
                                                                      sat_sfPtB [Occ=Once]
                                                                        :: Data.Semigroup.First
                                                                             a_XfyqX
                                                                      [LclId] =
                                                                          [h_sfPtx y'_sfPtA] \u []
                                                                              h_sfPtx y'_sfPtA; } in
                                                                    let {
                                                                      sat_sfPtC [Occ=Once]
                                                                        :: (Data.Semigroup.First
                                                                              a_XfyqX,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPtB
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPts sat_sfPtC;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfPts lvl34_sfPtt sat_sfPtD;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfPto sat_sfPtE sat_sfPtH;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfPtI [Occ=Once]
                                                    :: Data.Semigroup.First a_XfyqX
                                                  [LclId] =
                                                      [eta_sfPtq h_sfPtx] \u []
                                                          h_sfPtx eta_sfPtq; } in
                                                let {
                                                  sat_sfPtJ [Occ=Once]
                                                    :: (Data.Semigroup.First a_XfyqX,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfPtI GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfPts sat_sfPtJ;
                                          };
                                    }; } in
                          let {
                            sat_sfPtu [Occ=Once]
                              :: m_afy16 (a_XfyqX -> Data.Semigroup.First a_XfyqX,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPts] \u []
                                    GHC.Base.return $dMonad_sfPts Data.Semigroup.$fDataFirst1;
                          } in  GHC.Base.>>= $dMonad_sfPts sat_sfPtu sat_sfPtK;
                } in  GHC.Base.>>= $dMonad_sfPts sat_sfPtL sat_sfPtR;
          };

lvl21_rfC73 :: forall a. Data.Semigroup.First a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPtS] Data.Semigroup.$cFirst;

lvl22_rfC74
  :: forall a. Data.Semigroup.First a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPtT] Data.Semigroup.$tFirst;

lvl23_rfC75
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.First a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPtU ds_sfPtV] GHC.Base.Nothing [];

Data.Semigroup.$fDataFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.First a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPtW]
        let {
          sat_sfPur [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.First a_XfyqW -> m (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfPtW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapMo
                      $dData_sfPtW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPuq [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.First a_XfyqW -> m (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfPtW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapMp
                      $dData_sfPtW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPup [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.First a_XfyqW -> m (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfPtW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapM
                      $dData_sfPtW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPuo [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.First a_XfyqW
               -> u
          [LclId] =
              [$dData_sfPtW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapQi
                      $dData_sfPtW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPun [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.First a_XfyqW -> [u]
          [LclId] =
              [$dData_sfPtW] \r [ds_sfPuk x0_sfPul]
                  let {
                    sat_sfPum [Occ=Once] :: u_afy08
                    [LclId] =
                        [$dData_sfPtW ds_sfPuk x0_sfPul] \u []
                            ds_sfPuk $dData_sfPtW x0_sfPul;
                  } in  : [sat_sfPum GHC.Types.[]]; } in
        let {
          sat_sfPuj [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.First a_XfyqW
               -> r
          [LclId] =
              [$dData_sfPtW] \r [ds_sfPue ds1_sfPuf ds2_sfPug x0_sfPuh]
                  let {
                    sat_sfPui [Occ=Once] :: r'_afxZS
                    [LclId] =
                        [$dData_sfPtW ds2_sfPug x0_sfPuh] \u []
                            ds2_sfPug $dData_sfPtW x0_sfPuh;
                  } in  ds_sfPue sat_sfPui ds1_sfPuf; } in
        let {
          sat_sfPud [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.First a_XfyqW
               -> r
          [LclId] =
              [$dData_sfPtW] \r [ds_sfPu8 ds1_sfPu9 ds2_sfPua eta_sfPub]
                  let {
                    sat_sfPuc [Occ=Once] :: r'_afxZB
                    [LclId] =
                        [$dData_sfPtW ds2_sfPua eta_sfPub] \u []
                            ds2_sfPua $dData_sfPtW eta_sfPub;
                  } in  ds_sfPu8 ds1_sfPu9 sat_sfPuc; } in
        let {
          sat_sfPu7 [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.First a_XfyqW -> Data.Semigroup.First a_XfyqW
          [LclId] =
              [$dData_sfPtW] \r [ds_sfPu5 x0_sfPu6]
                  ds_sfPu5 $dData_sfPtW x0_sfPu6; } in
        let {
          sat_sfPu4 [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.First a_XfyqW))
          [LclId] =
              [$dData_sfPtW] \r [eta_B1]
                  Data.Semigroup.$fDataFirst_$cdataCast1 $dData_sfPtW eta_B1; } in
        let {
          sat_sfPu3 [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfPtW] \r [k_sfPtZ z_sfPu0 ds_sfPu1]
                  let {
                    sat_sfPu2 [Occ=Once]
                      :: c_afxYr (a_XfyqW -> Data.Semigroup.First a_XfyqW)
                    [LclId] =
                        [z_sfPu0] \u [] z_sfPu0 Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfPtZ $dData_sfPtW sat_sfPu2; } in
        let {
          sat_sfPtY [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.First a_XfyqW
               -> c (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfPtW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgfoldl
                      $dData_sfPtW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPtX [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfPtW] \u [] Data.Semigroup.$fDataFirst8 $dData_sfPtW;
        } in 
          Data.Data.C:Data [sat_sfPtX
                            sat_sfPtY
                            sat_sfPu3
                            lvl21_rfC73
                            lvl22_rfC74
                            sat_sfPu4
                            lvl23_rfC75
                            sat_sfPu7
                            sat_sfPud
                            sat_sfPuj
                            sat_sfPun
                            sat_sfPuo
                            sat_sfPup
                            sat_sfPuq
                            sat_sfPur];

Data.Semigroup.$fDataLast3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataLast4];

Data.Semigroup.$tcLast :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11434676963974803827##
                                    15911814017027463598##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataLast3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep11_rfC76 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcLast
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Last1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep11_rfC76];

Data.Semigroup.$tc'Last3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Last"#;

Data.Semigroup.$tc'Last2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Last3];

Data.Semigroup.$tc'Last :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3320600960953447003##
                                    12383530634546204472##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Last2
                                    1#
                                    Data.Semigroup.$tc'Last1];

Data.Semigroup.$fDataLast2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Last
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                11434676963974803827##
                15911814017027463598##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataLast3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPut [Occ=Once]
                   ww9_sfPuu [Occ=Once]
                   ww10_sfPuv [Occ=Once]
                   ww11_sfPuw [Occ=Once]
                   ww12_sfPux [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPut
                                              ww9_sfPuu
                                              ww10_sfPuv
                                              ww11_sfPuw
                                              ww12_sfPux];
        };

Data.Semigroup.$fDataLast8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Last a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPuy]
        case Data.Data.$p1Data $dData_sfPuy of sat_sfPuz {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataLast2 sat_sfPuz;
        };

Data.Semigroup.$fDataLast_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Last a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPuA $dTypeable_sfPuB]
        let {
          lvl33_sfPuC [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPuB] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPuB Data.Semigroup.$fDataLast2; } in
        let {
          sat_sfPuG [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afy7N (t_afy7M d))
               -> GHC.Base.Maybe (c_afy7N (Data.Semigroup.Last a_XfyAl))
          [LclId] =
              [$dData_sfPuA lvl33_sfPuC] \r [f_sfPuD]
                  case lvl33_sfPuC of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPuF [Occ=Once] :: c_afy7N (Data.Semigroup.Last a_XfyAl)
                          [LclId] =
                              [$dData_sfPuA f_sfPuD] \u [] f_sfPuD $dData_sfPuA;
                        } in  GHC.Base.Just [sat_sfPuF];
                  };
        } in  sat_sfPuG;

Data.Semigroup.$fDataLast1
  :: forall a. (a -> Data.Semigroup.Last a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataLast_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Last a -> m (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPuH $dMonadPlus_sfPuI ds_sfPuJ eta_sfPuK]
        let {
          lvl33_sfPuL [Occ=OnceL] :: m_afy9S (Data.Semigroup.Last a_XfyAu)
          [LclId] =
              [$dMonadPlus_sfPuI] \u [] GHC.Base.mzero $dMonadPlus_sfPuI;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPuI
          of
          $dMonad_sfPuM [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPv8 [Occ=Once]
                    :: (Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                       -> m_afy9S (Data.Semigroup.Last a_XfyAu)
                  [LclId] =
                      [lvl33_sfPuL $dMonad_sfPuM] \r [ds1_sfPv3]
                          case ds1_sfPv3 of {
                            (,) x'_sfPv5 [Occ=Once] b_sfPv6 [Occ=Once!] ->
                                case b_sfPv6 of {
                                  GHC.Types.False -> lvl33_sfPuL;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPuM x'_sfPv5;
                                };
                          }; } in
                let {
                  sat_sfPv2 [Occ=Once]
                    :: m_afy9S (Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPuH
                       $dMonadPlus_sfPuI
                       ds_sfPuJ
                       eta_sfPuK
                       $dMonad_sfPuM] \u []
                          let {
                            lvl34_sfPuN [Occ=OnceL] :: m_afy9S a_XfyAu
                            [LclId] =
                                [$dData_sfPuH ds_sfPuJ eta_sfPuK] \u []
                                    ds_sfPuJ $dData_sfPuH eta_sfPuK; } in
                          let {
                            sat_sfPv1 [Occ=Once]
                              :: (a_XfyAu -> Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                                 -> m_afy9S (Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPuI
                                 eta_sfPuK
                                 $dMonad_sfPuM
                                 lvl34_sfPuN] \r [ds1_sfPuP]
                                    case ds1_sfPuP of {
                                      (,) h_sfPuR b1_sfPuS [Occ=Once] ->
                                          let {
                                            sat_sfPv0 [Occ=Once]
                                              :: m_afy9S (Data.Semigroup.Last a_XfyAu,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfPuK $dMonad_sfPuM h_sfPuR b1_sfPuS] \u []
                                                    let {
                                                      sat_sfPuY [Occ=Once]
                                                        :: Data.Semigroup.Last a_XfyAu
                                                      [LclId] =
                                                          [eta_sfPuK h_sfPuR] \u []
                                                              h_sfPuR eta_sfPuK; } in
                                                    let {
                                                      sat_sfPuZ [Occ=Once]
                                                        :: (Data.Semigroup.Last a_XfyAu,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfPuY b1_sfPuS];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfPuM sat_sfPuZ; } in
                                          let {
                                            sat_sfPuX [Occ=Once]
                                              :: m_afy9S (Data.Semigroup.Last a_XfyAu,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfPuM lvl34_sfPuN h_sfPuR] \u []
                                                    let {
                                                      sat_sfPuW [Occ=Once]
                                                        :: a_XfyAu
                                                           -> m_afy9S (Data.Semigroup.Last a_XfyAu,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfPuM h_sfPuR] \r [y'_sfPuT]
                                                              let {
                                                                sat_sfPuU [Occ=Once]
                                                                  :: Data.Semigroup.Last a_XfyAu
                                                                [LclId] =
                                                                    [h_sfPuR y'_sfPuT] \u []
                                                                        h_sfPuR y'_sfPuT; } in
                                                              let {
                                                                sat_sfPuV [Occ=Once]
                                                                  :: (Data.Semigroup.Last a_XfyAu,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfPuU
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfPuM sat_sfPuV;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfPuM lvl34_sfPuN sat_sfPuW;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfPuI sat_sfPuX sat_sfPv0;
                                    }; } in
                          let {
                            sat_sfPuO [Occ=Once]
                              :: m_afy9S (a_XfyAu -> Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPuM] \u []
                                    GHC.Base.return $dMonad_sfPuM Data.Semigroup.$fDataLast1;
                          } in  GHC.Base.>>= $dMonad_sfPuM sat_sfPuO sat_sfPv1;
                } in  GHC.Base.>>= $dMonad_sfPuM sat_sfPv2 sat_sfPv8;
          };

Data.Semigroup.$fDataLast_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Last a -> m (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPv9 $dMonad_sfPva ds_sfPvb eta_sfPvc]
        let {
          lvl33_sfPvd [Occ=OnceL] :: m_afy9C a_XfyAt
          [LclId] =
              [$dData_sfPv9 ds_sfPvb eta_sfPvc] \u []
                  ds_sfPvb $dData_sfPv9 eta_sfPvc; } in
        let {
          sat_sfPvj [Occ=Once]
            :: (a_XfyAt -> Data.Semigroup.Last a_XfyAt)
               -> m_afy9C (Data.Semigroup.Last a_XfyAt)
          [LclId] =
              [$dMonad_sfPva lvl33_sfPvd] \r [c'_sfPvf]
                  let {
                    sat_sfPvi [Occ=Once]
                      :: a_XfyAt -> m_afy9C (Data.Semigroup.Last a_XfyAt)
                    [LclId] =
                        [$dMonad_sfPva c'_sfPvf] \r [x'_sfPvg]
                            let {
                              sat_sfPvh [Occ=Once] :: Data.Semigroup.Last a_XfyAt
                              [LclId] =
                                  [c'_sfPvf x'_sfPvg] \u [] c'_sfPvf x'_sfPvg;
                            } in  GHC.Base.return $dMonad_sfPva sat_sfPvh;
                  } in  GHC.Base.>>= $dMonad_sfPva lvl33_sfPvd sat_sfPvi; } in
        let {
          sat_sfPve [Occ=Once]
            :: m_afy9C (a_XfyAt -> Data.Semigroup.Last a_XfyAt)
          [LclId] =
              [$dMonad_sfPva] \u []
                  GHC.Base.return $dMonad_sfPva Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfPva sat_sfPve sat_sfPvj;

Data.Semigroup.$fDataLast_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Last a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPvk ds_sfPvl ds1_sfPvm x_sfPvn]
        case ds_sfPvl of {
          GHC.Types.I# x1_sfPvp [Occ=Once!] ->
              case x1_sfPvp of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfPvm $dData_sfPvk x_sfPvn;
              };
        };

Data.Semigroup.$fDataLast_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Last a -> m (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPvr $dMonadPlus_sfPvs ds_sfPvt eta_sfPvu]
        let {
          lvl33_sfPvv [Occ=OnceL] :: m_afya8 (Data.Semigroup.Last a_XfyAn)
          [LclId] =
              [$dMonadPlus_sfPvs] \u [] GHC.Base.mzero $dMonadPlus_sfPvs;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPvs
          of
          $dMonad_sfPvw [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPvV [Occ=Once]
                    :: (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                       -> m_afya8 (Data.Semigroup.Last a_XfyAn)
                  [LclId] =
                      [lvl33_sfPvv $dMonad_sfPvw] \r [ds1_sfPvQ]
                          case ds1_sfPvQ of {
                            (,) x'_sfPvS [Occ=Once] b_sfPvT [Occ=Once!] ->
                                case b_sfPvT of {
                                  GHC.Types.False -> lvl33_sfPvv;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPvw x'_sfPvS;
                                };
                          }; } in
                let {
                  sat_sfPvP [Occ=Once]
                    :: m_afya8 (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPvr
                       $dMonadPlus_sfPvs
                       ds_sfPvt
                       eta_sfPvu
                       $dMonad_sfPvw] \u []
                          let {
                            lvl34_sfPvx [Occ=OnceL] :: m_afya8 a_XfyAn
                            [LclId] =
                                [$dData_sfPvr ds_sfPvt eta_sfPvu] \u []
                                    ds_sfPvt $dData_sfPvr eta_sfPvu; } in
                          let {
                            sat_sfPvO [Occ=Once]
                              :: (a_XfyAn -> Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                                 -> m_afya8 (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPvs
                                 eta_sfPvu
                                 $dMonad_sfPvw
                                 lvl34_sfPvx] \r [ds1_sfPvz]
                                    case ds1_sfPvz of {
                                      (,) h_sfPvB b1_sfPvC [Occ=Once!] ->
                                          case b1_sfPvC of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfPvL [Occ=Once]
                                                    :: m_afya8 (Data.Semigroup.Last a_XfyAn,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfPvu $dMonad_sfPvw h_sfPvB] \u []
                                                          let {
                                                            sat_sfPvJ [Occ=Once]
                                                              :: Data.Semigroup.Last a_XfyAn
                                                            [LclId] =
                                                                [eta_sfPvu h_sfPvB] \u []
                                                                    h_sfPvB eta_sfPvu; } in
                                                          let {
                                                            sat_sfPvK [Occ=Once]
                                                              :: (Data.Semigroup.Last a_XfyAn,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfPvJ
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfPvw sat_sfPvK; } in
                                                let {
                                                  sat_sfPvI [Occ=Once]
                                                    :: m_afya8 (Data.Semigroup.Last a_XfyAn,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfPvw lvl34_sfPvx h_sfPvB] \u []
                                                          let {
                                                            sat_sfPvH [Occ=Once]
                                                              :: a_XfyAn
                                                                 -> m_afya8 (Data.Semigroup.Last
                                                                               a_XfyAn,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPvw
                                                                 h_sfPvB] \r [y'_sfPvE]
                                                                    let {
                                                                      sat_sfPvF [Occ=Once]
                                                                        :: Data.Semigroup.Last
                                                                             a_XfyAn
                                                                      [LclId] =
                                                                          [h_sfPvB y'_sfPvE] \u []
                                                                              h_sfPvB y'_sfPvE; } in
                                                                    let {
                                                                      sat_sfPvG [Occ=Once]
                                                                        :: (Data.Semigroup.Last
                                                                              a_XfyAn,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPvF
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPvw sat_sfPvG;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfPvw lvl34_sfPvx sat_sfPvH;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfPvs sat_sfPvI sat_sfPvL;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfPvM [Occ=Once]
                                                    :: Data.Semigroup.Last a_XfyAn
                                                  [LclId] =
                                                      [eta_sfPvu h_sfPvB] \u []
                                                          h_sfPvB eta_sfPvu; } in
                                                let {
                                                  sat_sfPvN [Occ=Once]
                                                    :: (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfPvM GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfPvw sat_sfPvN;
                                          };
                                    }; } in
                          let {
                            sat_sfPvy [Occ=Once]
                              :: m_afya8 (a_XfyAn -> Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPvw] \u []
                                    GHC.Base.return $dMonad_sfPvw Data.Semigroup.$fDataLast1;
                          } in  GHC.Base.>>= $dMonad_sfPvw sat_sfPvy sat_sfPvO;
                } in  GHC.Base.>>= $dMonad_sfPvw sat_sfPvP sat_sfPvV;
          };

lvl24_rfC77 :: forall a. Data.Semigroup.Last a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPvW] Data.Semigroup.$cLast;

lvl25_rfC78
  :: forall a. Data.Semigroup.Last a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPvX] Data.Semigroup.$tLast;

lvl26_rfC79
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Last a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPvY ds_sfPvZ] GHC.Base.Nothing [];

Data.Semigroup.$fDataLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Last a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPw0]
        let {
          sat_sfPwv [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Last a_XfyAm -> m (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfPw0] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapMo
                      $dData_sfPw0 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPwu [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Last a_XfyAm -> m (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfPw0] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapMp
                      $dData_sfPw0 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPwt [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Last a_XfyAm -> m (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfPw0] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapM
                      $dData_sfPw0 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPws [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Last a_XfyAm
               -> u
          [LclId] =
              [$dData_sfPw0] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapQi
                      $dData_sfPw0 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPwr [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Last a_XfyAm -> [u]
          [LclId] =
              [$dData_sfPw0] \r [ds_sfPwo x0_sfPwp]
                  let {
                    sat_sfPwq [Occ=Once] :: u_afy9a
                    [LclId] =
                        [$dData_sfPw0 ds_sfPwo x0_sfPwp] \u []
                            ds_sfPwo $dData_sfPw0 x0_sfPwp;
                  } in  : [sat_sfPwq GHC.Types.[]]; } in
        let {
          sat_sfPwn [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Last a_XfyAm
               -> r
          [LclId] =
              [$dData_sfPw0] \r [ds_sfPwi ds1_sfPwj ds2_sfPwk x0_sfPwl]
                  let {
                    sat_sfPwm [Occ=Once] :: r'_afy8U
                    [LclId] =
                        [$dData_sfPw0 ds2_sfPwk x0_sfPwl] \u []
                            ds2_sfPwk $dData_sfPw0 x0_sfPwl;
                  } in  ds_sfPwi sat_sfPwm ds1_sfPwj; } in
        let {
          sat_sfPwh [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Last a_XfyAm
               -> r
          [LclId] =
              [$dData_sfPw0] \r [ds_sfPwc ds1_sfPwd ds2_sfPwe eta_sfPwf]
                  let {
                    sat_sfPwg [Occ=Once] :: r'_afy8D
                    [LclId] =
                        [$dData_sfPw0 ds2_sfPwe eta_sfPwf] \u []
                            ds2_sfPwe $dData_sfPw0 eta_sfPwf;
                  } in  ds_sfPwc ds1_sfPwd sat_sfPwg; } in
        let {
          sat_sfPwb [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Last a_XfyAm -> Data.Semigroup.Last a_XfyAm
          [LclId] =
              [$dData_sfPw0] \r [ds_sfPw9 x0_sfPwa]
                  ds_sfPw9 $dData_sfPw0 x0_sfPwa; } in
        let {
          sat_sfPw8 [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Last a_XfyAm))
          [LclId] =
              [$dData_sfPw0] \r [eta_B1]
                  Data.Semigroup.$fDataLast_$cdataCast1 $dData_sfPw0 eta_B1; } in
        let {
          sat_sfPw7 [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfPw0] \r [k_sfPw3 z_sfPw4 ds_sfPw5]
                  let {
                    sat_sfPw6 [Occ=Once]
                      :: c_afy7t (a_XfyAm -> Data.Semigroup.Last a_XfyAm)
                    [LclId] =
                        [z_sfPw4] \u [] z_sfPw4 Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfPw3 $dData_sfPw0 sat_sfPw6; } in
        let {
          sat_sfPw2 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Last a_XfyAm
               -> c (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfPw0] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgfoldl
                      $dData_sfPw0 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPw1 [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfPw0] \u [] Data.Semigroup.$fDataLast8 $dData_sfPw0;
        } in 
          Data.Data.C:Data [sat_sfPw1
                            sat_sfPw2
                            sat_sfPw7
                            lvl24_rfC77
                            lvl25_rfC78
                            sat_sfPw8
                            lvl26_rfC79
                            sat_sfPwb
                            sat_sfPwh
                            sat_sfPwn
                            sat_sfPwr
                            sat_sfPws
                            sat_sfPwt
                            sat_sfPwu
                            sat_sfPwv];

Data.Semigroup.$fDataWrappedMonoid3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataWrappedMonoid4];

Data.Semigroup.$tcWrappedMonoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3715640179151546043##
                                    2823802549020348832##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataWrappedMonoid3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep12_rfC7a :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcWrappedMonoid
                                              $krep2_rfC6L];

Data.Semigroup.$tc'WrapMonoid1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep12_rfC7a];

Data.Semigroup.$tc'WrapMonoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'WrapMonoid"#;

Data.Semigroup.$tc'WrapMonoid2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'WrapMonoid3];

Data.Semigroup.$tc'WrapMonoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4283841874858276090##
                                    3445460813926951313##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'WrapMonoid2
                                    1#
                                    Data.Semigroup.$tc'WrapMonoid1];

Data.Semigroup.$fDataWrappedMonoid2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.WrappedMonoid
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                3715640179151546043##
                2823802549020348832##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataWrappedMonoid3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPwx [Occ=Once]
                   ww9_sfPwy [Occ=Once]
                   ww10_sfPwz [Occ=Once]
                   ww11_sfPwA [Occ=Once]
                   ww12_sfPwB [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPwx
                                              ww9_sfPwy
                                              ww10_sfPwz
                                              ww11_sfPwA
                                              ww12_sfPwB];
        };

Data.Semigroup.$fDataWrappedMonoid8
  :: forall m.
     Data.Data.Data m =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPwC]
        case Data.Data.$p1Data $dData_sfPwC of sat_sfPwD {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataWrappedMonoid2 sat_sfPwD;
        };

Data.Semigroup.$fDataWrappedMonoid_$cdataCast1
  :: forall m.
     Data.Data.Data m =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.WrappedMonoid m))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPwE $dTypeable_sfPwF]
        let {
          lvl33_sfPwG [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPwF] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPwF Data.Semigroup.$fDataWrappedMonoid2; } in
        let {
          sat_sfPwK [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afygP (t_afygO d))
               -> GHC.Base.Maybe (c_afygP (Data.Semigroup.WrappedMonoid m_XfyJL))
          [LclId] =
              [$dData_sfPwE lvl33_sfPwG] \r [f_sfPwH]
                  case lvl33_sfPwG of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPwJ [Occ=Once]
                            :: c_afygP (Data.Semigroup.WrappedMonoid m_XfyJL)
                          [LclId] =
                              [$dData_sfPwE f_sfPwH] \u [] f_sfPwH $dData_sfPwE;
                        } in  GHC.Base.Just [sat_sfPwJ];
                  };
        } in  sat_sfPwK;

Data.Semigroup.$fDataWrappedMonoid1
  :: forall m. (m -> Data.Semigroup.WrappedMonoid m, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataWrappedMonoid_$cgmapMp
  :: forall m.
     Data.Data.Data m =>
     forall (m1 :: * -> *).
     GHC.Base.MonadPlus m1 =>
     (forall d. Data.Data.Data d => d -> m1 d)
     -> Data.Semigroup.WrappedMonoid m
     -> m1 (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPwL $dMonadPlus_sfPwM ds_sfPwN eta_sfPwO]
        let {
          lvl33_sfPwP [Occ=OnceL]
            :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU)
          [LclId] =
              [$dMonadPlus_sfPwM] \u [] GHC.Base.mzero $dMonadPlus_sfPwM;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPwM
          of
          $dMonad_sfPwQ [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPxc [Occ=Once]
                    :: (Data.Semigroup.WrappedMonoid m_XfyJU, GHC.Types.Bool)
                       -> m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU)
                  [LclId] =
                      [lvl33_sfPwP $dMonad_sfPwQ] \r [ds1_sfPx7]
                          case ds1_sfPx7 of {
                            (,) x'_sfPx9 [Occ=Once] b_sfPxa [Occ=Once!] ->
                                case b_sfPxa of {
                                  GHC.Types.False -> lvl33_sfPwP;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPwQ x'_sfPx9;
                                };
                          }; } in
                let {
                  sat_sfPx6 [Occ=Once]
                    :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPwL
                       $dMonadPlus_sfPwM
                       ds_sfPwN
                       eta_sfPwO
                       $dMonad_sfPwQ] \u []
                          let {
                            lvl34_sfPwR [Occ=OnceL] :: m1_afyiU m_XfyJU
                            [LclId] =
                                [$dData_sfPwL ds_sfPwN eta_sfPwO] \u []
                                    ds_sfPwN $dData_sfPwL eta_sfPwO; } in
                          let {
                            sat_sfPx5 [Occ=Once]
                              :: (m_XfyJU -> Data.Semigroup.WrappedMonoid m_XfyJU,
                                  GHC.Types.Bool)
                                 -> m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPwM
                                 eta_sfPwO
                                 $dMonad_sfPwQ
                                 lvl34_sfPwR] \r [ds1_sfPwT]
                                    case ds1_sfPwT of {
                                      (,) h_sfPwV b1_sfPwW [Occ=Once] ->
                                          let {
                                            sat_sfPx4 [Occ=Once]
                                              :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU,
                                                           GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfPwO $dMonad_sfPwQ h_sfPwV b1_sfPwW] \u []
                                                    let {
                                                      sat_sfPx2 [Occ=Once]
                                                        :: Data.Semigroup.WrappedMonoid m_XfyJU
                                                      [LclId] =
                                                          [eta_sfPwO h_sfPwV] \u []
                                                              h_sfPwV eta_sfPwO; } in
                                                    let {
                                                      sat_sfPx3 [Occ=Once]
                                                        :: (Data.Semigroup.WrappedMonoid m_XfyJU,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfPx2 b1_sfPwW];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfPwQ sat_sfPx3; } in
                                          let {
                                            sat_sfPx1 [Occ=Once]
                                              :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU,
                                                           GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfPwQ lvl34_sfPwR h_sfPwV] \u []
                                                    let {
                                                      sat_sfPx0 [Occ=Once]
                                                        :: m_XfyJU
                                                           -> m1_afyiU (Data.Semigroup.WrappedMonoid
                                                                          m_XfyJU,
                                                                        GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfPwQ h_sfPwV] \r [y'_sfPwX]
                                                              let {
                                                                sat_sfPwY [Occ=Once]
                                                                  :: Data.Semigroup.WrappedMonoid
                                                                       m_XfyJU
                                                                [LclId] =
                                                                    [h_sfPwV y'_sfPwX] \u []
                                                                        h_sfPwV y'_sfPwX; } in
                                                              let {
                                                                sat_sfPwZ [Occ=Once]
                                                                  :: (Data.Semigroup.WrappedMonoid
                                                                        m_XfyJU,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfPwY
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfPwQ sat_sfPwZ;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfPwQ lvl34_sfPwR sat_sfPx0;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfPwM sat_sfPx1 sat_sfPx4;
                                    }; } in
                          let {
                            sat_sfPwS [Occ=Once]
                              :: m1_afyiU (m_XfyJU -> Data.Semigroup.WrappedMonoid m_XfyJU,
                                           GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPwQ] \u []
                                    GHC.Base.return
                                        $dMonad_sfPwQ Data.Semigroup.$fDataWrappedMonoid1;
                          } in  GHC.Base.>>= $dMonad_sfPwQ sat_sfPwS sat_sfPx5;
                } in  GHC.Base.>>= $dMonad_sfPwQ sat_sfPx6 sat_sfPxc;
          };

Data.Semigroup.$fDataWrappedMonoid_$cgmapM
  :: forall m.
     Data.Data.Data m =>
     forall (m1 :: * -> *).
     GHC.Base.Monad m1 =>
     (forall d. Data.Data.Data d => d -> m1 d)
     -> Data.Semigroup.WrappedMonoid m
     -> m1 (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPxd $dMonad_sfPxe ds_sfPxf eta_sfPxg]
        let {
          lvl33_sfPxh [Occ=OnceL] :: m1_afyiE m_XfyJT
          [LclId] =
              [$dData_sfPxd ds_sfPxf eta_sfPxg] \u []
                  ds_sfPxf $dData_sfPxd eta_sfPxg; } in
        let {
          sat_sfPxn [Occ=Once]
            :: (m_XfyJT -> Data.Semigroup.WrappedMonoid m_XfyJT)
               -> m1_afyiE (Data.Semigroup.WrappedMonoid m_XfyJT)
          [LclId] =
              [$dMonad_sfPxe lvl33_sfPxh] \r [c'_sfPxj]
                  let {
                    sat_sfPxm [Occ=Once]
                      :: m_XfyJT -> m1_afyiE (Data.Semigroup.WrappedMonoid m_XfyJT)
                    [LclId] =
                        [$dMonad_sfPxe c'_sfPxj] \r [x'_sfPxk]
                            let {
                              sat_sfPxl [Occ=Once] :: Data.Semigroup.WrappedMonoid m_XfyJT
                              [LclId] =
                                  [c'_sfPxj x'_sfPxk] \u [] c'_sfPxj x'_sfPxk;
                            } in  GHC.Base.return $dMonad_sfPxe sat_sfPxl;
                  } in  GHC.Base.>>= $dMonad_sfPxe lvl33_sfPxh sat_sfPxm; } in
        let {
          sat_sfPxi [Occ=Once]
            :: m1_afyiE (m_XfyJT -> Data.Semigroup.WrappedMonoid m_XfyJT)
          [LclId] =
              [$dMonad_sfPxe] \u []
                  GHC.Base.return $dMonad_sfPxe Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfPxe sat_sfPxi sat_sfPxn;

Data.Semigroup.$fDataWrappedMonoid_$cgmapQi
  :: forall m.
     Data.Data.Data m =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.WrappedMonoid m
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPxo ds_sfPxp ds1_sfPxq x_sfPxr]
        case ds_sfPxp of {
          GHC.Types.I# x1_sfPxt [Occ=Once!] ->
              case x1_sfPxt of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfPxq $dData_sfPxo x_sfPxr;
              };
        };

Data.Semigroup.$fDataWrappedMonoid_$cgmapMo
  :: forall m.
     Data.Data.Data m =>
     forall (m1 :: * -> *).
     GHC.Base.MonadPlus m1 =>
     (forall d. Data.Data.Data d => d -> m1 d)
     -> Data.Semigroup.WrappedMonoid m
     -> m1 (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPxv $dMonadPlus_sfPxw ds_sfPxx eta_sfPxy]
        let {
          lvl33_sfPxz [Occ=OnceL]
            :: m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN)
          [LclId] =
              [$dMonadPlus_sfPxw] \u [] GHC.Base.mzero $dMonadPlus_sfPxw;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPxw
          of
          $dMonad_sfPxA [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPxZ [Occ=Once]
                    :: (Data.Semigroup.WrappedMonoid m_XfyJN, GHC.Types.Bool)
                       -> m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN)
                  [LclId] =
                      [lvl33_sfPxz $dMonad_sfPxA] \r [ds1_sfPxU]
                          case ds1_sfPxU of {
                            (,) x'_sfPxW [Occ=Once] b_sfPxX [Occ=Once!] ->
                                case b_sfPxX of {
                                  GHC.Types.False -> lvl33_sfPxz;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPxA x'_sfPxW;
                                };
                          }; } in
                let {
                  sat_sfPxT [Occ=Once]
                    :: m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPxv
                       $dMonadPlus_sfPxw
                       ds_sfPxx
                       eta_sfPxy
                       $dMonad_sfPxA] \u []
                          let {
                            lvl34_sfPxB [Occ=OnceL] :: m1_afyja m_XfyJN
                            [LclId] =
                                [$dData_sfPxv ds_sfPxx eta_sfPxy] \u []
                                    ds_sfPxx $dData_sfPxv eta_sfPxy; } in
                          let {
                            sat_sfPxS [Occ=Once]
                              :: (m_XfyJN -> Data.Semigroup.WrappedMonoid m_XfyJN,
                                  GHC.Types.Bool)
                                 -> m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPxw
                                 eta_sfPxy
                                 $dMonad_sfPxA
                                 lvl34_sfPxB] \r [ds1_sfPxD]
                                    case ds1_sfPxD of {
                                      (,) h_sfPxF b1_sfPxG [Occ=Once!] ->
                                          case b1_sfPxG of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfPxP [Occ=Once]
                                                    :: m1_afyja (Data.Semigroup.WrappedMonoid
                                                                   m_XfyJN,
                                                                 GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfPxy $dMonad_sfPxA h_sfPxF] \u []
                                                          let {
                                                            sat_sfPxN [Occ=Once]
                                                              :: Data.Semigroup.WrappedMonoid
                                                                   m_XfyJN
                                                            [LclId] =
                                                                [eta_sfPxy h_sfPxF] \u []
                                                                    h_sfPxF eta_sfPxy; } in
                                                          let {
                                                            sat_sfPxO [Occ=Once]
                                                              :: (Data.Semigroup.WrappedMonoid
                                                                    m_XfyJN,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfPxN
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfPxA sat_sfPxO; } in
                                                let {
                                                  sat_sfPxM [Occ=Once]
                                                    :: m1_afyja (Data.Semigroup.WrappedMonoid
                                                                   m_XfyJN,
                                                                 GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfPxA lvl34_sfPxB h_sfPxF] \u []
                                                          let {
                                                            sat_sfPxL [Occ=Once]
                                                              :: m_XfyJN
                                                                 -> m1_afyja (Data.Semigroup.WrappedMonoid
                                                                                m_XfyJN,
                                                                              GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPxA
                                                                 h_sfPxF] \r [y'_sfPxI]
                                                                    let {
                                                                      sat_sfPxJ [Occ=Once]
                                                                        :: Data.Semigroup.WrappedMonoid
                                                                             m_XfyJN
                                                                      [LclId] =
                                                                          [h_sfPxF y'_sfPxI] \u []
                                                                              h_sfPxF y'_sfPxI; } in
                                                                    let {
                                                                      sat_sfPxK [Occ=Once]
                                                                        :: (Data.Semigroup.WrappedMonoid
                                                                              m_XfyJN,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPxJ
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPxA sat_sfPxK;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfPxA lvl34_sfPxB sat_sfPxL;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfPxw sat_sfPxM sat_sfPxP;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfPxQ [Occ=Once]
                                                    :: Data.Semigroup.WrappedMonoid m_XfyJN
                                                  [LclId] =
                                                      [eta_sfPxy h_sfPxF] \u []
                                                          h_sfPxF eta_sfPxy; } in
                                                let {
                                                  sat_sfPxR [Occ=Once]
                                                    :: (Data.Semigroup.WrappedMonoid m_XfyJN,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfPxQ GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfPxA sat_sfPxR;
                                          };
                                    }; } in
                          let {
                            sat_sfPxC [Occ=Once]
                              :: m1_afyja (m_XfyJN -> Data.Semigroup.WrappedMonoid m_XfyJN,
                                           GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPxA] \u []
                                    GHC.Base.return
                                        $dMonad_sfPxA Data.Semigroup.$fDataWrappedMonoid1;
                          } in  GHC.Base.>>= $dMonad_sfPxA sat_sfPxC sat_sfPxS;
                } in  GHC.Base.>>= $dMonad_sfPxA sat_sfPxT sat_sfPxZ;
          };

lvl27_rfC7b
  :: forall m. Data.Semigroup.WrappedMonoid m -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPy0] Data.Semigroup.$cWrapMonoid;

lvl28_rfC7c
  :: forall m. Data.Semigroup.WrappedMonoid m -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPy1] Data.Semigroup.$tWrappedMonoid;

lvl29_rfC7d
  :: forall m (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.WrappedMonoid m))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPy2 ds_sfPy3] GHC.Base.Nothing [];

Data.Semigroup.$fDataWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     Data.Data.Data m =>
     Data.Data.Data (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPy4]
        let {
          sat_sfPyz [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> m (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfPy4] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapMo
                      $dData_sfPy4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPyy [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> m (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfPy4] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapMp
                      $dData_sfPy4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPyx [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> m (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfPy4] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapM
                      $dData_sfPy4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPyw [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> u
          [LclId] =
              [$dData_sfPy4] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapQi
                      $dData_sfPy4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPyv [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.WrappedMonoid m_XfyJM -> [u]
          [LclId] =
              [$dData_sfPy4] \r [ds_sfPys x0_sfPyt]
                  let {
                    sat_sfPyu [Occ=Once] :: u_afyic
                    [LclId] =
                        [$dData_sfPy4 ds_sfPys x0_sfPyt] \u []
                            ds_sfPys $dData_sfPy4 x0_sfPyt;
                  } in  : [sat_sfPyu GHC.Types.[]]; } in
        let {
          sat_sfPyr [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> r
          [LclId] =
              [$dData_sfPy4] \r [ds_sfPym ds1_sfPyn ds2_sfPyo x0_sfPyp]
                  let {
                    sat_sfPyq [Occ=Once] :: r'_afyhW
                    [LclId] =
                        [$dData_sfPy4 ds2_sfPyo x0_sfPyp] \u []
                            ds2_sfPyo $dData_sfPy4 x0_sfPyp;
                  } in  ds_sfPym sat_sfPyq ds1_sfPyn; } in
        let {
          sat_sfPyl [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> r
          [LclId] =
              [$dData_sfPy4] \r [ds_sfPyg ds1_sfPyh ds2_sfPyi eta_sfPyj]
                  let {
                    sat_sfPyk [Occ=Once] :: r'_afyhF
                    [LclId] =
                        [$dData_sfPy4 ds2_sfPyi eta_sfPyj] \u []
                            ds2_sfPyi $dData_sfPy4 eta_sfPyj;
                  } in  ds_sfPyg ds1_sfPyh sat_sfPyk; } in
        let {
          sat_sfPyf [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> Data.Semigroup.WrappedMonoid m_XfyJM
          [LclId] =
              [$dData_sfPy4] \r [ds_sfPyd x0_sfPye]
                  ds_sfPyd $dData_sfPy4 x0_sfPye; } in
        let {
          sat_sfPyc [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.WrappedMonoid m_XfyJM))
          [LclId] =
              [$dData_sfPy4] \r [eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cdataCast1
                      $dData_sfPy4 eta_B1; } in
        let {
          sat_sfPyb [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfPy4] \r [k_sfPy7 z_sfPy8 ds_sfPy9]
                  let {
                    sat_sfPya [Occ=Once]
                      :: c_afygv (m_XfyJM -> Data.Semigroup.WrappedMonoid m_XfyJM)
                    [LclId] =
                        [z_sfPy8] \u [] z_sfPy8 Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfPy7 $dData_sfPy4 sat_sfPya; } in
        let {
          sat_sfPy6 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> c (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfPy4] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgfoldl
                      $dData_sfPy4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPy5 [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfPy4] \u []
                  Data.Semigroup.$fDataWrappedMonoid8 $dData_sfPy4;
        } in 
          Data.Data.C:Data [sat_sfPy5
                            sat_sfPy6
                            sat_sfPyb
                            lvl27_rfC7b
                            lvl28_rfC7c
                            sat_sfPyc
                            lvl29_rfC7d
                            sat_sfPyf
                            sat_sfPyl
                            sat_sfPyr
                            sat_sfPyv
                            sat_sfPyw
                            sat_sfPyx
                            sat_sfPyy
                            sat_sfPyz];

Data.Semigroup.$fDataOption5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataOption6];

Data.Semigroup.$tcOption :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10723619047615802556##
                                    16447525423442151350##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataOption5
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep13_rfC7e :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcOption
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Option1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rfC6M $krep13_rfC7e];

Data.Semigroup.$tc'Option3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Option"#;

Data.Semigroup.$tc'Option2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Option3];

Data.Semigroup.$tc'Option :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10684524870560962689##
                                    6198254930115905464##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Option2
                                    1#
                                    Data.Semigroup.$tc'Option1];

Data.Semigroup.$fDataOption4
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Option
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                10723619047615802556##
                16447525423442151350##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataOption5
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPyB [Occ=Once]
                   ww9_sfPyC [Occ=Once]
                   ww10_sfPyD [Occ=Once]
                   ww11_sfPyE [Occ=Once]
                   ww12_sfPyF [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPyB
                                              ww9_sfPyC
                                              ww10_sfPyD
                                              ww11_sfPyE
                                              ww12_sfPyF];
        };

Data.Semigroup.$fDataOption10
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPyG]
        case Data.Data.$p1Data $dData_sfPyG of sat_sfPyH {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataOption4 sat_sfPyH;
        };

Data.Semigroup.$fDataOption_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Option a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPyI $dTypeable_sfPyJ]
        let {
          lvl33_sfPyK [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPyJ] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPyJ Data.Semigroup.$fDataOption4; } in
        let {
          sat_sfPyO [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afypz (t_afypy d))
               -> GHC.Base.Maybe (c_afypz (Data.Semigroup.Option a_XfyST))
          [LclId] =
              [$dData_sfPyI lvl33_sfPyK] \r [f_sfPyL]
                  case lvl33_sfPyK of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPyN [Occ=Once] :: c_afypz (Data.Semigroup.Option a_XfyST)
                          [LclId] =
                              [$dData_sfPyI f_sfPyL] \u [] f_sfPyL $dData_sfPyI;
                        } in  GHC.Base.Just [sat_sfPyN];
                  };
        } in  sat_sfPyO;

Data.Semigroup.$fDataOption1
  :: forall a.
     (GHC.Base.Maybe a -> Data.Semigroup.Option a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fDataOption2 GHC.Types.False];

Data.Semigroup.$fDataOption_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPyP $dMonadPlus_sfPyQ ds_sfPyR eta_sfPyS]
        let {
          lvl33_sfPyT [Occ=OnceL] :: m_afyrE (Data.Semigroup.Option a_XfyT2)
          [LclId] =
              [$dMonadPlus_sfPyQ] \u [] GHC.Base.mzero $dMonadPlus_sfPyQ;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPyQ
          of
          $dMonad_sfPyU [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPzh [Occ=Once]
                    :: (Data.Semigroup.Option a_XfyT2, GHC.Types.Bool)
                       -> m_afyrE (Data.Semigroup.Option a_XfyT2)
                  [LclId] =
                      [lvl33_sfPyT $dMonad_sfPyU] \r [ds1_sfPzc]
                          case ds1_sfPzc of {
                            (,) x'_sfPze [Occ=Once] b_sfPzf [Occ=Once!] ->
                                case b_sfPzf of {
                                  GHC.Types.False -> lvl33_sfPyT;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPyU x'_sfPze;
                                };
                          }; } in
                let {
                  sat_sfPzb [Occ=Once]
                    :: m_afyrE (Data.Semigroup.Option a_XfyT2, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPyP
                       $dMonadPlus_sfPyQ
                       ds_sfPyR
                       eta_sfPyS
                       $dMonad_sfPyU] \u []
                          let {
                            lvl34_sfPyV [Occ=OnceL] :: m_afyrE (GHC.Base.Maybe a_XfyT2)
                            [LclId] =
                                [$dData_sfPyP ds_sfPyR eta_sfPyS] \u []
                                    let {
                                      sat_sfPyW [Occ=Once]
                                        :: Data.Data.Data (GHC.Base.Maybe a_XfyT2)
                                      [LclId] =
                                          [$dData_sfPyP] \u [] Data.Data.$fDataMaybe $dData_sfPyP;
                                    } in  ds_sfPyR sat_sfPyW eta_sfPyS; } in
                          let {
                            sat_sfPza [Occ=Once]
                              :: (GHC.Base.Maybe a_XfyT2 -> Data.Semigroup.Option a_XfyT2,
                                  GHC.Types.Bool)
                                 -> m_afyrE (Data.Semigroup.Option a_XfyT2, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPyQ
                                 eta_sfPyS
                                 $dMonad_sfPyU
                                 lvl34_sfPyV] \r [ds1_sfPyY]
                                    case ds1_sfPyY of {
                                      (,) h_sfPz0 b1_sfPz1 [Occ=Once] ->
                                          let {
                                            sat_sfPz9 [Occ=Once]
                                              :: m_afyrE (Data.Semigroup.Option a_XfyT2,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfPyS $dMonad_sfPyU h_sfPz0 b1_sfPz1] \u []
                                                    let {
                                                      sat_sfPz7 [Occ=Once]
                                                        :: Data.Semigroup.Option a_XfyT2
                                                      [LclId] =
                                                          [eta_sfPyS h_sfPz0] \u []
                                                              h_sfPz0 eta_sfPyS; } in
                                                    let {
                                                      sat_sfPz8 [Occ=Once]
                                                        :: (Data.Semigroup.Option a_XfyT2,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfPz7 b1_sfPz1];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfPyU sat_sfPz8; } in
                                          let {
                                            sat_sfPz6 [Occ=Once]
                                              :: m_afyrE (Data.Semigroup.Option a_XfyT2,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfPyU lvl34_sfPyV h_sfPz0] \u []
                                                    let {
                                                      sat_sfPz5 [Occ=Once]
                                                        :: GHC.Base.Maybe a_XfyT2
                                                           -> m_afyrE (Data.Semigroup.Option
                                                                         a_XfyT2,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfPyU h_sfPz0] \r [y'_sfPz2]
                                                              let {
                                                                sat_sfPz3 [Occ=Once]
                                                                  :: Data.Semigroup.Option a_XfyT2
                                                                [LclId] =
                                                                    [h_sfPz0 y'_sfPz2] \u []
                                                                        h_sfPz0 y'_sfPz2; } in
                                                              let {
                                                                sat_sfPz4 [Occ=Once]
                                                                  :: (Data.Semigroup.Option a_XfyT2,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfPz3
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfPyU sat_sfPz4;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfPyU lvl34_sfPyV sat_sfPz5;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfPyQ sat_sfPz6 sat_sfPz9;
                                    }; } in
                          let {
                            sat_sfPyX [Occ=Once]
                              :: m_afyrE (GHC.Base.Maybe a_XfyT2
                                          -> Data.Semigroup.Option a_XfyT2,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPyU] \u []
                                    GHC.Base.return $dMonad_sfPyU Data.Semigroup.$fDataOption1;
                          } in  GHC.Base.>>= $dMonad_sfPyU sat_sfPyX sat_sfPza;
                } in  GHC.Base.>>= $dMonad_sfPyU sat_sfPzb sat_sfPzh;
          };

Data.Semigroup.$fDataOption_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option a)
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPzi $dMonad_sfPzj ds_sfPzk]
        let {
          $dData1_sfPzl [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_XfyT1)
          [LclId] =
              [$dData_sfPzi] \u [] Data.Data.$fDataMaybe $dData_sfPzi; } in
        let {
          lvl33_sfPzm [Occ=OnceL]
            :: m_afyro (GHC.Base.Maybe a_XfyT1
                        -> Data.Semigroup.Option a_XfyT1)
          [LclId] =
              [$dMonad_sfPzj] \u []
                  GHC.Base.return $dMonad_sfPzj Data.Semigroup.$fDataOption2; } in
        let {
          sat_sfPzu [Occ=OnceT[0]]
            :: Data.Semigroup.Option a_XfyT1
               -> m_afyro (Data.Semigroup.Option a_XfyT1)
          [LclId] =
              [$dMonad_sfPzj ds_sfPzk $dData1_sfPzl lvl33_sfPzm] \r [ds1_sfPzn]
                  let {
                    lvl34_sfPzo [Occ=OnceL] :: m_afyro (GHC.Base.Maybe a_XfyT1)
                    [LclId] =
                        [ds_sfPzk $dData1_sfPzl ds1_sfPzn] \u []
                            ds_sfPzk $dData1_sfPzl ds1_sfPzn; } in
                  let {
                    sat_sfPzt [Occ=Once]
                      :: (GHC.Base.Maybe a_XfyT1 -> Data.Semigroup.Option a_XfyT1)
                         -> m_afyro (Data.Semigroup.Option a_XfyT1)
                    [LclId] =
                        [$dMonad_sfPzj lvl34_sfPzo] \r [c'_sfPzp]
                            let {
                              sat_sfPzs [Occ=Once]
                                :: GHC.Base.Maybe a_XfyT1
                                   -> m_afyro (Data.Semigroup.Option a_XfyT1)
                              [LclId] =
                                  [$dMonad_sfPzj c'_sfPzp] \r [x'_sfPzq]
                                      let {
                                        sat_sfPzr [Occ=Once] :: Data.Semigroup.Option a_XfyT1
                                        [LclId] =
                                            [c'_sfPzp x'_sfPzq] \u [] c'_sfPzp x'_sfPzq;
                                      } in  GHC.Base.return $dMonad_sfPzj sat_sfPzr;
                            } in  GHC.Base.>>= $dMonad_sfPzj lvl34_sfPzo sat_sfPzs;
                  } in  GHC.Base.>>= $dMonad_sfPzj lvl33_sfPzm sat_sfPzt;
        } in  sat_sfPzu;

Data.Semigroup.$fDataOption_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Option a
     -> u
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPzv ds_sfPzw ds1_sfPzx x_sfPzy]
        case ds_sfPzw of {
          GHC.Types.I# x1_sfPzA [Occ=Once!] ->
              case x1_sfPzA of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# ->
                    let {
                      sat_sfPzC [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfyT0)
                      [LclId] =
                          [$dData_sfPzv] \u [] Data.Data.$fDataMaybe $dData_sfPzv;
                    } in  ds1_sfPzx sat_sfPzC x_sfPzy;
              };
        };

Data.Semigroup.$fDataOption_$cgmapQr
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Option a
     -> r
[GblId,
 Arity=5,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPzD ds_sfPzE ds1_sfPzF ds2_sfPzG x0_sfPzH]
        let {
          sat_sfPzJ [Occ=Once] :: r'_afyqG
          [LclId] =
              [$dData_sfPzD ds2_sfPzG x0_sfPzH] \u []
                  let {
                    sat_sfPzI [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfySY)
                    [LclId] =
                        [$dData_sfPzD] \u [] Data.Data.$fDataMaybe $dData_sfPzD;
                  } in  ds2_sfPzG sat_sfPzI x0_sfPzH;
        } in  ds_sfPzE sat_sfPzJ ds1_sfPzF;

Data.Semigroup.$fDataOption_$cgmapQ
  :: forall a.
     Data.Data.Data a =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Option a -> [u]
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,1*C1(C1(U))><L,U>m2,
 Unf=OtherCon []] =
    [] \r [$dData_sfPzK ds_sfPzL x0_sfPzM]
        let {
          sat_sfPzO [Occ=Once] :: u_afyqW
          [LclId] =
              [$dData_sfPzK ds_sfPzL x0_sfPzM] \u []
                  let {
                    sat_sfPzN [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfySZ)
                    [LclId] =
                        [$dData_sfPzK] \u [] Data.Data.$fDataMaybe $dData_sfPzK;
                  } in  ds_sfPzL sat_sfPzN x0_sfPzM;
        } in  : [sat_sfPzO GHC.Types.[]];

Data.Semigroup.$fDataOption_$cgmapQl
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Option a
     -> r
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPzP ds_sfPzQ ds1_sfPzR ds2_sfPzS]
        let {
          $dData1_sfPzT [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_XfySX)
          [LclId] =
              [$dData_sfPzP] \u [] Data.Data.$fDataMaybe $dData_sfPzP; } in
        let {
          sat_sfPzW [Occ=OnceT[0]]
            :: Data.Semigroup.Option a_XfySX -> r_afyqo
          [LclId] =
              [ds_sfPzQ ds1_sfPzR ds2_sfPzS $dData1_sfPzT] \r [x_sfPzU]
                  let {
                    sat_sfPzV [Occ=Once] :: r'_afyqp
                    [LclId] =
                        [ds2_sfPzS $dData1_sfPzT x_sfPzU] \u []
                            ds2_sfPzS $dData1_sfPzT x_sfPzU;
                  } in  ds_sfPzQ ds1_sfPzR sat_sfPzV;
        } in  sat_sfPzW;

Data.Semigroup.$fDataOption3
  :: forall a.
     Data.Data.Data a =>
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Semigroup.Option a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPzX ds_sfPzY x0_sfPzZ]
        let {
          sat_sfPA0 [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfySW)
          [LclId] =
              [$dData_sfPzX] \u [] Data.Data.$fDataMaybe $dData_sfPzX;
        } in  ds_sfPzY sat_sfPA0 x0_sfPzZ;

Data.Semigroup.$fDataOption_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPA1 $dMonadPlus_sfPA2 ds_sfPA3 eta_sfPA4]
        let {
          lvl33_sfPA5 [Occ=OnceL] :: m_afyrU (Data.Semigroup.Option a_XfySV)
          [LclId] =
              [$dMonadPlus_sfPA2] \u [] GHC.Base.mzero $dMonadPlus_sfPA2;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPA2
          of
          $dMonad_sfPA6 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPAw [Occ=Once]
                    :: (Data.Semigroup.Option a_XfySV, GHC.Types.Bool)
                       -> m_afyrU (Data.Semigroup.Option a_XfySV)
                  [LclId] =
                      [lvl33_sfPA5 $dMonad_sfPA6] \r [ds1_sfPAr]
                          case ds1_sfPAr of {
                            (,) x'_sfPAt [Occ=Once] b_sfPAu [Occ=Once!] ->
                                case b_sfPAu of {
                                  GHC.Types.False -> lvl33_sfPA5;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPA6 x'_sfPAt;
                                };
                          }; } in
                let {
                  sat_sfPAq [Occ=Once]
                    :: m_afyrU (Data.Semigroup.Option a_XfySV, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPA1
                       $dMonadPlus_sfPA2
                       ds_sfPA3
                       eta_sfPA4
                       $dMonad_sfPA6] \u []
                          let {
                            lvl34_sfPA7 [Occ=OnceL] :: m_afyrU (GHC.Base.Maybe a_XfySV)
                            [LclId] =
                                [$dData_sfPA1 ds_sfPA3 eta_sfPA4] \u []
                                    let {
                                      sat_sfPA8 [Occ=Once]
                                        :: Data.Data.Data (GHC.Base.Maybe a_XfySV)
                                      [LclId] =
                                          [$dData_sfPA1] \u [] Data.Data.$fDataMaybe $dData_sfPA1;
                                    } in  ds_sfPA3 sat_sfPA8 eta_sfPA4; } in
                          let {
                            sat_sfPAp [Occ=Once]
                              :: (GHC.Base.Maybe a_XfySV -> Data.Semigroup.Option a_XfySV,
                                  GHC.Types.Bool)
                                 -> m_afyrU (Data.Semigroup.Option a_XfySV, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPA2
                                 eta_sfPA4
                                 $dMonad_sfPA6
                                 lvl34_sfPA7] \r [ds1_sfPAa]
                                    case ds1_sfPAa of {
                                      (,) h_sfPAc b1_sfPAd [Occ=Once!] ->
                                          case b1_sfPAd of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfPAm [Occ=Once]
                                                    :: m_afyrU (Data.Semigroup.Option a_XfySV,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfPA4 $dMonad_sfPA6 h_sfPAc] \u []
                                                          let {
                                                            sat_sfPAk [Occ=Once]
                                                              :: Data.Semigroup.Option a_XfySV
                                                            [LclId] =
                                                                [eta_sfPA4 h_sfPAc] \u []
                                                                    h_sfPAc eta_sfPA4; } in
                                                          let {
                                                            sat_sfPAl [Occ=Once]
                                                              :: (Data.Semigroup.Option a_XfySV,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfPAk
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfPA6 sat_sfPAl; } in
                                                let {
                                                  sat_sfPAj [Occ=Once]
                                                    :: m_afyrU (Data.Semigroup.Option a_XfySV,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfPA6 lvl34_sfPA7 h_sfPAc] \u []
                                                          let {
                                                            sat_sfPAi [Occ=Once]
                                                              :: GHC.Base.Maybe a_XfySV
                                                                 -> m_afyrU (Data.Semigroup.Option
                                                                               a_XfySV,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPA6
                                                                 h_sfPAc] \r [y'_sfPAf]
                                                                    let {
                                                                      sat_sfPAg [Occ=Once]
                                                                        :: Data.Semigroup.Option
                                                                             a_XfySV
                                                                      [LclId] =
                                                                          [h_sfPAc y'_sfPAf] \u []
                                                                              h_sfPAc y'_sfPAf; } in
                                                                    let {
                                                                      sat_sfPAh [Occ=Once]
                                                                        :: (Data.Semigroup.Option
                                                                              a_XfySV,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPAg
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPA6 sat_sfPAh;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfPA6 lvl34_sfPA7 sat_sfPAi;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfPA2 sat_sfPAj sat_sfPAm;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfPAn [Occ=Once]
                                                    :: Data.Semigroup.Option a_XfySV
                                                  [LclId] =
                                                      [eta_sfPA4 h_sfPAc] \u []
                                                          h_sfPAc eta_sfPA4; } in
                                                let {
                                                  sat_sfPAo [Occ=Once]
                                                    :: (Data.Semigroup.Option a_XfySV,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfPAn GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfPA6 sat_sfPAo;
                                          };
                                    }; } in
                          let {
                            sat_sfPA9 [Occ=Once]
                              :: m_afyrU (GHC.Base.Maybe a_XfySV
                                          -> Data.Semigroup.Option a_XfySV,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPA6] \u []
                                    GHC.Base.return $dMonad_sfPA6 Data.Semigroup.$fDataOption1;
                          } in  GHC.Base.>>= $dMonad_sfPA6 sat_sfPA9 sat_sfPAp;
                } in  GHC.Base.>>= $dMonad_sfPA6 sat_sfPAq sat_sfPAw;
          };

lvl30_rfC7f
  :: forall a. Data.Semigroup.Option a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPAx] Data.Semigroup.$cOption;

lvl31_rfC7g
  :: forall a. Data.Semigroup.Option a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPAy] Data.Semigroup.$tOption;

lvl32_rfC7h
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Option a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPAz ds_sfPAA] GHC.Base.Nothing [];

Data.Semigroup.$fDataOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Option a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPAB]
        let {
          sat_sfPAN [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Option a_XfySU
               -> m (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfPAB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapMo
                      $dData_sfPAB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPAM [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Option a_XfySU
               -> m (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfPAB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapMp
                      $dData_sfPAB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPAL [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Option a_XfySU
               -> m (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfPAB] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapM
                      $dData_sfPAB eta_B2 eta_B1; } in
        let {
          sat_sfPAK [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Option a_XfySU
               -> u
          [LclId] =
              [$dData_sfPAB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQi
                      $dData_sfPAB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPAJ [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Option a_XfySU -> [u]
          [LclId] =
              [$dData_sfPAB] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQ
                      $dData_sfPAB eta_B2 eta_B1; } in
        let {
          sat_sfPAI [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Option a_XfySU
               -> r
          [LclId] =
              [$dData_sfPAB] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQr
                      $dData_sfPAB eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPAH [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Option a_XfySU
               -> r
          [LclId] =
              [$dData_sfPAB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQl
                      $dData_sfPAB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPAG [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Option a_XfySU -> Data.Semigroup.Option a_XfySU
          [LclId] =
              [$dData_sfPAB] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption3 $dData_sfPAB eta_B2 eta_B1; } in
        let {
          sat_sfPAF [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Option a_XfySU))
          [LclId] =
              [$dData_sfPAB] \r [eta_B1]
                  Data.Semigroup.$fDataOption_$cdataCast1 $dData_sfPAB eta_B1; } in
        let {
          sat_sfPAE [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfPAB] \u []
                  Data.Semigroup.$fDataOption_$cgunfold $dData_sfPAB; } in
        let {
          sat_sfPAD [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Option a_XfySU
               -> c (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfPAB] \u []
                  Data.Semigroup.$fDataOption_$cgfoldl $dData_sfPAB; } in
        let {
          sat_sfPAC [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfPAB] \u [] Data.Semigroup.$fDataOption10 $dData_sfPAB;
        } in 
          Data.Data.C:Data [sat_sfPAC
                            sat_sfPAD
                            sat_sfPAE
                            lvl30_rfC7f
                            lvl31_rfC7g
                            sat_sfPAF
                            lvl32_rfC7h
                            sat_sfPAG
                            sat_sfPAH
                            sat_sfPAI
                            sat_sfPAJ
                            sat_sfPAK
                            sat_sfPAL
                            sat_sfPAM
                            sat_sfPAN];

Data.Semigroup.Arg :: forall a b. a -> b -> Data.Semigroup.Arg a b
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Semigroup.Arg [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:11:40.353689679 UTC

Data.Semigroup.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Min a
     -> [Data.Semigroup.Min a] -> Data.Semigroup.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfORT ww_sfORU ww1_sfORV]
        let {
          go_sfORW [Occ=LoopBreaker]
            :: Data.Semigroup.Min a_sfBoZ
               -> [Data.Semigroup.Min a_sfBoZ] -> Data.Semigroup.Min a_sfBoZ
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfORT go_sfORW] \r [b_sfORX ds1_sfORY]
                  case ds1_sfORY of {
                    [] -> b_sfORX;
                    : c_sfOS0 [Occ=Once] cs_sfOS1 [Occ=Once] ->
                        let {
                          sat_sfOS2 [Occ=Once] :: a_sfBoZ
                          [LclId] =
                              [go_sfORW c_sfOS0 cs_sfOS1] \u [] go_sfORW c_sfOS0 cs_sfOS1;
                        } in  GHC.Classes.min w_sfORT b_sfORX sat_sfOS2;
                  };
        } in  go_sfORW ww_sfORU ww1_sfORV;

Data.Semigroup.$fSemigroupMin_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Semigroup.Min a) -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfOS3 w1_sfOS4]
        case w1_sfOS4 of {
          GHC.Base.:| ww1_sfOS6 [Occ=Once] ww2_sfOS7 [Occ=Once] ->
              Data.Semigroup.$w$csconcat1 w_sfOS3 ww1_sfOS6 ww2_sfOS7;
        };

lvl_rfC66
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfOS8 eta_sfOS9 eta1_sfOSa]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfOS8 eta_sfOS9 eta1_sfOSa;

Data.Semigroup.$fSemigroupMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,A,A,U)>m] =
    [] \r [$dOrd_sfOSb]
        let {
          sat_sfOSd [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Min a_afzf5)
               -> Data.Semigroup.Min a_afzf5
          [LclId] =
              [$dOrd_sfOSb] \r [eta_B1]
                  Data.Semigroup.$fSemigroupMin_$csconcat $dOrd_sfOSb eta_B1; } in
        let {
          sat_sfOSc [Occ=Once]
            :: Data.Semigroup.Min a_afzf5
               -> Data.Semigroup.Min a_afzf5 -> Data.Semigroup.Min a_afzf5
          [LclId] =
              [$dOrd_sfOSb] \u [] GHC.Classes.min $dOrd_sfOSb;
        } in  GHC.Base.C:Semigroup [sat_sfOSc sat_sfOSd lvl_rfC66];

Data.Semigroup.$fFunctorMin2
  :: forall a b. (a -> b) -> Data.Semigroup.Min a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOSe ds_sfOSf] f_sfOSe ds_sfOSf;

Data.Semigroup.$fFunctorMin1
  :: forall b a. a -> Data.Semigroup.Min b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sfOSg ds_sfOSh] x_sfOSg;

Data.Semigroup.$fFunctorMin [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorMin2
                                       Data.Semigroup.$fFunctorMin1];

Data.Semigroup.$fFoldableMin_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Min a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOSi f_sfOSj ds_sfOSk] f_sfOSj ds_sfOSk;

Data.Semigroup.$fFoldableMin4
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.Min m -> Data.Semigroup.Min m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOSl ds_sfOSm] ds_sfOSm;

Data.Semigroup.$fFoldableMin1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfOSn eta_sfOSo] eta_sfOSo;

Data.Semigroup.$fFoldableMin2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOSp x_sfOSq] x_sfOSq;

Data.Semigroup.$fFoldableMin_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Min a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfOSr eta_sfOSs]
        let {
          f_sfOSt [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afzdA -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfOSr eta_sfOSs] \u []
                  GHC.Classes.== $dEq_sfOSr eta_sfOSs; } in
        let {
          sat_sfOSv [Occ=OnceT[0]]
            :: Data.Semigroup.Min a_afzdA -> GHC.Types.Bool
          [LclId] =
              [f_sfOSt] \r [ds_sfOSu] f_sfOSt ds_sfOSu;
        } in  sat_sfOSv;

Data.Semigroup.$fFoldableMin_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Min a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOSw z_sfOSx t1_sfOSy] f_sfOSw z_sfOSx t1_sfOSy;

Data.Semigroup.$fFoldableMin3
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfOSz xs_sfOSA] xs_sfOSA;

Data.Semigroup.$fFoldableMin_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Min a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOSB z0_sfOSC xs_sfOSD] f_sfOSB xs_sfOSD z0_sfOSC;

Data.Semigroup.$fFoldableFirst3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Semigroup.$fFoldableMin_$clength
  :: forall a. Data.Semigroup.Min a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfOSE] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableMin_$cnull
  :: forall a. Data.Semigroup.Min a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfOSF] GHC.Types.False [];

Data.Semigroup.$fFoldableMin_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Min a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfOSG] : [eta_sfOSG GHC.Types.[]];

Data.Semigroup.$fFoldableMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Min
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableMin4
                                             Data.Semigroup.$fFoldableMin_$cfoldMap
                                             Data.Semigroup.$fFoldableMin_$cfoldr'
                                             Data.Semigroup.$fFoldableMin_$cfoldr'
                                             Data.Semigroup.$fFoldableMin_$cfoldl
                                             Data.Semigroup.$fFoldableMin_$cfoldl
                                             Data.Semigroup.$fFoldableMin3
                                             Data.Semigroup.$fFoldableMin3
                                             Data.Semigroup.$fFoldableMin_$ctoList
                                             Data.Semigroup.$fFoldableMin_$cnull
                                             Data.Semigroup.$fFoldableMin_$clength
                                             Data.Semigroup.$fFoldableMin_$celem
                                             Data.Semigroup.$fFoldableMin2
                                             Data.Semigroup.$fFoldableMin2
                                             Data.Semigroup.$fFoldableMin1
                                             Data.Semigroup.$fFoldableMin1];

Data.Semigroup.$fApplicativeFirst3 :: forall b. b -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfOSH] v_sfOSH;

Data.Semigroup.$fTraversableMin_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.Min a -> f (Data.Semigroup.Min b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfOSI eta_sfOSJ eta1_sfOSK]
        let {
          sat_sfOSM [Occ=Once] :: f_afzb8 b_afzba
          [LclId] =
              [eta_sfOSJ eta1_sfOSK] \u [] eta_sfOSJ eta1_sfOSK;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfOSI of sat_sfOSL {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfOSL Data.Semigroup.$fApplicativeFirst3 sat_sfOSM;
          };

Data.Semigroup.$fTraversableMin_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Min (f a) -> f (Data.Semigroup.Min a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfOSN eta_sfOSO]
        case GHC.Base.$p1Applicative $dApplicative_sfOSN of sat_sfOSP {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfOSP Data.Semigroup.$fApplicativeFirst3 eta_sfOSO;
        };

Data.Semigroup.$fTraversableMin_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.Min a -> m (Data.Semigroup.Min b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfOSQ eta_sfOSR eta1_sfOSS]
        let {
          sat_sfOSV [Occ=Once] :: m_afzby b_afzbA
          [LclId] =
              [eta_sfOSR eta1_sfOSS] \u [] eta_sfOSR eta1_sfOSS;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfOSQ of sat_sfOST {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfOST of sat_sfOSU {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfOSU Data.Semigroup.$fApplicativeFirst3 sat_sfOSV;
                };
          };

Data.Semigroup.$fTraversableMin_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Min (m a) -> m (Data.Semigroup.Min a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfOSW eta_sfOSX]
        case GHC.Base.$p1Monad $dMonad_sfOSW of sat_sfOSY {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfOSY of sat_sfOSZ {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfOSZ Data.Semigroup.$fApplicativeFirst3 eta_sfOSX;
              };
        };

Data.Semigroup.$fTraversableMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorMin
                                                   Data.Semigroup.$fFoldableMin
                                                   Data.Semigroup.$fTraversableMin_$ctraverse
                                                   Data.Semigroup.$fTraversableMin_$csequenceA
                                                   Data.Semigroup.$fTraversableMin_$cmapM
                                                   Data.Semigroup.$fTraversableMin_$csequence];

Data.Semigroup.$fApplicativeMin_$c<*
  :: forall a b.
     Data.Semigroup.Min a
     -> Data.Semigroup.Min b -> Data.Semigroup.Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfOT0 ds_sfOT1] a1_sfOT0;

Data.Semigroup.$fApplicativeMin_$c*>
  :: forall a b.
     Data.Semigroup.Min a
     -> Data.Semigroup.Min b -> Data.Semigroup.Min b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfOT2 a1_sfOT3] a1_sfOT3;

Data.Semigroup.$fApplicativeFirst1
  :: forall a b c. (a -> b -> c) -> a -> b -> c
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfOT4] v_sfOT4;

Data.Semigroup.$fApplicativeMin1
  :: forall a b.
     Data.Semigroup.Min (a -> b) -> Data.Semigroup.Min (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfOT5] v_sfOT5;

Data.Semigroup.$fApplicativeMin [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorMin
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeMin1
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeMin_$c*>
                                           Data.Semigroup.$fApplicativeMin_$c<*];

Data.Semigroup.$fMonadMin_$c>>=
  :: forall a b.
     Data.Semigroup.Min a
     -> (a -> Data.Semigroup.Min b) -> Data.Semigroup.Min b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfOT6 f_sfOT7] f_sfOT7 ds_sfOT6;

lvl1_rfC67 :: forall a. [GHC.Types.Char] -> Data.Semigroup.Min a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfOT8] GHC.Err.errorWithoutStackTrace eta_sfOT8;

Data.Semigroup.$fMonadMin [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeMin
                                     Data.Semigroup.$fMonadMin_$c>>=
                                     Data.Semigroup.$fApplicativeMin_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl1_rfC67];

Data.Semigroup.$fNumMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U))>m] =
    [] \r [$dNum_sfOT9]
        let {
          sat_sfOTq [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [eta_sfOTp]
                  GHC.Num.fromInteger $dNum_sfOT9 eta_sfOTp; } in
        let {
          sat_sfOTo [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [ds_sfOTn]
                  GHC.Num.signum $dNum_sfOT9 ds_sfOTn; } in
        let {
          sat_sfOTm [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [ds_sfOTl] GHC.Num.abs $dNum_sfOT9 ds_sfOTl; } in
        let {
          sat_sfOTk [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [ds_sfOTj]
                  GHC.Num.negate $dNum_sfOT9 ds_sfOTj; } in
        let {
          sat_sfOTi [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK
               -> Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [ds_sfOTg ds1_sfOTh]
                  GHC.Num.* $dNum_sfOT9 ds_sfOTg ds1_sfOTh; } in
        let {
          sat_sfOTf [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK
               -> Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [ds_sfOTd ds1_sfOTe]
                  GHC.Num.- $dNum_sfOT9 ds_sfOTd ds1_sfOTe; } in
        let {
          sat_sfOTc [Occ=Once]
            :: Data.Semigroup.Min a_XfzlK
               -> Data.Semigroup.Min a_XfzlK -> Data.Semigroup.Min a_XfzlK
          [LclId] =
              [$dNum_sfOT9] \r [ds_sfOTa ds1_sfOTb]
                  GHC.Num.+ $dNum_sfOT9 ds_sfOTa ds1_sfOTb;
        } in 
          GHC.Num.C:Num [sat_sfOTc
                         sat_sfOTf
                         sat_sfOTi
                         sat_sfOTk
                         sat_sfOTm
                         sat_sfOTo
                         sat_sfOTq];

Data.Semigroup.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Max a
     -> [Data.Semigroup.Max a] -> Data.Semigroup.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfOTr ww_sfOTs ww1_sfOTt]
        let {
          go_sfOTu [Occ=LoopBreaker]
            :: Data.Semigroup.Max a_sfBpa
               -> [Data.Semigroup.Max a_sfBpa] -> Data.Semigroup.Max a_sfBpa
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfOTr go_sfOTu] \r [b_sfOTv ds1_sfOTw]
                  case ds1_sfOTw of {
                    [] -> b_sfOTv;
                    : c_sfOTy [Occ=Once] cs_sfOTz [Occ=Once] ->
                        let {
                          sat_sfOTA [Occ=Once] :: a_sfBpa
                          [LclId] =
                              [go_sfOTu c_sfOTy cs_sfOTz] \u [] go_sfOTu c_sfOTy cs_sfOTz;
                        } in  GHC.Classes.max w_sfOTr b_sfOTv sat_sfOTA;
                  };
        } in  go_sfOTu ww_sfOTs ww1_sfOTt;

Data.Semigroup.$fSemigroupMax_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty (Data.Semigroup.Max a) -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfOTB w1_sfOTC]
        case w1_sfOTC of {
          GHC.Base.:| ww1_sfOTE [Occ=Once] ww2_sfOTF [Occ=Once] ->
              Data.Semigroup.$w$csconcat w_sfOTB ww1_sfOTE ww2_sfOTF;
        };

lvl2_rfC68
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfOTG eta_sfOTH eta1_sfOTI]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfOTG eta_sfOTH eta1_sfOTI;

Data.Semigroup.$fSemigroupMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Semigroup (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,A,U,A)>m] =
    [] \r [$dOrd_sfOTJ]
        let {
          sat_sfOTL [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Max a_afz6w)
               -> Data.Semigroup.Max a_afz6w
          [LclId] =
              [$dOrd_sfOTJ] \r [eta_B1]
                  Data.Semigroup.$fSemigroupMax_$csconcat $dOrd_sfOTJ eta_B1; } in
        let {
          sat_sfOTK [Occ=Once]
            :: Data.Semigroup.Max a_afz6w
               -> Data.Semigroup.Max a_afz6w -> Data.Semigroup.Max a_afz6w
          [LclId] =
              [$dOrd_sfOTJ] \u [] GHC.Classes.max $dOrd_sfOTJ;
        } in  GHC.Base.C:Semigroup [sat_sfOTK sat_sfOTL lvl2_rfC68];

Data.Semigroup.$fFunctorMax2
  :: forall a b. (a -> b) -> Data.Semigroup.Max a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOTM ds_sfOTN] f_sfOTM ds_sfOTN;

Data.Semigroup.$fFunctorMax1
  :: forall b a. a -> Data.Semigroup.Max b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sfOTO ds_sfOTP] x_sfOTO;

Data.Semigroup.$fFunctorMax [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorMax2
                                       Data.Semigroup.$fFunctorMax1];

Data.Semigroup.$fFoldableMax_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Max a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOTQ f_sfOTR ds_sfOTS] f_sfOTR ds_sfOTS;

Data.Semigroup.$fFoldableMax4
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.Max m -> Data.Semigroup.Max m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOTT ds_sfOTU] ds_sfOTU;

Data.Semigroup.$fFoldableMax1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfOTV eta_sfOTW] eta_sfOTW;

Data.Semigroup.$fFoldableMax2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOTX x_sfOTY] x_sfOTY;

Data.Semigroup.$fFoldableMax_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Max a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfOTZ eta_sfOU0]
        let {
          f_sfOU1 [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afz51 -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfOTZ eta_sfOU0] \u []
                  GHC.Classes.== $dEq_sfOTZ eta_sfOU0; } in
        let {
          sat_sfOU3 [Occ=OnceT[0]]
            :: Data.Semigroup.Max a_afz51 -> GHC.Types.Bool
          [LclId] =
              [f_sfOU1] \r [ds_sfOU2] f_sfOU1 ds_sfOU2;
        } in  sat_sfOU3;

Data.Semigroup.$fFoldableMax_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Max a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOU4 z_sfOU5 t1_sfOU6] f_sfOU4 z_sfOU5 t1_sfOU6;

Data.Semigroup.$fFoldableMax3
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfOU7 xs_sfOU8] xs_sfOU8;

Data.Semigroup.$fFoldableMax_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Max a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOU9 z0_sfOUa xs_sfOUb] f_sfOU9 xs_sfOUb z0_sfOUa;

Data.Semigroup.$fFoldableMax_$clength
  :: forall a. Data.Semigroup.Max a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfOUc] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableMax_$cnull
  :: forall a. Data.Semigroup.Max a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfOUd] GHC.Types.False [];

Data.Semigroup.$fFoldableMax_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Max a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfOUe] : [eta_sfOUe GHC.Types.[]];

Data.Semigroup.$fFoldableMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Max
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableMax4
                                             Data.Semigroup.$fFoldableMax_$cfoldMap
                                             Data.Semigroup.$fFoldableMax_$cfoldr'
                                             Data.Semigroup.$fFoldableMax_$cfoldr'
                                             Data.Semigroup.$fFoldableMax_$cfoldl
                                             Data.Semigroup.$fFoldableMax_$cfoldl
                                             Data.Semigroup.$fFoldableMax3
                                             Data.Semigroup.$fFoldableMax3
                                             Data.Semigroup.$fFoldableMax_$ctoList
                                             Data.Semigroup.$fFoldableMax_$cnull
                                             Data.Semigroup.$fFoldableMax_$clength
                                             Data.Semigroup.$fFoldableMax_$celem
                                             Data.Semigroup.$fFoldableMax2
                                             Data.Semigroup.$fFoldableMax2
                                             Data.Semigroup.$fFoldableMax1
                                             Data.Semigroup.$fFoldableMax1];

Data.Semigroup.$fTraversableMax_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.Max a -> f (Data.Semigroup.Max b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfOUf eta_sfOUg eta1_sfOUh]
        let {
          sat_sfOUj [Occ=Once] :: f_afz2z b_afz2B
          [LclId] =
              [eta_sfOUg eta1_sfOUh] \u [] eta_sfOUg eta1_sfOUh;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfOUf of sat_sfOUi {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfOUi Data.Semigroup.$fApplicativeFirst3 sat_sfOUj;
          };

Data.Semigroup.$fTraversableMax_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Max (f a) -> f (Data.Semigroup.Max a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfOUk eta_sfOUl]
        case GHC.Base.$p1Applicative $dApplicative_sfOUk of sat_sfOUm {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfOUm Data.Semigroup.$fApplicativeFirst3 eta_sfOUl;
        };

Data.Semigroup.$fTraversableMax_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.Max a -> m (Data.Semigroup.Max b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfOUn eta_sfOUo eta1_sfOUp]
        let {
          sat_sfOUs [Occ=Once] :: m_afz2Z b_afz31
          [LclId] =
              [eta_sfOUo eta1_sfOUp] \u [] eta_sfOUo eta1_sfOUp;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfOUn of sat_sfOUq {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfOUq of sat_sfOUr {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfOUr Data.Semigroup.$fApplicativeFirst3 sat_sfOUs;
                };
          };

Data.Semigroup.$fTraversableMax_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Max (m a) -> m (Data.Semigroup.Max a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfOUt eta_sfOUu]
        case GHC.Base.$p1Monad $dMonad_sfOUt of sat_sfOUv {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfOUv of sat_sfOUw {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfOUw Data.Semigroup.$fApplicativeFirst3 eta_sfOUu;
              };
        };

Data.Semigroup.$fTraversableMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorMax
                                                   Data.Semigroup.$fFoldableMax
                                                   Data.Semigroup.$fTraversableMax_$ctraverse
                                                   Data.Semigroup.$fTraversableMax_$csequenceA
                                                   Data.Semigroup.$fTraversableMax_$cmapM
                                                   Data.Semigroup.$fTraversableMax_$csequence];

Data.Semigroup.$fApplicativeMax_$c<*
  :: forall a b.
     Data.Semigroup.Max a
     -> Data.Semigroup.Max b -> Data.Semigroup.Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfOUx ds_sfOUy] a1_sfOUx;

Data.Semigroup.$fApplicativeMax_$c*>
  :: forall a b.
     Data.Semigroup.Max a
     -> Data.Semigroup.Max b -> Data.Semigroup.Max b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfOUz a1_sfOUA] a1_sfOUA;

Data.Semigroup.$fApplicativeMax1
  :: forall a b.
     Data.Semigroup.Max (a -> b) -> Data.Semigroup.Max (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfOUB] v_sfOUB;

Data.Semigroup.$fApplicativeMax [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorMax
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeMax1
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeMax_$c*>
                                           Data.Semigroup.$fApplicativeMax_$c<*];

Data.Semigroup.$fMonadMax_$c>>=
  :: forall a b.
     Data.Semigroup.Max a
     -> (a -> Data.Semigroup.Max b) -> Data.Semigroup.Max b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfOUC f_sfOUD] f_sfOUD ds_sfOUC;

lvl3_rfC69 :: forall a. [GHC.Types.Char] -> Data.Semigroup.Max a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfOUE] GHC.Err.errorWithoutStackTrace eta_sfOUE;

Data.Semigroup.$fMonadMax [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeMax
                                     Data.Semigroup.$fMonadMax_$c>>=
                                     Data.Semigroup.$fApplicativeMax_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl3_rfC69];

Data.Semigroup.$fNumMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U))>m] =
    [] \r [$dNum_sfOUF]
        let {
          sat_sfOUW [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [eta_sfOUV]
                  GHC.Num.fromInteger $dNum_sfOUF eta_sfOUV; } in
        let {
          sat_sfOUU [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [ds_sfOUT]
                  GHC.Num.signum $dNum_sfOUF ds_sfOUT; } in
        let {
          sat_sfOUS [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [ds_sfOUR] GHC.Num.abs $dNum_sfOUF ds_sfOUR; } in
        let {
          sat_sfOUQ [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [ds_sfOUP]
                  GHC.Num.negate $dNum_sfOUF ds_sfOUP; } in
        let {
          sat_sfOUO [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3
               -> Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [ds_sfOUM ds1_sfOUN]
                  GHC.Num.* $dNum_sfOUF ds_sfOUM ds1_sfOUN; } in
        let {
          sat_sfOUL [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3
               -> Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [ds_sfOUJ ds1_sfOUK]
                  GHC.Num.- $dNum_sfOUF ds_sfOUJ ds1_sfOUK; } in
        let {
          sat_sfOUI [Occ=Once]
            :: Data.Semigroup.Max a_Xfzf3
               -> Data.Semigroup.Max a_Xfzf3 -> Data.Semigroup.Max a_Xfzf3
          [LclId] =
              [$dNum_sfOUF] \r [ds_sfOUG ds1_sfOUH]
                  GHC.Num.+ $dNum_sfOUF ds_sfOUG ds1_sfOUH;
        } in 
          GHC.Num.C:Num [sat_sfOUI
                         sat_sfOUL
                         sat_sfOUO
                         sat_sfOUQ
                         sat_sfOUS
                         sat_sfOUU
                         sat_sfOUW];

Data.Semigroup.$fFunctorArg_$cfmap
  :: forall a1 a2 b.
     (a2 -> b) -> Data.Semigroup.Arg a1 a2 -> Data.Semigroup.Arg a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sfOUX ds_sfOUY]
        case ds_sfOUY of {
          Data.Semigroup.Arg x_sfOV0 [Occ=Once] a2_sfOV1 [Occ=Once] ->
              let {
                sat_sfOV2 [Occ=Once] :: b_afyZC
                [LclId] =
                    [f_sfOUX a2_sfOV1] \u [] f_sfOUX a2_sfOV1;
              } in  Data.Semigroup.Arg [x_sfOV0 sat_sfOV2];
        };

Data.Semigroup.$fFunctorArg_$c<$
  :: forall a1 a2 b.
     a2 -> Data.Semigroup.Arg a1 b -> Data.Semigroup.Arg a1 a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [x_sfOV3 ds_sfOV4]
        case ds_sfOV4 of {
          Data.Semigroup.Arg x1_sfOV6 [Occ=Once] _ [Occ=Dead] ->
              Data.Semigroup.Arg [x1_sfOV6 x_sfOV3];
        };

Data.Semigroup.$fFunctorArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Functor (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorArg_$cfmap
                                       Data.Semigroup.$fFunctorArg_$c<$];

Data.Semigroup.$fFoldableArg_$cfoldMap
  :: forall a1 m a2.
     GHC.Base.Monoid m =>
     (a2 -> m) -> Data.Semigroup.Arg a1 a2 -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOV8 f_sfOV9 ds_sfOVa]
        case ds_sfOVa of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVd [Occ=Once] ->
              f_sfOV9 a2_sfOVd;
        };

Data.Semigroup.$fFoldableArg_$cfold
  :: forall a m. GHC.Base.Monoid m => Data.Semigroup.Arg a m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOVe ds_sfOVf]
        case ds_sfOVf of {
          Data.Semigroup.Arg _ [Occ=Dead] a1_sfOVi [Occ=Once] -> a1_sfOVi;
        };

Data.Semigroup.$fFoldableArg2
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Semigroup.Arg a1 a2 -> Data.Semigroup.Internal.Sum a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfOVj eta_sfOVk]
        case eta_sfOVk of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVn [Occ=Once] -> a2_sfOVn;
        };

Data.Semigroup.$fFoldableArg3
  :: forall a1 a2. Data.Semigroup.Arg a2 a1 -> a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [x_sfOVo]
        case x_sfOVo of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVr [Occ=Once] -> a2_sfOVr;
        };

Data.Semigroup.$fFoldableArg_$cminimum
  :: forall a1 a2.
     GHC.Classes.Ord a2 =>
     Data.Semigroup.Arg a1 a2 -> a2
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sfOVs eta_B1] Data.Semigroup.$fFoldableArg3 eta_B1;

Data.Semigroup.$fFoldableArg_$celem
  :: forall a1 a2.
     GHC.Classes.Eq a2 =>
     a2 -> Data.Semigroup.Arg a1 a2 -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfOVt eta_sfOVu]
        let {
          f_sfOVv [Occ=OnceL!, Dmd=<L,C(U)>] :: a1_afyYK -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfOVt eta_sfOVu] \u []
                  GHC.Classes.== $dEq_sfOVt eta_sfOVu; } in
        let {
          sat_sfOVA [Occ=Once]
            :: Data.Semigroup.Arg a_XfzaV a1_afyYK
               -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_sfOVv] \r [ds_sfOVw]
                  case ds_sfOVw of {
                    Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVz [Occ=Once] ->
                        f_sfOVv a2_sfOVz;
                  };
        } in  sat_sfOVA;

Data.Semigroup.$fFoldableArg_$cfoldl
  :: forall a1 b a2.
     (b -> a2 -> b) -> b -> Data.Semigroup.Arg a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfOVB z_sfOVC t1_sfOVD]
        case t1_sfOVD of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVG [Occ=Once] ->
              f_sfOVB z_sfOVC a2_sfOVG;
        };

Data.Semigroup.$fFoldableArg_$cfoldl1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Data.Semigroup.Arg a1 a2 -> a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sfOVH xs_sfOVI]
        case xs_sfOVI of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVL [Occ=Once] -> a2_sfOVL;
        };

Data.Semigroup.$fFoldableArg_$cfoldr'
  :: forall a1 a2 b.
     (a2 -> b -> b) -> b -> Data.Semigroup.Arg a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfOVM z0_sfOVN xs_sfOVO]
        case xs_sfOVO of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOVR [Occ=Once] ->
              f_sfOVM a2_sfOVR z0_sfOVN;
        };

Data.Semigroup.$fFoldableArg_$clength
  :: forall a1 a2. Data.Semigroup.Arg a1 a2 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_sfOVS]
        case xs_sfOVS of {
          Data.Semigroup.Arg _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Semigroup.$fFoldableFirst3;
        };

Data.Semigroup.$fFoldableArg_$cnull
  :: forall a1 a2. Data.Semigroup.Arg a1 a2 -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [t1_sfOVW]
        case t1_sfOVW of {
          Data.Semigroup.Arg _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Semigroup.$fFoldableArg1
  :: forall a1 a2.
     GHC.Num.Num a2 =>
     Data.Semigroup.Arg a1 a2 -> Data.Semigroup.Internal.Product a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfOW0 eta_sfOW1]
        case eta_sfOW1 of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOW4 [Occ=Once] -> a2_sfOW4;
        };

Data.Semigroup.$fFoldableArg_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. Data.Semigroup.Arg a1 a2 -> [a2]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_sfOW5]
        case eta_sfOW5 of {
          Data.Semigroup.Arg _ [Occ=Dead] a2_sfOW8 [Occ=Once] ->
              : [a2_sfOW8 GHC.Types.[]];
        };

Data.Semigroup.$fFoldableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Foldable.Foldable (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableArg_$cfold
                                             Data.Semigroup.$fFoldableArg_$cfoldMap
                                             Data.Semigroup.$fFoldableArg_$cfoldr'
                                             Data.Semigroup.$fFoldableArg_$cfoldr'
                                             Data.Semigroup.$fFoldableArg_$cfoldl
                                             Data.Semigroup.$fFoldableArg_$cfoldl
                                             Data.Semigroup.$fFoldableArg_$cfoldl1
                                             Data.Semigroup.$fFoldableArg_$cfoldl1
                                             Data.Semigroup.$fFoldableArg_$ctoList
                                             Data.Semigroup.$fFoldableArg_$cnull
                                             Data.Semigroup.$fFoldableArg_$clength
                                             Data.Semigroup.$fFoldableArg_$celem
                                             Data.Semigroup.$fFoldableArg_$cminimum
                                             Data.Semigroup.$fFoldableArg_$cminimum
                                             Data.Semigroup.$fFoldableArg2
                                             Data.Semigroup.$fFoldableArg1];

Data.Semigroup.$fTraversableArg_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     GHC.Base.Applicative f =>
     (a2 -> f b)
     -> Data.Semigroup.Arg a1 a2 -> f (Data.Semigroup.Arg a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfOW9 eta_sfOWa eta1_sfOWb]
        case eta1_sfOWb of {
          Data.Semigroup.Arg x_sfOWd [Occ=OnceL] a2_sfOWe [Occ=Once] ->
              let {
                sat_sfOWh [Occ=Once] :: f_afyWg b_afyWi
                [LclId] =
                    [eta_sfOWa a2_sfOWe] \u [] eta_sfOWa a2_sfOWe; } in
              let {
                sat_sfOWg [Occ=Once]
                  :: b_afyWi -> Data.Semigroup.Arg a_afyW4 b_afyWi
                [LclId] =
                    [x_sfOWd] \r [eta_B1] Data.Semigroup.Arg [x_sfOWd eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfOW9 of sat_sfOWf {
                  __DEFAULT -> GHC.Base.fmap sat_sfOWf sat_sfOWg sat_sfOWh;
                };
        };

Data.Semigroup.$fTraversableArg_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     GHC.Base.Applicative f =>
     Data.Semigroup.Arg a1 (f a2) -> f (Data.Semigroup.Arg a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfOWi eta_sfOWj]
        case eta_sfOWj of {
          Data.Semigroup.Arg x_sfOWl [Occ=OnceL] a2_sfOWm [Occ=Once] ->
              let {
                sat_sfOWo [Occ=Once]
                  :: a1_afyWw -> Data.Semigroup.Arg a_afyW4 a1_afyWw
                [LclId] =
                    [x_sfOWl] \r [eta_B1] Data.Semigroup.Arg [x_sfOWl eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfOWi of sat_sfOWn {
                  __DEFAULT -> GHC.Base.fmap sat_sfOWn sat_sfOWo a2_sfOWm;
                };
        };

Data.Semigroup.$fTraversableArg_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     GHC.Base.Monad m =>
     (a2 -> m b)
     -> Data.Semigroup.Arg a1 a2 -> m (Data.Semigroup.Arg a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfOWp eta_sfOWq eta1_sfOWr]
        case eta1_sfOWr of {
          Data.Semigroup.Arg x_sfOWt [Occ=OnceL] a2_sfOWu [Occ=Once] ->
              let {
                sat_sfOWy [Occ=Once] :: m_afyWH b_afyWJ
                [LclId] =
                    [eta_sfOWq a2_sfOWu] \u [] eta_sfOWq a2_sfOWu; } in
              let {
                sat_sfOWx [Occ=Once]
                  :: b_afyWJ -> Data.Semigroup.Arg a_afyW4 b_afyWJ
                [LclId] =
                    [x_sfOWt] \r [eta_B1] Data.Semigroup.Arg [x_sfOWt eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sfOWp of sat_sfOWv {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sfOWv of sat_sfOWw {
                        __DEFAULT -> GHC.Base.fmap sat_sfOWw sat_sfOWx sat_sfOWy;
                      };
                };
        };

Data.Semigroup.$fTraversableArg_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     GHC.Base.Monad m =>
     Data.Semigroup.Arg a1 (m a2) -> m (Data.Semigroup.Arg a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfOWz eta_sfOWA]
        case eta_sfOWA of {
          Data.Semigroup.Arg x_sfOWC [Occ=OnceL] a2_sfOWD [Occ=Once] ->
              let {
                sat_sfOWG [Occ=Once]
                  :: a1_afyWW -> Data.Semigroup.Arg a_afyW4 a1_afyWW
                [LclId] =
                    [x_sfOWC] \r [eta_B1] Data.Semigroup.Arg [x_sfOWC eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sfOWz of sat_sfOWE {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sfOWE of sat_sfOWF {
                        __DEFAULT -> GHC.Base.fmap sat_sfOWF sat_sfOWG a2_sfOWD;
                      };
                };
        };

Data.Semigroup.$fTraversableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Traversable.Traversable (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorArg
                                                   Data.Semigroup.$fFoldableArg
                                                   Data.Semigroup.$fTraversableArg_$ctraverse
                                                   Data.Semigroup.$fTraversableArg_$csequenceA
                                                   Data.Semigroup.$fTraversableArg_$cmapM
                                                   Data.Semigroup.$fTraversableArg_$csequence];

Data.Semigroup.$fEqArg_$c==
  :: forall a b.
     GHC.Classes.Eq a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfOWH ds_sfOWI ds1_sfOWJ]
        case ds_sfOWI of {
          Data.Semigroup.Arg a1_sfOWL [Occ=Once] _ [Occ=Dead] ->
              case ds1_sfOWJ of {
                Data.Semigroup.Arg b1_sfOWO [Occ=Once] _ [Occ=Dead] ->
                    GHC.Classes.== $dEq_sfOWH a1_sfOWL b1_sfOWO;
              };
        };

Data.Semigroup.$fEqArg_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     GHC.Classes.Eq a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfOWQ eta_sfOWR eta1_sfOWS]
        case eta_sfOWR of {
          Data.Semigroup.Arg a1_sfOWU [Occ=Once] _ [Occ=Dead] ->
              case eta1_sfOWS of {
                Data.Semigroup.Arg b1_sfOWX [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.== $dEq_sfOWQ a1_sfOWU b1_sfOWX of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Semigroup.$fEqArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Arg a b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sfOX0]
        let {
          sat_sfOX2 [Occ=Once]
            :: Data.Semigroup.Arg a_afyVO b_afyVP
               -> Data.Semigroup.Arg a_afyVO b_afyVP -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfOX0] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fEqArg_$c/= $dEq_sfOX0 eta_B2 eta_B1; } in
        let {
          sat_sfOX1 [Occ=Once]
            :: Data.Semigroup.Arg a_afyVO b_afyVP
               -> Data.Semigroup.Arg a_afyVO b_afyVP -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfOX0] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fEqArg_$c== $dEq_sfOX0 eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sfOX1 sat_sfOX2];

Data.Semigroup.$fOrdArg_$cmin
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b
     -> Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOX3 x_sfOX4 y_sfOX5]
        case x_sfOX4 of wild_sfOX6 {
          Data.Semigroup.Arg a1_sfOX7 [Occ=Once] _ [Occ=Dead] ->
              case y_sfOX5 of wild1_sfOX9 {
                Data.Semigroup.Arg b1_sfOXa [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.<= $dOrd_sfOX3 a1_sfOX7 b1_sfOXa of {
                      GHC.Types.False -> wild1_sfOX9;
                      GHC.Types.True -> wild_sfOX6;
                    };
              };
        };

Data.Semigroup.$fOrdArg_$cmax
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b
     -> Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOXd x_sfOXe y_sfOXf]
        case x_sfOXe of wild_sfOXg {
          Data.Semigroup.Arg a1_sfOXh [Occ=Once] _ [Occ=Dead] ->
              case y_sfOXf of wild1_sfOXj {
                Data.Semigroup.Arg b1_sfOXk [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.>= $dOrd_sfOXd a1_sfOXh b1_sfOXk of {
                      GHC.Types.False -> wild1_sfOXj;
                      GHC.Types.True -> wild_sfOXg;
                    };
              };
        };

Data.Semigroup.$fOrdArg_$ccompare
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b
     -> Data.Semigroup.Arg a b -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOXn ds_sfOXo ds1_sfOXp]
        case ds_sfOXo of {
          Data.Semigroup.Arg a1_sfOXr [Occ=Once] _ [Occ=Dead] ->
              case ds1_sfOXp of {
                Data.Semigroup.Arg b1_sfOXu [Occ=Once] _ [Occ=Dead] ->
                    GHC.Classes.compare $dOrd_sfOXn a1_sfOXr b1_sfOXu;
              };
        };

Data.Semigroup.$fOrdArg_$cp1Ord
  :: forall a b.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Arg a b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOXw]
        let {
          sat_sfOXx [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_afyV3
          [LclId] =
              [$dOrd_sfOXw] \u [] GHC.Classes.$p1Ord $dOrd_sfOXw;
        } in  Data.Semigroup.$fEqArg sat_sfOXx;

Data.Semigroup.$fOrdArg_$c<
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOXy x_sfOXz y_sfOXA]
        case x_sfOXz of {
          Data.Semigroup.Arg a1_sfOXC [Occ=Once] _ [Occ=Dead] ->
              case y_sfOXA of {
                Data.Semigroup.Arg b1_sfOXF [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfOXy a1_sfOXC b1_sfOXF of {
                      __DEFAULT -> GHC.Types.False [];
                      GHC.Types.LT -> GHC.Types.True [];
                    };
              };
        };

Data.Semigroup.$fOrdArg_$c>
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOXI x_sfOXJ y_sfOXK]
        case x_sfOXJ of {
          Data.Semigroup.Arg a1_sfOXM [Occ=Once] _ [Occ=Dead] ->
              case y_sfOXK of {
                Data.Semigroup.Arg b1_sfOXP [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfOXI a1_sfOXM b1_sfOXP of {
                      __DEFAULT -> GHC.Types.False [];
                      GHC.Types.GT -> GHC.Types.True [];
                    };
              };
        };

Data.Semigroup.$fOrdArg_$c<=
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOXS x_sfOXT y_sfOXU]
        case x_sfOXT of {
          Data.Semigroup.Arg a1_sfOXW [Occ=Once] _ [Occ=Dead] ->
              case y_sfOXU of {
                Data.Semigroup.Arg b1_sfOXZ [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfOXS a1_sfOXW b1_sfOXZ of {
                      __DEFAULT -> GHC.Types.True [];
                      GHC.Types.GT -> GHC.Types.False [];
                    };
              };
        };

Data.Semigroup.$fOrdArg_$c>=
  :: forall a b.
     GHC.Classes.Ord a =>
     Data.Semigroup.Arg a b -> Data.Semigroup.Arg a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOY2 x_sfOY3 y_sfOY4]
        case x_sfOY3 of {
          Data.Semigroup.Arg a1_sfOY6 [Occ=Once] _ [Occ=Dead] ->
              case y_sfOY4 of {
                Data.Semigroup.Arg b1_sfOY9 [Occ=Once] _ [Occ=Dead] ->
                    case GHC.Classes.compare $dOrd_sfOY2 a1_sfOY6 b1_sfOY9 of {
                      __DEFAULT -> GHC.Types.True [];
                      GHC.Types.LT -> GHC.Types.False [];
                    };
              };
        };

Data.Semigroup.$fOrdArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,C(C1(U)),A,C(C1(U)),A,A)>m] =
    [] \r [$dOrd_sfOYc]
        let {
          sat_sfOYk [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$cmin $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYj [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$cmax $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYi [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c>= $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYh [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c> $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYg [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c<= $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYf [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$c< $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYe [Occ=Once]
            :: Data.Semigroup.Arg a_afyV3 b_afyV4
               -> Data.Semigroup.Arg a_afyV3 b_afyV4 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfOYc] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fOrdArg_$ccompare $dOrd_sfOYc eta_B2 eta_B1; } in
        let {
          sat_sfOYd [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Arg a_afyV3 b_afyV4)
          [LclId] =
              [$dOrd_sfOYc] \u [] Data.Semigroup.$fOrdArg_$cp1Ord $dOrd_sfOYc;
        } in 
          GHC.Classes.C:Ord [sat_sfOYd
                             sat_sfOYe
                             sat_sfOYf
                             sat_sfOYg
                             sat_sfOYh
                             sat_sfOYi
                             sat_sfOYj
                             sat_sfOYk];

Data.Semigroup.$fBifunctorArg_$cbimap
  :: forall a b c d.
     (a -> b)
     -> (c -> d) -> Data.Semigroup.Arg a c -> Data.Semigroup.Arg b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sfOYl g_sfOYm ds_sfOYn]
        case ds_sfOYn of {
          Data.Semigroup.Arg a1_sfOYp [Occ=Once] b1_sfOYq [Occ=Once] ->
              let {
                sat_sfOYs [Occ=Once] :: d_afyUz
                [LclId] =
                    [g_sfOYm b1_sfOYq] \u [] g_sfOYm b1_sfOYq; } in
              let {
                sat_sfOYr [Occ=Once] :: b_afyUx
                [LclId] =
                    [f_sfOYl a1_sfOYp] \u [] f_sfOYl a1_sfOYp;
              } in  Data.Semigroup.Arg [sat_sfOYr sat_sfOYs];
        };

Data.Semigroup.$fBifunctorArg_$cfirst
  :: forall a b c.
     (a -> b) -> Data.Semigroup.Arg a c -> Data.Semigroup.Arg b c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sfOYt ds_sfOYu]
        case ds_sfOYu of {
          Data.Semigroup.Arg a1_sfOYw [Occ=Once] b1_sfOYx [Occ=Once] ->
              let {
                sat_sfOYy [Occ=Once] :: b_afyUH
                [LclId] =
                    [f_sfOYt a1_sfOYw] \u [] f_sfOYt a1_sfOYw;
              } in  Data.Semigroup.Arg [sat_sfOYy b1_sfOYx];
        };

Data.Semigroup.$fBifunctorArg_$csecond
  :: forall b c a.
     (b -> c) -> Data.Semigroup.Arg a b -> Data.Semigroup.Arg a c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [g_sfOYz ds_sfOYA]
        case ds_sfOYA of {
          Data.Semigroup.Arg a1_sfOYC [Occ=Once] b1_sfOYD [Occ=Once] ->
              let {
                sat_sfOYE [Occ=Once] :: c_afyUT
                [LclId] =
                    [g_sfOYz b1_sfOYD] \u [] g_sfOYz b1_sfOYD;
              } in  Data.Semigroup.Arg [a1_sfOYC sat_sfOYE];
        };

Data.Semigroup.$fBifunctorArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifunctor.Bifunctor Data.Semigroup.Arg
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifunctor.C:Bifunctor! [Data.Semigroup.$fBifunctorArg_$cbimap
                                               Data.Semigroup.$fBifunctorArg_$cfirst
                                               Data.Semigroup.$fBifunctorArg_$csecond];

Data.Semigroup.$fBifoldableArg_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> Data.Semigroup.Arg a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOYF eta_sfOYG eta1_sfOYH eta2_sfOYI]
        case eta2_sfOYI of {
          Data.Semigroup.Arg a1_sfOYK [Occ=Once] b1_sfOYL [Occ=Once] ->
              let {
                sat_sfOYO [Occ=Once] :: m_afyTV
                [LclId] =
                    [eta1_sfOYH b1_sfOYL] \u [] eta1_sfOYH b1_sfOYL; } in
              let {
                sat_sfOYN [Occ=Once] :: m_afyTV
                [LclId] =
                    [eta_sfOYG a1_sfOYK] \u [] eta_sfOYG a1_sfOYK;
              } in 
                case GHC.Base.$p1Monoid $dMonoid_sfOYF of sat_sfOYM {
                  __DEFAULT -> GHC.Base.<> sat_sfOYM sat_sfOYN sat_sfOYO;
                };
        };

Data.Semigroup.$fBifoldableArg_$cbifold
  :: forall m. GHC.Base.Monoid m => Data.Semigroup.Arg m m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOYP eta_sfOYQ]
        case eta_sfOYQ of {
          Data.Semigroup.Arg a_sfOYS [Occ=Once] b_sfOYT [Occ=Once] ->
              case GHC.Base.$p1Monoid $dMonoid_sfOYP of sat_sfOYU {
                __DEFAULT -> GHC.Base.<> sat_sfOYU a_sfOYS b_sfOYT;
              };
        };

Data.Semigroup.$fBifoldableArg_$cbifoldr
  :: forall a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> Data.Semigroup.Arg a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfOYV g_sfOYW z_sfOYX t_sfOYY]
        case t_sfOYY of {
          Data.Semigroup.Arg a1_sfOZ0 [Occ=Once] b1_sfOZ1 [Occ=Once] ->
              let {
                sat_sfOZ2 [Occ=Once] :: c_afyU7
                [LclId] =
                    [g_sfOYW z_sfOYX b1_sfOZ1] \u [] g_sfOYW b1_sfOZ1 z_sfOYX;
              } in  f_sfOYV a1_sfOZ0 sat_sfOZ2;
        };

Data.Semigroup.$fBifoldableArg_$cbifoldl
  :: forall c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> Data.Semigroup.Arg a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sfOZ3 g_sfOZ4 z_sfOZ5 t_sfOZ6]
        case t_sfOZ6 of {
          Data.Semigroup.Arg a1_sfOZ8 [Occ=Once] b1_sfOZ9 [Occ=Once] ->
              let {
                sat_sfOZa [Occ=Once] :: c_afyUi
                [LclId] =
                    [f_sfOZ3 z_sfOZ5 a1_sfOZ8] \u [] f_sfOZ3 z_sfOZ5 a1_sfOZ8;
              } in  g_sfOZ4 sat_sfOZa b1_sfOZ9;
        };

Data.Semigroup.$fBifoldableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable Data.Semigroup.Arg
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Semigroup.$fBifoldableArg_$cbifold
                                                 Data.Semigroup.$fBifoldableArg_$cbifoldMap
                                                 Data.Semigroup.$fBifoldableArg_$cbifoldr
                                                 Data.Semigroup.$fBifoldableArg_$cbifoldl];

Data.Semigroup.$w$cbitraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c) -> (b -> f d) -> a -> b -> f (Data.Semigroup.Arg c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfOZb w1_sfOZc w2_sfOZd ww_sfOZe ww1_sfOZf]
        let {
          sat_sfOZj [Occ=Once] :: f_sfBpj d_sfBpn
          [LclId] =
              [w2_sfOZd ww1_sfOZf] \u [] w2_sfOZd ww1_sfOZf; } in
        let {
          sat_sfOZi [Occ=Once]
            :: f_sfBpj (d_sfBpn -> Data.Semigroup.Arg c_sfBpl d_sfBpn)
          [LclId] =
              [w_sfOZb w1_sfOZc ww_sfOZe] \u []
                  let {
                    sat_sfOZh [Occ=Once] :: f_sfBpj c_sfBpl
                    [LclId] =
                        [w1_sfOZc ww_sfOZe] \u [] w1_sfOZc ww_sfOZe;
                  } in 
                    case GHC.Base.$p1Applicative w_sfOZb of sat_sfOZg {
                      __DEFAULT -> GHC.Base.fmap sat_sfOZg Data.Semigroup.Arg sat_sfOZh;
                    };
        } in  GHC.Base.<*> w_sfOZb sat_sfOZi sat_sfOZj;

Data.Semigroup.$fBitraversableArg_$cbitraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a c b d.
     GHC.Base.Applicative f =>
     (a -> f c)
     -> (b -> f d)
     -> Data.Semigroup.Arg a b
     -> f (Data.Semigroup.Arg c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sfOZk w1_sfOZl w2_sfOZm w3_sfOZn]
        case w3_sfOZn of {
          Data.Semigroup.Arg ww1_sfOZp [Occ=Once] ww2_sfOZq [Occ=Once] ->
              Data.Semigroup.$w$cbitraverse
                  w_sfOZk w1_sfOZl w2_sfOZm ww1_sfOZp ww2_sfOZq;
        };

Data.Semigroup.$fBitraversableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bitraversable.Bitraversable Data.Semigroup.Arg
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bitraversable.C:Bitraversable! [Data.Semigroup.$fBifunctorArg
                                                       Data.Semigroup.$fBifoldableArg
                                                       Data.Semigroup.$fBitraversableArg_$cbitraverse];

Data.Semigroup.$fSemigroupFirst_$cstimes
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfOZr eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfOZr eta_B2 eta_B1;

Data.Semigroup.$fSemigroupFirst_$c<>
  :: forall a.
     Data.Semigroup.First a
     -> Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfOZs ds_sfOZt] a1_sfOZs;

Data.Semigroup.$fSemigroupFirst_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Semigroup.First a)
     -> Data.Semigroup.First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfOZu]
        case ds_sfOZu of {
          GHC.Base.:| a1_sfOZw [Occ=Once] as_sfOZx [Occ=Once] ->
              case as_sfOZx of { __DEFAULT -> a1_sfOZw; };
        };

Data.Semigroup.$fSemigroupFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Semigroup.First a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Semigroup.$fSemigroupFirst_$c<>
                                         Data.Semigroup.$fSemigroupFirst_$csconcat
                                         Data.Semigroup.$fSemigroupFirst_$cstimes];

Data.Semigroup.$fFunctorFirst2
  :: forall a b. (a -> b) -> Data.Semigroup.First a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOZz ds_sfOZA] f_sfOZz ds_sfOZA;

Data.Semigroup.$fFunctorFirst1
  :: forall b a. a -> Data.Semigroup.First b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sfOZB ds_sfOZC] x_sfOZB;

Data.Semigroup.$fFunctorFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorFirst2
                                       Data.Semigroup.$fFunctorFirst1];

Data.Semigroup.$fFoldableFirst_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.First a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOZD f_sfOZE ds_sfOZF] f_sfOZE ds_sfOZF;

Data.Semigroup.$fFoldableFirst5
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.First m -> Data.Semigroup.First m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfOZG ds_sfOZH] ds_sfOZH;

Data.Semigroup.$fFoldableFirst1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfOZI eta_sfOZJ] eta_sfOZJ;

Data.Semigroup.$fFoldableFirst2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfOZK x_sfOZL] x_sfOZL;

Data.Semigroup.$fFoldableFirst_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.First a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfOZM eta_sfOZN]
        let {
          f_sfOZO [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afyQr -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfOZM eta_sfOZN] \u []
                  GHC.Classes.== $dEq_sfOZM eta_sfOZN; } in
        let {
          sat_sfOZQ [Occ=OnceT[0]]
            :: Data.Semigroup.First a_afyQr -> GHC.Types.Bool
          [LclId] =
              [f_sfOZO] \r [ds_sfOZP] f_sfOZO ds_sfOZP;
        } in  sat_sfOZQ;

Data.Semigroup.$fFoldableFirst_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOZR z_sfOZS t1_sfOZT] f_sfOZR z_sfOZS t1_sfOZT;

Data.Semigroup.$fFoldableFirst4
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.First a -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfOZU xs_sfOZV] xs_sfOZV;

Data.Semigroup.$fFoldableFirst_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfOZW z0_sfOZX xs_sfOZY] f_sfOZW xs_sfOZY z0_sfOZX;

Data.Semigroup.$fFoldableFirst_$clength
  :: forall a. Data.Semigroup.First a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfOZZ] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableFirst_$cnull
  :: forall a. Data.Semigroup.First a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfP00] GHC.Types.False [];

Data.Semigroup.$fFoldableFirst_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.First a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfP01] : [eta_sfP01 GHC.Types.[]];

Data.Semigroup.$fFoldableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.First
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableFirst5
                                             Data.Semigroup.$fFoldableFirst_$cfoldMap
                                             Data.Semigroup.$fFoldableFirst_$cfoldr'
                                             Data.Semigroup.$fFoldableFirst_$cfoldr'
                                             Data.Semigroup.$fFoldableFirst_$cfoldl
                                             Data.Semigroup.$fFoldableFirst_$cfoldl
                                             Data.Semigroup.$fFoldableFirst4
                                             Data.Semigroup.$fFoldableFirst4
                                             Data.Semigroup.$fFoldableFirst_$ctoList
                                             Data.Semigroup.$fFoldableFirst_$cnull
                                             Data.Semigroup.$fFoldableFirst_$clength
                                             Data.Semigroup.$fFoldableFirst_$celem
                                             Data.Semigroup.$fFoldableFirst2
                                             Data.Semigroup.$fFoldableFirst2
                                             Data.Semigroup.$fFoldableFirst1
                                             Data.Semigroup.$fFoldableFirst1];

Data.Semigroup.$fTraversableFirst_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.First a -> f (Data.Semigroup.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfP02 eta_sfP03 eta1_sfP04]
        let {
          sat_sfP06 [Occ=Once] :: f_afyNZ b_afyO1
          [LclId] =
              [eta_sfP03 eta1_sfP04] \u [] eta_sfP03 eta1_sfP04;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfP02 of sat_sfP05 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfP05 Data.Semigroup.$fApplicativeFirst3 sat_sfP06;
          };

Data.Semigroup.$fTraversableFirst_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.First (f a) -> f (Data.Semigroup.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfP07 eta_sfP08]
        case GHC.Base.$p1Applicative $dApplicative_sfP07 of sat_sfP09 {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfP09 Data.Semigroup.$fApplicativeFirst3 eta_sfP08;
        };

Data.Semigroup.$fTraversableFirst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.First a -> m (Data.Semigroup.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfP0a eta_sfP0b eta1_sfP0c]
        let {
          sat_sfP0f [Occ=Once] :: m_afyOp b_afyOr
          [LclId] =
              [eta_sfP0b eta1_sfP0c] \u [] eta_sfP0b eta1_sfP0c;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfP0a of sat_sfP0d {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfP0d of sat_sfP0e {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfP0e Data.Semigroup.$fApplicativeFirst3 sat_sfP0f;
                };
          };

Data.Semigroup.$fTraversableFirst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.First (m a) -> m (Data.Semigroup.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfP0g eta_sfP0h]
        case GHC.Base.$p1Monad $dMonad_sfP0g of sat_sfP0i {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfP0i of sat_sfP0j {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfP0j Data.Semigroup.$fApplicativeFirst3 eta_sfP0h;
              };
        };

Data.Semigroup.$fTraversableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorFirst
                                                   Data.Semigroup.$fFoldableFirst
                                                   Data.Semigroup.$fTraversableFirst_$ctraverse
                                                   Data.Semigroup.$fTraversableFirst_$csequenceA
                                                   Data.Semigroup.$fTraversableFirst_$cmapM
                                                   Data.Semigroup.$fTraversableFirst_$csequence];

Data.Semigroup.$fApplicativeFirst_$c<*
  :: forall a b.
     Data.Semigroup.First a
     -> Data.Semigroup.First b -> Data.Semigroup.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfP0k ds_sfP0l] a1_sfP0k;

Data.Semigroup.$fApplicativeFirst_$c*>
  :: forall a b.
     Data.Semigroup.First a
     -> Data.Semigroup.First b -> Data.Semigroup.First b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfP0m a1_sfP0n] a1_sfP0n;

Data.Semigroup.$fApplicativeFirst2
  :: forall a b.
     Data.Semigroup.First (a -> b) -> Data.Semigroup.First (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfP0o] v_sfP0o;

Data.Semigroup.$fApplicativeFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorFirst
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeFirst2
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeFirst_$c*>
                                           Data.Semigroup.$fApplicativeFirst_$c<*];

Data.Semigroup.$fMonadFirst_$c>>=
  :: forall a b.
     Data.Semigroup.First a
     -> (a -> Data.Semigroup.First b) -> Data.Semigroup.First b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfP0p f_sfP0q] f_sfP0q ds_sfP0p;

lvl4_rfC6a :: forall a. [GHC.Types.Char] -> Data.Semigroup.First a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfP0r] GHC.Err.errorWithoutStackTrace eta_sfP0r;

Data.Semigroup.$fMonadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeFirst
                                     Data.Semigroup.$fMonadFirst_$c>>=
                                     Data.Semigroup.$fApplicativeFirst_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl4_rfC6a];

Data.Semigroup.$fSemigroupLast_$cstimes
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfP0s eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfP0s eta_B2 eta_B1;

Data.Semigroup.$fSemigroupLast_$c<>
  :: forall a.
     Data.Semigroup.Last a
     -> Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfP0t b_sfP0u] b_sfP0u;

Data.Semigroup.$fSemigroupLast1 [Occ=LoopBreaker]
  :: forall a.
     Data.Semigroup.Last a
     -> [Data.Semigroup.Last a] -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sfP0v ds1_sfP0w]
        case ds1_sfP0w of {
          [] -> b_sfP0v;
          : c_sfP0y [Occ=Once] cs_sfP0z [Occ=Once] ->
              Data.Semigroup.$fSemigroupLast1 c_sfP0y cs_sfP0z;
        };

Data.Semigroup.$fSemigroupLast_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Semigroup.Last a) -> Data.Semigroup.Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfP0A]
        case ds_sfP0A of {
          GHC.Base.:| a1_sfP0C [Occ=Once] as_sfP0D [Occ=Once] ->
              Data.Semigroup.$fSemigroupLast1 a1_sfP0C as_sfP0D;
        };

Data.Semigroup.$fSemigroupLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Semigroup.Last a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Semigroup.$fSemigroupLast_$c<>
                                         Data.Semigroup.$fSemigroupLast_$csconcat
                                         Data.Semigroup.$fSemigroupLast_$cstimes];

Data.Semigroup.$fFunctorLast1
  :: forall a b. a -> Data.Semigroup.Last b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfP0E ds_sfP0F] a1_sfP0E;

Data.Semigroup.$fFunctorLast2
  :: forall a b. (a -> b) -> Data.Semigroup.Last a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfP0G ds_sfP0H] f_sfP0G ds_sfP0H;

Data.Semigroup.$fFunctorLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.$fFunctorLast2
                                       Data.Semigroup.$fFunctorLast1];

Data.Semigroup.$fFoldableLast_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Last a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfP0I f_sfP0J ds_sfP0K] f_sfP0J ds_sfP0K;

Data.Semigroup.$fFoldableLast4
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.Last m -> Data.Semigroup.Last m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfP0L ds_sfP0M] ds_sfP0M;

Data.Semigroup.$fFoldableLast1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfP0N eta_sfP0O] eta_sfP0O;

Data.Semigroup.$fFoldableLast2
  :: forall a.
     GHC.Classes.Ord a =>
     Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfP0P x_sfP0Q] x_sfP0Q;

Data.Semigroup.$fFoldableLast_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Last a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfP0R eta_sfP0S]
        let {
          f_sfP0T [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afyJq -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP0R eta_sfP0S] \u []
                  GHC.Classes.== $dEq_sfP0R eta_sfP0S; } in
        let {
          sat_sfP0V [Occ=OnceT[0]]
            :: Data.Semigroup.Last a_afyJq -> GHC.Types.Bool
          [LclId] =
              [f_sfP0T] \r [ds_sfP0U] f_sfP0T ds_sfP0U;
        } in  sat_sfP0V;

Data.Semigroup.$fFoldableLast_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfP0W z_sfP0X t1_sfP0Y] f_sfP0W z_sfP0X t1_sfP0Y;

Data.Semigroup.$fFoldableLast3
  :: forall a.
     (a -> a -> a) -> Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfP0Z xs_sfP10] xs_sfP10;

Data.Semigroup.$fFoldableLast_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sfP11 z0_sfP12 xs_sfP13] f_sfP11 xs_sfP13 z0_sfP12;

Data.Semigroup.$fFoldableLast_$clength
  :: forall a. Data.Semigroup.Last a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [xs_sfP14] Data.Semigroup.$fFoldableFirst3;

Data.Semigroup.$fFoldableLast_$cnull
  :: forall a. Data.Semigroup.Last a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [t1_sfP15] GHC.Types.False [];

Data.Semigroup.$fFoldableLast_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Last a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [eta_sfP16] : [eta_sfP16 GHC.Types.[]];

Data.Semigroup.$fFoldableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableLast4
                                             Data.Semigroup.$fFoldableLast_$cfoldMap
                                             Data.Semigroup.$fFoldableLast_$cfoldr'
                                             Data.Semigroup.$fFoldableLast_$cfoldr'
                                             Data.Semigroup.$fFoldableLast_$cfoldl
                                             Data.Semigroup.$fFoldableLast_$cfoldl
                                             Data.Semigroup.$fFoldableLast3
                                             Data.Semigroup.$fFoldableLast3
                                             Data.Semigroup.$fFoldableLast_$ctoList
                                             Data.Semigroup.$fFoldableLast_$cnull
                                             Data.Semigroup.$fFoldableLast_$clength
                                             Data.Semigroup.$fFoldableLast_$celem
                                             Data.Semigroup.$fFoldableLast2
                                             Data.Semigroup.$fFoldableLast2
                                             Data.Semigroup.$fFoldableLast1
                                             Data.Semigroup.$fFoldableLast1];

Data.Semigroup.$fTraversableLast_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Semigroup.Last a -> f (Data.Semigroup.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfP17 eta_sfP18 eta1_sfP19]
        let {
          sat_sfP1b [Occ=Once] :: f_afyGY b_afyH0
          [LclId] =
              [eta_sfP18 eta1_sfP19] \u [] eta_sfP18 eta1_sfP19;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sfP17 of sat_sfP1a {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sfP1a Data.Semigroup.$fApplicativeFirst3 sat_sfP1b;
          };

Data.Semigroup.$fTraversableLast_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Last (f a) -> f (Data.Semigroup.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfP1c eta_sfP1d]
        case GHC.Base.$p1Applicative $dApplicative_sfP1c of sat_sfP1e {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sfP1e Data.Semigroup.$fApplicativeFirst3 eta_sfP1d;
        };

Data.Semigroup.$fTraversableLast_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Semigroup.Last a -> m (Data.Semigroup.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfP1f eta_sfP1g eta1_sfP1h]
        let {
          sat_sfP1k [Occ=Once] :: m_afyHo b_afyHq
          [LclId] =
              [eta_sfP1g eta1_sfP1h] \u [] eta_sfP1g eta1_sfP1h;
        } in 
          case GHC.Base.$p1Monad $dMonad_sfP1f of sat_sfP1i {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sfP1i of sat_sfP1j {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sfP1j Data.Semigroup.$fApplicativeFirst3 sat_sfP1k;
                };
          };

Data.Semigroup.$fTraversableLast_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Last (m a) -> m (Data.Semigroup.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfP1l eta_sfP1m]
        case GHC.Base.$p1Monad $dMonad_sfP1l of sat_sfP1n {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sfP1n of sat_sfP1o {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sfP1o Data.Semigroup.$fApplicativeFirst3 eta_sfP1m;
              };
        };

Data.Semigroup.$fTraversableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorLast
                                                   Data.Semigroup.$fFoldableLast
                                                   Data.Semigroup.$fTraversableLast_$ctraverse
                                                   Data.Semigroup.$fTraversableLast_$csequenceA
                                                   Data.Semigroup.$fTraversableLast_$cmapM
                                                   Data.Semigroup.$fTraversableLast_$csequence];

Data.Semigroup.$fApplicativeLast_$c<*
  :: forall a b.
     Data.Semigroup.Last a
     -> Data.Semigroup.Last b -> Data.Semigroup.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a1_sfP1p ds_sfP1q] a1_sfP1p;

Data.Semigroup.$fApplicativeLast_$c*>
  :: forall a b.
     Data.Semigroup.Last a
     -> Data.Semigroup.Last b -> Data.Semigroup.Last b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfP1r a1_sfP1s] a1_sfP1s;

Data.Semigroup.$fApplicativeLast1
  :: forall a b.
     Data.Semigroup.Last (a -> b) -> Data.Semigroup.Last (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfP1t] v_sfP1t;

Data.Semigroup.$fApplicativeLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorLast
                                           Data.Semigroup.$fApplicativeFirst3
                                           Data.Semigroup.$fApplicativeLast1
                                           Data.Semigroup.$fApplicativeFirst1
                                           Data.Semigroup.$fApplicativeLast_$c*>
                                           Data.Semigroup.$fApplicativeLast_$c<*];

Data.Semigroup.$fMonadLast_$c>>=
  :: forall a b.
     Data.Semigroup.Last a
     -> (a -> Data.Semigroup.Last b) -> Data.Semigroup.Last b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfP1u f_sfP1v] f_sfP1v ds_sfP1u;

lvl5_rfC6b :: forall a. [GHC.Types.Char] -> Data.Semigroup.Last a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfP1w] GHC.Err.errorWithoutStackTrace eta_sfP1w;

Data.Semigroup.$fMonadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeLast
                                     Data.Semigroup.$fMonadLast_$c>>=
                                     Data.Semigroup.$fApplicativeLast_$c*>
                                     Data.Semigroup.$fApplicativeFirst3
                                     lvl5_rfC6b];

Data.Semigroup.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Semigroup.WrappedMonoid m
     -> [Data.Semigroup.WrappedMonoid m]
     -> Data.Semigroup.WrappedMonoid m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfP1x ww_sfP1y ww1_sfP1z]
        let {
          go_sfP1A [Occ=LoopBreaker]
            :: Data.Semigroup.WrappedMonoid m_sfBpD
               -> [Data.Semigroup.WrappedMonoid m_sfBpD]
               -> Data.Semigroup.WrappedMonoid m_sfBpD
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfP1x go_sfP1A] \r [b_sfP1B ds1_sfP1C]
                  case ds1_sfP1C of {
                    [] -> b_sfP1B;
                    : c_sfP1E [Occ=Once] cs_sfP1F [Occ=Once] ->
                        let {
                          sat_sfP1G [Occ=Once] :: m_sfBpD
                          [LclId] =
                              [go_sfP1A c_sfP1E cs_sfP1F] \u [] go_sfP1A c_sfP1E cs_sfP1F;
                        } in  GHC.Base.mappend w_sfP1x b_sfP1B sat_sfP1G;
                  };
        } in  go_sfP1A ww_sfP1y ww1_sfP1z;

Data.Semigroup.$fSemigroupWrappedMonoid_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Base.NonEmpty (Data.Semigroup.WrappedMonoid m)
     -> Data.Semigroup.WrappedMonoid m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfP1H w1_sfP1I]
        case w1_sfP1I of {
          GHC.Base.:| ww1_sfP1K [Occ=Once] ww2_sfP1L [Occ=Once] ->
              Data.Semigroup.$w$csconcat3 w_sfP1H ww1_sfP1K ww2_sfP1L;
        };

Data.Semigroup.$fSemigroupWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,U,A)>m] =
    [] \r [$dMonoid_sfP1M]
        let {
          sat_sfP1P [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.WrappedMonoid m_afyEA
               -> Data.Semigroup.WrappedMonoid m_afyEA
          [LclId] =
              [$dMonoid_sfP1M] \r [eta_B1]
                  Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes
                      $dMonoid_sfP1M eta_B1; } in
        let {
          sat_sfP1O [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.WrappedMonoid m_afyEA)
               -> Data.Semigroup.WrappedMonoid m_afyEA
          [LclId] =
              [$dMonoid_sfP1M] \r [eta_B1]
                  Data.Semigroup.$fSemigroupWrappedMonoid_$csconcat
                      $dMonoid_sfP1M eta_B1; } in
        let {
          sat_sfP1N [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyEA
               -> Data.Semigroup.WrappedMonoid m_afyEA
               -> Data.Semigroup.WrappedMonoid m_afyEA
          [LclId] =
              [$dMonoid_sfP1M] \u [] GHC.Base.mappend $dMonoid_sfP1M;
        } in  GHC.Base.C:Semigroup [sat_sfP1N sat_sfP1O sat_sfP1P];
Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes [Occ=LoopBreaker]
  :: forall m.
     GHC.Base.Monoid m =>
     forall b.
     GHC.Real.Integral b =>
     b
     -> Data.Semigroup.WrappedMonoid m -> Data.Semigroup.WrappedMonoid m
[GblId, Arity=2, Str=<L,U(A,A,U,A)><L,U>, Unf=OtherCon []] =
    [] \r [$dMonoid_sfP1Q $dIntegral_sfP1R]
        let {
          sat_sfP1S [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m_afyEA)
          [LclId] =
              [$dMonoid_sfP1Q] \u []
                  Data.Semigroup.$fSemigroupWrappedMonoid $dMonoid_sfP1Q;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_sfP1R sat_sfP1S;

Data.Semigroup.$fMonoidWrappedMonoid_$cmconcat
  :: forall m.
     GHC.Base.Monoid m =>
     [Data.Semigroup.WrappedMonoid m] -> Data.Semigroup.WrappedMonoid m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfP1T eta_sfP1U]
        let {
          z_sfP1V [Occ=OnceL] :: m_afyEb
          [LclId] =
              [$dMonoid_sfP1T] \u [] GHC.Base.mempty $dMonoid_sfP1T; } in
        let {
          go_sfP1W [Occ=LoopBreaker]
            :: [Data.Semigroup.WrappedMonoid m_afyEb]
               -> Data.Semigroup.WrappedMonoid m_afyEb
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_sfP1T z_sfP1V go_sfP1W] \r [ds_sfP1X]
                  case ds_sfP1X of {
                    [] -> z_sfP1V;
                    : y_sfP1Z [Occ=Once] ys_sfP20 [Occ=Once] ->
                        let {
                          sat_sfP21 [Occ=Once] :: m_afyEb
                          [LclId] =
                              [go_sfP1W ys_sfP20] \u [] go_sfP1W ys_sfP20;
                        } in  GHC.Base.mappend $dMonoid_sfP1T y_sfP1Z sat_sfP21;
                  };
        } in  go_sfP1W eta_sfP1U;

Data.Semigroup.$fMonoidWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Base.Monoid m =>
     GHC.Base.Monoid (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(A,U,U,A)>m] =
    [] \r [$dMonoid_sfP22]
        let {
          sat_sfP26 [Occ=Once]
            :: [Data.Semigroup.WrappedMonoid m_afyEb]
               -> Data.Semigroup.WrappedMonoid m_afyEb
          [LclId] =
              [$dMonoid_sfP22] \r [eta_B1]
                  Data.Semigroup.$fMonoidWrappedMonoid_$cmconcat
                      $dMonoid_sfP22 eta_B1; } in
        let {
          sat_sfP25 [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyEb
               -> Data.Semigroup.WrappedMonoid m_afyEb
               -> Data.Semigroup.WrappedMonoid m_afyEb
          [LclId] =
              [$dMonoid_sfP22] \u [] GHC.Base.mappend $dMonoid_sfP22; } in
        let {
          sat_sfP24 [Occ=Once] :: Data.Semigroup.WrappedMonoid m_afyEb
          [LclId] =
              [$dMonoid_sfP22] \u [] GHC.Base.mempty $dMonoid_sfP22; } in
        let {
          sat_sfP23 [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m_afyEb)
          [LclId] =
              [$dMonoid_sfP22] \u []
                  Data.Semigroup.$fSemigroupWrappedMonoid $dMonoid_sfP22;
        } in  GHC.Base.C:Monoid [sat_sfP23 sat_sfP24 sat_sfP25 sat_sfP26];

Data.Semigroup.$fFunctorOption1
  :: forall a b. a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sfP27 ds1_sfP28]
        case ds1_sfP28 of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Base.Just [x_sfP27];
        };

Data.Semigroup.$fFunctorOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       Data.Semigroup.$fFunctorOption1];

Data.Semigroup.$fApplicativeOption_$c*>
  :: forall a b.
     Data.Semigroup.Option a
     -> Data.Semigroup.Option b -> Data.Semigroup.Option b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfP2b ds1_sfP2c]
        case ds_sfP2b of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> ds1_sfP2c;
        };

Data.Semigroup.$fApplicativeOption1
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfP2f ds1_sfP2g]
        case ds_sfP2f of wild_sfP2h {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] ->
              case ds1_sfP2g of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just _ [Occ=Dead] -> wild_sfP2h;
              };
        };

Data.Semigroup.$fApplicativeOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.$fFunctorOption
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           Data.Semigroup.$fApplicativeOption_$c*>
                                           Data.Semigroup.$fApplicativeOption1];

Data.Semigroup.$fMonadOption_$c>>=
  :: forall a b.
     Data.Semigroup.Option a
     -> (a -> Data.Semigroup.Option b) -> Data.Semigroup.Option b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfP2l k_sfP2m]
        case ds_sfP2l of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_sfP2o [Occ=Once] -> k_sfP2m a1_sfP2o;
        };

lvl6_rfC6c :: forall a. [GHC.Types.Char] -> Data.Semigroup.Option a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sfP2p] GHC.Err.errorWithoutStackTrace eta_sfP2p;

Data.Semigroup.$fMonadOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.$fApplicativeOption
                                     Data.Semigroup.$fMonadOption_$c>>=
                                     Data.Semigroup.$fApplicativeOption_$c*>
                                     GHC.Base.Just
                                     lvl6_rfC6c];

Data.Semigroup.$fAlternativeOption_$c<|>
  :: forall a.
     Data.Semigroup.Option a
     -> Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfP2q b_sfP2r]
        case ds_sfP2q of wild_sfP2s {
          GHC.Base.Nothing -> b_sfP2r;
          GHC.Base.Just _ [Occ=Dead] -> wild_sfP2s;
        };

Data.Semigroup.$fAlternativeOption_$csome
  :: forall a. Data.Semigroup.Option a -> Data.Semigroup.Option [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sfP2u]
        let {
          some_v_sfP2v [Occ=LoopBreaker] :: GHC.Base.Maybe [a_afyAE]
          [LclId] =
              [v_sfP2u some_v_sfP2v] \u []
                  case v_sfP2u of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sfP2x [Occ=Once*] ->
                        case some_v_sfP2v of {
                          GHC.Base.Nothing ->
                              let {
                                sat_sfP2z [Occ=Once] :: [a_afyAE]
                                [LclId] =
                                    CCCS :! [x_sfP2x GHC.Types.[]];
                              } in  GHC.Base.Just [sat_sfP2z];
                          GHC.Base.Just ipv_sfP2A [Occ=Once] ->
                              let {
                                sat_sfP2B [Occ=Once] :: [a_afyAE]
                                [LclId] =
                                    CCCS :! [x_sfP2x ipv_sfP2A];
                              } in  GHC.Base.Just [sat_sfP2B];
                        };
                  };
        } in  some_v_sfP2v;

Data.Semigroup.$fAlternativeOption1 :: forall a. GHC.Base.Maybe [a]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [GHC.Types.[]];

Data.Semigroup.$fAlternativeOption_$cmany
  :: forall a. Data.Semigroup.Option a -> Data.Semigroup.Option [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sfP2C]
        let {
          many_v_sfP2D [Occ=LoopBreaker] :: Data.Semigroup.Option [a_afyAM]
          [LclId] =
              [v_sfP2C many_v_sfP2D] \u []
                  case v_sfP2C of {
                    GHC.Base.Nothing -> Data.Semigroup.$fAlternativeOption1;
                    GHC.Base.Just x_sfP2F [Occ=Once] ->
                        case many_v_sfP2D of {
                          GHC.Base.Nothing -> Data.Semigroup.$fAlternativeOption1;
                          GHC.Base.Just y_sfP2H [Occ=Once] ->
                              let {
                                sat_sfP2I [Occ=Once] :: [a_afyAM]
                                [LclId] =
                                    CCCS :! [x_sfP2F y_sfP2H];
                              } in  GHC.Base.Just [sat_sfP2I];
                        };
                  };
        } in  many_v_sfP2D;

Data.Semigroup.$fAlternativeOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [Data.Semigroup.$fApplicativeOption
                                           GHC.Base.Nothing
                                           Data.Semigroup.$fAlternativeOption_$c<|>
                                           Data.Semigroup.$fAlternativeOption_$csome
                                           Data.Semigroup.$fAlternativeOption_$cmany];

Data.Semigroup.$fMonadPlusOption [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [Data.Semigroup.$fAlternativeOption
                                         Data.Semigroup.$fMonadOption
                                         GHC.Base.Nothing
                                         Data.Semigroup.$fAlternativeOption_$c<|>];

Data.Semigroup.$fFoldableOption_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Semigroup.Option a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfP2J f_sfP2K ds_sfP2L]
        case ds_sfP2L of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_sfP2J;
          GHC.Base.Just m1_sfP2N [Occ=Once] -> f_sfP2K m1_sfP2N;
        };

Data.Semigroup.$fFoldableOption_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Semigroup.Option m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sfP2O ds_sfP2P]
        case ds_sfP2P of {
          GHC.Base.Nothing -> GHC.Base.mempty $dMonoid_sfP2O;
          GHC.Base.Just m1_sfP2R [Occ=Once] -> m1_sfP2R;
        };

Data.Semigroup.$fFoldableOption2
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Option a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfP2S ds_sfP2T]
        case ds_sfP2T of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidSum2 $dNum_sfP2S;
          GHC.Base.Just m_sfP2V [Occ=Once] -> m_sfP2V;
        };

lvl7_rfC6d :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum: empty structure"#;

Data.Semigroup.$fFoldableOption4 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl7_rfC6d of sat_sfP2W {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfP2W;
        };

Data.Semigroup.$fFoldableOption3
  :: forall a. Data.Semigroup.Option a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfP2X]
        case x_sfP2X of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption4;
          GHC.Base.Just v_sfP2Z [Occ=Once] -> v_sfP2Z;
        };

Data.Semigroup.$fFoldableOption_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sfP30 eta_B1] Data.Semigroup.$fFoldableOption3 eta_B1;

lvl8_rfC6e :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum: empty structure"#;

Data.Semigroup.$fFoldableOption6 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl8_rfC6e of sat_sfP31 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfP31;
        };

Data.Semigroup.$fFoldableOption5
  :: forall a. Data.Semigroup.Option a -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfP32]
        case x_sfP32 of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption6;
          GHC.Base.Just v_sfP34 [Occ=Once] -> v_sfP34;
        };

Data.Semigroup.$fFoldableOption_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [$dOrd_sfP35 eta_B1] Data.Semigroup.$fFoldableOption5 eta_B1;

Data.Semigroup.$fFoldableOption_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Semigroup.Option a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfP36 eta_sfP37]
        let {
          f_sfP38 [Occ=OnceL!, Dmd=<L,C(U)>] :: a_afyyC -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP36 eta_sfP37] \u []
                  GHC.Classes.== $dEq_sfP36 eta_sfP37; } in
        let {
          sat_sfP3c [Occ=Once]
            :: Data.Semigroup.Option a_afyyC -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_sfP38] \r [ds_sfP39]
                  case ds_sfP39 of {
                    GHC.Base.Nothing -> GHC.Types.False [];
                    GHC.Base.Just m_sfP3b [Occ=Once] -> f_sfP38 m_sfP3b;
                  };
        } in  sat_sfP3c;

Data.Semigroup.$fFoldableOption7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Semigroup.$fFoldableOption_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Semigroup.Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfP3d z_sfP3e t1_sfP3f]
        case t1_sfP3f of {
          GHC.Base.Nothing -> z_sfP3e;
          GHC.Base.Just m_sfP3h [Occ=Once] -> f_sfP3d z_sfP3e m_sfP3h;
        };

lvl9_rfC6f :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1: empty structure"#;

Data.Semigroup.$fFoldableOption8 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl9_rfC6f of sat_sfP3i {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfP3i;
        };

Data.Semigroup.$fFoldableOption_$cfoldl1
  :: forall a. (a -> a -> a) -> Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sfP3j xs_sfP3k]
        case xs_sfP3k of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption8;
          GHC.Base.Just m_sfP3m [Occ=Once] -> m_sfP3m;
        };

Data.Semigroup.$fFoldableOption_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Semigroup.Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sfP3n z0_sfP3o xs_sfP3p]
        case xs_sfP3p of {
          GHC.Base.Nothing -> z0_sfP3o;
          GHC.Base.Just m_sfP3r [Occ=Once] -> f_sfP3n m_sfP3r z0_sfP3o;
        };

Data.Semigroup.$fFoldableOption_$clength
  :: forall a. Data.Semigroup.Option a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [xs_sfP3s]
        case xs_sfP3s of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption7;
          GHC.Base.Just _ [Occ=Dead] -> Data.Semigroup.$fFoldableFirst3;
        };

lvl10_rfC6g :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1: empty structure"#;

Data.Semigroup.$fFoldableOption9 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl10_rfC6g of sat_sfP3v {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfP3v;
        };

Data.Semigroup.$fFoldableOption_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Semigroup.Option a -> a
[GblId, Arity=2, Str=<L,A><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sfP3w xs_sfP3x]
        case xs_sfP3x of {
          GHC.Base.Nothing -> Data.Semigroup.$fFoldableOption9;
          GHC.Base.Just m_sfP3z [Occ=Once] -> m_sfP3z;
        };

Data.Semigroup.$fFoldableOption_$cnull
  :: forall a. Data.Semigroup.Option a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [t1_sfP3A]
        case t1_sfP3A of {
          GHC.Base.Nothing -> GHC.Types.True [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Semigroup.$fFoldableOption1
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Option a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dNum_sfP3D ds_sfP3E]
        case ds_sfP3E of {
          GHC.Base.Nothing ->
              Data.Semigroup.Internal.$fMonoidProduct2 $dNum_sfP3D;
          GHC.Base.Just m_sfP3G [Occ=Once] -> m_sfP3G;
        };

Data.Semigroup.$fFoldableOption_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Semigroup.Option a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_sfP3H]
        case eta_sfP3H of {
          GHC.Base.Nothing -> [] [];
          GHC.Base.Just m_sfP3J [Occ=Once] -> : [m_sfP3J GHC.Types.[]];
        };

Data.Semigroup.$fFoldableOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Semigroup.Option
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Semigroup.$fFoldableOption_$cfold
                                             Data.Semigroup.$fFoldableOption_$cfoldMap
                                             Data.Semigroup.$fFoldableOption_$cfoldr'
                                             Data.Semigroup.$fFoldableOption_$cfoldr'
                                             Data.Semigroup.$fFoldableOption_$cfoldl
                                             Data.Semigroup.$fFoldableOption_$cfoldl
                                             Data.Semigroup.$fFoldableOption_$cfoldr1
                                             Data.Semigroup.$fFoldableOption_$cfoldl1
                                             Data.Semigroup.$fFoldableOption_$ctoList
                                             Data.Semigroup.$fFoldableOption_$cnull
                                             Data.Semigroup.$fFoldableOption_$clength
                                             Data.Semigroup.$fFoldableOption_$celem
                                             Data.Semigroup.$fFoldableOption_$cmaximum
                                             Data.Semigroup.$fFoldableOption_$cminimum
                                             Data.Semigroup.$fFoldableOption2
                                             Data.Semigroup.$fFoldableOption1];

Data.Semigroup.$fTraversableOption_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Option a -> f (Data.Semigroup.Option b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfP3K eta_sfP3L eta1_sfP3M]
        case eta1_sfP3M of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sfP3K GHC.Base.Nothing;
          GHC.Base.Just a1_sfP3O [Occ=Once] ->
              let {
                sat_sfP3Q [Occ=Once] :: f_afyvr b_afyvt
                [LclId] =
                    [eta_sfP3L a1_sfP3O] \u [] eta_sfP3L a1_sfP3O;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sfP3K of sat_sfP3P {
                  __DEFAULT -> GHC.Base.fmap sat_sfP3P GHC.Base.Just sat_sfP3Q;
                };
        };

Data.Semigroup.$fTraversableOption_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Option (f a) -> f (Data.Semigroup.Option a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sfP3R eta_sfP3S]
        case eta_sfP3S of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sfP3R GHC.Base.Nothing;
          GHC.Base.Just a1_sfP3U [Occ=Once] ->
              case GHC.Base.$p1Applicative $dApplicative_sfP3R of sat_sfP3V {
                __DEFAULT -> GHC.Base.fmap sat_sfP3V GHC.Base.Just a1_sfP3U;
              };
        };

Data.Semigroup.$fTraversableOption_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfP3W eta_sfP3X eta1_sfP3Y]
        case GHC.Base.$p1Monad $dMonad_sfP3W of sat_sfP3Z {
          __DEFAULT ->
              Data.Semigroup.$fTraversableOption_$ctraverse
                  sat_sfP3Z eta_sfP3X eta1_sfP3Y;
        };

Data.Semigroup.$fTraversableOption_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Option (m a) -> m (Data.Semigroup.Option a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfP40 eta_sfP41]
        case eta_sfP41 of {
          GHC.Base.Nothing ->
              case GHC.Base.$p1Monad $dMonad_sfP40 of sat_sfP43 {
                __DEFAULT -> GHC.Base.pure sat_sfP43 GHC.Base.Nothing;
              };
          GHC.Base.Just a1_sfP44 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sfP40 of sat_sfP45 {
                __DEFAULT ->
                    case GHC.Base.$p1Applicative sat_sfP45 of sat_sfP46 {
                      __DEFAULT -> GHC.Base.fmap sat_sfP46 GHC.Base.Just a1_sfP44;
                    };
              };
        };

Data.Semigroup.$fTraversableOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.$fFunctorOption
                                                   Data.Semigroup.$fFoldableOption
                                                   Data.Semigroup.$fTraversableOption_$ctraverse
                                                   Data.Semigroup.$fTraversableOption_$csequenceA
                                                   Data.Semigroup.$fTraversableOption_$cmapM
                                                   Data.Semigroup.$fTraversableOption_$csequence];

lvl11_rfC6h :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: Option, negative multiplier"#;

Data.Semigroup.$fSemigroupOption1
  :: forall a. Data.Semigroup.Option a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl11_rfC6h of sat_sfP47 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfP47;
        };

Data.Semigroup.$fSemigroupOption2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Semigroup.$fSemigroupOption_$cstimes
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,U(U(U(U,U,U,U,U,U,U),U(U,U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfP48 $dIntegral_sfP49 eta_sfP4a eta1_sfP4b]
        case eta1_sfP4b of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_sfP4d [Occ=Once] ->
              case
                  GHC.Real.$p1Integral $dIntegral_sfP49
              of
              $dReal_sfP4e [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      sat_sfP4h [Occ=Once] :: b_afyuS
                      [LclId] =
                          [$dReal_sfP4e] \u []
                              case GHC.Real.$p1Real $dReal_sfP4e of sat_sfP4g {
                                __DEFAULT ->
                                    GHC.Num.fromInteger sat_sfP4g Data.Semigroup.$fSemigroupOption2;
                              };
                    } in 
                      case GHC.Real.$p2Real $dReal_sfP4e of sat_sfP4f {
                        __DEFAULT ->
                            case GHC.Classes.compare sat_sfP4f eta_sfP4a sat_sfP4h of {
                              GHC.Types.LT -> Data.Semigroup.$fSemigroupOption1;
                              GHC.Types.EQ -> GHC.Base.Nothing [];
                              GHC.Types.GT ->
                                  let {
                                    sat_sfP4j [Occ=Once] :: a_afyuq
                                    [LclId] =
                                        [$dSemigroup_sfP48
                                         $dIntegral_sfP49
                                         eta_sfP4a
                                         a1_sfP4d] \u []
                                            GHC.Base.stimes
                                                $dSemigroup_sfP48
                                                $dIntegral_sfP49
                                                eta_sfP4a
                                                a1_sfP4d;
                                  } in  GHC.Base.Just [sat_sfP4j];
                            };
                      };
              };
        };

Data.Semigroup.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     Data.Semigroup.Option a
     -> [Data.Semigroup.Option a] -> Data.Semigroup.Option a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfP4k ww_sfP4l ww1_sfP4m]
        let {
          go_sfP4n [Occ=LoopBreaker]
            :: Data.Semigroup.Option a_sfBqa
               -> [Data.Semigroup.Option a_sfBqa] -> Data.Semigroup.Option a_sfBqa
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sfP4k go_sfP4n] \r [b_sfP4o ds1_sfP4p]
                  case ds1_sfP4p of {
                    [] -> b_sfP4o;
                    : c_sfP4r [Occ=Once*] cs_sfP4s [Occ=Once*] ->
                        case b_sfP4o of wild_sfP4t {
                          GHC.Base.Nothing -> go_sfP4n c_sfP4r cs_sfP4s;
                          GHC.Base.Just ipv_sfP4u [Occ=Once] ->
                              case go_sfP4n c_sfP4r cs_sfP4s of {
                                GHC.Base.Nothing -> wild_sfP4t;
                                GHC.Base.Just ipv1_sfP4w [Occ=Once] ->
                                    let {
                                      sat_sfP4x [Occ=Once] :: a_sfBqa
                                      [LclId] =
                                          [w_sfP4k ipv_sfP4u ipv1_sfP4w] \u []
                                              GHC.Base.<> w_sfP4k ipv_sfP4u ipv1_sfP4w;
                                    } in  GHC.Base.Just [sat_sfP4x];
                              };
                        };
                  };
        } in  go_sfP4n ww_sfP4l ww1_sfP4m;

Data.Semigroup.$fSemigroupOption_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (Data.Semigroup.Option a)
     -> Data.Semigroup.Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sfP4y w1_sfP4z]
        case w1_sfP4z of {
          GHC.Base.:| ww1_sfP4B [Occ=Once] ww2_sfP4C [Occ=Once] ->
              Data.Semigroup.$w$csconcat2 w_sfP4y ww1_sfP4B ww2_sfP4C;
        };

Data.Semigroup.$fSemigroupOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_sfP4D]
        let {
          sat_sfP4G [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> Data.Semigroup.Option a_afyuq -> Data.Semigroup.Option a_afyuq
          [LclId] =
              [$dSemigroup_sfP4D] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fSemigroupOption_$cstimes
                      $dSemigroup_sfP4D eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfP4F [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Option a_afyuq)
               -> Data.Semigroup.Option a_afyuq
          [LclId] =
              [$dSemigroup_sfP4D] \r [eta_B1]
                  Data.Semigroup.$fSemigroupOption_$csconcat
                      $dSemigroup_sfP4D eta_B1; } in
        let {
          sat_sfP4E [Occ=Once]
            :: Data.Semigroup.Option a_afyuq
               -> Data.Semigroup.Option a_afyuq -> Data.Semigroup.Option a_afyuq
          [LclId] =
              [$dSemigroup_sfP4D] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_sfP4D eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_sfP4E sat_sfP4F sat_sfP4G];

Data.Semigroup.$fMonoidOption_$cmconcat
  :: forall a.
     GHC.Base.Semigroup a =>
     [Data.Semigroup.Option a] -> Data.Semigroup.Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfP4H eta_sfP4I]
        let {
          go_sfP4J [Occ=LoopBreaker]
            :: [Data.Semigroup.Option a_XfyO3] -> Data.Semigroup.Option a_XfyO3
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_sfP4H go_sfP4J] \r [ds_sfP4K]
                  case ds_sfP4K of {
                    [] -> GHC.Base.Nothing [];
                    : y_sfP4M [Occ=Once] ys_sfP4N [Occ=Once*] ->
                        case y_sfP4M of wild1_sfP4O {
                          GHC.Base.Nothing -> go_sfP4J ys_sfP4N;
                          GHC.Base.Just ipv_sfP4P [Occ=Once] ->
                              case go_sfP4J ys_sfP4N of {
                                GHC.Base.Nothing -> wild1_sfP4O;
                                GHC.Base.Just ipv1_sfP4R [Occ=Once] ->
                                    let {
                                      sat_sfP4S [Occ=Once] :: a_XfyO3
                                      [LclId] =
                                          [$dSemigroup_sfP4H ipv_sfP4P ipv1_sfP4R] \u []
                                              GHC.Base.<> $dSemigroup_sfP4H ipv_sfP4P ipv1_sfP4R;
                                    } in  GHC.Base.Just [sat_sfP4S];
                              };
                        };
                  };
        } in  go_sfP4J eta_sfP4I;

Data.Semigroup.$fMonoidOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Monoid (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_sfP4T]
        let {
          sat_sfP4W [Occ=Once]
            :: [Data.Semigroup.Option a_XfyO1] -> Data.Semigroup.Option a_XfyO1
          [LclId] =
              [$dSemigroup_sfP4T] \r [eta_B1]
                  Data.Semigroup.$fMonoidOption_$cmconcat
                      $dSemigroup_sfP4T eta_B1; } in
        let {
          sat_sfP4V [Occ=Once]
            :: Data.Semigroup.Option a_XfyO1
               -> Data.Semigroup.Option a_XfyO1 -> Data.Semigroup.Option a_XfyO1
          [LclId] =
              [$dSemigroup_sfP4T] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_sfP4T eta_B2 eta_B1; } in
        let {
          sat_sfP4U [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Option a_XfyO1)
          [LclId] =
              [$dSemigroup_sfP4T] \u []
                  Data.Semigroup.$fSemigroupOption $dSemigroup_sfP4T;
        } in 
          GHC.Base.C:Monoid [sat_sfP4U GHC.Base.Nothing sat_sfP4V sat_sfP4W];

Data.Semigroup.$fGeneric1Option1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Option a
     -> GHC.Generics.Rep1 Data.Semigroup.Option a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP4X] ds_sfP4X;

Data.Semigroup.$fGeneric1Option2
  :: forall a. Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfP4Y] x_sfP4Y;

Data.Semigroup.$fGeneric1Option [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Option
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Option2
                                            Data.Semigroup.$fGeneric1Option1];

Data.Semigroup.$fGenericOption1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Option a) x
     -> GHC.Generics.Rep (Data.Semigroup.Option a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP4Z] ds_sfP4Z;

Data.Semigroup.$fGenericOption2
  :: forall a x. Data.Semigroup.Option a -> Data.Semigroup.Option a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfP50] x1_sfP50;

Data.Semigroup.$fGenericOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Option a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericOption2
                                           Data.Semigroup.$fGenericOption1];

Data.Semigroup.$fDataOption2
  :: forall a. GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sfP51] v_sfP51;

Data.Semigroup.$fDataOption_$cgunfold
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfP52]
        let {
          $dData1_sfP53 [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_afyoV)
          [LclId] =
              [$dData_sfP52] \u [] Data.Data.$fDataMaybe $dData_sfP52; } in
        let {
          sat_sfP58 [Occ=OnceT[0]]
            :: (forall b r. Data.Data.Data b => c_afypf (b -> r) -> c_afypf r)
               -> (forall r. r -> c_afypf r)
               -> Data.Data.Constr
               -> c_afypf (Data.Semigroup.Option a_afyoV)
          [LclId] =
              [$dData1_sfP53] \r [k_sfP54 z_sfP55 ds_sfP56]
                  let {
                    sat_sfP57 [Occ=Once]
                      :: c_afypf (GHC.Base.Maybe a_afyoV
                                  -> Data.Semigroup.Option a_afyoV)
                    [LclId] =
                        [z_sfP55] \u [] z_sfP55 Data.Semigroup.$fDataOption2;
                  } in  k_sfP54 $dData1_sfP53 sat_sfP57;
        } in  sat_sfP58;

Data.Semigroup.$fDataOption_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Option a
     -> c (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfP59]
        let {
          $dData1_sfP5a [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_afyoV)
          [LclId] =
              [$dData_sfP59] \u [] Data.Data.$fDataMaybe $dData_sfP59; } in
        let {
          sat_sfP5f [Occ=OnceT[0]]
            :: (forall d b.
                Data.Data.Data d =>
                c_afyp4 (d -> b) -> d -> c_afyp4 b)
               -> (forall g. g -> c_afyp4 g)
               -> Data.Semigroup.Option a_afyoV
               -> c_afyp4 (Data.Semigroup.Option a_afyoV)
          [LclId] =
              [$dData1_sfP5a] \r [k_sfP5b z_sfP5c ds_sfP5d]
                  let {
                    sat_sfP5e [Occ=Once]
                      :: c_afyp4 (GHC.Base.Maybe a_afyoV
                                  -> Data.Semigroup.Option a_afyoV)
                    [LclId] =
                        [z_sfP5c] \u [] z_sfP5c Data.Semigroup.$fDataOption2;
                  } in  k_sfP5b $dData1_sfP5a sat_sfP5e ds_sfP5d;
        } in  sat_sfP5f;

Data.Semigroup.$fDataOption6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Option"#;

Data.Semigroup.$fDataOption9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataOption6;

Data.Semigroup.$fReadOption_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataOption9];

Data.Semigroup.$fReadFirst8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Data.Semigroup.$fReadFirst7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadFirst8;

Data.Semigroup.$fReadFirst_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.$fReadFirst7];

Data.Semigroup.$fReadOption3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getOption"#;

Data.Semigroup.$fReadOption2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadOption3;

Data.Semigroup.$fReadArg2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Semigroup.$fReadFirst4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Data.Semigroup.$fReadFirst3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadFirst4;

Data.Semigroup.$fReadFirst2 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.$fReadFirst3];

Data.Semigroup.$fReadOption1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Option a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfP5g eta_sfP5h eta1_sfP5i]
        let {
          ds_sfP5j [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (GHC.Base.Maybe a_afyo6 -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
              [$dRead_sfP5g] \r [ds1_sfP5k eta2_sfP5l]
                  GHC.Read.$fReadMaybe1
                      $dRead_sfP5g
                      Text.ParserCombinators.ReadPrec.minPrec
                      eta2_sfP5l; } in
        let {
          sat_sfP5F [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Option a_afyo6)
          [LclId] =
              [ds_sfP5j] \r [c_sfP5m eta2_sfP5n]
                  case c_sfP5m of {
                    GHC.Types.I# x_sfP5p [Occ=Once] ->
                        case <=# [x_sfP5p 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfP5C [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                [LclId] =
                                    [ds_sfP5j eta2_sfP5n] \r [a1_sfP5r]
                                        let {
                                          sat_sfP5z [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                          [LclId] =
                                              [ds_sfP5j eta2_sfP5n] \r [a2_sfP5s]
                                                  let {
                                                    sat_sfP5y [Occ=Once]
                                                      :: GHC.Base.Maybe a_afyo6
                                                         -> Text.ParserCombinators.ReadP.P b1_i815E
                                                    [LclId] =
                                                        [eta2_sfP5n] \r [a3_sfP5t]
                                                            let {
                                                              sat_sfP5v [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b1_i815E
                                                              [LclId] =
                                                                  [eta2_sfP5n
                                                                   a3_sfP5t] \r [a4_sfP5u]
                                                                      eta2_sfP5n a3_sfP5t;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfP5v
                                                              of
                                                              { Unit# ww1_sfP5x [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfP5x];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadOption2
                                                        ds_sfP5j
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfP5y;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfP5z
                                          of
                                          { Unit# ww1_sfP5B [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfP5B];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadOption_lexeme sat_sfP5C
                                of
                                { Unit# ww1_sfP5E [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfP5E];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfP5F eta_sfP5h eta1_sfP5i;

Data.Semigroup.$fReadOption_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Option a)
[GblId, Arity=2, Str=<L,U(A,A,C(C1(U)),A)><L,U>, Unf=OtherCon []] =
    [] \r [$dRead_sfP5G n_sfP5H]
        let {
          sat_sfP5I [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Option a_XfyIB)
          [LclId] =
              [$dRead_sfP5G n_sfP5H] \u []
                  Data.Semigroup.$fReadOption1
                      $dRead_sfP5G
                      n_sfP5H
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfP5I;

Data.Semigroup.$fReadOption_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Option a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP5J]
        let {
          sat_sfP5K [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Option a_XfyIz)
          [LclId] =
              [$dRead_sfP5J] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadOption1 $dRead_sfP5J eta_B2 eta_B1;
        } in  GHC.Read.list sat_sfP5K;

Data.Semigroup.$fReadOption_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Option a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP5L]
        let {
          sat_sfP5N [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Option a_XfyIA]
          [LclId] =
              [$dRead_sfP5L] \u []
                  let {
                    sat_sfP5M [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Option a_XfyIA)
                    [LclId] =
                        [$dRead_sfP5L] \r [eta_B2 eta_B1]
                            Data.Semigroup.$fReadOption1 $dRead_sfP5L eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sfP5M
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfP5N;

Data.Semigroup.$fReadOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sfP5O]
        let {
          sat_sfP5S [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Option a_XfyIy]
          [LclId] =
              [$dRead_sfP5O] \u []
                  Data.Semigroup.$fReadOption_$creadListPrec $dRead_sfP5O; } in
        let {
          sat_sfP5R [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Option a_XfyIy)
          [LclId] =
              [$dRead_sfP5O] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadOption1 $dRead_sfP5O eta_B2 eta_B1; } in
        let {
          sat_sfP5Q [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Option a_XfyIy]
          [LclId] =
              [$dRead_sfP5O] \u []
                  Data.Semigroup.$fReadOption_$creadList $dRead_sfP5O; } in
        let {
          sat_sfP5P [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Option a_XfyIy)
          [LclId] =
              [$dRead_sfP5O] \r [eta_B1]
                  Data.Semigroup.$fReadOption_$creadsPrec $dRead_sfP5O eta_B1;
        } in  GHC.Read.C:Read [sat_sfP5P sat_sfP5Q sat_sfP5R sat_sfP5S];

Data.Semigroup.$fShowOption2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Option {"#;

Data.Semigroup.$fShowOption1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getOption = "#;

Data.Semigroup.$w$cshowsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Option a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfP5T ww_sfP5U w1_sfP5V]
        let {
          f_sfP5W [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfP5T w1_sfP5V] \u []
                  GHC.Show.$fShowMaybe_$cshowsPrec
                      w_sfP5T Data.Semigroup.$fFoldableOption7 w1_sfP5V;
        } in 
          case >=# [ww_sfP5U 11#] of {
            __DEFAULT ->
                let {
                  sat_sfP62 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfP5W] \r [x_sfP5Y]
                          let {
                            sat_sfP61 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfP5W x_sfP5Y] \u []
                                    let {
                                      sat_sfP60 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfP5W x_sfP5Y] \u []
                                              let {
                                                sat_sfP5Z [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfP5Y] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfP5Y;
                                              } in  f_sfP5W sat_sfP5Z;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowOption1 sat_sfP60;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowOption2 sat_sfP61;
                } in  sat_sfP62;
            1# ->
                let {
                  sat_sfP69 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfP5W] \r [x_sfP63]
                          let {
                            sat_sfP68 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfP5W x_sfP63] \u []
                                    let {
                                      sat_sfP67 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfP5W x_sfP63] \u []
                                              let {
                                                sat_sfP66 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfP5W x_sfP63] \u []
                                                        let {
                                                          sat_sfP65 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfP63] \u []
                                                                  let {
                                                                    sat_sfP64 [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfP63];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfP64;
                                                        } in  f_sfP5W sat_sfP65;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowOption1 sat_sfP66;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowOption2 sat_sfP67;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfP68];
                } in  sat_sfP69;
          };

Data.Semigroup.$fShowOption_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Option a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfP6a w1_sfP6b w2_sfP6c]
        case w1_sfP6b of {
          GHC.Types.I# ww1_sfP6e [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec5 w_sfP6a ww1_sfP6e w2_sfP6c;
        };

Data.Semigroup.$fShowOption3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++ GHC.Show.$fShowMaybe4 Data.Semigroup.$fReadFirst3;

Data.Semigroup.$fShowOption_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Option a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfP6f x_sfP6g]
        let {
          sat_sfP6l [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfP6f x_sfP6g] \u []
                  let {
                    sat_sfP6k [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfP6f x_sfP6g] \u []
                            case x_sfP6g of {
                              GHC.Base.Nothing -> Data.Semigroup.$fShowOption3;
                              GHC.Base.Just b1_sfP6i [Occ=Once] ->
                                  let {
                                    sat_sfP6j [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [$dShow_sfP6f b1_sfP6i] \s []
                                            GHC.Show.showsPrec
                                                $dShow_sfP6f
                                                GHC.Show.appPrec1
                                                b1_sfP6i
                                                Data.Semigroup.$fReadFirst3;
                                  } in  GHC.Base.++ GHC.Show.$fShowMaybe1 sat_sfP6j;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowOption1 sat_sfP6k;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowOption2 sat_sfP6l;

Data.Semigroup.$fShowOption_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Option a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfP6m ls_sfP6n s_sfP6o]
        let {
          sat_sfP6q [Occ=Once]
            :: Data.Semigroup.Option a_afynB -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP6m] \r [w_sfP6p]
                  Data.Semigroup.$w$cshowsPrec5 $dShow_sfP6m 0# w_sfP6p;
        } in  GHC.Show.showList__ sat_sfP6q ls_sfP6n s_sfP6o;

Data.Semigroup.$fShowOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfP6r]
        let {
          sat_sfP6u [Occ=Once]
            :: [Data.Semigroup.Option a_afynB] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP6r] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowOption_$cshowList
                      $dShow_sfP6r eta_B2 eta_B1; } in
        let {
          sat_sfP6t [Occ=Once]
            :: Data.Semigroup.Option a_afynB -> GHC.Base.String
          [LclId] =
              [$dShow_sfP6r] \r [eta_B1]
                  Data.Semigroup.$fShowOption_$cshow $dShow_sfP6r eta_B1; } in
        let {
          sat_sfP6s [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Option a_afynB -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP6r] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowOption_$cshowsPrec $dShow_sfP6r eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfP6s sat_sfP6t sat_sfP6u];

Data.Semigroup.$fEqOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Option a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sfP6v]
        let {
          sat_sfP6x [Occ=Once]
            :: Data.Semigroup.Option a_afyle
               -> Data.Semigroup.Option a_afyle -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP6v] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_sfP6v eta_B2 eta_B1; } in
        let {
          sat_sfP6w [Occ=Once]
            :: Data.Semigroup.Option a_afyle
               -> Data.Semigroup.Option a_afyle -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP6v] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_sfP6v eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sfP6w sat_sfP6x];

Data.Semigroup.$fOrdOption_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfP6y]
        let {
          sat_sfP6z [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_XfyGz
          [LclId] =
              [$dOrd_sfP6y] \u [] GHC.Classes.$p1Ord $dOrd_sfP6y;
        } in  Data.Semigroup.$fEqOption sat_sfP6z;

Data.Semigroup.$fOrdOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Option a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_sfP6A]
        let {
          sat_sfP6K [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> Data.Semigroup.Option a_XfyGA
          [LclId] =
              [$dOrd_sfP6A] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_sfP6A eta_B2 eta_B1; } in
        let {
          sat_sfP6J [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> Data.Semigroup.Option a_XfyGA
          [LclId] =
              [$dOrd_sfP6A] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_sfP6A eta_B2 eta_B1; } in
        let {
          sat_sfP6I [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP6A] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_sfP6A eta_B2 eta_B1; } in
        let {
          sat_sfP6H [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP6A] \r [a1_sfP6F b_sfP6G]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_sfP6A b_sfP6G a1_sfP6F; } in
        let {
          sat_sfP6E [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP6A] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_sfP6A eta_B2 eta_B1; } in
        let {
          sat_sfP6D [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP6A] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_sfP6A eta_B2 eta_B1; } in
        let {
          sat_sfP6C [Occ=Once]
            :: Data.Semigroup.Option a_XfyGA
               -> Data.Semigroup.Option a_XfyGA -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfP6A] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_sfP6A eta_B2 eta_B1; } in
        let {
          sat_sfP6B [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Option a_XfyGA)
          [LclId] =
              [$dOrd_sfP6A] \u [] Data.Semigroup.$fOrdOption_$cp1Ord $dOrd_sfP6A;
        } in 
          GHC.Classes.C:Ord [sat_sfP6B
                             sat_sfP6C
                             sat_sfP6D
                             sat_sfP6E
                             sat_sfP6H
                             sat_sfP6I
                             sat_sfP6J
                             sat_sfP6K];

Data.Semigroup.$fGeneric1WrappedMonoid1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.WrappedMonoid a
     -> GHC.Generics.Rep1 Data.Semigroup.WrappedMonoid a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP6L] ds_sfP6L;

Data.Semigroup.$fGeneric1WrappedMonoid2
  :: forall a.
     Data.Semigroup.WrappedMonoid a -> Data.Semigroup.WrappedMonoid a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfP6M] x_sfP6M;

Data.Semigroup.$fGeneric1WrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.WrappedMonoid
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1WrappedMonoid2
                                            Data.Semigroup.$fGeneric1WrappedMonoid1];

Data.Semigroup.$fGenericWrappedMonoid1
  :: forall m x.
     GHC.Generics.Rep (Data.Semigroup.WrappedMonoid m) x
     -> GHC.Generics.Rep (Data.Semigroup.WrappedMonoid m) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP6N] ds_sfP6N;

Data.Semigroup.$fGenericWrappedMonoid2
  :: forall m x.
     Data.Semigroup.WrappedMonoid m -> Data.Semigroup.WrappedMonoid m
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfP6O] x1_sfP6O;

Data.Semigroup.$fGenericWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. GHC.Generics.Generic (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericWrappedMonoid2
                                           Data.Semigroup.$fGenericWrappedMonoid1];

Data.Semigroup.$fDataWrappedMonoid_$cgfoldl
  :: forall m.
     Data.Data.Data m =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.WrappedMonoid m
     -> c (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfP6P k_sfP6Q z_sfP6R ds_sfP6S]
        let {
          sat_sfP6T [Occ=Once]
            :: c_afygk (m_afygb -> Data.Semigroup.WrappedMonoid m_afygb)
          [LclId] =
              [z_sfP6R] \u [] z_sfP6R Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfP6Q $dData_sfP6P sat_sfP6T ds_sfP6S;

Data.Semigroup.$fReadWrappedMonoid5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrapMonoid"#;

Data.Semigroup.$fReadWrappedMonoid4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.$fReadWrappedMonoid5;

Data.Semigroup.$fReadWrappedMonoid_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fReadWrappedMonoid4];

Data.Semigroup.$fReadWrappedMonoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "unwrapMonoid"#;

Data.Semigroup.$fReadWrappedMonoid2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.$fReadWrappedMonoid3;

Data.Semigroup.$fReadWrappedMonoid1
  :: forall m.
     GHC.Read.Read m =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.WrappedMonoid m
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP6U]
        let {
          lvl33_sfP6V [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP m_afyfm
          [LclId] =
              [$dRead_sfP6U] \u []
                  GHC.Read.readPrec
                      $dRead_sfP6U Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfP6W [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP m_afyfm
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfP6V] \r [ds1_sfP6X] lvl33_sfP6V; } in
        let {
          sat_sfP7h [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.WrappedMonoid m_afyfm)
          [LclId] =
              [ds_sfP6W] \r [c_sfP6Y eta_sfP6Z]
                  case c_sfP6Y of {
                    GHC.Types.I# x_sfP71 [Occ=Once] ->
                        case <=# [x_sfP71 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfP7e [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfP6W eta_sfP6Z] \r [a1_sfP73]
                                        let {
                                          sat_sfP7b [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfP6W eta_sfP6Z] \r [a2_sfP74]
                                                  let {
                                                    sat_sfP7a [Occ=Once]
                                                      :: m_afyfm
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfP6Z] \r [a3_sfP75]
                                                            let {
                                                              sat_sfP77 [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfP6Z a3_sfP75] \r [a4_sfP76]
                                                                      eta_sfP6Z a3_sfP75;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfP77
                                                              of
                                                              { Unit# ww1_sfP79 [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfP79];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadWrappedMonoid2
                                                        ds_sfP6W
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfP7a;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfP7b
                                          of
                                          { Unit# ww1_sfP7d [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfP7d];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadWrappedMonoid_lexeme sat_sfP7e
                                of
                                { Unit# ww1_sfP7g [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfP7g];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfP7h;

Data.Semigroup.$fReadWrappedMonoid_$creadsPrec
  :: forall m.
     GHC.Read.Read m =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.WrappedMonoid m)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP7i]
        let {
          ds_sfP7j [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.WrappedMonoid m_XfyAE
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfP7i] \u []
                  Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfP7i; } in
        let {
          sat_sfP7m [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.WrappedMonoid m_XfyAE)
          [LclId] =
              [ds_sfP7j] \r [n_sfP7k]
                  let {
                    sat_sfP7l [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.WrappedMonoid m_XfyAE)
                    [LclId] =
                        [ds_sfP7j n_sfP7k] \u []
                            ds_sfP7j
                                n_sfP7k Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfP7l;
        } in  sat_sfP7m;

Data.Semigroup.$fReadWrappedMonoid_$creadListPrec
  :: forall m.
     GHC.Read.Read m =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.WrappedMonoid m]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP7n]
        let {
          sat_sfP7o [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.WrappedMonoid m_XfyAC)
          [LclId] =
              [$dRead_sfP7n] \s []
                  Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfP7n;
        } in  GHC.Read.list sat_sfP7o;

Data.Semigroup.$fReadWrappedMonoid_$creadList
  :: forall m.
     GHC.Read.Read m =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.WrappedMonoid m]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP7p]
        let {
          sat_sfP7r [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.WrappedMonoid m_XfyAD]
          [LclId] =
              [$dRead_sfP7p] \u []
                  let {
                    sat_sfP7q [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.WrappedMonoid m_XfyAD)
                    [LclId] =
                        [$dRead_sfP7p] \s []
                            Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfP7p;
                  } in 
                    GHC.Read.list
                        sat_sfP7q
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfP7r;

Data.Semigroup.$fReadWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Read.Read m =>
     GHC.Read.Read (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfP7s]
        let {
          sat_sfP7w [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.WrappedMonoid m_XfyAB]
          [LclId] =
              [$dRead_sfP7s] \u []
                  Data.Semigroup.$fReadWrappedMonoid_$creadListPrec
                      $dRead_sfP7s; } in
        let {
          sat_sfP7v [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.WrappedMonoid m_XfyAB)
          [LclId] =
              [$dRead_sfP7s] \u []
                  Data.Semigroup.$fReadWrappedMonoid1 $dRead_sfP7s; } in
        let {
          sat_sfP7u [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.WrappedMonoid m_XfyAB]
          [LclId] =
              [$dRead_sfP7s] \u []
                  Data.Semigroup.$fReadWrappedMonoid_$creadList $dRead_sfP7s; } in
        let {
          sat_sfP7t [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.WrappedMonoid m_XfyAB)
          [LclId] =
              [$dRead_sfP7s] \u []
                  Data.Semigroup.$fReadWrappedMonoid_$creadsPrec $dRead_sfP7s;
        } in  GHC.Read.C:Read [sat_sfP7t sat_sfP7u sat_sfP7v sat_sfP7w];

Data.Semigroup.$fShowWrappedMonoid2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrapMonoid {"#;

Data.Semigroup.$fShowWrappedMonoid1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "unwrapMonoid = "#;

Data.Semigroup.$w$cshowsPrec6 [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Show.Show m =>
     GHC.Prim.Int# -> Data.Semigroup.WrappedMonoid m -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfP7x ww_sfP7y w1_sfP7z]
        let {
          f_sfP7A [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfP7x w1_sfP7z] \u []
                  GHC.Show.showsPrec
                      w_sfP7x Data.Semigroup.$fFoldableOption7 w1_sfP7z;
        } in 
          case >=# [ww_sfP7y 11#] of {
            __DEFAULT ->
                let {
                  sat_sfP7G [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfP7A] \r [x_sfP7C]
                          let {
                            sat_sfP7F [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfP7A x_sfP7C] \u []
                                    let {
                                      sat_sfP7E [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfP7A x_sfP7C] \u []
                                              let {
                                                sat_sfP7D [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfP7C] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfP7C;
                                              } in  f_sfP7A sat_sfP7D;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowWrappedMonoid1 sat_sfP7E;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowWrappedMonoid2 sat_sfP7F;
                } in  sat_sfP7G;
            1# ->
                let {
                  sat_sfP7N [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfP7A] \r [x_sfP7H]
                          let {
                            sat_sfP7M [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfP7A x_sfP7H] \u []
                                    let {
                                      sat_sfP7L [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfP7A x_sfP7H] \u []
                                              let {
                                                sat_sfP7K [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfP7A x_sfP7H] \u []
                                                        let {
                                                          sat_sfP7J [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfP7H] \u []
                                                                  let {
                                                                    sat_sfP7I [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfP7H];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfP7I;
                                                        } in  f_sfP7A sat_sfP7J;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowWrappedMonoid1 sat_sfP7K;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowWrappedMonoid2 sat_sfP7L;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfP7M];
                } in  sat_sfP7N;
          };

Data.Semigroup.$fShowWrappedMonoid_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     GHC.Show.Show m =>
     GHC.Types.Int -> Data.Semigroup.WrappedMonoid m -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfP7O w1_sfP7P w2_sfP7Q]
        case w1_sfP7P of {
          GHC.Types.I# ww1_sfP7S [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec6 w_sfP7O ww1_sfP7S w2_sfP7Q;
        };

Data.Semigroup.$fShowWrappedMonoid_$cshow
  :: forall m.
     GHC.Show.Show m =>
     Data.Semigroup.WrappedMonoid m -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfP7T x_sfP7U]
        let {
          sat_sfP7W [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfP7T x_sfP7U] \u []
                  let {
                    sat_sfP7V [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfP7T x_sfP7U] \u []
                            GHC.Show.showsPrec
                                $dShow_sfP7T
                                Data.Semigroup.$fFoldableOption7
                                x_sfP7U
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowWrappedMonoid1 sat_sfP7V;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowWrappedMonoid2 sat_sfP7W;

Data.Semigroup.$fShowWrappedMonoid_$cshowList
  :: forall m.
     GHC.Show.Show m =>
     [Data.Semigroup.WrappedMonoid m] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfP7X ls_sfP7Y s_sfP7Z]
        let {
          sat_sfP81 [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyeR -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP7X] \r [w_sfP80]
                  Data.Semigroup.$w$cshowsPrec6 $dShow_sfP7X 0# w_sfP80;
        } in  GHC.Show.showList__ sat_sfP81 ls_sfP7Y s_sfP7Z;

Data.Semigroup.$fShowWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Show.Show m =>
     GHC.Show.Show (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfP82]
        let {
          sat_sfP85 [Occ=Once]
            :: [Data.Semigroup.WrappedMonoid m_afyeR] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP82] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowWrappedMonoid_$cshowList
                      $dShow_sfP82 eta_B2 eta_B1; } in
        let {
          sat_sfP84 [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyeR -> GHC.Base.String
          [LclId] =
              [$dShow_sfP82] \r [eta_B1]
                  Data.Semigroup.$fShowWrappedMonoid_$cshow $dShow_sfP82 eta_B1; } in
        let {
          sat_sfP83 [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.WrappedMonoid m_afyeR -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP82] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowWrappedMonoid_$cshowsPrec
                      $dShow_sfP82 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfP83 sat_sfP84 sat_sfP85];

Data.Semigroup.$fEqWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Classes.Eq m =>
     GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfP86]
        let {
          sat_sfP88 [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afycu
               -> Data.Semigroup.WrappedMonoid m_afycu -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP86] \u [] GHC.Classes./= $dEq_sfP86; } in
        let {
          sat_sfP87 [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afycu
               -> Data.Semigroup.WrappedMonoid m_afycu -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP86] \u [] GHC.Classes.== $dEq_sfP86;
        } in  GHC.Classes.C:Eq [sat_sfP87 sat_sfP88];

Data.Semigroup.$fOrdWrappedMonoid_$cp1Ord
  :: forall m.
     GHC.Classes.Ord m =>
     GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfP89]
        let {
          sat_sfP8a [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq m_afyd2
          [LclId] =
              [$dOrd_sfP89] \u [] GHC.Classes.$p1Ord $dOrd_sfP89;
        } in  Data.Semigroup.$fEqWrappedMonoid sat_sfP8a;

Data.Semigroup.$fOrdWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Classes.Ord m =>
     GHC.Classes.Ord (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfP8b]
        let {
          sat_sfP8j [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.min $dOrd_sfP8b; } in
        let {
          sat_sfP8i [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.max $dOrd_sfP8b; } in
        let {
          sat_sfP8h [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.>= $dOrd_sfP8b; } in
        let {
          sat_sfP8g [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.> $dOrd_sfP8b; } in
        let {
          sat_sfP8f [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.<= $dOrd_sfP8b; } in
        let {
          sat_sfP8e [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.< $dOrd_sfP8b; } in
        let {
          sat_sfP8d [Occ=Once]
            :: Data.Semigroup.WrappedMonoid m_afyd2
               -> Data.Semigroup.WrappedMonoid m_afyd2 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfP8b] \u [] GHC.Classes.compare $dOrd_sfP8b; } in
        let {
          sat_sfP8c [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m_afyd2)
          [LclId] =
              [$dOrd_sfP8b] \u []
                  Data.Semigroup.$fOrdWrappedMonoid_$cp1Ord $dOrd_sfP8b;
        } in 
          GHC.Classes.C:Ord [sat_sfP8c
                             sat_sfP8d
                             sat_sfP8e
                             sat_sfP8f
                             sat_sfP8g
                             sat_sfP8h
                             sat_sfP8i
                             sat_sfP8j];

Data.Semigroup.$fBoundedWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     GHC.Enum.Bounded m =>
     GHC.Enum.Bounded (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfP8k]
        let {
          sat_sfP8m [Occ=Once] :: Data.Semigroup.WrappedMonoid m_afycc
          [LclId] =
              [$dBounded_sfP8k] \u [] GHC.Enum.maxBound $dBounded_sfP8k; } in
        let {
          sat_sfP8l [Occ=Once] :: Data.Semigroup.WrappedMonoid m_afycc
          [LclId] =
              [$dBounded_sfP8k] \u [] GHC.Enum.minBound $dBounded_sfP8k;
        } in  GHC.Enum.C:Bounded [sat_sfP8l sat_sfP8m];

Data.Semigroup.$fGeneric1Last1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Last a
     -> GHC.Generics.Rep1 Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP8n] ds_sfP8n;

Data.Semigroup.$fGeneric1Last2
  :: forall a. Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfP8o] x_sfP8o;

Data.Semigroup.$fGeneric1Last [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Last2
                                            Data.Semigroup.$fGeneric1Last1];

Data.Semigroup.$fGenericLast1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Last a) x
     -> GHC.Generics.Rep (Data.Semigroup.Last a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP8p] ds_sfP8p;

Data.Semigroup.$fGenericLast2
  :: forall a x. Data.Semigroup.Last a -> Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfP8q] x1_sfP8q;

Data.Semigroup.$fGenericLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Last a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericLast2
                                           Data.Semigroup.$fGenericLast1];

Data.Semigroup.$fDataLast_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Last a
     -> c (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfP8r k_sfP8s z_sfP8t ds_sfP8u]
        let {
          sat_sfP8v [Occ=Once]
            :: c_afy7i (a_afy79 -> Data.Semigroup.Last a_afy79)
          [LclId] =
              [z_sfP8t] \u [] z_sfP8t Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfP8s $dData_sfP8r sat_sfP8v ds_sfP8u;

Data.Semigroup.$fDataLast4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last"#;

Data.Semigroup.$fDataLast7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataLast4;

Data.Semigroup.$fReadLast_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataLast7];

Data.Semigroup.$fReadLast3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast"#;

Data.Semigroup.$fReadLast2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadLast3;

Data.Semigroup.$fReadLast1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Last a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP8w]
        let {
          lvl33_sfP8x [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afy6k
          [LclId] =
              [$dRead_sfP8w] \u []
                  GHC.Read.readPrec
                      $dRead_sfP8w Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfP8y [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afy6k
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfP8x] \r [ds1_sfP8z] lvl33_sfP8x; } in
        let {
          sat_sfP8T [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Last a_afy6k)
          [LclId] =
              [ds_sfP8y] \r [c_sfP8A eta_sfP8B]
                  case c_sfP8A of {
                    GHC.Types.I# x_sfP8D [Occ=Once] ->
                        case <=# [x_sfP8D 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfP8Q [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfP8y eta_sfP8B] \r [a1_sfP8F]
                                        let {
                                          sat_sfP8N [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfP8y eta_sfP8B] \r [a2_sfP8G]
                                                  let {
                                                    sat_sfP8M [Occ=Once]
                                                      :: a_afy6k
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfP8B] \r [a3_sfP8H]
                                                            let {
                                                              sat_sfP8J [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfP8B a3_sfP8H] \r [a4_sfP8I]
                                                                      eta_sfP8B a3_sfP8H;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfP8J
                                                              of
                                                              { Unit# ww1_sfP8L [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfP8L];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadLast2
                                                        ds_sfP8y
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfP8M;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfP8N
                                          of
                                          { Unit# ww1_sfP8P [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfP8P];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadLast_lexeme sat_sfP8Q
                                of
                                { Unit# ww1_sfP8S [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfP8S];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfP8T;

Data.Semigroup.$fReadLast_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Last a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP8U]
        let {
          ds_sfP8V [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Last a_Xfysp -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfP8U] \u [] Data.Semigroup.$fReadLast1 $dRead_sfP8U; } in
        let {
          sat_sfP8Y [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Last a_Xfysp)
          [LclId] =
              [ds_sfP8V] \r [n_sfP8W]
                  let {
                    sat_sfP8X [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Last a_Xfysp)
                    [LclId] =
                        [ds_sfP8V n_sfP8W] \u []
                            ds_sfP8V
                                n_sfP8W Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfP8X;
        } in  sat_sfP8Y;

Data.Semigroup.$fReadLast_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Last a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP8Z]
        let {
          sat_sfP90 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Last a_Xfysn)
          [LclId] =
              [$dRead_sfP8Z] \s [] Data.Semigroup.$fReadLast1 $dRead_sfP8Z;
        } in  GHC.Read.list sat_sfP90;

Data.Semigroup.$fReadLast_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Last a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfP91]
        let {
          sat_sfP93 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Last a_Xfyso]
          [LclId] =
              [$dRead_sfP91] \u []
                  let {
                    sat_sfP92 [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Last a_Xfyso)
                    [LclId] =
                        [$dRead_sfP91] \s [] Data.Semigroup.$fReadLast1 $dRead_sfP91;
                  } in 
                    GHC.Read.list
                        sat_sfP92
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfP93;

Data.Semigroup.$fReadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfP94]
        let {
          sat_sfP98 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Last a_Xfysm]
          [LclId] =
              [$dRead_sfP94] \u []
                  Data.Semigroup.$fReadLast_$creadListPrec $dRead_sfP94; } in
        let {
          sat_sfP97 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Last a_Xfysm)
          [LclId] =
              [$dRead_sfP94] \u [] Data.Semigroup.$fReadLast1 $dRead_sfP94; } in
        let {
          sat_sfP96 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Last a_Xfysm]
          [LclId] =
              [$dRead_sfP94] \u []
                  Data.Semigroup.$fReadLast_$creadList $dRead_sfP94; } in
        let {
          sat_sfP95 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Last a_Xfysm)
          [LclId] =
              [$dRead_sfP94] \u []
                  Data.Semigroup.$fReadLast_$creadsPrec $dRead_sfP94;
        } in  GHC.Read.C:Read [sat_sfP95 sat_sfP96 sat_sfP97 sat_sfP98];

Data.Semigroup.$fShowLast2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last {"#;

Data.Semigroup.$fShowLast1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast = "#;

Data.Semigroup.$w$cshowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfP99 ww_sfP9a w1_sfP9b]
        let {
          f_sfP9c [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfP99 w1_sfP9b] \u []
                  GHC.Show.showsPrec
                      w_sfP99 Data.Semigroup.$fFoldableOption7 w1_sfP9b;
        } in 
          case >=# [ww_sfP9a 11#] of {
            __DEFAULT ->
                let {
                  sat_sfP9i [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfP9c] \r [x_sfP9e]
                          let {
                            sat_sfP9h [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfP9c x_sfP9e] \u []
                                    let {
                                      sat_sfP9g [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfP9c x_sfP9e] \u []
                                              let {
                                                sat_sfP9f [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfP9e] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfP9e;
                                              } in  f_sfP9c sat_sfP9f;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowLast1 sat_sfP9g;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowLast2 sat_sfP9h;
                } in  sat_sfP9i;
            1# ->
                let {
                  sat_sfP9p [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfP9c] \r [x_sfP9j]
                          let {
                            sat_sfP9o [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfP9c x_sfP9j] \u []
                                    let {
                                      sat_sfP9n [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfP9c x_sfP9j] \u []
                                              let {
                                                sat_sfP9m [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfP9c x_sfP9j] \u []
                                                        let {
                                                          sat_sfP9l [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfP9j] \u []
                                                                  let {
                                                                    sat_sfP9k [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfP9j];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfP9k;
                                                        } in  f_sfP9c sat_sfP9l;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowLast1 sat_sfP9m;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowLast2 sat_sfP9n;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfP9o];
                } in  sat_sfP9p;
          };

Data.Semigroup.$fShowLast_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfP9q w1_sfP9r w2_sfP9s]
        case w1_sfP9r of {
          GHC.Types.I# ww1_sfP9u [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec2 w_sfP9q ww1_sfP9u w2_sfP9s;
        };

Data.Semigroup.$fShowLast_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Last a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfP9v x_sfP9w]
        let {
          sat_sfP9y [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfP9v x_sfP9w] \u []
                  let {
                    sat_sfP9x [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfP9v x_sfP9w] \u []
                            GHC.Show.showsPrec
                                $dShow_sfP9v
                                Data.Semigroup.$fFoldableOption7
                                x_sfP9w
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowLast1 sat_sfP9x;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowLast2 sat_sfP9y;

Data.Semigroup.$fShowLast_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Last a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfP9z ls_sfP9A s_sfP9B]
        let {
          sat_sfP9D [Occ=Once]
            :: Data.Semigroup.Last a_afy5P -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP9z] \r [w_sfP9C]
                  Data.Semigroup.$w$cshowsPrec2 $dShow_sfP9z 0# w_sfP9C;
        } in  GHC.Show.showList__ sat_sfP9D ls_sfP9A s_sfP9B;

Data.Semigroup.$fShowLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfP9E]
        let {
          sat_sfP9H [Occ=Once]
            :: [Data.Semigroup.Last a_afy5P] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP9E] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowLast_$cshowList
                      $dShow_sfP9E eta_B2 eta_B1; } in
        let {
          sat_sfP9G [Occ=Once]
            :: Data.Semigroup.Last a_afy5P -> GHC.Base.String
          [LclId] =
              [$dShow_sfP9E] \r [eta_B1]
                  Data.Semigroup.$fShowLast_$cshow $dShow_sfP9E eta_B1; } in
        let {
          sat_sfP9F [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Last a_afy5P -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfP9E] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowLast_$cshowsPrec $dShow_sfP9E eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfP9F sat_sfP9G sat_sfP9H];

Data.Semigroup.$fEqLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfP9I]
        let {
          sat_sfP9K [Occ=Once]
            :: Data.Semigroup.Last a_afy3s
               -> Data.Semigroup.Last a_afy3s -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP9I] \u [] GHC.Classes./= $dEq_sfP9I; } in
        let {
          sat_sfP9J [Occ=Once]
            :: Data.Semigroup.Last a_afy3s
               -> Data.Semigroup.Last a_afy3s -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfP9I] \u [] GHC.Classes.== $dEq_sfP9I;
        } in  GHC.Classes.C:Eq [sat_sfP9J sat_sfP9K];

Data.Semigroup.$fOrdLast_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Last a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfP9L]
        let {
          sat_sfP9M [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afy40
          [LclId] =
              [$dOrd_sfP9L] \u [] GHC.Classes.$p1Ord $dOrd_sfP9L;
        } in  Data.Semigroup.$fEqLast sat_sfP9M;

Data.Semigroup.$fOrdLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfP9N]
        let {
          sat_sfP9V [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> Data.Semigroup.Last a_afy40
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.min $dOrd_sfP9N; } in
        let {
          sat_sfP9U [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> Data.Semigroup.Last a_afy40
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.max $dOrd_sfP9N; } in
        let {
          sat_sfP9T [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.>= $dOrd_sfP9N; } in
        let {
          sat_sfP9S [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.> $dOrd_sfP9N; } in
        let {
          sat_sfP9R [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.<= $dOrd_sfP9N; } in
        let {
          sat_sfP9Q [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.< $dOrd_sfP9N; } in
        let {
          sat_sfP9P [Occ=Once]
            :: Data.Semigroup.Last a_afy40
               -> Data.Semigroup.Last a_afy40 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfP9N] \u [] GHC.Classes.compare $dOrd_sfP9N; } in
        let {
          sat_sfP9O [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Last a_afy40)
          [LclId] =
              [$dOrd_sfP9N] \u [] Data.Semigroup.$fOrdLast_$cp1Ord $dOrd_sfP9N;
        } in 
          GHC.Classes.C:Ord [sat_sfP9O
                             sat_sfP9P
                             sat_sfP9Q
                             sat_sfP9R
                             sat_sfP9S
                             sat_sfP9T
                             sat_sfP9U
                             sat_sfP9V];

Data.Semigroup.$fBoundedLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Last a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfP9W]
        let {
          sat_sfP9Y [Occ=Once] :: Data.Semigroup.Last a_afy3a
          [LclId] =
              [$dBounded_sfP9W] \u [] GHC.Enum.maxBound $dBounded_sfP9W; } in
        let {
          sat_sfP9X [Occ=Once] :: Data.Semigroup.Last a_afy3a
          [LclId] =
              [$dBounded_sfP9W] \u [] GHC.Enum.minBound $dBounded_sfP9W;
        } in  GHC.Enum.C:Bounded [sat_sfP9X sat_sfP9Y];

Data.Semigroup.$fGeneric1First1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.First a
     -> GHC.Generics.Rep1 Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfP9Z] ds_sfP9Z;

Data.Semigroup.$fGeneric1First2
  :: forall a. Data.Semigroup.First a -> Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfPa0] x_sfPa0;

Data.Semigroup.$fGeneric1First [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1First2
                                            Data.Semigroup.$fGeneric1First1];

Data.Semigroup.$fGenericFirst1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.First a) x
     -> GHC.Generics.Rep (Data.Semigroup.First a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfPa1] ds_sfPa1;

Data.Semigroup.$fGenericFirst2
  :: forall a x. Data.Semigroup.First a -> Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfPa2] x1_sfPa2;

Data.Semigroup.$fGenericFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.First a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericFirst2
                                           Data.Semigroup.$fGenericFirst1];

Data.Semigroup.$fDataFirst_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.First a
     -> c (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPa3 k_sfPa4 z_sfPa5 ds_sfPa6]
        let {
          sat_sfPa7 [Occ=Once]
            :: c_afxYg (a_afxY7 -> Data.Semigroup.First a_afxY7)
          [LclId] =
              [z_sfPa5] \u [] z_sfPa5 Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfPa4 $dData_sfPa3 sat_sfPa7 ds_sfPa6;

Data.Semigroup.$fDataFirst4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First"#;

Data.Semigroup.$fDataFirst7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataFirst4;

Data.Semigroup.$fReadFirst_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataFirst7];

Data.Semigroup.$fReadFirst6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst"#;

Data.Semigroup.$fReadFirst5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadFirst6;

Data.Semigroup.$fReadFirst1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.First a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPa8]
        let {
          lvl33_sfPa9 [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afxXi
          [LclId] =
              [$dRead_sfPa8] \u []
                  GHC.Read.readPrec
                      $dRead_sfPa8 Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfPaa [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afxXi
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfPa9] \r [ds1_sfPab] lvl33_sfPa9; } in
        let {
          sat_sfPav [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.First a_afxXi)
          [LclId] =
              [ds_sfPaa] \r [c_sfPac eta_sfPad]
                  case c_sfPac of {
                    GHC.Types.I# x_sfPaf [Occ=Once] ->
                        case <=# [x_sfPaf 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfPas [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfPaa eta_sfPad] \r [a1_sfPah]
                                        let {
                                          sat_sfPap [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfPaa eta_sfPad] \r [a2_sfPai]
                                                  let {
                                                    sat_sfPao [Occ=Once]
                                                      :: a_afxXi
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfPad] \r [a3_sfPaj]
                                                            let {
                                                              sat_sfPal [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfPad a3_sfPaj] \r [a4_sfPak]
                                                                      eta_sfPad a3_sfPaj;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfPal
                                                              of
                                                              { Unit# ww1_sfPan [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfPan];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadFirst5
                                                        ds_sfPaa
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfPao;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfPap
                                          of
                                          { Unit# ww1_sfPar [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfPar];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.$fReadFirst_lexeme1 sat_sfPas
                                of
                                { Unit# ww1_sfPau [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfPau];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfPav;

Data.Semigroup.$fReadFirst_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.First a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPaw]
        let {
          ds_sfPax [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.First a_Xfyka -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfPaw] \u [] Data.Semigroup.$fReadFirst1 $dRead_sfPaw; } in
        let {
          sat_sfPaA [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.First a_Xfyka)
          [LclId] =
              [ds_sfPax] \r [n_sfPay]
                  let {
                    sat_sfPaz [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.First a_Xfyka)
                    [LclId] =
                        [ds_sfPax n_sfPay] \u []
                            ds_sfPax
                                n_sfPay Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfPaz;
        } in  sat_sfPaA;

Data.Semigroup.$fReadFirst_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.First a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPaB]
        let {
          sat_sfPaC [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.First a_Xfyk8)
          [LclId] =
              [$dRead_sfPaB] \s [] Data.Semigroup.$fReadFirst1 $dRead_sfPaB;
        } in  GHC.Read.list sat_sfPaC;

Data.Semigroup.$fReadFirst_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.First a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPaD]
        let {
          sat_sfPaF [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.First a_Xfyk9]
          [LclId] =
              [$dRead_sfPaD] \u []
                  let {
                    sat_sfPaE [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.First a_Xfyk9)
                    [LclId] =
                        [$dRead_sfPaD] \s [] Data.Semigroup.$fReadFirst1 $dRead_sfPaD;
                  } in 
                    GHC.Read.list
                        sat_sfPaE
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfPaF;

Data.Semigroup.$fReadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfPaG]
        let {
          sat_sfPaK [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.First a_Xfyk7]
          [LclId] =
              [$dRead_sfPaG] \u []
                  Data.Semigroup.$fReadFirst_$creadListPrec $dRead_sfPaG; } in
        let {
          sat_sfPaJ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.First a_Xfyk7)
          [LclId] =
              [$dRead_sfPaG] \u [] Data.Semigroup.$fReadFirst1 $dRead_sfPaG; } in
        let {
          sat_sfPaI [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.First a_Xfyk7]
          [LclId] =
              [$dRead_sfPaG] \u []
                  Data.Semigroup.$fReadFirst_$creadList $dRead_sfPaG; } in
        let {
          sat_sfPaH [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.First a_Xfyk7)
          [LclId] =
              [$dRead_sfPaG] \u []
                  Data.Semigroup.$fReadFirst_$creadsPrec $dRead_sfPaG;
        } in  GHC.Read.C:Read [sat_sfPaH sat_sfPaI sat_sfPaJ sat_sfPaK];

Data.Semigroup.$fShowFirst2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First {"#;

Data.Semigroup.$fShowFirst1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst = "#;

Data.Semigroup.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPaL ww_sfPaM w1_sfPaN]
        let {
          f_sfPaO [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfPaL w1_sfPaN] \u []
                  GHC.Show.showsPrec
                      w_sfPaL Data.Semigroup.$fFoldableOption7 w1_sfPaN;
        } in 
          case >=# [ww_sfPaM 11#] of {
            __DEFAULT ->
                let {
                  sat_sfPaU [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPaO] \r [x_sfPaQ]
                          let {
                            sat_sfPaT [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPaO x_sfPaQ] \u []
                                    let {
                                      sat_sfPaS [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPaO x_sfPaQ] \u []
                                              let {
                                                sat_sfPaR [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfPaQ] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfPaQ;
                                              } in  f_sfPaO sat_sfPaR;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowFirst1 sat_sfPaS;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowFirst2 sat_sfPaT;
                } in  sat_sfPaU;
            1# ->
                let {
                  sat_sfPb1 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPaO] \r [x_sfPaV]
                          let {
                            sat_sfPb0 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPaO x_sfPaV] \u []
                                    let {
                                      sat_sfPaZ [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPaO x_sfPaV] \u []
                                              let {
                                                sat_sfPaY [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfPaO x_sfPaV] \u []
                                                        let {
                                                          sat_sfPaX [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfPaV] \u []
                                                                  let {
                                                                    sat_sfPaW [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfPaV];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfPaW;
                                                        } in  f_sfPaO sat_sfPaX;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowFirst1 sat_sfPaY;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowFirst2 sat_sfPaZ;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfPb0];
                } in  sat_sfPb1;
          };

Data.Semigroup.$fShowFirst_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPb2 w1_sfPb3 w2_sfPb4]
        case w1_sfPb3 of {
          GHC.Types.I# ww1_sfPb6 [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec1 w_sfPb2 ww1_sfPb6 w2_sfPb4;
        };

Data.Semigroup.$fShowFirst_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.First a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPb7 x_sfPb8]
        let {
          sat_sfPba [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfPb7 x_sfPb8] \u []
                  let {
                    sat_sfPb9 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfPb7 x_sfPb8] \u []
                            GHC.Show.showsPrec
                                $dShow_sfPb7
                                Data.Semigroup.$fFoldableOption7
                                x_sfPb8
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowFirst1 sat_sfPb9;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowFirst2 sat_sfPba;

Data.Semigroup.$fShowFirst_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.First a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPbb ls_sfPbc s_sfPbd]
        let {
          sat_sfPbf [Occ=Once]
            :: Data.Semigroup.First a_afxWN -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPbb] \r [w_sfPbe]
                  Data.Semigroup.$w$cshowsPrec1 $dShow_sfPbb 0# w_sfPbe;
        } in  GHC.Show.showList__ sat_sfPbf ls_sfPbc s_sfPbd;

Data.Semigroup.$fShowFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfPbg]
        let {
          sat_sfPbj [Occ=Once]
            :: [Data.Semigroup.First a_afxWN] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPbg] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowFirst_$cshowList
                      $dShow_sfPbg eta_B2 eta_B1; } in
        let {
          sat_sfPbi [Occ=Once]
            :: Data.Semigroup.First a_afxWN -> GHC.Base.String
          [LclId] =
              [$dShow_sfPbg] \r [eta_B1]
                  Data.Semigroup.$fShowFirst_$cshow $dShow_sfPbg eta_B1; } in
        let {
          sat_sfPbh [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.First a_afxWN -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPbg] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowFirst_$cshowsPrec $dShow_sfPbg eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfPbh sat_sfPbi sat_sfPbj];

Data.Semigroup.$fEqFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfPbk]
        let {
          sat_sfPbm [Occ=Once]
            :: Data.Semigroup.First a_afxUq
               -> Data.Semigroup.First a_afxUq -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfPbk] \u [] GHC.Classes./= $dEq_sfPbk; } in
        let {
          sat_sfPbl [Occ=Once]
            :: Data.Semigroup.First a_afxUq
               -> Data.Semigroup.First a_afxUq -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfPbk] \u [] GHC.Classes.== $dEq_sfPbk;
        } in  GHC.Classes.C:Eq [sat_sfPbl sat_sfPbm];

Data.Semigroup.$fOrdFirst_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.First a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfPbn]
        let {
          sat_sfPbo [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afxUY
          [LclId] =
              [$dOrd_sfPbn] \u [] GHC.Classes.$p1Ord $dOrd_sfPbn;
        } in  Data.Semigroup.$fEqFirst sat_sfPbo;

Data.Semigroup.$fOrdFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfPbp]
        let {
          sat_sfPbx [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> Data.Semigroup.First a_afxUY
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.min $dOrd_sfPbp; } in
        let {
          sat_sfPbw [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> Data.Semigroup.First a_afxUY
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.max $dOrd_sfPbp; } in
        let {
          sat_sfPbv [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.>= $dOrd_sfPbp; } in
        let {
          sat_sfPbu [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.> $dOrd_sfPbp; } in
        let {
          sat_sfPbt [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.<= $dOrd_sfPbp; } in
        let {
          sat_sfPbs [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.< $dOrd_sfPbp; } in
        let {
          sat_sfPbr [Occ=Once]
            :: Data.Semigroup.First a_afxUY
               -> Data.Semigroup.First a_afxUY -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfPbp] \u [] GHC.Classes.compare $dOrd_sfPbp; } in
        let {
          sat_sfPbq [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.First a_afxUY)
          [LclId] =
              [$dOrd_sfPbp] \u [] Data.Semigroup.$fOrdFirst_$cp1Ord $dOrd_sfPbp;
        } in 
          GHC.Classes.C:Ord [sat_sfPbq
                             sat_sfPbr
                             sat_sfPbs
                             sat_sfPbt
                             sat_sfPbu
                             sat_sfPbv
                             sat_sfPbw
                             sat_sfPbx];

Data.Semigroup.$fBoundedFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.First a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfPby]
        let {
          sat_sfPbA [Occ=Once] :: Data.Semigroup.First a_afxU8
          [LclId] =
              [$dBounded_sfPby] \u [] GHC.Enum.maxBound $dBounded_sfPby; } in
        let {
          sat_sfPbz [Occ=Once] :: Data.Semigroup.First a_afxU8
          [LclId] =
              [$dBounded_sfPby] \u [] GHC.Enum.minBound $dBounded_sfPby;
        } in  GHC.Enum.C:Bounded [sat_sfPbz sat_sfPbA];

Data.Semigroup.$fGeneric1Arg_$cto1
  :: forall a1 a2.
     GHC.Generics.Rep1 (Data.Semigroup.Arg a1) a2
     -> Data.Semigroup.Arg a1 a2
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sfPbB]
        case ds_sfPbB of {
          GHC.Generics.:*: ds1_sfPbD [Occ=Once] ds2_sfPbE [Occ=Once] ->
              Data.Semigroup.Arg [ds1_sfPbD ds2_sfPbE];
        };

Data.Semigroup.$fGeneric1Arg1
  :: forall a1 a2.
     Data.Semigroup.Arg a1 a2
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Arg" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R a1)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              GHC.Generics.Par1)
          a2
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_sfPbF]
        case x_sfPbF of {
          Data.Semigroup.Arg g1_sfPbH [Occ=Once] g2_sfPbI [Occ=Once] ->
              GHC.Generics.:*: [g1_sfPbH g2_sfPbI];
        };

Data.Semigroup.$fGeneric1Arg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic1 (Data.Semigroup.Arg a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Arg1
                                            Data.Semigroup.$fGeneric1Arg_$cto1];

Data.Semigroup.$fGenericArg_$cto
  :: forall a b x.
     GHC.Generics.Rep (Data.Semigroup.Arg a b) x
     -> Data.Semigroup.Arg a b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sfPbJ]
        case ds_sfPbJ of {
          GHC.Generics.:*: ds1_sfPbL [Occ=Once] ds2_sfPbM [Occ=Once] ->
              Data.Semigroup.Arg [ds1_sfPbL ds2_sfPbM];
        };

Data.Semigroup.$fGenericArg1
  :: forall a b x.
     Data.Semigroup.Arg a b
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             "Arg" 'GHC.Generics.PrefixI 'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R a)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.K1 GHC.Generics.R b))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x1_sfPbN]
        case x1_sfPbN of {
          Data.Semigroup.Arg g1_sfPbP [Occ=Once] g2_sfPbQ [Occ=Once] ->
              GHC.Generics.:*: [g1_sfPbP g2_sfPbQ];
        };

Data.Semigroup.$fGenericArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. GHC.Generics.Generic (Data.Semigroup.Arg a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericArg1
                                           Data.Semigroup.$fGenericArg_$cto];

Data.Semigroup.$fDataArg_$cgunfold
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (c :: * -> *).
     (forall b1 r. Data.Data.Data b1 => c (b1 -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPbR $dData1_sfPbS k_sfPbT z_sfPbU ds_sfPbV]
        let {
          sat_sfPbX [Occ=Once]
            :: c_afxOm (b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
          [LclId] =
              [$dData_sfPbR k_sfPbT z_sfPbU] \u []
                  let {
                    sat_sfPbW [Occ=Once]
                      :: c_afxOm (a_afxNW
                                  -> b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
                    [LclId] =
                        [z_sfPbU] \u [] z_sfPbU Data.Semigroup.Arg;
                  } in  k_sfPbT $dData_sfPbR sat_sfPbW;
        } in  k_sfPbT $dData1_sfPbS sat_sfPbX;

Data.Semigroup.$fDataArg_$cgfoldl
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (c :: * -> *).
     (forall d b1. Data.Data.Data d => c (d -> b1) -> d -> c b1)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Arg a b
     -> c (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPbY $dData1_sfPbZ k_sfPc0 z_sfPc1 ds_sfPc2]
        case ds_sfPc2 of {
          Data.Semigroup.Arg a1_sfPc4 [Occ=Once] a2_sfPc5 [Occ=Once] ->
              let {
                sat_sfPc7 [Occ=Once]
                  :: c_afxO7 (b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
                [LclId] =
                    [$dData_sfPbY k_sfPc0 z_sfPc1 a1_sfPc4] \u []
                        let {
                          sat_sfPc6 [Occ=Once]
                            :: c_afxO7 (a_afxNW
                                        -> b_afxNX -> Data.Semigroup.Arg a_afxNW b_afxNX)
                          [LclId] =
                              [z_sfPc1] \u [] z_sfPc1 Data.Semigroup.Arg;
                        } in  k_sfPc0 $dData_sfPbY sat_sfPc6 a1_sfPc4;
              } in  k_sfPc0 $dData1_sfPbZ sat_sfPc7 a2_sfPc5;
        };

Data.Semigroup.$fDataArg6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Arg"#;

Data.Semigroup.$fDataArg9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataArg6;

Data.Semigroup.$fReadArg_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataArg9];

Data.Semigroup.$fReadArg1
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Semigroup.Arg a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfPc8 $dRead1_sfPc9 eta_sfPca eta1_sfPcb]
        let {
          sat_sfPcq [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Arg a_afxN6 b_afxN7)
          [LclId] =
              [$dRead_sfPc8 $dRead1_sfPc9] \r [c_sfPcc eta2_sfPcd]
                  case c_sfPcc of {
                    GHC.Types.I# x_sfPcf [Occ=Once] ->
                        case <=# [x_sfPcf 10#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfPcn [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b2_i815E
                                [LclId] =
                                    [$dRead_sfPc8 $dRead1_sfPc9 eta2_sfPcd] \r [a1_sfPch]
                                        let {
                                          sat_sfPcm [Occ=Once]
                                            :: a_afxN6 -> Text.ParserCombinators.ReadP.P b2_i815E
                                          [LclId] =
                                              [$dRead1_sfPc9 eta2_sfPcd] \r [a2_sfPci]
                                                  let {
                                                    sat_sfPcl [Occ=Once]
                                                      :: b_afxN7
                                                         -> Text.ParserCombinators.ReadP.P b2_i815E
                                                    [LclId] =
                                                        [eta2_sfPcd a2_sfPci] \r [a3_sfPcj]
                                                            let {
                                                              sat_sfPck [Occ=Once]
                                                                :: Data.Semigroup.Arg
                                                                     a_afxN6 b_afxN7
                                                              [LclId] =
                                                                  CCCS Data.Semigroup.Arg! [a2_sfPci
                                                                                            a3_sfPcj];
                                                            } in  eta2_sfPcd sat_sfPck;
                                                  } in 
                                                    GHC.Read.readPrec
                                                        $dRead1_sfPc9
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfPcl;
                                        } in 
                                          GHC.Read.readPrec
                                              $dRead_sfPc8 Data.Semigroup.$fReadArg2 sat_sfPcm;
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Semigroup.$fReadArg_lexeme sat_sfPcn
                                of
                                { Unit# ww1_sfPcp [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfPcp];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfPcq eta_sfPca eta1_sfPcb;

Data.Semigroup.$fReadArg_$creadsPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Arg a b)
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfPcr $dRead1_sfPcs n_sfPct]
        let {
          sat_sfPcu [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Semigroup.Arg a_XfyaI b_XfyaK)
          [LclId] =
              [$dRead_sfPcr $dRead1_sfPcs n_sfPct] \u []
                  Data.Semigroup.$fReadArg1
                      $dRead_sfPcr
                      $dRead1_sfPcs
                      n_sfPct
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfPcu;

Data.Semigroup.$fReadArg_$creadListPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Arg a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfPcv $dRead1_sfPcw]
        let {
          sat_sfPcx [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Arg a_XfyaG b_XfyaI)
          [LclId] =
              [$dRead_sfPcv $dRead1_sfPcw] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadArg1 $dRead_sfPcv $dRead1_sfPcw eta_B2 eta_B1;
        } in  GHC.Read.list sat_sfPcx;

Data.Semigroup.$fReadArg_$creadList
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Arg a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_sfPcy $dRead1_sfPcz]
        let {
          sat_sfPcB [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Arg a_XfyaH b_XfyaJ]
          [LclId] =
              [$dRead_sfPcy $dRead1_sfPcz] \u []
                  let {
                    sat_sfPcA [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Arg a_XfyaH b_XfyaJ)
                    [LclId] =
                        [$dRead_sfPcy $dRead1_sfPcz] \r [eta_B2 eta_B1]
                            Data.Semigroup.$fReadArg1 $dRead_sfPcy $dRead1_sfPcz eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sfPcA
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfPcB;

Data.Semigroup.$fReadArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Read.Read (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_sfPcC $dRead1_sfPcD]
        let {
          sat_sfPcH [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Arg a_XfyaF b_XfyaH]
          [LclId] =
              [$dRead_sfPcC $dRead1_sfPcD] \u []
                  Data.Semigroup.$fReadArg_$creadListPrec
                      $dRead_sfPcC $dRead1_sfPcD; } in
        let {
          sat_sfPcG [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Arg a_XfyaF b_XfyaH)
          [LclId] =
              [$dRead_sfPcC $dRead1_sfPcD] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fReadArg1
                      $dRead_sfPcC $dRead1_sfPcD eta_B2 eta_B1; } in
        let {
          sat_sfPcF [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Arg a_XfyaF b_XfyaH]
          [LclId] =
              [$dRead_sfPcC $dRead1_sfPcD] \u []
                  Data.Semigroup.$fReadArg_$creadList
                      $dRead_sfPcC $dRead1_sfPcD; } in
        let {
          sat_sfPcE [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Arg a_XfyaF b_XfyaH)
          [LclId] =
              [$dRead_sfPcC $dRead1_sfPcD] \r [eta_B1]
                  Data.Semigroup.$fReadArg_$creadsPrec
                      $dRead_sfPcC $dRead1_sfPcD eta_B1;
        } in  GHC.Read.C:Read [sat_sfPcE sat_sfPcF sat_sfPcG sat_sfPcH];

Data.Semigroup.$fShowArg1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Arg "#;

Data.Semigroup.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Prim.Int# -> a -> b -> GHC.Show.ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPcI w1_sfPcJ ww_sfPcK ww1_sfPcL ww2_sfPcM]
        let {
          f_sfPcN [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfPcI ww1_sfPcL] \u []
                  GHC.Show.showsPrec
                      w_sfPcI Data.Semigroup.$fReadArg2 ww1_sfPcL; } in
        let {
          g_sfPcO [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w1_sfPcJ ww2_sfPcM] \u []
                  GHC.Show.showsPrec w1_sfPcJ Data.Semigroup.$fReadArg2 ww2_sfPcM;
        } in 
          case >=# [ww_sfPcK 11#] of {
            __DEFAULT ->
                let {
                  sat_sfPcU [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPcN g_sfPcO] \r [x_sfPcQ]
                          let {
                            sat_sfPcT [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPcN g_sfPcO x_sfPcQ] \u []
                                    let {
                                      sat_sfPcR [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sfPcO x_sfPcQ] \u [] g_sfPcO x_sfPcQ; } in
                                    let {
                                      sat_sfPcS [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          CCCS :! [GHC.Show.showSpace1 sat_sfPcR];
                                    } in  f_sfPcN sat_sfPcS;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowArg1 sat_sfPcT;
                } in  sat_sfPcU;
            1# ->
                let {
                  sat_sfPd1 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPcN g_sfPcO] \r [x_sfPcV]
                          let {
                            sat_sfPd0 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPcN g_sfPcO x_sfPcV] \u []
                                    let {
                                      sat_sfPcZ [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPcN g_sfPcO x_sfPcV] \u []
                                              let {
                                                sat_sfPcX [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sfPcO x_sfPcV] \u []
                                                        let {
                                                          sat_sfPcW [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sfPcV];
                                                        } in  g_sfPcO sat_sfPcW; } in
                                              let {
                                                sat_sfPcY [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    CCCS :! [GHC.Show.showSpace1 sat_sfPcX];
                                              } in  f_sfPcN sat_sfPcY;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowArg1 sat_sfPcZ;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfPd0];
                } in  sat_sfPd1;
          };

Data.Semigroup.$fShowArg_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Types.Int -> Data.Semigroup.Arg a b -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sfPd2 w1_sfPd3 w2_sfPd4 w3_sfPd5]
        case w2_sfPd4 of {
          GHC.Types.I# ww1_sfPd7 [Occ=Once] ->
              case w3_sfPd5 of {
                Data.Semigroup.Arg ww3_sfPd9 [Occ=Once] ww4_sfPda [Occ=Once] ->
                    Data.Semigroup.$w$cshowsPrec
                        w_sfPd2 w1_sfPd3 ww1_sfPd7 ww3_sfPd9 ww4_sfPda;
              };
        };

Data.Semigroup.$fShowArg_$cshow
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     Data.Semigroup.Arg a b -> GHC.Base.String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPdb $dShow1_sfPdc x_sfPdd]
        case x_sfPdd of {
          Data.Semigroup.Arg ww1_sfPdf [Occ=Once] ww2_sfPdg [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec
                  $dShow_sfPdb $dShow1_sfPdc 0# ww1_sfPdf ww2_sfPdg GHC.Types.[];
        };

Data.Semigroup.$fShowArg_$cshowList
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     [Data.Semigroup.Arg a b] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPdh $dShow1_sfPdi ls_sfPdj s_sfPdk]
        let {
          sat_sfPdp [Occ=Once]
            :: Data.Semigroup.Arg a_afxMx b_afxMy -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPdh $dShow1_sfPdi] \r [w_sfPdl]
                  case w_sfPdl of {
                    Data.Semigroup.Arg ww1_sfPdn [Occ=Once] ww2_sfPdo [Occ=Once] ->
                        Data.Semigroup.$w$cshowsPrec
                            $dShow_sfPdh $dShow1_sfPdi 0# ww1_sfPdn ww2_sfPdo;
                  };
        } in  GHC.Show.showList__ sat_sfPdp ls_sfPdj s_sfPdk;

Data.Semigroup.$fShowArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Show.Show (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfPdq $dShow1_sfPdr]
        let {
          sat_sfPdu [Occ=Once]
            :: [Data.Semigroup.Arg a_afxMx b_afxMy] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPdq $dShow1_sfPdr] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowArg_$cshowList
                      $dShow_sfPdq $dShow1_sfPdr eta_B2 eta_B1; } in
        let {
          sat_sfPdt [Occ=Once]
            :: Data.Semigroup.Arg a_afxMx b_afxMy -> GHC.Base.String
          [LclId] =
              [$dShow_sfPdq $dShow1_sfPdr] \r [eta_B1]
                  Data.Semigroup.$fShowArg_$cshow
                      $dShow_sfPdq $dShow1_sfPdr eta_B1; } in
        let {
          sat_sfPds [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Arg a_afxMx b_afxMy -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPdq $dShow1_sfPdr] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowArg_$cshowsPrec
                      $dShow_sfPdq $dShow1_sfPdr eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfPds sat_sfPdt sat_sfPdu];

Data.Semigroup.$fGeneric1Max1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Max a
     -> GHC.Generics.Rep1 Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfPdv] ds_sfPdv;

Data.Semigroup.$fGeneric1Max2
  :: forall a. Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfPdw] x_sfPdw;

Data.Semigroup.$fGeneric1Max [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Max
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Max2
                                            Data.Semigroup.$fGeneric1Max1];

Data.Semigroup.$fGenericMax1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Max a) x
     -> GHC.Generics.Rep (Data.Semigroup.Max a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfPdx] ds_sfPdx;

Data.Semigroup.$fGenericMax2
  :: forall a x. Data.Semigroup.Max a -> Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfPdy] x1_sfPdy;

Data.Semigroup.$fGenericMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Max a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericMax2
                                           Data.Semigroup.$fGenericMax1];

Data.Semigroup.$fDataMax_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Max a
     -> c (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPdz k_sfPdA z_sfPdB ds_sfPdC]
        let {
          sat_sfPdD [Occ=Once]
            :: c_afxHD (a_afxHu -> Data.Semigroup.Max a_afxHu)
          [LclId] =
              [z_sfPdB] \u [] z_sfPdB Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfPdA $dData_sfPdz sat_sfPdD ds_sfPdC;

Data.Semigroup.$fDataMax4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Max"#;

Data.Semigroup.$fDataMax7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataMax4;

Data.Semigroup.$fReadMax_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataMax7];

Data.Semigroup.$fReadMax3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMax"#;

Data.Semigroup.$fReadMax2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadMax3;

Data.Semigroup.$fReadMax1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Max a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPdE]
        let {
          lvl33_sfPdF [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afxGF
          [LclId] =
              [$dRead_sfPdE] \u []
                  GHC.Read.readPrec
                      $dRead_sfPdE Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfPdG [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afxGF
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfPdF] \r [ds1_sfPdH] lvl33_sfPdF; } in
        let {
          sat_sfPe1 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Max a_afxGF)
          [LclId] =
              [ds_sfPdG] \r [c_sfPdI eta_sfPdJ]
                  case c_sfPdI of {
                    GHC.Types.I# x_sfPdL [Occ=Once] ->
                        case <=# [x_sfPdL 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfPdY [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfPdG eta_sfPdJ] \r [a1_sfPdN]
                                        let {
                                          sat_sfPdV [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfPdG eta_sfPdJ] \r [a2_sfPdO]
                                                  let {
                                                    sat_sfPdU [Occ=Once]
                                                      :: a_afxGF
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfPdJ] \r [a3_sfPdP]
                                                            let {
                                                              sat_sfPdR [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfPdJ a3_sfPdP] \r [a4_sfPdQ]
                                                                      eta_sfPdJ a3_sfPdP;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfPdR
                                                              of
                                                              { Unit# ww1_sfPdT [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfPdT];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadMax2
                                                        ds_sfPdG
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfPdU;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfPdV
                                          of
                                          { Unit# ww1_sfPdX [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfPdX];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Semigroup.$fReadMax_lexeme sat_sfPdY
                                of
                                { Unit# ww1_sfPe0 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfPe0];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfPe1;

Data.Semigroup.$fReadMax_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Max a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPe2]
        let {
          ds_sfPe3 [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Max a_Xfy4P -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfPe2] \u [] Data.Semigroup.$fReadMax1 $dRead_sfPe2; } in
        let {
          sat_sfPe6 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Max a_Xfy4P)
          [LclId] =
              [ds_sfPe3] \r [n_sfPe4]
                  let {
                    sat_sfPe5 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Max a_Xfy4P)
                    [LclId] =
                        [ds_sfPe3 n_sfPe4] \u []
                            ds_sfPe3
                                n_sfPe4 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfPe5;
        } in  sat_sfPe6;

Data.Semigroup.$fReadMax_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Max a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPe7]
        let {
          sat_sfPe8 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Max a_Xfy4N)
          [LclId] =
              [$dRead_sfPe7] \s [] Data.Semigroup.$fReadMax1 $dRead_sfPe7;
        } in  GHC.Read.list sat_sfPe8;

Data.Semigroup.$fReadMax_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Max a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPe9]
        let {
          sat_sfPeb [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Max a_Xfy4O]
          [LclId] =
              [$dRead_sfPe9] \u []
                  let {
                    sat_sfPea [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Max a_Xfy4O)
                    [LclId] =
                        [$dRead_sfPe9] \s [] Data.Semigroup.$fReadMax1 $dRead_sfPe9;
                  } in 
                    GHC.Read.list
                        sat_sfPea
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfPeb;

Data.Semigroup.$fReadMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfPec]
        let {
          sat_sfPeg [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Max a_Xfy4M]
          [LclId] =
              [$dRead_sfPec] \u []
                  Data.Semigroup.$fReadMax_$creadListPrec $dRead_sfPec; } in
        let {
          sat_sfPef [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Max a_Xfy4M)
          [LclId] =
              [$dRead_sfPec] \u [] Data.Semigroup.$fReadMax1 $dRead_sfPec; } in
        let {
          sat_sfPee [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Max a_Xfy4M]
          [LclId] =
              [$dRead_sfPec] \u []
                  Data.Semigroup.$fReadMax_$creadList $dRead_sfPec; } in
        let {
          sat_sfPed [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Max a_Xfy4M)
          [LclId] =
              [$dRead_sfPec] \u []
                  Data.Semigroup.$fReadMax_$creadsPrec $dRead_sfPec;
        } in  GHC.Read.C:Read [sat_sfPed sat_sfPee sat_sfPef sat_sfPeg];

Data.Semigroup.$fShowMax2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Max {"#;

Data.Semigroup.$fShowMax1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMax = "#;

Data.Semigroup.$w$cshowsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Max a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPeh ww_sfPei w1_sfPej]
        let {
          f_sfPek [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfPeh w1_sfPej] \u []
                  GHC.Show.showsPrec
                      w_sfPeh Data.Semigroup.$fFoldableOption7 w1_sfPej;
        } in 
          case >=# [ww_sfPei 11#] of {
            __DEFAULT ->
                let {
                  sat_sfPeq [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPek] \r [x_sfPem]
                          let {
                            sat_sfPep [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPek x_sfPem] \u []
                                    let {
                                      sat_sfPeo [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPek x_sfPem] \u []
                                              let {
                                                sat_sfPen [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfPem] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfPem;
                                              } in  f_sfPek sat_sfPen;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMax1 sat_sfPeo;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowMax2 sat_sfPep;
                } in  sat_sfPeq;
            1# ->
                let {
                  sat_sfPex [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPek] \r [x_sfPer]
                          let {
                            sat_sfPew [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPek x_sfPer] \u []
                                    let {
                                      sat_sfPev [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPek x_sfPer] \u []
                                              let {
                                                sat_sfPeu [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfPek x_sfPer] \u []
                                                        let {
                                                          sat_sfPet [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfPer] \u []
                                                                  let {
                                                                    sat_sfPes [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfPer];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfPes;
                                                        } in  f_sfPek sat_sfPet;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowMax1 sat_sfPeu;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMax2 sat_sfPev;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfPew];
                } in  sat_sfPex;
          };

Data.Semigroup.$fShowMax_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Max a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPey w1_sfPez w2_sfPeA]
        case w1_sfPez of {
          GHC.Types.I# ww1_sfPeC [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec3 w_sfPey ww1_sfPeC w2_sfPeA;
        };

Data.Semigroup.$fShowMax_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Max a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPeD x_sfPeE]
        let {
          sat_sfPeG [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfPeD x_sfPeE] \u []
                  let {
                    sat_sfPeF [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfPeD x_sfPeE] \u []
                            GHC.Show.showsPrec
                                $dShow_sfPeD
                                Data.Semigroup.$fFoldableOption7
                                x_sfPeE
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowMax1 sat_sfPeF;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowMax2 sat_sfPeG;

Data.Semigroup.$fShowMax_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Max a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPeH ls_sfPeI s_sfPeJ]
        let {
          sat_sfPeL [Occ=Once]
            :: Data.Semigroup.Max a_afxGa -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPeH] \r [w_sfPeK]
                  Data.Semigroup.$w$cshowsPrec3 $dShow_sfPeH 0# w_sfPeK;
        } in  GHC.Show.showList__ sat_sfPeL ls_sfPeI s_sfPeJ;

Data.Semigroup.$fShowMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfPeM]
        let {
          sat_sfPeP [Occ=Once]
            :: [Data.Semigroup.Max a_afxGa] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPeM] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMax_$cshowList
                      $dShow_sfPeM eta_B2 eta_B1; } in
        let {
          sat_sfPeO [Occ=Once]
            :: Data.Semigroup.Max a_afxGa -> GHC.Base.String
          [LclId] =
              [$dShow_sfPeM] \r [eta_B1]
                  Data.Semigroup.$fShowMax_$cshow $dShow_sfPeM eta_B1; } in
        let {
          sat_sfPeN [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Max a_afxGa -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPeM] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMax_$cshowsPrec $dShow_sfPeM eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfPeN sat_sfPeO sat_sfPeP];

Data.Semigroup.$fEqMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfPeQ]
        let {
          sat_sfPeS [Occ=Once]
            :: Data.Semigroup.Max a_afxDN
               -> Data.Semigroup.Max a_afxDN -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfPeQ] \u [] GHC.Classes./= $dEq_sfPeQ; } in
        let {
          sat_sfPeR [Occ=Once]
            :: Data.Semigroup.Max a_afxDN
               -> Data.Semigroup.Max a_afxDN -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfPeQ] \u [] GHC.Classes.== $dEq_sfPeQ;
        } in  GHC.Classes.C:Eq [sat_sfPeR sat_sfPeS];

Data.Semigroup.$fOrdMax_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Max a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfPeT]
        let {
          sat_sfPeU [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afxEl
          [LclId] =
              [$dOrd_sfPeT] \u [] GHC.Classes.$p1Ord $dOrd_sfPeT;
        } in  Data.Semigroup.$fEqMax sat_sfPeU;

Data.Semigroup.$fOrdMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfPeV]
        let {
          sat_sfPf3 [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> Data.Semigroup.Max a_afxEl
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.min $dOrd_sfPeV; } in
        let {
          sat_sfPf2 [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> Data.Semigroup.Max a_afxEl
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.max $dOrd_sfPeV; } in
        let {
          sat_sfPf1 [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.>= $dOrd_sfPeV; } in
        let {
          sat_sfPf0 [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.> $dOrd_sfPeV; } in
        let {
          sat_sfPeZ [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.<= $dOrd_sfPeV; } in
        let {
          sat_sfPeY [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.< $dOrd_sfPeV; } in
        let {
          sat_sfPeX [Occ=Once]
            :: Data.Semigroup.Max a_afxEl
               -> Data.Semigroup.Max a_afxEl -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfPeV] \u [] GHC.Classes.compare $dOrd_sfPeV; } in
        let {
          sat_sfPeW [Occ=Once] :: GHC.Classes.Eq (Data.Semigroup.Max a_afxEl)
          [LclId] =
              [$dOrd_sfPeV] \u [] Data.Semigroup.$fOrdMax_$cp1Ord $dOrd_sfPeV;
        } in 
          GHC.Classes.C:Ord [sat_sfPeW
                             sat_sfPeX
                             sat_sfPeY
                             sat_sfPeZ
                             sat_sfPf0
                             sat_sfPf1
                             sat_sfPf2
                             sat_sfPf3];

Data.Semigroup.$fBoundedMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Max a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfPf4]
        let {
          sat_sfPf6 [Occ=Once] :: Data.Semigroup.Max a_afxDv
          [LclId] =
              [$dBounded_sfPf4] \u [] GHC.Enum.maxBound $dBounded_sfPf4; } in
        let {
          sat_sfPf5 [Occ=Once] :: Data.Semigroup.Max a_afxDv
          [LclId] =
              [$dBounded_sfPf4] \u [] GHC.Enum.minBound $dBounded_sfPf4;
        } in  GHC.Enum.C:Bounded [sat_sfPf5 sat_sfPf6];

Data.Semigroup.$fMonoidMax_$cmconcat
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     [Data.Semigroup.Max a] -> Data.Semigroup.Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><L,1*U(1*U,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfPf7 $dBounded_sfPf8 eta_sfPf9]
        let {
          z_sfPfa [Occ=OnceL] :: a_XfzuM
          [LclId] =
              [$dBounded_sfPf8] \u [] GHC.Enum.minBound $dBounded_sfPf8; } in
        let {
          go_sfPfb [Occ=LoopBreaker]
            :: [Data.Semigroup.Max a_XfzuM] -> Data.Semigroup.Max a_XfzuM
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_sfPf7 z_sfPfa go_sfPfb] \r [ds_sfPfc]
                  case ds_sfPfc of {
                    [] -> z_sfPfa;
                    : y_sfPfe [Occ=Once] ys_sfPff [Occ=Once] ->
                        let {
                          sat_sfPfg [Occ=Once] :: a_XfzuM
                          [LclId] =
                              [go_sfPfb ys_sfPff] \u [] go_sfPfb ys_sfPff;
                        } in  GHC.Classes.max $dOrd_sfPf7 y_sfPfe sat_sfPfg;
                  };
        } in  go_sfPfb eta_sfPf9;

Data.Semigroup.$fMonoidMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     GHC.Base.Monoid (Data.Semigroup.Max a)
[GblId[DFunId], Arity=2, Str=<L,U(A,A,A,A,A,A,U,A)><L,U(U,A)>m] =
    [] \r [$dOrd_sfPfh $dBounded_sfPfi]
        let {
          sat_sfPfm [Occ=Once]
            :: [Data.Semigroup.Max a_XfzuG] -> Data.Semigroup.Max a_XfzuG
          [LclId] =
              [$dOrd_sfPfh $dBounded_sfPfi] \r [eta_B1]
                  Data.Semigroup.$fMonoidMax_$cmconcat
                      $dOrd_sfPfh $dBounded_sfPfi eta_B1; } in
        let {
          sat_sfPfl [Occ=Once]
            :: Data.Semigroup.Max a_XfzuG
               -> Data.Semigroup.Max a_XfzuG -> Data.Semigroup.Max a_XfzuG
          [LclId] =
              [$dOrd_sfPfh] \u [] GHC.Classes.max $dOrd_sfPfh; } in
        let {
          sat_sfPfk [Occ=Once] :: Data.Semigroup.Max a_XfzuG
          [LclId] =
              [$dBounded_sfPfi] \u [] GHC.Enum.minBound $dBounded_sfPfi; } in
        let {
          sat_sfPfj [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Max a_XfzuG)
          [LclId] =
              [$dOrd_sfPfh] \u [] Data.Semigroup.$fSemigroupMax $dOrd_sfPfh;
        } in  GHC.Base.C:Monoid [sat_sfPfj sat_sfPfk sat_sfPfl sat_sfPfm];

Data.Semigroup.$fGeneric1Min1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Min a
     -> GHC.Generics.Rep1 Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfPfn] ds_sfPfn;

Data.Semigroup.$fGeneric1Min2
  :: forall a. Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_sfPfo] x_sfPfo;

Data.Semigroup.$fGeneric1Min [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Min
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.$fGeneric1Min2
                                            Data.Semigroup.$fGeneric1Min1];

Data.Semigroup.$fGenericMin1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Min a) x
     -> GHC.Generics.Rep (Data.Semigroup.Min a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfPfp] ds_sfPfp;

Data.Semigroup.$fGenericMin2
  :: forall a x. Data.Semigroup.Min a -> Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_sfPfq] x1_sfPfq;

Data.Semigroup.$fGenericMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Min a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.$fGenericMin2
                                           Data.Semigroup.$fGenericMin1];

Data.Semigroup.$fDataMin_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Semigroup.Min a
     -> c (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPfr k_sfPfs z_sfPft ds_sfPfu]
        let {
          sat_sfPfv [Occ=Once]
            :: c_afxyB (a_afxys -> Data.Semigroup.Min a_afxys)
          [LclId] =
              [z_sfPft] \u [] z_sfPft Data.Semigroup.$fApplicativeFirst3;
        } in  k_sfPfs $dData_sfPfr sat_sfPfv ds_sfPfu;

Data.Semigroup.$fDataMin4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Min"#;

Data.Semigroup.$fDataMin7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fDataMin4;

Data.Semigroup.$fReadMin_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.$fDataMin7];

Data.Semigroup.$fReadMin3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMin"#;

Data.Semigroup.$fReadMin2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Semigroup.$fReadMin3;

Data.Semigroup.$fReadMin1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Min a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPfw]
        let {
          lvl33_sfPfx [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_afxxD
          [LclId] =
              [$dRead_sfPfw] \u []
                  GHC.Read.readPrec
                      $dRead_sfPfw Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_sfPfy [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_afxxD
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl33_sfPfx] \r [ds1_sfPfz] lvl33_sfPfx; } in
        let {
          sat_sfPfT [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Min a_afxxD)
          [LclId] =
              [ds_sfPfy] \r [c_sfPfA eta_sfPfB]
                  case c_sfPfA of {
                    GHC.Types.I# x_sfPfD [Occ=Once] ->
                        case <=# [x_sfPfD 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sfPfQ [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                [LclId] =
                                    [ds_sfPfy eta_sfPfB] \r [a1_sfPfF]
                                        let {
                                          sat_sfPfN [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i815E
                                          [LclId] =
                                              [ds_sfPfy eta_sfPfB] \r [a2_sfPfG]
                                                  let {
                                                    sat_sfPfM [Occ=Once]
                                                      :: a_afxxD
                                                         -> Text.ParserCombinators.ReadP.P b_i815E
                                                    [LclId] =
                                                        [eta_sfPfB] \r [a3_sfPfH]
                                                            let {
                                                              sat_sfPfJ [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i815E
                                                              [LclId] =
                                                                  [eta_sfPfB a3_sfPfH] \r [a4_sfPfI]
                                                                      eta_sfPfB a3_sfPfH;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.$fReadFirst2
                                                                      sat_sfPfJ
                                                              of
                                                              { Unit# ww1_sfPfL [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_sfPfL];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.$fReadMin2
                                                        ds_sfPfy
                                                        Data.Semigroup.$fReadArg2
                                                        sat_sfPfM;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.$fReadFirst_lexeme sat_sfPfN
                                          of
                                          { Unit# ww1_sfPfP [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sfPfP];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Semigroup.$fReadMin_lexeme sat_sfPfQ
                                of
                                { Unit# ww1_sfPfS [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_sfPfS];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_sfPfT;

Data.Semigroup.$fReadMin_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Min a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPfU]
        let {
          ds_sfPfV [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Min a_XfxWM -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_sfPfU] \u [] Data.Semigroup.$fReadMin1 $dRead_sfPfU; } in
        let {
          sat_sfPfY [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Min a_XfxWM)
          [LclId] =
              [ds_sfPfV] \r [n_sfPfW]
                  let {
                    sat_sfPfX [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Semigroup.Min a_XfxWM)
                    [LclId] =
                        [ds_sfPfV n_sfPfW] \u []
                            ds_sfPfV
                                n_sfPfW Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sfPfX;
        } in  sat_sfPfY;

Data.Semigroup.$fReadMin_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Semigroup.Min a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPfZ]
        let {
          sat_sfPg0 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Min a_XfxWK)
          [LclId] =
              [$dRead_sfPfZ] \s [] Data.Semigroup.$fReadMin1 $dRead_sfPfZ;
        } in  GHC.Read.list sat_sfPg0;

Data.Semigroup.$fReadMin_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Min a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sfPg1]
        let {
          sat_sfPg3 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Min a_XfxWL]
          [LclId] =
              [$dRead_sfPg1] \u []
                  let {
                    sat_sfPg2 [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Min a_XfxWL)
                    [LclId] =
                        [$dRead_sfPg1] \s [] Data.Semigroup.$fReadMin1 $dRead_sfPg1;
                  } in 
                    GHC.Read.list
                        sat_sfPg2
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sfPg3;

Data.Semigroup.$fReadMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_sfPg4]
        let {
          sat_sfPg8 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Min a_XfxWJ]
          [LclId] =
              [$dRead_sfPg4] \u []
                  Data.Semigroup.$fReadMin_$creadListPrec $dRead_sfPg4; } in
        let {
          sat_sfPg7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Min a_XfxWJ)
          [LclId] =
              [$dRead_sfPg4] \u [] Data.Semigroup.$fReadMin1 $dRead_sfPg4; } in
        let {
          sat_sfPg6 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Min a_XfxWJ]
          [LclId] =
              [$dRead_sfPg4] \u []
                  Data.Semigroup.$fReadMin_$creadList $dRead_sfPg4; } in
        let {
          sat_sfPg5 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Semigroup.Min a_XfxWJ)
          [LclId] =
              [$dRead_sfPg4] \u []
                  Data.Semigroup.$fReadMin_$creadsPrec $dRead_sfPg4;
        } in  GHC.Read.C:Read [sat_sfPg5 sat_sfPg6 sat_sfPg7 sat_sfPg8];

Data.Semigroup.$fShowMin2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Min {"#;

Data.Semigroup.$fShowMin1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getMin = "#;

Data.Semigroup.$w$cshowsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Min a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPg9 ww_sfPga w1_sfPgb]
        let {
          f_sfPgc [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sfPg9 w1_sfPgb] \u []
                  GHC.Show.showsPrec
                      w_sfPg9 Data.Semigroup.$fFoldableOption7 w1_sfPgb;
        } in 
          case >=# [ww_sfPga 11#] of {
            __DEFAULT ->
                let {
                  sat_sfPgi [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPgc] \r [x_sfPge]
                          let {
                            sat_sfPgh [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPgc x_sfPge] \u []
                                    let {
                                      sat_sfPgg [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPgc x_sfPge] \u []
                                              let {
                                                sat_sfPgf [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_sfPge] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.$fReadFirst4 x_sfPge;
                                              } in  f_sfPgc sat_sfPgf;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMin1 sat_sfPgg;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.$fShowMin2 sat_sfPgh;
                } in  sat_sfPgi;
            1# ->
                let {
                  sat_sfPgp [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sfPgc] \r [x_sfPgj]
                          let {
                            sat_sfPgo [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sfPgc x_sfPgj] \u []
                                    let {
                                      sat_sfPgn [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_sfPgc x_sfPgj] \u []
                                              let {
                                                sat_sfPgm [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_sfPgc x_sfPgj] \u []
                                                        let {
                                                          sat_sfPgl [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_sfPgj] \u []
                                                                  let {
                                                                    sat_sfPgk [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_sfPgj];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.$fReadFirst4
                                                                        sat_sfPgk;
                                                        } in  f_sfPgc sat_sfPgl;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.$fShowMin1 sat_sfPgm;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.$fShowMin2 sat_sfPgn;
                          } in  : [GHC.Show.$fShow(,)4 sat_sfPgo];
                } in  sat_sfPgp;
          };

Data.Semigroup.$fShowMin_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Min a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPgq w1_sfPgr w2_sfPgs]
        case w1_sfPgr of {
          GHC.Types.I# ww1_sfPgu [Occ=Once] ->
              Data.Semigroup.$w$cshowsPrec4 w_sfPgq ww1_sfPgu w2_sfPgs;
        };

Data.Semigroup.$fShowMin_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Min a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPgv x_sfPgw]
        let {
          sat_sfPgy [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_sfPgv x_sfPgw] \u []
                  let {
                    sat_sfPgx [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_sfPgv x_sfPgw] \u []
                            GHC.Show.showsPrec
                                $dShow_sfPgv
                                Data.Semigroup.$fFoldableOption7
                                x_sfPgw
                                Data.Semigroup.$fReadFirst3;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.$fShowMin1 sat_sfPgx;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowMin2 sat_sfPgy;

Data.Semigroup.$fShowMin_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Min a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sfPgz ls_sfPgA s_sfPgB]
        let {
          sat_sfPgD [Occ=Once]
            :: Data.Semigroup.Min a_afxx8 -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPgz] \r [w_sfPgC]
                  Data.Semigroup.$w$cshowsPrec4 $dShow_sfPgz 0# w_sfPgC;
        } in  GHC.Show.showList__ sat_sfPgD ls_sfPgA s_sfPgB;

Data.Semigroup.$fShowMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sfPgE]
        let {
          sat_sfPgH [Occ=Once]
            :: [Data.Semigroup.Min a_afxx8] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPgE] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMin_$cshowList
                      $dShow_sfPgE eta_B2 eta_B1; } in
        let {
          sat_sfPgG [Occ=Once]
            :: Data.Semigroup.Min a_afxx8 -> GHC.Base.String
          [LclId] =
              [$dShow_sfPgE] \r [eta_B1]
                  Data.Semigroup.$fShowMin_$cshow $dShow_sfPgE eta_B1; } in
        let {
          sat_sfPgF [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Min a_afxx8 -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sfPgE] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fShowMin_$cshowsPrec $dShow_sfPgE eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sfPgF sat_sfPgG sat_sfPgH];

Data.Semigroup.$fEqMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_sfPgI]
        let {
          sat_sfPgK [Occ=Once]
            :: Data.Semigroup.Min a_afxuL
               -> Data.Semigroup.Min a_afxuL -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfPgI] \u [] GHC.Classes./= $dEq_sfPgI; } in
        let {
          sat_sfPgJ [Occ=Once]
            :: Data.Semigroup.Min a_afxuL
               -> Data.Semigroup.Min a_afxuL -> GHC.Types.Bool
          [LclId] =
              [$dEq_sfPgI] \u [] GHC.Classes.== $dEq_sfPgI;
        } in  GHC.Classes.C:Eq [sat_sfPgJ sat_sfPgK];

Data.Semigroup.$fOrdMin_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Min a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfPgL]
        let {
          sat_sfPgM [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_afxvj
          [LclId] =
              [$dOrd_sfPgL] \u [] GHC.Classes.$p1Ord $dOrd_sfPgL;
        } in  Data.Semigroup.$fEqMin sat_sfPgM;

Data.Semigroup.$fOrdMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_sfPgN]
        let {
          sat_sfPgV [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> Data.Semigroup.Min a_afxvj
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.min $dOrd_sfPgN; } in
        let {
          sat_sfPgU [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> Data.Semigroup.Min a_afxvj
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.max $dOrd_sfPgN; } in
        let {
          sat_sfPgT [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.>= $dOrd_sfPgN; } in
        let {
          sat_sfPgS [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.> $dOrd_sfPgN; } in
        let {
          sat_sfPgR [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.<= $dOrd_sfPgN; } in
        let {
          sat_sfPgQ [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.< $dOrd_sfPgN; } in
        let {
          sat_sfPgP [Occ=Once]
            :: Data.Semigroup.Min a_afxvj
               -> Data.Semigroup.Min a_afxvj -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfPgN] \u [] GHC.Classes.compare $dOrd_sfPgN; } in
        let {
          sat_sfPgO [Occ=Once] :: GHC.Classes.Eq (Data.Semigroup.Min a_afxvj)
          [LclId] =
              [$dOrd_sfPgN] \u [] Data.Semigroup.$fOrdMin_$cp1Ord $dOrd_sfPgN;
        } in 
          GHC.Classes.C:Ord [sat_sfPgO
                             sat_sfPgP
                             sat_sfPgQ
                             sat_sfPgR
                             sat_sfPgS
                             sat_sfPgT
                             sat_sfPgU
                             sat_sfPgV];

Data.Semigroup.$fBoundedMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Min a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_sfPgW]
        let {
          sat_sfPgY [Occ=Once] :: Data.Semigroup.Min a_afxut
          [LclId] =
              [$dBounded_sfPgW] \u [] GHC.Enum.maxBound $dBounded_sfPgW; } in
        let {
          sat_sfPgX [Occ=Once] :: Data.Semigroup.Min a_afxut
          [LclId] =
              [$dBounded_sfPgW] \u [] GHC.Enum.minBound $dBounded_sfPgW;
        } in  GHC.Enum.C:Bounded [sat_sfPgX sat_sfPgY];

Data.Semigroup.$fMonoidMin_$cmconcat
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     [Data.Semigroup.Min a] -> Data.Semigroup.Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><L,1*U(A,1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfPgZ $dBounded_sfPh0 eta_sfPh1]
        let {
          z_sfPh2 [Occ=OnceL] :: a_XfzEk
          [LclId] =
              [$dBounded_sfPh0] \u [] GHC.Enum.maxBound $dBounded_sfPh0; } in
        let {
          go_sfPh3 [Occ=LoopBreaker]
            :: [Data.Semigroup.Min a_XfzEk] -> Data.Semigroup.Min a_XfzEk
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dOrd_sfPgZ z_sfPh2 go_sfPh3] \r [ds_sfPh4]
                  case ds_sfPh4 of {
                    [] -> z_sfPh2;
                    : y_sfPh6 [Occ=Once] ys_sfPh7 [Occ=Once] ->
                        let {
                          sat_sfPh8 [Occ=Once] :: a_XfzEk
                          [LclId] =
                              [go_sfPh3 ys_sfPh7] \u [] go_sfPh3 ys_sfPh7;
                        } in  GHC.Classes.min $dOrd_sfPgZ y_sfPh6 sat_sfPh8;
                  };
        } in  go_sfPh3 eta_sfPh1;

Data.Semigroup.$fMonoidMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     (GHC.Classes.Ord a, GHC.Enum.Bounded a) =>
     GHC.Base.Monoid (Data.Semigroup.Min a)
[GblId[DFunId], Arity=2, Str=<L,U(A,A,A,A,A,A,A,U)><L,U(A,U)>m] =
    [] \r [$dOrd_sfPh9 $dBounded_sfPha]
        let {
          sat_sfPhe [Occ=Once]
            :: [Data.Semigroup.Min a_XfzEe] -> Data.Semigroup.Min a_XfzEe
          [LclId] =
              [$dOrd_sfPh9 $dBounded_sfPha] \r [eta_B1]
                  Data.Semigroup.$fMonoidMin_$cmconcat
                      $dOrd_sfPh9 $dBounded_sfPha eta_B1; } in
        let {
          sat_sfPhd [Occ=Once]
            :: Data.Semigroup.Min a_XfzEe
               -> Data.Semigroup.Min a_XfzEe -> Data.Semigroup.Min a_XfzEe
          [LclId] =
              [$dOrd_sfPh9] \u [] GHC.Classes.min $dOrd_sfPh9; } in
        let {
          sat_sfPhc [Occ=Once] :: Data.Semigroup.Min a_XfzEe
          [LclId] =
              [$dBounded_sfPha] \u [] GHC.Enum.maxBound $dBounded_sfPha; } in
        let {
          sat_sfPhb [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Min a_XfzEe)
          [LclId] =
              [$dOrd_sfPh9] \u [] Data.Semigroup.$fSemigroupMin $dOrd_sfPh9;
        } in  GHC.Base.C:Monoid [sat_sfPhb sat_sfPhc sat_sfPhd sat_sfPhe];

Data.Semigroup.getMin :: forall a. Data.Semigroup.Min a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Min2 eta_B1;

Data.Semigroup.$fMonadFixMin_$cmfix
  :: forall a. (a -> Data.Semigroup.Min a) -> Data.Semigroup.Min a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfPhf]
        let {
          x_sfPhg [Occ=LoopBreaker] :: Data.Semigroup.Min a_afz9s
          [LclId] =
              [f_sfPhf x_sfPhg] \u [] f_sfPhf x_sfPhg;
        } in  x_sfPhg;

Data.Semigroup.$fMonadFixMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Min
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadMin
                                                 Data.Semigroup.$fMonadFixMin_$cmfix];

Data.Semigroup.$fEnumMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfPhh]
        let {
          sat_sfPhB [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs
               -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfPhh] \r [ds_sfPhy ds1_sfPhz ds2_sfPhA]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfPhh ds_sfPhy ds1_sfPhz ds2_sfPhA; } in
        let {
          sat_sfPhx [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfPhh] \r [ds_sfPhv ds1_sfPhw]
                  GHC.Enum.enumFromTo $dEnum_sfPhh ds_sfPhv ds1_sfPhw; } in
        let {
          sat_sfPhu [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs
               -> Data.Semigroup.Min a_XfzFs -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfPhh] \r [ds_sfPhs ds1_sfPht]
                  GHC.Enum.enumFromThen $dEnum_sfPhh ds_sfPhs ds1_sfPht; } in
        let {
          sat_sfPhr [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs -> [Data.Semigroup.Min a_XfzFs]
          [LclId] =
              [$dEnum_sfPhh] \r [ds_sfPhq]
                  GHC.Enum.enumFrom $dEnum_sfPhh ds_sfPhq; } in
        let {
          sat_sfPhp [Occ=Once] :: Data.Semigroup.Min a_XfzFs -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfPhh] \r [eta_sfPho]
                  GHC.Enum.fromEnum $dEnum_sfPhh eta_sfPho; } in
        let {
          sat_sfPhn [Occ=Once] :: GHC.Types.Int -> Data.Semigroup.Min a_XfzFs
          [LclId] =
              [$dEnum_sfPhh] \r [eta_sfPhm]
                  GHC.Enum.toEnum $dEnum_sfPhh eta_sfPhm; } in
        let {
          sat_sfPhl [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs -> Data.Semigroup.Min a_XfzFs
          [LclId] =
              [$dEnum_sfPhh] \r [ds_sfPhk]
                  GHC.Enum.pred $dEnum_sfPhh ds_sfPhk; } in
        let {
          sat_sfPhj [Occ=Once]
            :: Data.Semigroup.Min a_XfzFs -> Data.Semigroup.Min a_XfzFs
          [LclId] =
              [$dEnum_sfPhh] \r [ds_sfPhi] GHC.Enum.succ $dEnum_sfPhh ds_sfPhi;
        } in 
          GHC.Enum.C:Enum [sat_sfPhj
                           sat_sfPhl
                           sat_sfPhn
                           sat_sfPhp
                           sat_sfPhr
                           sat_sfPhu
                           sat_sfPhx
                           sat_sfPhB];

Data.Semigroup.getMax :: forall a. Data.Semigroup.Max a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Max2 eta_B1;

Data.Semigroup.$fMonadFixMax_$cmfix
  :: forall a. (a -> Data.Semigroup.Max a) -> Data.Semigroup.Max a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfPhC]
        let {
          x_sfPhD [Occ=LoopBreaker] :: Data.Semigroup.Max a_afz0T
          [LclId] =
              [f_sfPhC x_sfPhD] \u [] f_sfPhC x_sfPhD;
        } in  x_sfPhD;

Data.Semigroup.$fMonadFixMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Max
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadMax
                                                 Data.Semigroup.$fMonadFixMax_$cmfix];

Data.Semigroup.$fEnumMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfPhE]
        let {
          sat_sfPhY [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1
               -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfPhE] \r [ds_sfPhV ds1_sfPhW ds2_sfPhX]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfPhE ds_sfPhV ds1_sfPhW ds2_sfPhX; } in
        let {
          sat_sfPhU [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1 -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfPhE] \r [ds_sfPhS ds1_sfPhT]
                  GHC.Enum.enumFromTo $dEnum_sfPhE ds_sfPhS ds1_sfPhT; } in
        let {
          sat_sfPhR [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1
               -> Data.Semigroup.Max a_Xfzx1 -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfPhE] \r [ds_sfPhP ds1_sfPhQ]
                  GHC.Enum.enumFromThen $dEnum_sfPhE ds_sfPhP ds1_sfPhQ; } in
        let {
          sat_sfPhO [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1 -> [Data.Semigroup.Max a_Xfzx1]
          [LclId] =
              [$dEnum_sfPhE] \r [ds_sfPhN]
                  GHC.Enum.enumFrom $dEnum_sfPhE ds_sfPhN; } in
        let {
          sat_sfPhM [Occ=Once] :: Data.Semigroup.Max a_Xfzx1 -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfPhE] \r [eta_sfPhL]
                  GHC.Enum.fromEnum $dEnum_sfPhE eta_sfPhL; } in
        let {
          sat_sfPhK [Occ=Once] :: GHC.Types.Int -> Data.Semigroup.Max a_Xfzx1
          [LclId] =
              [$dEnum_sfPhE] \r [eta_sfPhJ]
                  GHC.Enum.toEnum $dEnum_sfPhE eta_sfPhJ; } in
        let {
          sat_sfPhI [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1 -> Data.Semigroup.Max a_Xfzx1
          [LclId] =
              [$dEnum_sfPhE] \r [ds_sfPhH]
                  GHC.Enum.pred $dEnum_sfPhE ds_sfPhH; } in
        let {
          sat_sfPhG [Occ=Once]
            :: Data.Semigroup.Max a_Xfzx1 -> Data.Semigroup.Max a_Xfzx1
          [LclId] =
              [$dEnum_sfPhE] \r [ds_sfPhF] GHC.Enum.succ $dEnum_sfPhE ds_sfPhF;
        } in 
          GHC.Enum.C:Enum [sat_sfPhG
                           sat_sfPhI
                           sat_sfPhK
                           sat_sfPhM
                           sat_sfPhO
                           sat_sfPhR
                           sat_sfPhU
                           sat_sfPhY];

Data.Semigroup.getFirst :: forall a. Data.Semigroup.First a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1First2 eta_B1;

Data.Semigroup.$fMonadFixFirst_$cmfix
  :: forall a.
     (a -> Data.Semigroup.First a) -> Data.Semigroup.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfPhZ]
        let {
          x_sfPi0 [Occ=LoopBreaker] :: Data.Semigroup.First a_afyMj
          [LclId] =
              [f_sfPhZ x_sfPi0] \u [] f_sfPhZ x_sfPi0;
        } in  x_sfPi0;

Data.Semigroup.$fMonadFixFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadFirst
                                                 Data.Semigroup.$fMonadFixFirst_$cmfix];

Data.Semigroup.$fEnumFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfPi1]
        let {
          sat_sfPil [Occ=Once]
            :: Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV
               -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfPi1] \r [ds_sfPii ds1_sfPij ds2_sfPik]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfPi1 ds_sfPii ds1_sfPij ds2_sfPik; } in
        let {
          sat_sfPih [Occ=Once]
            :: Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfPi1] \r [ds_sfPif ds1_sfPig]
                  GHC.Enum.enumFromTo $dEnum_sfPi1 ds_sfPif ds1_sfPig; } in
        let {
          sat_sfPie [Occ=Once]
            :: Data.Semigroup.First a_XfzhV
               -> Data.Semigroup.First a_XfzhV -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfPi1] \r [ds_sfPic ds1_sfPid]
                  GHC.Enum.enumFromThen $dEnum_sfPi1 ds_sfPic ds1_sfPid; } in
        let {
          sat_sfPib [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> [Data.Semigroup.First a_XfzhV]
          [LclId] =
              [$dEnum_sfPi1] \r [ds_sfPia]
                  GHC.Enum.enumFrom $dEnum_sfPi1 ds_sfPia; } in
        let {
          sat_sfPi9 [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfPi1] \r [eta_sfPi8]
                  GHC.Enum.fromEnum $dEnum_sfPi1 eta_sfPi8; } in
        let {
          sat_sfPi7 [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.First a_XfzhV
          [LclId] =
              [$dEnum_sfPi1] \r [eta_sfPi6]
                  GHC.Enum.toEnum $dEnum_sfPi1 eta_sfPi6; } in
        let {
          sat_sfPi5 [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> Data.Semigroup.First a_XfzhV
          [LclId] =
              [$dEnum_sfPi1] \r [ds_sfPi4]
                  GHC.Enum.pred $dEnum_sfPi1 ds_sfPi4; } in
        let {
          sat_sfPi3 [Occ=Once]
            :: Data.Semigroup.First a_XfzhV -> Data.Semigroup.First a_XfzhV
          [LclId] =
              [$dEnum_sfPi1] \r [ds_sfPi2] GHC.Enum.succ $dEnum_sfPi1 ds_sfPi2;
        } in 
          GHC.Enum.C:Enum [sat_sfPi3
                           sat_sfPi5
                           sat_sfPi7
                           sat_sfPi9
                           sat_sfPib
                           sat_sfPie
                           sat_sfPih
                           sat_sfPil];

Data.Semigroup.getLast :: forall a. Data.Semigroup.Last a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Last2 eta_B1;

Data.Semigroup.$fMonadFixLast_$cmfix
  :: forall a. (a -> Data.Semigroup.Last a) -> Data.Semigroup.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfPim]
        let {
          x_sfPin [Occ=LoopBreaker] :: Data.Semigroup.Last a_afyFi
          [LclId] =
              [f_sfPim x_sfPin] \u [] f_sfPim x_sfPin;
        } in  x_sfPin;

Data.Semigroup.$fMonadFixLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadLast
                                                 Data.Semigroup.$fMonadFixLast_$cmfix];

Data.Semigroup.$fEnumLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfPio]
        let {
          sat_sfPiI [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2
               -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfPio] \r [ds_sfPiF ds1_sfPiG ds2_sfPiH]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfPio ds_sfPiF ds1_sfPiG ds2_sfPiH; } in
        let {
          sat_sfPiE [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2 -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfPio] \r [ds_sfPiC ds1_sfPiD]
                  GHC.Enum.enumFromTo $dEnum_sfPio ds_sfPiC ds1_sfPiD; } in
        let {
          sat_sfPiB [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2
               -> Data.Semigroup.Last a_Xfzb2 -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfPio] \r [ds_sfPiz ds1_sfPiA]
                  GHC.Enum.enumFromThen $dEnum_sfPio ds_sfPiz ds1_sfPiA; } in
        let {
          sat_sfPiy [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> [Data.Semigroup.Last a_Xfzb2]
          [LclId] =
              [$dEnum_sfPio] \r [ds_sfPix]
                  GHC.Enum.enumFrom $dEnum_sfPio ds_sfPix; } in
        let {
          sat_sfPiw [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfPio] \r [eta_sfPiv]
                  GHC.Enum.fromEnum $dEnum_sfPio eta_sfPiv; } in
        let {
          sat_sfPiu [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Last a_Xfzb2
          [LclId] =
              [$dEnum_sfPio] \r [eta_sfPit]
                  GHC.Enum.toEnum $dEnum_sfPio eta_sfPit; } in
        let {
          sat_sfPis [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> Data.Semigroup.Last a_Xfzb2
          [LclId] =
              [$dEnum_sfPio] \r [ds_sfPir]
                  GHC.Enum.pred $dEnum_sfPio ds_sfPir; } in
        let {
          sat_sfPiq [Occ=Once]
            :: Data.Semigroup.Last a_Xfzb2 -> Data.Semigroup.Last a_Xfzb2
          [LclId] =
              [$dEnum_sfPio] \r [ds_sfPip] GHC.Enum.succ $dEnum_sfPio ds_sfPip;
        } in 
          GHC.Enum.C:Enum [sat_sfPiq
                           sat_sfPis
                           sat_sfPiu
                           sat_sfPiw
                           sat_sfPiy
                           sat_sfPiB
                           sat_sfPiE
                           sat_sfPiI];

Data.Semigroup.unwrapMonoid
  :: forall m. Data.Semigroup.WrappedMonoid m -> m
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1WrappedMonoid2 eta_B1;

Data.Semigroup.$fEnumWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Enum a =>
     GHC.Enum.Enum (Data.Semigroup.WrappedMonoid a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m] =
    [] \r [$dEnum_sfPiJ]
        let {
          sat_sfPj3 [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfPiJ] \r [ds_sfPj0 ds1_sfPj1 ds2_sfPj2]
                  GHC.Enum.enumFromThenTo
                      $dEnum_sfPiJ ds_sfPj0 ds1_sfPj1 ds2_sfPj2; } in
        let {
          sat_sfPiZ [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfPiJ] \r [ds_sfPiX ds1_sfPiY]
                  GHC.Enum.enumFromTo $dEnum_sfPiJ ds_sfPiX ds1_sfPiY; } in
        let {
          sat_sfPiW [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfPiJ] \r [ds_sfPiU ds1_sfPiV]
                  GHC.Enum.enumFromThen $dEnum_sfPiJ ds_sfPiU ds1_sfPiV; } in
        let {
          sat_sfPiT [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> [Data.Semigroup.WrappedMonoid a_Xfz37]
          [LclId] =
              [$dEnum_sfPiJ] \r [ds_sfPiS]
                  GHC.Enum.enumFrom $dEnum_sfPiJ ds_sfPiS; } in
        let {
          sat_sfPiR [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37 -> GHC.Types.Int
          [LclId] =
              [$dEnum_sfPiJ] \r [eta_sfPiQ]
                  GHC.Enum.fromEnum $dEnum_sfPiJ eta_sfPiQ; } in
        let {
          sat_sfPiP [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.WrappedMonoid a_Xfz37
          [LclId] =
              [$dEnum_sfPiJ] \r [eta_sfPiO]
                  GHC.Enum.toEnum $dEnum_sfPiJ eta_sfPiO; } in
        let {
          sat_sfPiN [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
          [LclId] =
              [$dEnum_sfPiJ] \r [ds_sfPiM]
                  GHC.Enum.pred $dEnum_sfPiJ ds_sfPiM; } in
        let {
          sat_sfPiL [Occ=Once]
            :: Data.Semigroup.WrappedMonoid a_Xfz37
               -> Data.Semigroup.WrappedMonoid a_Xfz37
          [LclId] =
              [$dEnum_sfPiJ] \r [ds_sfPiK] GHC.Enum.succ $dEnum_sfPiJ ds_sfPiK;
        } in 
          GHC.Enum.C:Enum [sat_sfPiL
                           sat_sfPiN
                           sat_sfPiP
                           sat_sfPiR
                           sat_sfPiT
                           sat_sfPiW
                           sat_sfPiZ
                           sat_sfPj3];

Data.Semigroup.getOption
  :: forall a. Data.Semigroup.Option a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.$fGeneric1Option2 eta_B1;

Data.Semigroup.$fMonadFixOption_$cmfix
  :: forall a.
     (a -> Data.Semigroup.Option a) -> Data.Semigroup.Option a
[GblId, Arity=1, Str=<C(S),C(U)>, Unf=OtherCon []] =
    [] \r [f_sfPj4]
        let {
          a1_sfPj5 [Occ=LoopBreaker] :: Data.Semigroup.Option a_afyzI
          [LclId] =
              [f_sfPj4 a1_sfPj5] \u []
                  let {
                    sat_sfPj8 [Occ=Once] :: a_afyzI
                    [LclId] =
                        [a1_sfPj5] \u []
                            case a1_sfPj5 of {
                              GHC.Base.Nothing -> Control.Monad.Fix.$fMonadFixFirst1;
                              GHC.Base.Just x_sfPj7 [Occ=Once] -> x_sfPj7;
                            };
                  } in  f_sfPj4 sat_sfPj8;
        } in  a1_sfPj5;

Data.Semigroup.$fMonadFixOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Control.Monad.Fix.MonadFix Data.Semigroup.Option
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Control.Monad.Fix.C:MonadFix! [Data.Semigroup.$fMonadOption
                                                 Data.Semigroup.$fMonadFixOption_$cmfix];

Data.Semigroup.cycle1 :: forall m. GHC.Base.Semigroup m => m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),U(C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfPj9 xs_sfPja]
        let {
          xs'_sfPjb [Occ=LoopBreaker] :: m_afxsV
          [LclId] =
              [$dSemigroup_sfPj9 xs_sfPja xs'_sfPjb] \u []
                  GHC.Base.<> $dSemigroup_sfPj9 xs_sfPja xs'_sfPjb;
        } in  xs'_sfPjb;

Data.Semigroup.diff1
  :: forall m. GHC.Base.Semigroup m => m -> m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sfPjc eta_sfPjd]
        GHC.Base.<> $dSemigroup_sfPjc eta_sfPjd;

Data.Semigroup.diff
  :: forall m.
     GHC.Base.Semigroup m =>
     m -> Data.Semigroup.Internal.Endo m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Semigroup.diff1 eta_B2 eta_B1;

Data.Semigroup.mtimesDefault
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Monoid a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(U,U,U,U,U,U,U),U(U(U,U),U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U(A,1*U,U,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfPje $dMonoid_sfPjf eta_sfPjg eta1_sfPjh]
        case
            GHC.Real.$p1Integral $dIntegral_sfPje
        of
        $dReal_sfPji [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_sfPjm [Occ=Once] :: b_afxst
                [LclId] =
                    [$dReal_sfPji] \u []
                        case GHC.Real.$p1Real $dReal_sfPji of sat_sfPjl {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_sfPjl Data.Semigroup.$fSemigroupOption2;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_sfPji of sat_sfPjj {
                  __DEFAULT ->
                      case GHC.Classes.$p1Ord sat_sfPjj of sat_sfPjk {
                        __DEFAULT ->
                            case GHC.Classes.== sat_sfPjk eta_sfPjg sat_sfPjm of {
                              GHC.Types.False ->
                                  Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes
                                      $dMonoid_sfPjf $dIntegral_sfPje eta_sfPjg eta1_sfPjh;
                              GHC.Types.True -> GHC.Base.mempty $dMonoid_sfPjf;
                            };
                      };
                };
        };

Data.Semigroup.option
  :: forall b a. b -> (a -> b) -> Data.Semigroup.Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] Data.Maybe.maybe eta_B3 eta_B2 eta_B1;

$cMin1_rfC6i :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadMin2 GHC.Types.[]];

go61_rfC6j
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPjo _ys_sfPjp]
        case ds2_sfPjo of {
          [] -> GHC.List.badHead;
          : ipv_sfPjr [Occ=Once!] ipv1_sfPjs [Occ=Once] ->
              case _ys_sfPjp of {
                [] -> GHC.List.badHead;
                : ipv2_sfPju [Occ=Once] ipv3_sfPjv [Occ=Once] ->
                    case ipv_sfPjr of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPjy [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfPjy Data.Semigroup.$fDataMin7 of {
                            GHC.Types.False -> go61_rfC6j ipv1_sfPjs ipv3_sfPjv;
                            GHC.Types.True -> ipv2_sfPju;
                          };
                    };
              };
        };

$cMin2_rfC6k :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cMin3_rfC6l];
Data.Semigroup.$fDataMin6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cMin GHC.Types.[]];
Data.Semigroup.$fDataMin5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataMin6];
Data.Semigroup.$tMin :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataMin7
                                       Data.Semigroup.$fDataMin5];
Data.Semigroup.$cMin [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cMin2_rfC6k
                                     Data.Semigroup.$fDataMin7
                                     $cMin1_rfC6i
                                     Data.Data.Prefix
                                     Data.Semigroup.$tMin];
$cMin3_rfC6l :: Data.Data.ConIndex
[GblId] =
    [] \u [] go61_rfC6j Data.Semigroup.$fDataMin6 Data.Data.mkConstr1;

$cMax1_rfC6m :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadMax2 GHC.Types.[]];

go1_rfC6n
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPjD _ys_sfPjE]
        case ds2_sfPjD of {
          [] -> GHC.List.badHead;
          : ipv_sfPjG [Occ=Once!] ipv1_sfPjH [Occ=Once] ->
              case _ys_sfPjE of {
                [] -> GHC.List.badHead;
                : ipv2_sfPjJ [Occ=Once] ipv3_sfPjK [Occ=Once] ->
                    case ipv_sfPjG of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPjN [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfPjN Data.Semigroup.$fDataMax7 of {
                            GHC.Types.False -> go1_rfC6n ipv1_sfPjH ipv3_sfPjK;
                            GHC.Types.True -> ipv2_sfPjJ;
                          };
                    };
              };
        };

$cMax2_rfC6o :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cMax3_rfC6p];
Data.Semigroup.$fDataMax6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cMax GHC.Types.[]];
Data.Semigroup.$fDataMax5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataMax6];
Data.Semigroup.$tMax :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataMax7
                                       Data.Semigroup.$fDataMax5];
Data.Semigroup.$cMax [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cMax2_rfC6o
                                     Data.Semigroup.$fDataMax7
                                     $cMax1_rfC6m
                                     Data.Data.Prefix
                                     Data.Semigroup.$tMax];
$cMax3_rfC6p :: Data.Data.ConIndex
[GblId] =
    [] \u [] go1_rfC6n Data.Semigroup.$fDataMax6 Data.Data.mkConstr1;

go2_rfC6q
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPjS _ys_sfPjT]
        case ds2_sfPjS of {
          [] -> GHC.List.badHead;
          : ipv_sfPjV [Occ=Once!] ipv1_sfPjW [Occ=Once] ->
              case _ys_sfPjT of {
                [] -> GHC.List.badHead;
                : ipv2_sfPjY [Occ=Once] ipv3_sfPjZ [Occ=Once] ->
                    case ipv_sfPjV of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPk2 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfPk2 Data.Semigroup.$fDataArg9 of {
                            GHC.Types.False -> go2_rfC6q ipv1_sfPjW ipv3_sfPjZ;
                            GHC.Types.True -> ipv2_sfPjY;
                          };
                    };
              };
        };

$cArg1_rfC6r :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cArg2_rfC6s];
Data.Semigroup.$fDataArg8 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cArg GHC.Types.[]];
Data.Semigroup.$fDataArg7 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataArg8];
Data.Semigroup.$tArg :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataArg9
                                       Data.Semigroup.$fDataArg7];
Data.Semigroup.$cArg [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cArg1_rfC6r
                                     Data.Semigroup.$fDataArg9
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Semigroup.$tArg];
$cArg2_rfC6s :: Data.Data.ConIndex
[GblId] =
    [] \u [] go2_rfC6q Data.Semigroup.$fDataArg8 Data.Data.mkConstr1;

$cFirst1_rfC6t :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadFirst5 GHC.Types.[]];

go3_rfC6u
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPk7 _ys_sfPk8]
        case ds2_sfPk7 of {
          [] -> GHC.List.badHead;
          : ipv_sfPka [Occ=Once!] ipv1_sfPkb [Occ=Once] ->
              case _ys_sfPk8 of {
                [] -> GHC.List.badHead;
                : ipv2_sfPkd [Occ=Once] ipv3_sfPke [Occ=Once] ->
                    case ipv_sfPka of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPkh [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfPkh Data.Semigroup.$fDataFirst7 of {
                            GHC.Types.False -> go3_rfC6u ipv1_sfPkb ipv3_sfPke;
                            GHC.Types.True -> ipv2_sfPkd;
                          };
                    };
              };
        };

$cFirst2_rfC6v :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cFirst3_rfC6w];
Data.Semigroup.$fDataFirst6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cFirst GHC.Types.[]];
Data.Semigroup.$fDataFirst5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataFirst6];
Data.Semigroup.$tFirst :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataFirst7
                                       Data.Semigroup.$fDataFirst5];
Data.Semigroup.$cFirst [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cFirst2_rfC6v
                                     Data.Semigroup.$fDataFirst7
                                     $cFirst1_rfC6t
                                     Data.Data.Prefix
                                     Data.Semigroup.$tFirst];
$cFirst3_rfC6w :: Data.Data.ConIndex
[GblId] =
    [] \u [] go3_rfC6u Data.Semigroup.$fDataFirst6 Data.Data.mkConstr1;

$cLast1_rfC6x :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadLast2 GHC.Types.[]];

go4_rfC6y
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPkm _ys_sfPkn]
        case ds2_sfPkm of {
          [] -> GHC.List.badHead;
          : ipv_sfPkp [Occ=Once!] ipv1_sfPkq [Occ=Once] ->
              case _ys_sfPkn of {
                [] -> GHC.List.badHead;
                : ipv2_sfPks [Occ=Once] ipv3_sfPkt [Occ=Once] ->
                    case ipv_sfPkp of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPkw [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfPkw Data.Semigroup.$fDataLast7 of {
                            GHC.Types.False -> go4_rfC6y ipv1_sfPkq ipv3_sfPkt;
                            GHC.Types.True -> ipv2_sfPks;
                          };
                    };
              };
        };

$cLast2_rfC6z :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cLast3_rfC6A];
Data.Semigroup.$fDataLast6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cLast GHC.Types.[]];
Data.Semigroup.$fDataLast5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataLast6];
Data.Semigroup.$tLast :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataLast7
                                       Data.Semigroup.$fDataLast5];
Data.Semigroup.$cLast [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cLast2_rfC6z
                                     Data.Semigroup.$fDataLast7
                                     $cLast1_rfC6x
                                     Data.Data.Prefix
                                     Data.Semigroup.$tLast];
$cLast3_rfC6A :: Data.Data.ConIndex
[GblId] =
    [] \u [] go4_rfC6y Data.Semigroup.$fDataLast6 Data.Data.mkConstr1;

Data.Semigroup.$fDataWrappedMonoid4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "WrappedMonoid"#;

Data.Semigroup.$fDataWrappedMonoid7 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.$fDataWrappedMonoid4;

$cWrapMonoid1_rfC6B :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadWrappedMonoid2
                      GHC.Types.[]];

go5_rfC6C
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPkB _ys_sfPkC]
        case ds2_sfPkB of {
          [] -> GHC.List.badHead;
          : ipv_sfPkE [Occ=Once!] ipv1_sfPkF [Occ=Once] ->
              case _ys_sfPkC of {
                [] -> GHC.List.badHead;
                : ipv2_sfPkH [Occ=Once] ipv3_sfPkI [Occ=Once] ->
                    case ipv_sfPkE of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPkL [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case
                              GHC.Base.eqString ds4_sfPkL Data.Semigroup.$fReadWrappedMonoid4
                          of
                          { GHC.Types.False -> go5_rfC6C ipv1_sfPkF ipv3_sfPkI;
                            GHC.Types.True -> ipv2_sfPkH;
                          };
                    };
              };
        };

$cWrapMonoid2_rfC6D :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cWrapMonoid3_rfC6E];
Data.Semigroup.$fDataWrappedMonoid6 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cWrapMonoid GHC.Types.[]];
Data.Semigroup.$fDataWrappedMonoid5 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataWrappedMonoid6];
Data.Semigroup.$tWrappedMonoid :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataWrappedMonoid7
                                       Data.Semigroup.$fDataWrappedMonoid5];
Data.Semigroup.$cWrapMonoid [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cWrapMonoid2_rfC6D
                                     Data.Semigroup.$fReadWrappedMonoid4
                                     $cWrapMonoid1_rfC6B
                                     Data.Data.Prefix
                                     Data.Semigroup.$tWrappedMonoid];
$cWrapMonoid3_rfC6E :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go5_rfC6C Data.Semigroup.$fDataWrappedMonoid6 Data.Data.mkConstr1;

$cOption1_rfC6F :: [GHC.Base.String]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$fReadOption2 GHC.Types.[]];

go6_rfC6G
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfPkQ _ys_sfPkR]
        case ds2_sfPkQ of {
          [] -> GHC.List.badHead;
          : ipv_sfPkT [Occ=Once!] ipv1_sfPkU [Occ=Once] ->
              case _ys_sfPkR of {
                [] -> GHC.List.badHead;
                : ipv2_sfPkW [Occ=Once] ipv3_sfPkX [Occ=Once] ->
                    case ipv_sfPkT of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfPl0 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfPl0 Data.Semigroup.$fDataOption9 of {
                            GHC.Types.False -> go6_rfC6G ipv1_sfPkU ipv3_sfPkX;
                            GHC.Types.True -> ipv2_sfPkW;
                          };
                    };
              };
        };

$cOption2_rfC6H :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cOption3_rfC6I];
Data.Semigroup.$fDataOption8 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Semigroup.$cOption GHC.Types.[]];
Data.Semigroup.$fDataOption7 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Semigroup.$fDataOption8];
Data.Semigroup.$tOption :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Semigroup.$fDataOption9
                                       Data.Semigroup.$fDataOption7];
Data.Semigroup.$cOption [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cOption2_rfC6H
                                     Data.Semigroup.$fDataOption9
                                     $cOption1_rfC6F
                                     Data.Data.Prefix
                                     Data.Semigroup.$tOption];
$cOption3_rfC6I :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go6_rfC6G Data.Semigroup.$fDataOption8 Data.Data.mkConstr1;

Data.Semigroup.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Semigroup.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$trModule4];

Data.Semigroup.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Semigroup"#;

Data.Semigroup.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$trModule2];

Data.Semigroup.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Semigroup.$trModule3
                                     Data.Semigroup.$trModule1];

$krep_rfC6J :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_rfC6K :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_rfC6L :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rfC6K GHC.Types.[]];

$krep3_rfC6M :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep2_rfC6L];

Data.Semigroup.$fDataMin3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataMin4];

Data.Semigroup.$tcMin :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2898124504153588682##
                                    15185633012309158566##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataMin3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep4_rfC6N :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcMin
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Min1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep4_rfC6N];

Data.Semigroup.$tc'Min3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Min"#;

Data.Semigroup.$tc'Min2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Min3];

Data.Semigroup.$tc'Min :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7769702422559516318##
                                    9758175179672887730##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Min2
                                    1#
                                    Data.Semigroup.$tc'Min1];

Data.Semigroup.$fDataMin2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Min
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                2898124504153588682##
                15185633012309158566##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataMin3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPl6 [Occ=Once]
                   ww9_sfPl7 [Occ=Once]
                   ww10_sfPl8 [Occ=Once]
                   ww11_sfPl9 [Occ=Once]
                   ww12_sfPla [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPl6
                                              ww9_sfPl7
                                              ww10_sfPl8
                                              ww11_sfPl9
                                              ww12_sfPla];
        };

Data.Semigroup.$fDataMin8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Min a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPlb]
        case Data.Data.$p1Data $dData_sfPlb of sat_sfPlc {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp Data.Semigroup.$fDataMin2 sat_sfPlc;
        };

Data.Semigroup.$fDataMin_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Min a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPld $dTypeable_sfPle]
        let {
          lvl33_sfPlf [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPle] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPle Data.Semigroup.$fDataMin2; } in
        let {
          sat_sfPlj [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afxz6 (t_afxz5 d))
               -> GHC.Base.Maybe (c_afxz6 (Data.Semigroup.Min a_Xfy02))
          [LclId] =
              [$dData_sfPld lvl33_sfPlf] \r [f_sfPlg]
                  case lvl33_sfPlf of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPli [Occ=Once] :: c_afxz6 (Data.Semigroup.Min a_Xfy02)
                          [LclId] =
                              [$dData_sfPld f_sfPlg] \u [] f_sfPlg $dData_sfPld;
                        } in  GHC.Base.Just [sat_sfPli];
                  };
        } in  sat_sfPlj;

Data.Semigroup.$fDataMin1
  :: forall a. (a -> Data.Semigroup.Min a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataMin_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Min a -> m (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPlk $dMonadPlus_sfPll ds_sfPlm eta_sfPln]
        let {
          lvl33_sfPlo [Occ=OnceL] :: m_afxBb (Data.Semigroup.Min a_Xfy0b)
          [LclId] =
              [$dMonadPlus_sfPll] \u [] GHC.Base.mzero $dMonadPlus_sfPll;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPll
          of
          $dMonad_sfPlp [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPlL [Occ=Once]
                    :: (Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                       -> m_afxBb (Data.Semigroup.Min a_Xfy0b)
                  [LclId] =
                      [lvl33_sfPlo $dMonad_sfPlp] \r [ds1_sfPlG]
                          case ds1_sfPlG of {
                            (,) x'_sfPlI [Occ=Once] b_sfPlJ [Occ=Once!] ->
                                case b_sfPlJ of {
                                  GHC.Types.False -> lvl33_sfPlo;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPlp x'_sfPlI;
                                };
                          }; } in
                let {
                  sat_sfPlF [Occ=Once]
                    :: m_afxBb (Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPlk
                       $dMonadPlus_sfPll
                       ds_sfPlm
                       eta_sfPln
                       $dMonad_sfPlp] \u []
                          let {
                            lvl34_sfPlq [Occ=OnceL] :: m_afxBb a_Xfy0b
                            [LclId] =
                                [$dData_sfPlk ds_sfPlm eta_sfPln] \u []
                                    ds_sfPlm $dData_sfPlk eta_sfPln; } in
                          let {
                            sat_sfPlE [Occ=Once]
                              :: (a_Xfy0b -> Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                                 -> m_afxBb (Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPll
                                 eta_sfPln
                                 $dMonad_sfPlp
                                 lvl34_sfPlq] \r [ds1_sfPls]
                                    case ds1_sfPls of {
                                      (,) h_sfPlu b1_sfPlv [Occ=Once] ->
                                          let {
                                            sat_sfPlD [Occ=Once]
                                              :: m_afxBb (Data.Semigroup.Min a_Xfy0b,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfPln $dMonad_sfPlp h_sfPlu b1_sfPlv] \u []
                                                    let {
                                                      sat_sfPlB [Occ=Once]
                                                        :: Data.Semigroup.Min a_Xfy0b
                                                      [LclId] =
                                                          [eta_sfPln h_sfPlu] \u []
                                                              h_sfPlu eta_sfPln; } in
                                                    let {
                                                      sat_sfPlC [Occ=Once]
                                                        :: (Data.Semigroup.Min a_Xfy0b,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfPlB b1_sfPlv];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfPlp sat_sfPlC; } in
                                          let {
                                            sat_sfPlA [Occ=Once]
                                              :: m_afxBb (Data.Semigroup.Min a_Xfy0b,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfPlp lvl34_sfPlq h_sfPlu] \u []
                                                    let {
                                                      sat_sfPlz [Occ=Once]
                                                        :: a_Xfy0b
                                                           -> m_afxBb (Data.Semigroup.Min a_Xfy0b,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfPlp h_sfPlu] \r [y'_sfPlw]
                                                              let {
                                                                sat_sfPlx [Occ=Once]
                                                                  :: Data.Semigroup.Min a_Xfy0b
                                                                [LclId] =
                                                                    [h_sfPlu y'_sfPlw] \u []
                                                                        h_sfPlu y'_sfPlw; } in
                                                              let {
                                                                sat_sfPly [Occ=Once]
                                                                  :: (Data.Semigroup.Min a_Xfy0b,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfPlx
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfPlp sat_sfPly;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfPlp lvl34_sfPlq sat_sfPlz;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfPll sat_sfPlA sat_sfPlD;
                                    }; } in
                          let {
                            sat_sfPlr [Occ=Once]
                              :: m_afxBb (a_Xfy0b -> Data.Semigroup.Min a_Xfy0b, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPlp] \u []
                                    GHC.Base.return $dMonad_sfPlp Data.Semigroup.$fDataMin1;
                          } in  GHC.Base.>>= $dMonad_sfPlp sat_sfPlr sat_sfPlE;
                } in  GHC.Base.>>= $dMonad_sfPlp sat_sfPlF sat_sfPlL;
          };

Data.Semigroup.$fDataMin_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Min a -> m (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPlM $dMonad_sfPlN ds_sfPlO eta_sfPlP]
        let {
          lvl33_sfPlQ [Occ=OnceL] :: m_afxAV a_Xfy0a
          [LclId] =
              [$dData_sfPlM ds_sfPlO eta_sfPlP] \u []
                  ds_sfPlO $dData_sfPlM eta_sfPlP; } in
        let {
          sat_sfPlW [Occ=Once]
            :: (a_Xfy0a -> Data.Semigroup.Min a_Xfy0a)
               -> m_afxAV (Data.Semigroup.Min a_Xfy0a)
          [LclId] =
              [$dMonad_sfPlN lvl33_sfPlQ] \r [c'_sfPlS]
                  let {
                    sat_sfPlV [Occ=Once]
                      :: a_Xfy0a -> m_afxAV (Data.Semigroup.Min a_Xfy0a)
                    [LclId] =
                        [$dMonad_sfPlN c'_sfPlS] \r [x'_sfPlT]
                            let {
                              sat_sfPlU [Occ=Once] :: Data.Semigroup.Min a_Xfy0a
                              [LclId] =
                                  [c'_sfPlS x'_sfPlT] \u [] c'_sfPlS x'_sfPlT;
                            } in  GHC.Base.return $dMonad_sfPlN sat_sfPlU;
                  } in  GHC.Base.>>= $dMonad_sfPlN lvl33_sfPlQ sat_sfPlV; } in
        let {
          sat_sfPlR [Occ=Once]
            :: m_afxAV (a_Xfy0a -> Data.Semigroup.Min a_Xfy0a)
          [LclId] =
              [$dMonad_sfPlN] \u []
                  GHC.Base.return $dMonad_sfPlN Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfPlN sat_sfPlR sat_sfPlW;

Data.Semigroup.$fDataMin_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Min a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPlX ds_sfPlY ds1_sfPlZ x_sfPm0]
        case ds_sfPlY of {
          GHC.Types.I# x1_sfPm2 [Occ=Once!] ->
              case x1_sfPm2 of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfPlZ $dData_sfPlX x_sfPm0;
              };
        };

Data.Semigroup.$fDataMin_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Min a -> m (Data.Semigroup.Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPm4 $dMonadPlus_sfPm5 ds_sfPm6 eta_sfPm7]
        let {
          lvl33_sfPm8 [Occ=OnceL] :: m_afxBr (Data.Semigroup.Min a_Xfy04)
          [LclId] =
              [$dMonadPlus_sfPm5] \u [] GHC.Base.mzero $dMonadPlus_sfPm5;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPm5
          of
          $dMonad_sfPm9 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPmy [Occ=Once]
                    :: (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                       -> m_afxBr (Data.Semigroup.Min a_Xfy04)
                  [LclId] =
                      [lvl33_sfPm8 $dMonad_sfPm9] \r [ds1_sfPmt]
                          case ds1_sfPmt of {
                            (,) x'_sfPmv [Occ=Once] b_sfPmw [Occ=Once!] ->
                                case b_sfPmw of {
                                  GHC.Types.False -> lvl33_sfPm8;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPm9 x'_sfPmv;
                                };
                          }; } in
                let {
                  sat_sfPms [Occ=Once]
                    :: m_afxBr (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPm4
                       $dMonadPlus_sfPm5
                       ds_sfPm6
                       eta_sfPm7
                       $dMonad_sfPm9] \u []
                          let {
                            lvl34_sfPma [Occ=OnceL] :: m_afxBr a_Xfy04
                            [LclId] =
                                [$dData_sfPm4 ds_sfPm6 eta_sfPm7] \u []
                                    ds_sfPm6 $dData_sfPm4 eta_sfPm7; } in
                          let {
                            sat_sfPmr [Occ=Once]
                              :: (a_Xfy04 -> Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                                 -> m_afxBr (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPm5
                                 eta_sfPm7
                                 $dMonad_sfPm9
                                 lvl34_sfPma] \r [ds1_sfPmc]
                                    case ds1_sfPmc of {
                                      (,) h_sfPme b1_sfPmf [Occ=Once!] ->
                                          case b1_sfPmf of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfPmo [Occ=Once]
                                                    :: m_afxBr (Data.Semigroup.Min a_Xfy04,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfPm7 $dMonad_sfPm9 h_sfPme] \u []
                                                          let {
                                                            sat_sfPmm [Occ=Once]
                                                              :: Data.Semigroup.Min a_Xfy04
                                                            [LclId] =
                                                                [eta_sfPm7 h_sfPme] \u []
                                                                    h_sfPme eta_sfPm7; } in
                                                          let {
                                                            sat_sfPmn [Occ=Once]
                                                              :: (Data.Semigroup.Min a_Xfy04,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfPmm
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfPm9 sat_sfPmn; } in
                                                let {
                                                  sat_sfPml [Occ=Once]
                                                    :: m_afxBr (Data.Semigroup.Min a_Xfy04,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfPm9 lvl34_sfPma h_sfPme] \u []
                                                          let {
                                                            sat_sfPmk [Occ=Once]
                                                              :: a_Xfy04
                                                                 -> m_afxBr (Data.Semigroup.Min
                                                                               a_Xfy04,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPm9
                                                                 h_sfPme] \r [y'_sfPmh]
                                                                    let {
                                                                      sat_sfPmi [Occ=Once]
                                                                        :: Data.Semigroup.Min
                                                                             a_Xfy04
                                                                      [LclId] =
                                                                          [h_sfPme y'_sfPmh] \u []
                                                                              h_sfPme y'_sfPmh; } in
                                                                    let {
                                                                      sat_sfPmj [Occ=Once]
                                                                        :: (Data.Semigroup.Min
                                                                              a_Xfy04,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPmi
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPm9 sat_sfPmj;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfPm9 lvl34_sfPma sat_sfPmk;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfPm5 sat_sfPml sat_sfPmo;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfPmp [Occ=Once] :: Data.Semigroup.Min a_Xfy04
                                                  [LclId] =
                                                      [eta_sfPm7 h_sfPme] \u []
                                                          h_sfPme eta_sfPm7; } in
                                                let {
                                                  sat_sfPmq [Occ=Once]
                                                    :: (Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfPmp GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfPm9 sat_sfPmq;
                                          };
                                    }; } in
                          let {
                            sat_sfPmb [Occ=Once]
                              :: m_afxBr (a_Xfy04 -> Data.Semigroup.Min a_Xfy04, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPm9] \u []
                                    GHC.Base.return $dMonad_sfPm9 Data.Semigroup.$fDataMin1;
                          } in  GHC.Base.>>= $dMonad_sfPm9 sat_sfPmb sat_sfPmr;
                } in  GHC.Base.>>= $dMonad_sfPm9 sat_sfPms sat_sfPmy;
          };

lvl12_rfC6O :: forall a. Data.Semigroup.Min a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPmz] Data.Semigroup.$cMin;

lvl13_rfC6P :: forall a. Data.Semigroup.Min a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPmA] Data.Semigroup.$tMin;

lvl14_rfC6Q
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Min a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPmB ds_sfPmC] GHC.Base.Nothing [];

Data.Semigroup.$fDataMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Min a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPmD]
        let {
          sat_sfPn8 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Min a_Xfy03 -> m (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfPmD] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapMo
                      $dData_sfPmD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPn7 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Min a_Xfy03 -> m (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfPmD] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapMp
                      $dData_sfPmD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPn6 [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Min a_Xfy03 -> m (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfPmD] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapM
                      $dData_sfPmD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPn5 [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Min a_Xfy03
               -> u
          [LclId] =
              [$dData_sfPmD] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgmapQi
                      $dData_sfPmD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPn4 [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Min a_Xfy03 -> [u]
          [LclId] =
              [$dData_sfPmD] \r [ds_sfPn1 x0_sfPn2]
                  let {
                    sat_sfPn3 [Occ=Once] :: u_afxAt
                    [LclId] =
                        [$dData_sfPmD ds_sfPn1 x0_sfPn2] \u []
                            ds_sfPn1 $dData_sfPmD x0_sfPn2;
                  } in  : [sat_sfPn3 GHC.Types.[]]; } in
        let {
          sat_sfPn0 [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Min a_Xfy03
               -> r
          [LclId] =
              [$dData_sfPmD] \r [ds_sfPmV ds1_sfPmW ds2_sfPmX x0_sfPmY]
                  let {
                    sat_sfPmZ [Occ=Once] :: r'_afxAd
                    [LclId] =
                        [$dData_sfPmD ds2_sfPmX x0_sfPmY] \u []
                            ds2_sfPmX $dData_sfPmD x0_sfPmY;
                  } in  ds_sfPmV sat_sfPmZ ds1_sfPmW; } in
        let {
          sat_sfPmU [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Min a_Xfy03
               -> r
          [LclId] =
              [$dData_sfPmD] \r [ds_sfPmP ds1_sfPmQ ds2_sfPmR eta_sfPmS]
                  let {
                    sat_sfPmT [Occ=Once] :: r'_afxzW
                    [LclId] =
                        [$dData_sfPmD ds2_sfPmR eta_sfPmS] \u []
                            ds2_sfPmR $dData_sfPmD eta_sfPmS;
                  } in  ds_sfPmP ds1_sfPmQ sat_sfPmT; } in
        let {
          sat_sfPmO [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Min a_Xfy03 -> Data.Semigroup.Min a_Xfy03
          [LclId] =
              [$dData_sfPmD] \r [ds_sfPmM x0_sfPmN]
                  ds_sfPmM $dData_sfPmD x0_sfPmN; } in
        let {
          sat_sfPmL [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Min a_Xfy03))
          [LclId] =
              [$dData_sfPmD] \r [eta_B1]
                  Data.Semigroup.$fDataMin_$cdataCast1 $dData_sfPmD eta_B1; } in
        let {
          sat_sfPmK [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfPmD] \r [k_sfPmG z_sfPmH ds_sfPmI]
                  let {
                    sat_sfPmJ [Occ=Once]
                      :: c_afxyM (a_Xfy03 -> Data.Semigroup.Min a_Xfy03)
                    [LclId] =
                        [z_sfPmH] \u [] z_sfPmH Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfPmG $dData_sfPmD sat_sfPmJ; } in
        let {
          sat_sfPmF [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Min a_Xfy03
               -> c (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfPmD] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMin_$cgfoldl
                      $dData_sfPmD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPmE [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Min a_Xfy03)
          [LclId] =
              [$dData_sfPmD] \u [] Data.Semigroup.$fDataMin8 $dData_sfPmD;
        } in 
          Data.Data.C:Data [sat_sfPmE
                            sat_sfPmF
                            sat_sfPmK
                            lvl12_rfC6O
                            lvl13_rfC6P
                            sat_sfPmL
                            lvl14_rfC6Q
                            sat_sfPmO
                            sat_sfPmU
                            sat_sfPn0
                            sat_sfPn4
                            sat_sfPn5
                            sat_sfPn6
                            sat_sfPn7
                            sat_sfPn8];

Data.Semigroup.$fDataMax3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataMax4];

Data.Semigroup.$tcMax :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10813679156066679206##
                                    10491840004411982061##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataMax3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep5_rfC6R :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcMax
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Max1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep5_rfC6R];

Data.Semigroup.$tc'Max3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Max"#;

Data.Semigroup.$tc'Max2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Max3];

Data.Semigroup.$tc'Max :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9964620667386625613##
                                    8300955803911017019##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Max2
                                    1#
                                    Data.Semigroup.$tc'Max1];

Data.Semigroup.$fDataMax2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Max
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                10813679156066679206##
                10491840004411982061##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataMax3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPna [Occ=Once]
                   ww9_sfPnb [Occ=Once]
                   ww10_sfPnc [Occ=Once]
                   ww11_sfPnd [Occ=Once]
                   ww12_sfPne [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPna
                                              ww9_sfPnb
                                              ww10_sfPnc
                                              ww11_sfPnd
                                              ww12_sfPne];
        };

Data.Semigroup.$fDataMax8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Max a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPnf]
        case Data.Data.$p1Data $dData_sfPnf of sat_sfPng {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp Data.Semigroup.$fDataMax2 sat_sfPng;
        };

Data.Semigroup.$fDataMax_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Max a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPnh $dTypeable_sfPni]
        let {
          lvl33_sfPnj [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPni] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPni Data.Semigroup.$fDataMax2; } in
        let {
          sat_sfPnn [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afxI8 (t_afxI7 d))
               -> GHC.Base.Maybe (c_afxI8 (Data.Semigroup.Max a_Xfy9s))
          [LclId] =
              [$dData_sfPnh lvl33_sfPnj] \r [f_sfPnk]
                  case lvl33_sfPnj of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPnm [Occ=Once] :: c_afxI8 (Data.Semigroup.Max a_Xfy9s)
                          [LclId] =
                              [$dData_sfPnh f_sfPnk] \u [] f_sfPnk $dData_sfPnh;
                        } in  GHC.Base.Just [sat_sfPnm];
                  };
        } in  sat_sfPnn;

Data.Semigroup.$fDataMax1
  :: forall a. (a -> Data.Semigroup.Max a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataMax_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Max a -> m (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPno $dMonadPlus_sfPnp ds_sfPnq eta_sfPnr]
        let {
          lvl33_sfPns [Occ=OnceL] :: m_afxKd (Data.Semigroup.Max a_Xfy9B)
          [LclId] =
              [$dMonadPlus_sfPnp] \u [] GHC.Base.mzero $dMonadPlus_sfPnp;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPnp
          of
          $dMonad_sfPnt [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPnP [Occ=Once]
                    :: (Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                       -> m_afxKd (Data.Semigroup.Max a_Xfy9B)
                  [LclId] =
                      [lvl33_sfPns $dMonad_sfPnt] \r [ds1_sfPnK]
                          case ds1_sfPnK of {
                            (,) x'_sfPnM [Occ=Once] b_sfPnN [Occ=Once!] ->
                                case b_sfPnN of {
                                  GHC.Types.False -> lvl33_sfPns;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPnt x'_sfPnM;
                                };
                          }; } in
                let {
                  sat_sfPnJ [Occ=Once]
                    :: m_afxKd (Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPno
                       $dMonadPlus_sfPnp
                       ds_sfPnq
                       eta_sfPnr
                       $dMonad_sfPnt] \u []
                          let {
                            lvl34_sfPnu [Occ=OnceL] :: m_afxKd a_Xfy9B
                            [LclId] =
                                [$dData_sfPno ds_sfPnq eta_sfPnr] \u []
                                    ds_sfPnq $dData_sfPno eta_sfPnr; } in
                          let {
                            sat_sfPnI [Occ=Once]
                              :: (a_Xfy9B -> Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                                 -> m_afxKd (Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPnp
                                 eta_sfPnr
                                 $dMonad_sfPnt
                                 lvl34_sfPnu] \r [ds1_sfPnw]
                                    case ds1_sfPnw of {
                                      (,) h_sfPny b1_sfPnz [Occ=Once] ->
                                          let {
                                            sat_sfPnH [Occ=Once]
                                              :: m_afxKd (Data.Semigroup.Max a_Xfy9B,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfPnr $dMonad_sfPnt h_sfPny b1_sfPnz] \u []
                                                    let {
                                                      sat_sfPnF [Occ=Once]
                                                        :: Data.Semigroup.Max a_Xfy9B
                                                      [LclId] =
                                                          [eta_sfPnr h_sfPny] \u []
                                                              h_sfPny eta_sfPnr; } in
                                                    let {
                                                      sat_sfPnG [Occ=Once]
                                                        :: (Data.Semigroup.Max a_Xfy9B,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfPnF b1_sfPnz];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfPnt sat_sfPnG; } in
                                          let {
                                            sat_sfPnE [Occ=Once]
                                              :: m_afxKd (Data.Semigroup.Max a_Xfy9B,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfPnt lvl34_sfPnu h_sfPny] \u []
                                                    let {
                                                      sat_sfPnD [Occ=Once]
                                                        :: a_Xfy9B
                                                           -> m_afxKd (Data.Semigroup.Max a_Xfy9B,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfPnt h_sfPny] \r [y'_sfPnA]
                                                              let {
                                                                sat_sfPnB [Occ=Once]
                                                                  :: Data.Semigroup.Max a_Xfy9B
                                                                [LclId] =
                                                                    [h_sfPny y'_sfPnA] \u []
                                                                        h_sfPny y'_sfPnA; } in
                                                              let {
                                                                sat_sfPnC [Occ=Once]
                                                                  :: (Data.Semigroup.Max a_Xfy9B,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfPnB
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfPnt sat_sfPnC;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfPnt lvl34_sfPnu sat_sfPnD;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfPnp sat_sfPnE sat_sfPnH;
                                    }; } in
                          let {
                            sat_sfPnv [Occ=Once]
                              :: m_afxKd (a_Xfy9B -> Data.Semigroup.Max a_Xfy9B, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPnt] \u []
                                    GHC.Base.return $dMonad_sfPnt Data.Semigroup.$fDataMax1;
                          } in  GHC.Base.>>= $dMonad_sfPnt sat_sfPnv sat_sfPnI;
                } in  GHC.Base.>>= $dMonad_sfPnt sat_sfPnJ sat_sfPnP;
          };

Data.Semigroup.$fDataMax_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Max a -> m (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPnQ $dMonad_sfPnR ds_sfPnS eta_sfPnT]
        let {
          lvl33_sfPnU [Occ=OnceL] :: m_afxJX a_Xfy9A
          [LclId] =
              [$dData_sfPnQ ds_sfPnS eta_sfPnT] \u []
                  ds_sfPnS $dData_sfPnQ eta_sfPnT; } in
        let {
          sat_sfPo0 [Occ=Once]
            :: (a_Xfy9A -> Data.Semigroup.Max a_Xfy9A)
               -> m_afxJX (Data.Semigroup.Max a_Xfy9A)
          [LclId] =
              [$dMonad_sfPnR lvl33_sfPnU] \r [c'_sfPnW]
                  let {
                    sat_sfPnZ [Occ=Once]
                      :: a_Xfy9A -> m_afxJX (Data.Semigroup.Max a_Xfy9A)
                    [LclId] =
                        [$dMonad_sfPnR c'_sfPnW] \r [x'_sfPnX]
                            let {
                              sat_sfPnY [Occ=Once] :: Data.Semigroup.Max a_Xfy9A
                              [LclId] =
                                  [c'_sfPnW x'_sfPnX] \u [] c'_sfPnW x'_sfPnX;
                            } in  GHC.Base.return $dMonad_sfPnR sat_sfPnY;
                  } in  GHC.Base.>>= $dMonad_sfPnR lvl33_sfPnU sat_sfPnZ; } in
        let {
          sat_sfPnV [Occ=Once]
            :: m_afxJX (a_Xfy9A -> Data.Semigroup.Max a_Xfy9A)
          [LclId] =
              [$dMonad_sfPnR] \u []
                  GHC.Base.return $dMonad_sfPnR Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfPnR sat_sfPnV sat_sfPo0;

Data.Semigroup.$fDataMax_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Max a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPo1 ds_sfPo2 ds1_sfPo3 x_sfPo4]
        case ds_sfPo2 of {
          GHC.Types.I# x1_sfPo6 [Occ=Once!] ->
              case x1_sfPo6 of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfPo3 $dData_sfPo1 x_sfPo4;
              };
        };

Data.Semigroup.$fDataMax_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Max a -> m (Data.Semigroup.Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPo8 $dMonadPlus_sfPo9 ds_sfPoa eta_sfPob]
        let {
          lvl33_sfPoc [Occ=OnceL] :: m_afxKt (Data.Semigroup.Max a_Xfy9u)
          [LclId] =
              [$dMonadPlus_sfPo9] \u [] GHC.Base.mzero $dMonadPlus_sfPo9;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPo9
          of
          $dMonad_sfPod [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPoC [Occ=Once]
                    :: (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                       -> m_afxKt (Data.Semigroup.Max a_Xfy9u)
                  [LclId] =
                      [lvl33_sfPoc $dMonad_sfPod] \r [ds1_sfPox]
                          case ds1_sfPox of {
                            (,) x'_sfPoz [Occ=Once] b_sfPoA [Occ=Once!] ->
                                case b_sfPoA of {
                                  GHC.Types.False -> lvl33_sfPoc;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPod x'_sfPoz;
                                };
                          }; } in
                let {
                  sat_sfPow [Occ=Once]
                    :: m_afxKt (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPo8
                       $dMonadPlus_sfPo9
                       ds_sfPoa
                       eta_sfPob
                       $dMonad_sfPod] \u []
                          let {
                            lvl34_sfPoe [Occ=OnceL] :: m_afxKt a_Xfy9u
                            [LclId] =
                                [$dData_sfPo8 ds_sfPoa eta_sfPob] \u []
                                    ds_sfPoa $dData_sfPo8 eta_sfPob; } in
                          let {
                            sat_sfPov [Occ=Once]
                              :: (a_Xfy9u -> Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                                 -> m_afxKt (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPo9
                                 eta_sfPob
                                 $dMonad_sfPod
                                 lvl34_sfPoe] \r [ds1_sfPog]
                                    case ds1_sfPog of {
                                      (,) h_sfPoi b1_sfPoj [Occ=Once!] ->
                                          case b1_sfPoj of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfPos [Occ=Once]
                                                    :: m_afxKt (Data.Semigroup.Max a_Xfy9u,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfPob $dMonad_sfPod h_sfPoi] \u []
                                                          let {
                                                            sat_sfPoq [Occ=Once]
                                                              :: Data.Semigroup.Max a_Xfy9u
                                                            [LclId] =
                                                                [eta_sfPob h_sfPoi] \u []
                                                                    h_sfPoi eta_sfPob; } in
                                                          let {
                                                            sat_sfPor [Occ=Once]
                                                              :: (Data.Semigroup.Max a_Xfy9u,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfPoq
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfPod sat_sfPor; } in
                                                let {
                                                  sat_sfPop [Occ=Once]
                                                    :: m_afxKt (Data.Semigroup.Max a_Xfy9u,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfPod lvl34_sfPoe h_sfPoi] \u []
                                                          let {
                                                            sat_sfPoo [Occ=Once]
                                                              :: a_Xfy9u
                                                                 -> m_afxKt (Data.Semigroup.Max
                                                                               a_Xfy9u,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPod
                                                                 h_sfPoi] \r [y'_sfPol]
                                                                    let {
                                                                      sat_sfPom [Occ=Once]
                                                                        :: Data.Semigroup.Max
                                                                             a_Xfy9u
                                                                      [LclId] =
                                                                          [h_sfPoi y'_sfPol] \u []
                                                                              h_sfPoi y'_sfPol; } in
                                                                    let {
                                                                      sat_sfPon [Occ=Once]
                                                                        :: (Data.Semigroup.Max
                                                                              a_Xfy9u,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPom
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPod sat_sfPon;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfPod lvl34_sfPoe sat_sfPoo;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfPo9 sat_sfPop sat_sfPos;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfPot [Occ=Once] :: Data.Semigroup.Max a_Xfy9u
                                                  [LclId] =
                                                      [eta_sfPob h_sfPoi] \u []
                                                          h_sfPoi eta_sfPob; } in
                                                let {
                                                  sat_sfPou [Occ=Once]
                                                    :: (Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfPot GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfPod sat_sfPou;
                                          };
                                    }; } in
                          let {
                            sat_sfPof [Occ=Once]
                              :: m_afxKt (a_Xfy9u -> Data.Semigroup.Max a_Xfy9u, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPod] \u []
                                    GHC.Base.return $dMonad_sfPod Data.Semigroup.$fDataMax1;
                          } in  GHC.Base.>>= $dMonad_sfPod sat_sfPof sat_sfPov;
                } in  GHC.Base.>>= $dMonad_sfPod sat_sfPow sat_sfPoC;
          };

lvl15_rfC6S :: forall a. Data.Semigroup.Max a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPoD] Data.Semigroup.$cMax;

lvl16_rfC6T :: forall a. Data.Semigroup.Max a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPoE] Data.Semigroup.$tMax;

lvl17_rfC6U
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Max a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPoF ds_sfPoG] GHC.Base.Nothing [];

Data.Semigroup.$fDataMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Max a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPoH]
        let {
          sat_sfPpc [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Max a_Xfy9t -> m (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfPoH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapMo
                      $dData_sfPoH eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPpb [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Max a_Xfy9t -> m (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfPoH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapMp
                      $dData_sfPoH eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPpa [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Max a_Xfy9t -> m (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfPoH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapM
                      $dData_sfPoH eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPp9 [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Max a_Xfy9t
               -> u
          [LclId] =
              [$dData_sfPoH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgmapQi
                      $dData_sfPoH eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPp8 [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Max a_Xfy9t -> [u]
          [LclId] =
              [$dData_sfPoH] \r [ds_sfPp5 x0_sfPp6]
                  let {
                    sat_sfPp7 [Occ=Once] :: u_afxJv
                    [LclId] =
                        [$dData_sfPoH ds_sfPp5 x0_sfPp6] \u []
                            ds_sfPp5 $dData_sfPoH x0_sfPp6;
                  } in  : [sat_sfPp7 GHC.Types.[]]; } in
        let {
          sat_sfPp4 [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Max a_Xfy9t
               -> r
          [LclId] =
              [$dData_sfPoH] \r [ds_sfPoZ ds1_sfPp0 ds2_sfPp1 x0_sfPp2]
                  let {
                    sat_sfPp3 [Occ=Once] :: r'_afxJf
                    [LclId] =
                        [$dData_sfPoH ds2_sfPp1 x0_sfPp2] \u []
                            ds2_sfPp1 $dData_sfPoH x0_sfPp2;
                  } in  ds_sfPoZ sat_sfPp3 ds1_sfPp0; } in
        let {
          sat_sfPoY [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Max a_Xfy9t
               -> r
          [LclId] =
              [$dData_sfPoH] \r [ds_sfPoT ds1_sfPoU ds2_sfPoV eta_sfPoW]
                  let {
                    sat_sfPoX [Occ=Once] :: r'_afxIY
                    [LclId] =
                        [$dData_sfPoH ds2_sfPoV eta_sfPoW] \u []
                            ds2_sfPoV $dData_sfPoH eta_sfPoW;
                  } in  ds_sfPoT ds1_sfPoU sat_sfPoX; } in
        let {
          sat_sfPoS [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Max a_Xfy9t -> Data.Semigroup.Max a_Xfy9t
          [LclId] =
              [$dData_sfPoH] \r [ds_sfPoQ x0_sfPoR]
                  ds_sfPoQ $dData_sfPoH x0_sfPoR; } in
        let {
          sat_sfPoP [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Max a_Xfy9t))
          [LclId] =
              [$dData_sfPoH] \r [eta_B1]
                  Data.Semigroup.$fDataMax_$cdataCast1 $dData_sfPoH eta_B1; } in
        let {
          sat_sfPoO [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfPoH] \r [k_sfPoK z_sfPoL ds_sfPoM]
                  let {
                    sat_sfPoN [Occ=Once]
                      :: c_afxHO (a_Xfy9t -> Data.Semigroup.Max a_Xfy9t)
                    [LclId] =
                        [z_sfPoL] \u [] z_sfPoL Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfPoK $dData_sfPoH sat_sfPoN; } in
        let {
          sat_sfPoJ [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Max a_Xfy9t
               -> c (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfPoH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataMax_$cgfoldl
                      $dData_sfPoH eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPoI [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Max a_Xfy9t)
          [LclId] =
              [$dData_sfPoH] \u [] Data.Semigroup.$fDataMax8 $dData_sfPoH;
        } in 
          Data.Data.C:Data [sat_sfPoI
                            sat_sfPoJ
                            sat_sfPoO
                            lvl15_rfC6S
                            lvl16_rfC6T
                            sat_sfPoP
                            lvl17_rfC6U
                            sat_sfPoS
                            sat_sfPoY
                            sat_sfPp4
                            sat_sfPp8
                            sat_sfPp9
                            sat_sfPpa
                            sat_sfPpb
                            sat_sfPpc];

Data.Semigroup.$fDataArg5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataArg6];

Data.Semigroup.$tcArg :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12181131229304595757##
                                    13964868205162960136##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataArg5
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep6_rfC6V :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rfC6J GHC.Types.[]];

$krep7_rfC6W :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rfC6K $krep6_rfC6V];

$krep8_rfC6X :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcArg
                                              $krep7_rfC6W];

$krep9_rfC6Y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rfC6J $krep8_rfC6X];

Data.Semigroup.$tc'Arg1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep9_rfC6Y];

Data.Semigroup.$tc'Arg3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Arg"#;

Data.Semigroup.$tc'Arg2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Arg3];

Data.Semigroup.$tc'Arg :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1079323530693211499##
                                    7260223244427450599##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Arg2
                                    2#
                                    Data.Semigroup.$tc'Arg1];

Data.Semigroup.$fDataArg4
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Arg
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                12181131229304595757##
                13964868205162960136##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataArg5
                0#
                GHC.Types.krep$*->*->*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPpe [Occ=Once]
                   ww9_sfPpf [Occ=Once]
                   ww10_sfPpg [Occ=Once]
                   ww11_sfPph [Occ=Once]
                   ww12_sfPpi [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPpe
                                              ww9_sfPpf
                                              ww10_sfPpg
                                              ww11_sfPph
                                              ww12_sfPpi];
        };

Data.Semigroup.$fDataArg10
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Arg a b)
[GblId,
 Arity=2,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPpj $dData1_sfPpk]
        case Data.Data.$p1Data $dData1_sfPpk of sat_sfPpn {
          __DEFAULT ->
              case Data.Data.$p1Data $dData_sfPpj of sat_sfPpl {
                __DEFAULT ->
                    case
                        Data.Typeable.Internal.mkTrApp Data.Semigroup.$fDataArg4 sat_sfPpl
                    of
                    sat_sfPpm
                    { __DEFAULT -> Data.Typeable.Internal.mkTrApp sat_sfPpm sat_sfPpn;
                    };
              };
        };

Data.Semigroup.$fDataArg_$cdataCast2
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Arg a b))
[GblId, Arity=3, Str=<L,U><L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPpo $dData1_sfPpp $dTypeable_sfPpq]
        let {
          lvl33_sfPpr [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPpq] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPpq Data.Semigroup.$fDataArg4; } in
        let {
          sat_sfPpv [Occ=OnceT[0]]
            :: (forall d e.
                (Data.Data.Data d, Data.Data.Data e) =>
                c_afxP3 (t_afxP2 d e))
               -> GHC.Base.Maybe (c_afxP3 (Data.Semigroup.Arg a_Xfygm b_Xfygo))
          [LclId] =
              [$dData_sfPpo $dData1_sfPpp lvl33_sfPpr] \r [f_sfPps]
                  case lvl33_sfPpr of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPpu [Occ=Once]
                            :: c_afxP3 (Data.Semigroup.Arg a_Xfygm b_Xfygo)
                          [LclId] =
                              [$dData_sfPpo $dData1_sfPpp f_sfPps] \u []
                                  f_sfPps $dData_sfPpo $dData1_sfPpp;
                        } in  GHC.Base.Just [sat_sfPpu];
                  };
        } in  sat_sfPpv;

Data.Semigroup.$fDataArg1
  :: forall b a. (a -> b -> Data.Semigroup.Arg a b, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.Arg GHC.Types.False];

Data.Semigroup.$fDataArg_$cgmapMp
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Arg a b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPpw
           $dData1_sfPpx
           $dMonadPlus_sfPpy
           ds_sfPpz
           eta_sfPpA]
        let {
          lvl33_sfPpB [Occ=OnceL]
            :: m_afxQP (Data.Semigroup.Arg a_Xfygv b_Xfygx)
          [LclId] =
              [$dMonadPlus_sfPpy] \u [] GHC.Base.mzero $dMonadPlus_sfPpy;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPpy
          of
          $dMonad_sfPpC [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPq6 [Occ=Once]
                    :: (Data.Semigroup.Arg a_Xfygv b_Xfygx, GHC.Types.Bool)
                       -> m_afxQP (Data.Semigroup.Arg a_Xfygv b_Xfygx)
                  [LclId] =
                      [lvl33_sfPpB $dMonad_sfPpC] \r [ds1_sfPq1]
                          case ds1_sfPq1 of {
                            (,) x'_sfPq3 [Occ=Once] b1_sfPq4 [Occ=Once!] ->
                                case b1_sfPq4 of {
                                  GHC.Types.False -> lvl33_sfPpB;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPpC x'_sfPq3;
                                };
                          }; } in
                let {
                  sat_sfPq0 [Occ=Once]
                    :: m_afxQP (Data.Semigroup.Arg a_Xfygv b_Xfygx, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPpw
                       $dData1_sfPpx
                       $dMonadPlus_sfPpy
                       ds_sfPpz
                       eta_sfPpA
                       $dMonad_sfPpC] \u []
                          case eta_sfPpA of {
                            Data.Semigroup.Arg a1_sfPpE [Occ=Once] a2_sfPpF [Occ=Once] ->
                                let {
                                  k_sfPpG [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b1.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_afxQP (d -> b1)
                                       -> d -> m_afxQP (b1, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sfPpy
                                                ds_sfPpz
                                                $dMonad_sfPpC] \r [$dData2_sfPpH ds1_sfPpI y_sfPpJ]
                                          let {
                                            lvl34_sfPpK [Occ=OnceL] :: m_afxQP d_ae2Ws
                                            [LclId] =
                                                [ds_sfPpz $dData2_sfPpH y_sfPpJ] \u []
                                                    ds_sfPpz $dData2_sfPpH y_sfPpJ; } in
                                          let {
                                            sat_sfPpX [Occ=Once]
                                              :: (d_ae2Ws -> b1_ae2Wt, GHC.Types.Bool)
                                                 -> m_afxQP (b1_ae2Wt, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sfPpy
                                                 $dMonad_sfPpC
                                                 y_sfPpJ
                                                 lvl34_sfPpK] \r [ds2_sfPpL]
                                                    case ds2_sfPpL of {
                                                      (,) h_sfPpN b2_sfPpO [Occ=Once] ->
                                                          let {
                                                            sat_sfPpW [Occ=Once]
                                                              :: m_afxQP (b1_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPpC
                                                                 y_sfPpJ
                                                                 h_sfPpN
                                                                 b2_sfPpO] \u []
                                                                    let {
                                                                      sat_sfPpU [Occ=Once]
                                                                        :: b1_ae2Wt
                                                                      [LclId] =
                                                                          [y_sfPpJ h_sfPpN] \u []
                                                                              h_sfPpN y_sfPpJ; } in
                                                                    let {
                                                                      sat_sfPpV [Occ=Once]
                                                                        :: (b1_ae2Wt,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPpU
                                                                                     b2_sfPpO];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPpC
                                                                          sat_sfPpV; } in
                                                          let {
                                                            sat_sfPpT [Occ=Once]
                                                              :: m_afxQP (b1_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPpC
                                                                 lvl34_sfPpK
                                                                 h_sfPpN] \u []
                                                                    let {
                                                                      sat_sfPpS [Occ=Once]
                                                                        :: d_ae2Ws
                                                                           -> m_afxQP (b1_ae2Wt,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sfPpC
                                                                           h_sfPpN] \r [y'_sfPpP]
                                                                              let {
                                                                                sat_sfPpQ [Occ=Once]
                                                                                  :: b1_ae2Wt
                                                                                [LclId] =
                                                                                    [h_sfPpN
                                                                                     y'_sfPpP] \u []
                                                                                        h_sfPpN
                                                                                            y'_sfPpP; } in
                                                                              let {
                                                                                sat_sfPpR [Occ=Once]
                                                                                  :: (b1_ae2Wt,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sfPpQ
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sfPpC
                                                                                    sat_sfPpR;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sfPpC
                                                                          lvl34_sfPpK
                                                                          sat_sfPpS;
                                                          } in 
                                                            GHC.Base.mplus
                                                                $dMonadPlus_sfPpy
                                                                sat_sfPpT
                                                                sat_sfPpW;
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sfPpC ds1_sfPpI sat_sfPpX; } in
                                let {
                                  sat_sfPpZ [Occ=Once]
                                    :: Data.Data.Mp
                                         m_afxQP (b_Xfygx -> Data.Semigroup.Arg a_Xfygv b_Xfygx)
                                  [LclId] =
                                      [$dData_sfPpw $dMonad_sfPpC a1_sfPpE k_sfPpG] \u []
                                          let {
                                            sat_sfPpY [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_afxQP
                                                   (a_Xfygv
                                                    -> b_Xfygx
                                                    -> Data.Semigroup.Arg a_Xfygv b_Xfygx)
                                            [LclId] =
                                                [$dMonad_sfPpC] \u []
                                                    GHC.Base.return
                                                        $dMonad_sfPpC Data.Semigroup.$fDataArg1;
                                          } in  k_sfPpG $dData_sfPpw sat_sfPpY a1_sfPpE;
                                } in  k_sfPpG $dData1_sfPpx sat_sfPpZ a2_sfPpF;
                          };
                } in  GHC.Base.>>= $dMonad_sfPpC sat_sfPq0 sat_sfPq6;
          };

Data.Semigroup.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> a -> b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfPq7 w1_sfPq8 w2_sfPq9 w3_sfPqa ww_sfPqb ww1_sfPqc]
        let {
          k_sfPqd [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
            :: forall d b1.
               Data.Data.Data d =>
               m_sfBu8 (d -> b1) -> d -> m_sfBu8 b1
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w2_sfPq9 w3_sfPqa] \r [$dData1_sfPqe c_sfPqf x_sfPqg]
                  let {
                    lvl33_sfPqh [Occ=OnceL] :: m_sfBu8 d_ae2Vh
                    [LclId] =
                        [w3_sfPqa $dData1_sfPqe x_sfPqg] \u []
                            w3_sfPqa $dData1_sfPqe x_sfPqg; } in
                  let {
                    sat_sfPqm [Occ=Once] :: (d_ae2Vh -> b1_ae2Vi) -> m_sfBu8 b1_ae2Vi
                    [LclId] =
                        [w2_sfPq9 lvl33_sfPqh] \r [c'_sfPqi]
                            let {
                              sat_sfPql [Occ=Once] :: d_ae2Vh -> m_sfBu8 b1_ae2Vi
                              [LclId] =
                                  [w2_sfPq9 c'_sfPqi] \r [x'_sfPqj]
                                      let {
                                        sat_sfPqk [Occ=Once] :: b1_ae2Vi
                                        [LclId] =
                                            [c'_sfPqi x'_sfPqj] \u [] c'_sfPqi x'_sfPqj;
                                      } in  GHC.Base.return w2_sfPq9 sat_sfPqk;
                            } in  GHC.Base.>>= w2_sfPq9 lvl33_sfPqh sat_sfPql;
                  } in  GHC.Base.>>= w2_sfPq9 c_sfPqf sat_sfPqm; } in
        let {
          sat_sfPqo [Occ=Once]
            :: m_sfBu8 (b_sfBu5 -> Data.Semigroup.Arg a_sfBu4 b_sfBu5)
          [LclId] =
              [w_sfPq7 w2_sfPq9 ww_sfPqb k_sfPqd] \u []
                  let {
                    sat_sfPqn [Occ=Once]
                      :: m_sfBu8 (a_sfBu4
                                  -> b_sfBu5 -> Data.Semigroup.Arg a_sfBu4 b_sfBu5)
                    [LclId] =
                        [w2_sfPq9] \u [] GHC.Base.return w2_sfPq9 Data.Semigroup.Arg;
                  } in  k_sfPqd w_sfPq7 sat_sfPqn ww_sfPqb;
        } in  k_sfPqd w1_sfPq8 sat_sfPqo ww1_sfPqc;

Data.Semigroup.$fDataArg_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Arg a b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sfPqp w1_sfPqq w2_sfPqr w3_sfPqs w4_sfPqt]
        case w4_sfPqt of {
          Data.Semigroup.Arg ww1_sfPqv [Occ=Once] ww2_sfPqw [Occ=Once] ->
              Data.Semigroup.$w$cgmapM
                  w_sfPqp w1_sfPqq w2_sfPqr w3_sfPqs ww1_sfPqv ww2_sfPqw;
        };

Data.Semigroup.$fDataArg_$cgmapQi
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Arg a b
     -> u
[GblId,
 Arity=5,
 Str=<L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPqx $dData1_sfPqy ds_sfPqz ds1_sfPqA x_sfPqB]
        case x_sfPqB of {
          Data.Semigroup.Arg a1_sfPqD [Occ=Once] a2_sfPqE [Occ=Once] ->
              case ds_sfPqz of {
                GHC.Types.I# x1_sfPqG [Occ=Once!] ->
                    case x1_sfPqG of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sfPqA $dData_sfPqx a1_sfPqD;
                      1# -> ds1_sfPqA $dData1_sfPqy a2_sfPqE;
                    };
              };
        };

Data.Semigroup.$fDataArg_$cgmapQr
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Arg a b
     -> r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPqI
           $dData1_sfPqJ
           ds_sfPqK
           ds1_sfPqL
           ds2_sfPqM
           x0_sfPqN]
        case x0_sfPqN of {
          Data.Semigroup.Arg a1_sfPqP [Occ=Once] a2_sfPqQ [Occ=Once] ->
              let {
                sat_sfPqT [Occ=Once] :: r_afxPQ
                [LclId] =
                    [$dData1_sfPqJ ds_sfPqK ds1_sfPqL ds2_sfPqM a2_sfPqQ] \u []
                        let {
                          sat_sfPqS [Occ=Once] :: r'_afxPR
                          [LclId] =
                              [$dData1_sfPqJ ds2_sfPqM a2_sfPqQ] \u []
                                  ds2_sfPqM $dData1_sfPqJ a2_sfPqQ;
                        } in  ds_sfPqK sat_sfPqS ds1_sfPqL; } in
              let {
                sat_sfPqR [Occ=Once] :: r'_afxPR
                [LclId] =
                    [$dData_sfPqI ds2_sfPqM a1_sfPqP] \u []
                        ds2_sfPqM $dData_sfPqI a1_sfPqP;
              } in  ds_sfPqK sat_sfPqR sat_sfPqT;
        };

Data.Semigroup.$fDataArg_$cgmapQ
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Arg a b -> [u]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,C(C1(U))><S,1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [$dData_sfPqU $dData1_sfPqV ds_sfPqW x0_sfPqX]
        case x0_sfPqX of {
          Data.Semigroup.Arg a1_sfPqZ [Occ=Once] a2_sfPr0 [Occ=Once] ->
              let {
                sat_sfPr2 [Occ=Once] :: u_afxQ7
                [LclId] =
                    [$dData1_sfPqV ds_sfPqW a2_sfPr0] \u []
                        ds_sfPqW $dData1_sfPqV a2_sfPr0; } in
              let {
                sat_sfPr3 [Occ=Once] :: [u_afxQ7]
                [LclId] =
                    CCCS :! [sat_sfPr2 GHC.Types.[]]; } in
              let {
                sat_sfPr1 [Occ=Once] :: u_afxQ7
                [LclId] =
                    [$dData_sfPqU ds_sfPqW a1_sfPqZ] \u []
                        ds_sfPqW $dData_sfPqU a1_sfPqZ;
              } in  : [sat_sfPr1 sat_sfPr3];
        };

Data.Semigroup.$fDataArg2
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Arg a b
     -> Data.Functor.Const.Const r (Data.Semigroup.Arg a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPr4
           $dData1_sfPr5
           ds_sfPr6
           ds1_sfPr7
           ds2_sfPr8
           eta_sfPr9]
        case eta_sfPr9 of {
          Data.Semigroup.Arg a1_sfPrb [Occ=Once] a2_sfPrc [Occ=Once] ->
              let {
                sat_sfPrf [Occ=Once] :: r'_afxPA
                [LclId] =
                    [$dData1_sfPr5 ds2_sfPr8 a2_sfPrc] \u []
                        ds2_sfPr8 $dData1_sfPr5 a2_sfPrc; } in
              let {
                sat_sfPre [Occ=Once] :: r_afxPz
                [LclId] =
                    [$dData_sfPr4 ds_sfPr6 ds1_sfPr7 ds2_sfPr8 a1_sfPrb] \u []
                        let {
                          sat_sfPrd [Occ=Once] :: r'_afxPA
                          [LclId] =
                              [$dData_sfPr4 ds2_sfPr8 a1_sfPrb] \u []
                                  ds2_sfPr8 $dData_sfPr4 a1_sfPrb;
                        } in  ds_sfPr6 ds1_sfPr7 sat_sfPrd;
              } in  ds_sfPr6 sat_sfPre sat_sfPrf;
        };

Data.Semigroup.$fDataArg3
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     (forall b1. Data.Data.Data b1 => b1 -> b1)
     -> Data.Semigroup.Arg a b
     -> Data.Functor.Identity.Identity (Data.Semigroup.Arg a b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,C(C1(U))><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dData_sfPrg $dData1_sfPrh ds_sfPri x0_sfPrj]
        case x0_sfPrj of {
          Data.Semigroup.Arg a1_sfPrl [Occ=Once] a2_sfPrm [Occ=Once] ->
              let {
                sat_sfPro [Occ=Once] :: b_Xfygr
                [LclId] =
                    [$dData1_sfPrh ds_sfPri a2_sfPrm] \u []
                        ds_sfPri $dData1_sfPrh a2_sfPrm; } in
              let {
                sat_sfPrn [Occ=Once] :: a_Xfygp
                [LclId] =
                    [$dData_sfPrg ds_sfPri a1_sfPrl] \u []
                        ds_sfPri $dData_sfPrg a1_sfPrl;
              } in  Data.Semigroup.Arg [sat_sfPrn sat_sfPro];
        };

Data.Semigroup.$fDataArg_$cgmapMo
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Arg a b -> m (Data.Semigroup.Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPrp
           $dData1_sfPrq
           $dMonadPlus_sfPrr
           ds_sfPrs
           eta_sfPrt]
        let {
          lvl33_sfPru [Occ=OnceL]
            :: m_afxR5 (Data.Semigroup.Arg a_Xfygo b_XfyDI)
          [LclId] =
              [$dMonadPlus_sfPrr] \u [] GHC.Base.mzero $dMonadPlus_sfPrr;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPrr
          of
          $dMonad_sfPrv [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPs2 [Occ=Once]
                    :: (Data.Semigroup.Arg a_Xfygo b_XfyDI, GHC.Types.Bool)
                       -> m_afxR5 (Data.Semigroup.Arg a_Xfygo b_XfyDI)
                  [LclId] =
                      [lvl33_sfPru $dMonad_sfPrv] \r [ds1_sfPrX]
                          case ds1_sfPrX of {
                            (,) x'_sfPrZ [Occ=Once] b1_sfPs0 [Occ=Once!] ->
                                case b1_sfPs0 of {
                                  GHC.Types.False -> lvl33_sfPru;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPrv x'_sfPrZ;
                                };
                          }; } in
                let {
                  sat_sfPrW [Occ=Once]
                    :: m_afxR5 (Data.Semigroup.Arg a_Xfygo b_XfyDI, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPrp
                       $dData1_sfPrq
                       $dMonadPlus_sfPrr
                       ds_sfPrs
                       eta_sfPrt
                       $dMonad_sfPrv] \u []
                          case eta_sfPrt of {
                            Data.Semigroup.Arg a1_sfPrx [Occ=Once] a2_sfPry [Occ=Once] ->
                                let {
                                  k_sfPrz [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b1.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_afxR5 (d -> b1)
                                       -> d -> m_afxR5 (b1, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sfPrr
                                                ds_sfPrs
                                                $dMonad_sfPrv] \r [$dData2_sfPrA ds1_sfPrB y_sfPrC]
                                          let {
                                            lvl34_sfPrD [Occ=OnceL] :: m_afxR5 d_ae2Ya
                                            [LclId] =
                                                [ds_sfPrs $dData2_sfPrA y_sfPrC] \u []
                                                    ds_sfPrs $dData2_sfPrA y_sfPrC; } in
                                          let {
                                            sat_sfPrT [Occ=Once]
                                              :: (d_ae2Ya -> b1_ae2Yb, GHC.Types.Bool)
                                                 -> m_afxR5 (b1_ae2Yb, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sfPrr
                                                 $dMonad_sfPrv
                                                 y_sfPrC
                                                 lvl34_sfPrD] \r [ds2_sfPrE]
                                                    case ds2_sfPrE of {
                                                      (,) h_sfPrG b2_sfPrH [Occ=Once!] ->
                                                          case b2_sfPrH of {
                                                            GHC.Types.False ->
                                                                let {
                                                                  sat_sfPrQ [Occ=Once]
                                                                    :: m_afxR5 (b1_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sfPrv
                                                                       y_sfPrC
                                                                       h_sfPrG] \u []
                                                                          let {
                                                                            sat_sfPrO [Occ=Once]
                                                                              :: b1_ae2Yb
                                                                            [LclId] =
                                                                                [y_sfPrC
                                                                                 h_sfPrG] \u []
                                                                                    h_sfPrG
                                                                                        y_sfPrC; } in
                                                                          let {
                                                                            sat_sfPrP [Occ=Once]
                                                                              :: (b1_ae2Yb,
                                                                                  GHC.Types.Bool)
                                                                            [LclId] =
                                                                                CCCS (,)! [sat_sfPrO
                                                                                           GHC.Types.False];
                                                                          } in 
                                                                            GHC.Base.return
                                                                                $dMonad_sfPrv
                                                                                sat_sfPrP; } in
                                                                let {
                                                                  sat_sfPrN [Occ=Once]
                                                                    :: m_afxR5 (b1_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sfPrv
                                                                       lvl34_sfPrD
                                                                       h_sfPrG] \u []
                                                                          let {
                                                                            sat_sfPrM [Occ=Once]
                                                                              :: d_ae2Ya
                                                                                 -> m_afxR5 (b1_ae2Yb,
                                                                                             GHC.Types.Bool)
                                                                            [LclId] =
                                                                                [$dMonad_sfPrv
                                                                                 h_sfPrG] \r [y'_sfPrJ]
                                                                                    let {
                                                                                      sat_sfPrK [Occ=Once]
                                                                                        :: b1_ae2Yb
                                                                                      [LclId] =
                                                                                          [h_sfPrG
                                                                                           y'_sfPrJ] \u []
                                                                                              h_sfPrG
                                                                                                  y'_sfPrJ; } in
                                                                                    let {
                                                                                      sat_sfPrL [Occ=Once]
                                                                                        :: (b1_ae2Yb,
                                                                                            GHC.Types.Bool)
                                                                                      [LclId] =
                                                                                          CCCS (,)! [sat_sfPrK
                                                                                                     GHC.Types.True];
                                                                                    } in 
                                                                                      GHC.Base.return
                                                                                          $dMonad_sfPrv
                                                                                          sat_sfPrL;
                                                                          } in 
                                                                            GHC.Base.>>=
                                                                                $dMonad_sfPrv
                                                                                lvl34_sfPrD
                                                                                sat_sfPrM;
                                                                } in 
                                                                  GHC.Base.mplus
                                                                      $dMonadPlus_sfPrr
                                                                      sat_sfPrN
                                                                      sat_sfPrQ;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_sfPrR [Occ=Once] :: b1_ae2Yb
                                                                  [LclId] =
                                                                      [y_sfPrC h_sfPrG] \u []
                                                                          h_sfPrG y_sfPrC; } in
                                                                let {
                                                                  sat_sfPrS [Occ=Once]
                                                                    :: (b1_ae2Yb, GHC.Types.Bool)
                                                                  [LclId] =
                                                                      CCCS (,)! [sat_sfPrR
                                                                                 GHC.Types.True];
                                                                } in 
                                                                  GHC.Base.return
                                                                      $dMonad_sfPrv sat_sfPrS;
                                                          };
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sfPrv ds1_sfPrB sat_sfPrT; } in
                                let {
                                  sat_sfPrV [Occ=Once]
                                    :: Data.Data.Mp
                                         m_afxR5 (b_XfyDI -> Data.Semigroup.Arg a_Xfygo b_XfyDI)
                                  [LclId] =
                                      [$dData_sfPrp $dMonad_sfPrv a1_sfPrx k_sfPrz] \u []
                                          let {
                                            sat_sfPrU [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_afxR5
                                                   (a_Xfygo
                                                    -> b_XfyDI
                                                    -> Data.Semigroup.Arg a_Xfygo b_XfyDI)
                                            [LclId] =
                                                [$dMonad_sfPrv] \u []
                                                    GHC.Base.return
                                                        $dMonad_sfPrv Data.Semigroup.$fDataArg1;
                                          } in  k_sfPrz $dData_sfPrp sat_sfPrU a1_sfPrx;
                                } in  k_sfPrz $dData1_sfPrq sat_sfPrV a2_sfPry;
                          };
                } in  GHC.Base.>>= $dMonad_sfPrv sat_sfPrW sat_sfPs2;
          };

lvl18_rfC6Z
  :: forall b a. Data.Semigroup.Arg a b -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_sfPs3]
        case ds_sfPs3 of {
          Data.Semigroup.Arg _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Semigroup.$cArg;
        };

lvl19_rfC70
  :: forall a b. Data.Semigroup.Arg a b -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPs7] Data.Semigroup.$tArg;

lvl20_rfC71
  :: forall a b (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Arg a b))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPs8 ds_sfPs9] GHC.Base.Nothing [];

Data.Semigroup.$fDataArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (Data.Data.Data a, Data.Data.Data b) =>
     Data.Data.Data (Data.Semigroup.Arg a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPsa $dData1_sfPsb]
        let {
          sat_sfPsn [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> m (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapMo
                      $dData_sfPsa $dData1_sfPsb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsm [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> m (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapMp
                      $dData_sfPsa $dData1_sfPsb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsl [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> m (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapM
                      $dData_sfPsa $dData1_sfPsb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsk [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> u
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapQi
                      $dData_sfPsa $dData1_sfPsb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsj [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI -> [u]
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapQ
                      $dData_sfPsa $dData1_sfPsb eta_B2 eta_B1; } in
        let {
          sat_sfPsi [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> r
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgmapQr
                      $dData_sfPsa $dData1_sfPsb eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsh [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> r
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg2
                      $dData_sfPsa $dData1_sfPsb eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsg [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg3
                      $dData_sfPsa $dData1_sfPsb eta_B2 eta_B1; } in
        let {
          sat_sfPsf [Occ=Once]
            :: forall (t :: * -> * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
               -> GHC.Base.Maybe (c (Data.Semigroup.Arg a_Xfygn b_XfyDI))
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B1]
                  Data.Semigroup.$fDataArg_$cdataCast2
                      $dData_sfPsa $dData1_sfPsb eta_B1; } in
        let {
          sat_sfPse [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgunfold
                      $dData_sfPsa $dData1_sfPsb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsd [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Arg a_Xfygn b_XfyDI
               -> c (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataArg_$cgfoldl
                      $dData_sfPsa $dData1_sfPsb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPsc [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Semigroup.Arg a_Xfygn b_XfyDI)
          [LclId] =
              [$dData_sfPsa $dData1_sfPsb] \u []
                  Data.Semigroup.$fDataArg10 $dData_sfPsa $dData1_sfPsb;
        } in 
          Data.Data.C:Data [sat_sfPsc
                            sat_sfPsd
                            sat_sfPse
                            lvl18_rfC6Z
                            lvl19_rfC70
                            lvl20_rfC71
                            sat_sfPsf
                            sat_sfPsg
                            sat_sfPsh
                            sat_sfPsi
                            sat_sfPsj
                            sat_sfPsk
                            sat_sfPsl
                            sat_sfPsm
                            sat_sfPsn];

Data.Semigroup.$fDataFirst3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataFirst4];

Data.Semigroup.$tcFirst :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5289672677956055491##
                                    1507157566582617174##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataFirst3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep10_rfC72 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcFirst
                                              $krep2_rfC6L];

Data.Semigroup.$tc'First1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep10_rfC72];

Data.Semigroup.$tc'First3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'First"#;

Data.Semigroup.$tc'First2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'First3];

Data.Semigroup.$tc'First :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14746522314279732838##
                                    14022550265149674723##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'First2
                                    1#
                                    Data.Semigroup.$tc'First1];

Data.Semigroup.$fDataFirst2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.First
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                5289672677956055491##
                1507157566582617174##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataFirst3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPsp [Occ=Once]
                   ww9_sfPsq [Occ=Once]
                   ww10_sfPsr [Occ=Once]
                   ww11_sfPss [Occ=Once]
                   ww12_sfPst [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPsp
                                              ww9_sfPsq
                                              ww10_sfPsr
                                              ww11_sfPss
                                              ww12_sfPst];
        };

Data.Semigroup.$fDataFirst8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.First a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPsu]
        case Data.Data.$p1Data $dData_sfPsu of sat_sfPsv {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataFirst2 sat_sfPsv;
        };

Data.Semigroup.$fDataFirst_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.First a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPsw $dTypeable_sfPsx]
        let {
          lvl33_sfPsy [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPsx] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPsx Data.Semigroup.$fDataFirst2; } in
        let {
          sat_sfPsC [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afxYL (t_afxYK d))
               -> GHC.Base.Maybe (c_afxYL (Data.Semigroup.First a_XfyqV))
          [LclId] =
              [$dData_sfPsw lvl33_sfPsy] \r [f_sfPsz]
                  case lvl33_sfPsy of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPsB [Occ=Once] :: c_afxYL (Data.Semigroup.First a_XfyqV)
                          [LclId] =
                              [$dData_sfPsw f_sfPsz] \u [] f_sfPsz $dData_sfPsw;
                        } in  GHC.Base.Just [sat_sfPsB];
                  };
        } in  sat_sfPsC;

Data.Semigroup.$fDataFirst1
  :: forall a. (a -> Data.Semigroup.First a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataFirst_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.First a -> m (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPsD $dMonadPlus_sfPsE ds_sfPsF eta_sfPsG]
        let {
          lvl33_sfPsH [Occ=OnceL] :: m_afy0Q (Data.Semigroup.First a_Xfyr4)
          [LclId] =
              [$dMonadPlus_sfPsE] \u [] GHC.Base.mzero $dMonadPlus_sfPsE;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPsE
          of
          $dMonad_sfPsI [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPt4 [Occ=Once]
                    :: (Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                       -> m_afy0Q (Data.Semigroup.First a_Xfyr4)
                  [LclId] =
                      [lvl33_sfPsH $dMonad_sfPsI] \r [ds1_sfPsZ]
                          case ds1_sfPsZ of {
                            (,) x'_sfPt1 [Occ=Once] b_sfPt2 [Occ=Once!] ->
                                case b_sfPt2 of {
                                  GHC.Types.False -> lvl33_sfPsH;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPsI x'_sfPt1;
                                };
                          }; } in
                let {
                  sat_sfPsY [Occ=Once]
                    :: m_afy0Q (Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPsD
                       $dMonadPlus_sfPsE
                       ds_sfPsF
                       eta_sfPsG
                       $dMonad_sfPsI] \u []
                          let {
                            lvl34_sfPsJ [Occ=OnceL] :: m_afy0Q a_Xfyr4
                            [LclId] =
                                [$dData_sfPsD ds_sfPsF eta_sfPsG] \u []
                                    ds_sfPsF $dData_sfPsD eta_sfPsG; } in
                          let {
                            sat_sfPsX [Occ=Once]
                              :: (a_Xfyr4 -> Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                                 -> m_afy0Q (Data.Semigroup.First a_Xfyr4, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPsE
                                 eta_sfPsG
                                 $dMonad_sfPsI
                                 lvl34_sfPsJ] \r [ds1_sfPsL]
                                    case ds1_sfPsL of {
                                      (,) h_sfPsN b1_sfPsO [Occ=Once] ->
                                          let {
                                            sat_sfPsW [Occ=Once]
                                              :: m_afy0Q (Data.Semigroup.First a_Xfyr4,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfPsG $dMonad_sfPsI h_sfPsN b1_sfPsO] \u []
                                                    let {
                                                      sat_sfPsU [Occ=Once]
                                                        :: Data.Semigroup.First a_Xfyr4
                                                      [LclId] =
                                                          [eta_sfPsG h_sfPsN] \u []
                                                              h_sfPsN eta_sfPsG; } in
                                                    let {
                                                      sat_sfPsV [Occ=Once]
                                                        :: (Data.Semigroup.First a_Xfyr4,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfPsU b1_sfPsO];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfPsI sat_sfPsV; } in
                                          let {
                                            sat_sfPsT [Occ=Once]
                                              :: m_afy0Q (Data.Semigroup.First a_Xfyr4,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfPsI lvl34_sfPsJ h_sfPsN] \u []
                                                    let {
                                                      sat_sfPsS [Occ=Once]
                                                        :: a_Xfyr4
                                                           -> m_afy0Q (Data.Semigroup.First a_Xfyr4,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfPsI h_sfPsN] \r [y'_sfPsP]
                                                              let {
                                                                sat_sfPsQ [Occ=Once]
                                                                  :: Data.Semigroup.First a_Xfyr4
                                                                [LclId] =
                                                                    [h_sfPsN y'_sfPsP] \u []
                                                                        h_sfPsN y'_sfPsP; } in
                                                              let {
                                                                sat_sfPsR [Occ=Once]
                                                                  :: (Data.Semigroup.First a_Xfyr4,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfPsQ
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfPsI sat_sfPsR;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfPsI lvl34_sfPsJ sat_sfPsS;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfPsE sat_sfPsT sat_sfPsW;
                                    }; } in
                          let {
                            sat_sfPsK [Occ=Once]
                              :: m_afy0Q (a_Xfyr4 -> Data.Semigroup.First a_Xfyr4,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPsI] \u []
                                    GHC.Base.return $dMonad_sfPsI Data.Semigroup.$fDataFirst1;
                          } in  GHC.Base.>>= $dMonad_sfPsI sat_sfPsK sat_sfPsX;
                } in  GHC.Base.>>= $dMonad_sfPsI sat_sfPsY sat_sfPt4;
          };

Data.Semigroup.$fDataFirst_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.First a -> m (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPt5 $dMonad_sfPt6 ds_sfPt7 eta_sfPt8]
        let {
          lvl33_sfPt9 [Occ=OnceL] :: m_afy0A a_Xfyr3
          [LclId] =
              [$dData_sfPt5 ds_sfPt7 eta_sfPt8] \u []
                  ds_sfPt7 $dData_sfPt5 eta_sfPt8; } in
        let {
          sat_sfPtf [Occ=Once]
            :: (a_Xfyr3 -> Data.Semigroup.First a_Xfyr3)
               -> m_afy0A (Data.Semigroup.First a_Xfyr3)
          [LclId] =
              [$dMonad_sfPt6 lvl33_sfPt9] \r [c'_sfPtb]
                  let {
                    sat_sfPte [Occ=Once]
                      :: a_Xfyr3 -> m_afy0A (Data.Semigroup.First a_Xfyr3)
                    [LclId] =
                        [$dMonad_sfPt6 c'_sfPtb] \r [x'_sfPtc]
                            let {
                              sat_sfPtd [Occ=Once] :: Data.Semigroup.First a_Xfyr3
                              [LclId] =
                                  [c'_sfPtb x'_sfPtc] \u [] c'_sfPtb x'_sfPtc;
                            } in  GHC.Base.return $dMonad_sfPt6 sat_sfPtd;
                  } in  GHC.Base.>>= $dMonad_sfPt6 lvl33_sfPt9 sat_sfPte; } in
        let {
          sat_sfPta [Occ=Once]
            :: m_afy0A (a_Xfyr3 -> Data.Semigroup.First a_Xfyr3)
          [LclId] =
              [$dMonad_sfPt6] \u []
                  GHC.Base.return $dMonad_sfPt6 Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfPt6 sat_sfPta sat_sfPtf;

Data.Semigroup.$fDataFirst_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.First a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPtg ds_sfPth ds1_sfPti x_sfPtj]
        case ds_sfPth of {
          GHC.Types.I# x1_sfPtl [Occ=Once!] ->
              case x1_sfPtl of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfPti $dData_sfPtg x_sfPtj;
              };
        };

Data.Semigroup.$fDataFirst_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.First a -> m (Data.Semigroup.First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPtn $dMonadPlus_sfPto ds_sfPtp eta_sfPtq]
        let {
          lvl33_sfPtr [Occ=OnceL] :: m_afy16 (Data.Semigroup.First a_XfyqX)
          [LclId] =
              [$dMonadPlus_sfPto] \u [] GHC.Base.mzero $dMonadPlus_sfPto;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPto
          of
          $dMonad_sfPts [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPtR [Occ=Once]
                    :: (Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                       -> m_afy16 (Data.Semigroup.First a_XfyqX)
                  [LclId] =
                      [lvl33_sfPtr $dMonad_sfPts] \r [ds1_sfPtM]
                          case ds1_sfPtM of {
                            (,) x'_sfPtO [Occ=Once] b_sfPtP [Occ=Once!] ->
                                case b_sfPtP of {
                                  GHC.Types.False -> lvl33_sfPtr;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPts x'_sfPtO;
                                };
                          }; } in
                let {
                  sat_sfPtL [Occ=Once]
                    :: m_afy16 (Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPtn
                       $dMonadPlus_sfPto
                       ds_sfPtp
                       eta_sfPtq
                       $dMonad_sfPts] \u []
                          let {
                            lvl34_sfPtt [Occ=OnceL] :: m_afy16 a_XfyqX
                            [LclId] =
                                [$dData_sfPtn ds_sfPtp eta_sfPtq] \u []
                                    ds_sfPtp $dData_sfPtn eta_sfPtq; } in
                          let {
                            sat_sfPtK [Occ=Once]
                              :: (a_XfyqX -> Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                                 -> m_afy16 (Data.Semigroup.First a_XfyqX, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPto
                                 eta_sfPtq
                                 $dMonad_sfPts
                                 lvl34_sfPtt] \r [ds1_sfPtv]
                                    case ds1_sfPtv of {
                                      (,) h_sfPtx b1_sfPty [Occ=Once!] ->
                                          case b1_sfPty of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfPtH [Occ=Once]
                                                    :: m_afy16 (Data.Semigroup.First a_XfyqX,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfPtq $dMonad_sfPts h_sfPtx] \u []
                                                          let {
                                                            sat_sfPtF [Occ=Once]
                                                              :: Data.Semigroup.First a_XfyqX
                                                            [LclId] =
                                                                [eta_sfPtq h_sfPtx] \u []
                                                                    h_sfPtx eta_sfPtq; } in
                                                          let {
                                                            sat_sfPtG [Occ=Once]
                                                              :: (Data.Semigroup.First a_XfyqX,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfPtF
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfPts sat_sfPtG; } in
                                                let {
                                                  sat_sfPtE [Occ=Once]
                                                    :: m_afy16 (Data.Semigroup.First a_XfyqX,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfPts lvl34_sfPtt h_sfPtx] \u []
                                                          let {
                                                            sat_sfPtD [Occ=Once]
                                                              :: a_XfyqX
                                                                 -> m_afy16 (Data.Semigroup.First
                                                                               a_XfyqX,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPts
                                                                 h_sfPtx] \r [y'_sfPtA]
                                                                    let {
                                                                      sat_sfPtB [Occ=Once]
                                                                        :: Data.Semigroup.First
                                                                             a_XfyqX
                                                                      [LclId] =
                                                                          [h_sfPtx y'_sfPtA] \u []
                                                                              h_sfPtx y'_sfPtA; } in
                                                                    let {
                                                                      sat_sfPtC [Occ=Once]
                                                                        :: (Data.Semigroup.First
                                                                              a_XfyqX,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPtB
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPts sat_sfPtC;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfPts lvl34_sfPtt sat_sfPtD;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfPto sat_sfPtE sat_sfPtH;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfPtI [Occ=Once]
                                                    :: Data.Semigroup.First a_XfyqX
                                                  [LclId] =
                                                      [eta_sfPtq h_sfPtx] \u []
                                                          h_sfPtx eta_sfPtq; } in
                                                let {
                                                  sat_sfPtJ [Occ=Once]
                                                    :: (Data.Semigroup.First a_XfyqX,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfPtI GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfPts sat_sfPtJ;
                                          };
                                    }; } in
                          let {
                            sat_sfPtu [Occ=Once]
                              :: m_afy16 (a_XfyqX -> Data.Semigroup.First a_XfyqX,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPts] \u []
                                    GHC.Base.return $dMonad_sfPts Data.Semigroup.$fDataFirst1;
                          } in  GHC.Base.>>= $dMonad_sfPts sat_sfPtu sat_sfPtK;
                } in  GHC.Base.>>= $dMonad_sfPts sat_sfPtL sat_sfPtR;
          };

lvl21_rfC73 :: forall a. Data.Semigroup.First a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPtS] Data.Semigroup.$cFirst;

lvl22_rfC74
  :: forall a. Data.Semigroup.First a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPtT] Data.Semigroup.$tFirst;

lvl23_rfC75
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.First a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPtU ds_sfPtV] GHC.Base.Nothing [];

Data.Semigroup.$fDataFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.First a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPtW]
        let {
          sat_sfPur [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.First a_XfyqW -> m (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfPtW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapMo
                      $dData_sfPtW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPuq [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.First a_XfyqW -> m (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfPtW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapMp
                      $dData_sfPtW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPup [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.First a_XfyqW -> m (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfPtW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapM
                      $dData_sfPtW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPuo [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.First a_XfyqW
               -> u
          [LclId] =
              [$dData_sfPtW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgmapQi
                      $dData_sfPtW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPun [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.First a_XfyqW -> [u]
          [LclId] =
              [$dData_sfPtW] \r [ds_sfPuk x0_sfPul]
                  let {
                    sat_sfPum [Occ=Once] :: u_afy08
                    [LclId] =
                        [$dData_sfPtW ds_sfPuk x0_sfPul] \u []
                            ds_sfPuk $dData_sfPtW x0_sfPul;
                  } in  : [sat_sfPum GHC.Types.[]]; } in
        let {
          sat_sfPuj [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.First a_XfyqW
               -> r
          [LclId] =
              [$dData_sfPtW] \r [ds_sfPue ds1_sfPuf ds2_sfPug x0_sfPuh]
                  let {
                    sat_sfPui [Occ=Once] :: r'_afxZS
                    [LclId] =
                        [$dData_sfPtW ds2_sfPug x0_sfPuh] \u []
                            ds2_sfPug $dData_sfPtW x0_sfPuh;
                  } in  ds_sfPue sat_sfPui ds1_sfPuf; } in
        let {
          sat_sfPud [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.First a_XfyqW
               -> r
          [LclId] =
              [$dData_sfPtW] \r [ds_sfPu8 ds1_sfPu9 ds2_sfPua eta_sfPub]
                  let {
                    sat_sfPuc [Occ=Once] :: r'_afxZB
                    [LclId] =
                        [$dData_sfPtW ds2_sfPua eta_sfPub] \u []
                            ds2_sfPua $dData_sfPtW eta_sfPub;
                  } in  ds_sfPu8 ds1_sfPu9 sat_sfPuc; } in
        let {
          sat_sfPu7 [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.First a_XfyqW -> Data.Semigroup.First a_XfyqW
          [LclId] =
              [$dData_sfPtW] \r [ds_sfPu5 x0_sfPu6]
                  ds_sfPu5 $dData_sfPtW x0_sfPu6; } in
        let {
          sat_sfPu4 [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.First a_XfyqW))
          [LclId] =
              [$dData_sfPtW] \r [eta_B1]
                  Data.Semigroup.$fDataFirst_$cdataCast1 $dData_sfPtW eta_B1; } in
        let {
          sat_sfPu3 [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfPtW] \r [k_sfPtZ z_sfPu0 ds_sfPu1]
                  let {
                    sat_sfPu2 [Occ=Once]
                      :: c_afxYr (a_XfyqW -> Data.Semigroup.First a_XfyqW)
                    [LclId] =
                        [z_sfPu0] \u [] z_sfPu0 Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfPtZ $dData_sfPtW sat_sfPu2; } in
        let {
          sat_sfPtY [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.First a_XfyqW
               -> c (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfPtW] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataFirst_$cgfoldl
                      $dData_sfPtW eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPtX [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.First a_XfyqW)
          [LclId] =
              [$dData_sfPtW] \u [] Data.Semigroup.$fDataFirst8 $dData_sfPtW;
        } in 
          Data.Data.C:Data [sat_sfPtX
                            sat_sfPtY
                            sat_sfPu3
                            lvl21_rfC73
                            lvl22_rfC74
                            sat_sfPu4
                            lvl23_rfC75
                            sat_sfPu7
                            sat_sfPud
                            sat_sfPuj
                            sat_sfPun
                            sat_sfPuo
                            sat_sfPup
                            sat_sfPuq
                            sat_sfPur];

Data.Semigroup.$fDataLast3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataLast4];

Data.Semigroup.$tcLast :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11434676963974803827##
                                    15911814017027463598##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataLast3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep11_rfC76 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcLast
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Last1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep11_rfC76];

Data.Semigroup.$tc'Last3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Last"#;

Data.Semigroup.$tc'Last2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Last3];

Data.Semigroup.$tc'Last :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3320600960953447003##
                                    12383530634546204472##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Last2
                                    1#
                                    Data.Semigroup.$tc'Last1];

Data.Semigroup.$fDataLast2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Last
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                11434676963974803827##
                15911814017027463598##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataLast3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPut [Occ=Once]
                   ww9_sfPuu [Occ=Once]
                   ww10_sfPuv [Occ=Once]
                   ww11_sfPuw [Occ=Once]
                   ww12_sfPux [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPut
                                              ww9_sfPuu
                                              ww10_sfPuv
                                              ww11_sfPuw
                                              ww12_sfPux];
        };

Data.Semigroup.$fDataLast8
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Last a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPuy]
        case Data.Data.$p1Data $dData_sfPuy of sat_sfPuz {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataLast2 sat_sfPuz;
        };

Data.Semigroup.$fDataLast_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Last a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPuA $dTypeable_sfPuB]
        let {
          lvl33_sfPuC [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPuB] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPuB Data.Semigroup.$fDataLast2; } in
        let {
          sat_sfPuG [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afy7N (t_afy7M d))
               -> GHC.Base.Maybe (c_afy7N (Data.Semigroup.Last a_XfyAl))
          [LclId] =
              [$dData_sfPuA lvl33_sfPuC] \r [f_sfPuD]
                  case lvl33_sfPuC of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPuF [Occ=Once] :: c_afy7N (Data.Semigroup.Last a_XfyAl)
                          [LclId] =
                              [$dData_sfPuA f_sfPuD] \u [] f_sfPuD $dData_sfPuA;
                        } in  GHC.Base.Just [sat_sfPuF];
                  };
        } in  sat_sfPuG;

Data.Semigroup.$fDataLast1
  :: forall a. (a -> Data.Semigroup.Last a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataLast_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Last a -> m (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPuH $dMonadPlus_sfPuI ds_sfPuJ eta_sfPuK]
        let {
          lvl33_sfPuL [Occ=OnceL] :: m_afy9S (Data.Semigroup.Last a_XfyAu)
          [LclId] =
              [$dMonadPlus_sfPuI] \u [] GHC.Base.mzero $dMonadPlus_sfPuI;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPuI
          of
          $dMonad_sfPuM [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPv8 [Occ=Once]
                    :: (Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                       -> m_afy9S (Data.Semigroup.Last a_XfyAu)
                  [LclId] =
                      [lvl33_sfPuL $dMonad_sfPuM] \r [ds1_sfPv3]
                          case ds1_sfPv3 of {
                            (,) x'_sfPv5 [Occ=Once] b_sfPv6 [Occ=Once!] ->
                                case b_sfPv6 of {
                                  GHC.Types.False -> lvl33_sfPuL;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPuM x'_sfPv5;
                                };
                          }; } in
                let {
                  sat_sfPv2 [Occ=Once]
                    :: m_afy9S (Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPuH
                       $dMonadPlus_sfPuI
                       ds_sfPuJ
                       eta_sfPuK
                       $dMonad_sfPuM] \u []
                          let {
                            lvl34_sfPuN [Occ=OnceL] :: m_afy9S a_XfyAu
                            [LclId] =
                                [$dData_sfPuH ds_sfPuJ eta_sfPuK] \u []
                                    ds_sfPuJ $dData_sfPuH eta_sfPuK; } in
                          let {
                            sat_sfPv1 [Occ=Once]
                              :: (a_XfyAu -> Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                                 -> m_afy9S (Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPuI
                                 eta_sfPuK
                                 $dMonad_sfPuM
                                 lvl34_sfPuN] \r [ds1_sfPuP]
                                    case ds1_sfPuP of {
                                      (,) h_sfPuR b1_sfPuS [Occ=Once] ->
                                          let {
                                            sat_sfPv0 [Occ=Once]
                                              :: m_afy9S (Data.Semigroup.Last a_XfyAu,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfPuK $dMonad_sfPuM h_sfPuR b1_sfPuS] \u []
                                                    let {
                                                      sat_sfPuY [Occ=Once]
                                                        :: Data.Semigroup.Last a_XfyAu
                                                      [LclId] =
                                                          [eta_sfPuK h_sfPuR] \u []
                                                              h_sfPuR eta_sfPuK; } in
                                                    let {
                                                      sat_sfPuZ [Occ=Once]
                                                        :: (Data.Semigroup.Last a_XfyAu,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfPuY b1_sfPuS];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfPuM sat_sfPuZ; } in
                                          let {
                                            sat_sfPuX [Occ=Once]
                                              :: m_afy9S (Data.Semigroup.Last a_XfyAu,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfPuM lvl34_sfPuN h_sfPuR] \u []
                                                    let {
                                                      sat_sfPuW [Occ=Once]
                                                        :: a_XfyAu
                                                           -> m_afy9S (Data.Semigroup.Last a_XfyAu,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfPuM h_sfPuR] \r [y'_sfPuT]
                                                              let {
                                                                sat_sfPuU [Occ=Once]
                                                                  :: Data.Semigroup.Last a_XfyAu
                                                                [LclId] =
                                                                    [h_sfPuR y'_sfPuT] \u []
                                                                        h_sfPuR y'_sfPuT; } in
                                                              let {
                                                                sat_sfPuV [Occ=Once]
                                                                  :: (Data.Semigroup.Last a_XfyAu,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfPuU
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfPuM sat_sfPuV;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfPuM lvl34_sfPuN sat_sfPuW;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfPuI sat_sfPuX sat_sfPv0;
                                    }; } in
                          let {
                            sat_sfPuO [Occ=Once]
                              :: m_afy9S (a_XfyAu -> Data.Semigroup.Last a_XfyAu, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPuM] \u []
                                    GHC.Base.return $dMonad_sfPuM Data.Semigroup.$fDataLast1;
                          } in  GHC.Base.>>= $dMonad_sfPuM sat_sfPuO sat_sfPv1;
                } in  GHC.Base.>>= $dMonad_sfPuM sat_sfPv2 sat_sfPv8;
          };

Data.Semigroup.$fDataLast_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Last a -> m (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPv9 $dMonad_sfPva ds_sfPvb eta_sfPvc]
        let {
          lvl33_sfPvd [Occ=OnceL] :: m_afy9C a_XfyAt
          [LclId] =
              [$dData_sfPv9 ds_sfPvb eta_sfPvc] \u []
                  ds_sfPvb $dData_sfPv9 eta_sfPvc; } in
        let {
          sat_sfPvj [Occ=Once]
            :: (a_XfyAt -> Data.Semigroup.Last a_XfyAt)
               -> m_afy9C (Data.Semigroup.Last a_XfyAt)
          [LclId] =
              [$dMonad_sfPva lvl33_sfPvd] \r [c'_sfPvf]
                  let {
                    sat_sfPvi [Occ=Once]
                      :: a_XfyAt -> m_afy9C (Data.Semigroup.Last a_XfyAt)
                    [LclId] =
                        [$dMonad_sfPva c'_sfPvf] \r [x'_sfPvg]
                            let {
                              sat_sfPvh [Occ=Once] :: Data.Semigroup.Last a_XfyAt
                              [LclId] =
                                  [c'_sfPvf x'_sfPvg] \u [] c'_sfPvf x'_sfPvg;
                            } in  GHC.Base.return $dMonad_sfPva sat_sfPvh;
                  } in  GHC.Base.>>= $dMonad_sfPva lvl33_sfPvd sat_sfPvi; } in
        let {
          sat_sfPve [Occ=Once]
            :: m_afy9C (a_XfyAt -> Data.Semigroup.Last a_XfyAt)
          [LclId] =
              [$dMonad_sfPva] \u []
                  GHC.Base.return $dMonad_sfPva Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfPva sat_sfPve sat_sfPvj;

Data.Semigroup.$fDataLast_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Last a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPvk ds_sfPvl ds1_sfPvm x_sfPvn]
        case ds_sfPvl of {
          GHC.Types.I# x1_sfPvp [Occ=Once!] ->
              case x1_sfPvp of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfPvm $dData_sfPvk x_sfPvn;
              };
        };

Data.Semigroup.$fDataLast_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Last a -> m (Data.Semigroup.Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPvr $dMonadPlus_sfPvs ds_sfPvt eta_sfPvu]
        let {
          lvl33_sfPvv [Occ=OnceL] :: m_afya8 (Data.Semigroup.Last a_XfyAn)
          [LclId] =
              [$dMonadPlus_sfPvs] \u [] GHC.Base.mzero $dMonadPlus_sfPvs;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPvs
          of
          $dMonad_sfPvw [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPvV [Occ=Once]
                    :: (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                       -> m_afya8 (Data.Semigroup.Last a_XfyAn)
                  [LclId] =
                      [lvl33_sfPvv $dMonad_sfPvw] \r [ds1_sfPvQ]
                          case ds1_sfPvQ of {
                            (,) x'_sfPvS [Occ=Once] b_sfPvT [Occ=Once!] ->
                                case b_sfPvT of {
                                  GHC.Types.False -> lvl33_sfPvv;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPvw x'_sfPvS;
                                };
                          }; } in
                let {
                  sat_sfPvP [Occ=Once]
                    :: m_afya8 (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPvr
                       $dMonadPlus_sfPvs
                       ds_sfPvt
                       eta_sfPvu
                       $dMonad_sfPvw] \u []
                          let {
                            lvl34_sfPvx [Occ=OnceL] :: m_afya8 a_XfyAn
                            [LclId] =
                                [$dData_sfPvr ds_sfPvt eta_sfPvu] \u []
                                    ds_sfPvt $dData_sfPvr eta_sfPvu; } in
                          let {
                            sat_sfPvO [Occ=Once]
                              :: (a_XfyAn -> Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                                 -> m_afya8 (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPvs
                                 eta_sfPvu
                                 $dMonad_sfPvw
                                 lvl34_sfPvx] \r [ds1_sfPvz]
                                    case ds1_sfPvz of {
                                      (,) h_sfPvB b1_sfPvC [Occ=Once!] ->
                                          case b1_sfPvC of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfPvL [Occ=Once]
                                                    :: m_afya8 (Data.Semigroup.Last a_XfyAn,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfPvu $dMonad_sfPvw h_sfPvB] \u []
                                                          let {
                                                            sat_sfPvJ [Occ=Once]
                                                              :: Data.Semigroup.Last a_XfyAn
                                                            [LclId] =
                                                                [eta_sfPvu h_sfPvB] \u []
                                                                    h_sfPvB eta_sfPvu; } in
                                                          let {
                                                            sat_sfPvK [Occ=Once]
                                                              :: (Data.Semigroup.Last a_XfyAn,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfPvJ
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfPvw sat_sfPvK; } in
                                                let {
                                                  sat_sfPvI [Occ=Once]
                                                    :: m_afya8 (Data.Semigroup.Last a_XfyAn,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfPvw lvl34_sfPvx h_sfPvB] \u []
                                                          let {
                                                            sat_sfPvH [Occ=Once]
                                                              :: a_XfyAn
                                                                 -> m_afya8 (Data.Semigroup.Last
                                                                               a_XfyAn,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPvw
                                                                 h_sfPvB] \r [y'_sfPvE]
                                                                    let {
                                                                      sat_sfPvF [Occ=Once]
                                                                        :: Data.Semigroup.Last
                                                                             a_XfyAn
                                                                      [LclId] =
                                                                          [h_sfPvB y'_sfPvE] \u []
                                                                              h_sfPvB y'_sfPvE; } in
                                                                    let {
                                                                      sat_sfPvG [Occ=Once]
                                                                        :: (Data.Semigroup.Last
                                                                              a_XfyAn,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPvF
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPvw sat_sfPvG;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfPvw lvl34_sfPvx sat_sfPvH;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfPvs sat_sfPvI sat_sfPvL;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfPvM [Occ=Once]
                                                    :: Data.Semigroup.Last a_XfyAn
                                                  [LclId] =
                                                      [eta_sfPvu h_sfPvB] \u []
                                                          h_sfPvB eta_sfPvu; } in
                                                let {
                                                  sat_sfPvN [Occ=Once]
                                                    :: (Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfPvM GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfPvw sat_sfPvN;
                                          };
                                    }; } in
                          let {
                            sat_sfPvy [Occ=Once]
                              :: m_afya8 (a_XfyAn -> Data.Semigroup.Last a_XfyAn, GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPvw] \u []
                                    GHC.Base.return $dMonad_sfPvw Data.Semigroup.$fDataLast1;
                          } in  GHC.Base.>>= $dMonad_sfPvw sat_sfPvy sat_sfPvO;
                } in  GHC.Base.>>= $dMonad_sfPvw sat_sfPvP sat_sfPvV;
          };

lvl24_rfC77 :: forall a. Data.Semigroup.Last a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPvW] Data.Semigroup.$cLast;

lvl25_rfC78
  :: forall a. Data.Semigroup.Last a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPvX] Data.Semigroup.$tLast;

lvl26_rfC79
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Last a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPvY ds_sfPvZ] GHC.Base.Nothing [];

Data.Semigroup.$fDataLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Last a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPw0]
        let {
          sat_sfPwv [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Last a_XfyAm -> m (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfPw0] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapMo
                      $dData_sfPw0 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPwu [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Last a_XfyAm -> m (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfPw0] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapMp
                      $dData_sfPw0 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPwt [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Last a_XfyAm -> m (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfPw0] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapM
                      $dData_sfPw0 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPws [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Last a_XfyAm
               -> u
          [LclId] =
              [$dData_sfPw0] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgmapQi
                      $dData_sfPw0 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPwr [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Last a_XfyAm -> [u]
          [LclId] =
              [$dData_sfPw0] \r [ds_sfPwo x0_sfPwp]
                  let {
                    sat_sfPwq [Occ=Once] :: u_afy9a
                    [LclId] =
                        [$dData_sfPw0 ds_sfPwo x0_sfPwp] \u []
                            ds_sfPwo $dData_sfPw0 x0_sfPwp;
                  } in  : [sat_sfPwq GHC.Types.[]]; } in
        let {
          sat_sfPwn [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Last a_XfyAm
               -> r
          [LclId] =
              [$dData_sfPw0] \r [ds_sfPwi ds1_sfPwj ds2_sfPwk x0_sfPwl]
                  let {
                    sat_sfPwm [Occ=Once] :: r'_afy8U
                    [LclId] =
                        [$dData_sfPw0 ds2_sfPwk x0_sfPwl] \u []
                            ds2_sfPwk $dData_sfPw0 x0_sfPwl;
                  } in  ds_sfPwi sat_sfPwm ds1_sfPwj; } in
        let {
          sat_sfPwh [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Last a_XfyAm
               -> r
          [LclId] =
              [$dData_sfPw0] \r [ds_sfPwc ds1_sfPwd ds2_sfPwe eta_sfPwf]
                  let {
                    sat_sfPwg [Occ=Once] :: r'_afy8D
                    [LclId] =
                        [$dData_sfPw0 ds2_sfPwe eta_sfPwf] \u []
                            ds2_sfPwe $dData_sfPw0 eta_sfPwf;
                  } in  ds_sfPwc ds1_sfPwd sat_sfPwg; } in
        let {
          sat_sfPwb [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Last a_XfyAm -> Data.Semigroup.Last a_XfyAm
          [LclId] =
              [$dData_sfPw0] \r [ds_sfPw9 x0_sfPwa]
                  ds_sfPw9 $dData_sfPw0 x0_sfPwa; } in
        let {
          sat_sfPw8 [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Last a_XfyAm))
          [LclId] =
              [$dData_sfPw0] \r [eta_B1]
                  Data.Semigroup.$fDataLast_$cdataCast1 $dData_sfPw0 eta_B1; } in
        let {
          sat_sfPw7 [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfPw0] \r [k_sfPw3 z_sfPw4 ds_sfPw5]
                  let {
                    sat_sfPw6 [Occ=Once]
                      :: c_afy7t (a_XfyAm -> Data.Semigroup.Last a_XfyAm)
                    [LclId] =
                        [z_sfPw4] \u [] z_sfPw4 Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfPw3 $dData_sfPw0 sat_sfPw6; } in
        let {
          sat_sfPw2 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Last a_XfyAm
               -> c (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfPw0] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataLast_$cgfoldl
                      $dData_sfPw0 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPw1 [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Last a_XfyAm)
          [LclId] =
              [$dData_sfPw0] \u [] Data.Semigroup.$fDataLast8 $dData_sfPw0;
        } in 
          Data.Data.C:Data [sat_sfPw1
                            sat_sfPw2
                            sat_sfPw7
                            lvl24_rfC77
                            lvl25_rfC78
                            sat_sfPw8
                            lvl26_rfC79
                            sat_sfPwb
                            sat_sfPwh
                            sat_sfPwn
                            sat_sfPwr
                            sat_sfPws
                            sat_sfPwt
                            sat_sfPwu
                            sat_sfPwv];

Data.Semigroup.$fDataWrappedMonoid3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataWrappedMonoid4];

Data.Semigroup.$tcWrappedMonoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3715640179151546043##
                                    2823802549020348832##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataWrappedMonoid3
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep12_rfC7a :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcWrappedMonoid
                                              $krep2_rfC6L];

Data.Semigroup.$tc'WrapMonoid1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_rfC6K $krep12_rfC7a];

Data.Semigroup.$tc'WrapMonoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'WrapMonoid"#;

Data.Semigroup.$tc'WrapMonoid2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'WrapMonoid3];

Data.Semigroup.$tc'WrapMonoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4283841874858276090##
                                    3445460813926951313##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'WrapMonoid2
                                    1#
                                    Data.Semigroup.$tc'WrapMonoid1];

Data.Semigroup.$fDataWrappedMonoid2
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.WrappedMonoid
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                3715640179151546043##
                2823802549020348832##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataWrappedMonoid3
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPwx [Occ=Once]
                   ww9_sfPwy [Occ=Once]
                   ww10_sfPwz [Occ=Once]
                   ww11_sfPwA [Occ=Once]
                   ww12_sfPwB [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPwx
                                              ww9_sfPwy
                                              ww10_sfPwz
                                              ww11_sfPwA
                                              ww12_sfPwB];
        };

Data.Semigroup.$fDataWrappedMonoid8
  :: forall m.
     Data.Data.Data m =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPwC]
        case Data.Data.$p1Data $dData_sfPwC of sat_sfPwD {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataWrappedMonoid2 sat_sfPwD;
        };

Data.Semigroup.$fDataWrappedMonoid_$cdataCast1
  :: forall m.
     Data.Data.Data m =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.WrappedMonoid m))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPwE $dTypeable_sfPwF]
        let {
          lvl33_sfPwG [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPwF] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPwF Data.Semigroup.$fDataWrappedMonoid2; } in
        let {
          sat_sfPwK [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afygP (t_afygO d))
               -> GHC.Base.Maybe (c_afygP (Data.Semigroup.WrappedMonoid m_XfyJL))
          [LclId] =
              [$dData_sfPwE lvl33_sfPwG] \r [f_sfPwH]
                  case lvl33_sfPwG of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPwJ [Occ=Once]
                            :: c_afygP (Data.Semigroup.WrappedMonoid m_XfyJL)
                          [LclId] =
                              [$dData_sfPwE f_sfPwH] \u [] f_sfPwH $dData_sfPwE;
                        } in  GHC.Base.Just [sat_sfPwJ];
                  };
        } in  sat_sfPwK;

Data.Semigroup.$fDataWrappedMonoid1
  :: forall m. (m -> Data.Semigroup.WrappedMonoid m, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fApplicativeFirst3
                        GHC.Types.False];

Data.Semigroup.$fDataWrappedMonoid_$cgmapMp
  :: forall m.
     Data.Data.Data m =>
     forall (m1 :: * -> *).
     GHC.Base.MonadPlus m1 =>
     (forall d. Data.Data.Data d => d -> m1 d)
     -> Data.Semigroup.WrappedMonoid m
     -> m1 (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPwL $dMonadPlus_sfPwM ds_sfPwN eta_sfPwO]
        let {
          lvl33_sfPwP [Occ=OnceL]
            :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU)
          [LclId] =
              [$dMonadPlus_sfPwM] \u [] GHC.Base.mzero $dMonadPlus_sfPwM;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPwM
          of
          $dMonad_sfPwQ [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPxc [Occ=Once]
                    :: (Data.Semigroup.WrappedMonoid m_XfyJU, GHC.Types.Bool)
                       -> m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU)
                  [LclId] =
                      [lvl33_sfPwP $dMonad_sfPwQ] \r [ds1_sfPx7]
                          case ds1_sfPx7 of {
                            (,) x'_sfPx9 [Occ=Once] b_sfPxa [Occ=Once!] ->
                                case b_sfPxa of {
                                  GHC.Types.False -> lvl33_sfPwP;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPwQ x'_sfPx9;
                                };
                          }; } in
                let {
                  sat_sfPx6 [Occ=Once]
                    :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPwL
                       $dMonadPlus_sfPwM
                       ds_sfPwN
                       eta_sfPwO
                       $dMonad_sfPwQ] \u []
                          let {
                            lvl34_sfPwR [Occ=OnceL] :: m1_afyiU m_XfyJU
                            [LclId] =
                                [$dData_sfPwL ds_sfPwN eta_sfPwO] \u []
                                    ds_sfPwN $dData_sfPwL eta_sfPwO; } in
                          let {
                            sat_sfPx5 [Occ=Once]
                              :: (m_XfyJU -> Data.Semigroup.WrappedMonoid m_XfyJU,
                                  GHC.Types.Bool)
                                 -> m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPwM
                                 eta_sfPwO
                                 $dMonad_sfPwQ
                                 lvl34_sfPwR] \r [ds1_sfPwT]
                                    case ds1_sfPwT of {
                                      (,) h_sfPwV b1_sfPwW [Occ=Once] ->
                                          let {
                                            sat_sfPx4 [Occ=Once]
                                              :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU,
                                                           GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfPwO $dMonad_sfPwQ h_sfPwV b1_sfPwW] \u []
                                                    let {
                                                      sat_sfPx2 [Occ=Once]
                                                        :: Data.Semigroup.WrappedMonoid m_XfyJU
                                                      [LclId] =
                                                          [eta_sfPwO h_sfPwV] \u []
                                                              h_sfPwV eta_sfPwO; } in
                                                    let {
                                                      sat_sfPx3 [Occ=Once]
                                                        :: (Data.Semigroup.WrappedMonoid m_XfyJU,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfPx2 b1_sfPwW];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfPwQ sat_sfPx3; } in
                                          let {
                                            sat_sfPx1 [Occ=Once]
                                              :: m1_afyiU (Data.Semigroup.WrappedMonoid m_XfyJU,
                                                           GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfPwQ lvl34_sfPwR h_sfPwV] \u []
                                                    let {
                                                      sat_sfPx0 [Occ=Once]
                                                        :: m_XfyJU
                                                           -> m1_afyiU (Data.Semigroup.WrappedMonoid
                                                                          m_XfyJU,
                                                                        GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfPwQ h_sfPwV] \r [y'_sfPwX]
                                                              let {
                                                                sat_sfPwY [Occ=Once]
                                                                  :: Data.Semigroup.WrappedMonoid
                                                                       m_XfyJU
                                                                [LclId] =
                                                                    [h_sfPwV y'_sfPwX] \u []
                                                                        h_sfPwV y'_sfPwX; } in
                                                              let {
                                                                sat_sfPwZ [Occ=Once]
                                                                  :: (Data.Semigroup.WrappedMonoid
                                                                        m_XfyJU,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfPwY
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfPwQ sat_sfPwZ;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfPwQ lvl34_sfPwR sat_sfPx0;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfPwM sat_sfPx1 sat_sfPx4;
                                    }; } in
                          let {
                            sat_sfPwS [Occ=Once]
                              :: m1_afyiU (m_XfyJU -> Data.Semigroup.WrappedMonoid m_XfyJU,
                                           GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPwQ] \u []
                                    GHC.Base.return
                                        $dMonad_sfPwQ Data.Semigroup.$fDataWrappedMonoid1;
                          } in  GHC.Base.>>= $dMonad_sfPwQ sat_sfPwS sat_sfPx5;
                } in  GHC.Base.>>= $dMonad_sfPwQ sat_sfPx6 sat_sfPxc;
          };

Data.Semigroup.$fDataWrappedMonoid_$cgmapM
  :: forall m.
     Data.Data.Data m =>
     forall (m1 :: * -> *).
     GHC.Base.Monad m1 =>
     (forall d. Data.Data.Data d => d -> m1 d)
     -> Data.Semigroup.WrappedMonoid m
     -> m1 (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPxd $dMonad_sfPxe ds_sfPxf eta_sfPxg]
        let {
          lvl33_sfPxh [Occ=OnceL] :: m1_afyiE m_XfyJT
          [LclId] =
              [$dData_sfPxd ds_sfPxf eta_sfPxg] \u []
                  ds_sfPxf $dData_sfPxd eta_sfPxg; } in
        let {
          sat_sfPxn [Occ=Once]
            :: (m_XfyJT -> Data.Semigroup.WrappedMonoid m_XfyJT)
               -> m1_afyiE (Data.Semigroup.WrappedMonoid m_XfyJT)
          [LclId] =
              [$dMonad_sfPxe lvl33_sfPxh] \r [c'_sfPxj]
                  let {
                    sat_sfPxm [Occ=Once]
                      :: m_XfyJT -> m1_afyiE (Data.Semigroup.WrappedMonoid m_XfyJT)
                    [LclId] =
                        [$dMonad_sfPxe c'_sfPxj] \r [x'_sfPxk]
                            let {
                              sat_sfPxl [Occ=Once] :: Data.Semigroup.WrappedMonoid m_XfyJT
                              [LclId] =
                                  [c'_sfPxj x'_sfPxk] \u [] c'_sfPxj x'_sfPxk;
                            } in  GHC.Base.return $dMonad_sfPxe sat_sfPxl;
                  } in  GHC.Base.>>= $dMonad_sfPxe lvl33_sfPxh sat_sfPxm; } in
        let {
          sat_sfPxi [Occ=Once]
            :: m1_afyiE (m_XfyJT -> Data.Semigroup.WrappedMonoid m_XfyJT)
          [LclId] =
              [$dMonad_sfPxe] \u []
                  GHC.Base.return $dMonad_sfPxe Data.Semigroup.$fApplicativeFirst3;
        } in  GHC.Base.>>= $dMonad_sfPxe sat_sfPxi sat_sfPxn;

Data.Semigroup.$fDataWrappedMonoid_$cgmapQi
  :: forall m.
     Data.Data.Data m =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.WrappedMonoid m
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPxo ds_sfPxp ds1_sfPxq x_sfPxr]
        case ds_sfPxp of {
          GHC.Types.I# x1_sfPxt [Occ=Once!] ->
              case x1_sfPxt of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sfPxq $dData_sfPxo x_sfPxr;
              };
        };

Data.Semigroup.$fDataWrappedMonoid_$cgmapMo
  :: forall m.
     Data.Data.Data m =>
     forall (m1 :: * -> *).
     GHC.Base.MonadPlus m1 =>
     (forall d. Data.Data.Data d => d -> m1 d)
     -> Data.Semigroup.WrappedMonoid m
     -> m1 (Data.Semigroup.WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPxv $dMonadPlus_sfPxw ds_sfPxx eta_sfPxy]
        let {
          lvl33_sfPxz [Occ=OnceL]
            :: m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN)
          [LclId] =
              [$dMonadPlus_sfPxw] \u [] GHC.Base.mzero $dMonadPlus_sfPxw;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPxw
          of
          $dMonad_sfPxA [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPxZ [Occ=Once]
                    :: (Data.Semigroup.WrappedMonoid m_XfyJN, GHC.Types.Bool)
                       -> m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN)
                  [LclId] =
                      [lvl33_sfPxz $dMonad_sfPxA] \r [ds1_sfPxU]
                          case ds1_sfPxU of {
                            (,) x'_sfPxW [Occ=Once] b_sfPxX [Occ=Once!] ->
                                case b_sfPxX of {
                                  GHC.Types.False -> lvl33_sfPxz;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPxA x'_sfPxW;
                                };
                          }; } in
                let {
                  sat_sfPxT [Occ=Once]
                    :: m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPxv
                       $dMonadPlus_sfPxw
                       ds_sfPxx
                       eta_sfPxy
                       $dMonad_sfPxA] \u []
                          let {
                            lvl34_sfPxB [Occ=OnceL] :: m1_afyja m_XfyJN
                            [LclId] =
                                [$dData_sfPxv ds_sfPxx eta_sfPxy] \u []
                                    ds_sfPxx $dData_sfPxv eta_sfPxy; } in
                          let {
                            sat_sfPxS [Occ=Once]
                              :: (m_XfyJN -> Data.Semigroup.WrappedMonoid m_XfyJN,
                                  GHC.Types.Bool)
                                 -> m1_afyja (Data.Semigroup.WrappedMonoid m_XfyJN, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPxw
                                 eta_sfPxy
                                 $dMonad_sfPxA
                                 lvl34_sfPxB] \r [ds1_sfPxD]
                                    case ds1_sfPxD of {
                                      (,) h_sfPxF b1_sfPxG [Occ=Once!] ->
                                          case b1_sfPxG of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfPxP [Occ=Once]
                                                    :: m1_afyja (Data.Semigroup.WrappedMonoid
                                                                   m_XfyJN,
                                                                 GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfPxy $dMonad_sfPxA h_sfPxF] \u []
                                                          let {
                                                            sat_sfPxN [Occ=Once]
                                                              :: Data.Semigroup.WrappedMonoid
                                                                   m_XfyJN
                                                            [LclId] =
                                                                [eta_sfPxy h_sfPxF] \u []
                                                                    h_sfPxF eta_sfPxy; } in
                                                          let {
                                                            sat_sfPxO [Occ=Once]
                                                              :: (Data.Semigroup.WrappedMonoid
                                                                    m_XfyJN,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfPxN
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfPxA sat_sfPxO; } in
                                                let {
                                                  sat_sfPxM [Occ=Once]
                                                    :: m1_afyja (Data.Semigroup.WrappedMonoid
                                                                   m_XfyJN,
                                                                 GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfPxA lvl34_sfPxB h_sfPxF] \u []
                                                          let {
                                                            sat_sfPxL [Occ=Once]
                                                              :: m_XfyJN
                                                                 -> m1_afyja (Data.Semigroup.WrappedMonoid
                                                                                m_XfyJN,
                                                                              GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPxA
                                                                 h_sfPxF] \r [y'_sfPxI]
                                                                    let {
                                                                      sat_sfPxJ [Occ=Once]
                                                                        :: Data.Semigroup.WrappedMonoid
                                                                             m_XfyJN
                                                                      [LclId] =
                                                                          [h_sfPxF y'_sfPxI] \u []
                                                                              h_sfPxF y'_sfPxI; } in
                                                                    let {
                                                                      sat_sfPxK [Occ=Once]
                                                                        :: (Data.Semigroup.WrappedMonoid
                                                                              m_XfyJN,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPxJ
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPxA sat_sfPxK;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfPxA lvl34_sfPxB sat_sfPxL;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfPxw sat_sfPxM sat_sfPxP;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfPxQ [Occ=Once]
                                                    :: Data.Semigroup.WrappedMonoid m_XfyJN
                                                  [LclId] =
                                                      [eta_sfPxy h_sfPxF] \u []
                                                          h_sfPxF eta_sfPxy; } in
                                                let {
                                                  sat_sfPxR [Occ=Once]
                                                    :: (Data.Semigroup.WrappedMonoid m_XfyJN,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfPxQ GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfPxA sat_sfPxR;
                                          };
                                    }; } in
                          let {
                            sat_sfPxC [Occ=Once]
                              :: m1_afyja (m_XfyJN -> Data.Semigroup.WrappedMonoid m_XfyJN,
                                           GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPxA] \u []
                                    GHC.Base.return
                                        $dMonad_sfPxA Data.Semigroup.$fDataWrappedMonoid1;
                          } in  GHC.Base.>>= $dMonad_sfPxA sat_sfPxC sat_sfPxS;
                } in  GHC.Base.>>= $dMonad_sfPxA sat_sfPxT sat_sfPxZ;
          };

lvl27_rfC7b
  :: forall m. Data.Semigroup.WrappedMonoid m -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPy0] Data.Semigroup.$cWrapMonoid;

lvl28_rfC7c
  :: forall m. Data.Semigroup.WrappedMonoid m -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPy1] Data.Semigroup.$tWrappedMonoid;

lvl29_rfC7d
  :: forall m (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.WrappedMonoid m))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPy2 ds_sfPy3] GHC.Base.Nothing [];

Data.Semigroup.$fDataWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     Data.Data.Data m =>
     Data.Data.Data (Data.Semigroup.WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPy4]
        let {
          sat_sfPyz [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> m (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfPy4] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapMo
                      $dData_sfPy4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPyy [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> m (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfPy4] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapMp
                      $dData_sfPy4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPyx [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> m (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfPy4] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapM
                      $dData_sfPy4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPyw [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> u
          [LclId] =
              [$dData_sfPy4] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgmapQi
                      $dData_sfPy4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPyv [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.WrappedMonoid m_XfyJM -> [u]
          [LclId] =
              [$dData_sfPy4] \r [ds_sfPys x0_sfPyt]
                  let {
                    sat_sfPyu [Occ=Once] :: u_afyic
                    [LclId] =
                        [$dData_sfPy4 ds_sfPys x0_sfPyt] \u []
                            ds_sfPys $dData_sfPy4 x0_sfPyt;
                  } in  : [sat_sfPyu GHC.Types.[]]; } in
        let {
          sat_sfPyr [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> r
          [LclId] =
              [$dData_sfPy4] \r [ds_sfPym ds1_sfPyn ds2_sfPyo x0_sfPyp]
                  let {
                    sat_sfPyq [Occ=Once] :: r'_afyhW
                    [LclId] =
                        [$dData_sfPy4 ds2_sfPyo x0_sfPyp] \u []
                            ds2_sfPyo $dData_sfPy4 x0_sfPyp;
                  } in  ds_sfPym sat_sfPyq ds1_sfPyn; } in
        let {
          sat_sfPyl [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> r
          [LclId] =
              [$dData_sfPy4] \r [ds_sfPyg ds1_sfPyh ds2_sfPyi eta_sfPyj]
                  let {
                    sat_sfPyk [Occ=Once] :: r'_afyhF
                    [LclId] =
                        [$dData_sfPy4 ds2_sfPyi eta_sfPyj] \u []
                            ds2_sfPyi $dData_sfPy4 eta_sfPyj;
                  } in  ds_sfPyg ds1_sfPyh sat_sfPyk; } in
        let {
          sat_sfPyf [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> Data.Semigroup.WrappedMonoid m_XfyJM
          [LclId] =
              [$dData_sfPy4] \r [ds_sfPyd x0_sfPye]
                  ds_sfPyd $dData_sfPy4 x0_sfPye; } in
        let {
          sat_sfPyc [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.WrappedMonoid m_XfyJM))
          [LclId] =
              [$dData_sfPy4] \r [eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cdataCast1
                      $dData_sfPy4 eta_B1; } in
        let {
          sat_sfPyb [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfPy4] \r [k_sfPy7 z_sfPy8 ds_sfPy9]
                  let {
                    sat_sfPya [Occ=Once]
                      :: c_afygv (m_XfyJM -> Data.Semigroup.WrappedMonoid m_XfyJM)
                    [LclId] =
                        [z_sfPy8] \u [] z_sfPy8 Data.Semigroup.$fApplicativeFirst3;
                  } in  k_sfPy7 $dData_sfPy4 sat_sfPya; } in
        let {
          sat_sfPy6 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.WrappedMonoid m_XfyJM
               -> c (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfPy4] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataWrappedMonoid_$cgfoldl
                      $dData_sfPy4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPy5 [Occ=Once]
            :: Data.Typeable.Internal.Typeable
                 (Data.Semigroup.WrappedMonoid m_XfyJM)
          [LclId] =
              [$dData_sfPy4] \u []
                  Data.Semigroup.$fDataWrappedMonoid8 $dData_sfPy4;
        } in 
          Data.Data.C:Data [sat_sfPy5
                            sat_sfPy6
                            sat_sfPyb
                            lvl27_rfC7b
                            lvl28_rfC7c
                            sat_sfPyc
                            lvl29_rfC7d
                            sat_sfPyf
                            sat_sfPyl
                            sat_sfPyr
                            sat_sfPyv
                            sat_sfPyw
                            sat_sfPyx
                            sat_sfPyy
                            sat_sfPyz];

Data.Semigroup.$fDataOption5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$fDataOption6];

Data.Semigroup.$tcOption :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10723619047615802556##
                                    16447525423442151350##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$fDataOption5
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep13_rfC7e :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.$tcOption
                                              $krep2_rfC6L];

Data.Semigroup.$tc'Option1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rfC6M $krep13_rfC7e];

Data.Semigroup.$tc'Option3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Option"#;

Data.Semigroup.$tc'Option2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.$tc'Option3];

Data.Semigroup.$tc'Option :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10684524870560962689##
                                    6198254930115905464##
                                    Data.Semigroup.$trModule
                                    Data.Semigroup.$tc'Option2
                                    1#
                                    Data.Semigroup.$tc'Option1];

Data.Semigroup.$fDataOption4
  :: Data.Typeable.Internal.TypeRep Data.Semigroup.Option
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                10723619047615802556##
                16447525423442151350##
                Data.Semigroup.$trModule
                Data.Semigroup.$fDataOption5
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfPyB [Occ=Once]
                   ww9_sfPyC [Occ=Once]
                   ww10_sfPyD [Occ=Once]
                   ww11_sfPyE [Occ=Once]
                   ww12_sfPyF [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfPyB
                                              ww9_sfPyC
                                              ww10_sfPyD
                                              ww11_sfPyE
                                              ww12_sfPyF];
        };

Data.Semigroup.$fDataOption10
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Semigroup.Option a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPyG]
        case Data.Data.$p1Data $dData_sfPyG of sat_sfPyH {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Semigroup.$fDataOption4 sat_sfPyH;
        };

Data.Semigroup.$fDataOption_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Semigroup.Option a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sfPyI $dTypeable_sfPyJ]
        let {
          lvl33_sfPyK [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sfPyJ] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sfPyJ Data.Semigroup.$fDataOption4; } in
        let {
          sat_sfPyO [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_afypz (t_afypy d))
               -> GHC.Base.Maybe (c_afypz (Data.Semigroup.Option a_XfyST))
          [LclId] =
              [$dData_sfPyI lvl33_sfPyK] \r [f_sfPyL]
                  case lvl33_sfPyK of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sfPyN [Occ=Once] :: c_afypz (Data.Semigroup.Option a_XfyST)
                          [LclId] =
                              [$dData_sfPyI f_sfPyL] \u [] f_sfPyL $dData_sfPyI;
                        } in  GHC.Base.Just [sat_sfPyN];
                  };
        } in  sat_sfPyO;

Data.Semigroup.$fDataOption1
  :: forall a.
     (GHC.Base.Maybe a -> Data.Semigroup.Option a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Semigroup.$fDataOption2 GHC.Types.False];

Data.Semigroup.$fDataOption_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPyP $dMonadPlus_sfPyQ ds_sfPyR eta_sfPyS]
        let {
          lvl33_sfPyT [Occ=OnceL] :: m_afyrE (Data.Semigroup.Option a_XfyT2)
          [LclId] =
              [$dMonadPlus_sfPyQ] \u [] GHC.Base.mzero $dMonadPlus_sfPyQ;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPyQ
          of
          $dMonad_sfPyU [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPzh [Occ=Once]
                    :: (Data.Semigroup.Option a_XfyT2, GHC.Types.Bool)
                       -> m_afyrE (Data.Semigroup.Option a_XfyT2)
                  [LclId] =
                      [lvl33_sfPyT $dMonad_sfPyU] \r [ds1_sfPzc]
                          case ds1_sfPzc of {
                            (,) x'_sfPze [Occ=Once] b_sfPzf [Occ=Once!] ->
                                case b_sfPzf of {
                                  GHC.Types.False -> lvl33_sfPyT;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPyU x'_sfPze;
                                };
                          }; } in
                let {
                  sat_sfPzb [Occ=Once]
                    :: m_afyrE (Data.Semigroup.Option a_XfyT2, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPyP
                       $dMonadPlus_sfPyQ
                       ds_sfPyR
                       eta_sfPyS
                       $dMonad_sfPyU] \u []
                          let {
                            lvl34_sfPyV [Occ=OnceL] :: m_afyrE (GHC.Base.Maybe a_XfyT2)
                            [LclId] =
                                [$dData_sfPyP ds_sfPyR eta_sfPyS] \u []
                                    let {
                                      sat_sfPyW [Occ=Once]
                                        :: Data.Data.Data (GHC.Base.Maybe a_XfyT2)
                                      [LclId] =
                                          [$dData_sfPyP] \u [] Data.Data.$fDataMaybe $dData_sfPyP;
                                    } in  ds_sfPyR sat_sfPyW eta_sfPyS; } in
                          let {
                            sat_sfPza [Occ=Once]
                              :: (GHC.Base.Maybe a_XfyT2 -> Data.Semigroup.Option a_XfyT2,
                                  GHC.Types.Bool)
                                 -> m_afyrE (Data.Semigroup.Option a_XfyT2, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPyQ
                                 eta_sfPyS
                                 $dMonad_sfPyU
                                 lvl34_sfPyV] \r [ds1_sfPyY]
                                    case ds1_sfPyY of {
                                      (,) h_sfPz0 b1_sfPz1 [Occ=Once] ->
                                          let {
                                            sat_sfPz9 [Occ=Once]
                                              :: m_afyrE (Data.Semigroup.Option a_XfyT2,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [eta_sfPyS $dMonad_sfPyU h_sfPz0 b1_sfPz1] \u []
                                                    let {
                                                      sat_sfPz7 [Occ=Once]
                                                        :: Data.Semigroup.Option a_XfyT2
                                                      [LclId] =
                                                          [eta_sfPyS h_sfPz0] \u []
                                                              h_sfPz0 eta_sfPyS; } in
                                                    let {
                                                      sat_sfPz8 [Occ=Once]
                                                        :: (Data.Semigroup.Option a_XfyT2,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sfPz7 b1_sfPz1];
                                                    } in 
                                                      GHC.Base.return $dMonad_sfPyU sat_sfPz8; } in
                                          let {
                                            sat_sfPz6 [Occ=Once]
                                              :: m_afyrE (Data.Semigroup.Option a_XfyT2,
                                                          GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sfPyU lvl34_sfPyV h_sfPz0] \u []
                                                    let {
                                                      sat_sfPz5 [Occ=Once]
                                                        :: GHC.Base.Maybe a_XfyT2
                                                           -> m_afyrE (Data.Semigroup.Option
                                                                         a_XfyT2,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sfPyU h_sfPz0] \r [y'_sfPz2]
                                                              let {
                                                                sat_sfPz3 [Occ=Once]
                                                                  :: Data.Semigroup.Option a_XfyT2
                                                                [LclId] =
                                                                    [h_sfPz0 y'_sfPz2] \u []
                                                                        h_sfPz0 y'_sfPz2; } in
                                                              let {
                                                                sat_sfPz4 [Occ=Once]
                                                                  :: (Data.Semigroup.Option a_XfyT2,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sfPz3
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sfPyU sat_sfPz4;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sfPyU lvl34_sfPyV sat_sfPz5;
                                          } in 
                                            GHC.Base.mplus $dMonadPlus_sfPyQ sat_sfPz6 sat_sfPz9;
                                    }; } in
                          let {
                            sat_sfPyX [Occ=Once]
                              :: m_afyrE (GHC.Base.Maybe a_XfyT2
                                          -> Data.Semigroup.Option a_XfyT2,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPyU] \u []
                                    GHC.Base.return $dMonad_sfPyU Data.Semigroup.$fDataOption1;
                          } in  GHC.Base.>>= $dMonad_sfPyU sat_sfPyX sat_sfPza;
                } in  GHC.Base.>>= $dMonad_sfPyU sat_sfPzb sat_sfPzh;
          };

Data.Semigroup.$fDataOption_$cgmapM
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option a)
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPzi $dMonad_sfPzj ds_sfPzk]
        let {
          $dData1_sfPzl [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_XfyT1)
          [LclId] =
              [$dData_sfPzi] \u [] Data.Data.$fDataMaybe $dData_sfPzi; } in
        let {
          lvl33_sfPzm [Occ=OnceL]
            :: m_afyro (GHC.Base.Maybe a_XfyT1
                        -> Data.Semigroup.Option a_XfyT1)
          [LclId] =
              [$dMonad_sfPzj] \u []
                  GHC.Base.return $dMonad_sfPzj Data.Semigroup.$fDataOption2; } in
        let {
          sat_sfPzu [Occ=OnceT[0]]
            :: Data.Semigroup.Option a_XfyT1
               -> m_afyro (Data.Semigroup.Option a_XfyT1)
          [LclId] =
              [$dMonad_sfPzj ds_sfPzk $dData1_sfPzl lvl33_sfPzm] \r [ds1_sfPzn]
                  let {
                    lvl34_sfPzo [Occ=OnceL] :: m_afyro (GHC.Base.Maybe a_XfyT1)
                    [LclId] =
                        [ds_sfPzk $dData1_sfPzl ds1_sfPzn] \u []
                            ds_sfPzk $dData1_sfPzl ds1_sfPzn; } in
                  let {
                    sat_sfPzt [Occ=Once]
                      :: (GHC.Base.Maybe a_XfyT1 -> Data.Semigroup.Option a_XfyT1)
                         -> m_afyro (Data.Semigroup.Option a_XfyT1)
                    [LclId] =
                        [$dMonad_sfPzj lvl34_sfPzo] \r [c'_sfPzp]
                            let {
                              sat_sfPzs [Occ=Once]
                                :: GHC.Base.Maybe a_XfyT1
                                   -> m_afyro (Data.Semigroup.Option a_XfyT1)
                              [LclId] =
                                  [$dMonad_sfPzj c'_sfPzp] \r [x'_sfPzq]
                                      let {
                                        sat_sfPzr [Occ=Once] :: Data.Semigroup.Option a_XfyT1
                                        [LclId] =
                                            [c'_sfPzp x'_sfPzq] \u [] c'_sfPzp x'_sfPzq;
                                      } in  GHC.Base.return $dMonad_sfPzj sat_sfPzr;
                            } in  GHC.Base.>>= $dMonad_sfPzj lvl34_sfPzo sat_sfPzs;
                  } in  GHC.Base.>>= $dMonad_sfPzj lvl33_sfPzm sat_sfPzt;
        } in  sat_sfPzu;

Data.Semigroup.$fDataOption_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Option a
     -> u
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPzv ds_sfPzw ds1_sfPzx x_sfPzy]
        case ds_sfPzw of {
          GHC.Types.I# x1_sfPzA [Occ=Once!] ->
              case x1_sfPzA of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# ->
                    let {
                      sat_sfPzC [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfyT0)
                      [LclId] =
                          [$dData_sfPzv] \u [] Data.Data.$fDataMaybe $dData_sfPzv;
                    } in  ds1_sfPzx sat_sfPzC x_sfPzy;
              };
        };

Data.Semigroup.$fDataOption_$cgmapQr
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Option a
     -> r
[GblId,
 Arity=5,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPzD ds_sfPzE ds1_sfPzF ds2_sfPzG x0_sfPzH]
        let {
          sat_sfPzJ [Occ=Once] :: r'_afyqG
          [LclId] =
              [$dData_sfPzD ds2_sfPzG x0_sfPzH] \u []
                  let {
                    sat_sfPzI [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfySY)
                    [LclId] =
                        [$dData_sfPzD] \u [] Data.Data.$fDataMaybe $dData_sfPzD;
                  } in  ds2_sfPzG sat_sfPzI x0_sfPzH;
        } in  ds_sfPzE sat_sfPzJ ds1_sfPzF;

Data.Semigroup.$fDataOption_$cgmapQ
  :: forall a.
     Data.Data.Data a =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Semigroup.Option a -> [u]
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,1*C1(C1(U))><L,U>m2,
 Unf=OtherCon []] =
    [] \r [$dData_sfPzK ds_sfPzL x0_sfPzM]
        let {
          sat_sfPzO [Occ=Once] :: u_afyqW
          [LclId] =
              [$dData_sfPzK ds_sfPzL x0_sfPzM] \u []
                  let {
                    sat_sfPzN [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfySZ)
                    [LclId] =
                        [$dData_sfPzK] \u [] Data.Data.$fDataMaybe $dData_sfPzK;
                  } in  ds_sfPzL sat_sfPzN x0_sfPzM;
        } in  : [sat_sfPzO GHC.Types.[]];

Data.Semigroup.$fDataOption_$cgmapQl
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Semigroup.Option a
     -> r
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPzP ds_sfPzQ ds1_sfPzR ds2_sfPzS]
        let {
          $dData1_sfPzT [Occ=OnceL]
            :: Data.Data.Data (GHC.Base.Maybe a_XfySX)
          [LclId] =
              [$dData_sfPzP] \u [] Data.Data.$fDataMaybe $dData_sfPzP; } in
        let {
          sat_sfPzW [Occ=OnceT[0]]
            :: Data.Semigroup.Option a_XfySX -> r_afyqo
          [LclId] =
              [ds_sfPzQ ds1_sfPzR ds2_sfPzS $dData1_sfPzT] \r [x_sfPzU]
                  let {
                    sat_sfPzV [Occ=Once] :: r'_afyqp
                    [LclId] =
                        [ds2_sfPzS $dData1_sfPzT x_sfPzU] \u []
                            ds2_sfPzS $dData1_sfPzT x_sfPzU;
                  } in  ds_sfPzQ ds1_sfPzR sat_sfPzV;
        } in  sat_sfPzW;

Data.Semigroup.$fDataOption3
  :: forall a.
     Data.Data.Data a =>
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Semigroup.Option a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPzX ds_sfPzY x0_sfPzZ]
        let {
          sat_sfPA0 [Occ=Once] :: Data.Data.Data (GHC.Base.Maybe a_XfySW)
          [LclId] =
              [$dData_sfPzX] \u [] Data.Data.$fDataMaybe $dData_sfPzX;
        } in  ds_sfPzY sat_sfPA0 x0_sfPzZ;

Data.Semigroup.$fDataOption_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Semigroup.Option a -> m (Data.Semigroup.Option a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dData_sfPA1 $dMonadPlus_sfPA2 ds_sfPA3 eta_sfPA4]
        let {
          lvl33_sfPA5 [Occ=OnceL] :: m_afyrU (Data.Semigroup.Option a_XfySV)
          [LclId] =
              [$dMonadPlus_sfPA2] \u [] GHC.Base.mzero $dMonadPlus_sfPA2;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sfPA2
          of
          $dMonad_sfPA6 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfPAw [Occ=Once]
                    :: (Data.Semigroup.Option a_XfySV, GHC.Types.Bool)
                       -> m_afyrU (Data.Semigroup.Option a_XfySV)
                  [LclId] =
                      [lvl33_sfPA5 $dMonad_sfPA6] \r [ds1_sfPAr]
                          case ds1_sfPAr of {
                            (,) x'_sfPAt [Occ=Once] b_sfPAu [Occ=Once!] ->
                                case b_sfPAu of {
                                  GHC.Types.False -> lvl33_sfPA5;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfPA6 x'_sfPAt;
                                };
                          }; } in
                let {
                  sat_sfPAq [Occ=Once]
                    :: m_afyrU (Data.Semigroup.Option a_XfySV, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sfPA1
                       $dMonadPlus_sfPA2
                       ds_sfPA3
                       eta_sfPA4
                       $dMonad_sfPA6] \u []
                          let {
                            lvl34_sfPA7 [Occ=OnceL] :: m_afyrU (GHC.Base.Maybe a_XfySV)
                            [LclId] =
                                [$dData_sfPA1 ds_sfPA3 eta_sfPA4] \u []
                                    let {
                                      sat_sfPA8 [Occ=Once]
                                        :: Data.Data.Data (GHC.Base.Maybe a_XfySV)
                                      [LclId] =
                                          [$dData_sfPA1] \u [] Data.Data.$fDataMaybe $dData_sfPA1;
                                    } in  ds_sfPA3 sat_sfPA8 eta_sfPA4; } in
                          let {
                            sat_sfPAp [Occ=Once]
                              :: (GHC.Base.Maybe a_XfySV -> Data.Semigroup.Option a_XfySV,
                                  GHC.Types.Bool)
                                 -> m_afyrU (Data.Semigroup.Option a_XfySV, GHC.Types.Bool)
                            [LclId] =
                                [$dMonadPlus_sfPA2
                                 eta_sfPA4
                                 $dMonad_sfPA6
                                 lvl34_sfPA7] \r [ds1_sfPAa]
                                    case ds1_sfPAa of {
                                      (,) h_sfPAc b1_sfPAd [Occ=Once!] ->
                                          case b1_sfPAd of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sfPAm [Occ=Once]
                                                    :: m_afyrU (Data.Semigroup.Option a_XfySV,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [eta_sfPA4 $dMonad_sfPA6 h_sfPAc] \u []
                                                          let {
                                                            sat_sfPAk [Occ=Once]
                                                              :: Data.Semigroup.Option a_XfySV
                                                            [LclId] =
                                                                [eta_sfPA4 h_sfPAc] \u []
                                                                    h_sfPAc eta_sfPA4; } in
                                                          let {
                                                            sat_sfPAl [Occ=Once]
                                                              :: (Data.Semigroup.Option a_XfySV,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sfPAk
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sfPA6 sat_sfPAl; } in
                                                let {
                                                  sat_sfPAj [Occ=Once]
                                                    :: m_afyrU (Data.Semigroup.Option a_XfySV,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sfPA6 lvl34_sfPA7 h_sfPAc] \u []
                                                          let {
                                                            sat_sfPAi [Occ=Once]
                                                              :: GHC.Base.Maybe a_XfySV
                                                                 -> m_afyrU (Data.Semigroup.Option
                                                                               a_XfySV,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sfPA6
                                                                 h_sfPAc] \r [y'_sfPAf]
                                                                    let {
                                                                      sat_sfPAg [Occ=Once]
                                                                        :: Data.Semigroup.Option
                                                                             a_XfySV
                                                                      [LclId] =
                                                                          [h_sfPAc y'_sfPAf] \u []
                                                                              h_sfPAc y'_sfPAf; } in
                                                                    let {
                                                                      sat_sfPAh [Occ=Once]
                                                                        :: (Data.Semigroup.Option
                                                                              a_XfySV,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sfPAg
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sfPA6 sat_sfPAh;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sfPA6 lvl34_sfPA7 sat_sfPAi;
                                                } in 
                                                  GHC.Base.mplus
                                                      $dMonadPlus_sfPA2 sat_sfPAj sat_sfPAm;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sfPAn [Occ=Once]
                                                    :: Data.Semigroup.Option a_XfySV
                                                  [LclId] =
                                                      [eta_sfPA4 h_sfPAc] \u []
                                                          h_sfPAc eta_sfPA4; } in
                                                let {
                                                  sat_sfPAo [Occ=Once]
                                                    :: (Data.Semigroup.Option a_XfySV,
                                                        GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sfPAn GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sfPA6 sat_sfPAo;
                                          };
                                    }; } in
                          let {
                            sat_sfPA9 [Occ=Once]
                              :: m_afyrU (GHC.Base.Maybe a_XfySV
                                          -> Data.Semigroup.Option a_XfySV,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sfPA6] \u []
                                    GHC.Base.return $dMonad_sfPA6 Data.Semigroup.$fDataOption1;
                          } in  GHC.Base.>>= $dMonad_sfPA6 sat_sfPA9 sat_sfPAp;
                } in  GHC.Base.>>= $dMonad_sfPA6 sat_sfPAq sat_sfPAw;
          };

lvl30_rfC7f
  :: forall a. Data.Semigroup.Option a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPAx] Data.Semigroup.$cOption;

lvl31_rfC7g
  :: forall a. Data.Semigroup.Option a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfPAy] Data.Semigroup.$tOption;

lvl32_rfC7h
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Semigroup.Option a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfPAz ds_sfPAA] GHC.Base.Nothing [];

Data.Semigroup.$fDataOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Semigroup.Option a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sfPAB]
        let {
          sat_sfPAN [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Option a_XfySU
               -> m (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfPAB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapMo
                      $dData_sfPAB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPAM [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Option a_XfySU
               -> m (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfPAB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapMp
                      $dData_sfPAB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPAL [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Semigroup.Option a_XfySU
               -> m (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfPAB] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapM
                      $dData_sfPAB eta_B2 eta_B1; } in
        let {
          sat_sfPAK [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Option a_XfySU
               -> u
          [LclId] =
              [$dData_sfPAB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQi
                      $dData_sfPAB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPAJ [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Semigroup.Option a_XfySU -> [u]
          [LclId] =
              [$dData_sfPAB] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQ
                      $dData_sfPAB eta_B2 eta_B1; } in
        let {
          sat_sfPAI [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Option a_XfySU
               -> r
          [LclId] =
              [$dData_sfPAB] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQr
                      $dData_sfPAB eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPAH [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Semigroup.Option a_XfySU
               -> r
          [LclId] =
              [$dData_sfPAB] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption_$cgmapQl
                      $dData_sfPAB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sfPAG [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Semigroup.Option a_XfySU -> Data.Semigroup.Option a_XfySU
          [LclId] =
              [$dData_sfPAB] \r [eta_B2 eta_B1]
                  Data.Semigroup.$fDataOption3 $dData_sfPAB eta_B2 eta_B1; } in
        let {
          sat_sfPAF [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Semigroup.Option a_XfySU))
          [LclId] =
              [$dData_sfPAB] \r [eta_B1]
                  Data.Semigroup.$fDataOption_$cdataCast1 $dData_sfPAB eta_B1; } in
        let {
          sat_sfPAE [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfPAB] \u []
                  Data.Semigroup.$fDataOption_$cgunfold $dData_sfPAB; } in
        let {
          sat_sfPAD [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Semigroup.Option a_XfySU
               -> c (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfPAB] \u []
                  Data.Semigroup.$fDataOption_$cgfoldl $dData_sfPAB; } in
        let {
          sat_sfPAC [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Semigroup.Option a_XfySU)
          [LclId] =
              [$dData_sfPAB] \u [] Data.Semigroup.$fDataOption10 $dData_sfPAB;
        } in 
          Data.Data.C:Data [sat_sfPAC
                            sat_sfPAD
                            sat_sfPAE
                            lvl30_rfC7f
                            lvl31_rfC7g
                            sat_sfPAF
                            lvl32_rfC7h
                            sat_sfPAG
                            sat_sfPAH
                            sat_sfPAI
                            sat_sfPAJ
                            sat_sfPAK
                            sat_sfPAL
                            sat_sfPAM
                            sat_sfPAN];

Data.Semigroup.Arg :: forall a b. a -> b -> Data.Semigroup.Arg a b
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Semigroup.Arg [eta_B2 eta_B1];

