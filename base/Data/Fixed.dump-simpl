
==================== Tidy Core ====================
2018-03-16 16:12:18.037601515 UTC

Result size of Tidy Core
  = {terms: 1,696, types: 2,405, coercions: 473, joins: 3/35}

-- RHS size: {terms: 3, types: 4, coercions: 2, joins: 0/0}
resolution [InlPrag=INLINE]
  :: forall a.
     HasResolution a =>
     forall (p :: * -> *). p a -> Integer
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ a_agnna) (v_B1 [Occ=Once] :: HasResolution a_agnna) ->
                 v_B1
                 `cast` (Data.Fixed.N:HasResolution[0] <a_agnna>_N
                         :: (HasResolution a_agnna :: Constraint)
                            ~R# (forall (p :: * -> *). p a_agnna -> Integer :: *))}]
resolution
  = \ (@ a_agnna) (v_B1 :: HasResolution a_agnna) ->
      v_B1
      `cast` (Data.Fixed.N:HasResolution[0] <a_agnna>_N
              :: (HasResolution a_agnna :: Constraint)
                 ~R# (forall (p :: * -> *). p a_agnna -> Integer :: *))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Fixed.$fDataFixed2 :: Integer -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (v_B1 [Occ=Once] :: Integer) -> v_B1}]
Data.Fixed.$fDataFixed2 = \ (v_B1 :: Integer) -> v_B1

-- RHS size: {terms: 11, types: 35, coercions: 7, joins: 0/0}
Data.Fixed.$fDataFixed_$cgfoldl
  :: forall a.
     Typeable a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Fixed a -> c (Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agnL1)
                 _ [Occ=Dead]
                 (@ (c_agnLa :: * -> *))
                 (k_agnnY [Occ=Once!]
                    :: forall d b. Data d => c_agnLa (d -> b) -> d -> c_agnLa b)
                 (z_agnnZ [Occ=Once!] :: forall g. g -> c_agnLa g)
                 (ds_dgnWC [Occ=Once] :: Fixed a_agnL1) ->
                 k_agnnY
                   @ Integer
                   @ (Fixed a_agnL1)
                   Data.Data.$fDataInteger
                   (z_agnnZ
                      @ (Integer -> Fixed a_agnL1)
                      (Data.Fixed.$fDataFixed2
                       `cast` (<Integer>_R ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnL1>_P)
                               :: (Integer -> Integer :: *) ~R# (Integer -> Fixed a_agnL1 :: *))))
                   (ds_dgnWC
                    `cast` (Data.Fixed.N:Fixed[0] <a_agnL1>_P
                            :: (Fixed a_agnL1 :: *) ~R# (Integer :: *)))}]
Data.Fixed.$fDataFixed_$cgfoldl
  = \ (@ a_agnL1)
      _ [Occ=Dead]
      (@ (c_agnLa :: * -> *))
      (k_agnnY
         :: forall d b. Data d => c_agnLa (d -> b) -> d -> c_agnLa b)
      (z_agnnZ :: forall g. g -> c_agnLa g)
      (ds_dgnWC :: Fixed a_agnL1) ->
      k_agnnY
        @ Integer
        @ (Fixed a_agnL1)
        Data.Data.$fDataInteger
        (z_agnnZ
           @ (Integer -> Fixed a_agnL1)
           (Data.Fixed.$fDataFixed2
            `cast` (<Integer>_R ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnL1>_P)
                    :: (Integer -> Integer :: *) ~R# (Integer -> Fixed a_agnL1 :: *))))
        (ds_dgnWC
         `cast` (Data.Fixed.N:Fixed[0] <a_agnL1>_P
                 :: (Fixed a_agnL1 :: *) ~R# (Integer :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$fEnumFixed1 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Fixed.$fEnumFixed1 = 0

-- RHS size: {terms: 48, types: 30, coercions: 18, joins: 0/3}
Data.Fixed.$fEnumFixed_$cenumFromThenTo
  :: forall a. Fixed a -> Fixed a -> Fixed a -> [Fixed a]
[GblId,
 Arity=3,
 Str=<S,U><S,1*U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 390 0}]
Data.Fixed.$fEnumFixed_$cenumFromThenTo
  = \ (@ a_agnJM)
      (ds_dgnWs :: Fixed a_agnJM)
      (ds1_dgnWt :: Fixed a_agnJM)
      (ds2_dgnWu :: Fixed a_agnJM) ->
      let {
        delta_ignXu [Dmd=<S,U>] :: Integer
        [LclId]
        delta_ignXu
          = integer-simple-0.1.1.1:GHC.Integer.Type.minusInteger
              (ds1_dgnWt
               `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                       :: (Fixed a_agnJM :: *) ~R# (Integer :: *)))
              (ds_dgnWs
               `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                       :: (Fixed a_agnJM :: *) ~R# (Integer :: *))) } in
      case integer-simple-0.1.1.1:GHC.Integer.Type.geInteger#
             delta_ignXu Data.Fixed.$fEnumFixed1
      of {
        __DEFAULT ->
          letrec {
            go_igofY [Occ=LoopBreaker] :: Integer -> [Fixed a_agnJM]
            [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
            go_igofY
              = \ (x_igofZ :: Integer) ->
                  case integer-simple-0.1.1.1:GHC.Integer.Type.ltInteger#
                         x_igofZ
                         (ds2_dgnWu
                          `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                                  :: (Fixed a_agnJM :: *) ~R# (Integer :: *)))
                  of {
                    __DEFAULT ->
                      GHC.Types.:
                        @ (Fixed a_agnJM)
                        (x_igofZ
                         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnJM>_P)
                                 :: (Integer :: *) ~R# (Fixed a_agnJM :: *)))
                        (go_igofY
                           (integer-simple-0.1.1.1:GHC.Integer.Type.plusInteger
                              x_igofZ delta_ignXu));
                    1# -> GHC.Types.[] @ (Fixed a_agnJM)
                  }; } in
          go_igofY
            (ds_dgnWs
             `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                     :: (Fixed a_agnJM :: *) ~R# (Integer :: *)));
        1# ->
          letrec {
            go_igog8 [Occ=LoopBreaker] :: Integer -> [Fixed a_agnJM]
            [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
            go_igog8
              = \ (x_igog9 :: Integer) ->
                  case integer-simple-0.1.1.1:GHC.Integer.Type.gtInteger#
                         x_igog9
                         (ds2_dgnWu
                          `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                                  :: (Fixed a_agnJM :: *) ~R# (Integer :: *)))
                  of {
                    __DEFAULT ->
                      GHC.Types.:
                        @ (Fixed a_agnJM)
                        (x_igog9
                         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnJM>_P)
                                 :: (Integer :: *) ~R# (Fixed a_agnJM :: *)))
                        (go_igog8
                           (integer-simple-0.1.1.1:GHC.Integer.Type.plusInteger
                              x_igog9 delta_ignXu));
                    1# -> GHC.Types.[] @ (Fixed a_agnJM)
                  }; } in
          go_igog8
            (ds_dgnWs
             `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                     :: (Fixed a_agnJM :: *) ~R# (Integer :: *)))
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$fEnumFixed2 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Fixed.$fEnumFixed2 = 1

-- RHS size: {terms: 20, types: 16, coercions: 7, joins: 0/1}
Data.Fixed.$fEnumFixed_$cenumFromTo
  :: forall a. Fixed a -> Fixed a -> [Fixed a]
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 150 0}]
Data.Fixed.$fEnumFixed_$cenumFromTo
  = \ (@ a_agnJM)
      (ds_dgnWl :: Fixed a_agnJM)
      (ds1_dgnWm :: Fixed a_agnJM) ->
      letrec {
        go_ignXS [Occ=LoopBreaker] :: Integer -> [Fixed a_agnJM]
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        go_ignXS
          = \ (x_ignXT :: Integer) ->
              case integer-simple-0.1.1.1:GHC.Integer.Type.gtInteger#
                     x_ignXT
                     (ds1_dgnWm
                      `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                              :: (Fixed a_agnJM :: *) ~R# (Integer :: *)))
              of {
                __DEFAULT ->
                  GHC.Types.:
                    @ (Fixed a_agnJM)
                    (x_ignXT
                     `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnJM>_P)
                             :: (Integer :: *) ~R# (Fixed a_agnJM :: *)))
                    (go_ignXS
                       (integer-simple-0.1.1.1:GHC.Integer.Type.plusInteger
                          x_ignXT Data.Fixed.$fEnumFixed2));
                1# -> GHC.Types.[] @ (Fixed a_agnJM)
              }; } in
      go_ignXS
        (ds_dgnWl
         `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                 :: (Fixed a_agnJM :: *) ~R# (Integer :: *)))

-- RHS size: {terms: 20, types: 15, coercions: 9, joins: 0/2}
Data.Fixed.$fEnumFixed_$cenumFromThen
  :: forall a. Fixed a -> Fixed a -> [Fixed a]
[GblId,
 Arity=2,
 Str=<S,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 150 0}]
Data.Fixed.$fEnumFixed_$cenumFromThen
  = \ (@ a_agnJM)
      (ds_dgnWe :: Fixed a_agnJM)
      (ds1_dgnWf :: Fixed a_agnJM) ->
      let {
        d_ignY6 :: Integer
        [LclId]
        d_ignY6
          = integer-simple-0.1.1.1:GHC.Integer.Type.minusInteger
              (ds1_dgnWf
               `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                       :: (Fixed a_agnJM :: *) ~R# (Integer :: *)))
              (ds_dgnWe
               `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                       :: (Fixed a_agnJM :: *) ~R# (Integer :: *))) } in
      letrec {
        go_ignY7 [Occ=LoopBreaker] :: Integer -> [Fixed a_agnJM]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_ignY7
          = \ (x_ignY8 :: Integer) ->
              case x_ignY8 of x1_ignY9 { __DEFAULT ->
              GHC.Types.:
                @ (Fixed a_agnJM)
                (x1_ignY9
                 `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnJM>_P)
                         :: (Integer :: *) ~R# (Fixed a_agnJM :: *)))
                (go_ignY7
                   (integer-simple-0.1.1.1:GHC.Integer.Type.plusInteger
                      x1_ignY9 d_ignY6))
              }; } in
      go_ignY7
        (ds_dgnWe
         `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                 :: (Fixed a_agnJM :: *) ~R# (Integer :: *)))

Rec {
-- RHS size: {terms: 11, types: 7, coercions: 3, joins: 0/0}
Data.Fixed.$fEnumFixed3 [Occ=LoopBreaker]
  :: forall a. Integer -> [Fixed a]
[GblId, Arity=1, Str=<S,1*U>m2, Unf=OtherCon []]
Data.Fixed.$fEnumFixed3
  = \ (@ a_agnJM) (x_ignY8 :: Integer) ->
      case x_ignY8 of x1_ignY9 { __DEFAULT ->
      GHC.Types.:
        @ (Fixed a_agnJM)
        (x1_ignY9
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnJM>_P)
                 :: (Integer :: *) ~R# (Fixed a_agnJM :: *)))
        (Data.Fixed.$fEnumFixed3
           @ a_agnJM
           (integer-simple-0.1.1.1:GHC.Integer.Type.plusInteger
              x1_ignY9 Data.Fixed.$fEnumFixed2))
      }
end Rec }

-- RHS size: {terms: 4, types: 5, coercions: 2, joins: 0/0}
Data.Fixed.$fEnumFixed_$cenumFrom :: forall a. Fixed a -> [Fixed a]
[GblId,
 Arity=1,
 Str=<S,1*U>m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
Data.Fixed.$fEnumFixed_$cenumFrom
  = \ (@ a_agnJM) (ds_dgnWa :: Fixed a_agnJM) ->
      Data.Fixed.$fEnumFixed3
        @ a_agnJM
        (ds_dgnWa
         `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                 :: (Fixed a_agnJM :: *) ~R# (Integer :: *)))

-- RHS size: {terms: 4, types: 4, coercions: 2, joins: 0/0}
Data.Fixed.$fEnumFixed_$cfromEnum :: forall a. Fixed a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agnJM) (ds_dgnW6 [Occ=Once] :: Fixed a_agnJM) ->
                 GHC.Enum.$fEnumInteger_$cfromEnum
                   (ds_dgnW6
                    `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                            :: (Fixed a_agnJM :: *) ~R# (Integer :: *)))}]
Data.Fixed.$fEnumFixed_$cfromEnum
  = \ (@ a_agnJM) (ds_dgnW6 :: Fixed a_agnJM) ->
      GHC.Enum.$fEnumInteger_$cfromEnum
        (ds_dgnW6
         `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                 :: (Fixed a_agnJM :: *) ~R# (Integer :: *)))

-- RHS size: {terms: 4, types: 4, coercions: 2, joins: 0/0}
Data.Fixed.$fEnumFixed4 :: forall a. Fixed a -> Integer
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_agnJM) (ds_dgnW1 [Occ=Once] :: Fixed a_agnJM) ->
                 GHC.Enum.$fEnumInteger_$cpred
                   (ds_dgnW1
                    `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                            :: (Fixed a_agnJM :: *) ~R# (Integer :: *)))}]
Data.Fixed.$fEnumFixed4
  = \ (@ a_agnJM) (ds_dgnW1 :: Fixed a_agnJM) ->
      GHC.Enum.$fEnumInteger_$cpred
        (ds_dgnW1
         `cast` (Data.Fixed.N:Fixed[0] <a_agnJM>_P
                 :: (Fixed a_agnJM :: *) ~R# (Integer :: *)))

-- RHS size: {terms: 4, types: 4, coercions: 2, joins: 0/0}
Data.Fixed.$fEnumFixed5 :: forall a. Fixed a -> Integer
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_XgnLK) (ds_dgnVX [Occ=Once] :: Fixed a_XgnLK) ->
                 GHC.Enum.$fEnumInteger_$csucc
                   (ds_dgnVX
                    `cast` (Data.Fixed.N:Fixed[0] <a_XgnLK>_P
                            :: (Fixed a_XgnLK :: *) ~R# (Integer :: *)))}]
Data.Fixed.$fEnumFixed5
  = \ (@ a_XgnLK) (ds_dgnVX :: Fixed a_XgnLK) ->
      GHC.Enum.$fEnumInteger_$csucc
        (ds_dgnVX
         `cast` (Data.Fixed.N:Fixed[0] <a_XgnLK>_P
                 :: (Fixed a_XgnLK :: *) ~R# (Integer :: *)))

-- RHS size: {terms: 10, types: 11, coercions: 17, joins: 0/0}
Data.Fixed.$fEnumFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Enum (Fixed a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_agnnL) ->
       GHC.Enum.C:Enum TYPE: Fixed a_agnnL
                       (Data.Fixed.$fEnumFixed5 @ a_agnnL)
                       `cast` (<Fixed a_agnnL>_R
                               ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnL>_P)
                               :: (Fixed a_agnnL -> Integer :: *)
                                  ~R# (Fixed a_agnnL -> Fixed a_agnnL :: *))
                       (Data.Fixed.$fEnumFixed4 @ a_agnnL)
                       `cast` (<Fixed a_agnnL>_R
                               ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnL>_P)
                               :: (Fixed a_agnnL -> Integer :: *)
                                  ~R# (Fixed a_agnnL -> Fixed a_agnnL :: *))
                       GHC.Enum.$fEnumInteger_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnL>_P)
                               :: (Int -> Integer :: *) ~R# (Int -> Fixed a_agnnL :: *))
                       Data.Fixed.$fEnumFixed_$cfromEnum @ a_agnnL
                       Data.Fixed.$fEnumFixed_$cenumFrom @ a_agnnL
                       Data.Fixed.$fEnumFixed_$cenumFromThen @ a_agnnL
                       Data.Fixed.$fEnumFixed_$cenumFromTo @ a_agnnL
                       Data.Fixed.$fEnumFixed_$cenumFromThenTo @ a_agnnL]
Data.Fixed.$fEnumFixed
  = \ (@ a_XgnLO) ->
      GHC.Enum.C:Enum
        @ (Fixed a_XgnLO)
        ((Data.Fixed.$fEnumFixed5 @ a_XgnLO)
         `cast` (<Fixed a_XgnLO>_R
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnLO>_P)
                 :: (Fixed a_XgnLO -> Integer :: *)
                    ~R# (Fixed a_XgnLO -> Fixed a_XgnLO :: *)))
        ((Data.Fixed.$fEnumFixed4 @ a_XgnLO)
         `cast` (<Fixed a_XgnLO>_R
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnLO>_P)
                 :: (Fixed a_XgnLO -> Integer :: *)
                    ~R# (Fixed a_XgnLO -> Fixed a_XgnLO :: *)))
        (GHC.Enum.$fEnumInteger_$ctoEnum
         `cast` (<Int>_R ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnLO>_P)
                 :: (Int -> Integer :: *) ~R# (Int -> Fixed a_XgnLO :: *)))
        (Data.Fixed.$fEnumFixed_$cfromEnum @ a_XgnLO)
        (Data.Fixed.$fEnumFixed_$cenumFrom @ a_XgnLO)
        (Data.Fixed.$fEnumFixed_$cenumFromThen @ a_XgnLO)
        (Data.Fixed.$fEnumFixed_$cenumFromTo @ a_XgnLO)
        (Data.Fixed.$fEnumFixed_$cenumFromThenTo @ a_XgnLO)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Fixed.$fHasResolutionE0_$cresolution
  :: forall (p :: * -> *). p E0 -> Integer
[GblId,
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (p_agnF7 :: * -> *)) _ [Occ=Dead] ->
                 Data.Fixed.$fEnumFixed2}]
Data.Fixed.$fHasResolutionE0_$cresolution
  = \ (@ (p_agnF7 :: * -> *)) _ [Occ=Dead] -> Data.Fixed.$fEnumFixed2

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Data.Fixed.$fHasResolutionE0 [InlPrag=INLINE (sat-args=0)]
  :: HasResolution E0
[GblId[DFunId(nt)],
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Fixed.$fHasResolutionE0_$cresolution
               `cast` (Sym (Data.Fixed.N:HasResolution[0] <E0>_N)
                       :: (forall (p :: * -> *). p E0 -> Integer :: *)
                          ~R# (HasResolution E0 :: Constraint))}]
Data.Fixed.$fHasResolutionE0
  = Data.Fixed.$fHasResolutionE0_$cresolution
    `cast` (Sym (Data.Fixed.N:HasResolution[0] <E0>_N)
            :: (forall (p :: * -> *). p E0 -> Integer :: *)
               ~R# (HasResolution E0 :: Constraint))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$fHasResolutionE4 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Fixed.$fHasResolutionE4 = 10

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Fixed.$fHasResolutionE1_$cresolution
  :: forall (p :: * -> *). p E1 -> Integer
[GblId,
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (p_agnF0 :: * -> *)) _ [Occ=Dead] ->
                 Data.Fixed.$fHasResolutionE4}]
Data.Fixed.$fHasResolutionE1_$cresolution
  = \ (@ (p_agnF0 :: * -> *)) _ [Occ=Dead] ->
      Data.Fixed.$fHasResolutionE4

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Data.Fixed.$fHasResolutionE1 [InlPrag=INLINE (sat-args=0)]
  :: HasResolution E1
[GblId[DFunId(nt)],
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Fixed.$fHasResolutionE1_$cresolution
               `cast` (Sym (Data.Fixed.N:HasResolution[0] <E1>_N)
                       :: (forall (p :: * -> *). p E1 -> Integer :: *)
                          ~R# (HasResolution E1 :: Constraint))}]
Data.Fixed.$fHasResolutionE1
  = Data.Fixed.$fHasResolutionE1_$cresolution
    `cast` (Sym (Data.Fixed.N:HasResolution[0] <E1>_N)
            :: (forall (p :: * -> *). p E1 -> Integer :: *)
               ~R# (HasResolution E1 :: Constraint))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$fHasResolutionE7 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Fixed.$fHasResolutionE7 = 100

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Fixed.$fHasResolutionE2_$cresolution
  :: forall (p :: * -> *). p E2 -> Integer
[GblId,
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (p_agnET :: * -> *)) _ [Occ=Dead] ->
                 Data.Fixed.$fHasResolutionE7}]
Data.Fixed.$fHasResolutionE2_$cresolution
  = \ (@ (p_agnET :: * -> *)) _ [Occ=Dead] ->
      Data.Fixed.$fHasResolutionE7

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Data.Fixed.$fHasResolutionE2 [InlPrag=INLINE (sat-args=0)]
  :: HasResolution E2
[GblId[DFunId(nt)],
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Fixed.$fHasResolutionE2_$cresolution
               `cast` (Sym (Data.Fixed.N:HasResolution[0] <E2>_N)
                       :: (forall (p :: * -> *). p E2 -> Integer :: *)
                          ~R# (HasResolution E2 :: Constraint))}]
Data.Fixed.$fHasResolutionE2
  = Data.Fixed.$fHasResolutionE2_$cresolution
    `cast` (Sym (Data.Fixed.N:HasResolution[0] <E2>_N)
            :: (forall (p :: * -> *). p E2 -> Integer :: *)
               ~R# (HasResolution E2 :: Constraint))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$fHasResolutionE8 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Fixed.$fHasResolutionE8 = 1000

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Fixed.$fHasResolutionE3_$cresolution
  :: forall (p :: * -> *). p E3 -> Integer
[GblId,
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (p_agnEM :: * -> *)) _ [Occ=Dead] ->
                 Data.Fixed.$fHasResolutionE8}]
Data.Fixed.$fHasResolutionE3_$cresolution
  = \ (@ (p_agnEM :: * -> *)) _ [Occ=Dead] ->
      Data.Fixed.$fHasResolutionE8

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Data.Fixed.$fHasResolutionE3 [InlPrag=INLINE (sat-args=0)]
  :: HasResolution E3
[GblId[DFunId(nt)],
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Fixed.$fHasResolutionE3_$cresolution
               `cast` (Sym (Data.Fixed.N:HasResolution[0] <E3>_N)
                       :: (forall (p :: * -> *). p E3 -> Integer :: *)
                          ~R# (HasResolution E3 :: Constraint))}]
Data.Fixed.$fHasResolutionE3
  = Data.Fixed.$fHasResolutionE3_$cresolution
    `cast` (Sym (Data.Fixed.N:HasResolution[0] <E3>_N)
            :: (forall (p :: * -> *). p E3 -> Integer :: *)
               ~R# (HasResolution E3 :: Constraint))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$fHasResolutionE10 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Fixed.$fHasResolutionE10 = 1000000

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Fixed.$fHasResolutionE6_$cresolution
  :: forall (p :: * -> *). p E6 -> Integer
[GblId,
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (p_agnEF :: * -> *)) _ [Occ=Dead] ->
                 Data.Fixed.$fHasResolutionE10}]
Data.Fixed.$fHasResolutionE6_$cresolution
  = \ (@ (p_agnEF :: * -> *)) _ [Occ=Dead] ->
      Data.Fixed.$fHasResolutionE10

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Data.Fixed.$fHasResolutionE6 [InlPrag=INLINE (sat-args=0)]
  :: HasResolution E6
[GblId[DFunId(nt)],
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Fixed.$fHasResolutionE6_$cresolution
               `cast` (Sym (Data.Fixed.N:HasResolution[0] <E6>_N)
                       :: (forall (p :: * -> *). p E6 -> Integer :: *)
                          ~R# (HasResolution E6 :: Constraint))}]
Data.Fixed.$fHasResolutionE6
  = Data.Fixed.$fHasResolutionE6_$cresolution
    `cast` (Sym (Data.Fixed.N:HasResolution[0] <E6>_N)
            :: (forall (p :: * -> *). p E6 -> Integer :: *)
               ~R# (HasResolution E6 :: Constraint))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$fHasResolutionE11 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Fixed.$fHasResolutionE11 = 1000000000

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Fixed.$fHasResolutionE9_$cresolution
  :: forall (p :: * -> *). p E9 -> Integer
[GblId,
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (p_agnEy :: * -> *)) _ [Occ=Dead] ->
                 Data.Fixed.$fHasResolutionE11}]
Data.Fixed.$fHasResolutionE9_$cresolution
  = \ (@ (p_agnEy :: * -> *)) _ [Occ=Dead] ->
      Data.Fixed.$fHasResolutionE11

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Data.Fixed.$fHasResolutionE9 [InlPrag=INLINE (sat-args=0)]
  :: HasResolution E9
[GblId[DFunId(nt)],
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Fixed.$fHasResolutionE9_$cresolution
               `cast` (Sym (Data.Fixed.N:HasResolution[0] <E9>_N)
                       :: (forall (p :: * -> *). p E9 -> Integer :: *)
                          ~R# (HasResolution E9 :: Constraint))}]
Data.Fixed.$fHasResolutionE9
  = Data.Fixed.$fHasResolutionE9_$cresolution
    `cast` (Sym (Data.Fixed.N:HasResolution[0] <E9>_N)
            :: (forall (p :: * -> *). p E9 -> Integer :: *)
               ~R# (HasResolution E9 :: Constraint))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$fHasResolutionE5 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Fixed.$fHasResolutionE5 = 1000000000000

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Fixed.$fHasResolutionE12_$cresolution
  :: forall (p :: * -> *). p E12 -> Integer
[GblId,
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (p_agnEr :: * -> *)) _ [Occ=Dead] ->
                 Data.Fixed.$fHasResolutionE5}]
Data.Fixed.$fHasResolutionE12_$cresolution
  = \ (@ (p_agnEr :: * -> *)) _ [Occ=Dead] ->
      Data.Fixed.$fHasResolutionE5

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Data.Fixed.$fHasResolutionE12 [InlPrag=INLINE (sat-args=0)]
  :: HasResolution E12
[GblId[DFunId(nt)],
 Arity=1,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= Data.Fixed.$fHasResolutionE12_$cresolution
               `cast` (Sym (Data.Fixed.N:HasResolution[0] <E12>_N)
                       :: (forall (p :: * -> *). p E12 -> Integer :: *)
                          ~R# (HasResolution E12 :: Constraint))}]
Data.Fixed.$fHasResolutionE12
  = Data.Fixed.$fHasResolutionE12_$cresolution
    `cast` (Sym (Data.Fixed.N:HasResolution[0] <E12>_N)
            :: (forall (p :: * -> *). p E12 -> Integer :: *)
               ~R# (HasResolution E12 :: Constraint))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$fDataFixed6 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Fixed.$fDataFixed6 = "Data.Fixed.Fixed"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$fDataFixed5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Fixed.$fDataFixed5
  = GHC.CString.unpackCString# Data.Fixed.$fDataFixed6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
w1_rgoyk :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
w1_rgoyk = "MkFixed"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
w2_rgoyl :: String
[GblId]
w2_rgoyl = GHC.CString.unpackCString# w1_rgoyk

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go61_rgoym :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go61_rgoym
  = \ (ds2_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds2_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Data.Data.Constr ds3_de7m3 ds4_de7m4 ds5_de7m5 ds6_de7m6
                                 ds7_de7m7 ->
              case GHC.Base.eqString ds4_de7m4 w2_rgoyl of {
                False -> go61_rgoym ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
conMkFixed1_rgoyn :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
conMkFixed1_rgoyn = Data.Data.AlgConstr conMkFixed2_rgoyo

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Fixed.$fDataFixed4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Fixed.$fDataFixed4
  = GHC.Types.: @ Constr conMkFixed (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$fDataFixed3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Fixed.$fDataFixed3 = Data.Data.AlgRep Data.Fixed.$fDataFixed4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
tyFixed :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
tyFixed
  = Data.Data.DataType
      Data.Fixed.$fDataFixed5 Data.Fixed.$fDataFixed3

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
conMkFixed [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
conMkFixed
  = Data.Data.Constr
      conMkFixed1_rgoyn
      w2_rgoyl
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      tyFixed

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
conMkFixed2_rgoyo :: ConIndex
[GblId]
conMkFixed2_rgoyo
  = go61_rgoym Data.Fixed.$fDataFixed4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Fixed.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
loc_rgoyp :: [Char]
[GblId]
loc_rgoyp = GHC.CString.unpackCString# Data.Fixed.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Fixed.$trModule2 = "Data.Fixed"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
loc1_rgoyq :: [Char]
[GblId]
loc1_rgoyq = GHC.CString.unpackCString# Data.Fixed.$trModule2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
loc2_rgoyr :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
loc2_rgoyr = "./Data/Fixed.hs"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
loc3_rgoys :: [Char]
[GblId]
loc3_rgoys = GHC.CString.unpackCString# loc2_rgoyr

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
loc4_rgoyt :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
loc4_rgoyt = GHC.Types.I# 83#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
loc5_rgoyu :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
loc5_rgoyu = GHC.Types.I# 20#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
loc6_rgoyv :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
loc6_rgoyv = GHC.Types.I# 29#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$dIP_rgoyw :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$dIP_rgoyw = "undefined"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$dIP1_rgoyx :: [Char]
[GblId]
$dIP1_rgoyx = GHC.CString.unpackCString# $dIP_rgoyw

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
$dIP2_rgoyy :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []]
$dIP2_rgoyy
  = GHC.Stack.Types.SrcLoc
      loc_rgoyp
      loc1_rgoyq
      loc3_rgoys
      loc4_rgoyt
      loc5_rgoyu
      loc4_rgoyt
      loc6_rgoyv

-- RHS size: {terms: 4, types: 0, coercions: 0, joins: 0/0}
$dIP3_rgoyz :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []]
$dIP3_rgoyz
  = GHC.Stack.Types.PushCallStack
      $dIP1_rgoyx $dIP2_rgoyy GHC.Stack.Types.EmptyCallStack

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Fixed.$trModule3 = GHC.Types.TrNameS Data.Fixed.$trModule4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Fixed.$trModule1 = GHC.Types.TrNameS Data.Fixed.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Fixed.$trModule
  = GHC.Types.Module Data.Fixed.$trModule3 Data.Fixed.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_rgoyA :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_rgoyA
  = GHC.Types.KindRepTyConApp
      integer-simple-0.1.1.1:GHC.Integer.Type.$tcInteger
      (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_rgoyB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_rgoyB
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcHasResolution1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Fixed.$tcHasResolution1
  = GHC.Types.KindRepFun GHC.Types.krep$* $krep1_rgoyB

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2_rgoyC :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep2_rgoyC = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$fDataFixed10 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Fixed.$fDataFixed10 = "Fixed"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$fDataFixed9 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Fixed.$fDataFixed9
  = GHC.Types.TrNameS Data.Fixed.$fDataFixed10

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcFixed :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Fixed.$tcFixed
  = GHC.Types.TyCon
      12850707307297787398##
      5875431371990069009##
      Data.Fixed.$trModule
      Data.Fixed.$fDataFixed9
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep3_rgoyD :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep3_rgoyD
  = GHC.Types.:
      @ GHC.Types.KindRep $krep2_rgoyC (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4_rgoyE :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep4_rgoyE
  = GHC.Types.KindRepTyConApp Data.Fixed.$tcFixed $krep3_rgoyD

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tc'MkFixed1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Fixed.$tc'MkFixed1
  = GHC.Types.KindRepFun $krep_rgoyA $krep4_rgoyE

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tc'MkFixed3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Fixed.$tc'MkFixed3 = "'MkFixed"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tc'MkFixed2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Fixed.$tc'MkFixed2 = GHC.Types.TrNameS Data.Fixed.$tc'MkFixed3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tc'MkFixed :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Fixed.$tc'MkFixed
  = GHC.Types.TyCon
      8992689233320522225##
      9587721628087041380##
      Data.Fixed.$trModule
      Data.Fixed.$tc'MkFixed2
      1#
      Data.Fixed.$tc'MkFixed1

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Fixed.$fDataFixed8 :: Data.Typeable.Internal.TypeRep Fixed
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Fixed.$fDataFixed8
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Fixed
           12850707307297787398##
           5875431371990069009##
           Data.Fixed.$trModule
           Data.Fixed.$fDataFixed9
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Fixed
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 5, types: 12, coercions: 4, joins: 0/0}
Data.Fixed.$fDataFixed7
  :: forall a. Typeable a => Data.Typeable.Internal.TypeRep (Fixed a)
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agnL1)
                 ($dTypeable_agnL2 [Occ=Once] :: Typeable a_agnL1) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Fixed
                   @ a_agnL1
                   Data.Fixed.$fDataFixed8
                   ($dTypeable_agnL2
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_agnL1>_N
                            :: (Typeable a_agnL1 :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_agnL1 :: *)))}]
Data.Fixed.$fDataFixed7
  = \ (@ a_agnL1) ($dTypeable_agnL2 :: Typeable a_agnL1) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Fixed
        @ a_agnL1
        Data.Fixed.$fDataFixed8
        ($dTypeable_agnL2
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_agnL1>_N
                 :: (Typeable a_agnL1 :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_agnL1 :: *)))

-- RHS size: {terms: 4, types: 6, coercions: 5, joins: 0/0}
Data.Fixed.$fDataFixed1 :: forall a. (Integer -> Fixed a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Fixed.$fDataFixed1
  = \ (@ a_XgnOd) ->
      (Data.Fixed.$fDataFixed2
       `cast` (<Integer>_R ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnOd>_P)
               :: (Integer -> Integer :: *) ~R# (Integer -> Fixed a_XgnOd :: *)),
       GHC.Types.False)

-- RHS size: {terms: 56, types: 110, coercions: 4, joins: 0/3}
Data.Fixed.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data d => d -> m d) -> Fixed a -> m (Fixed a)
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 0] 510 0}]
Data.Fixed.$w$cgmapMp
  = \ (@ a_sgomL)
      (@ (m_sgomN :: * -> *))
      (w_sgomO :: GHC.Base.MonadPlus m_sgomN)
      (w3_sgomP :: forall d. Data d => d -> m_sgomN d)
      (w4_sgomQ :: Fixed a_sgomL) ->
      let {
        lvl17_sgo7C :: m_sgomN (Fixed a_sgomL)
        [LclId]
        lvl17_sgo7C
          = GHC.Base.mzero @ m_sgomN w_sgomO @ (Fixed a_sgomL) } in
      let {
        $dMonad_sgo6F [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_sgomN
        [LclId]
        $dMonad_sgo6F = GHC.Base.$p2MonadPlus @ m_sgomN w_sgomO } in
      >>=
        @ m_sgomN
        $dMonad_sgo6F
        @ (Fixed a_sgomL, Bool)
        @ (Fixed a_sgomL)
        (let {
           lvl18_sgo7B :: m_sgomN Integer
           [LclId]
           lvl18_sgo7B
             = w3_sgomP
                 @ Integer
                 Data.Data.$fDataInteger
                 (w4_sgomQ
                  `cast` (Data.Fixed.N:Fixed[0] <a_sgomL>_P
                          :: (Fixed a_sgomL :: *) ~R# (Integer :: *))) } in
         >>=
           @ m_sgomN
           $dMonad_sgo6F
           @ (Integer -> Fixed a_sgomL, Bool)
           @ (Fixed a_sgomL, Bool)
           (return
              @ m_sgomN
              $dMonad_sgo6F
              @ (Integer -> Fixed a_sgomL, Bool)
              (Data.Fixed.$fDataFixed1 @ a_sgomL))
           (\ (ds1_de7oD :: (Integer -> Fixed a_sgomL, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b1_ae1TB) ->
              GHC.Base.mplus
                @ m_sgomN
                w_sgomO
                @ (Fixed a_sgomL, Bool)
                (>>=
                   @ m_sgomN
                   $dMonad_sgo6F
                   @ Integer
                   @ (Fixed a_sgomL, Bool)
                   lvl18_sgo7B
                   (\ (y'_ae1TC :: Integer) ->
                      return
                        @ m_sgomN
                        $dMonad_sgo6F
                        @ (Fixed a_sgomL, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_sgomN
                   $dMonad_sgo6F
                   @ (Fixed a_sgomL, Bool)
                   (h_ae1TA
                      (w4_sgomQ
                       `cast` (Data.Fixed.N:Fixed[0] <a_sgomL>_P
                               :: (Fixed a_sgomL :: *) ~R# (Integer :: *))),
                    b1_ae1TB))
              }))
        (\ (ds_de7oa :: (Fixed a_sgomL, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl17_sgo7C;
             True -> return @ m_sgomN $dMonad_sgo6F @ (Fixed a_sgomL) x'_ae1TD
           }
           })

-- RHS size: {terms: 10, types: 23, coercions: 0, joins: 0/0}
Data.Fixed.$fDataFixed_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Typeable a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data d => d -> m d) -> Fixed a -> m (Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sgomL)
                 _ [Occ=Dead]
                 (@ (m_sgomN :: * -> *))
                 (w3_sgomO [Occ=Once] :: GHC.Base.MonadPlus m_sgomN)
                 (w4_sgomP [Occ=Once] :: forall d. Data d => d -> m_sgomN d)
                 (w5_sgomQ [Occ=Once] :: Fixed a_sgomL) ->
                 Data.Fixed.$w$cgmapMp
                   @ a_sgomL @ m_sgomN w3_sgomO w4_sgomP w5_sgomQ}]
Data.Fixed.$fDataFixed_$cgmapMp
  = \ (@ a_sgomL)
      _ [Occ=Dead]
      (@ (m_sgomN :: * -> *))
      (w3_sgomO :: GHC.Base.MonadPlus m_sgomN)
      (w4_sgomP :: forall d. Data d => d -> m_sgomN d)
      (w5_sgomQ :: Fixed a_sgomL) ->
      Data.Fixed.$w$cgmapMp
        @ a_sgomL @ m_sgomN w3_sgomO w4_sgomP w5_sgomQ

-- RHS size: {terms: 23, types: 41, coercions: 7, joins: 0/1}
Data.Fixed.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Fixed a -> m (Fixed a)
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [120 60 0] 220 0}]
Data.Fixed.$w$cgmapM
  = \ (@ a_sgomS)
      (@ (m_sgomU :: * -> *))
      (w_sgomV :: Monad m_sgomU)
      (w3_sgomW :: forall d. Data d => d -> m_sgomU d)
      (w4_sgomX :: Fixed a_sgomS) ->
      let {
        lvl17_sgo7E :: m_sgomU Integer
        [LclId]
        lvl17_sgo7E
          = w3_sgomW
              @ Integer
              Data.Data.$fDataInteger
              (w4_sgomX
               `cast` (Data.Fixed.N:Fixed[0] <a_sgomS>_P
                       :: (Fixed a_sgomS :: *) ~R# (Integer :: *))) } in
      >>=
        @ m_sgomU
        w_sgomV
        @ (Integer -> Fixed a_sgomS)
        @ (Fixed a_sgomS)
        (return
           @ m_sgomU
           w_sgomV
           @ (Integer -> Fixed a_sgomS)
           (Data.Fixed.$fDataFixed2
            `cast` (<Integer>_R ->_R Sym (Data.Fixed.N:Fixed[0] <a_sgomS>_P)
                    :: (Integer -> Integer :: *) ~R# (Integer -> Fixed a_sgomS :: *))))
        (\ (c'_ae1To :: Integer -> Fixed a_sgomS) ->
           >>=
             @ m_sgomU
             w_sgomV
             @ Integer
             @ (Fixed a_sgomS)
             lvl17_sgo7E
             (\ (x'_ae1Tp :: Integer) ->
                return @ m_sgomU w_sgomV @ (Fixed a_sgomS) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 10, types: 23, coercions: 0, joins: 0/0}
Data.Fixed.$fDataFixed_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Typeable a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Fixed a -> m (Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sgomS)
                 _ [Occ=Dead]
                 (@ (m_sgomU :: * -> *))
                 (w3_sgomV [Occ=Once] :: Monad m_sgomU)
                 (w4_sgomW [Occ=Once] :: forall d. Data d => d -> m_sgomU d)
                 (w5_sgomX [Occ=Once] :: Fixed a_sgomS) ->
                 Data.Fixed.$w$cgmapM
                   @ a_sgomS @ m_sgomU w3_sgomV w4_sgomW w5_sgomX}]
Data.Fixed.$fDataFixed_$cgmapM
  = \ (@ a_sgomS)
      _ [Occ=Dead]
      (@ (m_sgomU :: * -> *))
      (w3_sgomV :: Monad m_sgomU)
      (w4_sgomW :: forall d. Data d => d -> m_sgomU d)
      (w5_sgomX :: Fixed a_sgomS) ->
      Data.Fixed.$w$cgmapM @ a_sgomS @ m_sgomU w3_sgomV w4_sgomW w5_sgomX

-- RHS size: {terms: 17, types: 22, coercions: 2, joins: 0/0}
Data.Fixed.$fDataFixed_$cgmapQi
  :: forall a.
     Typeable a =>
     forall u. Int -> (forall d. Data d => d -> u) -> Fixed a -> u
[GblId,
 Arity=4,
 Str=<L,A><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgnOb)
                 _ [Occ=Dead]
                 (@ u_agnNh)
                 (ds_dgnWZ [Occ=Once!] :: Int)
                 (ds1_dgnX0 [Occ=Once!] :: forall d. Data d => d -> u_agnNh)
                 (x_ae1T7 [Occ=Once] :: Fixed a_XgnOb) ->
                 case ds_dgnWZ of { GHC.Types.I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_agnNh;
                   0# ->
                     ds1_dgnX0
                       @ Integer
                       Data.Data.$fDataInteger
                       (x_ae1T7
                        `cast` (Data.Fixed.N:Fixed[0] <a_XgnOb>_P
                                :: (Fixed a_XgnOb :: *) ~R# (Integer :: *)))
                 }
                 }}]
Data.Fixed.$fDataFixed_$cgmapQi
  = \ (@ a_XgnOb)
      _ [Occ=Dead]
      (@ u_agnNh)
      (ds_dgnWZ :: Int)
      (ds1_dgnX0 :: forall d. Data d => d -> u_agnNh)
      (x_ae1T7 :: Fixed a_XgnOb) ->
      case ds_dgnWZ of { GHC.Types.I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_agnNh;
        0# ->
          ds1_dgnX0
            @ Integer
            Data.Data.$fDataInteger
            (x_ae1T7
             `cast` (Data.Fixed.N:Fixed[0] <a_XgnOb>_P
                     :: (Fixed a_XgnOb :: *) ~R# (Integer :: *)))
      }
      }

-- RHS size: {terms: 66, types: 119, coercions: 6, joins: 0/3}
Data.Fixed.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data d => d -> m d) -> Fixed a -> m (Fixed a)
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 0] 590 0}]
Data.Fixed.$w$cgmapMo
  = \ (@ a_sgomZ)
      (@ (m_sgon1 :: * -> *))
      (w_sgon2 :: GHC.Base.MonadPlus m_sgon1)
      (w3_sgon3 :: forall d. Data d => d -> m_sgon1 d)
      (w4_sgon4 :: Fixed a_sgomZ) ->
      let {
        lvl17_sgo7J :: m_sgon1 (Fixed a_sgomZ)
        [LclId]
        lvl17_sgo7J
          = GHC.Base.mzero @ m_sgon1 w_sgon2 @ (Fixed a_sgomZ) } in
      let {
        $dMonad_sgo6D [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_sgon1
        [LclId]
        $dMonad_sgo6D = GHC.Base.$p2MonadPlus @ m_sgon1 w_sgon2 } in
      >>=
        @ m_sgon1
        $dMonad_sgo6D
        @ (Fixed a_sgomZ, Bool)
        @ (Fixed a_sgomZ)
        (let {
           lvl18_sgo7I :: m_sgon1 Integer
           [LclId]
           lvl18_sgo7I
             = w3_sgon3
                 @ Integer
                 Data.Data.$fDataInteger
                 (w4_sgon4
                  `cast` (Data.Fixed.N:Fixed[0] <a_sgomZ>_P
                          :: (Fixed a_sgomZ :: *) ~R# (Integer :: *))) } in
         >>=
           @ m_sgon1
           $dMonad_sgo6D
           @ (Integer -> Fixed a_sgomZ, Bool)
           @ (Fixed a_sgomZ, Bool)
           (return
              @ m_sgon1
              $dMonad_sgo6D
              @ (Integer -> Fixed a_sgomZ, Bool)
              (Data.Fixed.$fDataFixed1 @ a_sgomZ))
           (\ (ds1_de7pD :: (Integer -> Fixed a_sgomZ, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b1_ae1TQ) ->
              case b1_ae1TQ of {
                False ->
                  GHC.Base.mplus
                    @ m_sgon1
                    w_sgon2
                    @ (Fixed a_sgomZ, Bool)
                    (>>=
                       @ m_sgon1
                       $dMonad_sgo6D
                       @ Integer
                       @ (Fixed a_sgomZ, Bool)
                       lvl18_sgo7I
                       (\ (y'_ae1TR :: Integer) ->
                          return
                            @ m_sgon1
                            $dMonad_sgo6D
                            @ (Fixed a_sgomZ, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_sgon1
                       $dMonad_sgo6D
                       @ (Fixed a_sgomZ, Bool)
                       (h_ae1TP
                          (w4_sgon4
                           `cast` (Data.Fixed.N:Fixed[0] <a_sgomZ>_P
                                   :: (Fixed a_sgomZ :: *) ~R# (Integer :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_sgon1
                    $dMonad_sgo6D
                    @ (Fixed a_sgomZ, Bool)
                    (h_ae1TP
                       (w4_sgon4
                        `cast` (Data.Fixed.N:Fixed[0] <a_sgomZ>_P
                                :: (Fixed a_sgomZ :: *) ~R# (Integer :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds_de7pa :: (Fixed a_sgomZ, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl17_sgo7J;
             True -> return @ m_sgon1 $dMonad_sgo6D @ (Fixed a_sgomZ) x'_ae1TS
           }
           })

-- RHS size: {terms: 10, types: 23, coercions: 0, joins: 0/0}
Data.Fixed.$fDataFixed_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Typeable a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data d => d -> m d) -> Fixed a -> m (Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sgomZ)
                 _ [Occ=Dead]
                 (@ (m_sgon1 :: * -> *))
                 (w3_sgon2 [Occ=Once] :: GHC.Base.MonadPlus m_sgon1)
                 (w4_sgon3 [Occ=Once] :: forall d. Data d => d -> m_sgon1 d)
                 (w5_sgon4 [Occ=Once] :: Fixed a_sgomZ) ->
                 Data.Fixed.$w$cgmapMo
                   @ a_sgomZ @ m_sgon1 w3_sgon2 w4_sgon3 w5_sgon4}]
Data.Fixed.$fDataFixed_$cgmapMo
  = \ (@ a_sgomZ)
      _ [Occ=Dead]
      (@ (m_sgon1 :: * -> *))
      (w3_sgon2 :: GHC.Base.MonadPlus m_sgon1)
      (w4_sgon3 :: forall d. Data d => d -> m_sgon1 d)
      (w5_sgon4 :: Fixed a_sgomZ) ->
      Data.Fixed.$w$cgmapMo
        @ a_sgomZ @ m_sgon1 w3_sgon2 w4_sgon3 w5_sgon4

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl_rgoyF :: forall a. Fixed a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl_rgoyF = \ (@ a_XgnO4) _ [Occ=Dead] -> conMkFixed

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl1_rgoyG :: forall a. Fixed a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl1_rgoyG = \ (@ a_XgnO4) _ [Occ=Dead] -> tyFixed

-- RHS size: {terms: 6, types: 26, coercions: 0, joins: 0/0}
lvl2_rgoyH
  :: forall a (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Fixed a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl2_rgoyH
  = \ (@ a_XgnO4)
      (@ (t_agnLE :: * -> *))
      (@ (c_agnLF :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_agnLF (Fixed a_XgnO4))

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl3_rgoyI
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Fixed a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl3_rgoyI
  = \ (@ a_XgnO4)
      (@ (t_agnLX :: * -> * -> *))
      (@ (c_agnLY :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_agnLY (Fixed a_XgnO4))

-- RHS size: {terms: 6, types: 11, coercions: 2, joins: 0/0}
lvl4_rgoyJ
  :: forall a. (forall b. Data b => b -> b) -> Fixed a -> Integer
[GblId, Arity=2, Str=<C(C(S)),1*C1(C1(U))><L,U>, Unf=OtherCon []]
lvl4_rgoyJ
  = \ (@ a_XgnO4)
      (ds_dgnWR :: forall b. Data b => b -> b)
      (x0_Xe2jm :: Fixed a_XgnO4) ->
      ds_dgnWR
        @ Integer
        Data.Data.$fDataInteger
        (x0_Xe2jm
         `cast` (Data.Fixed.N:Fixed[0] <a_XgnO4>_P
                 :: (Fixed a_XgnO4 :: *) ~R# (Integer :: *)))

-- RHS size: {terms: 12, types: 19, coercions: 2, joins: 0/0}
lvl5_rgoyK
  :: forall a r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> Fixed a -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []]
lvl5_rgoyK
  = \ (@ a_XgnO4)
      (@ r_agnMv)
      (@ r'_agnMw)
      (ds_dgnWS :: r_agnMv -> r'_agnMw -> r_agnMv)
      (ds1_dgnWT :: r_agnMv)
      (ds2_dgnWU :: forall d. Data d => d -> r'_agnMw)
      (eta_B1 :: Fixed a_XgnO4) ->
      ds_dgnWS
        ds1_dgnWT
        (ds2_dgnWU
           @ Integer
           Data.Data.$fDataInteger
           (eta_B1
            `cast` (Data.Fixed.N:Fixed[0] <a_XgnO4>_P
                    :: (Fixed a_XgnO4 :: *) ~R# (Integer :: *))))

-- RHS size: {terms: 12, types: 19, coercions: 2, joins: 0/0}
lvl6_rgoyL
  :: forall a r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Fixed a -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []]
lvl6_rgoyL
  = \ (@ a_XgnO4)
      (@ r_agnMM)
      (@ r'_agnMN)
      (ds_dgnWV :: r'_agnMN -> r_agnMM -> r_agnMM)
      (ds1_dgnWW :: r_agnMM)
      (ds2_dgnWX :: forall d. Data d => d -> r'_agnMN)
      (x0_ae1SX :: Fixed a_XgnO4) ->
      ds_dgnWV
        (ds2_dgnWX
           @ Integer
           Data.Data.$fDataInteger
           (x0_ae1SX
            `cast` (Data.Fixed.N:Fixed[0] <a_XgnO4>_P
                    :: (Fixed a_XgnO4 :: *) ~R# (Integer :: *))))
        ds1_dgnWW

-- RHS size: {terms: 9, types: 15, coercions: 2, joins: 0/0}
lvl7_rgoyM
  :: forall a u. (forall d. Data d => d -> u) -> Fixed a -> [u]
[GblId, Arity=2, Str=<L,1*C1(C1(U))><L,U>m2, Unf=OtherCon []]
lvl7_rgoyM
  = \ (@ a_XgnO4)
      (@ u_agnN3)
      (ds_dgnWY :: forall d. Data d => d -> u_agnN3)
      (x0_ae1SX :: Fixed a_XgnO4) ->
      GHC.Types.:
        @ u_agnN3
        (ds_dgnWY
           @ Integer
           Data.Data.$fDataInteger
           (x0_ae1SX
            `cast` (Data.Fixed.N:Fixed[0] <a_XgnO4>_P
                    :: (Fixed a_XgnO4 :: *) ~R# (Integer :: *))))
        (GHC.Types.[] @ u_agnN3)

-- RHS size: {terms: 9, types: 29, coercions: 5, joins: 0/0}
lvl8_rgoyN
  :: forall a (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (Fixed a)
[GblId,
 Arity=3,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,A>,
 Unf=OtherCon []]
lvl8_rgoyN
  = \ (@ a_XgnO4)
      (@ (c_agnLl :: * -> *))
      (k_agno1 :: forall b r. Data b => c_agnLl (b -> r) -> c_agnLl r)
      (z_agno2 :: forall r. r -> c_agnLl r)
      _ [Occ=Dead] ->
      k_agno1
        @ Integer
        @ (Fixed a_XgnO4)
        Data.Data.$fDataInteger
        (z_agno2
           @ (Integer -> Fixed a_XgnO4)
           (Data.Fixed.$fDataFixed2
            `cast` (<Integer>_R ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnO4>_P)
                    :: (Integer -> Integer :: *) ~R# (Integer -> Fixed a_XgnO4 :: *))))

-- RHS size: {terms: 21, types: 23, coercions: 19, joins: 0/0}
Data.Fixed.$fDataFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Typeable a => Data (Fixed a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U>,
 Unf=DFun: \ (@ a_agnnX) (v_B1 :: Typeable a_agnnX) ->
       Data.Data.C:Data TYPE: Fixed a_agnnX
                        (Data.Fixed.$fDataFixed7 @ a_agnnX v_B1)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Fixed
                                                                                    a_agnnX>_N
                                :: (Data.Typeable.Internal.TypeRep (Fixed a_agnnX) :: *)
                                   ~R# (Typeable (Fixed a_agnnX) :: Constraint))
                        Data.Fixed.$fDataFixed_$cgfoldl @ a_agnnX v_B1
                        \ (@ (c_agnLl :: * -> *))
                          (k_agno1 [Occ=Once!]
                             :: forall b r. Data b => c_agnLl (b -> r) -> c_agnLl r)
                          (z_agno2 [Occ=Once!] :: forall r. r -> c_agnLl r)
                          _ [Occ=Dead] ->
                          k_agno1
                            @ Integer
                            @ (Fixed a_agnnX)
                            Data.Data.$fDataInteger
                            (z_agno2
                               @ (Integer -> Fixed a_agnnX)
                               (Data.Fixed.$fDataFixed2
                                `cast` (<Integer>_R ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnX>_P)
                                        :: (Integer -> Integer :: *)
                                           ~R# (Integer -> Fixed a_agnnX :: *))))
                        \ _ [Occ=Dead] -> conMkFixed
                        \ _ [Occ=Dead] -> tyFixed
                        \ (@ (t_agnLE :: * -> *))
                          (@ (c_agnLF :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_agnLF (Fixed a_agnnX))
                        \ (@ (t_agnLX :: * -> * -> *))
                          (@ (c_agnLY :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_agnLY (Fixed a_agnnX))
                        (\ (ds_dgnWR [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe2jm [Occ=Once] :: Fixed a_agnnX) ->
                           ds_dgnWR
                             @ Integer
                             Data.Data.$fDataInteger
                             (x0_Xe2jm
                              `cast` (Data.Fixed.N:Fixed[0] <a_agnnX>_P
                                      :: (Fixed a_agnnX :: *) ~R# (Integer :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Fixed a_agnnX>_R
                                ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnX>_P)
                                :: ((forall b. Data b => b -> b) -> Fixed a_agnnX -> Integer :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Fixed a_agnnX -> Fixed a_agnnX :: *))
                        \ (@ r_agnMv)
                          (@ r'_agnMw)
                          (ds_dgnWS [Occ=Once!] :: r_agnMv -> r'_agnMw -> r_agnMv)
                          (ds1_dgnWT [Occ=Once] :: r_agnMv)
                          (ds2_dgnWU [Occ=Once!] :: forall d. Data d => d -> r'_agnMw)
                          (eta_X3j [Occ=Once] :: Fixed a_agnnX) ->
                          ds_dgnWS
                            ds1_dgnWT
                            (ds2_dgnWU
                               @ Integer
                               Data.Data.$fDataInteger
                               (eta_X3j
                                `cast` (Data.Fixed.N:Fixed[0] <a_agnnX>_P
                                        :: (Fixed a_agnnX :: *) ~R# (Integer :: *))))
                        \ (@ r_agnMM)
                          (@ r'_agnMN)
                          (ds_dgnWV [Occ=Once!] :: r'_agnMN -> r_agnMM -> r_agnMM)
                          (ds1_dgnWW [Occ=Once] :: r_agnMM)
                          (ds2_dgnWX [Occ=Once!] :: forall d. Data d => d -> r'_agnMN)
                          (x0_ae1SX [Occ=Once] :: Fixed a_agnnX) ->
                          ds_dgnWV
                            (ds2_dgnWX
                               @ Integer
                               Data.Data.$fDataInteger
                               (x0_ae1SX
                                `cast` (Data.Fixed.N:Fixed[0] <a_agnnX>_P
                                        :: (Fixed a_agnnX :: *) ~R# (Integer :: *))))
                            ds1_dgnWW
                        \ (@ u_agnN3)
                          (ds_dgnWY [Occ=Once!] :: forall d. Data d => d -> u_agnN3)
                          (x0_ae1SX [Occ=Once] :: Fixed a_agnnX) ->
                          GHC.Types.:
                            @ u_agnN3
                            (ds_dgnWY
                               @ Integer
                               Data.Data.$fDataInteger
                               (x0_ae1SX
                                `cast` (Data.Fixed.N:Fixed[0] <a_agnnX>_P
                                        :: (Fixed a_agnnX :: *) ~R# (Integer :: *))))
                            (GHC.Types.[] @ u_agnN3)
                        Data.Fixed.$fDataFixed_$cgmapQi @ a_agnnX v_B1
                        Data.Fixed.$fDataFixed_$cgmapM @ a_agnnX v_B1
                        Data.Fixed.$fDataFixed_$cgmapMp @ a_agnnX v_B1
                        Data.Fixed.$fDataFixed_$cgmapMo @ a_agnnX v_B1]
Data.Fixed.$fDataFixed
  = \ (@ a_XgnO4) ($dTypeable_XgnO6 :: Typeable a_XgnO4) ->
      Data.Data.C:Data
        @ (Fixed a_XgnO4)
        ((Data.Fixed.$fDataFixed7 @ a_XgnO4 $dTypeable_XgnO6)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Fixed
                                                                     a_XgnO4>_N
                 :: (Data.Typeable.Internal.TypeRep (Fixed a_XgnO4) :: *)
                    ~R# (Typeable (Fixed a_XgnO4) :: Constraint)))
        (Data.Fixed.$fDataFixed_$cgfoldl @ a_XgnO4 $dTypeable_XgnO6)
        (lvl8_rgoyN @ a_XgnO4)
        (lvl_rgoyF @ a_XgnO4)
        (lvl1_rgoyG @ a_XgnO4)
        (lvl2_rgoyH @ a_XgnO4)
        (lvl3_rgoyI @ a_XgnO4)
        ((lvl4_rgoyJ @ a_XgnO4)
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Fixed a_XgnO4>_R
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnO4>_P)
                 :: ((forall b. Data b => b -> b) -> Fixed a_XgnO4 -> Integer :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Fixed a_XgnO4 -> Fixed a_XgnO4 :: *)))
        (lvl5_rgoyK @ a_XgnO4)
        (lvl6_rgoyL @ a_XgnO4)
        (lvl7_rgoyM @ a_XgnO4)
        (Data.Fixed.$fDataFixed_$cgmapQi @ a_XgnO4 $dTypeable_XgnO6)
        (Data.Fixed.$w$cgmapM @ a_XgnO4)
        (Data.Fixed.$w$cgmapMp @ a_XgnO4)
        (Data.Fixed.$w$cgmapMo @ a_XgnO4)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcHasResolution3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Fixed.$tcHasResolution3 = "HasResolution"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcHasResolution2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Fixed.$tcHasResolution2
  = GHC.Types.TrNameS Data.Fixed.$tcHasResolution3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcHasResolution :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Fixed.$tcHasResolution
  = GHC.Types.TyCon
      7410670074803796200##
      11622449620609036983##
      Data.Fixed.$trModule
      Data.Fixed.$tcHasResolution2
      0#
      Data.Fixed.$tcHasResolution1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE5 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Fixed.$tcE5 = "E0"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE4 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Fixed.$tcE4 = GHC.Types.TrNameS Data.Fixed.$tcE5

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE0 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Fixed.$tcE0
  = GHC.Types.TyCon
      1111589946053822622##
      14645449775626969178##
      Data.Fixed.$trModule
      Data.Fixed.$tcE4
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE8 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Fixed.$tcE8 = "E1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE7 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Fixed.$tcE7 = GHC.Types.TrNameS Data.Fixed.$tcE8

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE1 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Fixed.$tcE1
  = GHC.Types.TyCon
      17242267792727872229##
      10571291330004494282##
      Data.Fixed.$trModule
      Data.Fixed.$tcE7
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE14 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Fixed.$tcE14 = "E2"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE13 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Fixed.$tcE13 = GHC.Types.TrNameS Data.Fixed.$tcE14

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE2 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Fixed.$tcE2
  = GHC.Types.TyCon
      18184774527647329547##
      15895109557895358229##
      Data.Fixed.$trModule
      Data.Fixed.$tcE13
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE16 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Fixed.$tcE16 = "E3"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE15 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Fixed.$tcE15 = GHC.Types.TrNameS Data.Fixed.$tcE16

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE3 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Fixed.$tcE3
  = GHC.Types.TyCon
      2281297682271263739##
      13982938170987291273##
      Data.Fixed.$trModule
      Data.Fixed.$tcE15
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE18 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Fixed.$tcE18 = "E6"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE17 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Fixed.$tcE17 = GHC.Types.TrNameS Data.Fixed.$tcE18

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE6 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Fixed.$tcE6
  = GHC.Types.TyCon
      6430880657524859014##
      16351944333195325805##
      Data.Fixed.$trModule
      Data.Fixed.$tcE17
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE20 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Fixed.$tcE20 = "E9"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE19 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Fixed.$tcE19 = GHC.Types.TrNameS Data.Fixed.$tcE20

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE9 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Fixed.$tcE9
  = GHC.Types.TyCon
      8202840314884717291##
      5390706447224283764##
      Data.Fixed.$trModule
      Data.Fixed.$tcE19
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE11 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Fixed.$tcE11 = "E12"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE10 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Fixed.$tcE10 = GHC.Types.TrNameS Data.Fixed.$tcE11

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Fixed.$tcE12 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Fixed.$tcE12
  = GHC.Types.TyCon
      11177455628646877585##
      1804744900678580889##
      Data.Fixed.$trModule
      Data.Fixed.$tcE10
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 27, types: 28, coercions: 0, joins: 0/0}
div' :: forall a b. (Real a, Integral b) => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(LLC(S(SS))),U(A,A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0 0] 180 0}]
div'
  = \ (@ a_agnAY)
      (@ b_agnAZ)
      ($dReal_agnB1 :: Real a_agnAY)
      ($dIntegral_agnB2 :: Integral b_agnAZ)
      (n_agnof :: a_agnAY)
      (d_agnog :: a_agnAY) ->
      case toRational @ a_agnAY $dReal_agnB1 n_agnof of
      { GHC.Real.:% ww1_ignZJ ww2_ignZK ->
      case toRational @ a_agnAY $dReal_agnB1 d_agnog of
      { GHC.Real.:% ww4_ignZP ww5_ignZQ ->
      case GHC.Real.$w$s$c/ ww1_ignZJ ww2_ignZK ww4_ignZP ww5_ignZQ of
      { (# ww7_ignZU, ww8_ignZV #) ->
      GHC.Real.$w$s$cfloor @ b_agnAZ $dIntegral_agnB2 ww7_ignZU ww8_ignZV
      }
      }
      }

-- RHS size: {terms: 28, types: 24, coercions: 0, joins: 0/2}
Data.Fixed.$wdivMod' [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (Real a, Integral b) => a -> a -> (# b, a #)
[GblId,
 Arity=4,
 Str=<L,U(1*U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U)),A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 0] 230 30}]
Data.Fixed.$wdivMod'
  = \ (@ a_sgonc)
      (@ b_sgond)
      (w_sgone :: Real a_sgonc)
      (w3_sgonf :: Integral b_sgond)
      (w4_sgong :: a_sgonc)
      (w5_sgonh :: a_sgonc) ->
      let {
        f_sgo6B :: b_sgond
        [LclId]
        f_sgo6B
          = div' @ a_sgonc @ b_sgond w_sgone w3_sgonf w4_sgong w5_sgonh } in
      (# f_sgo6B,
         let {
           $dNum_sgo6z [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U))>]
             :: Num a_sgonc
           [LclId]
           $dNum_sgo6z = GHC.Real.$p1Real @ a_sgonc w_sgone } in
         - @ a_sgonc
           $dNum_sgo6z
           w4_sgong
           (* @ a_sgonc
              $dNum_sgo6z
              (fromInteger
                 @ a_sgonc $dNum_sgo6z (toInteger @ b_sgond w3_sgonf f_sgo6B))
              w5_sgonh) #)

-- RHS size: {terms: 16, types: 21, coercions: 0, joins: 0/0}
divMod' [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (Real a, Integral b) => a -> a -> (b, a)
[GblId,
 Arity=4,
 Str=<L,U(U(A,C(C1(U)),C(C1(U)),A,A,A,C(U)),A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgonc)
                 (@ b_sgond)
                 (w_sgone [Occ=Once] :: Real a_sgonc)
                 (w3_sgonf [Occ=Once] :: Integral b_sgond)
                 (w4_sgong [Occ=Once] :: a_sgonc)
                 (w5_sgonh [Occ=Once] :: a_sgonc) ->
                 case Data.Fixed.$wdivMod'
                        @ a_sgonc @ b_sgond w_sgone w3_sgonf w4_sgong w5_sgonh
                 of
                 { (# ww1_sgooI [Occ=Once], ww2_sgooJ [Occ=Once] #) ->
                 (ww1_sgooI, ww2_sgooJ)
                 }}]
divMod'
  = \ (@ a_sgonc)
      (@ b_sgond)
      (w_sgone :: Real a_sgonc)
      (w3_sgonf :: Integral b_sgond)
      (w4_sgong :: a_sgonc)
      (w5_sgonh :: a_sgonc) ->
      case Data.Fixed.$wdivMod'
             @ a_sgonc @ b_sgond w_sgone w3_sgonf w4_sgong w5_sgonh
      of
      { (# ww1_sgooI, ww2_sgooJ #) ->
      (ww1_sgooI, ww2_sgooJ)
      }

-- RHS size: {terms: 20, types: 14, coercions: 0, joins: 0/1}
mod' :: forall a. Real a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LC(C(S))LLLLL)LL),U(1*U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U)),A,C(U(U,U)))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 190 0}]
mod'
  = \ (@ a_agnBF)
      ($dReal_agnBH :: Real a_agnBF)
      (eta_B2 :: a_agnBF)
      (eta1_B1 :: a_agnBF) ->
      let {
        $dNum_sgo6x [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U))>]
          :: Num a_agnBF
        [LclId]
        $dNum_sgo6x = GHC.Real.$p1Real @ a_agnBF $dReal_agnBH } in
      - @ a_agnBF
        $dNum_sgo6x
        eta_B2
        (* @ a_agnBF
           $dNum_sgo6x
           (fromInteger
              @ a_agnBF
              $dNum_sgo6x
              (div'
                 @ a_agnBF
                 @ Integer
                 $dReal_agnBH
                 GHC.Real.$fIntegralInteger
                 eta_B2
                 eta1_B1))
           eta1_B1)

-- RHS size: {terms: 3, types: 9, coercions: 4, joins: 0/0}
Data.Fixed.$fFractionalFixed2 :: forall a. GHC.Types.Any a
[GblId, Str=x]
Data.Fixed.$fFractionalFixed2
  = \ (@ a_agnHt) ->
      undefined
        @ 'GHC.Types.LiftedRep
        @ (GHC.Types.Any a_agnHt)
        ($dIP3_rgoyz
         `cast` (Sym (GHC.Classes.N:IP[0]
                          <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                 :: (GHC.Stack.Types.CallStack :: *)
                    ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))

-- RHS size: {terms: 21, types: 21, coercions: 2, joins: 0/0}
Data.Fixed.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a. HasResolution a => Integer -> Integer -> Integer
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 170 0}]
Data.Fixed.$w$cfromRational
  = \ (@ a_sgonq)
      (w_sgonr :: HasResolution a_sgonq)
      (ww_sgonv
         :: Integer
         Unf=OtherCon [])
      (ww1_sgonw
         :: Integer
         Unf=OtherCon []) ->
      case (w_sgonr
            `cast` (Data.Fixed.N:HasResolution[0] <a_sgonq>_N
                    :: (HasResolution a_sgonq :: Constraint)
                       ~R# (forall (p :: * -> *). p a_sgonq -> Integer :: *)))
             @ GHC.Types.Any (Data.Fixed.$fFractionalFixed2 @ a_sgonq)
      of dt_icBOu
      { __DEFAULT ->
      case GHC.Real.$w$sreduce
             (integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
                ww_sgonv dt_icBOu)
             (integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
                ww1_sgonw GHC.Real.$fEnumRatio1)
      of
      { (# ww7_igo0b, ww8_igo0c #) ->
      GHC.Real.$w$s$cfloor
        @ Integer GHC.Real.$fIntegralInteger ww7_igo0b ww8_igo0c
      }
      }

-- RHS size: {terms: 10, types: 9, coercions: 0, joins: 0/0}
Data.Fixed.$fFractionalFixed1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. HasResolution a => Rational -> Integer
[GblId,
 Arity=2,
 Str=<C(S),1*C1(U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgonq)
                 (w_sgonr [Occ=Once] :: HasResolution a_sgonq)
                 (w3_sgons [Occ=Once!] :: Rational) ->
                 case w3_sgons of
                 { GHC.Real.:% ww1_sgonv [Occ=Once] ww2_sgonw [Occ=Once] ->
                 Data.Fixed.$w$cfromRational @ a_sgonq w_sgonr ww1_sgonv ww2_sgonw
                 }}]
Data.Fixed.$fFractionalFixed1
  = \ (@ a_sgonq)
      (w_sgonr :: HasResolution a_sgonq)
      (w3_sgons :: Rational) ->
      case w3_sgons of { GHC.Real.:% ww1_sgonv ww2_sgonw ->
      Data.Fixed.$w$cfromRational @ a_sgonq w_sgonr ww1_sgonv ww2_sgonw
      }

-- RHS size: {terms: 17, types: 16, coercions: 4, joins: 0/0}
Data.Fixed.$fRealFixed_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: forall a. HasResolution a => Fixed a -> Rational
[GblId,
 Arity=2,
 Str=<C(S),1*C1(U)><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgonz)
                 (w_sgonA [Occ=Once] :: HasResolution a_sgonz)
                 (w3_sgonB :: Fixed a_sgonz) ->
                 case (w_sgonA
                       `cast` (Data.Fixed.N:HasResolution[0] <a_sgonz>_N
                               :: (HasResolution a_sgonz :: Constraint)
                                  ~R# (forall (p :: * -> *). p a_sgonz -> Integer :: *)))
                        @ Fixed w3_sgonB
                 of dt_XcBU3
                 { __DEFAULT ->
                 case GHC.Real.$w$s$c/
                        (w3_sgonB
                         `cast` (Data.Fixed.N:Fixed[0] <a_sgonz>_P
                                 :: (Fixed a_sgonz :: *) ~R# (Integer :: *)))
                        GHC.Real.$fEnumRatio1
                        dt_XcBU3
                        GHC.Real.$fEnumRatio1
                 of
                 { (# ww1_sgooL [Occ=Once], ww2_sgooM [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww1_sgooL ww2_sgooM
                 }
                 }}]
Data.Fixed.$fRealFixed_$ctoRational
  = \ (@ a_sgonz)
      (w_sgonA :: HasResolution a_sgonz)
      (w3_sgonB :: Fixed a_sgonz) ->
      case (w_sgonA
            `cast` (Data.Fixed.N:HasResolution[0] <a_sgonz>_N
                    :: (HasResolution a_sgonz :: Constraint)
                       ~R# (forall (p :: * -> *). p a_sgonz -> Integer :: *)))
             @ Fixed w3_sgonB
      of dt_XcBU3
      { __DEFAULT ->
      case GHC.Real.$w$s$c/
             (w3_sgonB
              `cast` (Data.Fixed.N:Fixed[0] <a_sgonz>_P
                      :: (Fixed a_sgonz :: *) ~R# (Integer :: *)))
             GHC.Real.$fEnumRatio1
             dt_XcBU3
             GHC.Real.$fEnumRatio1
      of
      { (# ww1_sgooL, ww2_sgooM #) ->
      GHC.Real.:% @ Integer ww1_sgooL ww2_sgooM
      }
      }

-- RHS size: {terms: 17, types: 11, coercions: 8, joins: 0/0}
Data.Fixed.$fFractionalFixed3
  :: forall a. HasResolution a => Fixed a -> Fixed a -> Integer
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 130 0}]
Data.Fixed.$fFractionalFixed3
  = \ (@ a_XgnLd)
      ($dHasResolution_XgnLf :: HasResolution a_XgnLd)
      (fa_agnnn :: Fixed a_XgnLd)
      (ds_dgnV6 :: Fixed a_XgnLd) ->
      case integer-simple-0.1.1.1:GHC.Integer.Type.eqInteger#
             (ds_dgnV6
              `cast` (Data.Fixed.N:Fixed[0] <a_XgnLd>_P
                      :: (Fixed a_XgnLd :: *) ~R# (Integer :: *)))
             Data.Fixed.$fEnumFixed1
      of {
        __DEFAULT ->
          integer-simple-0.1.1.1:GHC.Integer.Type.divInteger
            (integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
               (fa_agnnn
                `cast` (Data.Fixed.N:Fixed[0] <a_XgnLd>_P
                        :: (Fixed a_XgnLd :: *) ~R# (Integer :: *)))
               (($dHasResolution_XgnLf
                 `cast` (Data.Fixed.N:HasResolution[0] <a_XgnLd>_N
                         :: (HasResolution a_XgnLd :: Constraint)
                            ~R# (forall (p :: * -> *). p a_XgnLd -> Integer :: *)))
                  @ Fixed fa_agnnn))
            (ds_dgnV6
             `cast` (Data.Fixed.N:Fixed[0] <a_XgnLd>_P
                     :: (Fixed a_XgnLd :: *) ~R# (Integer :: *)));
        1# -> GHC.Real.divZeroError @ Integer
      }

-- RHS size: {terms: 18, types: 10, coercions: 12, joins: 0/1}
Data.Fixed.$fFractionalFixed_$crecip
  :: forall a. HasResolution a => Fixed a -> Fixed a
[GblId,
 Arity=2,
 Str=<C(S),1*C1(U)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 140 0}]
Data.Fixed.$fFractionalFixed_$crecip
  = \ (@ a_XgnLj)
      ($dHasResolution_XgnLl :: HasResolution a_XgnLj)
      (fa_agnnq :: Fixed a_XgnLj) ->
      case integer-simple-0.1.1.1:GHC.Integer.Type.eqInteger#
             (fa_agnnq
              `cast` (Data.Fixed.N:Fixed[0] <a_XgnLj>_P
                      :: (Fixed a_XgnLj :: *) ~R# (Integer :: *)))
             Data.Fixed.$fEnumFixed1
      of {
        __DEFAULT ->
          let {
            res_sgo6v [Dmd=<S,U>] :: Integer
            [LclId]
            res_sgo6v
              = ($dHasResolution_XgnLl
                 `cast` (Data.Fixed.N:HasResolution[0] <a_XgnLj>_N
                         :: (HasResolution a_XgnLj :: Constraint)
                            ~R# (forall (p :: * -> *). p a_XgnLj -> Integer :: *)))
                  @ Fixed fa_agnnq } in
          (integer-simple-0.1.1.1:GHC.Integer.Type.divInteger
             (integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
                res_sgo6v res_sgo6v)
             (fa_agnnq
              `cast` (Data.Fixed.N:Fixed[0] <a_XgnLj>_P
                      :: (Fixed a_XgnLj :: *) ~R# (Integer :: *))))
          `cast` (Sym (Data.Fixed.N:Fixed[0] <a_XgnLj>_P)
                  :: (Integer :: *) ~R# (Fixed a_XgnLj :: *));
        1# ->
          (GHC.Real.divZeroError @ Integer)
          `cast` (Sym (Data.Fixed.N:Fixed[0] <a_XgnLj>_P)
                  :: (Integer :: *) ~R# (Fixed a_XgnLj :: *))
      }

-- RHS size: {terms: 19, types: 12, coercions: 12, joins: 0/1}
Data.Fixed.$fNumFixed_$c*
  :: forall a. HasResolution a => Fixed a -> Fixed a -> Fixed a
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 140 0}]
Data.Fixed.$fNumFixed_$c*
  = \ (@ a_XgnMP)
      ($dHasResolution_XgnMR :: HasResolution a_XgnMP)
      (fa_agnnD :: Fixed a_XgnMP)
      (ds_dgnVC :: Fixed a_XgnMP) ->
      let {
        ds1_sgo6t [Dmd=<S,U>] :: Integer
        [LclId]
        ds1_sgo6t
          = ($dHasResolution_XgnMR
             `cast` (Data.Fixed.N:HasResolution[0] <a_XgnMP>_N
                     :: (HasResolution a_XgnMP :: Constraint)
                        ~R# (forall (p :: * -> *). p a_XgnMP -> Integer :: *)))
              @ Fixed fa_agnnD } in
      case integer-simple-0.1.1.1:GHC.Integer.Type.eqInteger#
             ds1_sgo6t Data.Fixed.$fEnumFixed1
      of {
        __DEFAULT ->
          (integer-simple-0.1.1.1:GHC.Integer.Type.divInteger
             (integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
                (fa_agnnD
                 `cast` (Data.Fixed.N:Fixed[0] <a_XgnMP>_P
                         :: (Fixed a_XgnMP :: *) ~R# (Integer :: *)))
                (ds_dgnVC
                 `cast` (Data.Fixed.N:Fixed[0] <a_XgnMP>_P
                         :: (Fixed a_XgnMP :: *) ~R# (Integer :: *))))
             ds1_sgo6t)
          `cast` (Sym (Data.Fixed.N:Fixed[0] <a_XgnMP>_P)
                  :: (Integer :: *) ~R# (Fixed a_XgnMP :: *));
        1# ->
          (GHC.Real.divZeroError @ Integer)
          `cast` (Sym (Data.Fixed.N:Fixed[0] <a_XgnMP>_P)
                  :: (Integer :: *) ~R# (Fixed a_XgnMP :: *))
      }

-- RHS size: {terms: 7, types: 11, coercions: 2, joins: 0/0}
Data.Fixed.$fNumFixed1
  :: forall a. HasResolution a => Integer -> Integer
[GblId,
 Arity=2,
 Str=<C(S),1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgnN0)
                 ($dHasResolution_XgnN2 [Occ=Once] :: HasResolution a_XgnN0)
                 (i_agnnJ [Occ=Once] :: Integer) ->
                 integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
                   i_agnnJ
                   (($dHasResolution_XgnN2
                     `cast` (Data.Fixed.N:HasResolution[0] <a_XgnN0>_N
                             :: (HasResolution a_XgnN0 :: Constraint)
                                ~R# (forall (p :: * -> *). p a_XgnN0 -> Integer :: *)))
                      @ GHC.Types.Any (Data.Fixed.$fFractionalFixed2 @ a_XgnN0))}]
Data.Fixed.$fNumFixed1
  = \ (@ a_XgnN0)
      ($dHasResolution_XgnN2 :: HasResolution a_XgnN0)
      (i_agnnJ :: Integer) ->
      integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
        i_agnnJ
        (($dHasResolution_XgnN2
          `cast` (Data.Fixed.N:HasResolution[0] <a_XgnN0>_N
                  :: (HasResolution a_XgnN0 :: Constraint)
                     ~R# (forall (p :: * -> *). p a_XgnN0 -> Integer :: *)))
           @ GHC.Types.Any (Data.Fixed.$fFractionalFixed2 @ a_XgnN0))

-- RHS size: {terms: 8, types: 12, coercions: 4, joins: 0/0}
Data.Fixed.$fNumFixed2
  :: forall a. HasResolution a => Fixed a -> Integer
[GblId,
 Arity=2,
 Str=<C(S),1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgnN6)
                 ($dHasResolution_XgnN8 [Occ=Once] :: HasResolution a_XgnN6)
                 (ds_dgnVR [Occ=Once] :: Fixed a_XgnN6) ->
                 integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
                   (integer-simple-0.1.1.1:GHC.Integer.Type.signumInteger
                      (ds_dgnVR
                       `cast` (Data.Fixed.N:Fixed[0] <a_XgnN6>_P
                               :: (Fixed a_XgnN6 :: *) ~R# (Integer :: *))))
                   (($dHasResolution_XgnN8
                     `cast` (Data.Fixed.N:HasResolution[0] <a_XgnN6>_N
                             :: (HasResolution a_XgnN6 :: Constraint)
                                ~R# (forall (p :: * -> *). p a_XgnN6 -> Integer :: *)))
                      @ GHC.Types.Any (Data.Fixed.$fFractionalFixed2 @ a_XgnN6))}]
Data.Fixed.$fNumFixed2
  = \ (@ a_XgnN6)
      ($dHasResolution_XgnN8 :: HasResolution a_XgnN6)
      (ds_dgnVR :: Fixed a_XgnN6) ->
      integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
        (integer-simple-0.1.1.1:GHC.Integer.Type.signumInteger
           (ds_dgnVR
            `cast` (Data.Fixed.N:Fixed[0] <a_XgnN6>_P
                    :: (Fixed a_XgnN6 :: *) ~R# (Integer :: *))))
        (($dHasResolution_XgnN8
          `cast` (Data.Fixed.N:HasResolution[0] <a_XgnN6>_N
                  :: (HasResolution a_XgnN6 :: Constraint)
                     ~R# (forall (p :: * -> *). p a_XgnN6 -> Integer :: *)))
           @ GHC.Types.Any (Data.Fixed.$fFractionalFixed2 @ a_XgnN6))

-- RHS size: {terms: 13, types: 9, coercions: 47, joins: 0/0}
Data.Fixed.$fNumFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. HasResolution a => Num (Fixed a)
[GblId[DFunId],
 Arity=1,
 Str=<L,C(U)>m,
 Unf=DFun: \ (@ a_agnny) (v_B1 :: HasResolution a_agnny) ->
       GHC.Num.C:Num TYPE: Fixed a_agnny
                     integer-simple-0.1.1.1:GHC.Integer.Type.plusInteger
                     `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnny>_P)
                             ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnny>_P)
                             ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnny>_P)
                             :: (Integer -> Integer -> Integer :: *)
                                ~R# (Fixed a_agnny -> Fixed a_agnny -> Fixed a_agnny :: *))
                     integer-simple-0.1.1.1:GHC.Integer.Type.minusInteger
                     `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnny>_P)
                             ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnny>_P)
                             ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnny>_P)
                             :: (Integer -> Integer -> Integer :: *)
                                ~R# (Fixed a_agnny -> Fixed a_agnny -> Fixed a_agnny :: *))
                     Data.Fixed.$fNumFixed_$c* @ a_agnny v_B1
                     integer-simple-0.1.1.1:GHC.Integer.Type.negateInteger
                     `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnny>_P)
                             ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnny>_P)
                             :: (Integer -> Integer :: *)
                                ~R# (Fixed a_agnny -> Fixed a_agnny :: *))
                     integer-simple-0.1.1.1:GHC.Integer.Type.absInteger
                     `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnny>_P)
                             ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnny>_P)
                             :: (Integer -> Integer :: *)
                                ~R# (Fixed a_agnny -> Fixed a_agnny :: *))
                     (Data.Fixed.$fNumFixed2 @ a_agnny v_B1)
                     `cast` (<Fixed a_agnny>_R
                             ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnny>_P)
                             :: (Fixed a_agnny -> Integer :: *)
                                ~R# (Fixed a_agnny -> Fixed a_agnny :: *))
                     (Data.Fixed.$fNumFixed1 @ a_agnny v_B1)
                     `cast` (<Integer>_R ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnny>_P)
                             :: (Integer -> Integer :: *) ~R# (Integer -> Fixed a_agnny :: *))]
Data.Fixed.$fNumFixed
  = \ (@ a_XgnN5) ($dHasResolution_XgnN7 :: HasResolution a_XgnN5) ->
      GHC.Num.C:Num
        @ (Fixed a_XgnN5)
        (integer-simple-0.1.1.1:GHC.Integer.Type.plusInteger
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_XgnN5>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnN5>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnN5>_P)
                 :: (Integer -> Integer -> Integer :: *)
                    ~R# (Fixed a_XgnN5 -> Fixed a_XgnN5 -> Fixed a_XgnN5 :: *)))
        (integer-simple-0.1.1.1:GHC.Integer.Type.minusInteger
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_XgnN5>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnN5>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnN5>_P)
                 :: (Integer -> Integer -> Integer :: *)
                    ~R# (Fixed a_XgnN5 -> Fixed a_XgnN5 -> Fixed a_XgnN5 :: *)))
        (Data.Fixed.$fNumFixed_$c* @ a_XgnN5 $dHasResolution_XgnN7)
        (integer-simple-0.1.1.1:GHC.Integer.Type.negateInteger
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_XgnN5>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnN5>_P)
                 :: (Integer -> Integer :: *)
                    ~R# (Fixed a_XgnN5 -> Fixed a_XgnN5 :: *)))
        (integer-simple-0.1.1.1:GHC.Integer.Type.absInteger
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_XgnN5>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnN5>_P)
                 :: (Integer -> Integer :: *)
                    ~R# (Fixed a_XgnN5 -> Fixed a_XgnN5 :: *)))
        ((Data.Fixed.$fNumFixed2 @ a_XgnN5 $dHasResolution_XgnN7)
         `cast` (<Fixed a_XgnN5>_R
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnN5>_P)
                 :: (Fixed a_XgnN5 -> Integer :: *)
                    ~R# (Fixed a_XgnN5 -> Fixed a_XgnN5 :: *)))
        ((Data.Fixed.$fNumFixed1 @ a_XgnN5 $dHasResolution_XgnN7)
         `cast` (<Integer>_R ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnN5>_P)
                 :: (Integer -> Integer :: *) ~R# (Integer -> Fixed a_XgnN5 :: *)))

-- RHS size: {terms: 11, types: 10, coercions: 14, joins: 0/0}
Data.Fixed.$fFractionalFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. HasResolution a => Fractional (Fixed a)
[GblId[DFunId],
 Arity=1,
 Str=<L,C(U)>m,
 Unf=DFun: \ (@ a_agnnm) (v_B1 :: HasResolution a_agnnm) ->
       GHC.Real.C:Fractional TYPE: Fixed a_agnnm
                             Data.Fixed.$fNumFixed @ a_agnnm v_B1
                             (Data.Fixed.$fFractionalFixed3 @ a_agnnm v_B1)
                             `cast` (<Fixed a_agnnm>_R
                                     ->_R <Fixed a_agnnm>_R
                                     ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnm>_P)
                                     :: (Fixed a_agnnm -> Fixed a_agnnm -> Integer :: *)
                                        ~R# (Fixed a_agnnm -> Fixed a_agnnm -> Fixed a_agnnm :: *))
                             Data.Fixed.$fFractionalFixed_$crecip @ a_agnnm v_B1
                             (Data.Fixed.$fFractionalFixed1 @ a_agnnm v_B1)
                             `cast` (<Rational>_R ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnm>_P)
                                     :: (Rational -> Integer :: *)
                                        ~R# (Rational -> Fixed a_agnnm :: *))]
Data.Fixed.$fFractionalFixed
  = \ (@ a_XgnLO) ($dHasResolution_XgnLQ :: HasResolution a_XgnLO) ->
      GHC.Real.C:Fractional
        @ (Fixed a_XgnLO)
        (Data.Fixed.$fNumFixed @ a_XgnLO $dHasResolution_XgnLQ)
        ((Data.Fixed.$fFractionalFixed3 @ a_XgnLO $dHasResolution_XgnLQ)
         `cast` (<Fixed a_XgnLO>_R
                 ->_R <Fixed a_XgnLO>_R
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnLO>_P)
                 :: (Fixed a_XgnLO -> Fixed a_XgnLO -> Integer :: *)
                    ~R# (Fixed a_XgnLO -> Fixed a_XgnLO -> Fixed a_XgnLO :: *)))
        (Data.Fixed.$fFractionalFixed_$crecip
           @ a_XgnLO $dHasResolution_XgnLQ)
        ((Data.Fixed.$fFractionalFixed1 @ a_XgnLO $dHasResolution_XgnLQ)
         `cast` (<Rational>_R ->_R Sym (Data.Fixed.N:Fixed[0] <a_XgnLO>_P)
                 :: (Rational -> Integer :: *)
                    ~R# (Rational -> Fixed a_XgnLO :: *)))

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Fixed.$fReadFixed2 :: Double
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 14 20}]
Data.Fixed.$fReadFixed2
  = case GHC.Prim.logDouble# 10.0## of v_B2 { __DEFAULT ->
    GHC.Types.D# v_B2
    }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl9_rgoyO :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl9_rgoyO = GHC.Types.I# 172#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl10_rgoyP :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl10_rgoyP = GHC.Types.I# 27#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl11_rgoyQ :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl11_rgoyQ = GHC.Types.I# 36#

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
lvl12_rgoyR :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []]
lvl12_rgoyR
  = GHC.Stack.Types.SrcLoc
      loc_rgoyp
      loc1_rgoyq
      loc3_rgoys
      lvl9_rgoyO
      lvl10_rgoyP
      lvl9_rgoyO
      lvl11_rgoyQ

-- RHS size: {terms: 4, types: 0, coercions: 0, joins: 0/0}
lvl13_rgoyS :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []]
lvl13_rgoyS
  = GHC.Stack.Types.PushCallStack
      $dIP1_rgoyx lvl12_rgoyR GHC.Stack.Types.EmptyCallStack

-- RHS size: {terms: 3, types: 5, coercions: 4, joins: 0/0}
Data.Fixed.$fReadFixed3 :: forall a. Fixed a
[GblId, Str=x]
Data.Fixed.$fReadFixed3
  = \ (@ a_agnFb) ->
      undefined
        @ 'GHC.Types.LiftedRep
        @ (Fixed a_agnFb)
        (lvl13_rgoyS
         `cast` (Sym (GHC.Classes.N:IP[0]
                          <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                 :: (GHC.Stack.Types.CallStack :: *)
                    ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))

-- RHS size: {terms: 109, types: 74, coercions: 48, joins: 0/5}
Data.Fixed.$fReadFixed1
  :: forall a.
     HasResolution a =>
     Prec
     -> forall b.
        (Fixed a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=1,
 Str=<L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [180] 800 60}]
Data.Fixed.$fReadFixed1
  = \ (@ a_agnFb) ($dHasResolution_agnFc :: HasResolution a_agnFb) ->
      let {
        lvl17_sgo8q :: Integer
        [LclId]
        lvl17_sgo8q
          = ($dHasResolution_agnFc
             `cast` (Data.Fixed.N:HasResolution[0] <a_agnFb>_N
                     :: (HasResolution a_agnFb :: Constraint)
                        ~R# (forall (p :: * -> *). p a_agnFb -> Integer :: *)))
              @ GHC.Types.Any (Data.Fixed.$fFractionalFixed2 @ a_agnFb) } in
      let {
        e_sgo8m :: Integer
        [LclId]
        e_sgo8m
          = case integer-simple-0.1.1.1:GHC.Integer.Type.doubleFromInteger
                   (($dHasResolution_agnFc
                     `cast` (Data.Fixed.N:HasResolution[0] <a_agnFb>_N
                             :: (HasResolution a_agnFb :: Constraint)
                                ~R# (forall (p :: * -> *). p a_agnFb -> Integer :: *)))
                      @ Fixed (Data.Fixed.$fReadFixed3 @ a_agnFb))
            of wild_igo1s
            { __DEFAULT ->
            case GHC.Prim.logDouble# wild_igo1s of wild1_igo1d { __DEFAULT ->
            case Data.Fixed.$fReadFixed2 of { GHC.Types.D# v1_B2 ->
            case GHC.Prim./## wild1_igo1d v1_B2 of wild4_igo1j { __DEFAULT ->
            case integer-simple-0.1.1.1:GHC.Integer.Type.decodeDoubleInteger
                   (GHC.Prim.negateDouble# wild4_igo1j)
            of
            { (# ipv_igo0D, ipv1_igo0E #) ->
            case GHC.Prim.<# ipv1_igo0E 0# of {
              __DEFAULT ->
                integer-simple-0.1.1.1:GHC.Integer.Type.negateInteger
                  (integer-simple-0.1.1.1:GHC.Integer.Type.shiftLInteger
                     ipv_igo0D ipv1_igo0E);
              1# ->
                let {
                  s_sgo6r [Dmd=<S,U>] :: GHC.Prim.Int#
                  [LclId]
                  s_sgo6r = GHC.Prim.negateInt# ipv1_igo0E } in
                case GHC.Prim.># s_sgo6r 52# of {
                  __DEFAULT ->
                    case integer-simple-0.1.1.1:GHC.Integer.Type.integerToInt ipv_igo0D
                    of n_igo0J
                    { __DEFAULT ->
                    integer-simple-0.1.1.1:GHC.Integer.Type.negateInteger
                      (integer-simple-0.1.1.1:GHC.Integer.Type.smallInteger
                         (GHC.Prim.uncheckedIShiftRA# n_igo0J s_sgo6r))
                    };
                  1# ->
                    case integer-simple-0.1.1.1:GHC.Integer.Type.ltInteger#
                           ipv_igo0D Data.Fixed.$fEnumFixed1
                    of {
                      __DEFAULT -> Data.Fixed.$fEnumFixed1;
                      1# -> Data.Fixed.$fEnumFixed2
                    }
                }
            }
            }
            }
            }
            }
            } } in
      let {
        lvl18_sgo8t :: Fixed a_agnFb
        [LclId]
        lvl18_sgo8t
          = ^ @ (Fixed a_agnFb)
              @ Integer
              (Data.Fixed.$fNumFixed @ a_agnFb $dHasResolution_agnFc)
              GHC.Real.$fIntegralInteger
              ((integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
                  Data.Fixed.$fHasResolutionE4
                  (($dHasResolution_agnFc
                    `cast` (Data.Fixed.N:HasResolution[0] <a_agnFb>_N
                            :: (HasResolution a_agnFb :: Constraint)
                               ~R# (forall (p :: * -> *). p a_agnFb -> Integer :: *)))
                     @ GHC.Types.Any (Data.Fixed.$fFractionalFixed2 @ a_agnFb)))
               `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnFb>_P)
                       :: (Integer :: *) ~R# (Fixed a_agnFb :: *)))
              e_sgo8m } in
      GHC.Read.readNumber1
        @ (Fixed a_agnFb)
        (Data.Fixed.$fNumFixed @ a_agnFb $dHasResolution_agnFc)
        (\ (ds_dgnQC :: Lexeme) ->
           case ds_dgnQC of {
             __DEFAULT ->
               (Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                  @ (Fixed a_agnFb))
               `cast` ((<Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Fixed
                                         a_agnFb>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                 <Fixed a_agnFb>_R)
                       :: (Prec
                           -> forall b.
                              (Fixed a_agnFb -> Text.ParserCombinators.ReadP.P b)
                              -> Text.ParserCombinators.ReadP.P b :: *)
                          ~R# (ReadPrec (Fixed a_agnFb) :: *));
             Number n_agnoM ->
               case numberToFixed e_sgo8m n_agnoM of {
                 Nothing ->
                   (Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                      @ (Fixed a_agnFb))
                   `cast` ((<Prec>_R
                            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                          <Fixed
                                             a_agnFb>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     <Fixed a_agnFb>_R)
                           :: (Prec
                               -> forall b.
                                  (Fixed a_agnFb -> Text.ParserCombinators.ReadP.P b)
                                  -> Text.ParserCombinators.ReadP.P b :: *)
                              ~R# (ReadPrec (Fixed a_agnFb) :: *));
                 Just ds1_dgnSd ->
                   case ds1_dgnSd of { (i_agnoP, f_agnoQ) ->
                   let {
                     x_sgo6n :: Integer
                     [LclId]
                     x_sgo6n
                       = integer-simple-0.1.1.1:GHC.Integer.Type.plusInteger
                           (integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
                              i_agnoP lvl17_sgo8q)
                           (Data.Fixed.$fFractionalFixed3
                              @ a_agnFb
                              $dHasResolution_agnFc
                              ((integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
                                  f_agnoQ lvl17_sgo8q)
                               `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnFb>_P)
                                       :: (Integer :: *) ~R# (Fixed a_agnFb :: *)))
                              lvl18_sgo8t) } in
                   (\ _ [Occ=Dead]
                      (@ b_i816N)
                      (k_i816O
                         :: Fixed a_agnFb -> Text.ParserCombinators.ReadP.P b_i816N) ->
                      k_i816O
                        (x_sgo6n
                         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnFb>_P)
                                 :: (Integer :: *) ~R# (Fixed a_agnFb :: *))))
                   `cast` ((<Prec>_R
                            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                          <Fixed
                                             a_agnFb>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     <Fixed a_agnFb>_R)
                           :: (Prec
                               -> forall b.
                                  (Fixed a_agnFb -> Text.ParserCombinators.ReadP.P b)
                                  -> Text.ParserCombinators.ReadP.P b :: *)
                              ~R# (ReadPrec (Fixed a_agnFb) :: *))
                   }
               }
           })

-- RHS size: {terms: 10, types: 21, coercions: 0, joins: 0/1}
Data.Fixed.$fReadFixed_$creadsPrec
  :: forall a. HasResolution a => Int -> ReadS (Fixed a)
[GblId,
 Arity=1,
 Str=<L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 90 60}]
Data.Fixed.$fReadFixed_$creadsPrec
  = \ (@ a_XgnJE) ($dHasResolution_XgnJG :: HasResolution a_XgnJE) ->
      let {
        ds_sgo6j [Dmd=<L,C(C1(U))>]
          :: Prec
             -> forall b.
                (Fixed a_XgnJE -> Text.ParserCombinators.ReadP.P b)
                -> Text.ParserCombinators.ReadP.P b
        [LclId]
        ds_sgo6j
          = Data.Fixed.$fReadFixed1 @ a_XgnJE $dHasResolution_XgnJG } in
      \ (n_i8156 :: Int) ->
        Text.ParserCombinators.ReadP.run
          @ (Fixed a_XgnJE)
          (ds_sgo6j
             n_i8156
             @ (Fixed a_XgnJE)
             (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                @ (Fixed a_XgnJE)))

-- RHS size: {terms: 5, types: 7, coercions: 11, joins: 0/0}
Data.Fixed.$fReadFixed_$creadListPrec
  :: forall a. HasResolution a => ReadPrec [Fixed a]
[GblId,
 Arity=1,
 Str=<L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgnJC)
                 ($dHasResolution_XgnJE [Occ=Once] :: HasResolution a_XgnJC) ->
                 list
                   @ (Fixed a_XgnJC)
                   ((Data.Fixed.$fReadFixed1 @ a_XgnJC $dHasResolution_XgnJE)
                    `cast` ((<Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Fixed
                                              a_XgnJC>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Fixed a_XgnJC>_R)
                            :: (Prec
                                -> forall b.
                                   (Fixed a_XgnJC -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (ReadPrec (Fixed a_XgnJC) :: *)))}]
Data.Fixed.$fReadFixed_$creadListPrec
  = \ (@ a_XgnJC) ($dHasResolution_XgnJE :: HasResolution a_XgnJC) ->
      list
        @ (Fixed a_XgnJC)
        ((Data.Fixed.$fReadFixed1 @ a_XgnJC $dHasResolution_XgnJE)
         `cast` ((<Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Fixed
                                   a_XgnJC>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Fixed a_XgnJC>_R)
                 :: (Prec
                     -> forall b.
                        (Fixed a_XgnJC -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (Fixed a_XgnJC) :: *)))

-- RHS size: {terms: 8, types: 16, coercions: 19, joins: 0/0}
Data.Fixed.$fReadFixed_$creadList
  :: forall a. HasResolution a => ReadS [Fixed a]
[GblId,
 Arity=1,
 Str=<L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgnJD)
                 ($dHasResolution_XgnJF [Occ=Once] :: HasResolution a_XgnJD) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Fixed a_XgnJD]
                   (((((list
                          @ (Fixed a_XgnJD)
                          ((Data.Fixed.$fReadFixed1 @ a_XgnJD $dHasResolution_XgnJF)
                           `cast` ((<Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <Fixed
                                                     a_XgnJD>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <Fixed a_XgnJD>_R)
                                   :: (Prec
                                       -> forall b.
                                          (Fixed a_XgnJD -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (ReadPrec (Fixed a_XgnJD) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[Fixed a_XgnJD]>_R
                               :: (ReadPrec [Fixed a_XgnJD] :: *)
                                  ~R# (Prec
                                       -> Text.ParserCombinators.ReadP.ReadP [Fixed a_XgnJD] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Fixed a_XgnJD]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [Fixed a_XgnJD] :: *)
                                ~R# (forall b.
                                     ([Fixed a_XgnJD] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [Fixed a_XgnJD]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Fixed a_XgnJD]))}]
Data.Fixed.$fReadFixed_$creadList
  = \ (@ a_XgnJD) ($dHasResolution_XgnJF :: HasResolution a_XgnJD) ->
      Text.ParserCombinators.ReadP.run
        @ [Fixed a_XgnJD]
        (((((list
               @ (Fixed a_XgnJD)
               ((Data.Fixed.$fReadFixed1 @ a_XgnJD $dHasResolution_XgnJF)
                `cast` ((<Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Fixed
                                          a_XgnJD>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Fixed a_XgnJD>_R)
                        :: (Prec
                            -> forall b.
                               (Fixed a_XgnJD -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (ReadPrec (Fixed a_XgnJD) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[Fixed a_XgnJD]>_R
                    :: (ReadPrec [Fixed a_XgnJD] :: *)
                       ~R# (Prec
                            -> Text.ParserCombinators.ReadP.ReadP [Fixed a_XgnJD] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Fixed a_XgnJD]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [Fixed a_XgnJD] :: *)
                     ~R# (forall b.
                          ([Fixed a_XgnJD] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [Fixed a_XgnJD]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [Fixed a_XgnJD]))

-- RHS size: {terms: 11, types: 10, coercions: 11, joins: 0/0}
Data.Fixed.$fReadFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. HasResolution a => Read (Fixed a)
[GblId[DFunId],
 Arity=1,
 Str=<L,C(U)>m,
 Unf=DFun: \ (@ a_agnnd) (v_B1 :: HasResolution a_agnnd) ->
       GHC.Read.C:Read TYPE: Fixed a_agnnd
                       Data.Fixed.$fReadFixed_$creadsPrec @ a_agnnd v_B1
                       Data.Fixed.$fReadFixed_$creadList @ a_agnnd v_B1
                       (Data.Fixed.$fReadFixed1 @ a_agnnd v_B1)
                       `cast` ((<Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Fixed
                                                 a_agnnd>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <Fixed a_agnnd>_R)
                               :: (Prec
                                   -> forall b.
                                      (Fixed a_agnnd -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (ReadPrec (Fixed a_agnnd) :: *))
                       Data.Fixed.$fReadFixed_$creadListPrec @ a_agnnd v_B1]
Data.Fixed.$fReadFixed
  = \ (@ a_XgnJB) ($dHasResolution_XgnJD :: HasResolution a_XgnJB) ->
      GHC.Read.C:Read
        @ (Fixed a_XgnJB)
        (Data.Fixed.$fReadFixed_$creadsPrec
           @ a_XgnJB $dHasResolution_XgnJD)
        (Data.Fixed.$fReadFixed_$creadList @ a_XgnJB $dHasResolution_XgnJD)
        ((Data.Fixed.$fReadFixed1 @ a_XgnJB $dHasResolution_XgnJD)
         `cast` ((<Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Fixed
                                   a_XgnJB>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Fixed a_XgnJB>_R)
                 :: (Prec
                     -> forall b.
                        (Fixed a_XgnJB -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (ReadPrec (Fixed a_XgnJB) :: *)))
        (Data.Fixed.$fReadFixed_$creadListPrec
           @ a_XgnJB $dHasResolution_XgnJD)

-- RHS size: {terms: 4, types: 4, coercions: 18, joins: 0/0}
Data.Fixed.$fEqFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq (Fixed a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_agnnc) ->
       GHC.Classes.C:Eq TYPE: Fixed a_agnnc
                        integer-simple-0.1.1.1:GHC.Integer.Type.eqInteger
                        `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                ->_R <Bool>_R
                                :: (Integer -> Integer -> Bool :: *)
                                   ~R# (Fixed a_agnnc -> Fixed a_agnnc -> Bool :: *))
                        integer-simple-0.1.1.1:GHC.Integer.Type.neqInteger
                        `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                ->_R <Bool>_R
                                :: (Integer -> Integer -> Bool :: *)
                                   ~R# (Fixed a_agnnc -> Fixed a_agnnc -> Bool :: *))]
Data.Fixed.$fEqFixed
  = \ (@ a_agnC3) ->
      GHC.Classes.C:Eq
        @ (Fixed a_agnC3)
        (integer-simple-0.1.1.1:GHC.Integer.Type.eqInteger
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnC3>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnC3>_P)
                 ->_R <Bool>_R
                 :: (Integer -> Integer -> Bool :: *)
                    ~R# (Fixed a_agnC3 -> Fixed a_agnC3 -> Bool :: *)))
        (integer-simple-0.1.1.1:GHC.Integer.Type.neqInteger
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnC3>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnC3>_P)
                 ->_R <Bool>_R
                 :: (Integer -> Integer -> Bool :: *)
                    ~R# (Fixed a_agnC3 -> Fixed a_agnC3 -> Bool :: *)))

-- RHS size: {terms: 10, types: 5, coercions: 67, joins: 0/0}
Data.Fixed.$fOrdFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord (Fixed a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_agnnc) ->
       GHC.Classes.C:Ord TYPE: Fixed a_agnnc
                         Data.Fixed.$fEqFixed @ a_agnnc
                         integer-simple-0.1.1.1:GHC.Integer.Type.compareInteger
                         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R <Ordering>_R
                                 :: (Integer -> Integer -> Ordering :: *)
                                    ~R# (Fixed a_agnnc -> Fixed a_agnnc -> Ordering :: *))
                         integer-simple-0.1.1.1:GHC.Integer.Type.ltInteger
                         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R <Bool>_R
                                 :: (Integer -> Integer -> Bool :: *)
                                    ~R# (Fixed a_agnnc -> Fixed a_agnnc -> Bool :: *))
                         integer-simple-0.1.1.1:GHC.Integer.Type.leInteger
                         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R <Bool>_R
                                 :: (Integer -> Integer -> Bool :: *)
                                    ~R# (Fixed a_agnnc -> Fixed a_agnnc -> Bool :: *))
                         integer-simple-0.1.1.1:GHC.Integer.Type.gtInteger
                         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R <Bool>_R
                                 :: (Integer -> Integer -> Bool :: *)
                                    ~R# (Fixed a_agnnc -> Fixed a_agnnc -> Bool :: *))
                         integer-simple-0.1.1.1:GHC.Integer.Type.geInteger
                         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R <Bool>_R
                                 :: (Integer -> Integer -> Bool :: *)
                                    ~R# (Fixed a_agnnc -> Fixed a_agnnc -> Bool :: *))
                         integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger_$cmax
                         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 :: (Integer -> Integer -> Integer :: *)
                                    ~R# (Fixed a_agnnc -> Fixed a_agnnc -> Fixed a_agnnc :: *))
                         integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger_$cmin
                         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnnc>_P)
                                 :: (Integer -> Integer -> Integer :: *)
                                    ~R# (Fixed a_agnnc -> Fixed a_agnnc -> Fixed a_agnnc :: *))]
Data.Fixed.$fOrdFixed
  = \ (@ a_agnCA) ->
      GHC.Classes.C:Ord
        @ (Fixed a_agnCA)
        (Data.Fixed.$fEqFixed @ a_agnCA)
        (integer-simple-0.1.1.1:GHC.Integer.Type.compareInteger
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R <Ordering>_R
                 :: (Integer -> Integer -> Ordering :: *)
                    ~R# (Fixed a_agnCA -> Fixed a_agnCA -> Ordering :: *)))
        (integer-simple-0.1.1.1:GHC.Integer.Type.ltInteger
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R <Bool>_R
                 :: (Integer -> Integer -> Bool :: *)
                    ~R# (Fixed a_agnCA -> Fixed a_agnCA -> Bool :: *)))
        (integer-simple-0.1.1.1:GHC.Integer.Type.leInteger
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R <Bool>_R
                 :: (Integer -> Integer -> Bool :: *)
                    ~R# (Fixed a_agnCA -> Fixed a_agnCA -> Bool :: *)))
        (integer-simple-0.1.1.1:GHC.Integer.Type.gtInteger
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R <Bool>_R
                 :: (Integer -> Integer -> Bool :: *)
                    ~R# (Fixed a_agnCA -> Fixed a_agnCA -> Bool :: *)))
        (integer-simple-0.1.1.1:GHC.Integer.Type.geInteger
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R <Bool>_R
                 :: (Integer -> Integer -> Bool :: *)
                    ~R# (Fixed a_agnCA -> Fixed a_agnCA -> Bool :: *)))
        (integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger_$cmax
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 :: (Integer -> Integer -> Integer :: *)
                    ~R# (Fixed a_agnCA -> Fixed a_agnCA -> Fixed a_agnCA :: *)))
        (integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger_$cmin
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 ->_R Sym (Data.Fixed.N:Fixed[0] <a_agnCA>_P)
                 :: (Integer -> Integer -> Integer :: *)
                    ~R# (Fixed a_agnCA -> Fixed a_agnCA -> Fixed a_agnCA :: *)))

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Fixed.$fRealFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. HasResolution a => Real (Fixed a)
[GblId[DFunId],
 Arity=1,
 Str=<L,C(U)>m,
 Unf=DFun: \ (@ a_agnnv) (v_B1 :: HasResolution a_agnnv) ->
       GHC.Real.C:Real TYPE: Fixed a_agnnv
                       Data.Fixed.$fNumFixed @ a_agnnv v_B1
                       Data.Fixed.$fOrdFixed @ a_agnnv
                       Data.Fixed.$fRealFixed_$ctoRational @ a_agnnv v_B1]
Data.Fixed.$fRealFixed
  = \ (@ a_agnIn) ($dHasResolution_agnIo :: HasResolution a_agnIn) ->
      GHC.Real.C:Real
        @ (Fixed a_agnIn)
        (Data.Fixed.$fNumFixed @ a_agnIn $dHasResolution_agnIo)
        (Data.Fixed.$fOrdFixed @ a_agnIn)
        (Data.Fixed.$fRealFixed_$ctoRational
           @ a_agnIn $dHasResolution_agnIo)

-- RHS size: {terms: 34, types: 33, coercions: 4, joins: 0/0}
Data.Fixed.$fRealFracFixed_$ctruncate
  :: forall a.
     HasResolution a =>
     forall b. Integral b => Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 30 0] 250 0}]
Data.Fixed.$fRealFracFixed_$ctruncate
  = \ (@ a_agnG0)
      ($dHasResolution_agnG1 :: HasResolution a_agnG0)
      (@ b_agnGE)
      ($dIntegral_agnGG :: Integral b_agnGE)
      (f_agnni :: Fixed a_agnG0) ->
      case ($dHasResolution_agnG1
            `cast` (Data.Fixed.N:HasResolution[0] <a_agnG0>_N
                    :: (HasResolution a_agnG0 :: Constraint)
                       ~R# (forall (p :: * -> *). p a_agnG0 -> Integer :: *)))
             @ Fixed f_agnni
      of dt_XcBU3
      { __DEFAULT ->
      case GHC.Real.$w$s$c/
             (f_agnni
              `cast` (Data.Fixed.N:Fixed[0] <a_agnG0>_P
                      :: (Fixed a_agnG0 :: *) ~R# (Integer :: *)))
             GHC.Real.$fEnumRatio1
             dt_XcBU3
             GHC.Real.$fEnumRatio1
      of
      { (# ww7_ignZU, ww8_ignZV #) ->
      fromInteger
        @ b_agnGE
        (GHC.Real.$p1Real
           @ b_agnGE (GHC.Real.$p1Integral @ b_agnGE $dIntegral_agnGG))
        (case integer-simple-0.1.1.1:GHC.Integer.Type.eqInteger#
                ww8_ignZV Data.Fixed.$fEnumFixed1
         of {
           __DEFAULT ->
             case integer-simple-0.1.1.1:GHC.Integer.Type.quotRemInteger
                    ww7_ignZU ww8_ignZV
             of
             { (# ipv_igo2M, ipv1_igo2N #) ->
             ipv_igo2M
             };
           1# -> case GHC.Real.divZeroError of wild_00 { }
         })
      }
      }

-- RHS size: {terms: 20, types: 20, coercions: 4, joins: 0/0}
Data.Fixed.$fRealFracFixed_$cround
  :: forall a.
     HasResolution a =>
     forall b. Integral b => Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 130 0}]
Data.Fixed.$fRealFracFixed_$cround
  = \ (@ a_agnG0)
      ($dHasResolution_agnG1 :: HasResolution a_agnG0)
      (@ b_agnGR)
      ($dIntegral_agnGT :: Integral b_agnGR)
      (f_agnnj :: Fixed a_agnG0) ->
      case ($dHasResolution_agnG1
            `cast` (Data.Fixed.N:HasResolution[0] <a_agnG0>_N
                    :: (HasResolution a_agnG0 :: Constraint)
                       ~R# (forall (p :: * -> *). p a_agnG0 -> Integer :: *)))
             @ Fixed f_agnnj
      of dt_XcBU3
      { __DEFAULT ->
      case GHC.Real.$w$s$c/
             (f_agnnj
              `cast` (Data.Fixed.N:Fixed[0] <a_agnG0>_P
                      :: (Fixed a_agnG0 :: *) ~R# (Integer :: *)))
             GHC.Real.$fEnumRatio1
             dt_XcBU3
             GHC.Real.$fEnumRatio1
      of
      { (# ww7_ignZU, ww8_ignZV #) ->
      GHC.Real.$w$s$cround @ b_agnGR $dIntegral_agnGT ww7_ignZU ww8_ignZV
      }
      }

-- RHS size: {terms: 20, types: 20, coercions: 4, joins: 0/0}
Data.Fixed.$fRealFracFixed_$cceiling
  :: forall a.
     HasResolution a =>
     forall b. Integral b => Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 130 0}]
Data.Fixed.$fRealFracFixed_$cceiling
  = \ (@ a_agnG0)
      ($dHasResolution_agnG1 :: HasResolution a_agnG0)
      (@ b_agnH4)
      ($dIntegral_agnH6 :: Integral b_agnH4)
      (f_agnnk :: Fixed a_agnG0) ->
      case ($dHasResolution_agnG1
            `cast` (Data.Fixed.N:HasResolution[0] <a_agnG0>_N
                    :: (HasResolution a_agnG0 :: Constraint)
                       ~R# (forall (p :: * -> *). p a_agnG0 -> Integer :: *)))
             @ Fixed f_agnnk
      of dt_XcBU3
      { __DEFAULT ->
      case GHC.Real.$w$s$c/
             (f_agnnk
              `cast` (Data.Fixed.N:Fixed[0] <a_agnG0>_P
                      :: (Fixed a_agnG0 :: *) ~R# (Integer :: *)))
             GHC.Real.$fEnumRatio1
             dt_XcBU3
             GHC.Real.$fEnumRatio1
      of
      { (# ww7_ignZU, ww8_ignZV #) ->
      GHC.Real.$w$s$cceiling
        @ b_agnH4 $dIntegral_agnH6 ww7_ignZU ww8_ignZV
      }
      }

-- RHS size: {terms: 20, types: 20, coercions: 4, joins: 0/0}
Data.Fixed.$fRealFracFixed_$cfloor
  :: forall a.
     HasResolution a =>
     forall b. Integral b => Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 130 0}]
Data.Fixed.$fRealFracFixed_$cfloor
  = \ (@ a_agnG0)
      ($dHasResolution_agnG1 :: HasResolution a_agnG0)
      (@ b_agnHh)
      ($dIntegral_agnHj :: Integral b_agnHh)
      (f_agnnl :: Fixed a_agnG0) ->
      case ($dHasResolution_agnG1
            `cast` (Data.Fixed.N:HasResolution[0] <a_agnG0>_N
                    :: (HasResolution a_agnG0 :: Constraint)
                       ~R# (forall (p :: * -> *). p a_agnG0 -> Integer :: *)))
             @ Fixed f_agnnl
      of dt_XcBU3
      { __DEFAULT ->
      case GHC.Real.$w$s$c/
             (f_agnnl
              `cast` (Data.Fixed.N:Fixed[0] <a_agnG0>_P
                      :: (Fixed a_agnG0 :: *) ~R# (Integer :: *)))
             GHC.Real.$fEnumRatio1
             dt_XcBU3
             GHC.Real.$fEnumRatio1
      of
      { (# ww7_ignZU, ww8_ignZV #) ->
      GHC.Real.$w$s$cfloor @ b_agnHh $dIntegral_agnHj ww7_ignZU ww8_ignZV
      }
      }

-- RHS size: {terms: 20, types: 25, coercions: 7, joins: 0/1}
Data.Fixed.$w$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     HasResolution a =>
     forall b. Integral b => Fixed a -> (# b, Fixed a #)
[GblId,
 Arity=3,
 Str=<L,C(U)><L,U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 30 0] 160 30}]
Data.Fixed.$w$cproperFraction
  = \ (@ a_sgoof)
      (w_sgoog :: HasResolution a_sgoof)
      (@ b_sgooh)
      (w3_sgooi :: Integral b_sgooh)
      (w4_sgooj :: Fixed a_sgoof) ->
      let {
        i_sgo6h :: b_sgooh
        [LclId]
        i_sgo6h
          = Data.Fixed.$fRealFracFixed_$ctruncate
              @ a_sgoof w_sgoog @ b_sgooh w3_sgooi w4_sgooj } in
      (# i_sgo6h,
         (integer-simple-0.1.1.1:GHC.Integer.Type.minusInteger
            (w4_sgooj
             `cast` (Data.Fixed.N:Fixed[0] <a_sgoof>_P
                     :: (Fixed a_sgoof :: *) ~R# (Integer :: *)))
            (integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
               (toInteger @ b_sgooh w3_sgooi i_sgo6h)
               ((w_sgoog
                 `cast` (Data.Fixed.N:HasResolution[0] <a_sgoof>_N
                         :: (HasResolution a_sgoof :: Constraint)
                            ~R# (forall (p :: * -> *). p a_sgoof -> Integer :: *)))
                  @ GHC.Types.Any (Data.Fixed.$fFractionalFixed2 @ a_sgoof))))
         `cast` (Sym (Data.Fixed.N:Fixed[0] <a_sgoof>_P)
                 :: (Integer :: *) ~R# (Fixed a_sgoof :: *)) #)

-- RHS size: {terms: 14, types: 24, coercions: 0, joins: 0/0}
Data.Fixed.$fRealFracFixed_$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     HasResolution a =>
     forall b. Integral b => Fixed a -> (b, Fixed a)
[GblId,
 Arity=3,
 Str=<L,C(U)><L,U(U(U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgoof)
                 (w_sgoog [Occ=Once] :: HasResolution a_sgoof)
                 (@ b_sgooh)
                 (w3_sgooi [Occ=Once] :: Integral b_sgooh)
                 (w4_sgooj [Occ=Once] :: Fixed a_sgoof) ->
                 case Data.Fixed.$w$cproperFraction
                        @ a_sgoof w_sgoog @ b_sgooh w3_sgooi w4_sgooj
                 of
                 { (# ww1_sgooO [Occ=Once], ww2_sgooP [Occ=Once] #) ->
                 (ww1_sgooO, ww2_sgooP)
                 }}]
Data.Fixed.$fRealFracFixed_$cproperFraction
  = \ (@ a_sgoof)
      (w_sgoog :: HasResolution a_sgoof)
      (@ b_sgooh)
      (w3_sgooi :: Integral b_sgooh)
      (w4_sgooj :: Fixed a_sgoof) ->
      case Data.Fixed.$w$cproperFraction
             @ a_sgoof w_sgoog @ b_sgooh w3_sgooi w4_sgooj
      of
      { (# ww1_sgooO, ww2_sgooP #) ->
      (ww1_sgooO, ww2_sgooP)
      }

-- RHS size: {terms: 17, types: 13, coercions: 0, joins: 0/0}
Data.Fixed.$fRealFracFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. HasResolution a => RealFrac (Fixed a)
[GblId[DFunId],
 Arity=1,
 Str=<L,C(U)>m,
 Unf=DFun: \ (@ a_agnnf) (v_B1 :: HasResolution a_agnnf) ->
       GHC.Real.C:RealFrac TYPE: Fixed a_agnnf
                           Data.Fixed.$fRealFixed @ a_agnnf v_B1
                           Data.Fixed.$fFractionalFixed @ a_agnnf v_B1
                           Data.Fixed.$fRealFracFixed_$cproperFraction @ a_agnnf v_B1
                           Data.Fixed.$fRealFracFixed_$ctruncate @ a_agnnf v_B1
                           Data.Fixed.$fRealFracFixed_$cround @ a_agnnf v_B1
                           Data.Fixed.$fRealFracFixed_$cceiling @ a_agnnf v_B1
                           Data.Fixed.$fRealFracFixed_$cfloor @ a_agnnf v_B1]
Data.Fixed.$fRealFracFixed
  = \ (@ a_agnG0) ($dHasResolution_agnG1 :: HasResolution a_agnG0) ->
      GHC.Real.C:RealFrac
        @ (Fixed a_agnG0)
        (Data.Fixed.$fRealFixed @ a_agnG0 $dHasResolution_agnG1)
        (Data.Fixed.$fFractionalFixed @ a_agnG0 $dHasResolution_agnG1)
        (Data.Fixed.$fRealFracFixed_$cproperFraction
           @ a_agnG0 $dHasResolution_agnG1)
        (Data.Fixed.$fRealFracFixed_$ctruncate
           @ a_agnG0 $dHasResolution_agnG1)
        (Data.Fixed.$fRealFracFixed_$cround
           @ a_agnG0 $dHasResolution_agnG1)
        (Data.Fixed.$fRealFracFixed_$cceiling
           @ a_agnG0 $dHasResolution_agnG1)
        (Data.Fixed.$fRealFracFixed_$cfloor
           @ a_agnG0 $dHasResolution_agnG1)

Rec {
-- RHS size: {terms: 22, types: 4, coercions: 0, joins: 0/0}
chopZeros_rgnn4 :: Integer -> String
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []]
chopZeros_rgnn4
  = \ (ds_dgnSF :: Integer) ->
      case integer-simple-0.1.1.1:GHC.Integer.Type.eqInteger#
             ds_dgnSF Data.Fixed.$fEnumFixed1
      of {
        __DEFAULT ->
          case integer-simple-0.1.1.1:GHC.Integer.Type.eqInteger#
                 (integer-simple-0.1.1.1:GHC.Integer.Type.modInteger
                    ds_dgnSF Data.Fixed.$fHasResolutionE4)
                 Data.Fixed.$fEnumFixed1
          of {
            __DEFAULT -> GHC.Show.$fShowInteger_$cshow ds_dgnSF;
            1# ->
              chopZeros_rgnn4
                (integer-simple-0.1.1.1:GHC.Integer.Type.divInteger
                   ds_dgnSF Data.Fixed.$fHasResolutionE4)
          };
        1# -> GHC.Types.[] @ Char
      }
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl14_rgoyT :: Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl14_rgoyT = GHC.Types.C# '0'#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl15_rgoyU :: Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl15_rgoyU = GHC.Types.C# '.'#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl16_rgoyV :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl16_rgoyV = "-"#

Rec {
-- RHS size: {terms: 205, types: 103, coercions: 11, joins: 3/10}
showFixed [Occ=LoopBreaker]
  :: forall a. HasResolution a => Bool -> Fixed a -> String
[GblId, Arity=3, Str=<L,1*C1(U)><L,U><S,U>, Unf=OtherCon []]
showFixed
  = \ (@ a_agnyt)
      ($dHasResolution_agnyv :: HasResolution a_agnyt)
      (chopTrailingZeros_agnox :: Bool)
      (fa_agnoy :: Fixed a_agnyt) ->
      case integer-simple-0.1.1.1:GHC.Integer.Type.ltInteger#
             (fa_agnoy
              `cast` (Data.Fixed.N:Fixed[0] <a_agnyt>_P
                      :: (Fixed a_agnyt :: *) ~R# (Integer :: *)))
             Data.Fixed.$fEnumFixed1
      of {
        __DEFAULT ->
          let {
            res_sgo67 [Dmd=<S,U>] :: Integer
            [LclId]
            res_sgo67
              = ($dHasResolution_agnyv
                 `cast` (Data.Fixed.N:HasResolution[0] <a_agnyt>_N
                         :: (HasResolution a_agnyt :: Constraint)
                            ~R# (forall (p :: * -> *). p a_agnyt -> Integer :: *)))
                  @ Fixed fa_agnoy } in
          case integer-simple-0.1.1.1:GHC.Integer.Type.eqInteger#
                 res_sgo67 Data.Fixed.$fEnumFixed1
          of wild1_igo3d {
            __DEFAULT ->
              case integer-simple-0.1.1.1:GHC.Integer.Type.divModInteger
                     (fa_agnoy
                      `cast` (Data.Fixed.N:Fixed[0] <a_agnyt>_P
                              :: (Fixed a_agnyt :: *) ~R# (Integer :: *)))
                     res_sgo67
              of
              { (# ipv_igo3g, ipv1_igo3h #) ->
              case GHC.Show.$w$cshowsPrec4 0# ipv_igo3g (GHC.Types.[] @ Char) of
              { (# ww3_ibkxp, ww4_ibkxq #) ->
              ++
                @ Char
                (GHC.Types.: @ Char ww3_ibkxp ww4_ibkxq)
                (case integer-simple-0.1.1.1:GHC.Integer.Type.doubleFromInteger
                        res_sgo67
                 of wild2_igo1s
                 { __DEFAULT ->
                 case GHC.Prim.logDouble# wild2_igo1s of wild3_igo1d { __DEFAULT ->
                 case Data.Fixed.$fReadFixed2 of { GHC.Types.D# v1_B2 ->
                 case GHC.Prim./## wild3_igo1d v1_B2 of wild4_igo1j { __DEFAULT ->
                 let {
                   n_sgo6d [Dmd=<S,U>] :: GHC.Prim.Int#
                   [LclId]
                   n_sgo6d = GHC.Prim.double2Int# wild4_igo1j } in
                 join {
                   $j_sgoqq [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> [Char]
                   [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                   $j_sgoqq (ww_sgoor [OS=OneShot] :: GHC.Prim.Int#)
                     = case GHC.Prim.<# ww_sgoor 0# of {
                         __DEFAULT ->
                           join {
                             $j1_sgoqo [Dmd=<C(S),1*C1(U)>] :: Integer -> [Char]
                             [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
                             $j1_sgoqo (ds_sgo64 [OS=OneShot] :: Integer)
                               = join {
                                   fail_sgo63 [Dmd=<L,1*C1(U)>] :: GHC.Prim.Void# -> [Char]
                                   [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
                                   fail_sgo63 _ [Occ=Dead, OS=OneShot]
                                     = case GHC.Show.$w$cshowsPrec4
                                              0# ds_sgo64 (GHC.Types.[] @ Char)
                                       of
                                       { (# ww5_XbkDQ, ww6_XbkDS #) ->
                                       let {
                                         s_sgo69 [Dmd=<S,U>] :: String
                                         [LclId, Unf=OtherCon []]
                                         s_sgo69 = GHC.Types.: @ Char ww5_XbkDQ ww6_XbkDS } in
                                       case GHC.List.$wlenAcc @ Char s_sgo69 0# of ww7_i8PwI
                                       { __DEFAULT ->
                                       let {
                                         y_alNd [Dmd=<S,U>] :: GHC.Prim.Int#
                                         [LclId]
                                         y_alNd = GHC.Prim.-# ww_sgoor ww7_i8PwI } in
                                       case GHC.Prim.<# 0# y_alNd of {
                                         __DEFAULT ->
                                           case chopTrailingZeros_agnox of {
                                             False -> GHC.Types.: @ Char lvl15_rgoyU s_sgo69;
                                             True ->
                                               case chopZeros_rgnn4 ds_sgo64 of wild6_X4Z {
                                                 [] -> GHC.Types.[] @ Char;
                                                 : ipv2_sgo3R ipv3_sgo3S ->
                                                   GHC.Types.: @ Char lvl15_rgoyU wild6_X4Z
                                               }
                                           };
                                         1# ->
                                           let {
                                             n1_iax4b :: [Char]
                                             [LclId]
                                             n1_iax4b
                                               = case chopTrailingZeros_agnox of {
                                                   False -> s_sgo69;
                                                   True -> chopZeros_rgnn4 ds_sgo64
                                                 } } in
                                           let {
                                             lvl17_sgotK :: [Char]
                                             [LclId, Unf=OtherCon []]
                                             lvl17_sgotK
                                               = GHC.Types.: @ Char lvl14_rgoyT n1_iax4b } in
                                           letrec {
                                             $wxs_sgooy [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                                               :: GHC.Prim.Int# -> [Char]
                                             [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                             $wxs_sgooy
                                               = \ (ww8_sgoow :: GHC.Prim.Int#) ->
                                                   case ww8_sgoow of ds3_iax4j {
                                                     __DEFAULT ->
                                                       GHC.Types.:
                                                         @ Char
                                                         lvl14_rgoyT
                                                         ($wxs_sgooy (GHC.Prim.-# ds3_iax4j 1#));
                                                     1# -> lvl17_sgotK
                                                   }; } in
                                           case $wxs_sgooy y_alNd of wild5_X4Z {
                                             [] -> GHC.Types.[] @ Char;
                                             : ipv2_sgo3R ipv3_sgo3S ->
                                               GHC.Types.: @ Char lvl15_rgoyU wild5_X4Z
                                           }
                                       }
                                       }
                                       } } in
                                 case chopTrailingZeros_agnox of {
                                   False -> jump fail_sgo63 GHC.Prim.void#;
                                   True ->
                                     case integer-simple-0.1.1.1:GHC.Integer.Type.eqInteger#
                                            ds_sgo64 Data.Fixed.$fEnumFixed1
                                     of {
                                       __DEFAULT -> jump fail_sgo63 GHC.Prim.void#;
                                       1# -> GHC.Types.[] @ Char
                                     }
                                 } } in
                           case ww_sgoor of wild5_igod1 {
                             __DEFAULT ->
                               jump $j1_sgoqo
                                 (integer-simple-0.1.1.1:GHC.Integer.Type.divInteger
                                    (integer-simple-0.1.1.1:GHC.Integer.Type.minusInteger
                                       (integer-simple-0.1.1.1:GHC.Integer.Type.plusInteger
                                          (integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
                                             ipv1_igo3h
                                             (GHC.Real.$wf
                                                Data.Fixed.$fHasResolutionE4 wild5_igod1))
                                          res_sgo67)
                                       Data.Fixed.$fEnumFixed2)
                                    res_sgo67);
                             0# ->
                               jump $j1_sgoqo
                                 (integer-simple-0.1.1.1:GHC.Integer.Type.divInteger
                                    (integer-simple-0.1.1.1:GHC.Integer.Type.minusInteger
                                       (integer-simple-0.1.1.1:GHC.Integer.Type.plusInteger
                                          (integer-simple-0.1.1.1:GHC.Integer.Type.timesInteger
                                             ipv1_igo3h GHC.Real.$fEnumRatio1)
                                          res_sgo67)
                                       Data.Fixed.$fEnumFixed2)
                                    res_sgo67)
                           };
                         1# -> case GHC.Real.^1 of wild5_00 { }
                       } } in
                 case GHC.Prim.<## (GHC.Prim.int2Double# n_sgo6d) wild4_igo1j of {
                   __DEFAULT -> jump $j_sgoqq n_sgo6d;
                   1# -> jump $j_sgoqq (GHC.Prim.+# n_sgo6d 1#)
                 }
                 }
                 }
                 }
                 })
              }
              };
            1# -> case GHC.Real.divZeroError of wild2_00 { }
          };
        1# ->
          GHC.CString.unpackAppendCString#
            lvl16_rgoyV
            (showFixed
               @ a_agnyt
               $dHasResolution_agnyv
               chopTrailingZeros_agnox
               ((integer-simple-0.1.1.1:GHC.Integer.Type.negateInteger
                   (fa_agnoy
                    `cast` (Data.Fixed.N:Fixed[0] <a_agnyt>_P
                            :: (Fixed a_agnyt :: *) ~R# (Integer :: *))))
                `cast` (Sym (Data.Fixed.N:Fixed[0] <a_agnyt>_P)
                        :: (Integer :: *) ~R# (Fixed a_agnyt :: *))))
      }
end Rec }

-- RHS size: {terms: 5, types: 5, coercions: 0, joins: 0/0}
Data.Fixed.$fShowFixed_$cshow
  :: forall a. HasResolution a => Fixed a -> String
[GblId,
 Arity=2,
 Str=<L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agnFG)
                 ($dHasResolution_agnFH [Occ=Once] :: HasResolution a_agnFG) ->
                 showFixed @ a_agnFG $dHasResolution_agnFH GHC.Types.False}]
Data.Fixed.$fShowFixed_$cshow
  = \ (@ a_agnFG) ($dHasResolution_agnFH :: HasResolution a_agnFG) ->
      showFixed @ a_agnFG $dHasResolution_agnFH GHC.Types.False

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
Data.Fixed.$fShowFixed_$cshowsPrec
  :: forall a. HasResolution a => Int -> Fixed a -> ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(U)><L,A><S,U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agnFG)
                 ($dHasResolution_agnFH [Occ=Once] :: HasResolution a_agnFG)
                 _ [Occ=Dead]
                 (x_i7QGZ [Occ=Once] :: Fixed a_agnFG)
                 (s_i7QH0 [Occ=Once] :: String) ->
                 GHC.Base.augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      GHC.Base.foldr
                        @ Char
                        @ b_i7JbU
                        c_i7JbV
                        n_i7JbW
                        (showFixed
                           @ a_agnFG $dHasResolution_agnFH GHC.Types.False x_i7QGZ))
                   s_i7QH0}]
Data.Fixed.$fShowFixed_$cshowsPrec
  = \ (@ a_agnFG)
      ($dHasResolution_agnFH :: HasResolution a_agnFG)
      _ [Occ=Dead]
      (x_i7QGZ :: Fixed a_agnFG)
      (s_i7QH0 :: String) ->
      ++
        @ Char
        (showFixed @ a_agnFG $dHasResolution_agnFH GHC.Types.False x_i7QGZ)
        s_i7QH0

-- RHS size: {terms: 15, types: 15, coercions: 0, joins: 0/0}
Data.Fixed.$fShowFixed_$cshowList
  :: forall a. HasResolution a => [Fixed a] -> ShowS
[GblId,
 Arity=3,
 Str=<L,C(U)><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 130 0}]
Data.Fixed.$fShowFixed_$cshowList
  = \ (@ a_agnFG)
      ($dHasResolution_agnFH :: HasResolution a_agnFG)
      (ls_i7JaB :: [Fixed a_agnFG])
      (s_i7JaC :: String) ->
      GHC.Show.showList__
        @ (Fixed a_agnFG)
        (\ (x_i7QGZ :: Fixed a_agnFG) (s1_i7QH0 [OS=OneShot] :: String) ->
           ++
             @ Char
             (showFixed @ a_agnFG $dHasResolution_agnFH GHC.Types.False x_i7QGZ)
             s1_i7QH0)
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Fixed.$fShowFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. HasResolution a => Show (Fixed a)
[GblId[DFunId],
 Arity=1,
 Str=<L,C(U)>m,
 Unf=DFun: \ (@ a_agnne) (v_B1 :: HasResolution a_agnne) ->
       GHC.Show.C:Show TYPE: Fixed a_agnne
                       Data.Fixed.$fShowFixed_$cshowsPrec @ a_agnne v_B1
                       Data.Fixed.$fShowFixed_$cshow @ a_agnne v_B1
                       Data.Fixed.$fShowFixed_$cshowList @ a_agnne v_B1]
Data.Fixed.$fShowFixed
  = \ (@ a_agnFG) ($dHasResolution_agnFH :: HasResolution a_agnFG) ->
      GHC.Show.C:Show
        @ (Fixed a_agnFG)
        (Data.Fixed.$fShowFixed_$cshowsPrec
           @ a_agnFG $dHasResolution_agnFH)
        (Data.Fixed.$fShowFixed_$cshow @ a_agnFG $dHasResolution_agnFH)
        (Data.Fixed.$fShowFixed_$cshowList @ a_agnFG $dHasResolution_agnFH)


