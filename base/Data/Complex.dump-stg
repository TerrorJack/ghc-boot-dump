
==================== Pre unarise: ====================
2018-03-16 16:12:26.53815184 UTC

Data.Complex.$W:+ [InlPrag=INLINE[2]]
  :: forall a. a -> a -> Data.Complex.Complex a
[GblId[DataConWrapper],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>m,
 Unf=OtherCon []] =
    [] \r [dt_sgA6D dt_sgA6E]
        case dt_sgA6D of dt_sgA6F {
          __DEFAULT ->
              case dt_sgA6E of dt_sgA6G {
                __DEFAULT -> Data.Complex.:+ [dt_sgA6F dt_sgA6G];
              };
        };

Data.Complex.$fStorableComplex2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Complex.$fStorableComplex1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> Data.Complex.Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,U><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgA6H w1_sgA6I w2_sgA6J w3_sgA6K]
        case w2_sgA6J of {
          Data.Complex.:+ ww1_sgA6M [Occ=Once] ww2_sgA6N [Occ=Once] ->
              case Foreign.Storable.poke w_sgA6H w1_sgA6I ww1_sgA6M w3_sgA6K of {
                (#,#) ipv_sgA6P [Occ=Once] _ [Occ=Dead] ->
                    Foreign.Storable.pokeElemOff
                        w_sgA6H
                        w1_sgA6I
                        Data.Complex.$fStorableComplex2
                        ww2_sgA6N
                        ipv_sgA6P;
              };
        };

Data.Complex.$fStorableComplex3
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Complex.Complex a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,1*C1(C1(C1(U(U,U)))),A,A,A,1*C1(C1(U(U,U))),A)><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgA6R p_sgA6S s_sgA6T]
        case Foreign.Storable.peek $dStorable_sgA6R p_sgA6S s_sgA6T of {
          (#,#) ipv_sgA6V [Occ=Once] ipv1_sgA6W [Occ=Once] ->
              case
                  Foreign.Storable.peekElemOff
                      $dStorable_sgA6R p_sgA6S Data.Complex.$fStorableComplex2 ipv_sgA6V
              of
              { (#,#) ipv2_sgA6Y [Occ=Once] ipv3_sgA6Z [Occ=Once] ->
                    let {
                      sat_sgA70 [Occ=Once] :: Data.Complex.Complex a_XgsQ1
                      [LclId] =
                          [ipv1_sgA6W ipv3_sgA6Z] \u []
                              Data.Complex.$W:+ ipv1_sgA6W ipv3_sgA6Z;
                    } in  (#,#) [ipv2_sgA6Y sat_sgA70];
              };
        };

Data.Complex.$fApplicativeComplex_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> Data.Complex.Complex a
     -> Data.Complex.Complex b
     -> Data.Complex.Complex c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgA71 w1_sgA72 w2_sgA73]
        case w1_sgA72 of {
          Data.Complex.:+ ww1_sgA75 [Occ=Once] ww2_sgA76 [Occ=Once] ->
              case w2_sgA73 of {
                Data.Complex.:+ ww4_sgA78 [Occ=Once] ww5_sgA79 [Occ=Once] ->
                    case w_sgA71 ww1_sgA75 ww4_sgA78 of dt_sgA7a {
                      __DEFAULT ->
                          case w_sgA71 ww2_sgA76 ww5_sgA79 of dt1_sgA7b {
                            __DEFAULT -> Data.Complex.:+ [dt_sgA7a dt1_sgA7b];
                          };
                    };
              };
        };

Data.Complex.$fApplicativeComplex_$c<*>
  :: forall a b.
     Data.Complex.Complex (a -> b)
     -> Data.Complex.Complex a -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)C(S)),1*U(C1(U),C1(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgA7c ds1_sgA7d]
        case ds_sgA7c of {
          Data.Complex.:+ f_sgA7f [Occ=Once!] g_sgA7g [Occ=Once!] ->
              case ds1_sgA7d of {
                Data.Complex.:+ a1_sgA7i [Occ=Once] b1_sgA7j [Occ=Once] ->
                    case f_sgA7f a1_sgA7i of dt_sgA7k {
                      __DEFAULT ->
                          case g_sgA7g b1_sgA7j of dt1_sgA7l {
                            __DEFAULT -> Data.Complex.:+ [dt_sgA7k dt1_sgA7l];
                          };
                    };
              };
        };

Data.Complex.$fApplicativeComplex_$cpure
  :: forall a. a -> Data.Complex.Complex a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>m, Unf=OtherCon []] =
    [] \r [a1_sgA7m] Data.Complex.$W:+ a1_sgA7m a1_sgA7m;

Data.Complex.$fTraversableComplex_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Complex.Complex a -> f (Data.Complex.Complex b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgA7n f1_sgA7o ds_sgA7p]
        case ds_sgA7p of {
          Data.Complex.:+ a1_sgA7r [Occ=Once] a2_sgA7s [Occ=Once] ->
              let {
                sat_sgA7u [Occ=Once] :: f_agsK7 b_agsK9
                [LclId] =
                    [f1_sgA7o a2_sgA7s] \u [] f1_sgA7o a2_sgA7s; } in
              let {
                sat_sgA7t [Occ=Once] :: f_agsK7 b_agsK9
                [LclId] =
                    [f1_sgA7o a1_sgA7r] \u [] f1_sgA7o a1_sgA7r;
              } in 
                GHC.Base.liftA2
                    $dApplicative_sgA7n Data.Complex.$W:+ sat_sgA7t sat_sgA7u;
        };

Data.Complex.$fFoldableComplex_$cnull
  :: forall a. Data.Complex.Complex a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_sgA7v]
        case ds_sgA7v of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Complex.$fFoldableComplex_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgA7z z_sgA7A ds_sgA7B]
        case ds_sgA7B of {
          Data.Complex.:+ a1_sgA7D [Occ=Once] a2_sgA7E [Occ=Once] ->
              let {
                sat_sgA7F [Occ=Once] :: b_agsHZ
                [LclId] =
                    [f_sgA7z z_sgA7A a2_sgA7E] \u [] f_sgA7z a2_sgA7E z_sgA7A;
              } in  f_sgA7z a1_sgA7D sat_sgA7F;
        };

Data.Complex.$fFoldableComplex_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Complex.Complex a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgA7G f_sgA7H ds_sgA7I]
        case ds_sgA7I of {
          Data.Complex.:+ a1_sgA7K [Occ=Once] a2_sgA7L [Occ=Once] ->
              let {
                sat_sgA7N [Occ=Once] :: m_agsHO
                [LclId] =
                    [f_sgA7H a2_sgA7L] \u [] f_sgA7H a2_sgA7L; } in
              let {
                sat_sgA7M [Occ=Once] :: m_agsHO
                [LclId] =
                    [f_sgA7H a1_sgA7K] \u [] f_sgA7H a1_sgA7K;
              } in  GHC.Base.mappend $dMonoid_sgA7G sat_sgA7M sat_sgA7N;
        };

Data.Complex.$fFoldableComplex_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Complex.Complex m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgA7O ds_sgA7P]
        case ds_sgA7P of {
          Data.Complex.:+ a1_sgA7R [Occ=Once] a2_sgA7S [Occ=Once] ->
              GHC.Base.mappend $dMonoid_sgA7O a1_sgA7R a2_sgA7S;
        };

Data.Complex.$fFoldableComplex2
  :: forall a.
     GHC.Num.Num a =>
     Data.Complex.Complex a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgA7T ds_sgA7U]
        case ds_sgA7U of {
          Data.Complex.:+ a1_sgA7W [Occ=Once] a2_sgA7X [Occ=Once] ->
              GHC.Num.+ $dNum_sgA7T a1_sgA7W a2_sgA7X;
        };

Data.Complex.$fFoldableComplex_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sgA7Y x_sgA7Z]
        case x_sgA7Z of {
          Data.Complex.:+ a1_sgA81 a2_sgA82 ->
              case GHC.Classes.<= $dOrd_sgA7Y a1_sgA81 a2_sgA82 of {
                GHC.Types.False -> a2_sgA82;
                GHC.Types.True -> a1_sgA81;
              };
        };

Data.Complex.$fFoldableComplex_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sgA84 x_sgA85]
        case x_sgA85 of {
          Data.Complex.:+ a1_sgA87 a2_sgA88 ->
              case GHC.Classes.>= $dOrd_sgA84 a1_sgA87 a2_sgA88 of {
                GHC.Types.False -> a2_sgA88;
                GHC.Types.True -> a1_sgA87;
              };
        };

Data.Complex.$fFoldableComplex_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Complex.Complex a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sgA8a eta_sgA8b]
        let {
          f_sgA8c [Dmd=<L,C(U)>] :: a_agsJ9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgA8a eta_sgA8b] \u []
                  GHC.Classes.== $dEq_sgA8a eta_sgA8b; } in
        let {
          sat_sgA8i [Occ=Once]
            :: Data.Complex.Complex a_agsJ9 -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_sgA8c] \r [ds_sgA8d]
                  case ds_sgA8d of {
                    Data.Complex.:+ a1_sgA8f [Occ=Once] a2_sgA8g [Occ=Once] ->
                        case f_sgA8c a1_sgA8f of {
                          GHC.Types.False -> f_sgA8c a2_sgA8g;
                          GHC.Types.True -> GHC.Types.True [];
                        };
                  };
        } in  sat_sgA8i;

Data.Complex.$fFoldableComplex_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgA8j xs_sgA8k]
        case xs_sgA8k of {
          Data.Complex.:+ a1_sgA8m [Occ=Once] a2_sgA8n [Occ=Once] ->
              f_sgA8j a1_sgA8m a2_sgA8n;
        };

Data.Complex.$fFoldableComplex_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgA8o z0_sgA8p xs_sgA8q]
        case xs_sgA8q of {
          Data.Complex.:+ a1_sgA8s [Occ=Once] a2_sgA8t [Occ=Once] ->
              case f_sgA8o z0_sgA8p a1_sgA8s of vx_sgA8u {
                __DEFAULT -> f_sgA8o vx_sgA8u a2_sgA8t;
              };
        };

lvl_rgA6e :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

Data.Complex.$fFoldableComplex_$clength
  :: forall a. Data.Complex.Complex a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_sgA8v]
        case xs_sgA8v of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> lvl_rgA6e;
        };

Data.Complex.$fFoldableComplex_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgA8z z_sgA8A t1_sgA8B]
        case t1_sgA8B of {
          Data.Complex.:+ a1_sgA8D [Occ=Once] a2_sgA8E [Occ=Once] ->
              let {
                sat_sgA8F [Occ=Once] :: b_agsIe
                [LclId] =
                    [f_sgA8z z_sgA8A a1_sgA8D] \u [] f_sgA8z z_sgA8A a1_sgA8D;
              } in  f_sgA8z sat_sgA8F a2_sgA8E;
        };

Data.Complex.$fFoldableComplex_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgA8G z0_sgA8H xs_sgA8I]
        case xs_sgA8I of {
          Data.Complex.:+ a1_sgA8K [Occ=Once] a2_sgA8L [Occ=Once] ->
              case f_sgA8G a2_sgA8L z0_sgA8H of vx_sgA8M {
                __DEFAULT -> f_sgA8G a1_sgA8K vx_sgA8M;
              };
        };

Data.Complex.$fFoldableComplex1
  :: forall a.
     GHC.Num.Num a =>
     Data.Complex.Complex a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgA8N ds_sgA8O]
        case ds_sgA8O of {
          Data.Complex.:+ a1_sgA8Q [Occ=Once] a2_sgA8R [Occ=Once] ->
              GHC.Num.* $dNum_sgA8N a1_sgA8Q a2_sgA8R;
        };

Data.Complex.$fFoldableComplex_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Complex.Complex a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_sgA8S]
        case eta_sgA8S of {
          Data.Complex.:+ a1_sgA8U [Occ=Once] a2_sgA8V [Occ=Once] ->
              let {
                sat_sgA8W [Occ=Once] :: [a_agsIO]
                [LclId] =
                    CCCS :! [a2_sgA8V GHC.Types.[]];
              } in  : [a1_sgA8U sat_sgA8W];
        };

Data.Complex.$fFoldableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Complex.$fFoldableComplex_$cfold
                                             Data.Complex.$fFoldableComplex_$cfoldMap
                                             Data.Complex.$fFoldableComplex_$cfoldr
                                             Data.Complex.$fFoldableComplex_$cfoldr'
                                             Data.Complex.$fFoldableComplex_$cfoldl
                                             Data.Complex.$fFoldableComplex_$cfoldl'
                                             Data.Complex.$fFoldableComplex_$cfoldr1
                                             Data.Complex.$fFoldableComplex_$cfoldr1
                                             Data.Complex.$fFoldableComplex_$ctoList
                                             Data.Complex.$fFoldableComplex_$cnull
                                             Data.Complex.$fFoldableComplex_$clength
                                             Data.Complex.$fFoldableComplex_$celem
                                             Data.Complex.$fFoldableComplex_$cmaximum
                                             Data.Complex.$fFoldableComplex_$cminimum
                                             Data.Complex.$fFoldableComplex2
                                             Data.Complex.$fFoldableComplex1];

Data.Complex.$fFunctorComplex_$c<$
  :: forall a b.
     a -> Data.Complex.Complex b -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [z_sgA8X ds_sgA8Y]
        case ds_sgA8Y of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Complex.$W:+ z_sgA8X z_sgA8X;
        };

Data.Complex.$fFunctorComplex_$cfmap
  :: forall a b.
     (a -> b) -> Data.Complex.Complex a -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sgA92 ds_sgA93]
        case ds_sgA93 of {
          Data.Complex.:+ a1_sgA95 [Occ=Once] a2_sgA96 [Occ=Once] ->
              case f_sgA92 a1_sgA95 of dt_sgA97 {
                __DEFAULT ->
                    case f_sgA92 a2_sgA96 of dt1_sgA98 {
                      __DEFAULT -> Data.Complex.:+ [dt_sgA97 dt1_sgA98];
                    };
              };
        };

Data.Complex.$fFunctorComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Complex.$fFunctorComplex_$cfmap
                                       Data.Complex.$fFunctorComplex_$c<$];

Data.Complex.$fTraversableComplex_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Complex.Complex (f a) -> f (Data.Complex.Complex a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgA99 ds_sgA9a]
        case ds_sgA9a of {
          Data.Complex.:+ a1_sgA9c [Occ=Once] a2_sgA9d [Occ=Once] ->
              GHC.Base.liftA2
                  $dApplicative_sgA99 Data.Complex.$W:+ a1_sgA9c a2_sgA9d;
        };

Data.Complex.$fTraversableComplex_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Complex.Complex a -> m (Data.Complex.Complex b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgA9e eta_sgA9f eta1_sgA9g]
        case eta1_sgA9g of {
          Data.Complex.:+ a1_sgA9i [Occ=Once] a2_sgA9j [Occ=Once] ->
              let {
                sat_sgA9m [Occ=Once] :: m_agsKy b_agsKA
                [LclId] =
                    [eta_sgA9f a2_sgA9j] \u [] eta_sgA9f a2_sgA9j; } in
              let {
                sat_sgA9l [Occ=Once] :: m_agsKy b_agsKA
                [LclId] =
                    [eta_sgA9f a1_sgA9i] \u [] eta_sgA9f a1_sgA9i;
              } in 
                case GHC.Base.$p1Monad $dMonad_sgA9e of sat_sgA9k {
                  __DEFAULT ->
                      GHC.Base.liftA2 sat_sgA9k Data.Complex.$W:+ sat_sgA9l sat_sgA9m;
                };
        };

Data.Complex.$fTraversableComplex_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Complex.Complex (m a) -> m (Data.Complex.Complex a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgA9n eta_sgA9o]
        case eta_sgA9o of {
          Data.Complex.:+ a1_sgA9q [Occ=Once] a2_sgA9r [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sgA9n of sat_sgA9s {
                __DEFAULT ->
                    GHC.Base.liftA2 sat_sgA9s Data.Complex.$W:+ a1_sgA9q a2_sgA9r;
              };
        };

Data.Complex.$fTraversableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Complex.$fFunctorComplex
                                                   Data.Complex.$fFoldableComplex
                                                   Data.Complex.$fTraversableComplex_$ctraverse
                                                   Data.Complex.$fTraversableComplex_$csequenceA
                                                   Data.Complex.$fTraversableComplex_$cmapM
                                                   Data.Complex.$fTraversableComplex_$csequence];

Data.Complex.$fApplicativeComplex_$c*>
  :: forall a b.
     Data.Complex.Complex a
     -> Data.Complex.Complex b -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [a1_sgA9t a2_sgA9u]
        case a1_sgA9t of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> a2_sgA9u;
        };

Data.Complex.$fApplicativeComplex_$c<*
  :: forall a b.
     Data.Complex.Complex a
     -> Data.Complex.Complex b -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [ds_sgA9y ds1_sgA9z]
        case ds_sgA9y of wild_sgA9A {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] ->
              case ds1_sgA9z of {
                Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> wild_sgA9A;
              };
        };

Data.Complex.$fApplicativeComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Complex.$fFunctorComplex
                                           Data.Complex.$fApplicativeComplex_$cpure
                                           Data.Complex.$fApplicativeComplex_$c<*>
                                           Data.Complex.$fApplicativeComplex_$cliftA2
                                           Data.Complex.$fApplicativeComplex_$c*>
                                           Data.Complex.$fApplicativeComplex_$c<*];

Data.Complex.$fGeneric1Complex_$cto1
  :: forall a.
     GHC.Generics.Rep1 Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgA9G]
        case ds_sgA9G of {
          GHC.Generics.:*: ds1_sgA9I [Occ=Once] ds2_sgA9J [Occ=Once] ->
              Data.Complex.$W:+ ds1_sgA9I ds2_sgA9J;
        };

Data.Complex.$fGeneric1Complex1
  :: forall a.
     Data.Complex.Complex a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             ":+"
             ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
             'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.SourceStrict
                'GHC.Generics.DecidedStrict)
             GHC.Generics.Par1
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.SourceStrict
                                 'GHC.Generics.DecidedStrict)
                              GHC.Generics.Par1)
          a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_sgA9K]
        case x_sgA9K of {
          Data.Complex.:+ g1_sgA9M [Occ=Once] g2_sgA9N [Occ=Once] ->
              GHC.Generics.:*: [g1_sgA9M g2_sgA9N];
        };

Data.Complex.$fGeneric1Complex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Complex.$fGeneric1Complex1
                                            Data.Complex.$fGeneric1Complex_$cto1];

Data.Complex.$fGenericComplex_$cto
  :: forall a x.
     GHC.Generics.Rep (Data.Complex.Complex a) x
     -> Data.Complex.Complex a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgA9O]
        case ds_sgA9O of {
          GHC.Generics.:*: ds1_sgA9Q [Occ=Once] ds2_sgA9R [Occ=Once] ->
              Data.Complex.$W:+ ds1_sgA9Q ds2_sgA9R;
        };

Data.Complex.$fGenericComplex1
  :: forall a x.
     Data.Complex.Complex a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             ":+"
             ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
             'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.SourceStrict
                'GHC.Generics.DecidedStrict)
             (GHC.Generics.K1 GHC.Generics.R a)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.SourceStrict
                                 'GHC.Generics.DecidedStrict)
                              (GHC.Generics.K1 GHC.Generics.R a))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x1_sgA9S]
        case x1_sgA9S of {
          Data.Complex.:+ g1_sgA9U [Occ=Once] g2_sgA9V [Occ=Once] ->
              GHC.Generics.:*: [g1_sgA9U g2_sgA9V];
        };

Data.Complex.$fGenericComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Complex.Complex a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Complex.$fGenericComplex1
                                           Data.Complex.$fGenericComplex_$cto];

Data.Complex.$fDataComplex_$cgunfold
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dData_sgA9W k_sgA9X z_sgA9Y ds_sgA9Z]
        let {
          sat_sgAa1 [Occ=Once]
            :: c_agsBB (a_agsBe -> Data.Complex.Complex a_agsBe)
          [LclId] =
              [$dData_sgA9W k_sgA9X z_sgA9Y] \u []
                  let {
                    sat_sgAa0 [Occ=Once]
                      :: c_agsBB (a_agsBe -> a_agsBe -> Data.Complex.Complex a_agsBe)
                    [LclId] =
                        [z_sgA9Y] \u [] z_sgA9Y Data.Complex.$W:+;
                  } in  k_sgA9X $dData_sgA9W sat_sgAa0;
        } in  k_sgA9X $dData_sgA9W sat_sgAa1;

Data.Complex.$fDataComplex_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Complex.Complex a
     -> c (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgAa2 k_sgAa3 z_sgAa4 ds_sgAa5]
        case ds_sgAa5 of {
          Data.Complex.:+ a1_sgAa7 [Occ=Once] a2_sgAa8 [Occ=Once] ->
              let {
                sat_sgAaa [Occ=Once]
                  :: c_agsBn (a_agsBe -> Data.Complex.Complex a_agsBe)
                [LclId] =
                    [$dData_sgAa2 k_sgAa3 z_sgAa4 a1_sgAa7] \u []
                        let {
                          sat_sgAa9 [Occ=Once]
                            :: c_agsBn (a_agsBe -> a_agsBe -> Data.Complex.Complex a_agsBe)
                          [LclId] =
                              [z_sgAa4] \u [] z_sgAa4 Data.Complex.$W:+;
                        } in  k_sgAa3 $dData_sgAa2 sat_sgAa9 a1_sgAa7;
              } in  k_sgAa3 $dData_sgAa2 sat_sgAaa a2_sgAa8;
        };

Data.Complex.$fReadComplex5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [7#];

Data.Complex.$fReadComplex4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":+"#;

Data.Complex.$fReadComplex3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Complex.$fReadComplex4;

Data.Complex.$fReadComplex2 :: Text.Read.Lex.Lexeme
[GblId, Str=m5, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Symbol! [Data.Complex.$fReadComplex3];

Data.Complex.$fReadComplex1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Complex.Complex a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sgAab eta_sgAac eta1_sgAad]
        let {
          ds1_sgAae [Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_agsAr
          [LclId] =
              [$dRead_sgAab] \u []
                  GHC.Read.readPrec $dRead_sgAab Data.Complex.$fReadComplex5; } in
        let {
          sat_sgAat [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Complex.Complex a_agsAr)
          [LclId] =
              [ds1_sgAae] \r [c_sgAaf eta2_sgAag]
                  case c_sgAaf of {
                    GHC.Types.I# x_sgAai [Occ=Once] ->
                        case <=# [x_sgAai 6#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sgAas [Occ=Once]
                                  :: a_agsAr -> Text.ParserCombinators.ReadP.P b1_i815E
                                [LclId] =
                                    [ds1_sgAae eta2_sgAag] \r [a1_sgAak]
                                        let {
                                          sat_sgAap [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                          [LclId] =
                                              [ds1_sgAae eta2_sgAag a1_sgAak] \r [a2_sgAal]
                                                  let {
                                                    sat_sgAao [Occ=Once]
                                                      :: a_agsAr
                                                         -> Text.ParserCombinators.ReadP.P b1_i815E
                                                    [LclId] =
                                                        [eta2_sgAag a1_sgAak] \r [a3_sgAam]
                                                            let {
                                                              sat_sgAan [Occ=Once]
                                                                :: Data.Complex.Complex a_agsAr
                                                              [LclId] =
                                                                  [a1_sgAak a3_sgAam] \u []
                                                                      Data.Complex.$W:+
                                                                          a1_sgAak a3_sgAam;
                                                            } in  eta2_sgAag sat_sgAan;
                                                  } in  ds1_sgAae sat_sgAao;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Complex.$fReadComplex2 sat_sgAap
                                          of
                                          { Unit# ww1_sgAar [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sgAar];
                                          };
                              } in  ds1_sgAae sat_sgAas;
                        };
                  };
        } in  GHC.Read.list3 sat_sgAat eta_sgAac eta1_sgAad;

Data.Complex.$fReadComplex_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Complex.Complex a)
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sgAau n_sgAav]
        let {
          sat_sgAaw [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Complex.Complex a_XgsEB)
          [LclId] =
              [$dRead_sgAau n_sgAav] \u []
                  Data.Complex.$fReadComplex1
                      $dRead_sgAau
                      n_sgAav
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgAaw;

Data.Complex.$fReadComplex_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Complex.Complex a]
[GblId, Arity=1, Str=<L,U(A,A,C(C(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sgAax]
        let {
          sat_sgAay [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Complex.Complex a_XgsEz)
          [LclId] =
              [$dRead_sgAax] \r [eta_B2 eta_B1]
                  Data.Complex.$fReadComplex1 $dRead_sgAax eta_B2 eta_B1;
        } in  GHC.Read.list sat_sgAay;

Data.Complex.$fReadComplex_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Complex.Complex a]
[GblId, Arity=1, Str=<L,U(A,A,C(C(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sgAaz]
        let {
          sat_sgAaB [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Complex.Complex a_XgsEA]
          [LclId] =
              [$dRead_sgAaz] \u []
                  let {
                    sat_sgAaA [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Complex.Complex a_XgsEA)
                    [LclId] =
                        [$dRead_sgAaz] \r [eta_B2 eta_B1]
                            Data.Complex.$fReadComplex1 $dRead_sgAaz eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sgAaA
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgAaB;

Data.Complex.$fReadComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Complex.Complex a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C(U)),A)>m] =
    [] \r [$dRead_sgAaC]
        let {
          sat_sgAaG [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Complex.Complex a_XgsEy]
          [LclId] =
              [$dRead_sgAaC] \u []
                  Data.Complex.$fReadComplex_$creadListPrec $dRead_sgAaC; } in
        let {
          sat_sgAaF [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Complex.Complex a_XgsEy)
          [LclId] =
              [$dRead_sgAaC] \r [eta_B2 eta_B1]
                  Data.Complex.$fReadComplex1 $dRead_sgAaC eta_B2 eta_B1; } in
        let {
          sat_sgAaE [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Complex.Complex a_XgsEy]
          [LclId] =
              [$dRead_sgAaC] \u []
                  Data.Complex.$fReadComplex_$creadList $dRead_sgAaC; } in
        let {
          sat_sgAaD [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Complex.Complex a_XgsEy)
          [LclId] =
              [$dRead_sgAaC] \r [eta_B1]
                  Data.Complex.$fReadComplex_$creadsPrec $dRead_sgAaC eta_B1;
        } in  GHC.Read.C:Read [sat_sgAaD sat_sgAaE sat_sgAaF sat_sgAaG];

Data.Complex.$fShowComplex2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    " :+ "#;

Data.Complex.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> a -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAaH ww_sgAaI ww1_sgAaJ ww2_sgAaK]
        let {
          f_sgAaL [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sgAaH ww1_sgAaJ] \u []
                  GHC.Show.showsPrec
                      w_sgAaH Data.Complex.$fReadComplex5 ww1_sgAaJ; } in
        let {
          g_sgAaM [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sgAaH ww2_sgAaK] \u []
                  GHC.Show.showsPrec w_sgAaH Data.Complex.$fReadComplex5 ww2_sgAaK;
        } in 
          case >=# [ww_sgAaI 7#] of {
            __DEFAULT ->
                let {
                  sat_sgAaR [Occ=OnceT[0]] :: GHC.Base.String -> GHC.Base.String
                  [LclId] =
                      [f_sgAaL g_sgAaM] \r [x_sgAaO]
                          let {
                            sat_sgAaQ [Occ=Once] :: GHC.Base.String
                            [LclId] =
                                [g_sgAaM x_sgAaO] \u []
                                    let {
                                      sat_sgAaP [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sgAaM x_sgAaO] \u [] g_sgAaM x_sgAaO;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Complex.$fShowComplex2 sat_sgAaP;
                          } in  f_sgAaL sat_sgAaQ;
                } in  sat_sgAaR;
            1# ->
                let {
                  sat_sgAaX [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sgAaL g_sgAaM] \r [x_sgAaS]
                          let {
                            sat_sgAaW [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sgAaL g_sgAaM x_sgAaS] \u []
                                    let {
                                      sat_sgAaV [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          [g_sgAaM x_sgAaS] \u []
                                              let {
                                                sat_sgAaU [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sgAaM x_sgAaS] \u []
                                                        let {
                                                          sat_sgAaT [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sgAaS];
                                                        } in  g_sgAaM sat_sgAaT;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Complex.$fShowComplex2 sat_sgAaU;
                                    } in  f_sgAaL sat_sgAaV;
                          } in  : [GHC.Show.$fShow(,)4 sat_sgAaW];
                } in  sat_sgAaX;
          };

Data.Complex.$fShowComplex_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Complex.Complex a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAaY w1_sgAaZ w2_sgAb0]
        case w1_sgAaZ of {
          GHC.Types.I# ww1_sgAb2 [Occ=Once] ->
              case w2_sgAb0 of {
                Data.Complex.:+ ww3_sgAb4 [Occ=Once] ww4_sgAb5 [Occ=Once] ->
                    Data.Complex.$w$cshowsPrec w_sgAaY ww1_sgAb2 ww3_sgAb4 ww4_sgAb5;
              };
        };

Data.Complex.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Show.Show a => a -> a -> GHC.Base.String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAb6 ww_sgAb7 ww1_sgAb8]
        let {
          sat_sgAba [Occ=Once] :: GHC.Base.String
          [LclId] =
              [w_sgAb6 ww1_sgAb8] \u []
                  let {
                    sat_sgAb9 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [w_sgAb6 ww1_sgAb8] \u []
                            GHC.Show.showsPrec
                                w_sgAb6 Data.Complex.$fReadComplex5 ww1_sgAb8 GHC.Types.[];
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Complex.$fShowComplex2 sat_sgAb9;
        } in 
          GHC.Show.showsPrec
              w_sgAb6 Data.Complex.$fReadComplex5 ww_sgAb7 sat_sgAba;

Data.Complex.$fShowComplex_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     Data.Complex.Complex a -> GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAbb w1_sgAbc]
        case w1_sgAbc of {
          Data.Complex.:+ ww1_sgAbe [Occ=Once] ww2_sgAbf [Occ=Once] ->
              Data.Complex.$w$cshow w_sgAbb ww1_sgAbe ww2_sgAbf;
        };

Data.Complex.$fShowComplex1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Complex.$fShowComplex_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Complex.Complex a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sgAbg ls_sgAbh s_sgAbi]
        let {
          sat_sgAbn [Occ=Once]
            :: Data.Complex.Complex a_agszX -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgAbg] \r [w_sgAbj]
                  case w_sgAbj of {
                    Data.Complex.:+ ww1_sgAbl [Occ=Once] ww2_sgAbm [Occ=Once] ->
                        Data.Complex.$w$cshowsPrec $dShow_sgAbg 0# ww1_sgAbl ww2_sgAbm;
                  };
        } in  GHC.Show.showList__ sat_sgAbn ls_sgAbh s_sgAbi;

Data.Complex.$fShowComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sgAbo]
        let {
          sat_sgAbr [Occ=Once]
            :: [Data.Complex.Complex a_agszX] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgAbo] \r [eta_B2 eta_B1]
                  Data.Complex.$fShowComplex_$cshowList
                      $dShow_sgAbo eta_B2 eta_B1; } in
        let {
          sat_sgAbq [Occ=Once]
            :: Data.Complex.Complex a_agszX -> GHC.Base.String
          [LclId] =
              [$dShow_sgAbo] \r [eta_B1]
                  Data.Complex.$fShowComplex_$cshow $dShow_sgAbo eta_B1; } in
        let {
          sat_sgAbp [Occ=Once]
            :: GHC.Types.Int -> Data.Complex.Complex a_agszX -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgAbo] \r [eta_B2 eta_B1]
                  Data.Complex.$fShowComplex_$cshowsPrec $dShow_sgAbo eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgAbp sat_sgAbq sat_sgAbr];

Data.Complex.$fEqComplex_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Complex.Complex a -> Data.Complex.Complex a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAbs w1_sgAbt w2_sgAbu]
        case w1_sgAbt of {
          Data.Complex.:+ ww1_sgAbw [Occ=Once] ww2_sgAbx [Occ=Once] ->
              case w2_sgAbu of {
                Data.Complex.:+ ww4_sgAbz [Occ=Once] ww5_sgAbA [Occ=Once] ->
                    case GHC.Classes.== w_sgAbs ww1_sgAbw ww4_sgAbz of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> GHC.Classes.== w_sgAbs ww2_sgAbx ww5_sgAbA;
                    };
              };
        };

Data.Complex.$fEqComplex_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Complex.Complex a -> Data.Complex.Complex a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sgAbC eta_sgAbD eta1_sgAbE]
        case eta_sgAbD of {
          Data.Complex.:+ ww1_sgAbG [Occ=Once] ww2_sgAbH [Occ=Once] ->
              case eta1_sgAbE of {
                Data.Complex.:+ ww4_sgAbJ [Occ=Once] ww5_sgAbK [Occ=Once] ->
                    case GHC.Classes.== $dEq_sgAbC ww1_sgAbG ww4_sgAbJ of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True ->
                          case GHC.Classes.== $dEq_sgAbC ww2_sgAbH ww5_sgAbK of {
                            GHC.Types.False -> GHC.Types.True [];
                            GHC.Types.True -> GHC.Types.False [];
                          };
                    };
              };
        };

Data.Complex.$fEqComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Complex.Complex a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sgAbN]
        let {
          sat_sgAbP [Occ=Once]
            :: Data.Complex.Complex a_agszG
               -> Data.Complex.Complex a_agszG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgAbN] \r [eta_B2 eta_B1]
                  Data.Complex.$fEqComplex_$c/= $dEq_sgAbN eta_B2 eta_B1; } in
        let {
          sat_sgAbO [Occ=Once]
            :: Data.Complex.Complex a_agszG
               -> Data.Complex.Complex a_agszG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgAbN] \r [eta_B2 eta_B1]
                  Data.Complex.$fEqComplex_$c== $dEq_sgAbN eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sgAbO sat_sgAbP];

Data.Complex.realPart :: forall a. Data.Complex.Complex a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_sgAbQ]
        case ds_sgAbQ of {
          Data.Complex.:+ x_sgAbS [Occ=Once] _ [Occ=Dead] -> x_sgAbS;
        };

Data.Complex.$fStorableComplex_$csizeOf
  :: forall a.
     Foreign.Storable.Storable a =>
     Data.Complex.Complex a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S(S))LLLLLLL),1*U(1*C1(U(U)),A,A,A,A,A,A,A)><L,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgAbU a1_sgAbV]
        let {
          sat_sgAbZ [Occ=Once] :: a_XgsQG
          [LclId] =
              [a1_sgAbV] \u []
                  case a1_sgAbV of {
                    Data.Complex.:+ x_sgAbX [Occ=Once] _ [Occ=Dead] -> x_sgAbX;
                  };
        } in 
          case Foreign.Storable.sizeOf $dStorable_sgAbU sat_sgAbZ of {
            GHC.Types.I# y_sgAc1 [Occ=Once] ->
                case *# [2# y_sgAc1] of sat_sgAc2 {
                  __DEFAULT -> GHC.Types.I# [sat_sgAc2];
                };
          };

Data.Complex.$fStorableComplex_$calignment
  :: forall a.
     Foreign.Storable.Storable a =>
     Data.Complex.Complex a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLLLL),1*U(A,1*C1(U(U)),A,A,A,A,A,A)><L,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgAc3 a1_sgAc4]
        let {
          sat_sgAc8 [Occ=Once] :: a_XgsQH
          [LclId] =
              [a1_sgAc4] \u []
                  case a1_sgAc4 of {
                    Data.Complex.:+ x_sgAc6 [Occ=Once] _ [Occ=Dead] -> x_sgAc6;
                  };
        } in  Foreign.Storable.alignment $dStorable_sgAc3 sat_sgAc8;

Data.Complex.$fStorableComplex5
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Complex.Complex a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgAc9 ptr_sgAca off_sgAcb eta_sgAcc]
        let {
          sat_sgAci [Occ=Once] :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQL)
          [LclId] =
              [ptr_sgAca off_sgAcb] \u []
                  case ptr_sgAca of {
                    GHC.Ptr.Ptr addr_sgAce [Occ=Once] ->
                        case off_sgAcb of {
                          GHC.Types.I# d_sgAcg [Occ=Once] ->
                              case plusAddr# [addr_sgAce d_sgAcg] of sat_sgAch {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_sgAch];
                              };
                        };
                  };
        } in 
          Data.Complex.$fStorableComplex3
              $dStorable_sgAc9 sat_sgAci eta_sgAcc;

lvl1_rgA6f :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "undefined"#;

lvl2_rgA6g :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl1_rgA6f;

Data.Complex.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl3_rgA6h :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Complex.$trModule4;

lvl4_rgA6i :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Foreign.Storable"#;

lvl5_rgA6j :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_rgA6i;

lvl6_rgA6k :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Foreign/Storable.hs"#;

lvl7_rgA6l :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl6_rgA6k;

lvl8_rgA6m :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [137#];

lvl9_rgA6n :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [31#];

lvl10_rgA6o :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [40#];

lvl11_rgA6p :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl3_rgA6h
                                           lvl5_rgA6j
                                           lvl7_rgA6l
                                           lvl8_rgA6m
                                           lvl9_rgA6n
                                           lvl8_rgA6m
                                           lvl10_rgA6o];

lvl12_rgA6q :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl2_rgA6g
                                                  lvl11_rgA6p
                                                  GHC.Stack.Types.EmptyCallStack];

Data.Complex.$fStorableComplex8 :: forall a. Data.Complex.Complex a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl12_rgA6q;

Data.Complex.$fStorableComplex7
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Complex.Complex a #)
[GblId,
 Arity=4,
 Str=<S(LLLLLLC(C(S(SL)))L),U(1*C1(U(U)),A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgAcj ptr_sgAck off_sgAcl eta_sgAcm]
        let {
          sat_sgAcx [Occ=Once] :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQM)
          [LclId] =
              [$dStorable_sgAcj ptr_sgAck off_sgAcl] \u []
                  case ptr_sgAck of {
                    GHC.Ptr.Ptr addr_sgAco [Occ=Once] ->
                        case off_sgAcl of {
                          GHC.Types.I# x_sgAcq [Occ=Once] ->
                              case
                                  Foreign.Storable.sizeOf
                                      $dStorable_sgAcj Data.Complex.$fStorableComplex8
                              of
                              { GHC.Types.I# y_sgAct [Occ=Once] ->
                                    case *# [2# y_sgAct] of sat_sgAcu {
                                      __DEFAULT ->
                                          case *# [x_sgAcq sat_sgAcu] of sat_sgAcv {
                                            __DEFAULT ->
                                                case plusAddr# [addr_sgAco sat_sgAcv] of sat_sgAcw {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_sgAcw];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          Data.Complex.$fStorableComplex3
              $dStorable_sgAcj sat_sgAcx eta_sgAcm;

Data.Complex.$fStorableComplex4
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> Data.Complex.Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgAcy ptr_sgAcz off_sgAcA eta_sgAcB eta1_sgAcC]
        case eta_sgAcB of {
          Data.Complex.:+ ww1_sgAcE [Occ=Once] ww2_sgAcF [Occ=Once] ->
              let {
                w_sgAcG :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQJ)
                [LclId] =
                    [ptr_sgAcz off_sgAcA] \u []
                        case ptr_sgAcz of {
                          GHC.Ptr.Ptr addr_sgAcI [Occ=Once] ->
                              case off_sgAcA of {
                                GHC.Types.I# d_sgAcK [Occ=Once] ->
                                    case plusAddr# [addr_sgAcI d_sgAcK] of sat_sgAcL {
                                      __DEFAULT -> GHC.Ptr.Ptr [sat_sgAcL];
                                    };
                              };
                        };
              } in 
                case
                    Foreign.Storable.poke $dStorable_sgAcy w_sgAcG ww1_sgAcE eta1_sgAcC
                of
                { (#,#) ipv_sgAcN [Occ=Once] _ [Occ=Dead] ->
                      Foreign.Storable.pokeElemOff
                          $dStorable_sgAcy
                          w_sgAcG
                          Data.Complex.$fStorableComplex2
                          ww2_sgAcF
                          ipv_sgAcN;
                };
        };

Data.Complex.$w$cpokeElemOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Types.Int
     -> a
     -> a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(1*C1(U(U)),A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAcP w1_sgAcQ w2_sgAcR ww_sgAcS ww1_sgAcT w3_sgAcU]
        let {
          w4_sgAcV :: GHC.Ptr.Ptr (Data.Complex.Complex a_sgxtm)
          [LclId] =
              [w_sgAcP w1_sgAcQ w2_sgAcR ww_sgAcS] \u []
                  case w1_sgAcQ of {
                    GHC.Ptr.Ptr addr_sgAcX [Occ=Once] ->
                        case w2_sgAcR of {
                          GHC.Types.I# x_sgAcZ [Occ=Once] ->
                              case Foreign.Storable.sizeOf w_sgAcP ww_sgAcS of {
                                GHC.Types.I# y_sgAd1 [Occ=Once] ->
                                    case *# [2# y_sgAd1] of sat_sgAd2 {
                                      __DEFAULT ->
                                          case *# [x_sgAcZ sat_sgAd2] of sat_sgAd3 {
                                            __DEFAULT ->
                                                case plusAddr# [addr_sgAcX sat_sgAd3] of sat_sgAd4 {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_sgAd4];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case Foreign.Storable.poke w_sgAcP w4_sgAcV ww_sgAcS w3_sgAcU of {
            (#,#) ipv_sgAd6 [Occ=Once] _ [Occ=Dead] ->
                Foreign.Storable.pokeElemOff
                    w_sgAcP
                    w4_sgAcV
                    Data.Complex.$fStorableComplex2
                    ww1_sgAcT
                    ipv_sgAd6;
          };

Data.Complex.$fStorableComplex6 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Types.Int
     -> Data.Complex.Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(C(U(U)),A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAd8 w1_sgAd9 w2_sgAda w3_sgAdb w4_sgAdc]
        case w3_sgAdb of {
          Data.Complex.:+ ww1_sgAde [Occ=Once] ww2_sgAdf [Occ=Once] ->
              Data.Complex.$w$cpokeElemOff
                  w_sgAd8 w1_sgAd9 w2_sgAda ww1_sgAde ww2_sgAdf w4_sgAdc;
        };

Data.Complex.$fStorableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Foreign.Storable.Storable a =>
     Foreign.Storable.Storable (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(U(U)),C(U(U)),C(C1(C1(U(U,U)))),C(C1(C1(C1(U(U,U))))),A,A,C(C1(U(U,U))),C(C1(C1(U(U,A)))))>m] =
    [] \r [$dStorable_sgAdg]
        let {
          sat_sgAdo [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> Data.Complex.Complex a_XgsQI -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fStorableComplex1
                      $dStorable_sgAdg eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAdn [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> GHC.Types.IO (Data.Complex.Complex a_XgsQI)
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B2 eta_B1]
                  Data.Complex.$fStorableComplex3
                      $dStorable_sgAdg eta_B2 eta_B1; } in
        let {
          sat_sgAdm [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> Data.Complex.Complex a_XgsQI -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fStorableComplex4
                      $dStorable_sgAdg eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAdl [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> GHC.Types.IO (Data.Complex.Complex a_XgsQI)
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fStorableComplex5
                      $dStorable_sgAdg eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAdk [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> GHC.Types.Int -> Data.Complex.Complex a_XgsQI -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fStorableComplex6
                      $dStorable_sgAdg eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAdj [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> GHC.Types.Int -> GHC.Types.IO (Data.Complex.Complex a_XgsQI)
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fStorableComplex7
                      $dStorable_sgAdg eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAdi [Occ=Once]
            :: Data.Complex.Complex a_XgsQI -> GHC.Types.Int
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B1]
                  Data.Complex.$fStorableComplex_$calignment
                      $dStorable_sgAdg eta_B1; } in
        let {
          sat_sgAdh [Occ=Once]
            :: Data.Complex.Complex a_XgsQI -> GHC.Types.Int
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B1]
                  Data.Complex.$fStorableComplex_$csizeOf $dStorable_sgAdg eta_B1;
        } in 
          Foreign.Storable.C:Storable [sat_sgAdh
                                       sat_sgAdi
                                       sat_sgAdj
                                       sat_sgAdk
                                       sat_sgAdl
                                       sat_sgAdm
                                       sat_sgAdn
                                       sat_sgAdo];

Data.Complex.imagPart :: forall a. Data.Complex.Complex a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgAdp]
        case ds_sgAdp of {
          Data.Complex.:+ _ [Occ=Dead] y_sgAds [Occ=Once] -> y_sgAds;
        };

Data.Complex.$fMonadComplex_$c>>=
  :: forall a b.
     Data.Complex.Complex a
     -> (a -> Data.Complex.Complex b) -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><C(S(SS)),C(U(U,U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAdt f_sgAdu]
        case ds_sgAdt of {
          Data.Complex.:+ a1_sgAdw [Occ=Once] b1_sgAdx [Occ=Once] ->
              case f_sgAdu a1_sgAdw of {
                Data.Complex.:+ x_sgAdz [Occ=Once] _ [Occ=Dead] ->
                    case f_sgAdu b1_sgAdx of {
                      Data.Complex.:+ _ [Occ=Dead] y_sgAdD [Occ=Once] ->
                          Data.Complex.:+ [x_sgAdz y_sgAdD];
                    };
              };
        };

Data.Complex.$fMonadComplex_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Complex.Complex a
     -> Data.Complex.Complex b -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Complex.$fApplicativeComplex_$c*> eta_B2 eta_B1;

lvl13_rgA6r :: forall a. [GHC.Types.Char] -> Data.Complex.Complex a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sgAdE] GHC.Err.errorWithoutStackTrace eta_sgAdE;

Data.Complex.$fMonadComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Complex.Complex
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Complex.$fApplicativeComplex
                                     Data.Complex.$fMonadComplex_$c>>=
                                     Data.Complex.$fMonadComplex_$c>>
                                     Data.Complex.$fApplicativeComplex_$cpure
                                     lvl13_rgA6r];

Data.Complex.$fDataComplex6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Complex"#;

Data.Complex.$fDataComplex9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Complex.$fDataComplex6;

go61_rgA6s
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgAdF _ys_sgAdG]
        case ds2_sgAdF of {
          [] -> GHC.List.badHead;
          : ipv_sgAdI [Occ=Once!] ipv1_sgAdJ [Occ=Once] ->
              case _ys_sgAdG of {
                [] -> GHC.List.badHead;
                : ipv2_sgAdL [Occ=Once] ipv3_sgAdM [Occ=Once] ->
                    case ipv_sgAdI of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgAdP [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sgAdP Data.Complex.$fReadComplex3 of {
                            GHC.Types.False -> go61_rgA6s ipv1_sgAdJ ipv3_sgAdM;
                            GHC.Types.True -> ipv2_sgAdL;
                          };
                    };
              };
        };

$c:+1_rgA6t :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$c:+2_rgA6u];
Data.Complex.$fDataComplex8 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Complex.$c:+ GHC.Types.[]];
Data.Complex.$fDataComplex7 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Complex.$fDataComplex8];
Data.Complex.$tComplex :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Complex.$fDataComplex9
                                       Data.Complex.$fDataComplex7];
Data.Complex.$c:+ [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$c:+1_rgA6t
                                     Data.Complex.$fReadComplex3
                                     GHC.Types.[]
                                     Data.Data.Infix
                                     Data.Complex.$tComplex];
$c:+2_rgA6u :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rgA6s Data.Complex.$fDataComplex8 Data.Data.mkConstr1;

Data.Complex.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$trModule4];

Data.Complex.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Complex"#;

Data.Complex.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$trModule2];

Data.Complex.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Complex.$trModule3
                                     Data.Complex.$trModule1];

$krep_rgA6v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Complex.$fDataComplex5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$fDataComplex6];

Data.Complex.$tcComplex :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1343342814679332338##
                                    7004386227939987578##
                                    Data.Complex.$trModule
                                    Data.Complex.$fDataComplex5
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep1_rgA6w :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgA6v GHC.Types.[]];

$krep2_rgA6x :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Complex.$tcComplex
                                              $krep1_rgA6w];

$krep3_rgA6y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgA6v $krep2_rgA6x];

Data.Complex.$tc':+1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgA6v $krep3_rgA6y];

Data.Complex.$tc':+3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "':+"#;

Data.Complex.$tc':+2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$tc':+3];

Data.Complex.$tc':+ :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6922641126191179007##
                                    8119904032930905711##
                                    Data.Complex.$trModule
                                    Data.Complex.$tc':+2
                                    1#
                                    Data.Complex.$tc':+1];

Data.Complex.$fDataComplex4
  :: Data.Typeable.Internal.TypeRep Data.Complex.Complex
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                1343342814679332338##
                7004386227939987578##
                Data.Complex.$trModule
                Data.Complex.$fDataComplex5
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sgAdV [Occ=Once]
                   ww9_sgAdW [Occ=Once]
                   ww10_sgAdX [Occ=Once]
                   ww11_sgAdY [Occ=Once]
                   ww12_sgAdZ [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sgAdV
                                              ww9_sgAdW
                                              ww10_sgAdX
                                              ww11_sgAdY
                                              ww12_sgAdZ];
        };

Data.Complex.$fDataComplex10
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Complex.Complex a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgAe0]
        case Data.Data.$p1Data $dData_sgAe0 of sat_sgAe1 {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Complex.$fDataComplex4 sat_sgAe1;
        };

Data.Complex.$fDataComplex_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Complex.Complex a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sgAe2 $dTypeable_sgAe3]
        let {
          lvl17_sgAe4 [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sgAe3] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sgAe3 Data.Complex.$fDataComplex4; } in
        let {
          sat_sgAe8 [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_agsBY (t_agsBX d))
               -> GHC.Base.Maybe (c_agsBY (Data.Complex.Complex a_XgsGb))
          [LclId] =
              [$dData_sgAe2 lvl17_sgAe4] \r [f_sgAe5]
                  case lvl17_sgAe4 of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sgAe7 [Occ=Once] :: c_agsBY (Data.Complex.Complex a_XgsGb)
                          [LclId] =
                              [$dData_sgAe2 f_sgAe5] \u [] f_sgAe5 $dData_sgAe2;
                        } in  GHC.Base.Just [sat_sgAe7];
                  };
        } in  sat_sgAe8;

Data.Complex.$fDataComplex1
  :: forall a. (a -> a -> Data.Complex.Complex a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Complex.$W:+ GHC.Types.False];

Data.Complex.$fDataComplex_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Complex.Complex a -> m (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgAe9 $dMonadPlus_sgAea ds_sgAeb eta_sgAec]
        let {
          lvl17_sgAed [Occ=OnceL] :: m_agsE3 (Data.Complex.Complex a_XgsGk)
          [LclId] =
              [$dMonadPlus_sgAea] \u [] GHC.Base.mzero $dMonadPlus_sgAea;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sgAea
          of
          $dMonad_sgAee [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgAeI [Occ=Once]
                    :: (Data.Complex.Complex a_XgsGk, GHC.Types.Bool)
                       -> m_agsE3 (Data.Complex.Complex a_XgsGk)
                  [LclId] =
                      [lvl17_sgAed $dMonad_sgAee] \r [ds1_sgAeD]
                          case ds1_sgAeD of {
                            (,) x'_sgAeF [Occ=Once] b_sgAeG [Occ=Once!] ->
                                case b_sgAeG of {
                                  GHC.Types.False -> lvl17_sgAed;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgAee x'_sgAeF;
                                };
                          }; } in
                let {
                  sat_sgAeC [Occ=Once]
                    :: m_agsE3 (Data.Complex.Complex a_XgsGk, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sgAe9
                       $dMonadPlus_sgAea
                       ds_sgAeb
                       eta_sgAec
                       $dMonad_sgAee] \u []
                          case eta_sgAec of {
                            Data.Complex.:+ a1_sgAeg [Occ=Once] a2_sgAeh [Occ=Once] ->
                                let {
                                  k_sgAei [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_agsE3 (d -> b)
                                       -> d -> m_agsE3 (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sgAea
                                                ds_sgAeb
                                                $dMonad_sgAee] \r [$dData1_sgAej ds1_sgAek y_sgAel]
                                          let {
                                            lvl18_sgAem [Occ=OnceL] :: m_agsE3 d_ae2Ws
                                            [LclId] =
                                                [ds_sgAeb $dData1_sgAej y_sgAel] \u []
                                                    ds_sgAeb $dData1_sgAej y_sgAel; } in
                                          let {
                                            sat_sgAez [Occ=Once]
                                              :: (d_ae2Ws -> b_ae2Wt, GHC.Types.Bool)
                                                 -> m_agsE3 (b_ae2Wt, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sgAea
                                                 $dMonad_sgAee
                                                 y_sgAel
                                                 lvl18_sgAem] \r [ds2_sgAen]
                                                    case ds2_sgAen of {
                                                      (,) h_sgAep b1_sgAeq [Occ=Once] ->
                                                          let {
                                                            sat_sgAey [Occ=Once]
                                                              :: m_agsE3 (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgAee
                                                                 y_sgAel
                                                                 h_sgAep
                                                                 b1_sgAeq] \u []
                                                                    let {
                                                                      sat_sgAew [Occ=Once]
                                                                        :: b_ae2Wt
                                                                      [LclId] =
                                                                          [y_sgAel h_sgAep] \u []
                                                                              h_sgAep y_sgAel; } in
                                                                    let {
                                                                      sat_sgAex [Occ=Once]
                                                                        :: (b_ae2Wt, GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sgAew
                                                                                     b1_sgAeq];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sgAee
                                                                          sat_sgAex; } in
                                                          let {
                                                            sat_sgAev [Occ=Once]
                                                              :: m_agsE3 (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgAee
                                                                 lvl18_sgAem
                                                                 h_sgAep] \u []
                                                                    let {
                                                                      sat_sgAeu [Occ=Once]
                                                                        :: d_ae2Ws
                                                                           -> m_agsE3 (b_ae2Wt,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sgAee
                                                                           h_sgAep] \r [y'_sgAer]
                                                                              let {
                                                                                sat_sgAes [Occ=Once]
                                                                                  :: b_ae2Wt
                                                                                [LclId] =
                                                                                    [h_sgAep
                                                                                     y'_sgAer] \u []
                                                                                        h_sgAep
                                                                                            y'_sgAer; } in
                                                                              let {
                                                                                sat_sgAet [Occ=Once]
                                                                                  :: (b_ae2Wt,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sgAes
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sgAee
                                                                                    sat_sgAet;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sgAee
                                                                          lvl18_sgAem
                                                                          sat_sgAeu;
                                                          } in 
                                                            GHC.Base.mplus
                                                                $dMonadPlus_sgAea
                                                                sat_sgAev
                                                                sat_sgAey;
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sgAee ds1_sgAek sat_sgAez; } in
                                let {
                                  sat_sgAeB [Occ=Once]
                                    :: Data.Data.Mp
                                         m_agsE3 (a_XgsGk -> Data.Complex.Complex a_XgsGk)
                                  [LclId] =
                                      [$dData_sgAe9 $dMonad_sgAee a1_sgAeg k_sgAei] \u []
                                          let {
                                            sat_sgAeA [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_agsE3
                                                   (a_XgsGk
                                                    -> a_XgsGk -> Data.Complex.Complex a_XgsGk)
                                            [LclId] =
                                                [$dMonad_sgAee] \u []
                                                    GHC.Base.return
                                                        $dMonad_sgAee Data.Complex.$fDataComplex1;
                                          } in  k_sgAei $dData_sgAe9 sat_sgAeA a1_sgAeg;
                                } in  k_sgAei $dData_sgAe9 sat_sgAeB a2_sgAeh;
                          };
                } in  GHC.Base.>>= $dMonad_sgAee sat_sgAeC sat_sgAeI;
          };

Data.Complex.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> a -> a -> m (Data.Complex.Complex a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAeJ w1_sgAeK w2_sgAeL ww_sgAeM ww1_sgAeN]
        let {
          k_sgAeO [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
            :: forall d b.
               Data.Data.Data d =>
               m_sgxtX (d -> b) -> d -> m_sgxtX b
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w1_sgAeK w2_sgAeL] \r [$dData1_sgAeP c_sgAeQ x_sgAeR]
                  let {
                    lvl17_sgAeS [Occ=OnceL] :: m_sgxtX d_ae2Vh
                    [LclId] =
                        [w2_sgAeL $dData1_sgAeP x_sgAeR] \u []
                            w2_sgAeL $dData1_sgAeP x_sgAeR; } in
                  let {
                    sat_sgAeX [Occ=Once] :: (d_ae2Vh -> b_ae2Vi) -> m_sgxtX b_ae2Vi
                    [LclId] =
                        [w1_sgAeK lvl17_sgAeS] \r [c'_sgAeT]
                            let {
                              sat_sgAeW [Occ=Once] :: d_ae2Vh -> m_sgxtX b_ae2Vi
                              [LclId] =
                                  [w1_sgAeK c'_sgAeT] \r [x'_sgAeU]
                                      let {
                                        sat_sgAeV [Occ=Once] :: b_ae2Vi
                                        [LclId] =
                                            [c'_sgAeT x'_sgAeU] \u [] c'_sgAeT x'_sgAeU;
                                      } in  GHC.Base.return w1_sgAeK sat_sgAeV;
                            } in  GHC.Base.>>= w1_sgAeK lvl17_sgAeS sat_sgAeW;
                  } in  GHC.Base.>>= w1_sgAeK c_sgAeQ sat_sgAeX; } in
        let {
          sat_sgAeZ [Occ=Once]
            :: m_sgxtX (a_sgxtV -> Data.Complex.Complex a_sgxtV)
          [LclId] =
              [w_sgAeJ w1_sgAeK ww_sgAeM k_sgAeO] \u []
                  let {
                    sat_sgAeY [Occ=Once]
                      :: m_sgxtX (a_sgxtV -> a_sgxtV -> Data.Complex.Complex a_sgxtV)
                    [LclId] =
                        [w1_sgAeK] \u [] GHC.Base.return w1_sgAeK Data.Complex.$W:+;
                  } in  k_sgAeO w_sgAeJ sat_sgAeY ww_sgAeM;
        } in  k_sgAeO w_sgAeJ sat_sgAeZ ww1_sgAeN;

Data.Complex.$fDataComplex_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Complex.Complex a -> m (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAf0 w1_sgAf1 w2_sgAf2 w3_sgAf3]
        case w3_sgAf3 of {
          Data.Complex.:+ ww1_sgAf5 [Occ=Once] ww2_sgAf6 [Occ=Once] ->
              Data.Complex.$w$cgmapM
                  w_sgAf0 w1_sgAf1 w2_sgAf2 ww1_sgAf5 ww2_sgAf6;
        };

Data.Complex.$fDataComplex_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Complex.Complex a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgAf7 ds_sgAf8 ds1_sgAf9 x_sgAfa]
        case x_sgAfa of {
          Data.Complex.:+ a1_sgAfc [Occ=Once] a2_sgAfd [Occ=Once] ->
              case ds_sgAf8 of {
                GHC.Types.I# x1_sgAff [Occ=Once!] ->
                    case x1_sgAff of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sgAf9 $dData_sgAf7 a1_sgAfc;
                      1# -> ds1_sgAf9 $dData_sgAf7 a2_sgAfd;
                    };
              };
        };

Data.Complex.$fDataComplex_$cgmapQr [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Complex.Complex a
     -> r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAfh w1_sgAfi w2_sgAfj w3_sgAfk w4_sgAfl]
        case w4_sgAfl of {
          Data.Complex.:+ ww1_sgAfn [Occ=Once] ww2_sgAfo [Occ=Once] ->
              let {
                sat_sgAfr [Occ=Once] :: r_sgxu9
                [LclId] =
                    [w_sgAfh w1_sgAfi w2_sgAfj w3_sgAfk ww2_sgAfo] \u []
                        let {
                          sat_sgAfq [Occ=Once] :: r'_sgxua
                          [LclId] =
                              [w_sgAfh w3_sgAfk ww2_sgAfo] \u [] w3_sgAfk w_sgAfh ww2_sgAfo;
                        } in  w1_sgAfi sat_sgAfq w2_sgAfj; } in
              let {
                sat_sgAfp [Occ=Once] :: r'_sgxua
                [LclId] =
                    [w_sgAfh w3_sgAfk ww1_sgAfn] \u [] w3_sgAfk w_sgAfh ww1_sgAfn;
              } in  w1_sgAfi sat_sgAfp sat_sgAfr;
        };

Data.Complex.$fDataComplex_$cgmapQ
  :: forall a.
     Data.Data.Data a =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Complex.Complex a -> [u]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,C(C1(U))><S(SS),1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [$dData_sgAfs ds_sgAft x0_sgAfu]
        case x0_sgAfu of {
          Data.Complex.:+ a1_sgAfw [Occ=Once] a2_sgAfx [Occ=Once] ->
              let {
                sat_sgAfz [Occ=Once] :: u_agsDl
                [LclId] =
                    [$dData_sgAfs ds_sgAft a2_sgAfx] \u []
                        ds_sgAft $dData_sgAfs a2_sgAfx; } in
              let {
                sat_sgAfA [Occ=Once] :: [u_agsDl]
                [LclId] =
                    CCCS :! [sat_sgAfz GHC.Types.[]]; } in
              let {
                sat_sgAfy [Occ=Once] :: u_agsDl
                [LclId] =
                    [$dData_sgAfs ds_sgAft a1_sgAfw] \u []
                        ds_sgAft $dData_sgAfs a1_sgAfw;
              } in  : [sat_sgAfy sat_sgAfA];
        };

Data.Complex.$fDataComplex2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Complex.Complex a
     -> Data.Functor.Const.Const r (Data.Complex.Complex a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAfB w1_sgAfC w2_sgAfD w3_sgAfE w4_sgAfF]
        case w4_sgAfF of {
          Data.Complex.:+ ww1_sgAfH [Occ=Once] ww2_sgAfI [Occ=Once] ->
              let {
                sat_sgAfL [Occ=Once] :: r'_XgxE2
                [LclId] =
                    [w_sgAfB w3_sgAfE ww2_sgAfI] \u [] w3_sgAfE w_sgAfB ww2_sgAfI; } in
              let {
                sat_sgAfK [Occ=Once] :: r_XgxE0
                [LclId] =
                    [w_sgAfB w1_sgAfC w2_sgAfD w3_sgAfE ww1_sgAfH] \u []
                        let {
                          sat_sgAfJ [Occ=Once] :: r'_XgxE2
                          [LclId] =
                              [w_sgAfB w3_sgAfE ww1_sgAfH] \u [] w3_sgAfE w_sgAfB ww1_sgAfH;
                        } in  w1_sgAfC w2_sgAfD sat_sgAfJ;
              } in  w1_sgAfC sat_sgAfK sat_sgAfL;
        };

Data.Complex.$fDataComplex3
  :: forall a.
     Data.Data.Data a =>
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Complex.Complex a
     -> Data.Functor.Identity.Identity (Data.Complex.Complex a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dData_sgAfM ds_sgAfN x0_sgAfO]
        case x0_sgAfO of {
          Data.Complex.:+ a1_sgAfQ [Occ=Once] a2_sgAfR [Occ=Once] ->
              case ds_sgAfN $dData_sgAfM a1_sgAfQ of dt_sgAfS {
                __DEFAULT ->
                    case ds_sgAfN $dData_sgAfM a2_sgAfR of dt1_sgAfT {
                      __DEFAULT -> Data.Complex.:+ [dt_sgAfS dt1_sgAfT];
                    };
              };
        };

Data.Complex.$fDataComplex_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Complex.Complex a -> m (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgAfU $dMonadPlus_sgAfV ds_sgAfW eta_sgAfX]
        let {
          lvl17_sgAfY [Occ=OnceL] :: m_agsEj (Data.Complex.Complex a_XgsGd)
          [LclId] =
              [$dMonadPlus_sgAfV] \u [] GHC.Base.mzero $dMonadPlus_sgAfV;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sgAfV
          of
          $dMonad_sgAfZ [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgAgw [Occ=Once]
                    :: (Data.Complex.Complex a_XgsGd, GHC.Types.Bool)
                       -> m_agsEj (Data.Complex.Complex a_XgsGd)
                  [LclId] =
                      [lvl17_sgAfY $dMonad_sgAfZ] \r [ds1_sgAgr]
                          case ds1_sgAgr of {
                            (,) x'_sgAgt [Occ=Once] b_sgAgu [Occ=Once!] ->
                                case b_sgAgu of {
                                  GHC.Types.False -> lvl17_sgAfY;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgAfZ x'_sgAgt;
                                };
                          }; } in
                let {
                  sat_sgAgq [Occ=Once]
                    :: m_agsEj (Data.Complex.Complex a_XgsGd, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sgAfU
                       $dMonadPlus_sgAfV
                       ds_sgAfW
                       eta_sgAfX
                       $dMonad_sgAfZ] \u []
                          case eta_sgAfX of {
                            Data.Complex.:+ a1_sgAg1 [Occ=Once] a2_sgAg2 [Occ=Once] ->
                                let {
                                  k_sgAg3 [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_agsEj (d -> b)
                                       -> d -> m_agsEj (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sgAfV
                                                ds_sgAfW
                                                $dMonad_sgAfZ] \r [$dData1_sgAg4 ds1_sgAg5 y_sgAg6]
                                          let {
                                            lvl18_sgAg7 [Occ=OnceL] :: m_agsEj d_ae2Ya
                                            [LclId] =
                                                [ds_sgAfW $dData1_sgAg4 y_sgAg6] \u []
                                                    ds_sgAfW $dData1_sgAg4 y_sgAg6; } in
                                          let {
                                            sat_sgAgn [Occ=Once]
                                              :: (d_ae2Ya -> b_ae2Yb, GHC.Types.Bool)
                                                 -> m_agsEj (b_ae2Yb, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sgAfV
                                                 $dMonad_sgAfZ
                                                 y_sgAg6
                                                 lvl18_sgAg7] \r [ds2_sgAg8]
                                                    case ds2_sgAg8 of {
                                                      (,) h_sgAga b1_sgAgb [Occ=Once!] ->
                                                          case b1_sgAgb of {
                                                            GHC.Types.False ->
                                                                let {
                                                                  sat_sgAgk [Occ=Once]
                                                                    :: m_agsEj (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sgAfZ
                                                                       y_sgAg6
                                                                       h_sgAga] \u []
                                                                          let {
                                                                            sat_sgAgi [Occ=Once]
                                                                              :: b_ae2Yb
                                                                            [LclId] =
                                                                                [y_sgAg6
                                                                                 h_sgAga] \u []
                                                                                    h_sgAga
                                                                                        y_sgAg6; } in
                                                                          let {
                                                                            sat_sgAgj [Occ=Once]
                                                                              :: (b_ae2Yb,
                                                                                  GHC.Types.Bool)
                                                                            [LclId] =
                                                                                CCCS (,)! [sat_sgAgi
                                                                                           GHC.Types.False];
                                                                          } in 
                                                                            GHC.Base.return
                                                                                $dMonad_sgAfZ
                                                                                sat_sgAgj; } in
                                                                let {
                                                                  sat_sgAgh [Occ=Once]
                                                                    :: m_agsEj (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sgAfZ
                                                                       lvl18_sgAg7
                                                                       h_sgAga] \u []
                                                                          let {
                                                                            sat_sgAgg [Occ=Once]
                                                                              :: d_ae2Ya
                                                                                 -> m_agsEj (b_ae2Yb,
                                                                                             GHC.Types.Bool)
                                                                            [LclId] =
                                                                                [$dMonad_sgAfZ
                                                                                 h_sgAga] \r [y'_sgAgd]
                                                                                    let {
                                                                                      sat_sgAge [Occ=Once]
                                                                                        :: b_ae2Yb
                                                                                      [LclId] =
                                                                                          [h_sgAga
                                                                                           y'_sgAgd] \u []
                                                                                              h_sgAga
                                                                                                  y'_sgAgd; } in
                                                                                    let {
                                                                                      sat_sgAgf [Occ=Once]
                                                                                        :: (b_ae2Yb,
                                                                                            GHC.Types.Bool)
                                                                                      [LclId] =
                                                                                          CCCS (,)! [sat_sgAge
                                                                                                     GHC.Types.True];
                                                                                    } in 
                                                                                      GHC.Base.return
                                                                                          $dMonad_sgAfZ
                                                                                          sat_sgAgf;
                                                                          } in 
                                                                            GHC.Base.>>=
                                                                                $dMonad_sgAfZ
                                                                                lvl18_sgAg7
                                                                                sat_sgAgg;
                                                                } in 
                                                                  GHC.Base.mplus
                                                                      $dMonadPlus_sgAfV
                                                                      sat_sgAgh
                                                                      sat_sgAgk;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_sgAgl [Occ=Once] :: b_ae2Yb
                                                                  [LclId] =
                                                                      [y_sgAg6 h_sgAga] \u []
                                                                          h_sgAga y_sgAg6; } in
                                                                let {
                                                                  sat_sgAgm [Occ=Once]
                                                                    :: (b_ae2Yb, GHC.Types.Bool)
                                                                  [LclId] =
                                                                      CCCS (,)! [sat_sgAgl
                                                                                 GHC.Types.True];
                                                                } in 
                                                                  GHC.Base.return
                                                                      $dMonad_sgAfZ sat_sgAgm;
                                                          };
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sgAfZ ds1_sgAg5 sat_sgAgn; } in
                                let {
                                  sat_sgAgp [Occ=Once]
                                    :: Data.Data.Mp
                                         m_agsEj (a_XgsGd -> Data.Complex.Complex a_XgsGd)
                                  [LclId] =
                                      [$dData_sgAfU $dMonad_sgAfZ a1_sgAg1 k_sgAg3] \u []
                                          let {
                                            sat_sgAgo [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_agsEj
                                                   (a_XgsGd
                                                    -> a_XgsGd -> Data.Complex.Complex a_XgsGd)
                                            [LclId] =
                                                [$dMonad_sgAfZ] \u []
                                                    GHC.Base.return
                                                        $dMonad_sgAfZ Data.Complex.$fDataComplex1;
                                          } in  k_sgAg3 $dData_sgAfU sat_sgAgo a1_sgAg1;
                                } in  k_sgAg3 $dData_sgAfU sat_sgAgp a2_sgAg2;
                          };
                } in  GHC.Base.>>= $dMonad_sgAfZ sat_sgAgq sat_sgAgw;
          };

lvl14_rgA6z :: forall a. Data.Complex.Complex a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_sgAgx]
        case ds_sgAgx of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> Data.Complex.$c:+;
        };

lvl15_rgA6A
  :: forall a. Data.Complex.Complex a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgAgB] Data.Complex.$tComplex;

lvl16_rgA6B
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Complex.Complex a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgAgC ds_sgAgD] GHC.Base.Nothing [];

Data.Complex.$fDataComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sgAgE]
        let {
          sat_sgAgQ [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Complex.Complex a_XgsGc -> m (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgAgE] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapMo
                      $dData_sgAgE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgP [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Complex.Complex a_XgsGc -> m (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgAgE] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapMp
                      $dData_sgAgE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgO [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Complex.Complex a_XgsGc -> m (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgAgE] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapM
                      $dData_sgAgE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgN [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Complex.Complex a_XgsGc
               -> u
          [LclId] =
              [$dData_sgAgE] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapQi
                      $dData_sgAgE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgM [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Complex.Complex a_XgsGc -> [u]
          [LclId] =
              [$dData_sgAgE] \r [eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapQ $dData_sgAgE eta_B2 eta_B1; } in
        let {
          sat_sgAgL [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Complex.Complex a_XgsGc
               -> r
          [LclId] =
              [$dData_sgAgE] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapQr
                      $dData_sgAgE eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgK [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Complex.Complex a_XgsGc
               -> r
          [LclId] =
              [$dData_sgAgE] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex2
                      $dData_sgAgE eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgJ [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Complex.Complex a_XgsGc -> Data.Complex.Complex a_XgsGc
          [LclId] =
              [$dData_sgAgE] \r [eta_B2 eta_B1]
                  Data.Complex.$fDataComplex3 $dData_sgAgE eta_B2 eta_B1; } in
        let {
          sat_sgAgI [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Complex.Complex a_XgsGc))
          [LclId] =
              [$dData_sgAgE] \r [eta_B1]
                  Data.Complex.$fDataComplex_$cdataCast1 $dData_sgAgE eta_B1; } in
        let {
          sat_sgAgH [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgAgE] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgunfold
                      $dData_sgAgE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgG [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Complex.Complex a_XgsGc
               -> c (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgAgE] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgfoldl
                      $dData_sgAgE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgF [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgAgE] \u [] Data.Complex.$fDataComplex10 $dData_sgAgE;
        } in 
          Data.Data.C:Data [sat_sgAgF
                            sat_sgAgG
                            sat_sgAgH
                            lvl14_rgA6z
                            lvl15_rgA6A
                            sat_sgAgI
                            lvl16_rgA6B
                            sat_sgAgJ
                            sat_sgAgK
                            sat_sgAgL
                            sat_sgAgM
                            sat_sgAgN
                            sat_sgAgO
                            sat_sgAgP
                            sat_sgAgQ];

Data.Complex.$fFloatingComplex9 :: GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.F#! [0.0#];

Data.Complex.$fFloatingComplex_$s$cpi1
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [GHC.Float.$fFloatingFloat_$cpi
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$fFloatingComplex_$s$cexp1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAgR]
        case ds_sgAgR of {
          Data.Complex.:+ x_sgAgT [Occ=Once!] y_sgAgU [Occ=Once!] ->
              case x_sgAgT of {
                GHC.Types.F# x1_sgAgW [Occ=Once] ->
                    case y_sgAgU of {
                      GHC.Types.F# x2_sgAgY ->
                          case expFloat# [x1_sgAgW] of expx_sgAgZ {
                            __DEFAULT ->
                                case sinFloat# [x2_sgAgY] of sat_sgAh3 {
                                  __DEFAULT ->
                                      case timesFloat# [expx_sgAgZ sat_sgAh3] of sat_sgAh4 {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAh5 [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgAh4];
                                            } in 
                                              case cosFloat# [x2_sgAgY] of sat_sgAh0 {
                                                __DEFAULT ->
                                                    case
                                                        timesFloat# [expx_sgAgZ sat_sgAh0]
                                                    of
                                                    sat_sgAh1
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_sgAh2 [Occ=Once] :: GHC.Types.Float
                                                            [LclId] =
                                                                CCCS GHC.Types.F#! [sat_sgAh1];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgAh2 sat_sgAh5];
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$csin1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAh6]
        case ds_sgAh6 of {
          Data.Complex.:+ x_sgAh8 [Occ=Once!] y_sgAh9 [Occ=Once!] ->
              case y_sgAh9 of {
                GHC.Types.F# x1_sgAhb ->
                    case x_sgAh8 of {
                      GHC.Types.F# x2_sgAhd ->
                          case sinhFloat# [x1_sgAhb] of sat_sgAhj {
                            __DEFAULT ->
                                case cosFloat# [x2_sgAhd] of sat_sgAhi {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgAhi sat_sgAhj] of sat_sgAhk {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAhl [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgAhk];
                                            } in 
                                              case coshFloat# [x1_sgAhb] of sat_sgAhf {
                                                __DEFAULT ->
                                                    case sinFloat# [x2_sgAhd] of sat_sgAhe {
                                                      __DEFAULT ->
                                                          case
                                                              timesFloat# [sat_sgAhe sat_sgAhf]
                                                          of
                                                          sat_sgAhg
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgAhh [Occ=Once]
                                                                    :: GHC.Types.Float
                                                                  [LclId] =
                                                                      CCCS GHC.Types.F#! [sat_sgAhg];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgAhh
                                                                                   sat_sgAhl];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ccos1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAhm]
        case ds_sgAhm of {
          Data.Complex.:+ x_sgAho [Occ=Once!] y_sgAhp [Occ=Once!] ->
              case y_sgAhp of {
                GHC.Types.F# x1_sgAhr ->
                    case x_sgAho of {
                      GHC.Types.F# x2_sgAht ->
                          case sinhFloat# [x1_sgAhr] of sat_sgAhz {
                            __DEFAULT ->
                                case sinFloat# [x2_sgAht] of sat_sgAhy {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgAhy sat_sgAhz] of sat_sgAhA {
                                        __DEFAULT ->
                                            case negateFloat# [sat_sgAhA] of sat_sgAhB {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAhC [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [sat_sgAhB];
                                                  } in 
                                                    case coshFloat# [x1_sgAhr] of sat_sgAhv {
                                                      __DEFAULT ->
                                                          case cosFloat# [x2_sgAht] of sat_sgAhu {
                                                            __DEFAULT ->
                                                                case
                                                                    timesFloat# [sat_sgAhu
                                                                                 sat_sgAhv]
                                                                of
                                                                sat_sgAhw
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_sgAhx [Occ=Once]
                                                                          :: GHC.Types.Float
                                                                        [LclId] =
                                                                            CCCS GHC.Types.F#! [sat_sgAhw];
                                                                      } in 
                                                                        Data.Complex.:+ [sat_sgAhx
                                                                                         sat_sgAhC];
                                                                };
                                                          };
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$csinh1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAhD]
        case ds_sgAhD of {
          Data.Complex.:+ x_sgAhF [Occ=Once!] y_sgAhG [Occ=Once!] ->
              case x_sgAhF of {
                GHC.Types.F# x1_sgAhI ->
                    case y_sgAhG of {
                      GHC.Types.F# x2_sgAhK ->
                          case coshFloat# [x1_sgAhI] of sat_sgAhQ {
                            __DEFAULT ->
                                case sinFloat# [x2_sgAhK] of sat_sgAhP {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgAhP sat_sgAhQ] of sat_sgAhR {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAhS [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgAhR];
                                            } in 
                                              case sinhFloat# [x1_sgAhI] of sat_sgAhM {
                                                __DEFAULT ->
                                                    case cosFloat# [x2_sgAhK] of sat_sgAhL {
                                                      __DEFAULT ->
                                                          case
                                                              timesFloat# [sat_sgAhL sat_sgAhM]
                                                          of
                                                          sat_sgAhN
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgAhO [Occ=Once]
                                                                    :: GHC.Types.Float
                                                                  [LclId] =
                                                                      CCCS GHC.Types.F#! [sat_sgAhN];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgAhO
                                                                                   sat_sgAhS];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ccosh1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAhT]
        case ds_sgAhT of {
          Data.Complex.:+ x_sgAhV [Occ=Once!] y_sgAhW [Occ=Once!] ->
              case x_sgAhV of {
                GHC.Types.F# x1_sgAhY ->
                    case y_sgAhW of {
                      GHC.Types.F# x2_sgAi0 ->
                          case sinhFloat# [x1_sgAhY] of sat_sgAi6 {
                            __DEFAULT ->
                                case sinFloat# [x2_sgAi0] of sat_sgAi5 {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgAi5 sat_sgAi6] of sat_sgAi7 {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAi8 [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgAi7];
                                            } in 
                                              case coshFloat# [x1_sgAhY] of sat_sgAi2 {
                                                __DEFAULT ->
                                                    case cosFloat# [x2_sgAi0] of sat_sgAi1 {
                                                      __DEFAULT ->
                                                          case
                                                              timesFloat# [sat_sgAi1 sat_sgAi2]
                                                          of
                                                          sat_sgAi3
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgAi4 [Occ=Once]
                                                                    :: GHC.Types.Float
                                                                  [LclId] =
                                                                      CCCS GHC.Types.F#! [sat_sgAi3];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgAi4
                                                                                   sat_sgAi8];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$s$c/1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAi9 ww1_sgAia ww2_sgAib ww3_sgAic]
        case GHC.Float.$w$cexponent1 ww2_sgAib of ww4_sgAid {
          __DEFAULT ->
              case GHC.Float.$w$cexponent1 ww3_sgAic of ww5_sgAie {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgAif [Occ=Once*!T[1], Dmd=<C(S),1*C1(U(U,U))>]
                        :: GHC.Prim.Int# -> (# GHC.Types.Float, GHC.Types.Float #)
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgAi9 ww1_sgAia ww2_sgAib ww3_sgAic] \r [ww6_sgAig]
                              case GHC.Float.$w$cscaleFloat1 ww6_sgAig ww2_sgAib of ww7_sgAih {
                                __DEFAULT ->
                                    case
                                        GHC.Float.$w$cscaleFloat1 ww6_sgAig ww3_sgAic
                                    of
                                    ww8_sgAii
                                    { __DEFAULT ->
                                          case timesFloat# [ww3_sgAic ww8_sgAii] of sat_sgAil {
                                            __DEFAULT ->
                                                case
                                                    timesFloat# [ww2_sgAib ww7_sgAih]
                                                of
                                                sat_sgAik
                                                { __DEFAULT ->
                                                      case
                                                          plusFloat# [sat_sgAik sat_sgAil]
                                                      of
                                                      y_sgAij [Dmd=<S,U>]
                                                      { __DEFAULT ->
                                                            case
                                                                timesFloat# [ww1_sgAia ww8_sgAii]
                                                            of
                                                            sat_sgAin
                                                            { __DEFAULT ->
                                                                  case
                                                                      timesFloat# [ww_sgAi9
                                                                                   ww7_sgAih]
                                                                  of
                                                                  sat_sgAim
                                                                  { __DEFAULT ->
                                                                        case
                                                                            plusFloat# [sat_sgAim
                                                                                        sat_sgAin]
                                                                        of
                                                                        sat_sgAio
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  divideFloat# [sat_sgAio
                                                                                                y_sgAij]
                                                                              of
                                                                              wild2_sgAip
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        timesFloat# [ww_sgAi9
                                                                                                     ww8_sgAii]
                                                                                    of
                                                                                    sat_sgAir
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              timesFloat# [ww1_sgAia
                                                                                                           ww7_sgAih]
                                                                                          of
                                                                                          sat_sgAiq
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    minusFloat# [sat_sgAiq
                                                                                                                 sat_sgAir]
                                                                                                of
                                                                                                sat_sgAis
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          divideFloat# [sat_sgAis
                                                                                                                        y_sgAij]
                                                                                                      of
                                                                                                      wild1_sgAit
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgAiv [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [wild1_sgAit]; } in
                                                                                                            let {
                                                                                                              sat_sgAiu [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [wild2_sgAip];
                                                                                                            } in 
                                                                                                              (#,#) [sat_sgAiu
                                                                                                                     sat_sgAiv];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww4_sgAid ww5_sgAie] of {
                        __DEFAULT ->
                            case negateInt# [ww4_sgAid] of sat_sgAix {
                              __DEFAULT -> $j_sgAif sat_sgAix;
                            };
                        1# ->
                            case negateInt# [ww5_sgAie] of sat_sgAiy {
                              __DEFAULT -> $j_sgAif sat_sgAiy;
                            };
                      };
              };
        };

Data.Complex.$fFloatingComplex_$s$c/1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAiz w1_sgAiA]
        case w_sgAiz of {
          Data.Complex.:+ ww1_sgAiC [Occ=Once!] ww2_sgAiD [Occ=Once!] ->
              case ww1_sgAiC of {
                GHC.Types.F# ww4_sgAiF [Occ=Once] ->
                    case ww2_sgAiD of {
                      GHC.Types.F# ww6_sgAiH [Occ=Once] ->
                          case w1_sgAiA of {
                            Data.Complex.:+ ww8_sgAiJ [Occ=Once!] ww9_sgAiK [Occ=Once!] ->
                                case ww8_sgAiJ of {
                                  GHC.Types.F# ww11_sgAiM [Occ=Once] ->
                                      case ww9_sgAiK of {
                                        GHC.Types.F# ww13_sgAiO [Occ=Once] ->
                                            case
                                                Data.Complex.$w$s$c/1
                                                    ww4_sgAiF ww6_sgAiH ww11_sgAiM ww13_sgAiO
                                            of
                                            { (#,#) ww15_sgAiQ [Occ=Once] ww16_sgAiR [Occ=Once] ->
                                                  Data.Complex.:+ [ww15_sgAiQ ww16_sgAiR];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromRational1
  :: GHC.Real.Rational -> Data.Complex.Complex GHC.Types.Float
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [a_sgAiS]
        case a_sgAiS of {
          GHC.Real.:% n_sgAiU [Occ=Once] d_sgAiV [Occ=Once] ->
              case GHC.Float.rationalToFloat n_sgAiU d_sgAiV of dt_sgAiW {
                GHC.Types.F# _ [Occ=Dead] ->
                    Data.Complex.:+ [dt_sgAiW Data.Complex.$fFloatingComplex9];
              };
        };

Data.Complex.$fFloatingComplex_$s$c+1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAiY w1_sgAiZ]
        case w_sgAiY of {
          Data.Complex.:+ ww1_sgAj1 [Occ=Once!] ww2_sgAj2 [Occ=Once!] ->
              case ww1_sgAj1 of {
                GHC.Types.F# ww4_sgAj4 [Occ=Once] ->
                    case ww2_sgAj2 of {
                      GHC.Types.F# ww6_sgAj6 [Occ=Once] ->
                          case w1_sgAiZ of {
                            Data.Complex.:+ ww8_sgAj8 [Occ=Once!] ww9_sgAj9 [Occ=Once!] ->
                                case ww8_sgAj8 of {
                                  GHC.Types.F# ww11_sgAjb [Occ=Once] ->
                                      case ww9_sgAj9 of {
                                        GHC.Types.F# ww13_sgAjd [Occ=Once] ->
                                            case plusFloat# [ww6_sgAj6 ww13_sgAjd] of sat_sgAjg {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAjh [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [sat_sgAjg];
                                                  } in 
                                                    case
                                                        plusFloat# [ww4_sgAj4 ww11_sgAjb]
                                                    of
                                                    sat_sgAje
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_sgAjf [Occ=Once] :: GHC.Types.Float
                                                            [LclId] =
                                                                CCCS GHC.Types.F#! [sat_sgAje];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgAjf sat_sgAjh];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c-1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAji w1_sgAjj]
        case w_sgAji of {
          Data.Complex.:+ ww1_sgAjl [Occ=Once!] ww2_sgAjm [Occ=Once!] ->
              case ww1_sgAjl of {
                GHC.Types.F# ww4_sgAjo [Occ=Once] ->
                    case ww2_sgAjm of {
                      GHC.Types.F# ww6_sgAjq [Occ=Once] ->
                          case w1_sgAjj of {
                            Data.Complex.:+ ww8_sgAjs [Occ=Once!] ww9_sgAjt [Occ=Once!] ->
                                case ww8_sgAjs of {
                                  GHC.Types.F# ww11_sgAjv [Occ=Once] ->
                                      case ww9_sgAjt of {
                                        GHC.Types.F# ww13_sgAjx [Occ=Once] ->
                                            case minusFloat# [ww6_sgAjq ww13_sgAjx] of sat_sgAjA {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAjB [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [sat_sgAjA];
                                                  } in 
                                                    case
                                                        minusFloat# [ww4_sgAjo ww11_sgAjv]
                                                    of
                                                    sat_sgAjy
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_sgAjz [Occ=Once] :: GHC.Types.Float
                                                            [LclId] =
                                                                CCCS GHC.Types.F#! [sat_sgAjy];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgAjz sat_sgAjB];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c*1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAjC w1_sgAjD]
        case w_sgAjC of {
          Data.Complex.:+ ww1_sgAjF [Occ=Once!] ww2_sgAjG [Occ=Once!] ->
              case ww1_sgAjF of {
                GHC.Types.F# ww4_sgAjI ->
                    case ww2_sgAjG of {
                      GHC.Types.F# ww6_sgAjK ->
                          case w1_sgAjD of {
                            Data.Complex.:+ ww8_sgAjM [Occ=Once!] ww9_sgAjN [Occ=Once!] ->
                                case ww8_sgAjM of {
                                  GHC.Types.F# ww11_sgAjP ->
                                      case ww9_sgAjN of {
                                        GHC.Types.F# ww13_sgAjR ->
                                            case timesFloat# [ww6_sgAjK ww11_sgAjP] of sat_sgAjX {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [ww4_sgAjI ww13_sgAjR]
                                                  of
                                                  sat_sgAjW
                                                  { __DEFAULT ->
                                                        case
                                                            plusFloat# [sat_sgAjW sat_sgAjX]
                                                        of
                                                        sat_sgAjY
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_sgAjZ [Occ=Once]
                                                                  :: GHC.Types.Float
                                                                [LclId] =
                                                                    CCCS GHC.Types.F#! [sat_sgAjY];
                                                              } in 
                                                                case
                                                                    timesFloat# [ww6_sgAjK
                                                                                 ww13_sgAjR]
                                                                of
                                                                sat_sgAjT
                                                                { __DEFAULT ->
                                                                      case
                                                                          timesFloat# [ww4_sgAjI
                                                                                       ww11_sgAjP]
                                                                      of
                                                                      sat_sgAjS
                                                                      { __DEFAULT ->
                                                                            case
                                                                                minusFloat# [sat_sgAjS
                                                                                             sat_sgAjT]
                                                                            of
                                                                            sat_sgAjU
                                                                            { __DEFAULT ->
                                                                                  let {
                                                                                    sat_sgAjV [Occ=Once]
                                                                                      :: GHC.Types.Float
                                                                                    [LclId] =
                                                                                        CCCS GHC.Types.F#! [sat_sgAjU];
                                                                                  } in 
                                                                                    Data.Complex.:+ [sat_sgAjV
                                                                                                     sat_sgAjZ];
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cnegate1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAk0]
        case ds_sgAk0 of {
          Data.Complex.:+ x_sgAk2 [Occ=Once!] y_sgAk3 [Occ=Once!] ->
              case x_sgAk2 of {
                GHC.Types.F# x1_sgAk5 [Occ=Once] ->
                    case y_sgAk3 of {
                      GHC.Types.F# x2_sgAk7 [Occ=Once] ->
                          case negateFloat# [x2_sgAk7] of sat_sgAka {
                            __DEFAULT ->
                                let {
                                  sat_sgAkb [Occ=Once] :: GHC.Types.Float
                                  [LclId] =
                                      CCCS GHC.Types.F#! [sat_sgAka];
                                } in 
                                  case negateFloat# [x1_sgAk5] of sat_sgAk8 {
                                    __DEFAULT ->
                                        let {
                                          sat_sgAk9 [Occ=Once] :: GHC.Types.Float
                                          [LclId] =
                                              CCCS GHC.Types.F#! [sat_sgAk8];
                                        } in  Data.Complex.:+ [sat_sgAk9 sat_sgAkb];
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromInteger1
  :: GHC.Integer.Type.Integer -> Data.Complex.Complex GHC.Types.Float
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [n_sgAkc]
        case GHC.Integer.Type.floatFromInteger n_sgAkc of wild_sgAkd {
          __DEFAULT ->
              let {
                sat_sgAke [Occ=Once] :: GHC.Types.Float
                [LclId] =
                    CCCS GHC.Types.F#! [wild_sgAkd];
              } in  Data.Complex.:+ [sat_sgAke Data.Complex.$fFloatingComplex9];
        };

Data.Complex.conjugate_$sconjugate
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAkf]
        case ds_sgAkf of {
          Data.Complex.:+ x_sgAkh [Occ=Once] y_sgAki [Occ=Once!] ->
              case y_sgAki of {
                GHC.Types.D# x1_sgAkk [Occ=Once] ->
                    case negateDouble# [x1_sgAkk] of sat_sgAkl {
                      __DEFAULT ->
                          let {
                            sat_sgAkm [Occ=Once] :: GHC.Types.Double
                            [LclId] =
                                CCCS GHC.Types.D#! [sat_sgAkl];
                          } in  Data.Complex.:+ [x_sgAkh sat_sgAkm];
                    };
              };
        };

Data.Complex.conjugate
  :: forall a.
     GHC.Num.Num a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LLL),1*U(A,A,A,1*C1(U),A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dNum_sgAkn ds_sgAko]
        case ds_sgAko of {
          Data.Complex.:+ x_sgAkq [Occ=Once] y_sgAkr [Occ=Once] ->
              case GHC.Num.negate $dNum_sgAkn y_sgAkr of dt_sgAks {
                __DEFAULT -> Data.Complex.:+ [x_sgAkq dt_sgAks];
              };
        };

Data.Complex.cis_$scis
  :: GHC.Types.Double -> Data.Complex.Complex GHC.Types.Double
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [theta_sgAkt]
        case theta_sgAkt of {
          GHC.Types.D# x_sgAkv ->
              case sinDouble# [x_sgAkv] of sat_sgAky {
                __DEFAULT ->
                    let {
                      sat_sgAkz [Occ=Once] :: GHC.Types.Double
                      [LclId] =
                          CCCS GHC.Types.D#! [sat_sgAky];
                    } in 
                      case cosDouble# [x_sgAkv] of sat_sgAkw {
                        __DEFAULT ->
                            let {
                              sat_sgAkx [Occ=Once] :: GHC.Types.Double
                              [LclId] =
                                  CCCS GHC.Types.D#! [sat_sgAkw];
                            } in  Data.Complex.:+ [sat_sgAkx sat_sgAkz];
                      };
              };
        };

Data.Complex.cis
  :: forall a. GHC.Float.Floating a => a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)C(S)LLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgAkA theta_sgAkB]
        case GHC.Float.cos $dFloating_sgAkA theta_sgAkB of dt_sgAkC {
          __DEFAULT ->
              case GHC.Float.sin $dFloating_sgAkA theta_sgAkB of dt1_sgAkD {
                __DEFAULT -> Data.Complex.:+ [dt_sgAkC dt1_sgAkD];
              };
        };

Data.Complex.mkPolar_$smkPolar
  :: GHC.Types.Double
     -> GHC.Types.Double -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [r_sgAkE theta_sgAkF]
        case r_sgAkE of {
          GHC.Types.D# x_sgAkH ->
              case theta_sgAkF of {
                GHC.Types.D# x1_sgAkJ ->
                    case sinDouble# [x1_sgAkJ] of sat_sgAkN {
                      __DEFAULT ->
                          case *## [x_sgAkH sat_sgAkN] of sat_sgAkO {
                            __DEFAULT ->
                                let {
                                  sat_sgAkP [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [sat_sgAkO];
                                } in 
                                  case cosDouble# [x1_sgAkJ] of sat_sgAkK {
                                    __DEFAULT ->
                                        case *## [x_sgAkH sat_sgAkK] of sat_sgAkL {
                                          __DEFAULT ->
                                              let {
                                                sat_sgAkM [Occ=Once] :: GHC.Types.Double
                                                [LclId] =
                                                    CCCS GHC.Types.D#! [sat_sgAkL];
                                              } in  Data.Complex.:+ [sat_sgAkM sat_sgAkP];
                                        };
                                  };
                          };
                    };
              };
        };

Data.Complex.$wmkPolar [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.Floating a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LLC(C(S))LLLL)LLL)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A,A),A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAkQ w1_sgAkR w2_sgAkS]
        case
            GHC.Float.$p1Floating w_sgAkQ
        of
        $dFractional_sgAkT [Dmd=<S(S(LLC(C(S))LLLL)LLL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Fractional $dFractional_sgAkT
              of
              $dNum_sgAkU [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
              { __DEFAULT ->
                    let {
                      sat_sgAkV [Occ=Once] :: a_sgxwP
                      [LclId] =
                          [w_sgAkQ w2_sgAkS] \u [] GHC.Float.cos w_sgAkQ w2_sgAkS;
                    } in 
                      case GHC.Num.* $dNum_sgAkU w1_sgAkR sat_sgAkV of dt_sgAkW {
                        __DEFAULT ->
                            let {
                              sat_sgAkX [Occ=Once] :: a_sgxwP
                              [LclId] =
                                  [w_sgAkQ w2_sgAkS] \u [] GHC.Float.sin w_sgAkQ w2_sgAkS;
                            } in 
                              case GHC.Num.* $dNum_sgAkU w1_sgAkR sat_sgAkX of dt1_sgAkY {
                                __DEFAULT -> (#,#) [dt_sgAkW dt1_sgAkY];
                              };
                      };
              };
        };

Data.Complex.mkPolar [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.Floating a =>
     a -> a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LLC(C(S))LLLL)LLL)LLLLLLLLLLLLLLLLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),A,A,A),A,A,A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgAkZ w1_sgAl0 w2_sgAl1]
        case Data.Complex.$wmkPolar w_sgAkZ w1_sgAl0 w2_sgAl1 of {
          (#,#) ww1_sgAl3 [Occ=Once] ww2_sgAl4 [Occ=Once] ->
              Data.Complex.:+ [ww1_sgAl3 ww2_sgAl4];
        };

Data.Complex.$w$sphase [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> GHC.Prim.Double#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_sgAl5 ww1_sgAl6]
        case ==## [ww_sgAl5 0.0##] of {
          __DEFAULT ->
              let {
                sat_sgAl8 [Occ=Once] :: GHC.Types.Double
                [LclId] =
                    CCCS GHC.Types.D#! [ww1_sgAl6];
              } in  GHC.Float.$w$catan2 sat_sgAl8 ww_sgAl5;
          1# ->
              case ==## [ww1_sgAl6 0.0##] of {
                __DEFAULT ->
                    let {
                      sat_sgAla [Occ=Once] :: GHC.Types.Double
                      [LclId] =
                          CCCS GHC.Types.D#! [ww1_sgAl6];
                    } in  GHC.Float.$w$catan2 sat_sgAla ww_sgAl5;
                1# -> 0.0##;
              };
        };

Data.Complex.$fFloatingComplex_$sphase [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double -> GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAlb]
        case w_sgAlb of {
          Data.Complex.:+ ww1_sgAld [Occ=Once!] ww2_sgAle [Occ=Once!] ->
              case ww1_sgAld of {
                GHC.Types.D# ww4_sgAlg [Occ=Once] ->
                    case ww2_sgAle of {
                      GHC.Types.D# ww6_sgAli [Occ=Once] ->
                          case Data.Complex.$w$sphase ww4_sgAlg ww6_sgAli of ww7_sgAlj {
                            __DEFAULT -> GHC.Types.D# [ww7_sgAlj];
                          };
                    };
              };
        };

Data.Complex.$w$sphase1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> GHC.Prim.Float#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_sgAlk ww1_sgAll]
        case eqFloat# [ww_sgAlk 0.0#] of {
          __DEFAULT ->
              let {
                sat_sgAln [Occ=Once] :: GHC.Types.Float
                [LclId] =
                    CCCS GHC.Types.F#! [ww1_sgAll];
              } in  GHC.Float.$w$catan1 sat_sgAln ww_sgAlk;
          1# ->
              case eqFloat# [ww1_sgAll 0.0#] of {
                __DEFAULT ->
                    let {
                      sat_sgAlp [Occ=Once] :: GHC.Types.Float
                      [LclId] =
                          CCCS GHC.Types.F#! [ww1_sgAll];
                    } in  GHC.Float.$w$catan1 sat_sgAlp ww_sgAlk;
                1# -> 0.0#;
              };
        };

Data.Complex.$fFloatingComplex_$sphase1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float -> GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAlq]
        case w_sgAlq of {
          Data.Complex.:+ ww1_sgAls [Occ=Once!] ww2_sgAlt [Occ=Once!] ->
              case ww1_sgAls of {
                GHC.Types.F# ww4_sgAlv [Occ=Once] ->
                    case ww2_sgAlt of {
                      GHC.Types.F# ww6_sgAlx [Occ=Once] ->
                          case Data.Complex.$w$sphase1 ww4_sgAlv ww6_sgAlx of ww7_sgAly {
                            __DEFAULT -> GHC.Types.F# [ww7_sgAly];
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex17 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Complex.$wphase [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAlz ww_sgAlA ww1_sgAlB]
        case
            GHC.Float.$p1RealFloat w_sgAlz
        of
        $dRealFrac_sgAlC [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAlC
              of
              $dReal_sgAlD [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      $dNum_sgAlE [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_sgxxx
                      [LclId] =
                          [$dReal_sgAlD] \u [] GHC.Real.$p1Real $dReal_sgAlD;
                    } in 
                      case
                          GHC.Real.$p2Real $dReal_sgAlD
                      of
                      $dOrd_sgAlF [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                      { __DEFAULT ->
                            case
                                GHC.Classes.$p1Ord $dOrd_sgAlF
                            of
                            $dEq_sgAlG [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                            { __DEFAULT ->
                                  let {
                                    sat_sgAlH [Occ=Once] :: a_sgxxx
                                    [LclId] =
                                        [$dNum_sgAlE] \u []
                                            GHC.Num.fromInteger
                                                $dNum_sgAlE Data.Complex.$fFloatingComplex17;
                                  } in 
                                    case GHC.Classes.== $dEq_sgAlG ww_sgAlA sat_sgAlH of {
                                      GHC.Types.False -> GHC.Float.atan2 w_sgAlz ww1_sgAlB ww_sgAlA;
                                      GHC.Types.True ->
                                          let {
                                            sat_sgAlJ [Occ=Once] :: a_sgxxx
                                            [LclId] =
                                                [$dNum_sgAlE] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_sgAlE
                                                        Data.Complex.$fFloatingComplex17;
                                          } in 
                                            case GHC.Classes.== $dEq_sgAlG ww1_sgAlB sat_sgAlJ of {
                                              GHC.Types.False ->
                                                  GHC.Float.atan2 w_sgAlz ww1_sgAlB ww_sgAlA;
                                              GHC.Types.True ->
                                                  GHC.Num.fromInteger
                                                      $dNum_sgAlE Data.Complex.$fFloatingComplex17;
                                            };
                                    };
                            };
                      };
              };
        };

Data.Complex.phase [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAlL w1_sgAlM]
        case w1_sgAlM of {
          Data.Complex.:+ ww1_sgAlO [Occ=Once] ww2_sgAlP [Occ=Once] ->
              Data.Complex.$wphase w_sgAlL ww1_sgAlO ww2_sgAlP;
        };

Data.Complex.$w$smagnitude [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> GHC.Prim.Double#
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAlQ ww1_sgAlR]
        case GHC.Float.$w$cexponent ww_sgAlQ of ww2_sgAlS {
          __DEFAULT ->
              case GHC.Float.$w$cexponent ww1_sgAlR of ww3_sgAlT {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgAlU [Occ=Once*!T[1], Dmd=<C(S),1*C1(U)>]
                        :: GHC.Prim.Int# -> GHC.Prim.Double#
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgAlQ ww1_sgAlR] \r [x_sgAlV]
                              case negateInt# [x_sgAlV] of ww4_sgAlW [Dmd=<S,U>] {
                                __DEFAULT ->
                                    case GHC.Float.$w$cscaleFloat ww4_sgAlW ww_sgAlQ of ww5_sgAlX {
                                      __DEFAULT ->
                                          case
                                              GHC.Float.$w$cscaleFloat ww4_sgAlW ww1_sgAlR
                                          of
                                          ww6_sgAlY
                                          { __DEFAULT ->
                                                case *## [ww6_sgAlY ww6_sgAlY] of sat_sgAm0 {
                                                  __DEFAULT ->
                                                      case *## [ww5_sgAlX ww5_sgAlX] of sat_sgAlZ {
                                                        __DEFAULT ->
                                                            case
                                                                +## [sat_sgAlZ sat_sgAm0]
                                                            of
                                                            sat_sgAm1
                                                            { __DEFAULT ->
                                                                  case
                                                                      sqrtDouble# [sat_sgAm1]
                                                                  of
                                                                  sat_sgAm2
                                                                  { __DEFAULT ->
                                                                        GHC.Float.$w$cscaleFloat
                                                                            x_sgAlV sat_sgAm2;
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww2_sgAlS ww3_sgAlT] of {
                        __DEFAULT -> $j_sgAlU ww2_sgAlS;
                        1# -> $j_sgAlU ww3_sgAlT;
                      };
              };
        };

Data.Complex.$fFloatingComplex_$smagnitude [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double -> GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAm4]
        case w_sgAm4 of {
          Data.Complex.:+ ww1_sgAm6 [Occ=Once!] ww2_sgAm7 [Occ=Once!] ->
              case ww1_sgAm6 of {
                GHC.Types.D# ww4_sgAm9 [Occ=Once] ->
                    case ww2_sgAm7 of {
                      GHC.Types.D# ww6_sgAmb [Occ=Once] ->
                          case Data.Complex.$w$smagnitude ww4_sgAm9 ww6_sgAmb of ww7_sgAmc {
                            __DEFAULT -> GHC.Types.D# [ww7_sgAmc];
                          };
                    };
              };
        };

Data.Complex.$w$smagnitude1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> GHC.Prim.Float#
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAmd ww1_sgAme]
        case GHC.Float.$w$cexponent1 ww_sgAmd of ww2_sgAmf {
          __DEFAULT ->
              case GHC.Float.$w$cexponent1 ww1_sgAme of ww3_sgAmg {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgAmh [Occ=Once*!T[1], Dmd=<C(S),1*C1(U)>]
                        :: GHC.Prim.Int# -> GHC.Prim.Float#
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgAmd ww1_sgAme] \r [x_sgAmi]
                              case negateInt# [x_sgAmi] of ww4_sgAmj [Dmd=<S,U>] {
                                __DEFAULT ->
                                    case GHC.Float.$w$cscaleFloat1 ww4_sgAmj ww_sgAmd of ww5_sgAmk {
                                      __DEFAULT ->
                                          case
                                              GHC.Float.$w$cscaleFloat1 ww4_sgAmj ww1_sgAme
                                          of
                                          ww6_sgAml
                                          { __DEFAULT ->
                                                case
                                                    timesFloat# [ww6_sgAml ww6_sgAml]
                                                of
                                                sat_sgAmn
                                                { __DEFAULT ->
                                                      case
                                                          timesFloat# [ww5_sgAmk ww5_sgAmk]
                                                      of
                                                      sat_sgAmm
                                                      { __DEFAULT ->
                                                            case
                                                                plusFloat# [sat_sgAmm sat_sgAmn]
                                                            of
                                                            sat_sgAmo
                                                            { __DEFAULT ->
                                                                  case
                                                                      sqrtFloat# [sat_sgAmo]
                                                                  of
                                                                  sat_sgAmp
                                                                  { __DEFAULT ->
                                                                        GHC.Float.$w$cscaleFloat1
                                                                            x_sgAmi sat_sgAmp;
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww2_sgAmf ww3_sgAmg] of {
                        __DEFAULT -> $j_sgAmh ww2_sgAmf;
                        1# -> $j_sgAmh ww3_sgAmg;
                      };
              };
        };

Data.Complex.$fFloatingComplex_$smagnitude1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float -> GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAmr]
        case w_sgAmr of {
          Data.Complex.:+ ww1_sgAmt [Occ=Once!] ww2_sgAmu [Occ=Once!] ->
              case ww1_sgAmt of {
                GHC.Types.F# ww4_sgAmw [Occ=Once] ->
                    case ww2_sgAmu of {
                      GHC.Types.F# ww6_sgAmy [Occ=Once] ->
                          case Data.Complex.$w$smagnitude1 ww4_sgAmw ww6_sgAmy of ww7_sgAmz {
                            __DEFAULT -> GHC.Types.F# [ww7_sgAmz];
                          };
                    };
              };
        };

Data.Complex.$wmagnitude [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(C(S))LLLLLL),U(1*U(1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAmA ww_sgAmB ww1_sgAmC]
        let {
          k_sgAmD [Dmd=<L,U(U)>] :: GHC.Types.Int
          [LclId] =
              [w_sgAmA ww_sgAmB ww1_sgAmC] \u []
                  case GHC.Float.exponent w_sgAmA ww_sgAmB of wild_sgAmE {
                    GHC.Types.I# x1_sgAmF [Occ=Once] ->
                        case GHC.Float.exponent w_sgAmA ww1_sgAmC of wild1_sgAmG {
                          GHC.Types.I# y1_sgAmH [Occ=Once] ->
                              case <=# [x1_sgAmF y1_sgAmH] of {
                                __DEFAULT -> wild_sgAmE;
                                1# -> wild1_sgAmG;
                              };
                        };
                  }; } in
        let {
          sat_sgAmW [Occ=Once] :: a_sgxyi
          [LclId] =
              [w_sgAmA ww_sgAmB ww1_sgAmC k_sgAmD] \u []
                  let {
                    sat_sgAmV [Occ=Once] :: a_sgxyi
                    [LclId] =
                        [w_sgAmA ww_sgAmB ww1_sgAmC k_sgAmD] \u []
                            case
                                GHC.Float.$p1RealFloat w_sgAmA
                            of
                            $dRealFrac_sgAmK [Dmd=<S(S(S(C(C(S))LLLLLL)LL)LLLLLL),1*U(1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
                            { __DEFAULT ->
                                  case
                                      GHC.Real.$p1RealFrac $dRealFrac_sgAmK
                                  of
                                  $dReal_sgAmL [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A)>]
                                  { __DEFAULT ->
                                        case
                                            GHC.Real.$p1Real $dReal_sgAmL
                                        of
                                        $dNum_sgAmM [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A)>]
                                        { __DEFAULT ->
                                              let {
                                                mk_sgAmN :: GHC.Types.Int
                                                [LclId] =
                                                    [k_sgAmD] \u []
                                                        case k_sgAmD of {
                                                          GHC.Types.I# x_sgAmP [Occ=Once] ->
                                                              case
                                                                  negateInt# [x_sgAmP]
                                                              of
                                                              sat_sgAmQ
                                                              { __DEFAULT ->
                                                                    GHC.Types.I# [sat_sgAmQ];
                                                              };
                                                        }; } in
                                              let {
                                                sat_sgAmU [Occ=Once] :: a_sgxyi
                                                [LclId] =
                                                    [w_sgAmA ww1_sgAmC $dNum_sgAmM mk_sgAmN] \u []
                                                        let {
                                                          z_sgAmT :: a_sgxyi
                                                          [LclId] =
                                                              [w_sgAmA ww1_sgAmC mk_sgAmN] \u []
                                                                  GHC.Float.scaleFloat
                                                                      w_sgAmA mk_sgAmN ww1_sgAmC;
                                                        } in 
                                                          GHC.Num.*
                                                              $dNum_sgAmM z_sgAmT z_sgAmT; } in
                                              let {
                                                sat_sgAmS [Occ=Once] :: a_sgxyi
                                                [LclId] =
                                                    [w_sgAmA ww_sgAmB $dNum_sgAmM mk_sgAmN] \u []
                                                        let {
                                                          z_sgAmR :: a_sgxyi
                                                          [LclId] =
                                                              [w_sgAmA ww_sgAmB mk_sgAmN] \u []
                                                                  GHC.Float.scaleFloat
                                                                      w_sgAmA mk_sgAmN ww_sgAmB;
                                                        } in  GHC.Num.* $dNum_sgAmM z_sgAmR z_sgAmR;
                                              } in  GHC.Num.+ $dNum_sgAmM sat_sgAmS sat_sgAmU;
                                        };
                                  };
                            };
                  } in 
                    case GHC.Float.$p2RealFloat w_sgAmA of sat_sgAmJ {
                      __DEFAULT -> GHC.Float.sqrt sat_sgAmJ sat_sgAmV;
                    };
        } in  GHC.Float.scaleFloat w_sgAmA k_sgAmD sat_sgAmW;

Data.Complex.magnitude [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAmX w1_sgAmY]
        case w1_sgAmY of {
          Data.Complex.:+ ww1_sgAn0 [Occ=Once] ww2_sgAn1 [Occ=Once] ->
              Data.Complex.$wmagnitude w_sgAmX ww1_sgAn0 ww2_sgAn1;
        };

Data.Complex.$fFloatingComplex_$s$clog1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAn2]
        case w_sgAn2 of {
          Data.Complex.:+ ww1_sgAn4 [Occ=Once!] ww2_sgAn5 [Occ=Once!] ->
              case ww1_sgAn4 of {
                GHC.Types.F# ww4_sgAn7 ->
                    case ww2_sgAn5 of {
                      GHC.Types.F# ww6_sgAn9 ->
                          case Data.Complex.$w$smagnitude1 ww4_sgAn7 ww6_sgAn9 of ww7_sgAna {
                            __DEFAULT ->
                                case logFloat# [ww7_sgAna] of wild1_sgAnb {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$sphase1 ww4_sgAn7 ww6_sgAn9
                                      of
                                      ww8_sgAnc
                                      { __DEFAULT ->
                                            let {
                                              sat_sgAne [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [ww8_sgAnc]; } in
                                            let {
                                              sat_sgAnd [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [wild1_sgAnb];
                                            } in  Data.Complex.:+ [sat_sgAnd sat_sgAne];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cabs1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [z_sgAnf]
        case z_sgAnf of {
          Data.Complex.:+ ww1_sgAnh [Occ=Once!] ww2_sgAni [Occ=Once!] ->
              case ww1_sgAnh of {
                GHC.Types.F# ww4_sgAnk [Occ=Once] ->
                    case ww2_sgAni of {
                      GHC.Types.F# ww6_sgAnm [Occ=Once] ->
                          case Data.Complex.$w$smagnitude1 ww4_sgAnk ww6_sgAnm of ww7_sgAnn {
                            __DEFAULT ->
                                let {
                                  sat_sgAno [Occ=Once] :: GHC.Types.Float
                                  [LclId] =
                                      CCCS GHC.Types.F#! [ww7_sgAnn];
                                } in  Data.Complex.:+ [sat_sgAno Data.Complex.$fFloatingComplex9];
                          };
                    };
              };
        };

Data.Complex.polar_$spolar
  :: Data.Complex.Complex GHC.Types.Double
     -> (GHC.Types.Double, GHC.Types.Double)
[GblId, Arity=1, Str=<L,U(U(U),U(U))>m, Unf=OtherCon []] =
    [] \r [z_sgAnp]
        let {
          sat_sgAnr [Occ=Once] :: GHC.Types.Double
          [LclId] =
              [z_sgAnp] \u []
                  Data.Complex.$fFloatingComplex_$sphase z_sgAnp; } in
        let {
          sat_sgAnq [Occ=Once] :: GHC.Types.Double
          [LclId] =
              [z_sgAnp] \u [] Data.Complex.$fFloatingComplex_$smagnitude z_sgAnp;
        } in  (,) [sat_sgAnq sat_sgAnr];

Data.Complex.polar
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> (a, a)
[GblId,
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgAns z_sgAnt]
        let {
          sat_sgAnv [Occ=Once] :: a_agsyd
          [LclId] =
              [$dRealFloat_sgAns z_sgAnt] \u []
                  Data.Complex.phase $dRealFloat_sgAns z_sgAnt; } in
        let {
          sat_sgAnu [Occ=Once] :: a_agsyd
          [LclId] =
              [$dRealFloat_sgAns z_sgAnt] \u []
                  Data.Complex.magnitude $dRealFloat_sgAns z_sgAnt;
        } in  (,) [sat_sgAnu sat_sgAnv];

Data.Complex.$fFloatingComplex1 :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.D#! [0.0##];

Data.Complex.$fFloatingComplex_$s$cpi
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [GHC.Float.$fFloatingDouble_$cpi
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$w$cpi [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => (# a, a #)
[GblId,
 Arity=1,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)S(LSLLLLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A),1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [w_sgAnw]
        case GHC.Float.$p2RealFloat w_sgAnw of sat_sgAnx {
          __DEFAULT ->
              case GHC.Float.pi sat_sgAnx of dt_sgAny {
                __DEFAULT ->
                    case GHC.Float.$p1RealFloat w_sgAnw of sat_sgAnz {
                      __DEFAULT ->
                          case GHC.Real.$p1RealFrac sat_sgAnz of sat_sgAnA {
                            __DEFAULT ->
                                case GHC.Real.$p1Real sat_sgAnA of sat_sgAnB {
                                  __DEFAULT ->
                                      case
                                          GHC.Num.fromInteger
                                              sat_sgAnB Data.Complex.$fFloatingComplex17
                                      of
                                      dt1_sgAnC
                                      { __DEFAULT -> (#,#) [dt_sgAny dt1_sgAnC];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cpi [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => Data.Complex.Complex a
[GblId,
 Arity=1,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)S(LSLLLLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAnD]
        case Data.Complex.$w$cpi w_sgAnD of {
          (#,#) ww1_sgAnF [Occ=Once] ww2_sgAnG [Occ=Once] ->
              Data.Complex.:+ [ww1_sgAnF ww2_sgAnG];
        };

Data.Complex.$fFloatingComplex_$s$cexp
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAnH]
        case ds_sgAnH of {
          Data.Complex.:+ x_sgAnJ [Occ=Once!] y_sgAnK [Occ=Once!] ->
              case x_sgAnJ of {
                GHC.Types.D# x1_sgAnM [Occ=Once] ->
                    case y_sgAnK of {
                      GHC.Types.D# x2_sgAnO ->
                          case expDouble# [x1_sgAnM] of expx_sgAnP {
                            __DEFAULT ->
                                case sinDouble# [x2_sgAnO] of sat_sgAnT {
                                  __DEFAULT ->
                                      case *## [expx_sgAnP sat_sgAnT] of sat_sgAnU {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAnV [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgAnU];
                                            } in 
                                              case cosDouble# [x2_sgAnO] of sat_sgAnQ {
                                                __DEFAULT ->
                                                    case *## [expx_sgAnP sat_sgAnQ] of sat_sgAnR {
                                                      __DEFAULT ->
                                                          let {
                                                            sat_sgAnS [Occ=Once] :: GHC.Types.Double
                                                            [LclId] =
                                                                CCCS GHC.Types.D#! [sat_sgAnR];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgAnS sat_sgAnV];
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$cexp [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAnW ww_sgAnX ww1_sgAnY]
        case
            GHC.Float.$p1RealFloat w_sgAnW
        of
        $dRealFrac_sgAnZ [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAnZ
              of
              $dReal_sgAo0 [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAo0
                    of
                    $dNum_sgAo1 [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dFloating_sgAo2 [Dmd=<L,U(A,A,1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
                              :: GHC.Float.Floating a_sgxyP
                            [LclId] =
                                [w_sgAnW] \u [] GHC.Float.$p2RealFloat w_sgAnW; } in
                          let {
                            expx_sgAo3 :: a_sgxyP
                            [LclId] =
                                [ww_sgAnX $dFloating_sgAo2] \u []
                                    GHC.Float.exp $dFloating_sgAo2 ww_sgAnX; } in
                          let {
                            sat_sgAo4 [Occ=Once] :: a_sgxyP
                            [LclId] =
                                [ww1_sgAnY $dFloating_sgAo2] \u []
                                    GHC.Float.cos $dFloating_sgAo2 ww1_sgAnY;
                          } in 
                            case GHC.Num.* $dNum_sgAo1 expx_sgAo3 sat_sgAo4 of dt_sgAo5 {
                              __DEFAULT ->
                                  let {
                                    sat_sgAo6 [Occ=Once] :: a_sgxyP
                                    [LclId] =
                                        [ww1_sgAnY $dFloating_sgAo2] \u []
                                            GHC.Float.sin $dFloating_sgAo2 ww1_sgAnY;
                                  } in 
                                    case GHC.Num.* $dNum_sgAo1 expx_sgAo3 sat_sgAo6 of dt1_sgAo7 {
                                      __DEFAULT -> (#,#) [dt_sgAo5 dt1_sgAo7];
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cexp [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAo8 w1_sgAo9]
        case w1_sgAo9 of {
          Data.Complex.:+ ww1_sgAob [Occ=Once] ww2_sgAoc [Occ=Once] ->
              case Data.Complex.$w$cexp w_sgAo8 ww1_sgAob ww2_sgAoc of {
                (#,#) ww4_sgAoe [Occ=Once] ww5_sgAof [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAoe ww5_sgAof];
              };
        };

Data.Complex.$fFloatingComplex_$s$clog [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAog]
        case w_sgAog of {
          Data.Complex.:+ ww1_sgAoi [Occ=Once!] ww2_sgAoj [Occ=Once!] ->
              case ww1_sgAoi of {
                GHC.Types.D# ww4_sgAol ->
                    case ww2_sgAoj of {
                      GHC.Types.D# ww6_sgAon ->
                          case Data.Complex.$w$smagnitude ww4_sgAol ww6_sgAon of ww7_sgAoo {
                            __DEFAULT ->
                                case logDouble# [ww7_sgAoo] of wild1_sgAop {
                                  __DEFAULT ->
                                      case Data.Complex.$w$sphase ww4_sgAol ww6_sgAon of ww8_sgAoq {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAos [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [ww8_sgAoq]; } in
                                            let {
                                              sat_sgAor [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [wild1_sgAop];
                                            } in  Data.Complex.:+ [sat_sgAor sat_sgAos];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$clog [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAot ww_sgAou ww1_sgAov]
        let {
          sat_sgAox [Occ=Once] :: a_sgxzj
          [LclId] =
              [w_sgAot ww_sgAou ww1_sgAov] \u []
                  Data.Complex.$wmagnitude w_sgAot ww_sgAou ww1_sgAov;
        } in 
          case GHC.Float.$p2RealFloat w_sgAot of sat_sgAow {
            __DEFAULT ->
                case GHC.Float.log sat_sgAow sat_sgAox of dt_sgAoy {
                  __DEFAULT ->
                      case Data.Complex.$wphase w_sgAot ww_sgAou ww1_sgAov of dt1_sgAoz {
                        __DEFAULT -> (#,#) [dt_sgAoy dt1_sgAoz];
                      };
                };
          };

Data.Complex.$fFloatingComplex_$clog [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAoA w1_sgAoB]
        case w1_sgAoB of {
          Data.Complex.:+ ww1_sgAoD [Occ=Once] ww2_sgAoE [Occ=Once] ->
              case Data.Complex.$w$clog w_sgAoA ww1_sgAoD ww2_sgAoE of {
                (#,#) ww4_sgAoG [Occ=Once] ww5_sgAoH [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAoG ww5_sgAoH];
              };
        };

Data.Complex.$fFloatingComplex_$s$csin
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAoI]
        case ds_sgAoI of {
          Data.Complex.:+ x_sgAoK [Occ=Once!] y_sgAoL [Occ=Once!] ->
              case y_sgAoL of {
                GHC.Types.D# x1_sgAoN ->
                    case x_sgAoK of {
                      GHC.Types.D# x2_sgAoP ->
                          case sinhDouble# [x1_sgAoN] of sat_sgAoV {
                            __DEFAULT ->
                                case cosDouble# [x2_sgAoP] of sat_sgAoU {
                                  __DEFAULT ->
                                      case *## [sat_sgAoU sat_sgAoV] of sat_sgAoW {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAoX [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgAoW];
                                            } in 
                                              case coshDouble# [x1_sgAoN] of sat_sgAoR {
                                                __DEFAULT ->
                                                    case sinDouble# [x2_sgAoP] of sat_sgAoQ {
                                                      __DEFAULT ->
                                                          case
                                                              *## [sat_sgAoQ sat_sgAoR]
                                                          of
                                                          sat_sgAoS
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgAoT [Occ=Once]
                                                                    :: GHC.Types.Double
                                                                  [LclId] =
                                                                      CCCS GHC.Types.D#! [sat_sgAoS];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgAoT
                                                                                   sat_sgAoX];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$csin [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAoY ww_sgAoZ ww1_sgAp0]
        let {
          $dFloating_sgAp1 [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxzv
          [LclId] =
              [w_sgAoY] \u [] GHC.Float.$p2RealFloat w_sgAoY;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgAoY
          of
          $dRealFrac_sgAp2 [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgAp2
                of
                $dReal_sgAp3 [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgAp3
                      of
                      $dNum_sgAp4 [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgAp6 [Occ=Once] :: a_sgxzv
                              [LclId] =
                                  [ww1_sgAp0 $dFloating_sgAp1] \u []
                                      GHC.Float.cosh $dFloating_sgAp1 ww1_sgAp0; } in
                            let {
                              sat_sgAp5 [Occ=Once] :: a_sgxzv
                              [LclId] =
                                  [ww_sgAoZ $dFloating_sgAp1] \u []
                                      GHC.Float.sin $dFloating_sgAp1 ww_sgAoZ;
                            } in 
                              case GHC.Num.* $dNum_sgAp4 sat_sgAp5 sat_sgAp6 of dt_sgAp7 {
                                __DEFAULT ->
                                    let {
                                      sat_sgAp9 [Occ=Once] :: a_sgxzv
                                      [LclId] =
                                          [ww1_sgAp0 $dFloating_sgAp1] \u []
                                              GHC.Float.sinh $dFloating_sgAp1 ww1_sgAp0; } in
                                    let {
                                      sat_sgAp8 [Occ=Once] :: a_sgxzv
                                      [LclId] =
                                          [ww_sgAoZ $dFloating_sgAp1] \u []
                                              GHC.Float.cos $dFloating_sgAp1 ww_sgAoZ;
                                    } in 
                                      case GHC.Num.* $dNum_sgAp4 sat_sgAp8 sat_sgAp9 of dt1_sgApa {
                                        __DEFAULT -> (#,#) [dt_sgAp7 dt1_sgApa];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$csin [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgApb w1_sgApc]
        case w1_sgApc of {
          Data.Complex.:+ ww1_sgApe [Occ=Once] ww2_sgApf [Occ=Once] ->
              case Data.Complex.$w$csin w_sgApb ww1_sgApe ww2_sgApf of {
                (#,#) ww4_sgAph [Occ=Once] ww5_sgApi [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAph ww5_sgApi];
              };
        };

Data.Complex.$fFloatingComplex_$s$ccos
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgApj]
        case ds_sgApj of {
          Data.Complex.:+ x_sgApl [Occ=Once!] y_sgApm [Occ=Once!] ->
              case y_sgApm of {
                GHC.Types.D# x1_sgApo ->
                    case x_sgApl of {
                      GHC.Types.D# x2_sgApq ->
                          case sinhDouble# [x1_sgApo] of sat_sgApw {
                            __DEFAULT ->
                                case sinDouble# [x2_sgApq] of sat_sgApv {
                                  __DEFAULT ->
                                      case *## [sat_sgApv sat_sgApw] of sat_sgApx {
                                        __DEFAULT ->
                                            case negateDouble# [sat_sgApx] of sat_sgApy {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgApz [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [sat_sgApy];
                                                  } in 
                                                    case coshDouble# [x1_sgApo] of sat_sgAps {
                                                      __DEFAULT ->
                                                          case cosDouble# [x2_sgApq] of sat_sgApr {
                                                            __DEFAULT ->
                                                                case
                                                                    *## [sat_sgApr sat_sgAps]
                                                                of
                                                                sat_sgApt
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_sgApu [Occ=Once]
                                                                          :: GHC.Types.Double
                                                                        [LclId] =
                                                                            CCCS GHC.Types.D#! [sat_sgApt];
                                                                      } in 
                                                                        Data.Complex.:+ [sat_sgApu
                                                                                         sat_sgApz];
                                                                };
                                                          };
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ccos [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgApA ww_sgApB ww1_sgApC]
        let {
          $dFloating_sgApD [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxzH
          [LclId] =
              [w_sgApA] \u [] GHC.Float.$p2RealFloat w_sgApA;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgApA
          of
          $dRealFrac_sgApE [Dmd=<S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgApE
                of
                $dReal_sgApF [Dmd=<S(S(LLC(C(S))C(S)LLL)LL),1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgApF
                      of
                      $dNum_sgApG [Dmd=<S(LLC(C(S))C(S)LLL),U(A,A,C(C1(U)),1*C1(U),A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgApI [Occ=Once] :: a_sgxzH
                              [LclId] =
                                  [ww1_sgApC $dFloating_sgApD] \u []
                                      GHC.Float.cosh $dFloating_sgApD ww1_sgApC; } in
                            let {
                              sat_sgApH [Occ=Once] :: a_sgxzH
                              [LclId] =
                                  [ww_sgApB $dFloating_sgApD] \u []
                                      GHC.Float.cos $dFloating_sgApD ww_sgApB;
                            } in 
                              case GHC.Num.* $dNum_sgApG sat_sgApH sat_sgApI of dt_sgApJ {
                                __DEFAULT ->
                                    let {
                                      sat_sgApM [Occ=Once] :: a_sgxzH
                                      [LclId] =
                                          [ww_sgApB ww1_sgApC $dFloating_sgApD $dNum_sgApG] \u []
                                              let {
                                                sat_sgApL [Occ=Once] :: a_sgxzH
                                                [LclId] =
                                                    [ww1_sgApC $dFloating_sgApD] \u []
                                                        GHC.Float.sinh
                                                            $dFloating_sgApD ww1_sgApC; } in
                                              let {
                                                sat_sgApK [Occ=Once] :: a_sgxzH
                                                [LclId] =
                                                    [ww_sgApB $dFloating_sgApD] \u []
                                                        GHC.Float.sin $dFloating_sgApD ww_sgApB;
                                              } in  GHC.Num.* $dNum_sgApG sat_sgApK sat_sgApL;
                                    } in 
                                      case GHC.Num.negate $dNum_sgApG sat_sgApM of dt1_sgApN {
                                        __DEFAULT -> (#,#) [dt_sgApJ dt1_sgApN];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$ccos [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),C(U),A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgApO w1_sgApP]
        case w1_sgApP of {
          Data.Complex.:+ ww1_sgApR [Occ=Once] ww2_sgApS [Occ=Once] ->
              case Data.Complex.$w$ccos w_sgApO ww1_sgApR ww2_sgApS of {
                (#,#) ww4_sgApU [Occ=Once] ww5_sgApV [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgApU ww5_sgApV];
              };
        };

Data.Complex.$fFloatingComplex_$s$csinh
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgApW]
        case ds_sgApW of {
          Data.Complex.:+ x_sgApY [Occ=Once!] y_sgApZ [Occ=Once!] ->
              case x_sgApY of {
                GHC.Types.D# x1_sgAq1 ->
                    case y_sgApZ of {
                      GHC.Types.D# x2_sgAq3 ->
                          case coshDouble# [x1_sgAq1] of sat_sgAq9 {
                            __DEFAULT ->
                                case sinDouble# [x2_sgAq3] of sat_sgAq8 {
                                  __DEFAULT ->
                                      case *## [sat_sgAq8 sat_sgAq9] of sat_sgAqa {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAqb [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgAqa];
                                            } in 
                                              case sinhDouble# [x1_sgAq1] of sat_sgAq5 {
                                                __DEFAULT ->
                                                    case cosDouble# [x2_sgAq3] of sat_sgAq4 {
                                                      __DEFAULT ->
                                                          case
                                                              *## [sat_sgAq4 sat_sgAq5]
                                                          of
                                                          sat_sgAq6
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgAq7 [Occ=Once]
                                                                    :: GHC.Types.Double
                                                                  [LclId] =
                                                                      CCCS GHC.Types.D#! [sat_sgAq6];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgAq7
                                                                                   sat_sgAqb];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$csinh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAqc ww_sgAqd ww1_sgAqe]
        let {
          $dFloating_sgAqf [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxzT
          [LclId] =
              [w_sgAqc] \u [] GHC.Float.$p2RealFloat w_sgAqc;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgAqc
          of
          $dRealFrac_sgAqg [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgAqg
                of
                $dReal_sgAqh [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgAqh
                      of
                      $dNum_sgAqi [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgAqk [Occ=Once] :: a_sgxzT
                              [LclId] =
                                  [ww_sgAqd $dFloating_sgAqf] \u []
                                      GHC.Float.sinh $dFloating_sgAqf ww_sgAqd; } in
                            let {
                              sat_sgAqj [Occ=Once] :: a_sgxzT
                              [LclId] =
                                  [ww1_sgAqe $dFloating_sgAqf] \u []
                                      GHC.Float.cos $dFloating_sgAqf ww1_sgAqe;
                            } in 
                              case GHC.Num.* $dNum_sgAqi sat_sgAqj sat_sgAqk of dt_sgAql {
                                __DEFAULT ->
                                    let {
                                      sat_sgAqn [Occ=Once] :: a_sgxzT
                                      [LclId] =
                                          [ww_sgAqd $dFloating_sgAqf] \u []
                                              GHC.Float.cosh $dFloating_sgAqf ww_sgAqd; } in
                                    let {
                                      sat_sgAqm [Occ=Once] :: a_sgxzT
                                      [LclId] =
                                          [ww1_sgAqe $dFloating_sgAqf] \u []
                                              GHC.Float.sin $dFloating_sgAqf ww1_sgAqe;
                                    } in 
                                      case GHC.Num.* $dNum_sgAqi sat_sgAqm sat_sgAqn of dt1_sgAqo {
                                        __DEFAULT -> (#,#) [dt_sgAql dt1_sgAqo];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$csinh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAqp w1_sgAqq]
        case w1_sgAqq of {
          Data.Complex.:+ ww1_sgAqs [Occ=Once] ww2_sgAqt [Occ=Once] ->
              case Data.Complex.$w$csinh w_sgAqp ww1_sgAqs ww2_sgAqt of {
                (#,#) ww4_sgAqv [Occ=Once] ww5_sgAqw [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAqv ww5_sgAqw];
              };
        };

Data.Complex.$fFloatingComplex_$s$ccosh
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAqx]
        case ds_sgAqx of {
          Data.Complex.:+ x_sgAqz [Occ=Once!] y_sgAqA [Occ=Once!] ->
              case x_sgAqz of {
                GHC.Types.D# x1_sgAqC ->
                    case y_sgAqA of {
                      GHC.Types.D# x2_sgAqE ->
                          case sinhDouble# [x1_sgAqC] of sat_sgAqK {
                            __DEFAULT ->
                                case sinDouble# [x2_sgAqE] of sat_sgAqJ {
                                  __DEFAULT ->
                                      case *## [sat_sgAqJ sat_sgAqK] of sat_sgAqL {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAqM [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgAqL];
                                            } in 
                                              case coshDouble# [x1_sgAqC] of sat_sgAqG {
                                                __DEFAULT ->
                                                    case cosDouble# [x2_sgAqE] of sat_sgAqF {
                                                      __DEFAULT ->
                                                          case
                                                              *## [sat_sgAqF sat_sgAqG]
                                                          of
                                                          sat_sgAqH
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgAqI [Occ=Once]
                                                                    :: GHC.Types.Double
                                                                  [LclId] =
                                                                      CCCS GHC.Types.D#! [sat_sgAqH];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgAqI
                                                                                   sat_sgAqM];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ccosh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAqN ww_sgAqO ww1_sgAqP]
        let {
          $dFloating_sgAqQ [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxA5
          [LclId] =
              [w_sgAqN] \u [] GHC.Float.$p2RealFloat w_sgAqN;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgAqN
          of
          $dRealFrac_sgAqR [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgAqR
                of
                $dReal_sgAqS [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgAqS
                      of
                      $dNum_sgAqT [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgAqV [Occ=Once] :: a_sgxA5
                              [LclId] =
                                  [ww_sgAqO $dFloating_sgAqQ] \u []
                                      GHC.Float.cosh $dFloating_sgAqQ ww_sgAqO; } in
                            let {
                              sat_sgAqU [Occ=Once] :: a_sgxA5
                              [LclId] =
                                  [ww1_sgAqP $dFloating_sgAqQ] \u []
                                      GHC.Float.cos $dFloating_sgAqQ ww1_sgAqP;
                            } in 
                              case GHC.Num.* $dNum_sgAqT sat_sgAqU sat_sgAqV of dt_sgAqW {
                                __DEFAULT ->
                                    let {
                                      sat_sgAqY [Occ=Once] :: a_sgxA5
                                      [LclId] =
                                          [ww_sgAqO $dFloating_sgAqQ] \u []
                                              GHC.Float.sinh $dFloating_sgAqQ ww_sgAqO; } in
                                    let {
                                      sat_sgAqX [Occ=Once] :: a_sgxA5
                                      [LclId] =
                                          [ww1_sgAqP $dFloating_sgAqQ] \u []
                                              GHC.Float.sin $dFloating_sgAqQ ww1_sgAqP;
                                    } in 
                                      case GHC.Num.* $dNum_sgAqT sat_sgAqX sat_sgAqY of dt1_sgAqZ {
                                        __DEFAULT -> (#,#) [dt_sgAqW dt1_sgAqZ];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$ccosh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAr0 w1_sgAr1]
        case w1_sgAr1 of {
          Data.Complex.:+ ww1_sgAr3 [Occ=Once] ww2_sgAr4 [Occ=Once] ->
              case Data.Complex.$w$ccosh w_sgAr0 ww1_sgAr3 ww2_sgAr4 of {
                (#,#) ww4_sgAr6 [Occ=Once] ww5_sgAr7 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAr6 ww5_sgAr7];
              };
        };

Data.Complex.$w$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAr8 ww1_sgAr9 ww2_sgAra ww3_sgArb]
        case GHC.Float.$w$cexponent ww2_sgAra of ww4_sgArc {
          __DEFAULT ->
              case GHC.Float.$w$cexponent ww3_sgArb of ww5_sgArd {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgAre [Occ=Once*!T[1], Dmd=<C(S),1*C1(U(U,U))>]
                        :: GHC.Prim.Int# -> (# GHC.Types.Double, GHC.Types.Double #)
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgAr8 ww1_sgAr9 ww2_sgAra ww3_sgArb] \r [ww6_sgArf]
                              case GHC.Float.$w$cscaleFloat ww6_sgArf ww2_sgAra of ww7_sgArg {
                                __DEFAULT ->
                                    case GHC.Float.$w$cscaleFloat ww6_sgArf ww3_sgArb of ww8_sgArh {
                                      __DEFAULT ->
                                          case *## [ww3_sgArb ww8_sgArh] of sat_sgArk {
                                            __DEFAULT ->
                                                case *## [ww2_sgAra ww7_sgArg] of sat_sgArj {
                                                  __DEFAULT ->
                                                      case
                                                          +## [sat_sgArj sat_sgArk]
                                                      of
                                                      y_sgAri [Dmd=<S,U>]
                                                      { __DEFAULT ->
                                                            case
                                                                *## [ww1_sgAr9 ww8_sgArh]
                                                            of
                                                            sat_sgArm
                                                            { __DEFAULT ->
                                                                  case
                                                                      *## [ww_sgAr8 ww7_sgArg]
                                                                  of
                                                                  sat_sgArl
                                                                  { __DEFAULT ->
                                                                        case
                                                                            +## [sat_sgArl
                                                                                 sat_sgArm]
                                                                        of
                                                                        sat_sgArn
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  /## [sat_sgArn
                                                                                       y_sgAri]
                                                                              of
                                                                              wild2_sgAro
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        *## [ww_sgAr8
                                                                                             ww8_sgArh]
                                                                                    of
                                                                                    sat_sgArq
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              *## [ww1_sgAr9
                                                                                                   ww7_sgArg]
                                                                                          of
                                                                                          sat_sgArp
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    -## [sat_sgArp
                                                                                                         sat_sgArq]
                                                                                                of
                                                                                                sat_sgArr
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          /## [sat_sgArr
                                                                                                               y_sgAri]
                                                                                                      of
                                                                                                      wild1_sgArs
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgAru [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [wild1_sgArs]; } in
                                                                                                            let {
                                                                                                              sat_sgArt [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [wild2_sgAro];
                                                                                                            } in 
                                                                                                              (#,#) [sat_sgArt
                                                                                                                     sat_sgAru];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww4_sgArc ww5_sgArd] of {
                        __DEFAULT ->
                            case negateInt# [ww4_sgArc] of sat_sgArw {
                              __DEFAULT -> $j_sgAre sat_sgArw;
                            };
                        1# ->
                            case negateInt# [ww5_sgArd] of sat_sgArx {
                              __DEFAULT -> $j_sgAre sat_sgArx;
                            };
                      };
              };
        };

Data.Complex.$fFloatingComplex_$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAry w1_sgArz]
        case w_sgAry of {
          Data.Complex.:+ ww1_sgArB [Occ=Once!] ww2_sgArC [Occ=Once!] ->
              case ww1_sgArB of {
                GHC.Types.D# ww4_sgArE [Occ=Once] ->
                    case ww2_sgArC of {
                      GHC.Types.D# ww6_sgArG [Occ=Once] ->
                          case w1_sgArz of {
                            Data.Complex.:+ ww8_sgArI [Occ=Once!] ww9_sgArJ [Occ=Once!] ->
                                case ww8_sgArI of {
                                  GHC.Types.D# ww11_sgArL [Occ=Once] ->
                                      case ww9_sgArJ of {
                                        GHC.Types.D# ww13_sgArN [Occ=Once] ->
                                            case
                                                Data.Complex.$w$s$c/
                                                    ww4_sgArE ww6_sgArG ww11_sgArL ww13_sgArN
                                            of
                                            { (#,#) ww15_sgArP [Occ=Once] ww16_sgArQ [Occ=Once] ->
                                                  Data.Complex.:+ [ww15_sgArP ww16_sgArQ];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgArR ww_sgArS ww1_sgArT ww2_sgArU ww3_sgArV]
        case
            GHC.Float.$p1RealFloat w_sgArR
        of
        $dRealFrac_sgArW [Dmd=<S(LS(LC(C(S))LL)LLLLL),U(1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p2RealFrac $dRealFrac_sgArW
              of
              $dFractional_sgArX [Dmd=<S(LC(C(S))LL),U(A,C(C1(U)),A,A)>]
              { __DEFAULT ->
                    let {
                      $dReal_sgArY [Occ=OnceL,
                                    Dmd=<L,1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
                        :: GHC.Real.Real a_sgxAO
                      [LclId] =
                          [$dRealFrac_sgArW] \s []
                              GHC.Real.$p1RealFrac $dRealFrac_sgArW; } in
                    let {
                      $dNum_sgArZ [Dmd=<L,U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
                        :: GHC.Num.Num a_sgxAO
                      [LclId] =
                          [$dReal_sgArY] \u [] GHC.Real.$p1Real $dReal_sgArY; } in
                    let {
                      k_sgAs0 :: GHC.Types.Int
                      [LclId] =
                          [w_sgArR ww2_sgArU ww3_sgArV] \u []
                              case GHC.Float.exponent w_sgArR ww2_sgArU of {
                                GHC.Types.I# x1_sgAs2 ->
                                    case GHC.Float.exponent w_sgArR ww3_sgArV of {
                                      GHC.Types.I# y1_sgAs4 ->
                                          case <=# [x1_sgAs2 y1_sgAs4] of {
                                            __DEFAULT ->
                                                case negateInt# [x1_sgAs2] of sat_sgAs6 {
                                                  __DEFAULT -> GHC.Types.I# [sat_sgAs6];
                                                };
                                            1# ->
                                                case negateInt# [y1_sgAs4] of sat_sgAs7 {
                                                  __DEFAULT -> GHC.Types.I# [sat_sgAs7];
                                                };
                                          };
                                    };
                              }; } in
                    let {
                      y''_sgAs8 :: a_sgxAO
                      [LclId] =
                          [w_sgArR ww3_sgArV k_sgAs0] \u []
                              GHC.Float.scaleFloat w_sgArR k_sgAs0 ww3_sgArV; } in
                    let {
                      x''_sgAs9 :: a_sgxAO
                      [LclId] =
                          [w_sgArR ww2_sgArU k_sgAs0] \u []
                              GHC.Float.scaleFloat w_sgArR k_sgAs0 ww2_sgArU; } in
                    let {
                      d_sgAsa :: a_sgxAO
                      [LclId] =
                          [ww2_sgArU ww3_sgArV $dNum_sgArZ y''_sgAs8 x''_sgAs9] \u []
                              let {
                                sat_sgAsc [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww3_sgArV $dNum_sgArZ y''_sgAs8] \u []
                                        GHC.Num.* $dNum_sgArZ ww3_sgArV y''_sgAs8; } in
                              let {
                                sat_sgAsb [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww2_sgArU $dNum_sgArZ x''_sgAs9] \u []
                                        GHC.Num.* $dNum_sgArZ ww2_sgArU x''_sgAs9;
                              } in  GHC.Num.+ $dNum_sgArZ sat_sgAsb sat_sgAsc; } in
                    let {
                      sat_sgAsf [Occ=Once] :: a_sgxAO
                      [LclId] =
                          [ww_sgArS ww1_sgArT $dNum_sgArZ y''_sgAs8 x''_sgAs9] \u []
                              let {
                                sat_sgAse [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww1_sgArT $dNum_sgArZ y''_sgAs8] \u []
                                        GHC.Num.* $dNum_sgArZ ww1_sgArT y''_sgAs8; } in
                              let {
                                sat_sgAsd [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww_sgArS $dNum_sgArZ x''_sgAs9] \u []
                                        GHC.Num.* $dNum_sgArZ ww_sgArS x''_sgAs9;
                              } in  GHC.Num.+ $dNum_sgArZ sat_sgAsd sat_sgAse;
                    } in 
                      case GHC.Real./ $dFractional_sgArX sat_sgAsf d_sgAsa of dt_sgAsg {
                        __DEFAULT ->
                            let {
                              sat_sgAsj [Occ=Once] :: a_sgxAO
                              [LclId] =
                                  [ww_sgArS ww1_sgArT $dNum_sgArZ y''_sgAs8 x''_sgAs9] \u []
                                      let {
                                        sat_sgAsi [Occ=Once] :: a_sgxAO
                                        [LclId] =
                                            [ww_sgArS $dNum_sgArZ y''_sgAs8] \u []
                                                GHC.Num.* $dNum_sgArZ ww_sgArS y''_sgAs8; } in
                                      let {
                                        sat_sgAsh [Occ=Once] :: a_sgxAO
                                        [LclId] =
                                            [ww1_sgArT $dNum_sgArZ x''_sgAs9] \u []
                                                GHC.Num.* $dNum_sgArZ ww1_sgArT x''_sgAs9;
                                      } in  GHC.Num.- $dNum_sgArZ sat_sgAsh sat_sgAsi;
                            } in 
                              case GHC.Real./ $dFractional_sgArX sat_sgAsj d_sgAsa of dt1_sgAsk {
                                __DEFAULT -> (#,#) [dt_sgAsg dt1_sgAsk];
                              };
                      };
              };
        };

Data.Complex.$fFloatingComplex_$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAsl w1_sgAsm w2_sgAsn]
        case w1_sgAsm of {
          Data.Complex.:+ ww1_sgAsp [Occ=Once] ww2_sgAsq [Occ=Once] ->
              case w2_sgAsn of {
                Data.Complex.:+ ww4_sgAss [Occ=Once] ww5_sgAst [Occ=Once] ->
                    case
                        Data.Complex.$w$c/ w_sgAsl ww1_sgAsp ww2_sgAsq ww4_sgAss ww5_sgAst
                    of
                    { (#,#) ww7_sgAsv [Occ=Once] ww8_sgAsw [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgAsv ww8_sgAsw];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromRational
  :: GHC.Real.Rational -> Data.Complex.Complex GHC.Types.Double
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [a_sgAsx]
        case a_sgAsx of {
          GHC.Real.:% n_sgAsz [Occ=Once] d_sgAsA [Occ=Once] ->
              case GHC.Float.rationalToDouble n_sgAsz d_sgAsA of dt_sgAsB {
                GHC.Types.D# _ [Occ=Dead] ->
                    Data.Complex.:+ [dt_sgAsB Data.Complex.$fFloatingComplex1];
              };
        };

Data.Complex.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.Rational -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAsD w1_sgAsE]
        case
            GHC.Float.$p1RealFloat w_sgAsD
        of
        $dRealFrac_sgAsF [Dmd=<S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A)>]
        { __DEFAULT ->
              case GHC.Real.$p2RealFrac $dRealFrac_sgAsF of sat_sgAsG {
                __DEFAULT ->
                    case GHC.Real.fromRational sat_sgAsG w1_sgAsE of dt_sgAsH {
                      __DEFAULT ->
                          case GHC.Real.$p1RealFrac $dRealFrac_sgAsF of sat_sgAsI {
                            __DEFAULT ->
                                case GHC.Real.$p1Real sat_sgAsI of sat_sgAsJ {
                                  __DEFAULT ->
                                      case
                                          GHC.Num.fromInteger
                                              sat_sgAsJ Data.Complex.$fFloatingComplex17
                                      of
                                      dt1_sgAsK
                                      { __DEFAULT -> (#,#) [dt_sgAsH dt1_sgAsK];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFractionalComplex_$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.Rational -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgAsL w1_sgAsM]
        case Data.Complex.$w$cfromRational w_sgAsL w1_sgAsM of {
          (#,#) ww1_sgAsO [Occ=Once] ww2_sgAsP [Occ=Once] ->
              Data.Complex.:+ [ww1_sgAsO ww2_sgAsP];
        };

Data.Complex.$fFloatingComplex_$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAsQ w1_sgAsR]
        case w_sgAsQ of {
          Data.Complex.:+ ww1_sgAsT [Occ=Once!] ww2_sgAsU [Occ=Once!] ->
              case ww1_sgAsT of {
                GHC.Types.D# ww4_sgAsW [Occ=Once] ->
                    case ww2_sgAsU of {
                      GHC.Types.D# ww6_sgAsY [Occ=Once] ->
                          case w1_sgAsR of {
                            Data.Complex.:+ ww8_sgAt0 [Occ=Once!] ww9_sgAt1 [Occ=Once!] ->
                                case ww8_sgAt0 of {
                                  GHC.Types.D# ww11_sgAt3 [Occ=Once] ->
                                      case ww9_sgAt1 of {
                                        GHC.Types.D# ww13_sgAt5 [Occ=Once] ->
                                            case +## [ww6_sgAsY ww13_sgAt5] of sat_sgAt8 {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAt9 [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [sat_sgAt8];
                                                  } in 
                                                    case +## [ww4_sgAsW ww11_sgAt3] of sat_sgAt6 {
                                                      __DEFAULT ->
                                                          let {
                                                            sat_sgAt7 [Occ=Once] :: GHC.Types.Double
                                                            [LclId] =
                                                                CCCS GHC.Types.D#! [sat_sgAt6];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgAt7 sat_sgAt9];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))LLLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAta ww_sgAtb ww1_sgAtc ww2_sgAtd ww3_sgAte]
        case
            GHC.Float.$p1RealFloat w_sgAta
        of
        $dRealFrac_sgAtf [Dmd=<S(S(S(C(C(S))LLLLLL)LL)LLLLLL),1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAtf
              of
              $dReal_sgAtg [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAtg
                    of
                    $dNum_sgAth [Dmd=<S(C(C(S))LLLLLL),U(C(C1(U)),A,A,A,A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.+ $dNum_sgAth ww_sgAtb ww2_sgAtd of dt_sgAti {
                            __DEFAULT ->
                                case GHC.Num.+ $dNum_sgAth ww1_sgAtc ww3_sgAte of dt1_sgAtj {
                                  __DEFAULT -> (#,#) [dt_sgAti dt1_sgAtj];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))LLLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAtk w1_sgAtl w2_sgAtm]
        case w1_sgAtl of {
          Data.Complex.:+ ww1_sgAto [Occ=Once] ww2_sgAtp [Occ=Once] ->
              case w2_sgAtm of {
                Data.Complex.:+ ww4_sgAtr [Occ=Once] ww5_sgAts [Occ=Once] ->
                    case
                        Data.Complex.$w$c+ w_sgAtk ww1_sgAto ww2_sgAtp ww4_sgAtr ww5_sgAts
                    of
                    { (#,#) ww7_sgAtu [Occ=Once] ww8_sgAtv [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgAtu ww8_sgAtv];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c- [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAtw w1_sgAtx]
        case w_sgAtw of {
          Data.Complex.:+ ww1_sgAtz [Occ=Once!] ww2_sgAtA [Occ=Once!] ->
              case ww1_sgAtz of {
                GHC.Types.D# ww4_sgAtC [Occ=Once] ->
                    case ww2_sgAtA of {
                      GHC.Types.D# ww6_sgAtE [Occ=Once] ->
                          case w1_sgAtx of {
                            Data.Complex.:+ ww8_sgAtG [Occ=Once!] ww9_sgAtH [Occ=Once!] ->
                                case ww8_sgAtG of {
                                  GHC.Types.D# ww11_sgAtJ [Occ=Once] ->
                                      case ww9_sgAtH of {
                                        GHC.Types.D# ww13_sgAtL [Occ=Once] ->
                                            case -## [ww6_sgAtE ww13_sgAtL] of sat_sgAtO {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAtP [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [sat_sgAtO];
                                                  } in 
                                                    case -## [ww4_sgAtC ww11_sgAtJ] of sat_sgAtM {
                                                      __DEFAULT ->
                                                          let {
                                                            sat_sgAtN [Occ=Once] :: GHC.Types.Double
                                                            [LclId] =
                                                                CCCS GHC.Types.D#! [sat_sgAtM];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgAtN sat_sgAtP];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAtQ ww_sgAtR ww1_sgAtS ww2_sgAtT ww3_sgAtU]
        case
            GHC.Float.$p1RealFloat w_sgAtQ
        of
        $dRealFrac_sgAtV [Dmd=<S(S(S(LC(C(S))LLLLL)LL)LLLLLL),1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAtV
              of
              $dReal_sgAtW [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAtW
                    of
                    $dNum_sgAtX [Dmd=<S(LC(C(S))LLLLL),U(A,C(C1(U)),A,A,A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.- $dNum_sgAtX ww_sgAtR ww2_sgAtT of dt_sgAtY {
                            __DEFAULT ->
                                case GHC.Num.- $dNum_sgAtX ww1_sgAtS ww3_sgAtU of dt1_sgAtZ {
                                  __DEFAULT -> (#,#) [dt_sgAtY dt1_sgAtZ];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAu0 w1_sgAu1 w2_sgAu2]
        case w1_sgAu1 of {
          Data.Complex.:+ ww1_sgAu4 [Occ=Once] ww2_sgAu5 [Occ=Once] ->
              case w2_sgAu2 of {
                Data.Complex.:+ ww4_sgAu7 [Occ=Once] ww5_sgAu8 [Occ=Once] ->
                    case
                        Data.Complex.$w$c- w_sgAu0 ww1_sgAu4 ww2_sgAu5 ww4_sgAu7 ww5_sgAu8
                    of
                    { (#,#) ww7_sgAua [Occ=Once] ww8_sgAub [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgAua ww8_sgAub];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c* [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAuc w1_sgAud]
        case w_sgAuc of {
          Data.Complex.:+ ww1_sgAuf [Occ=Once!] ww2_sgAug [Occ=Once!] ->
              case ww1_sgAuf of {
                GHC.Types.D# ww4_sgAui ->
                    case ww2_sgAug of {
                      GHC.Types.D# ww6_sgAuk ->
                          case w1_sgAud of {
                            Data.Complex.:+ ww8_sgAum [Occ=Once!] ww9_sgAun [Occ=Once!] ->
                                case ww8_sgAum of {
                                  GHC.Types.D# ww11_sgAup ->
                                      case ww9_sgAun of {
                                        GHC.Types.D# ww13_sgAur ->
                                            case *## [ww6_sgAuk ww11_sgAup] of sat_sgAux {
                                              __DEFAULT ->
                                                  case *## [ww4_sgAui ww13_sgAur] of sat_sgAuw {
                                                    __DEFAULT ->
                                                        case
                                                            +## [sat_sgAuw sat_sgAux]
                                                        of
                                                        sat_sgAuy
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_sgAuz [Occ=Once]
                                                                  :: GHC.Types.Double
                                                                [LclId] =
                                                                    CCCS GHC.Types.D#! [sat_sgAuy];
                                                              } in 
                                                                case
                                                                    *## [ww6_sgAuk ww13_sgAur]
                                                                of
                                                                sat_sgAut
                                                                { __DEFAULT ->
                                                                      case
                                                                          *## [ww4_sgAui ww11_sgAup]
                                                                      of
                                                                      sat_sgAus
                                                                      { __DEFAULT ->
                                                                            case
                                                                                -## [sat_sgAus
                                                                                     sat_sgAut]
                                                                            of
                                                                            sat_sgAuu
                                                                            { __DEFAULT ->
                                                                                  let {
                                                                                    sat_sgAuv [Occ=Once]
                                                                                      :: GHC.Types.Double
                                                                                    [LclId] =
                                                                                        CCCS GHC.Types.D#! [sat_sgAuu];
                                                                                  } in 
                                                                                    Data.Complex.:+ [sat_sgAuv
                                                                                                     sat_sgAuz];
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAuA ww_sgAuB ww1_sgAuC ww2_sgAuD ww3_sgAuE]
        case
            GHC.Float.$p1RealFloat w_sgAuA
        of
        $dRealFrac_sgAuF [Dmd=<S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL),1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAuF
              of
              $dReal_sgAuG [Dmd=<S(S(C(C(S))C(C(S))LLLLL)LL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAuG
                    of
                    $dNum_sgAuH [Dmd=<S(C(C(S))C(C(S))LLLLL),U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            sat_sgAuJ [Occ=Once] :: a_sgxDl
                            [LclId] =
                                [ww1_sgAuC ww3_sgAuE $dNum_sgAuH] \u []
                                    GHC.Num.* $dNum_sgAuH ww1_sgAuC ww3_sgAuE; } in
                          let {
                            sat_sgAuI [Occ=Once] :: a_sgxDl
                            [LclId] =
                                [ww_sgAuB ww2_sgAuD $dNum_sgAuH] \u []
                                    GHC.Num.* $dNum_sgAuH ww_sgAuB ww2_sgAuD;
                          } in 
                            case GHC.Num.- $dNum_sgAuH sat_sgAuI sat_sgAuJ of dt_sgAuK {
                              __DEFAULT ->
                                  let {
                                    sat_sgAuM [Occ=Once] :: a_sgxDl
                                    [LclId] =
                                        [ww1_sgAuC ww2_sgAuD $dNum_sgAuH] \u []
                                            GHC.Num.* $dNum_sgAuH ww1_sgAuC ww2_sgAuD; } in
                                  let {
                                    sat_sgAuL [Occ=Once] :: a_sgxDl
                                    [LclId] =
                                        [ww_sgAuB ww3_sgAuE $dNum_sgAuH] \u []
                                            GHC.Num.* $dNum_sgAuH ww_sgAuB ww3_sgAuE;
                                  } in 
                                    case GHC.Num.+ $dNum_sgAuH sat_sgAuL sat_sgAuM of dt1_sgAuN {
                                      __DEFAULT -> (#,#) [dt_sgAuK dt1_sgAuN];
                                    };
                            };
                    };
              };
        };

Data.Complex.$fNumComplex_$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAuO w1_sgAuP w2_sgAuQ]
        case w1_sgAuP of {
          Data.Complex.:+ ww1_sgAuS [Occ=Once] ww2_sgAuT [Occ=Once] ->
              case w2_sgAuQ of {
                Data.Complex.:+ ww4_sgAuV [Occ=Once] ww5_sgAuW [Occ=Once] ->
                    case
                        Data.Complex.$w$c* w_sgAuO ww1_sgAuS ww2_sgAuT ww4_sgAuV ww5_sgAuW
                    of
                    { (#,#) ww7_sgAuY [Occ=Once] ww8_sgAuZ [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgAuY ww8_sgAuZ];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cnegate
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAv0]
        case ds_sgAv0 of {
          Data.Complex.:+ x_sgAv2 [Occ=Once!] y_sgAv3 [Occ=Once!] ->
              case x_sgAv2 of {
                GHC.Types.D# x1_sgAv5 [Occ=Once] ->
                    case y_sgAv3 of {
                      GHC.Types.D# x2_sgAv7 [Occ=Once] ->
                          case negateDouble# [x2_sgAv7] of sat_sgAva {
                            __DEFAULT ->
                                let {
                                  sat_sgAvb [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [sat_sgAva];
                                } in 
                                  case negateDouble# [x1_sgAv5] of sat_sgAv8 {
                                    __DEFAULT ->
                                        let {
                                          sat_sgAv9 [Occ=Once] :: GHC.Types.Double
                                          [LclId] =
                                              CCCS GHC.Types.D#! [sat_sgAv8];
                                        } in  Data.Complex.:+ [sat_sgAv9 sat_sgAvb];
                                  };
                          };
                    };
              };
        };

Data.Complex.$w$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLLC(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAvc ww_sgAvd ww1_sgAve]
        case
            GHC.Float.$p1RealFloat w_sgAvc
        of
        $dRealFrac_sgAvf [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAvf
              of
              $dReal_sgAvg [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAvg
                    of
                    $dNum_sgAvh [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.negate $dNum_sgAvh ww_sgAvd of dt_sgAvi {
                            __DEFAULT ->
                                case GHC.Num.negate $dNum_sgAvh ww1_sgAve of dt1_sgAvj {
                                  __DEFAULT -> (#,#) [dt_sgAvi dt1_sgAvj];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLLC(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAvk w1_sgAvl]
        case w1_sgAvl of {
          Data.Complex.:+ ww1_sgAvn [Occ=Once] ww2_sgAvo [Occ=Once] ->
              case Data.Complex.$w$cnegate w_sgAvk ww1_sgAvn ww2_sgAvo of {
                (#,#) ww4_sgAvq [Occ=Once] ww5_sgAvr [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAvq ww5_sgAvr];
              };
        };

Data.Complex.$fFloatingComplex_$s$cabs
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [z_sgAvs]
        case z_sgAvs of {
          Data.Complex.:+ ww1_sgAvu [Occ=Once!] ww2_sgAvv [Occ=Once!] ->
              case ww1_sgAvu of {
                GHC.Types.D# ww4_sgAvx [Occ=Once] ->
                    case ww2_sgAvv of {
                      GHC.Types.D# ww6_sgAvz [Occ=Once] ->
                          case Data.Complex.$w$smagnitude ww4_sgAvx ww6_sgAvz of ww7_sgAvA {
                            __DEFAULT ->
                                let {
                                  sat_sgAvB [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [ww7_sgAvA];
                                } in  Data.Complex.:+ [sat_sgAvB Data.Complex.$fFloatingComplex1];
                          };
                    };
              };
        };

Data.Complex.$w$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,1*C1(U)),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAvC ww_sgAvD ww1_sgAvE]
        case
            Data.Complex.$wmagnitude w_sgAvC ww_sgAvD ww1_sgAvE
        of
        dt_sgAvF
        { __DEFAULT ->
              case GHC.Float.$p1RealFloat w_sgAvC of sat_sgAvG {
                __DEFAULT ->
                    case GHC.Real.$p1RealFrac sat_sgAvG of sat_sgAvH {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_sgAvH of sat_sgAvI {
                            __DEFAULT ->
                                case
                                    GHC.Num.fromInteger sat_sgAvI Data.Complex.$fFloatingComplex17
                                of
                                dt1_sgAvJ
                                { __DEFAULT -> (#,#) [dt_sgAvF dt1_sgAvJ];
                                };
                          };
                    };
              };
        };

Data.Complex.$fNumComplex_$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAvK w1_sgAvL]
        case w1_sgAvL of {
          Data.Complex.:+ ww1_sgAvN [Occ=Once] ww2_sgAvO [Occ=Once] ->
              case Data.Complex.$w$cabs w_sgAvK ww1_sgAvN ww2_sgAvO of {
                (#,#) ww4_sgAvQ [Occ=Once] ww5_sgAvR [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAvQ ww5_sgAvR];
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromInteger
  :: GHC.Integer.Type.Integer
     -> Data.Complex.Complex GHC.Types.Double
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [n_sgAvS]
        case GHC.Integer.Type.doubleFromInteger n_sgAvS of wild_sgAvT {
          __DEFAULT ->
              let {
                sat_sgAvU [Occ=Once] :: GHC.Types.Double
                [LclId] =
                    CCCS GHC.Types.D#! [wild_sgAvT];
              } in  Data.Complex.:+ [sat_sgAvU Data.Complex.$fFloatingComplex1];
        };

Data.Complex.$w$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Integer.Type.Integer -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAvV w1_sgAvW]
        case
            GHC.Float.$p1RealFloat w_sgAvV
        of
        $dRealFrac_sgAvX [Dmd=<S(S(S(LLLLLLC(S))LL)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAvX
              of
              $dReal_sgAvY [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAvY
                    of
                    $dNum_sgAvZ [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
                    { __DEFAULT ->
                          case GHC.Num.fromInteger $dNum_sgAvZ w1_sgAvW of dt_sgAw0 {
                            __DEFAULT ->
                                case
                                    GHC.Num.fromInteger $dNum_sgAvZ Data.Complex.$fFloatingComplex17
                                of
                                dt1_sgAw1
                                { __DEFAULT -> (#,#) [dt_sgAw0 dt1_sgAw1];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Integer.Type.Integer -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgAw2 w1_sgAw3]
        case Data.Complex.$w$cfromInteger w_sgAw2 w1_sgAw3 of {
          (#,#) ww1_sgAw5 [Occ=Once] ww2_sgAw6 [Occ=Once] ->
              Data.Complex.:+ [ww1_sgAw5 ww2_sgAw6];
        };

Data.Complex.$fFloatingComplex4
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex1
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$fFloatingComplex_$s$csignum [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAw7]
        case w_sgAw7 of {
          Data.Complex.:+ ww1_sgAw9 [Occ=Once!] ww2_sgAwa [Occ=Once!] ->
              case ww1_sgAw9 of {
                GHC.Types.D# ww4_sgAwc ->
                    case ww2_sgAwa of {
                      GHC.Types.D# ww6_sgAwe ->
                          case ==## [ww4_sgAwc 0.0##] of {
                            __DEFAULT ->
                                case Data.Complex.$w$smagnitude ww4_sgAwc ww6_sgAwe of ww7_sgAwg {
                                  __DEFAULT ->
                                      case /## [ww4_sgAwc ww7_sgAwg] of wild2_sgAwh {
                                        __DEFAULT ->
                                            case /## [ww6_sgAwe ww7_sgAwg] of wild1_sgAwi {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAwk [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [wild1_sgAwi]; } in
                                                  let {
                                                    sat_sgAwj [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [wild2_sgAwh];
                                                  } in  Data.Complex.:+ [sat_sgAwj sat_sgAwk];
                                            };
                                      };
                                };
                            1# ->
                                case ==## [ww6_sgAwe 0.0##] of {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$smagnitude ww4_sgAwc ww6_sgAwe
                                      of
                                      ww7_sgAwm
                                      { __DEFAULT ->
                                            case /## [ww4_sgAwc ww7_sgAwm] of wild2_sgAwn {
                                              __DEFAULT ->
                                                  case /## [ww6_sgAwe ww7_sgAwm] of wild1_sgAwo {
                                                    __DEFAULT ->
                                                        let {
                                                          sat_sgAwq [Occ=Once] :: GHC.Types.Double
                                                          [LclId] =
                                                              CCCS GHC.Types.D#! [wild1_sgAwo]; } in
                                                        let {
                                                          sat_sgAwp [Occ=Once] :: GHC.Types.Double
                                                          [LclId] =
                                                              CCCS GHC.Types.D#! [wild2_sgAwn];
                                                        } in  Data.Complex.:+ [sat_sgAwp sat_sgAwq];
                                                  };
                                            };
                                      };
                                  1# -> Data.Complex.$fFloatingComplex4;
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex12
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex9
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$fFloatingComplex_$s$csignum1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAwr]
        case w_sgAwr of {
          Data.Complex.:+ ww1_sgAwt [Occ=Once!] ww2_sgAwu [Occ=Once!] ->
              case ww1_sgAwt of {
                GHC.Types.F# ww4_sgAww ->
                    case ww2_sgAwu of {
                      GHC.Types.F# ww6_sgAwy ->
                          case eqFloat# [ww4_sgAww 0.0#] of {
                            __DEFAULT ->
                                case Data.Complex.$w$smagnitude1 ww4_sgAww ww6_sgAwy of ww7_sgAwA {
                                  __DEFAULT ->
                                      case divideFloat# [ww4_sgAww ww7_sgAwA] of wild2_sgAwB {
                                        __DEFAULT ->
                                            case divideFloat# [ww6_sgAwy ww7_sgAwA] of wild1_sgAwC {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAwE [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [wild1_sgAwC]; } in
                                                  let {
                                                    sat_sgAwD [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [wild2_sgAwB];
                                                  } in  Data.Complex.:+ [sat_sgAwD sat_sgAwE];
                                            };
                                      };
                                };
                            1# ->
                                case eqFloat# [ww6_sgAwy 0.0#] of {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$smagnitude1 ww4_sgAww ww6_sgAwy
                                      of
                                      ww7_sgAwG
                                      { __DEFAULT ->
                                            case divideFloat# [ww4_sgAww ww7_sgAwG] of wild2_sgAwH {
                                              __DEFAULT ->
                                                  case
                                                      divideFloat# [ww6_sgAwy ww7_sgAwG]
                                                  of
                                                  wild1_sgAwI
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_sgAwK [Occ=Once] :: GHC.Types.Float
                                                          [LclId] =
                                                              CCCS GHC.Types.F#! [wild1_sgAwI]; } in
                                                        let {
                                                          sat_sgAwJ [Occ=Once] :: GHC.Types.Float
                                                          [LclId] =
                                                              CCCS GHC.Types.F#! [wild2_sgAwH];
                                                        } in  Data.Complex.:+ [sat_sgAwJ sat_sgAwK];
                                                  };
                                            };
                                      };
                                  1# -> Data.Complex.$fFloatingComplex12;
                                };
                          };
                    };
              };
        };

Data.Complex.$w$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAwL ww_sgAwM ww1_sgAwN]
        case
            GHC.Float.$p1RealFloat w_sgAwL
        of
        $dRealFrac_sgAwO [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAwO
              of
              $dReal_sgAwP [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      $dNum_sgAwQ [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_sgxEJ
                      [LclId] =
                          [$dReal_sgAwP] \u [] GHC.Real.$p1Real $dReal_sgAwP;
                    } in 
                      case
                          GHC.Real.$p2Real $dReal_sgAwP
                      of
                      $dOrd_sgAwR [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                      { __DEFAULT ->
                            case
                                GHC.Classes.$p1Ord $dOrd_sgAwR
                            of
                            $dEq_sgAwS [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                            { __DEFAULT ->
                                  let {
                                    sat_sgAwZ [Occ=Once] :: a_sgxEJ
                                    [LclId] =
                                        [$dNum_sgAwQ] \u []
                                            GHC.Num.fromInteger
                                                $dNum_sgAwQ Data.Complex.$fFloatingComplex17;
                                  } in 
                                    let-no-escape {
                                      fail_sgAwT [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> (# a_sgxEJ, a_sgxEJ #)
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [w_sgAwL
                                                    ww_sgAwM
                                                    ww1_sgAwN
                                                    $dRealFrac_sgAwO] \r [ds_sgAwU]
                                              case
                                                  GHC.Real.$p2RealFrac $dRealFrac_sgAwO
                                              of
                                              $dFractional_sgAwV [Dmd=<S(LC(C(S))LL),U(A,C(C1(U)),A,A)>]
                                              { __DEFAULT ->
                                                    let {
                                                      r_sgAwW :: a_sgxEJ
                                                      [LclId] =
                                                          [w_sgAwL ww_sgAwM ww1_sgAwN] \u []
                                                              Data.Complex.$wmagnitude
                                                                  w_sgAwL ww_sgAwM ww1_sgAwN;
                                                    } in 
                                                      case
                                                          GHC.Real./
                                                              $dFractional_sgAwV ww_sgAwM r_sgAwW
                                                      of
                                                      dt_sgAwX
                                                      { __DEFAULT ->
                                                            case
                                                                GHC.Real./
                                                                    $dFractional_sgAwV
                                                                    ww1_sgAwN
                                                                    r_sgAwW
                                                            of
                                                            dt1_sgAwY
                                                            { __DEFAULT ->
                                                                  (#,#) [dt_sgAwX dt1_sgAwY];
                                                            };
                                                      };
                                              };
                                    } in 
                                      case GHC.Classes.== $dEq_sgAwS ww_sgAwM sat_sgAwZ of {
                                        GHC.Types.False -> fail_sgAwT GHC.Prim.void#;
                                        GHC.Types.True ->
                                            let {
                                              sat_sgAx1 [Occ=Once] :: a_sgxEJ
                                              [LclId] =
                                                  [$dNum_sgAwQ] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_sgAwQ
                                                          Data.Complex.$fFloatingComplex17;
                                            } in 
                                              case
                                                  GHC.Classes.== $dEq_sgAwS ww1_sgAwN sat_sgAx1
                                              of
                                              { GHC.Types.False -> fail_sgAwT GHC.Prim.void#;
                                                GHC.Types.True ->
                                                    Data.Complex.$w$cfromInteger
                                                        w_sgAwL Data.Complex.$fFloatingComplex17;
                                              };
                                      };
                            };
                      };
              };
        };

Data.Complex.$fNumComplex_$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAx3 w1_sgAx4]
        case w1_sgAx4 of {
          Data.Complex.:+ ww1_sgAx6 [Occ=Once] ww2_sgAx7 [Occ=Once] ->
              case Data.Complex.$w$csignum w_sgAx3 ww1_sgAx6 ww2_sgAx7 of {
                (#,#) ww4_sgAx9 [Occ=Once] ww5_sgAxa [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAx9 ww5_sgAxa];
              };
        };

Data.Complex.$fFloatingComplex_$s$fNumComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Num.Num (Data.Complex.Complex GHC.Types.Double)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Num.C:Num! [Data.Complex.$fFloatingComplex_$s$c+
                                  Data.Complex.$fFloatingComplex_$s$c-
                                  Data.Complex.$fFloatingComplex_$s$c*
                                  Data.Complex.$fFloatingComplex_$s$cnegate
                                  Data.Complex.$fFloatingComplex_$s$cabs
                                  Data.Complex.$fFloatingComplex_$s$csignum
                                  Data.Complex.$fFloatingComplex_$s$cfromInteger];

Data.Complex.$fFloatingComplex_$s$fNumComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Num.Num (Data.Complex.Complex GHC.Types.Float)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Num.C:Num! [Data.Complex.$fFloatingComplex_$s$c+1
                                  Data.Complex.$fFloatingComplex_$s$c-1
                                  Data.Complex.$fFloatingComplex_$s$c*1
                                  Data.Complex.$fFloatingComplex_$s$cnegate1
                                  Data.Complex.$fFloatingComplex_$s$cabs1
                                  Data.Complex.$fFloatingComplex_$s$csignum1
                                  Data.Complex.$fFloatingComplex_$s$cfromInteger1];

Data.Complex.$fNumComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Num.Num (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dRealFloat_sgAxb]
        let {
          sat_sgAxi [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cfromInteger
                      $dRealFloat_sgAxb eta_B1; } in
        let {
          sat_sgAxh [Occ=Once]
            :: Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B1]
                  Data.Complex.$fNumComplex_$csignum $dRealFloat_sgAxb eta_B1; } in
        let {
          sat_sgAxg [Occ=Once]
            :: Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B1]
                  Data.Complex.$fNumComplex_$cabs $dRealFloat_sgAxb eta_B1; } in
        let {
          sat_sgAxf [Occ=Once]
            :: Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cnegate
                      $dRealFloat_sgAxb eta_B1; } in
        let {
          sat_sgAxe [Occ=Once]
            :: Data.Complex.Complex a_agt1x
               -> Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B2 eta_B1]
                  Data.Complex.$fNumComplex_$c* $dRealFloat_sgAxb eta_B2 eta_B1; } in
        let {
          sat_sgAxd [Occ=Once]
            :: Data.Complex.Complex a_agt1x
               -> Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c-
                      $dRealFloat_sgAxb eta_B2 eta_B1; } in
        let {
          sat_sgAxc [Occ=Once]
            :: Data.Complex.Complex a_agt1x
               -> Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c+ $dRealFloat_sgAxb eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [sat_sgAxc
                         sat_sgAxd
                         sat_sgAxe
                         sat_sgAxf
                         sat_sgAxg
                         sat_sgAxh
                         sat_sgAxi];

Data.Complex.$w$s$csqrt1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAxj ww1_sgAxk]
        let-no-escape {
          fail_sgAxl [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> (# GHC.Types.Float, GHC.Types.Float #)
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [ww_sgAxj ww1_sgAxk] \r [ds_sgAxm]
                  case ltFloat# [ww_sgAxj 0.0#] of {
                    __DEFAULT ->
                        case Data.Complex.$w$smagnitude1 ww_sgAxj ww1_sgAxk of ww2_sgAxo {
                          __DEFAULT ->
                              case fabsFloat# [ww_sgAxj] of sat_sgAxq {
                                __DEFAULT ->
                                    case plusFloat# [ww2_sgAxo sat_sgAxq] of sat_sgAxr {
                                      __DEFAULT ->
                                          case divideFloat# [sat_sgAxr 2.0#] of sat_sgAxs {
                                            __DEFAULT ->
                                                case
                                                    sqrtFloat# [sat_sgAxs]
                                                of
                                                ipv_sgAxp [Dmd=<S,U>]
                                                { __DEFAULT ->
                                                      case ltFloat# [ww1_sgAxk 0.0#] of {
                                                        __DEFAULT ->
                                                            case
                                                                plusFloat# [ipv_sgAxp ipv_sgAxp]
                                                            of
                                                            sat_sgAxv
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsFloat# [ww1_sgAxk]
                                                                  of
                                                                  sat_sgAxu
                                                                  { __DEFAULT ->
                                                                        case
                                                                            divideFloat# [sat_sgAxu
                                                                                          sat_sgAxv]
                                                                        of
                                                                        wild2_sgAxw
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgAxy [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [wild2_sgAxw]; } in
                                                                              let {
                                                                                sat_sgAxx [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [ipv_sgAxp];
                                                                              } in 
                                                                                (#,#) [sat_sgAxx
                                                                                       sat_sgAxy];
                                                                        };
                                                                  };
                                                            };
                                                        1# ->
                                                            case
                                                                plusFloat# [ipv_sgAxp ipv_sgAxp]
                                                            of
                                                            sat_sgAxA
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsFloat# [ww1_sgAxk]
                                                                  of
                                                                  sat_sgAxz
                                                                  { __DEFAULT ->
                                                                        case
                                                                            divideFloat# [sat_sgAxz
                                                                                          sat_sgAxA]
                                                                        of
                                                                        wild2_sgAxB
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  negateFloat# [wild2_sgAxB]
                                                                              of
                                                                              sat_sgAxD
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgAxE [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [sat_sgAxD]; } in
                                                                                    let {
                                                                                      sat_sgAxC [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [ipv_sgAxp];
                                                                                    } in 
                                                                                      (#,#) [sat_sgAxC
                                                                                             sat_sgAxE];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                    1# ->
                        case Data.Complex.$w$smagnitude1 ww_sgAxj ww1_sgAxk of ww2_sgAxF {
                          __DEFAULT ->
                              case fabsFloat# [ww_sgAxj] of sat_sgAxH {
                                __DEFAULT ->
                                    case plusFloat# [ww2_sgAxF sat_sgAxH] of sat_sgAxI {
                                      __DEFAULT ->
                                          case divideFloat# [sat_sgAxI 2.0#] of sat_sgAxJ {
                                            __DEFAULT ->
                                                case sqrtFloat# [sat_sgAxJ] of x_sgAxG [Dmd=<S,U>] {
                                                  __DEFAULT ->
                                                      case
                                                          plusFloat# [x_sgAxG x_sgAxG]
                                                      of
                                                      sat_sgAxL
                                                      { __DEFAULT ->
                                                            case
                                                                fabsFloat# [ww1_sgAxk]
                                                            of
                                                            sat_sgAxK
                                                            { __DEFAULT ->
                                                                  case
                                                                      divideFloat# [sat_sgAxK
                                                                                    sat_sgAxL]
                                                                  of
                                                                  wild2_sgAxM
                                                                  { __DEFAULT ->
                                                                        case
                                                                            ltFloat# [ww1_sgAxk
                                                                                      0.0#]
                                                                        of
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgAxP [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [x_sgAxG]; } in
                                                                              let {
                                                                                sat_sgAxO [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [wild2_sgAxM];
                                                                              } in 
                                                                                (#,#) [sat_sgAxO
                                                                                       sat_sgAxP];
                                                                          1# ->
                                                                              case
                                                                                  negateFloat# [x_sgAxG]
                                                                              of
                                                                              sat_sgAxR
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgAxS [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [sat_sgAxR]; } in
                                                                                    let {
                                                                                      sat_sgAxQ [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [wild2_sgAxM];
                                                                                    } in 
                                                                                      (#,#) [sat_sgAxQ
                                                                                             sat_sgAxS];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case eqFloat# [ww_sgAxj 0.0#] of {
            __DEFAULT -> fail_sgAxl GHC.Prim.void#;
            1# ->
                case eqFloat# [ww1_sgAxk 0.0#] of {
                  __DEFAULT -> fail_sgAxl GHC.Prim.void#;
                  1# ->
                      (#,#) [Data.Complex.$fFloatingComplex9
                             Data.Complex.$fFloatingComplex9];
                };
          };

Data.Complex.$fFloatingComplex_$s$csqrt1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAxV]
        case w_sgAxV of {
          Data.Complex.:+ ww1_sgAxX [Occ=Once!] ww2_sgAxY [Occ=Once!] ->
              case ww1_sgAxX of {
                GHC.Types.F# ww4_sgAy0 [Occ=Once] ->
                    case ww2_sgAxY of {
                      GHC.Types.F# ww6_sgAy2 [Occ=Once] ->
                          case Data.Complex.$w$s$csqrt1 ww4_sgAy0 ww6_sgAy2 of {
                            (#,#) ww8_sgAy4 [Occ=Once] ww9_sgAy5 [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAy4 ww9_sgAy5];
                          };
                    };
              };
        };

Data.Complex.$w$s$csqrt [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAy6 ww1_sgAy7]
        let-no-escape {
          fail_sgAy8 [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> (# GHC.Types.Double, GHC.Types.Double #)
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [ww_sgAy6 ww1_sgAy7] \r [ds_sgAy9]
                  case <## [ww_sgAy6 0.0##] of {
                    __DEFAULT ->
                        case Data.Complex.$w$smagnitude ww_sgAy6 ww1_sgAy7 of ww2_sgAyb {
                          __DEFAULT ->
                              case fabsDouble# [ww_sgAy6] of sat_sgAyd {
                                __DEFAULT ->
                                    case +## [ww2_sgAyb sat_sgAyd] of sat_sgAye {
                                      __DEFAULT ->
                                          case /## [sat_sgAye 2.0##] of sat_sgAyf {
                                            __DEFAULT ->
                                                case
                                                    sqrtDouble# [sat_sgAyf]
                                                of
                                                ipv_sgAyc [Dmd=<S,U>]
                                                { __DEFAULT ->
                                                      case <## [ww1_sgAy7 0.0##] of {
                                                        __DEFAULT ->
                                                            case
                                                                +## [ipv_sgAyc ipv_sgAyc]
                                                            of
                                                            sat_sgAyi
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsDouble# [ww1_sgAy7]
                                                                  of
                                                                  sat_sgAyh
                                                                  { __DEFAULT ->
                                                                        case
                                                                            /## [sat_sgAyh
                                                                                 sat_sgAyi]
                                                                        of
                                                                        wild2_sgAyj
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgAyl [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [wild2_sgAyj]; } in
                                                                              let {
                                                                                sat_sgAyk [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [ipv_sgAyc];
                                                                              } in 
                                                                                (#,#) [sat_sgAyk
                                                                                       sat_sgAyl];
                                                                        };
                                                                  };
                                                            };
                                                        1# ->
                                                            case
                                                                +## [ipv_sgAyc ipv_sgAyc]
                                                            of
                                                            sat_sgAyn
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsDouble# [ww1_sgAy7]
                                                                  of
                                                                  sat_sgAym
                                                                  { __DEFAULT ->
                                                                        case
                                                                            /## [sat_sgAym
                                                                                 sat_sgAyn]
                                                                        of
                                                                        wild2_sgAyo
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  negateDouble# [wild2_sgAyo]
                                                                              of
                                                                              sat_sgAyq
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgAyr [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [sat_sgAyq]; } in
                                                                                    let {
                                                                                      sat_sgAyp [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [ipv_sgAyc];
                                                                                    } in 
                                                                                      (#,#) [sat_sgAyp
                                                                                             sat_sgAyr];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                    1# ->
                        case Data.Complex.$w$smagnitude ww_sgAy6 ww1_sgAy7 of ww2_sgAys {
                          __DEFAULT ->
                              case fabsDouble# [ww_sgAy6] of sat_sgAyu {
                                __DEFAULT ->
                                    case +## [ww2_sgAys sat_sgAyu] of sat_sgAyv {
                                      __DEFAULT ->
                                          case /## [sat_sgAyv 2.0##] of sat_sgAyw {
                                            __DEFAULT ->
                                                case
                                                    sqrtDouble# [sat_sgAyw]
                                                of
                                                x_sgAyt [Dmd=<S,U>]
                                                { __DEFAULT ->
                                                      case +## [x_sgAyt x_sgAyt] of sat_sgAyy {
                                                        __DEFAULT ->
                                                            case
                                                                fabsDouble# [ww1_sgAy7]
                                                            of
                                                            sat_sgAyx
                                                            { __DEFAULT ->
                                                                  case
                                                                      /## [sat_sgAyx sat_sgAyy]
                                                                  of
                                                                  wild2_sgAyz
                                                                  { __DEFAULT ->
                                                                        case
                                                                            <## [ww1_sgAy7 0.0##]
                                                                        of
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgAyC [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [x_sgAyt]; } in
                                                                              let {
                                                                                sat_sgAyB [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [wild2_sgAyz];
                                                                              } in 
                                                                                (#,#) [sat_sgAyB
                                                                                       sat_sgAyC];
                                                                          1# ->
                                                                              case
                                                                                  negateDouble# [x_sgAyt]
                                                                              of
                                                                              sat_sgAyE
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgAyF [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [sat_sgAyE]; } in
                                                                                    let {
                                                                                      sat_sgAyD [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [wild2_sgAyz];
                                                                                    } in 
                                                                                      (#,#) [sat_sgAyD
                                                                                             sat_sgAyF];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case ==## [ww_sgAy6 0.0##] of {
            __DEFAULT -> fail_sgAy8 GHC.Prim.void#;
            1# ->
                case ==## [ww1_sgAy7 0.0##] of {
                  __DEFAULT -> fail_sgAy8 GHC.Prim.void#;
                  1# ->
                      (#,#) [Data.Complex.$fFloatingComplex1
                             Data.Complex.$fFloatingComplex1];
                };
          };

Data.Complex.$fFloatingComplex_$s$csqrt [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAyI]
        case w_sgAyI of {
          Data.Complex.:+ ww1_sgAyK [Occ=Once!] ww2_sgAyL [Occ=Once!] ->
              case ww1_sgAyK of {
                GHC.Types.D# ww4_sgAyN [Occ=Once] ->
                    case ww2_sgAyL of {
                      GHC.Types.D# ww6_sgAyP [Occ=Once] ->
                          case Data.Complex.$w$s$csqrt ww4_sgAyN ww6_sgAyP of {
                            (#,#) ww8_sgAyR [Occ=Once] ww9_sgAyS [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAyR ww9_sgAyS];
                          };
                    };
              };
        };

sat_sgAyT :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_sgAyU :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgAyT GHC.Types.[]];

Data.Complex.$fFloatingComplex21 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgAyU;

Data.Complex.$w$csqrt [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAyV ww_sgAyW ww1_sgAyX]
        case
            GHC.Float.$p1RealFloat w_sgAyV
        of
        $dRealFrac_sgAyY [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAyY
              of
              $dReal_sgAyZ [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p2Real $dReal_sgAyZ
                    of
                    $dOrd_sgAz0 [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dNum_sgAz1 [Dmd=<L,U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U))>]
                              :: GHC.Num.Num a_sgxFA
                            [LclId] =
                                [$dReal_sgAyZ] \u [] GHC.Real.$p1Real $dReal_sgAyZ;
                          } in 
                            case
                                GHC.Classes.$p1Ord $dOrd_sgAz0
                            of
                            $dEq_sgAz2 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                            { __DEFAULT ->
                                  let {
                                    sat_sgAzr [Occ=Once] :: a_sgxFA
                                    [LclId] =
                                        [$dNum_sgAz1] \u []
                                            GHC.Num.fromInteger
                                                $dNum_sgAz1 Data.Complex.$fFloatingComplex17;
                                  } in 
                                    let-no-escape {
                                      fail_sgAz3 [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> (# a_sgxFA, a_sgxFA #)
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [w_sgAyV
                                                    ww_sgAyW
                                                    ww1_sgAyX
                                                    $dRealFrac_sgAyY
                                                    $dOrd_sgAz0
                                                    $dNum_sgAz1] \r [ds_sgAz4]
                                              let {
                                                $dFractional_sgAz5 [Dmd=<L,U(A,C(C1(U)),A,A)>]
                                                  :: GHC.Real.Fractional a_sgxFA
                                                [LclId] =
                                                    [$dRealFrac_sgAyY] \u []
                                                        GHC.Real.$p2RealFrac $dRealFrac_sgAyY; } in
                                              let {
                                                u'_sgAz6 :: a_sgxFA
                                                [LclId] =
                                                    [w_sgAyV
                                                     ww_sgAyW
                                                     ww1_sgAyX
                                                     $dNum_sgAz1
                                                     $dFractional_sgAz5] \u []
                                                        let {
                                                          sat_sgAzc [Occ=Once] :: a_sgxFA
                                                          [LclId] =
                                                              [w_sgAyV
                                                               ww_sgAyW
                                                               ww1_sgAyX
                                                               $dNum_sgAz1
                                                               $dFractional_sgAz5] \u []
                                                                  let {
                                                                    sat_sgAzb [Occ=Once] :: a_sgxFA
                                                                    [LclId] =
                                                                        [$dNum_sgAz1] \u []
                                                                            GHC.Num.fromInteger
                                                                                $dNum_sgAz1
                                                                                Data.Complex.$fFloatingComplex21; } in
                                                                  let {
                                                                    sat_sgAza [Occ=Once] :: a_sgxFA
                                                                    [LclId] =
                                                                        [w_sgAyV
                                                                         ww_sgAyW
                                                                         ww1_sgAyX
                                                                         $dNum_sgAz1] \u []
                                                                            let {
                                                                              sat_sgAz9 [Occ=Once]
                                                                                :: a_sgxFA
                                                                              [LclId] =
                                                                                  [ww_sgAyW
                                                                                   $dNum_sgAz1] \u []
                                                                                      GHC.Num.abs
                                                                                          $dNum_sgAz1
                                                                                          ww_sgAyW; } in
                                                                            let {
                                                                              sat_sgAz8 [Occ=Once]
                                                                                :: a_sgxFA
                                                                              [LclId] =
                                                                                  [w_sgAyV
                                                                                   ww_sgAyW
                                                                                   ww1_sgAyX] \u []
                                                                                      Data.Complex.$wmagnitude
                                                                                          w_sgAyV
                                                                                          ww_sgAyW
                                                                                          ww1_sgAyX;
                                                                            } in 
                                                                              GHC.Num.+
                                                                                  $dNum_sgAz1
                                                                                  sat_sgAz8
                                                                                  sat_sgAz9;
                                                                  } in 
                                                                    GHC.Real./
                                                                        $dFractional_sgAz5
                                                                        sat_sgAza
                                                                        sat_sgAzb;
                                                        } in 
                                                          case
                                                              GHC.Float.$p2RealFloat w_sgAyV
                                                          of
                                                          sat_sgAz7
                                                          { __DEFAULT ->
                                                                GHC.Float.sqrt sat_sgAz7 sat_sgAzc;
                                                          }; } in
                                              let {
                                                v'_sgAzd [Occ=Once*] :: a_sgxFA
                                                [LclId] =
                                                    [ww1_sgAyX
                                                     $dNum_sgAz1
                                                     $dFractional_sgAz5
                                                     u'_sgAz6] \u []
                                                        let {
                                                          sat_sgAzg [Occ=Once] :: a_sgxFA
                                                          [LclId] =
                                                              [$dNum_sgAz1 u'_sgAz6] \u []
                                                                  let {
                                                                    sat_sgAzf [Occ=Once] :: a_sgxFA
                                                                    [LclId] =
                                                                        [$dNum_sgAz1] \u []
                                                                            GHC.Num.fromInteger
                                                                                $dNum_sgAz1
                                                                                Data.Complex.$fFloatingComplex21;
                                                                  } in 
                                                                    GHC.Num.*
                                                                        $dNum_sgAz1
                                                                        u'_sgAz6
                                                                        sat_sgAzf; } in
                                                        let {
                                                          sat_sgAze [Occ=Once] :: a_sgxFA
                                                          [LclId] =
                                                              [ww1_sgAyX $dNum_sgAz1] \u []
                                                                  GHC.Num.abs $dNum_sgAz1 ww1_sgAyX;
                                                        } in 
                                                          GHC.Real./
                                                              $dFractional_sgAz5
                                                              sat_sgAze
                                                              sat_sgAzg; } in
                                              let {
                                                sat_sgAzp [Occ=Once] :: a_sgxFA
                                                [LclId] =
                                                    [$dNum_sgAz1] \u []
                                                        GHC.Num.fromInteger
                                                            $dNum_sgAz1
                                                            Data.Complex.$fFloatingComplex17;
                                              } in 
                                                let-no-escape {
                                                  $j_sgAzh [Occ=Once*!T[2],
                                                            Dmd=<C(C(S)),1*C1(C1(U(U,U)))>]
                                                    :: a_sgxFA -> a_sgxFA -> (# a_sgxFA, a_sgxFA #)
                                                  [LclId[JoinId(2)],
                                                   Arity=2,
                                                   Str=<S,1*U><L,U>,
                                                   Unf=OtherCon []] =
                                                      sat-only [ww1_sgAyX
                                                                $dOrd_sgAz0
                                                                $dNum_sgAz1] \r [u_sgAzi v_sgAzj]
                                                          case u_sgAzi of dt_sgAzk {
                                                            __DEFAULT ->
                                                                let {
                                                                  sat_sgAzl [Occ=Once] :: a_sgxFA
                                                                  [LclId] =
                                                                      [$dNum_sgAz1] \u []
                                                                          GHC.Num.fromInteger
                                                                              $dNum_sgAz1
                                                                              Data.Complex.$fFloatingComplex17;
                                                                } in 
                                                                  case
                                                                      GHC.Classes.<
                                                                          $dOrd_sgAz0
                                                                          ww1_sgAyX
                                                                          sat_sgAzl
                                                                  of
                                                                  { GHC.Types.False ->
                                                                        case v_sgAzj of dt1_sgAzn {
                                                                          __DEFAULT ->
                                                                              (#,#) [dt_sgAzk
                                                                                     dt1_sgAzn];
                                                                        };
                                                                    GHC.Types.True ->
                                                                        case
                                                                            GHC.Num.negate
                                                                                $dNum_sgAz1 v_sgAzj
                                                                        of
                                                                        dt1_sgAzo
                                                                        { __DEFAULT ->
                                                                              (#,#) [dt_sgAzk
                                                                                     dt1_sgAzo];
                                                                        };
                                                                  };
                                                          };
                                                } in 
                                                  case
                                                      GHC.Classes.< $dOrd_sgAz0 ww_sgAyW sat_sgAzp
                                                  of
                                                  { GHC.Types.False -> $j_sgAzh u'_sgAz6 v'_sgAzd;
                                                    GHC.Types.True -> $j_sgAzh v'_sgAzd u'_sgAz6;
                                                  };
                                    } in 
                                      case GHC.Classes.== $dEq_sgAz2 ww_sgAyW sat_sgAzr of {
                                        GHC.Types.False -> fail_sgAz3 GHC.Prim.void#;
                                        GHC.Types.True ->
                                            let {
                                              sat_sgAzt [Occ=Once] :: a_sgxFA
                                              [LclId] =
                                                  [$dNum_sgAz1] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_sgAz1
                                                          Data.Complex.$fFloatingComplex17;
                                            } in 
                                              case
                                                  GHC.Classes.== $dEq_sgAz2 ww1_sgAyX sat_sgAzt
                                              of
                                              { GHC.Types.False -> fail_sgAz3 GHC.Prim.void#;
                                                GHC.Types.True ->
                                                    Data.Complex.$w$cfromInteger
                                                        w_sgAyV Data.Complex.$fFloatingComplex17;
                                              };
                                      };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$csqrt [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAzv w1_sgAzw]
        case w1_sgAzw of {
          Data.Complex.:+ ww1_sgAzy [Occ=Once] ww2_sgAzz [Occ=Once] ->
              case Data.Complex.$w$csqrt w_sgAzv ww1_sgAzy ww2_sgAzz of {
                (#,#) ww4_sgAzB [Occ=Once] ww5_sgAzC [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAzB ww5_sgAzC];
              };
        };

Data.Complex.$fFloatingComplex_$s$crecip [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAzD]
        case eta_sgAzD of {
          Data.Complex.:+ ww1_sgAzF [Occ=Once!] ww2_sgAzG [Occ=Once!] ->
              case ww1_sgAzF of {
                GHC.Types.D# ww4_sgAzI [Occ=Once] ->
                    case ww2_sgAzG of {
                      GHC.Types.D# ww6_sgAzK [Occ=Once] ->
                          case Data.Complex.$w$s$c/ 1.0## 0.0## ww4_sgAzI ww6_sgAzK of {
                            (#,#) ww8_sgAzM [Occ=Once] ww9_sgAzN [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAzM ww9_sgAzN];
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$crecip1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAzO]
        case eta_sgAzO of {
          Data.Complex.:+ ww1_sgAzQ [Occ=Once!] ww2_sgAzR [Occ=Once!] ->
              case ww1_sgAzQ of {
                GHC.Types.F# ww4_sgAzT [Occ=Once] ->
                    case ww2_sgAzR of {
                      GHC.Types.F# ww6_sgAzV [Occ=Once] ->
                          case Data.Complex.$w$s$c/1 1.0# 0.0# ww4_sgAzT ww6_sgAzV of {
                            (#,#) ww8_sgAzX [Occ=Once] ww9_sgAzY [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAzX ww9_sgAzY];
                          };
                    };
              };
        };

sat_sgAzZ :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sgAA0 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgAzZ GHC.Types.[]];

Data.Complex.$fFloatingComplex19 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgAA0;

Data.Complex.$fFractionalComplex_$crecip [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgAA1 eta_sgAA2]
        case
            Data.Complex.$w$cfromInteger
                $dRealFloat_sgAA1 Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww1_sgAA4 [Occ=Once] ww2_sgAA5 [Occ=Once] ->
              case eta_sgAA2 of {
                Data.Complex.:+ ww4_sgAA7 [Occ=Once] ww5_sgAA8 [Occ=Once] ->
                    case
                        Data.Complex.$w$c/
                            $dRealFloat_sgAA1 ww1_sgAA4 ww2_sgAA5 ww4_sgAA7 ww5_sgAA8
                    of
                    { (#,#) ww7_sgAAa [Occ=Once] ww8_sgAAb [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgAAa ww8_sgAAb];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$fFractionalComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Fractional (Data.Complex.Complex GHC.Types.Double)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Fractional! [Data.Complex.$fFloatingComplex_$s$fNumComplex
                                          Data.Complex.$fFloatingComplex_$s$c/
                                          Data.Complex.$fFloatingComplex_$s$crecip
                                          Data.Complex.$fFloatingComplex_$s$cfromRational];

Data.Complex.$fFloatingComplex_$s$fFractionalComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Fractional (Data.Complex.Complex GHC.Types.Float)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Fractional! [Data.Complex.$fFloatingComplex_$s$fNumComplex1
                                          Data.Complex.$fFloatingComplex_$s$c/1
                                          Data.Complex.$fFloatingComplex_$s$crecip1
                                          Data.Complex.$fFloatingComplex_$s$cfromRational1];

Data.Complex.$fFractionalComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.Fractional (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dRealFloat_sgAAc]
        let {
          sat_sgAAg [Occ=Once]
            :: GHC.Real.Rational -> Data.Complex.Complex a_agsZS
          [LclId] =
              [$dRealFloat_sgAAc] \r [eta_B1]
                  Data.Complex.$fFractionalComplex_$cfromRational
                      $dRealFloat_sgAAc eta_B1; } in
        let {
          sat_sgAAf [Occ=Once]
            :: Data.Complex.Complex a_agsZS -> Data.Complex.Complex a_agsZS
          [LclId] =
              [$dRealFloat_sgAAc] \r [eta_B1]
                  Data.Complex.$fFractionalComplex_$crecip
                      $dRealFloat_sgAAc eta_B1; } in
        let {
          sat_sgAAe [Occ=Once]
            :: Data.Complex.Complex a_agsZS
               -> Data.Complex.Complex a_agsZS -> Data.Complex.Complex a_agsZS
          [LclId] =
              [$dRealFloat_sgAAc] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c/
                      $dRealFloat_sgAAc eta_B2 eta_B1; } in
        let {
          sat_sgAAd [Occ=Once] :: GHC.Num.Num (Data.Complex.Complex a_agsZS)
          [LclId] =
              [$dRealFloat_sgAAc] \u []
                  Data.Complex.$fNumComplex $dRealFloat_sgAAc;
        } in 
          GHC.Real.C:Fractional [sat_sgAAd sat_sgAAe sat_sgAAf sat_sgAAg];

Data.Complex.$fFloatingComplex_$s$ctan1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAAh]
        case w_sgAAh of {
          Data.Complex.:+ ww1_sgAAj [Occ=Once!] ww2_sgAAk [Occ=Once!] ->
              case ww1_sgAAj of {
                GHC.Types.F# ww4_sgAAm ->
                    case ww2_sgAAk of {
                      GHC.Types.F# ww6_sgAAo ->
                          case coshFloat# [ww6_sgAAo] of coshy_sgAAp [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhFloat# [ww6_sgAAo] of sinhy_sgAAq [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosFloat# [ww4_sgAAm] of cosx_sgAAr [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinFloat# [ww4_sgAAm] of sinx_sgAAs [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [sinx_sgAAs sinhy_sgAAq]
                                                  of
                                                  sat_sgAAw
                                                  { __DEFAULT ->
                                                        case negateFloat# [sat_sgAAw] of sat_sgAAx {
                                                          __DEFAULT ->
                                                              case
                                                                  timesFloat# [cosx_sgAAr
                                                                               coshy_sgAAp]
                                                              of
                                                              sat_sgAAv
                                                              { __DEFAULT ->
                                                                    case
                                                                        timesFloat# [cosx_sgAAr
                                                                                     sinhy_sgAAq]
                                                                    of
                                                                    sat_sgAAu
                                                                    { __DEFAULT ->
                                                                          case
                                                                              timesFloat# [sinx_sgAAs
                                                                                           coshy_sgAAp]
                                                                          of
                                                                          sat_sgAAt
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/1
                                                                                        sat_sgAAt
                                                                                        sat_sgAAu
                                                                                        sat_sgAAv
                                                                                        sat_sgAAx
                                                                                of
                                                                                { (#,#) ww8_sgAAz [Occ=Once]
                                                                                        ww9_sgAAA [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww8_sgAAz
                                                                                                       ww9_sgAAA];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ctan [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAAB]
        case w_sgAAB of {
          Data.Complex.:+ ww1_sgAAD [Occ=Once!] ww2_sgAAE [Occ=Once!] ->
              case ww1_sgAAD of {
                GHC.Types.D# ww4_sgAAG ->
                    case ww2_sgAAE of {
                      GHC.Types.D# ww6_sgAAI ->
                          case coshDouble# [ww6_sgAAI] of coshy_sgAAJ [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhDouble# [ww6_sgAAI] of sinhy_sgAAK [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosDouble# [ww4_sgAAG] of cosx_sgAAL [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinDouble# [ww4_sgAAG] of sinx_sgAAM [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case *## [sinx_sgAAM sinhy_sgAAK] of sat_sgAAQ {
                                                    __DEFAULT ->
                                                        case
                                                            negateDouble# [sat_sgAAQ]
                                                        of
                                                        sat_sgAAR
                                                        { __DEFAULT ->
                                                              case
                                                                  *## [cosx_sgAAL coshy_sgAAJ]
                                                              of
                                                              sat_sgAAP
                                                              { __DEFAULT ->
                                                                    case
                                                                        *## [cosx_sgAAL sinhy_sgAAK]
                                                                    of
                                                                    sat_sgAAO
                                                                    { __DEFAULT ->
                                                                          case
                                                                              *## [sinx_sgAAM
                                                                                   coshy_sgAAJ]
                                                                          of
                                                                          sat_sgAAN
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/
                                                                                        sat_sgAAN
                                                                                        sat_sgAAO
                                                                                        sat_sgAAP
                                                                                        sat_sgAAR
                                                                                of
                                                                                { (#,#) ww8_sgAAT [Occ=Once]
                                                                                        ww9_sgAAU [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww8_sgAAT
                                                                                                       ww9_sgAAU];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ctan [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),1*C1(U),A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAAV ww_sgAAW ww1_sgAAX]
        case
            GHC.Float.$p1RealFloat w_sgAAV
        of
        $dRealFrac_sgAAY [Dmd=<S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAAY
              of
              $dReal_sgAAZ [Dmd=<S(S(LLC(C(S))C(S)LLL)LL),1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAAZ
                    of
                    $dNum_sgAB0 [Dmd=<S(LLC(C(S))C(S)LLL),U(A,A,C(C1(U)),1*C1(U),A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dFloating_sgAB1 [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
                              :: GHC.Float.Floating a_sgxGm
                            [LclId] =
                                [w_sgAAV] \u [] GHC.Float.$p2RealFloat w_sgAAV; } in
                          let {
                            coshy_sgAB2 :: a_sgxGm
                            [LclId] =
                                [ww1_sgAAX $dFloating_sgAB1] \u []
                                    GHC.Float.cosh $dFloating_sgAB1 ww1_sgAAX; } in
                          let {
                            sinx_sgAB3 :: a_sgxGm
                            [LclId] =
                                [ww_sgAAW $dFloating_sgAB1] \u []
                                    GHC.Float.sin $dFloating_sgAB1 ww_sgAAW;
                          } in 
                            case GHC.Num.* $dNum_sgAB0 sinx_sgAB3 coshy_sgAB2 of dt_sgAB4 {
                              __DEFAULT ->
                                  let {
                                    sinhy_sgAB5 :: a_sgxGm
                                    [LclId] =
                                        [ww1_sgAAX $dFloating_sgAB1] \u []
                                            GHC.Float.sinh $dFloating_sgAB1 ww1_sgAAX; } in
                                  let {
                                    cosx_sgAB6 :: a_sgxGm
                                    [LclId] =
                                        [ww_sgAAW $dFloating_sgAB1] \u []
                                            GHC.Float.cos $dFloating_sgAB1 ww_sgAAW;
                                  } in 
                                    case GHC.Num.* $dNum_sgAB0 cosx_sgAB6 sinhy_sgAB5 of dt1_sgAB7 {
                                      __DEFAULT ->
                                          case
                                              GHC.Num.* $dNum_sgAB0 cosx_sgAB6 coshy_sgAB2
                                          of
                                          dt2_sgAB8
                                          { __DEFAULT ->
                                                let {
                                                  sat_sgAB9 [Occ=Once] :: a_sgxGm
                                                  [LclId] =
                                                      [$dNum_sgAB0 sinx_sgAB3 sinhy_sgAB5] \u []
                                                          GHC.Num.*
                                                              $dNum_sgAB0 sinx_sgAB3 sinhy_sgAB5;
                                                } in 
                                                  case
                                                      GHC.Num.negate $dNum_sgAB0 sat_sgAB9
                                                  of
                                                  dt3_sgABa
                                                  { __DEFAULT ->
                                                        Data.Complex.$w$c/
                                                            w_sgAAV
                                                            dt_sgAB4
                                                            dt1_sgAB7
                                                            dt2_sgAB8
                                                            dt3_sgABa;
                                                  };
                                          };
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$ctan [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgABb w1_sgABc]
        case w1_sgABc of {
          Data.Complex.:+ ww1_sgABe [Occ=Once] ww2_sgABf [Occ=Once] ->
              case Data.Complex.$w$ctan w_sgABb ww1_sgABe ww2_sgABf of {
                (#,#) ww4_sgABh [Occ=Once] ww5_sgABi [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgABh ww5_sgABi];
              };
        };

Data.Complex.$fFloatingComplex_$s$ctanh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgABj]
        case w_sgABj of {
          Data.Complex.:+ ww1_sgABl [Occ=Once!] ww2_sgABm [Occ=Once!] ->
              case ww1_sgABl of {
                GHC.Types.F# ww4_sgABo ->
                    case ww2_sgABm of {
                      GHC.Types.F# ww6_sgABq ->
                          case coshFloat# [ww4_sgABo] of coshx_sgABr [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhFloat# [ww4_sgABo] of sinhx_sgABs [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosFloat# [ww6_sgABq] of cosy_sgABt [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinFloat# [ww6_sgABq] of siny_sgABu [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [siny_sgABu sinhx_sgABs]
                                                  of
                                                  sat_sgABy
                                                  { __DEFAULT ->
                                                        case
                                                            timesFloat# [cosy_sgABt coshx_sgABr]
                                                        of
                                                        sat_sgABx
                                                        { __DEFAULT ->
                                                              case
                                                                  timesFloat# [siny_sgABu
                                                                               coshx_sgABr]
                                                              of
                                                              sat_sgABw
                                                              { __DEFAULT ->
                                                                    case
                                                                        timesFloat# [cosy_sgABt
                                                                                     sinhx_sgABs]
                                                                    of
                                                                    sat_sgABv
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/1
                                                                                  sat_sgABv
                                                                                  sat_sgABw
                                                                                  sat_sgABx
                                                                                  sat_sgABy
                                                                          of
                                                                          { (#,#) ww8_sgABA [Occ=Once]
                                                                                  ww9_sgABB [Occ=Once] ->
                                                                                Data.Complex.:+ [ww8_sgABA
                                                                                                 ww9_sgABB];
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ctanh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgABC]
        case w_sgABC of {
          Data.Complex.:+ ww1_sgABE [Occ=Once!] ww2_sgABF [Occ=Once!] ->
              case ww1_sgABE of {
                GHC.Types.D# ww4_sgABH ->
                    case ww2_sgABF of {
                      GHC.Types.D# ww6_sgABJ ->
                          case coshDouble# [ww4_sgABH] of coshx_sgABK [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhDouble# [ww4_sgABH] of sinhx_sgABL [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosDouble# [ww6_sgABJ] of cosy_sgABM [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinDouble# [ww6_sgABJ] of siny_sgABN [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case *## [siny_sgABN sinhx_sgABL] of sat_sgABR {
                                                    __DEFAULT ->
                                                        case
                                                            *## [cosy_sgABM coshx_sgABK]
                                                        of
                                                        sat_sgABQ
                                                        { __DEFAULT ->
                                                              case
                                                                  *## [siny_sgABN coshx_sgABK]
                                                              of
                                                              sat_sgABP
                                                              { __DEFAULT ->
                                                                    case
                                                                        *## [cosy_sgABM sinhx_sgABL]
                                                                    of
                                                                    sat_sgABO
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/
                                                                                  sat_sgABO
                                                                                  sat_sgABP
                                                                                  sat_sgABQ
                                                                                  sat_sgABR
                                                                          of
                                                                          { (#,#) ww8_sgABT [Occ=Once]
                                                                                  ww9_sgABU [Occ=Once] ->
                                                                                Data.Complex.:+ [ww8_sgABT
                                                                                                 ww9_sgABU];
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ctanh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgABV ww_sgABW ww1_sgABX]
        case
            GHC.Float.$p1RealFloat w_sgABV
        of
        $dRealFrac_sgABY [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgABY
              of
              $dReal_sgABZ [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgABZ
                    of
                    $dNum_sgAC0 [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dFloating_sgAC1 [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
                              :: GHC.Float.Floating a_sgxH8
                            [LclId] =
                                [w_sgABV] \u [] GHC.Float.$p2RealFloat w_sgABV; } in
                          let {
                            sinhx_sgAC2 :: a_sgxH8
                            [LclId] =
                                [ww_sgABW $dFloating_sgAC1] \u []
                                    GHC.Float.sinh $dFloating_sgAC1 ww_sgABW; } in
                          let {
                            cosy_sgAC3 :: a_sgxH8
                            [LclId] =
                                [ww1_sgABX $dFloating_sgAC1] \u []
                                    GHC.Float.cos $dFloating_sgAC1 ww1_sgABX;
                          } in 
                            case GHC.Num.* $dNum_sgAC0 cosy_sgAC3 sinhx_sgAC2 of dt_sgAC4 {
                              __DEFAULT ->
                                  let {
                                    coshx_sgAC5 :: a_sgxH8
                                    [LclId] =
                                        [ww_sgABW $dFloating_sgAC1] \u []
                                            GHC.Float.cosh $dFloating_sgAC1 ww_sgABW; } in
                                  let {
                                    siny_sgAC6 :: a_sgxH8
                                    [LclId] =
                                        [ww1_sgABX $dFloating_sgAC1] \u []
                                            GHC.Float.sin $dFloating_sgAC1 ww1_sgABX;
                                  } in 
                                    case GHC.Num.* $dNum_sgAC0 siny_sgAC6 coshx_sgAC5 of dt1_sgAC7 {
                                      __DEFAULT ->
                                          case
                                              GHC.Num.* $dNum_sgAC0 cosy_sgAC3 coshx_sgAC5
                                          of
                                          dt2_sgAC8
                                          { __DEFAULT ->
                                                case
                                                    GHC.Num.* $dNum_sgAC0 siny_sgAC6 sinhx_sgAC2
                                                of
                                                dt3_sgAC9
                                                { __DEFAULT ->
                                                      Data.Complex.$w$c/
                                                          w_sgABV
                                                          dt_sgAC4
                                                          dt1_sgAC7
                                                          dt2_sgAC8
                                                          dt3_sgAC9;
                                                };
                                          };
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$ctanh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgACa w1_sgACb]
        case w1_sgACb of {
          Data.Complex.:+ ww1_sgACd [Occ=Once] ww2_sgACe [Occ=Once] ->
              case Data.Complex.$w$ctanh w_sgACa ww1_sgACd ww2_sgACe of {
                (#,#) ww4_sgACg [Occ=Once] ww5_sgACh [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgACg ww5_sgACh];
              };
        };

Data.Complex.$w$s$cacosh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgACi ww1_sgACj]
        case plusFloat# [ww_sgACi 1.0#] of sat_sgACk {
          __DEFAULT ->
              case Data.Complex.$w$s$csqrt1 sat_sgACk ww1_sgACj of {
                (#,#) ww3_sgACm [Occ=Once!] ww4_sgACn [Occ=Once!] ->
                    case ww4_sgACn of {
                      GHC.Types.F# x_sgACp ->
                          case ww3_sgACm of {
                            GHC.Types.F# x1_sgACr ->
                                case minusFloat# [ww_sgACi 1.0#] of sat_sgACs {
                                  __DEFAULT ->
                                      case Data.Complex.$w$s$csqrt1 sat_sgACs ww1_sgACj of {
                                        (#,#) ww6_sgACu [Occ=Once!] ww7_sgACv [Occ=Once!] ->
                                            case ww7_sgACv of {
                                              GHC.Types.F# y_sgACx ->
                                                  case ww6_sgACu of {
                                                    GHC.Types.F# y1_sgACz ->
                                                        case
                                                            timesFloat# [x_sgACp y1_sgACz]
                                                        of
                                                        sat_sgACC
                                                        { __DEFAULT ->
                                                              case
                                                                  timesFloat# [x1_sgACr y_sgACx]
                                                              of
                                                              sat_sgACB
                                                              { __DEFAULT ->
                                                                    case
                                                                        plusFloat# [sat_sgACB
                                                                                    sat_sgACC]
                                                                    of
                                                                    sat_sgACD
                                                                    { __DEFAULT ->
                                                                          case
                                                                              plusFloat# [ww1_sgACj
                                                                                          sat_sgACD]
                                                                          of
                                                                          ww8_sgACA [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    timesFloat# [x_sgACp
                                                                                                 y_sgACx]
                                                                                of
                                                                                sat_sgACG
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          timesFloat# [x1_sgACr
                                                                                                       y1_sgACz]
                                                                                      of
                                                                                      sat_sgACF
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                minusFloat# [sat_sgACF
                                                                                                             sat_sgACG]
                                                                                            of
                                                                                            sat_sgACH
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      plusFloat# [ww_sgACi
                                                                                                                  sat_sgACH]
                                                                                                  of
                                                                                                  ww9_sgACE [Dmd=<S,U>]
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$smagnitude1
                                                                                                                ww9_sgACE
                                                                                                                ww8_sgACA
                                                                                                        of
                                                                                                        ww10_sgACI
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  logFloat# [ww10_sgACI]
                                                                                                              of
                                                                                                              wild4_sgACJ
                                                                                                              { __DEFAULT ->
                                                                                                                    case
                                                                                                                        Data.Complex.$w$sphase1
                                                                                                                            ww9_sgACE
                                                                                                                            ww8_sgACA
                                                                                                                    of
                                                                                                                    ww11_sgACK
                                                                                                                    { __DEFAULT ->
                                                                                                                          let {
                                                                                                                            sat_sgACM [Occ=Once]
                                                                                                                              :: GHC.Types.Float
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.F#! [ww11_sgACK]; } in
                                                                                                                          let {
                                                                                                                            sat_sgACL [Occ=Once]
                                                                                                                              :: GHC.Types.Float
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.F#! [wild4_sgACJ];
                                                                                                                          } in 
                                                                                                                            (#,#) [sat_sgACL
                                                                                                                                   sat_sgACM];
                                                                                                                    };
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacosh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgACN]
        case w_sgACN of {
          Data.Complex.:+ ww1_sgACP [Occ=Once!] ww2_sgACQ [Occ=Once!] ->
              case ww1_sgACP of {
                GHC.Types.F# ww4_sgACS [Occ=Once] ->
                    case ww2_sgACQ of {
                      GHC.Types.F# ww6_sgACU [Occ=Once] ->
                          case Data.Complex.$w$s$cacosh1 ww4_sgACS ww6_sgACU of {
                            (#,#) ww8_sgACW [Occ=Once] ww9_sgACX [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgACW ww9_sgACX];
                          };
                    };
              };
        };

Data.Complex.$w$s$cacosh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgACY ww1_sgACZ]
        case +## [ww_sgACY 1.0##] of sat_sgAD0 {
          __DEFAULT ->
              case Data.Complex.$w$s$csqrt sat_sgAD0 ww1_sgACZ of {
                (#,#) ww3_sgAD2 [Occ=Once!] ww4_sgAD3 [Occ=Once!] ->
                    case ww4_sgAD3 of {
                      GHC.Types.D# x_sgAD5 ->
                          case ww3_sgAD2 of {
                            GHC.Types.D# x1_sgAD7 ->
                                case -## [ww_sgACY 1.0##] of sat_sgAD8 {
                                  __DEFAULT ->
                                      case Data.Complex.$w$s$csqrt sat_sgAD8 ww1_sgACZ of {
                                        (#,#) ww6_sgADa [Occ=Once!] ww7_sgADb [Occ=Once!] ->
                                            case ww7_sgADb of {
                                              GHC.Types.D# y_sgADd ->
                                                  case ww6_sgADa of {
                                                    GHC.Types.D# y1_sgADf ->
                                                        case *## [x_sgAD5 y1_sgADf] of sat_sgADi {
                                                          __DEFAULT ->
                                                              case
                                                                  *## [x1_sgAD7 y_sgADd]
                                                              of
                                                              sat_sgADh
                                                              { __DEFAULT ->
                                                                    case
                                                                        +## [sat_sgADh sat_sgADi]
                                                                    of
                                                                    sat_sgADj
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +## [ww1_sgACZ
                                                                                   sat_sgADj]
                                                                          of
                                                                          ww8_sgADg [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    *## [x_sgAD5
                                                                                         y_sgADd]
                                                                                of
                                                                                sat_sgADm
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          *## [x1_sgAD7
                                                                                               y1_sgADf]
                                                                                      of
                                                                                      sat_sgADl
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                -## [sat_sgADl
                                                                                                     sat_sgADm]
                                                                                            of
                                                                                            sat_sgADn
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      +## [ww_sgACY
                                                                                                           sat_sgADn]
                                                                                                  of
                                                                                                  ww9_sgADk [Dmd=<S,U>]
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$smagnitude
                                                                                                                ww9_sgADk
                                                                                                                ww8_sgADg
                                                                                                        of
                                                                                                        ww10_sgADo
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  logDouble# [ww10_sgADo]
                                                                                                              of
                                                                                                              wild4_sgADp
                                                                                                              { __DEFAULT ->
                                                                                                                    case
                                                                                                                        Data.Complex.$w$sphase
                                                                                                                            ww9_sgADk
                                                                                                                            ww8_sgADg
                                                                                                                    of
                                                                                                                    ww11_sgADq
                                                                                                                    { __DEFAULT ->
                                                                                                                          let {
                                                                                                                            sat_sgADs [Occ=Once]
                                                                                                                              :: GHC.Types.Double
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.D#! [ww11_sgADq]; } in
                                                                                                                          let {
                                                                                                                            sat_sgADr [Occ=Once]
                                                                                                                              :: GHC.Types.Double
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.D#! [wild4_sgADp];
                                                                                                                          } in 
                                                                                                                            (#,#) [sat_sgADr
                                                                                                                                   sat_sgADs];
                                                                                                                    };
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacosh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgADt]
        case w_sgADt of {
          Data.Complex.:+ ww1_sgADv [Occ=Once!] ww2_sgADw [Occ=Once!] ->
              case ww1_sgADv of {
                GHC.Types.D# ww4_sgADy [Occ=Once] ->
                    case ww2_sgADw of {
                      GHC.Types.D# ww6_sgADA [Occ=Once] ->
                          case Data.Complex.$w$s$cacosh ww4_sgADy ww6_sgADA of {
                            (#,#) ww8_sgADC [Occ=Once] ww9_sgADD [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgADC ww9_sgADD];
                          };
                    };
              };
        };

Data.Complex.$w$cacosh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgADE ww_sgADF ww1_sgADG]
        case
            Data.Complex.$w$cfromInteger
                w_sgADE Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww3_sgADI ww4_sgADJ ->
              case
                  Data.Complex.$w$c+ w_sgADE ww_sgADF ww1_sgADG ww3_sgADI ww4_sgADJ
              of
              { (#,#) ww6_sgADL [Occ=Once] ww7_sgADM [Occ=Once] ->
                    case Data.Complex.$w$csqrt w_sgADE ww6_sgADL ww7_sgADM of {
                      (#,#) ww9_sgADO [Occ=Once] ww10_sgADP [Occ=Once] ->
                          case
                              Data.Complex.$w$c- w_sgADE ww_sgADF ww1_sgADG ww3_sgADI ww4_sgADJ
                          of
                          { (#,#) ww12_sgADR [Occ=Once] ww13_sgADS [Occ=Once] ->
                                case Data.Complex.$w$csqrt w_sgADE ww12_sgADR ww13_sgADS of {
                                  (#,#) ww15_sgADU [Occ=Once] ww16_sgADV [Occ=Once] ->
                                      case
                                          Data.Complex.$w$c*
                                              w_sgADE ww9_sgADO ww10_sgADP ww15_sgADU ww16_sgADV
                                      of
                                      { (#,#) ww18_sgADX [Occ=Once] ww19_sgADY [Occ=Once] ->
                                            case
                                                Data.Complex.$w$c+
                                                    w_sgADE ww_sgADF ww1_sgADG ww18_sgADX ww19_sgADY
                                            of
                                            { (#,#) ww21_sgAE0 [Occ=Once] ww22_sgAE1 [Occ=Once] ->
                                                  Data.Complex.$w$clog
                                                      w_sgADE ww21_sgAE0 ww22_sgAE1;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cacosh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAE2 w1_sgAE3]
        case w1_sgAE3 of {
          Data.Complex.:+ ww1_sgAE5 [Occ=Once] ww2_sgAE6 [Occ=Once] ->
              case Data.Complex.$w$cacosh w_sgAE2 ww1_sgAE5 ww2_sgAE6 of {
                (#,#) ww4_sgAE8 [Occ=Once] ww5_sgAE9 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAE8 ww5_sgAE9];
              };
        };

Data.Complex.$w$s$casinh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAEa ww1_sgAEb]
        case timesFloat# [ww1_sgAEb ww_sgAEa] of sat_sgAEh {
          __DEFAULT ->
              case timesFloat# [ww_sgAEa ww1_sgAEb] of sat_sgAEg {
                __DEFAULT ->
                    case plusFloat# [sat_sgAEg sat_sgAEh] of sat_sgAEi {
                      __DEFAULT ->
                          case timesFloat# [ww1_sgAEb ww1_sgAEb] of sat_sgAEd {
                            __DEFAULT ->
                                case timesFloat# [ww_sgAEa ww_sgAEa] of sat_sgAEc {
                                  __DEFAULT ->
                                      case minusFloat# [sat_sgAEc sat_sgAEd] of sat_sgAEe {
                                        __DEFAULT ->
                                            case plusFloat# [1.0# sat_sgAEe] of sat_sgAEf {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt1 sat_sgAEf sat_sgAEi
                                                  of
                                                  { (#,#) ww3_sgAEk [Occ=Once!]
                                                          ww4_sgAEl [Occ=Once!] ->
                                                        case ww3_sgAEk of {
                                                          GHC.Types.F# y_sgAEn [Occ=Once] ->
                                                              case ww4_sgAEl of {
                                                                GHC.Types.F# y1_sgAEp [Occ=Once] ->
                                                                    case
                                                                        plusFloat# [ww1_sgAEb
                                                                                    y1_sgAEp]
                                                                    of
                                                                    ww5_sgAEq [Dmd=<S,U>]
                                                                    { __DEFAULT ->
                                                                          case
                                                                              plusFloat# [ww_sgAEa
                                                                                          y_sgAEn]
                                                                          of
                                                                          ww6_sgAEr [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$smagnitude1
                                                                                        ww6_sgAEr
                                                                                        ww5_sgAEq
                                                                                of
                                                                                ww7_sgAEs
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          logFloat# [ww7_sgAEs]
                                                                                      of
                                                                                      wild3_sgAEt
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$sphase1
                                                                                                    ww6_sgAEr
                                                                                                    ww5_sgAEq
                                                                                            of
                                                                                            ww8_sgAEu
                                                                                            { __DEFAULT ->
                                                                                                  let {
                                                                                                    sat_sgAEw [Occ=Once]
                                                                                                      :: GHC.Types.Float
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.F#! [ww8_sgAEu]; } in
                                                                                                  let {
                                                                                                    sat_sgAEv [Occ=Once]
                                                                                                      :: GHC.Types.Float
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.F#! [wild3_sgAEt];
                                                                                                  } in 
                                                                                                    (#,#) [sat_sgAEv
                                                                                                           sat_sgAEw];
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casinh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAEx]
        case w_sgAEx of {
          Data.Complex.:+ ww1_sgAEz [Occ=Once!] ww2_sgAEA [Occ=Once!] ->
              case ww1_sgAEz of {
                GHC.Types.F# ww4_sgAEC [Occ=Once] ->
                    case ww2_sgAEA of {
                      GHC.Types.F# ww6_sgAEE [Occ=Once] ->
                          case Data.Complex.$w$s$casinh1 ww4_sgAEC ww6_sgAEE of {
                            (#,#) ww8_sgAEG [Occ=Once] ww9_sgAEH [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAEG ww9_sgAEH];
                          };
                    };
              };
        };

Data.Complex.$w$s$casinh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAEI ww1_sgAEJ]
        case *## [ww1_sgAEJ ww_sgAEI] of sat_sgAEP {
          __DEFAULT ->
              case *## [ww_sgAEI ww1_sgAEJ] of sat_sgAEO {
                __DEFAULT ->
                    case +## [sat_sgAEO sat_sgAEP] of sat_sgAEQ {
                      __DEFAULT ->
                          case *## [ww1_sgAEJ ww1_sgAEJ] of sat_sgAEL {
                            __DEFAULT ->
                                case *## [ww_sgAEI ww_sgAEI] of sat_sgAEK {
                                  __DEFAULT ->
                                      case -## [sat_sgAEK sat_sgAEL] of sat_sgAEM {
                                        __DEFAULT ->
                                            case +## [1.0## sat_sgAEM] of sat_sgAEN {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt sat_sgAEN sat_sgAEQ
                                                  of
                                                  { (#,#) ww3_sgAES [Occ=Once!]
                                                          ww4_sgAET [Occ=Once!] ->
                                                        case ww3_sgAES of {
                                                          GHC.Types.D# y_sgAEV [Occ=Once] ->
                                                              case ww4_sgAET of {
                                                                GHC.Types.D# y1_sgAEX [Occ=Once] ->
                                                                    case
                                                                        +## [ww1_sgAEJ y1_sgAEX]
                                                                    of
                                                                    ww5_sgAEY [Dmd=<S,U>]
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +## [ww_sgAEI y_sgAEV]
                                                                          of
                                                                          ww6_sgAEZ [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$smagnitude
                                                                                        ww6_sgAEZ
                                                                                        ww5_sgAEY
                                                                                of
                                                                                ww7_sgAF0
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          logDouble# [ww7_sgAF0]
                                                                                      of
                                                                                      wild3_sgAF1
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$sphase
                                                                                                    ww6_sgAEZ
                                                                                                    ww5_sgAEY
                                                                                            of
                                                                                            ww8_sgAF2
                                                                                            { __DEFAULT ->
                                                                                                  let {
                                                                                                    sat_sgAF4 [Occ=Once]
                                                                                                      :: GHC.Types.Double
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.D#! [ww8_sgAF2]; } in
                                                                                                  let {
                                                                                                    sat_sgAF3 [Occ=Once]
                                                                                                      :: GHC.Types.Double
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.D#! [wild3_sgAF1];
                                                                                                  } in 
                                                                                                    (#,#) [sat_sgAF3
                                                                                                           sat_sgAF4];
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casinh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAF5]
        case w_sgAF5 of {
          Data.Complex.:+ ww1_sgAF7 [Occ=Once!] ww2_sgAF8 [Occ=Once!] ->
              case ww1_sgAF7 of {
                GHC.Types.D# ww4_sgAFa [Occ=Once] ->
                    case ww2_sgAF8 of {
                      GHC.Types.D# ww6_sgAFc [Occ=Once] ->
                          case Data.Complex.$w$s$casinh ww4_sgAFa ww6_sgAFc of {
                            (#,#) ww8_sgAFe [Occ=Once] ww9_sgAFf [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAFe ww9_sgAFf];
                          };
                    };
              };
        };

Data.Complex.$w$casinh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),1*C1(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAFg ww_sgAFh ww1_sgAFi]
        case
            Data.Complex.$w$cfromInteger
                w_sgAFg Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww3_sgAFk [Occ=Once] ww4_sgAFl [Occ=Once] ->
              case
                  Data.Complex.$w$c* w_sgAFg ww_sgAFh ww1_sgAFi ww_sgAFh ww1_sgAFi
              of
              { (#,#) ww6_sgAFn [Occ=Once] ww7_sgAFo [Occ=Once] ->
                    case
                        Data.Complex.$w$c+ w_sgAFg ww3_sgAFk ww4_sgAFl ww6_sgAFn ww7_sgAFo
                    of
                    { (#,#) ww9_sgAFq [Occ=Once] ww10_sgAFr [Occ=Once] ->
                          case Data.Complex.$w$csqrt w_sgAFg ww9_sgAFq ww10_sgAFr of {
                            (#,#) ww12_sgAFt [Occ=Once] ww13_sgAFu [Occ=Once] ->
                                case
                                    Data.Complex.$w$c+
                                        w_sgAFg ww_sgAFh ww1_sgAFi ww12_sgAFt ww13_sgAFu
                                of
                                { (#,#) ww15_sgAFw [Occ=Once] ww16_sgAFx [Occ=Once] ->
                                      Data.Complex.$w$clog w_sgAFg ww15_sgAFw ww16_sgAFx;
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$casinh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAFy w1_sgAFz]
        case w1_sgAFz of {
          Data.Complex.:+ ww1_sgAFB [Occ=Once] ww2_sgAFC [Occ=Once] ->
              case Data.Complex.$w$casinh w_sgAFy ww1_sgAFB ww2_sgAFC of {
                (#,#) ww4_sgAFE [Occ=Once] ww5_sgAFF [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAFE ww5_sgAFF];
              };
        };

Data.Complex.$w$s$catan1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAFG ww1_sgAFH]
        case timesFloat# [ww1_sgAFH ww_sgAFG] of sat_sgAFN {
          __DEFAULT ->
              case timesFloat# [ww_sgAFG ww1_sgAFH] of sat_sgAFM {
                __DEFAULT ->
                    case plusFloat# [sat_sgAFM sat_sgAFN] of sat_sgAFO {
                      __DEFAULT ->
                          case timesFloat# [ww1_sgAFH ww1_sgAFH] of sat_sgAFJ {
                            __DEFAULT ->
                                case timesFloat# [ww_sgAFG ww_sgAFG] of sat_sgAFI {
                                  __DEFAULT ->
                                      case minusFloat# [sat_sgAFI sat_sgAFJ] of sat_sgAFK {
                                        __DEFAULT ->
                                            case plusFloat# [1.0# sat_sgAFK] of sat_sgAFL {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt1 sat_sgAFL sat_sgAFO
                                                  of
                                                  { (#,#) ww3_sgAFQ [Occ=Once!]
                                                          ww4_sgAFR [Occ=Once!] ->
                                                        case ww3_sgAFQ of {
                                                          GHC.Types.F# ww6_sgAFT [Occ=Once] ->
                                                              case ww4_sgAFR of {
                                                                GHC.Types.F# ww8_sgAFV [Occ=Once] ->
                                                                    case
                                                                        minusFloat# [1.0# ww1_sgAFH]
                                                                    of
                                                                    sat_sgAFW
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/1
                                                                                  sat_sgAFW
                                                                                  ww_sgAFG
                                                                                  ww6_sgAFT
                                                                                  ww8_sgAFV
                                                                          of
                                                                          { (#,#) ww10_sgAFY [Occ=Once!]
                                                                                  ww11_sgAFZ [Occ=Once!] ->
                                                                                case ww10_sgAFY of {
                                                                                  GHC.Types.F# ww13_sgAG1 ->
                                                                                      case
                                                                                          ww11_sgAFZ
                                                                                      of
                                                                                      { GHC.Types.F# ww15_sgAG3 ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude1
                                                                                                    ww13_sgAG1
                                                                                                    ww15_sgAG3
                                                                                            of
                                                                                            ww16_sgAG4
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logFloat# [ww16_sgAG4]
                                                                                                  of
                                                                                                  wild1_sgAG5
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase1
                                                                                                                ww13_sgAG1
                                                                                                                ww15_sgAG3
                                                                                                        of
                                                                                                        ww17_sgAG6
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateFloat# [wild1_sgAG5]
                                                                                                              of
                                                                                                              sat_sgAG8
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgAG9 [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [sat_sgAG8]; } in
                                                                                                                    let {
                                                                                                                      sat_sgAG7 [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [ww17_sgAG6];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgAG7
                                                                                                                             sat_sgAG9];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catan1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAGa]
        case w_sgAGa of {
          Data.Complex.:+ ww1_sgAGc [Occ=Once!] ww2_sgAGd [Occ=Once!] ->
              case ww1_sgAGc of {
                GHC.Types.F# ww4_sgAGf [Occ=Once] ->
                    case ww2_sgAGd of {
                      GHC.Types.F# ww6_sgAGh [Occ=Once] ->
                          case Data.Complex.$w$s$catan1 ww4_sgAGf ww6_sgAGh of {
                            (#,#) ww8_sgAGj [Occ=Once] ww9_sgAGk [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAGj ww9_sgAGk];
                          };
                    };
              };
        };

Data.Complex.$w$s$catan [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAGl ww1_sgAGm]
        case *## [ww1_sgAGm ww_sgAGl] of sat_sgAGs {
          __DEFAULT ->
              case *## [ww_sgAGl ww1_sgAGm] of sat_sgAGr {
                __DEFAULT ->
                    case +## [sat_sgAGr sat_sgAGs] of sat_sgAGt {
                      __DEFAULT ->
                          case *## [ww1_sgAGm ww1_sgAGm] of sat_sgAGo {
                            __DEFAULT ->
                                case *## [ww_sgAGl ww_sgAGl] of sat_sgAGn {
                                  __DEFAULT ->
                                      case -## [sat_sgAGn sat_sgAGo] of sat_sgAGp {
                                        __DEFAULT ->
                                            case +## [1.0## sat_sgAGp] of sat_sgAGq {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt sat_sgAGq sat_sgAGt
                                                  of
                                                  { (#,#) ww3_sgAGv [Occ=Once!]
                                                          ww4_sgAGw [Occ=Once!] ->
                                                        case ww3_sgAGv of {
                                                          GHC.Types.D# ww6_sgAGy [Occ=Once] ->
                                                              case ww4_sgAGw of {
                                                                GHC.Types.D# ww8_sgAGA [Occ=Once] ->
                                                                    case
                                                                        -## [1.0## ww1_sgAGm]
                                                                    of
                                                                    sat_sgAGB
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/
                                                                                  sat_sgAGB
                                                                                  ww_sgAGl
                                                                                  ww6_sgAGy
                                                                                  ww8_sgAGA
                                                                          of
                                                                          { (#,#) ww10_sgAGD [Occ=Once!]
                                                                                  ww11_sgAGE [Occ=Once!] ->
                                                                                case ww10_sgAGD of {
                                                                                  GHC.Types.D# ww13_sgAGG ->
                                                                                      case
                                                                                          ww11_sgAGE
                                                                                      of
                                                                                      { GHC.Types.D# ww15_sgAGI ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude
                                                                                                    ww13_sgAGG
                                                                                                    ww15_sgAGI
                                                                                            of
                                                                                            ww16_sgAGJ
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logDouble# [ww16_sgAGJ]
                                                                                                  of
                                                                                                  wild1_sgAGK
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase
                                                                                                                ww13_sgAGG
                                                                                                                ww15_sgAGI
                                                                                                        of
                                                                                                        ww17_sgAGL
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateDouble# [wild1_sgAGK]
                                                                                                              of
                                                                                                              sat_sgAGN
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgAGO [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [sat_sgAGN]; } in
                                                                                                                    let {
                                                                                                                      sat_sgAGM [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [ww17_sgAGL];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgAGM
                                                                                                                             sat_sgAGO];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catan [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAGP]
        case w_sgAGP of {
          Data.Complex.:+ ww1_sgAGR [Occ=Once!] ww2_sgAGS [Occ=Once!] ->
              case ww1_sgAGR of {
                GHC.Types.D# ww4_sgAGU [Occ=Once] ->
                    case ww2_sgAGS of {
                      GHC.Types.D# ww6_sgAGW [Occ=Once] ->
                          case Data.Complex.$w$s$catan ww4_sgAGU ww6_sgAGW of {
                            (#,#) ww8_sgAGY [Occ=Once] ww9_sgAGZ [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAGY ww9_sgAGZ];
                          };
                    };
              };
        };

Data.Complex.$w$catan [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAH0 ww_sgAH1 ww1_sgAH2]
        case
            GHC.Float.$p1RealFloat w_sgAH0
        of
        $dRealFrac_sgAH3 [Dmd=<S(S(S(LC(C(S))LC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U)),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAH3
              of
              $dReal_sgAH4 [Dmd=<S(S(LC(C(S))LC(S)LLL)LL),1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U)),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAH4
                    of
                    $dNum_sgAH5 [Dmd=<S(LC(C(S))LC(S)LLL),U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U))>]
                    { __DEFAULT ->
                          let {
                            sat_sgAH6 [Occ=Once] :: a_sgxKN
                            [LclId] =
                                [$dNum_sgAH5] \u []
                                    GHC.Num.fromInteger
                                        $dNum_sgAH5 Data.Complex.$fFloatingComplex19;
                          } in 
                            case GHC.Num.- $dNum_sgAH5 sat_sgAH6 ww1_sgAH2 of dt_sgAH7 {
                              __DEFAULT ->
                                  case
                                      Data.Complex.$w$cfromInteger
                                          w_sgAH0 Data.Complex.$fFloatingComplex19
                                  of
                                  { (#,#) ww3_sgAH9 [Occ=Once] ww4_sgAHa [Occ=Once] ->
                                        case
                                            Data.Complex.$w$c*
                                                w_sgAH0 ww_sgAH1 ww1_sgAH2 ww_sgAH1 ww1_sgAH2
                                        of
                                        { (#,#) ww6_sgAHc [Occ=Once] ww7_sgAHd [Occ=Once] ->
                                              case
                                                  Data.Complex.$w$c+
                                                      w_sgAH0
                                                      ww3_sgAH9
                                                      ww4_sgAHa
                                                      ww6_sgAHc
                                                      ww7_sgAHd
                                              of
                                              { (#,#) ww9_sgAHf [Occ=Once] ww10_sgAHg [Occ=Once] ->
                                                    case
                                                        Data.Complex.$w$csqrt
                                                            w_sgAH0 ww9_sgAHf ww10_sgAHg
                                                    of
                                                    { (#,#) ww12_sgAHi [Occ=Once]
                                                            ww13_sgAHj [Occ=Once] ->
                                                          case
                                                              Data.Complex.$w$c/
                                                                  w_sgAH0
                                                                  dt_sgAH7
                                                                  ww_sgAH1
                                                                  ww12_sgAHi
                                                                  ww13_sgAHj
                                                          of
                                                          { (#,#) ww15_sgAHl ww16_sgAHm ->
                                                                let {
                                                                  sat_sgAHo [Occ=Once] :: a_sgxKN
                                                                  [LclId] =
                                                                      [w_sgAH0
                                                                       ww15_sgAHl
                                                                       ww16_sgAHm] \u []
                                                                          Data.Complex.$wmagnitude
                                                                              w_sgAH0
                                                                              ww15_sgAHl
                                                                              ww16_sgAHm;
                                                                } in 
                                                                  case
                                                                      GHC.Float.$p2RealFloat w_sgAH0
                                                                  of
                                                                  sat_sgAHn
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Float.log
                                                                                sat_sgAHn sat_sgAHo
                                                                        of
                                                                        dt1_sgAHp
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  Data.Complex.$wphase
                                                                                      w_sgAH0
                                                                                      ww15_sgAHl
                                                                                      ww16_sgAHm
                                                                              of
                                                                              dt2_sgAHq
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        GHC.Num.negate
                                                                                            $dNum_sgAH5
                                                                                            dt1_sgAHp
                                                                                    of
                                                                                    dt3_sgAHr
                                                                                    { __DEFAULT ->
                                                                                          (#,#) [dt2_sgAHq
                                                                                                 dt3_sgAHr];
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                          };
                                                    };
                                              };
                                        };
                                  };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$catan [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAHs w1_sgAHt]
        case w1_sgAHt of {
          Data.Complex.:+ ww1_sgAHv [Occ=Once] ww2_sgAHw [Occ=Once] ->
              case Data.Complex.$w$catan w_sgAHs ww1_sgAHv ww2_sgAHw of {
                (#,#) ww4_sgAHy [Occ=Once] ww5_sgAHz [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAHy ww5_sgAHz];
              };
        };

Data.Complex.$w$s$cacos1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAHA ww1_sgAHB]
        case timesFloat# [ww1_sgAHB ww_sgAHA] of sat_sgAHH {
          __DEFAULT ->
              case timesFloat# [ww_sgAHA ww1_sgAHB] of sat_sgAHG {
                __DEFAULT ->
                    case plusFloat# [sat_sgAHG sat_sgAHH] of sat_sgAHI {
                      __DEFAULT ->
                          case minusFloat# [0.0# sat_sgAHI] of sat_sgAHJ {
                            __DEFAULT ->
                                case timesFloat# [ww1_sgAHB ww1_sgAHB] of sat_sgAHD {
                                  __DEFAULT ->
                                      case timesFloat# [ww_sgAHA ww_sgAHA] of sat_sgAHC {
                                        __DEFAULT ->
                                            case minusFloat# [sat_sgAHC sat_sgAHD] of sat_sgAHE {
                                              __DEFAULT ->
                                                  case minusFloat# [1.0# sat_sgAHE] of sat_sgAHF {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt1
                                                                sat_sgAHF sat_sgAHJ
                                                        of
                                                        { (#,#) ww3_sgAHL [Occ=Once!]
                                                                ww4_sgAHM [Occ=Once!] ->
                                                              case ww4_sgAHM of {
                                                                GHC.Types.F# x_sgAHO [Occ=Once] ->
                                                                    case ww3_sgAHL of {
                                                                      GHC.Types.F# y_sgAHQ [Occ=Once] ->
                                                                          case
                                                                              plusFloat# [ww1_sgAHB
                                                                                          y_sgAHQ]
                                                                          of
                                                                          ww5_sgAHR [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateFloat# [x_sgAHO]
                                                                                of
                                                                                sat_sgAHT
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          plusFloat# [ww_sgAHA
                                                                                                      sat_sgAHT]
                                                                                      of
                                                                                      ww6_sgAHS [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude1
                                                                                                    ww6_sgAHS
                                                                                                    ww5_sgAHR
                                                                                            of
                                                                                            ww7_sgAHU
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logFloat# [ww7_sgAHU]
                                                                                                  of
                                                                                                  wild2_sgAHV
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase1
                                                                                                                ww6_sgAHS
                                                                                                                ww5_sgAHR
                                                                                                        of
                                                                                                        ww8_sgAHW
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateFloat# [wild2_sgAHV]
                                                                                                              of
                                                                                                              sat_sgAHY
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgAHZ [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [sat_sgAHY]; } in
                                                                                                                    let {
                                                                                                                      sat_sgAHX [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [ww8_sgAHW];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgAHX
                                                                                                                             sat_sgAHZ];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacos1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAI0]
        case w_sgAI0 of {
          Data.Complex.:+ ww1_sgAI2 [Occ=Once!] ww2_sgAI3 [Occ=Once!] ->
              case ww1_sgAI2 of {
                GHC.Types.F# ww4_sgAI5 [Occ=Once] ->
                    case ww2_sgAI3 of {
                      GHC.Types.F# ww6_sgAI7 [Occ=Once] ->
                          case Data.Complex.$w$s$cacos1 ww4_sgAI5 ww6_sgAI7 of {
                            (#,#) ww8_sgAI9 [Occ=Once] ww9_sgAIa [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAI9 ww9_sgAIa];
                          };
                    };
              };
        };

Data.Complex.$w$s$cacos [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAIb ww1_sgAIc]
        case *## [ww1_sgAIc ww_sgAIb] of sat_sgAIi {
          __DEFAULT ->
              case *## [ww_sgAIb ww1_sgAIc] of sat_sgAIh {
                __DEFAULT ->
                    case +## [sat_sgAIh sat_sgAIi] of sat_sgAIj {
                      __DEFAULT ->
                          case -## [0.0## sat_sgAIj] of sat_sgAIk {
                            __DEFAULT ->
                                case *## [ww1_sgAIc ww1_sgAIc] of sat_sgAIe {
                                  __DEFAULT ->
                                      case *## [ww_sgAIb ww_sgAIb] of sat_sgAId {
                                        __DEFAULT ->
                                            case -## [sat_sgAId sat_sgAIe] of sat_sgAIf {
                                              __DEFAULT ->
                                                  case -## [1.0## sat_sgAIf] of sat_sgAIg {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt
                                                                sat_sgAIg sat_sgAIk
                                                        of
                                                        { (#,#) ww3_sgAIm [Occ=Once!]
                                                                ww4_sgAIn [Occ=Once!] ->
                                                              case ww4_sgAIn of {
                                                                GHC.Types.D# x_sgAIp [Occ=Once] ->
                                                                    case ww3_sgAIm of {
                                                                      GHC.Types.D# y_sgAIr [Occ=Once] ->
                                                                          case
                                                                              +## [ww1_sgAIc
                                                                                   y_sgAIr]
                                                                          of
                                                                          ww5_sgAIs [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateDouble# [x_sgAIp]
                                                                                of
                                                                                sat_sgAIu
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          +## [ww_sgAIb
                                                                                               sat_sgAIu]
                                                                                      of
                                                                                      ww6_sgAIt [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude
                                                                                                    ww6_sgAIt
                                                                                                    ww5_sgAIs
                                                                                            of
                                                                                            ww7_sgAIv
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logDouble# [ww7_sgAIv]
                                                                                                  of
                                                                                                  wild2_sgAIw
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase
                                                                                                                ww6_sgAIt
                                                                                                                ww5_sgAIs
                                                                                                        of
                                                                                                        ww8_sgAIx
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateDouble# [wild2_sgAIw]
                                                                                                              of
                                                                                                              sat_sgAIz
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgAIA [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [sat_sgAIz]; } in
                                                                                                                    let {
                                                                                                                      sat_sgAIy [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [ww8_sgAIx];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgAIy
                                                                                                                             sat_sgAIA];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacos [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAIB]
        case w_sgAIB of {
          Data.Complex.:+ ww1_sgAID [Occ=Once!] ww2_sgAIE [Occ=Once!] ->
              case ww1_sgAID of {
                GHC.Types.D# ww4_sgAIG [Occ=Once] ->
                    case ww2_sgAIE of {
                      GHC.Types.D# ww6_sgAII [Occ=Once] ->
                          case Data.Complex.$w$s$cacos ww4_sgAIG ww6_sgAII of {
                            (#,#) ww8_sgAIK [Occ=Once] ww9_sgAIL [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAIK ww9_sgAIL];
                          };
                    };
              };
        };

Data.Complex.$w$cacos [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAIM ww_sgAIN ww1_sgAIO]
        case
            Data.Complex.$w$cfromInteger
                w_sgAIM Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww3_sgAIQ [Occ=Once] ww4_sgAIR [Occ=Once] ->
              case
                  Data.Complex.$w$c* w_sgAIM ww_sgAIN ww1_sgAIO ww_sgAIN ww1_sgAIO
              of
              { (#,#) ww6_sgAIT [Occ=Once] ww7_sgAIU [Occ=Once] ->
                    case
                        Data.Complex.$w$c- w_sgAIM ww3_sgAIQ ww4_sgAIR ww6_sgAIT ww7_sgAIU
                    of
                    { (#,#) ww9_sgAIW [Occ=Once] ww10_sgAIX [Occ=Once] ->
                          case Data.Complex.$w$csqrt w_sgAIM ww9_sgAIW ww10_sgAIX of {
                            (#,#) ww12_sgAIZ [Occ=Once] ww13_sgAJ0 [Occ=Once] ->
                                case
                                    GHC.Float.$p1RealFloat w_sgAIM
                                of
                                $dRealFrac_sgAJ1 [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
                                { __DEFAULT ->
                                      case
                                          GHC.Real.$p1RealFrac $dRealFrac_sgAJ1
                                      of
                                      $dReal_sgAJ2 [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
                                      { __DEFAULT ->
                                            case
                                                GHC.Real.$p1Real $dReal_sgAJ2
                                            of
                                            $dNum_sgAJ3 [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Num.negate $dNum_sgAJ3 ww13_sgAJ0
                                                  of
                                                  dt_sgAJ4
                                                  { __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$c+
                                                                w_sgAIM
                                                                ww_sgAIN
                                                                ww1_sgAIO
                                                                dt_sgAJ4
                                                                ww12_sgAIZ
                                                        of
                                                        { (#,#) ww15_sgAJ6 ww16_sgAJ7 ->
                                                              let {
                                                                sat_sgAJ9 [Occ=Once] :: a_sgxM9
                                                                [LclId] =
                                                                    [w_sgAIM
                                                                     ww15_sgAJ6
                                                                     ww16_sgAJ7] \u []
                                                                        Data.Complex.$wmagnitude
                                                                            w_sgAIM
                                                                            ww15_sgAJ6
                                                                            ww16_sgAJ7;
                                                              } in 
                                                                case
                                                                    GHC.Float.$p2RealFloat w_sgAIM
                                                                of
                                                                sat_sgAJ8
                                                                { __DEFAULT ->
                                                                      case
                                                                          GHC.Float.log
                                                                              sat_sgAJ8 sat_sgAJ9
                                                                      of
                                                                      dt1_sgAJa
                                                                      { __DEFAULT ->
                                                                            case
                                                                                Data.Complex.$wphase
                                                                                    w_sgAIM
                                                                                    ww15_sgAJ6
                                                                                    ww16_sgAJ7
                                                                            of
                                                                            dt2_sgAJb
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      GHC.Num.negate
                                                                                          $dNum_sgAJ3
                                                                                          dt1_sgAJa
                                                                                  of
                                                                                  dt3_sgAJc
                                                                                  { __DEFAULT ->
                                                                                        (#,#) [dt2_sgAJb
                                                                                               dt3_sgAJc];
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cacos [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAJd w1_sgAJe]
        case w1_sgAJe of {
          Data.Complex.:+ ww1_sgAJg [Occ=Once] ww2_sgAJh [Occ=Once] ->
              case Data.Complex.$w$cacos w_sgAJd ww1_sgAJg ww2_sgAJh of {
                (#,#) ww4_sgAJj [Occ=Once] ww5_sgAJk [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAJj ww5_sgAJk];
              };
        };

Data.Complex.$w$s$casin1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAJl ww1_sgAJm]
        case timesFloat# [ww1_sgAJm ww_sgAJl] of sat_sgAJs {
          __DEFAULT ->
              case timesFloat# [ww_sgAJl ww1_sgAJm] of sat_sgAJr {
                __DEFAULT ->
                    case plusFloat# [sat_sgAJr sat_sgAJs] of sat_sgAJt {
                      __DEFAULT ->
                          case minusFloat# [0.0# sat_sgAJt] of sat_sgAJu {
                            __DEFAULT ->
                                case timesFloat# [ww1_sgAJm ww1_sgAJm] of sat_sgAJo {
                                  __DEFAULT ->
                                      case timesFloat# [ww_sgAJl ww_sgAJl] of sat_sgAJn {
                                        __DEFAULT ->
                                            case minusFloat# [sat_sgAJn sat_sgAJo] of sat_sgAJp {
                                              __DEFAULT ->
                                                  case minusFloat# [1.0# sat_sgAJp] of sat_sgAJq {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt1
                                                                sat_sgAJq sat_sgAJu
                                                        of
                                                        { (#,#) ww3_sgAJw [Occ=Once!]
                                                                ww4_sgAJx [Occ=Once!] ->
                                                              case ww3_sgAJw of {
                                                                GHC.Types.F# y_sgAJz [Occ=Once] ->
                                                                    case ww4_sgAJx of {
                                                                      GHC.Types.F# y1_sgAJB [Occ=Once] ->
                                                                          case
                                                                              plusFloat# [ww_sgAJl
                                                                                          y1_sgAJB]
                                                                          of
                                                                          ww5_sgAJC [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateFloat# [ww1_sgAJm]
                                                                                of
                                                                                sat_sgAJE
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          plusFloat# [sat_sgAJE
                                                                                                      y_sgAJz]
                                                                                      of
                                                                                      ww6_sgAJD [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude1
                                                                                                    ww6_sgAJD
                                                                                                    ww5_sgAJC
                                                                                            of
                                                                                            ww7_sgAJF
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logFloat# [ww7_sgAJF]
                                                                                                  of
                                                                                                  wild3_sgAJG
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase1
                                                                                                                ww6_sgAJD
                                                                                                                ww5_sgAJC
                                                                                                        of
                                                                                                        ww8_sgAJH
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateFloat# [wild3_sgAJG]
                                                                                                              of
                                                                                                              sat_sgAJJ
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgAJK [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [sat_sgAJJ]; } in
                                                                                                                    let {
                                                                                                                      sat_sgAJI [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [ww8_sgAJH];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgAJI
                                                                                                                             sat_sgAJK];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casin1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAJL]
        case w_sgAJL of {
          Data.Complex.:+ ww1_sgAJN [Occ=Once!] ww2_sgAJO [Occ=Once!] ->
              case ww1_sgAJN of {
                GHC.Types.F# ww4_sgAJQ [Occ=Once] ->
                    case ww2_sgAJO of {
                      GHC.Types.F# ww6_sgAJS [Occ=Once] ->
                          case Data.Complex.$w$s$casin1 ww4_sgAJQ ww6_sgAJS of {
                            (#,#) ww8_sgAJU [Occ=Once] ww9_sgAJV [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAJU ww9_sgAJV];
                          };
                    };
              };
        };

Data.Complex.$w$s$casin [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAJW ww1_sgAJX]
        case *## [ww1_sgAJX ww_sgAJW] of sat_sgAK3 {
          __DEFAULT ->
              case *## [ww_sgAJW ww1_sgAJX] of sat_sgAK2 {
                __DEFAULT ->
                    case +## [sat_sgAK2 sat_sgAK3] of sat_sgAK4 {
                      __DEFAULT ->
                          case -## [0.0## sat_sgAK4] of sat_sgAK5 {
                            __DEFAULT ->
                                case *## [ww1_sgAJX ww1_sgAJX] of sat_sgAJZ {
                                  __DEFAULT ->
                                      case *## [ww_sgAJW ww_sgAJW] of sat_sgAJY {
                                        __DEFAULT ->
                                            case -## [sat_sgAJY sat_sgAJZ] of sat_sgAK0 {
                                              __DEFAULT ->
                                                  case -## [1.0## sat_sgAK0] of sat_sgAK1 {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt
                                                                sat_sgAK1 sat_sgAK5
                                                        of
                                                        { (#,#) ww3_sgAK7 [Occ=Once!]
                                                                ww4_sgAK8 [Occ=Once!] ->
                                                              case ww3_sgAK7 of {
                                                                GHC.Types.D# y_sgAKa [Occ=Once] ->
                                                                    case ww4_sgAK8 of {
                                                                      GHC.Types.D# y1_sgAKc [Occ=Once] ->
                                                                          case
                                                                              +## [ww_sgAJW
                                                                                   y1_sgAKc]
                                                                          of
                                                                          ww5_sgAKd [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateDouble# [ww1_sgAJX]
                                                                                of
                                                                                sat_sgAKf
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          +## [sat_sgAKf
                                                                                               y_sgAKa]
                                                                                      of
                                                                                      ww6_sgAKe [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude
                                                                                                    ww6_sgAKe
                                                                                                    ww5_sgAKd
                                                                                            of
                                                                                            ww7_sgAKg
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logDouble# [ww7_sgAKg]
                                                                                                  of
                                                                                                  wild3_sgAKh
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase
                                                                                                                ww6_sgAKe
                                                                                                                ww5_sgAKd
                                                                                                        of
                                                                                                        ww8_sgAKi
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateDouble# [wild3_sgAKh]
                                                                                                              of
                                                                                                              sat_sgAKk
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgAKl [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [sat_sgAKk]; } in
                                                                                                                    let {
                                                                                                                      sat_sgAKj [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [ww8_sgAKi];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgAKj
                                                                                                                             sat_sgAKl];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casin [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAKm]
        case w_sgAKm of {
          Data.Complex.:+ ww1_sgAKo [Occ=Once!] ww2_sgAKp [Occ=Once!] ->
              case ww1_sgAKo of {
                GHC.Types.D# ww4_sgAKr [Occ=Once] ->
                    case ww2_sgAKp of {
                      GHC.Types.D# ww6_sgAKt [Occ=Once] ->
                          case Data.Complex.$w$s$casin ww4_sgAKr ww6_sgAKt of {
                            (#,#) ww8_sgAKv [Occ=Once] ww9_sgAKw [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAKv ww9_sgAKw];
                          };
                    };
              };
        };

Data.Complex.$w$casin [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAKx ww_sgAKy ww1_sgAKz]
        case
            GHC.Float.$p1RealFloat w_sgAKx
        of
        $dRealFrac_sgAKA [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAKA
              of
              $dReal_sgAKB [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAKB
                    of
                    $dNum_sgAKC [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.negate $dNum_sgAKC ww1_sgAKz of dt_sgAKD {
                            __DEFAULT ->
                                case
                                    Data.Complex.$w$cfromInteger
                                        w_sgAKx Data.Complex.$fFloatingComplex19
                                of
                                { (#,#) ww3_sgAKF [Occ=Once] ww4_sgAKG [Occ=Once] ->
                                      case
                                          Data.Complex.$w$c*
                                              w_sgAKx ww_sgAKy ww1_sgAKz ww_sgAKy ww1_sgAKz
                                      of
                                      { (#,#) ww6_sgAKI [Occ=Once] ww7_sgAKJ [Occ=Once] ->
                                            case
                                                Data.Complex.$w$c-
                                                    w_sgAKx ww3_sgAKF ww4_sgAKG ww6_sgAKI ww7_sgAKJ
                                            of
                                            { (#,#) ww9_sgAKL [Occ=Once] ww10_sgAKM [Occ=Once] ->
                                                  case
                                                      Data.Complex.$w$csqrt
                                                          w_sgAKx ww9_sgAKL ww10_sgAKM
                                                  of
                                                  { (#,#) ww12_sgAKO [Occ=Once]
                                                          ww13_sgAKP [Occ=Once] ->
                                                        case
                                                            Data.Complex.$w$c+
                                                                w_sgAKx
                                                                dt_sgAKD
                                                                ww_sgAKy
                                                                ww12_sgAKO
                                                                ww13_sgAKP
                                                        of
                                                        { (#,#) ww15_sgAKR ww16_sgAKS ->
                                                              let {
                                                                sat_sgAKU [Occ=Once] :: a_sgxNq
                                                                [LclId] =
                                                                    [w_sgAKx
                                                                     ww15_sgAKR
                                                                     ww16_sgAKS] \u []
                                                                        Data.Complex.$wmagnitude
                                                                            w_sgAKx
                                                                            ww15_sgAKR
                                                                            ww16_sgAKS;
                                                              } in 
                                                                case
                                                                    GHC.Float.$p2RealFloat w_sgAKx
                                                                of
                                                                sat_sgAKT
                                                                { __DEFAULT ->
                                                                      case
                                                                          GHC.Float.log
                                                                              sat_sgAKT sat_sgAKU
                                                                      of
                                                                      dt1_sgAKV
                                                                      { __DEFAULT ->
                                                                            case
                                                                                Data.Complex.$wphase
                                                                                    w_sgAKx
                                                                                    ww15_sgAKR
                                                                                    ww16_sgAKS
                                                                            of
                                                                            dt2_sgAKW
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      GHC.Num.negate
                                                                                          $dNum_sgAKC
                                                                                          dt1_sgAKV
                                                                                  of
                                                                                  dt3_sgAKX
                                                                                  { __DEFAULT ->
                                                                                        (#,#) [dt2_sgAKW
                                                                                               dt3_sgAKX];
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$casin [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAKY w1_sgAKZ]
        case w1_sgAKZ of {
          Data.Complex.:+ ww1_sgAL1 [Occ=Once] ww2_sgAL2 [Occ=Once] ->
              case Data.Complex.$w$casin w_sgAKY ww1_sgAL1 ww2_sgAL2 of {
                (#,#) ww4_sgAL4 [Occ=Once] ww5_sgAL5 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAL4 ww5_sgAL5];
              };
        };

Data.Complex.$w$s$catanh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAL6 ww1_sgAL7]
        case minusFloat# [0.0# ww1_sgAL7] of sat_sgALa {
          __DEFAULT ->
              case minusFloat# [1.0# ww_sgAL6] of sat_sgAL9 {
                __DEFAULT ->
                    case plusFloat# [1.0# ww_sgAL6] of sat_sgAL8 {
                      __DEFAULT ->
                          case
                              Data.Complex.$w$s$c/1 sat_sgAL8 ww1_sgAL7 sat_sgAL9 sat_sgALa
                          of
                          { (#,#) ww3_sgALc [Occ=Once!] ww4_sgALd [Occ=Once!] ->
                                case ww3_sgALc of {
                                  GHC.Types.F# ww6_sgALf ->
                                      case ww4_sgALd of {
                                        GHC.Types.F# ww8_sgALh ->
                                            case
                                                Data.Complex.$w$smagnitude1 ww6_sgALf ww8_sgALh
                                            of
                                            ww9_sgALi
                                            { __DEFAULT ->
                                                  case logFloat# [ww9_sgALi] of wild1_sgALj {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$sphase1
                                                                ww6_sgALf ww8_sgALh
                                                        of
                                                        ww10_sgALk
                                                        { __DEFAULT ->
                                                              case
                                                                  timesFloat# [0.0# wild1_sgALj]
                                                              of
                                                              sat_sgALq
                                                              { __DEFAULT ->
                                                                    case
                                                                        timesFloat# [0.5#
                                                                                     ww10_sgALk]
                                                                    of
                                                                    sat_sgALp
                                                                    { __DEFAULT ->
                                                                          case
                                                                              plusFloat# [sat_sgALp
                                                                                          sat_sgALq]
                                                                          of
                                                                          sat_sgALr
                                                                          { __DEFAULT ->
                                                                                let {
                                                                                  sat_sgALs [Occ=Once]
                                                                                    :: GHC.Types.Float
                                                                                  [LclId] =
                                                                                      CCCS GHC.Types.F#! [sat_sgALr];
                                                                                } in 
                                                                                  case
                                                                                      timesFloat# [0.0#
                                                                                                   ww10_sgALk]
                                                                                  of
                                                                                  sat_sgALm
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            timesFloat# [0.5#
                                                                                                         wild1_sgALj]
                                                                                        of
                                                                                        sat_sgALl
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  minusFloat# [sat_sgALl
                                                                                                               sat_sgALm]
                                                                                              of
                                                                                              sat_sgALn
                                                                                              { __DEFAULT ->
                                                                                                    let {
                                                                                                      sat_sgALo [Occ=Once]
                                                                                                        :: GHC.Types.Float
                                                                                                      [LclId] =
                                                                                                          CCCS GHC.Types.F#! [sat_sgALn];
                                                                                                    } in 
                                                                                                      (#,#) [sat_sgALo
                                                                                                             sat_sgALs];
                                                                                              };
                                                                                        };
                                                                                  };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catanh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgALt]
        case w_sgALt of {
          Data.Complex.:+ ww1_sgALv [Occ=Once!] ww2_sgALw [Occ=Once!] ->
              case ww1_sgALv of {
                GHC.Types.F# ww4_sgALy [Occ=Once] ->
                    case ww2_sgALw of {
                      GHC.Types.F# ww6_sgALA [Occ=Once] ->
                          case Data.Complex.$w$s$catanh1 ww4_sgALy ww6_sgALA of {
                            (#,#) ww8_sgALC [Occ=Once] ww9_sgALD [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgALC ww9_sgALD];
                          };
                    };
              };
        };

Data.Complex.$w$s$catanh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgALE ww1_sgALF]
        case -## [0.0## ww1_sgALF] of sat_sgALI {
          __DEFAULT ->
              case -## [1.0## ww_sgALE] of sat_sgALH {
                __DEFAULT ->
                    case +## [1.0## ww_sgALE] of sat_sgALG {
                      __DEFAULT ->
                          case
                              Data.Complex.$w$s$c/ sat_sgALG ww1_sgALF sat_sgALH sat_sgALI
                          of
                          { (#,#) ww3_sgALK [Occ=Once!] ww4_sgALL [Occ=Once!] ->
                                case ww3_sgALK of {
                                  GHC.Types.D# ww6_sgALN ->
                                      case ww4_sgALL of {
                                        GHC.Types.D# ww8_sgALP ->
                                            case
                                                Data.Complex.$w$smagnitude ww6_sgALN ww8_sgALP
                                            of
                                            ww9_sgALQ
                                            { __DEFAULT ->
                                                  case logDouble# [ww9_sgALQ] of wild1_sgALR {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$sphase
                                                                ww6_sgALN ww8_sgALP
                                                        of
                                                        ww10_sgALS
                                                        { __DEFAULT ->
                                                              case
                                                                  *## [0.0## wild1_sgALR]
                                                              of
                                                              sat_sgALY
                                                              { __DEFAULT ->
                                                                    case
                                                                        *## [0.5## ww10_sgALS]
                                                                    of
                                                                    sat_sgALX
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +## [sat_sgALX
                                                                                   sat_sgALY]
                                                                          of
                                                                          sat_sgALZ
                                                                          { __DEFAULT ->
                                                                                let {
                                                                                  sat_sgAM0 [Occ=Once]
                                                                                    :: GHC.Types.Double
                                                                                  [LclId] =
                                                                                      CCCS GHC.Types.D#! [sat_sgALZ];
                                                                                } in 
                                                                                  case
                                                                                      *## [0.0##
                                                                                           ww10_sgALS]
                                                                                  of
                                                                                  sat_sgALU
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            *## [0.5##
                                                                                                 wild1_sgALR]
                                                                                        of
                                                                                        sat_sgALT
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  -## [sat_sgALT
                                                                                                       sat_sgALU]
                                                                                              of
                                                                                              sat_sgALV
                                                                                              { __DEFAULT ->
                                                                                                    let {
                                                                                                      sat_sgALW [Occ=Once]
                                                                                                        :: GHC.Types.Double
                                                                                                      [LclId] =
                                                                                                          CCCS GHC.Types.D#! [sat_sgALV];
                                                                                                    } in 
                                                                                                      (#,#) [sat_sgALW
                                                                                                             sat_sgAM0];
                                                                                              };
                                                                                        };
                                                                                  };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catanh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAM1]
        case w_sgAM1 of {
          Data.Complex.:+ ww1_sgAM3 [Occ=Once!] ww2_sgAM4 [Occ=Once!] ->
              case ww1_sgAM3 of {
                GHC.Types.D# ww4_sgAM6 [Occ=Once] ->
                    case ww2_sgAM4 of {
                      GHC.Types.D# ww6_sgAM8 [Occ=Once] ->
                          case Data.Complex.$w$s$catanh ww4_sgAM6 ww6_sgAM8 of {
                            (#,#) ww8_sgAMa [Occ=Once] ww9_sgAMb [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAMa ww9_sgAMb];
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex20
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [Data.Complex.$fFloatingComplex19
                                Data.Complex.$fFloatingComplex21];

Data.Complex.$fFloatingComplex18
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [Data.Complex.$fFloatingComplex19
                                Data.Complex.$fFloatingComplex19];

Data.Complex.$w$catanh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LC(S))LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAMc ww_sgAMd ww1_sgAMe]
        case
            Data.Complex.$w$cfromRational
                w_sgAMc Data.Complex.$fFloatingComplex20
        of
        { (#,#) ww3_sgAMg [Occ=Once] ww4_sgAMh [Occ=Once] ->
              case
                  Data.Complex.$w$cfromRational
                      w_sgAMc Data.Complex.$fFloatingComplex18
              of
              { (#,#) ww6_sgAMj ww7_sgAMk ->
                    case
                        Data.Complex.$w$c+ w_sgAMc ww6_sgAMj ww7_sgAMk ww_sgAMd ww1_sgAMe
                    of
                    { (#,#) ww9_sgAMm [Occ=Once] ww10_sgAMn [Occ=Once] ->
                          case
                              Data.Complex.$w$c- w_sgAMc ww6_sgAMj ww7_sgAMk ww_sgAMd ww1_sgAMe
                          of
                          { (#,#) ww12_sgAMp [Occ=Once] ww13_sgAMq [Occ=Once] ->
                                case
                                    Data.Complex.$w$c/
                                        w_sgAMc ww9_sgAMm ww10_sgAMn ww12_sgAMp ww13_sgAMq
                                of
                                { (#,#) ww15_sgAMs ww16_sgAMt ->
                                      let {
                                        sat_sgAMv [Occ=Once] :: a_sgxOH
                                        [LclId] =
                                            [w_sgAMc ww15_sgAMs ww16_sgAMt] \u []
                                                Data.Complex.$wmagnitude
                                                    w_sgAMc ww15_sgAMs ww16_sgAMt;
                                      } in 
                                        case GHC.Float.$p2RealFloat w_sgAMc of sat_sgAMu {
                                          __DEFAULT ->
                                              case GHC.Float.log sat_sgAMu sat_sgAMv of dt_sgAMw {
                                                __DEFAULT ->
                                                    case
                                                        Data.Complex.$wphase
                                                            w_sgAMc ww15_sgAMs ww16_sgAMt
                                                    of
                                                    dt1_sgAMx
                                                    { __DEFAULT ->
                                                          Data.Complex.$w$c*
                                                              w_sgAMc
                                                              ww3_sgAMg
                                                              ww4_sgAMh
                                                              dt_sgAMw
                                                              dt1_sgAMx;
                                                    };
                                              };
                                        };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$catanh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LC(S))LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAMy w1_sgAMz]
        case w1_sgAMz of {
          Data.Complex.:+ ww1_sgAMB [Occ=Once] ww2_sgAMC [Occ=Once] ->
              case Data.Complex.$w$catanh w_sgAMy ww1_sgAMB ww2_sgAMC of {
                (#,#) ww4_sgAME [Occ=Once] ww5_sgAMF [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAME ww5_sgAMF];
              };
        };

Data.Complex.$fFloatingComplex_nan :: GHC.Types.Double
[GblId] =
    [] \u []
        case /## [0.0## 0.0##] of wild2_sgAMG {
          __DEFAULT -> GHC.Types.D# [wild2_sgAMG];
        };

Data.Complex.$fFloatingComplex_inf :: GHC.Types.Double
[GblId] =
    [] \u []
        case /## [1.0## 0.0##] of wild2_sgAMH {
          __DEFAULT -> GHC.Types.D# [wild2_sgAMH];
        };

Data.Complex.$fFloatingComplex6
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_nan
                                    Data.Complex.$fFloatingComplex_nan];

Data.Complex.$fFloatingComplex5
  :: Data.Complex.Complex GHC.Types.Double
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_nan of {
          GHC.Types.D# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex6;
        };

Data.Complex.$fFloatingComplex8
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_inf
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$fFloatingComplex7
  :: Data.Complex.Complex GHC.Types.Double
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_inf of {
          GHC.Types.D# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex8;
        };

Data.Complex.$fFloatingComplex3 :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.D#! [1.0##];

Data.Complex.$fFloatingComplex2
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex3
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$w$s$c** [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=3,
 Str=<L,1*U(U(U),U(U))><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAMM ww_sgAMN ww1_sgAMO]
        let-no-escape {
          fail_sgAMP [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Double
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [w_sgAMM ww_sgAMN ww1_sgAMO] \r [ds_sgAMQ]
                  case w_sgAMM of {
                    Data.Complex.:+ ds1_sgAMS [Occ=Once!] ds2_sgAMT [Occ=Once!] ->
                        case ds2_sgAMT of {
                          GHC.Types.D# ds4_sgAMV ->
                              case ds1_sgAMS of {
                                GHC.Types.D# ds6_sgAMX ->
                                    let-no-escape {
                                      fail1_sgAMY [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Double
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [ww_sgAMN
                                                    ww1_sgAMO
                                                    ds4_sgAMV
                                                    ds6_sgAMX] \r [ds7_sgAMZ]
                                              case
                                                  __pkg_ccall base-4.11.0.0 [ds6_sgAMX
                                                                             GHC.Prim.realWorld#]
                                              of
                                              { (#,#) _ [Occ=Dead] ds9_sgAN3 [Occ=Once!] ->
                                                    case ds9_sgAN3 of {
                                                      __DEFAULT ->
                                                          case <## [ww_sgAMN 0.0##] of {
                                                            __DEFAULT ->
                                                                case ==## [ww_sgAMN 0.0##] of {
                                                                  __DEFAULT ->
                                                                      Data.Complex.$fFloatingComplex7;
                                                                  1# ->
                                                                      Data.Complex.$fFloatingComplex5;
                                                                };
                                                            1# -> Data.Complex.$fFloatingComplex4;
                                                          };
                                                      0# ->
                                                          case
                                                              __pkg_ccall base-4.11.0.0 [ds4_sgAMV
                                                                                         GHC.Prim.realWorld#]
                                                          of
                                                          { (#,#) _ [Occ=Dead]
                                                                  ds11_sgANa [Occ=Once!] ->
                                                                case ds11_sgANa of {
                                                                  __DEFAULT ->
                                                                      case <## [ww_sgAMN 0.0##] of {
                                                                        __DEFAULT ->
                                                                            case
                                                                                ==## [ww_sgAMN
                                                                                      0.0##]
                                                                            of
                                                                            { __DEFAULT ->
                                                                                  Data.Complex.$fFloatingComplex7;
                                                                              1# ->
                                                                                  Data.Complex.$fFloatingComplex5;
                                                                            };
                                                                        1# ->
                                                                            Data.Complex.$fFloatingComplex4;
                                                                      };
                                                                  0# ->
                                                                      case
                                                                          Data.Complex.$w$smagnitude
                                                                              ds6_sgAMX ds4_sgAMV
                                                                      of
                                                                      ww2_sgANe
                                                                      { __DEFAULT ->
                                                                            case
                                                                                logDouble# [ww2_sgANe]
                                                                            of
                                                                            wild5_sgANf
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      Data.Complex.$w$sphase
                                                                                          ds6_sgAMX
                                                                                          ds4_sgAMV
                                                                                  of
                                                                                  ww3_sgANg
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            *## [ww3_sgANg
                                                                                                 ww_sgAMN]
                                                                                        of
                                                                                        sat_sgANj
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  *## [wild5_sgANf
                                                                                                       ww1_sgAMO]
                                                                                              of
                                                                                              sat_sgANi
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        +## [sat_sgANi
                                                                                                             sat_sgANj]
                                                                                                    of
                                                                                                    y_sgANh
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              *## [ww3_sgANg
                                                                                                                   ww1_sgAMO]
                                                                                                          of
                                                                                                          sat_sgANm
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    *## [wild5_sgANf
                                                                                                                         ww_sgAMN]
                                                                                                                of
                                                                                                                sat_sgANl
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          -## [sat_sgANl
                                                                                                                               sat_sgANm]
                                                                                                                      of
                                                                                                                      sat_sgANn
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                expDouble# [sat_sgANn]
                                                                                                                            of
                                                                                                                            expx_sgANk
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sinDouble# [y_sgANh]
                                                                                                                                  of
                                                                                                                                  sat_sgANr
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            *## [expx_sgANk
                                                                                                                                                 sat_sgANr]
                                                                                                                                        of
                                                                                                                                        sat_sgANs
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              let {
                                                                                                                                                sat_sgANt [Occ=Once]
                                                                                                                                                  :: GHC.Types.Double
                                                                                                                                                [LclId] =
                                                                                                                                                    CCCS GHC.Types.D#! [sat_sgANs];
                                                                                                                                              } in 
                                                                                                                                                case
                                                                                                                                                    cosDouble# [y_sgANh]
                                                                                                                                                of
                                                                                                                                                sat_sgANo
                                                                                                                                                { __DEFAULT ->
                                                                                                                                                      case
                                                                                                                                                          *## [expx_sgANk
                                                                                                                                                               sat_sgANo]
                                                                                                                                                      of
                                                                                                                                                      sat_sgANp
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgANq [Occ=Once]
                                                                                                                                                                :: GHC.Types.Double
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.D#! [sat_sgANp];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgANq
                                                                                                                                                                               sat_sgANt];
                                                                                                                                                      };
                                                                                                                                                };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                    } in 
                                      case ==## [ds6_sgAMX 0.0##] of {
                                        __DEFAULT -> fail1_sgAMY GHC.Prim.void#;
                                        1# ->
                                            case ==## [ds4_sgAMV 0.0##] of {
                                              __DEFAULT -> fail1_sgAMY GHC.Prim.void#;
                                              1# ->
                                                  case <## [ww_sgAMN 0.0##] of {
                                                    __DEFAULT ->
                                                        case ==## [ww_sgAMN 0.0##] of {
                                                          __DEFAULT ->
                                                              Data.Complex.$fFloatingComplex4;
                                                          1# -> Data.Complex.$fFloatingComplex5;
                                                        };
                                                    1# -> Data.Complex.$fFloatingComplex7;
                                                  };
                                            };
                                      };
                              };
                        };
                  };
        } in 
          case ==## [ww_sgAMN 0.0##] of {
            __DEFAULT -> fail_sgAMP GHC.Prim.void#;
            1# ->
                case ==## [ww1_sgAMO 0.0##] of {
                  __DEFAULT -> fail_sgAMP GHC.Prim.void#;
                  1# -> Data.Complex.$fFloatingComplex2;
                };
          };

Data.Complex.$fFloatingComplex_$s$c** [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Str=<L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>,
 Unf=OtherCon []] =
    [] \r [w_sgANA w1_sgANB]
        case w1_sgANB of {
          Data.Complex.:+ ww1_sgAND [Occ=Once!] ww2_sgANE [Occ=Once!] ->
              case ww1_sgAND of {
                GHC.Types.D# ww4_sgANG [Occ=Once] ->
                    case ww2_sgANE of {
                      GHC.Types.D# ww6_sgANI [Occ=Once] ->
                          Data.Complex.$w$s$c** w_sgANA ww4_sgANG ww6_sgANI;
                    };
              };
        };

Data.Complex.$fFloatingComplex_nan1 :: GHC.Types.Float
[GblId] =
    [] \u []
        case divideFloat# [0.0# 0.0#] of wild2_sgANJ {
          __DEFAULT -> GHC.Types.F# [wild2_sgANJ];
        };

Data.Complex.$fFloatingComplex_inf1 :: GHC.Types.Float
[GblId] =
    [] \u []
        case divideFloat# [1.0# 0.0#] of wild2_sgANK {
          __DEFAULT -> GHC.Types.F# [wild2_sgANK];
        };

Data.Complex.$fFloatingComplex14
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_nan1
                                    Data.Complex.$fFloatingComplex_nan1];

Data.Complex.$fFloatingComplex13
  :: Data.Complex.Complex GHC.Types.Float
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_nan1 of {
          GHC.Types.F# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex14;
        };

Data.Complex.$fFloatingComplex16
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_inf1
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$fFloatingComplex15
  :: Data.Complex.Complex GHC.Types.Float
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_inf1 of {
          GHC.Types.F# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex16;
        };

Data.Complex.$fFloatingComplex11 :: GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.F#! [1.0#];

Data.Complex.$fFloatingComplex10
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex11
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$w$s$c**1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=3,
 Str=<L,1*U(U(U),U(U))><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgANP ww_sgANQ ww1_sgANR]
        let-no-escape {
          fail_sgANS [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Float
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [w_sgANP ww_sgANQ ww1_sgANR] \r [ds_sgANT]
                  case w_sgANP of {
                    Data.Complex.:+ ds1_sgANV [Occ=Once!] ds2_sgANW [Occ=Once!] ->
                        case ds2_sgANW of {
                          GHC.Types.F# ds4_sgANY ->
                              case ds1_sgANV of {
                                GHC.Types.F# ds6_sgAO0 ->
                                    let-no-escape {
                                      fail1_sgAO1 [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Float
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [ww_sgANQ
                                                    ww1_sgANR
                                                    ds4_sgANY
                                                    ds6_sgAO0] \r [ds7_sgAO2]
                                              case
                                                  __pkg_ccall base-4.11.0.0 [ds6_sgAO0
                                                                             GHC.Prim.realWorld#]
                                              of
                                              { (#,#) _ [Occ=Dead] ds9_sgAO6 [Occ=Once!] ->
                                                    case ds9_sgAO6 of {
                                                      __DEFAULT ->
                                                          case ltFloat# [ww_sgANQ 0.0#] of {
                                                            __DEFAULT ->
                                                                case eqFloat# [ww_sgANQ 0.0#] of {
                                                                  __DEFAULT ->
                                                                      Data.Complex.$fFloatingComplex15;
                                                                  1# ->
                                                                      Data.Complex.$fFloatingComplex13;
                                                                };
                                                            1# -> Data.Complex.$fFloatingComplex12;
                                                          };
                                                      0# ->
                                                          case
                                                              __pkg_ccall base-4.11.0.0 [ds4_sgANY
                                                                                         GHC.Prim.realWorld#]
                                                          of
                                                          { (#,#) _ [Occ=Dead]
                                                                  ds11_sgAOd [Occ=Once!] ->
                                                                case ds11_sgAOd of {
                                                                  __DEFAULT ->
                                                                      case
                                                                          ltFloat# [ww_sgANQ 0.0#]
                                                                      of
                                                                      { __DEFAULT ->
                                                                            case
                                                                                eqFloat# [ww_sgANQ
                                                                                          0.0#]
                                                                            of
                                                                            { __DEFAULT ->
                                                                                  Data.Complex.$fFloatingComplex15;
                                                                              1# ->
                                                                                  Data.Complex.$fFloatingComplex13;
                                                                            };
                                                                        1# ->
                                                                            Data.Complex.$fFloatingComplex12;
                                                                      };
                                                                  0# ->
                                                                      case
                                                                          Data.Complex.$w$smagnitude1
                                                                              ds6_sgAO0 ds4_sgANY
                                                                      of
                                                                      ww2_sgAOh
                                                                      { __DEFAULT ->
                                                                            case
                                                                                logFloat# [ww2_sgAOh]
                                                                            of
                                                                            wild5_sgAOi
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      Data.Complex.$w$sphase1
                                                                                          ds6_sgAO0
                                                                                          ds4_sgANY
                                                                                  of
                                                                                  ww3_sgAOj
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            timesFloat# [ww3_sgAOj
                                                                                                         ww_sgANQ]
                                                                                        of
                                                                                        sat_sgAOm
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  timesFloat# [wild5_sgAOi
                                                                                                               ww1_sgANR]
                                                                                              of
                                                                                              sat_sgAOl
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        plusFloat# [sat_sgAOl
                                                                                                                    sat_sgAOm]
                                                                                                    of
                                                                                                    y_sgAOk
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              timesFloat# [ww3_sgAOj
                                                                                                                           ww1_sgANR]
                                                                                                          of
                                                                                                          sat_sgAOp
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    timesFloat# [wild5_sgAOi
                                                                                                                                 ww_sgANQ]
                                                                                                                of
                                                                                                                sat_sgAOo
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          minusFloat# [sat_sgAOo
                                                                                                                                       sat_sgAOp]
                                                                                                                      of
                                                                                                                      sat_sgAOq
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                expFloat# [sat_sgAOq]
                                                                                                                            of
                                                                                                                            expx_sgAOn
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sinFloat# [y_sgAOk]
                                                                                                                                  of
                                                                                                                                  sat_sgAOu
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            timesFloat# [expx_sgAOn
                                                                                                                                                         sat_sgAOu]
                                                                                                                                        of
                                                                                                                                        sat_sgAOv
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              let {
                                                                                                                                                sat_sgAOw [Occ=Once]
                                                                                                                                                  :: GHC.Types.Float
                                                                                                                                                [LclId] =
                                                                                                                                                    CCCS GHC.Types.F#! [sat_sgAOv];
                                                                                                                                              } in 
                                                                                                                                                case
                                                                                                                                                    cosFloat# [y_sgAOk]
                                                                                                                                                of
                                                                                                                                                sat_sgAOr
                                                                                                                                                { __DEFAULT ->
                                                                                                                                                      case
                                                                                                                                                          timesFloat# [expx_sgAOn
                                                                                                                                                                       sat_sgAOr]
                                                                                                                                                      of
                                                                                                                                                      sat_sgAOs
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgAOt [Occ=Once]
                                                                                                                                                                :: GHC.Types.Float
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.F#! [sat_sgAOs];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgAOt
                                                                                                                                                                               sat_sgAOw];
                                                                                                                                                      };
                                                                                                                                                };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                    } in 
                                      case eqFloat# [ds6_sgAO0 0.0#] of {
                                        __DEFAULT -> fail1_sgAO1 GHC.Prim.void#;
                                        1# ->
                                            case eqFloat# [ds4_sgANY 0.0#] of {
                                              __DEFAULT -> fail1_sgAO1 GHC.Prim.void#;
                                              1# ->
                                                  case ltFloat# [ww_sgANQ 0.0#] of {
                                                    __DEFAULT ->
                                                        case eqFloat# [ww_sgANQ 0.0#] of {
                                                          __DEFAULT ->
                                                              Data.Complex.$fFloatingComplex12;
                                                          1# -> Data.Complex.$fFloatingComplex13;
                                                        };
                                                    1# -> Data.Complex.$fFloatingComplex15;
                                                  };
                                            };
                                      };
                              };
                        };
                  };
        } in 
          case eqFloat# [ww_sgANQ 0.0#] of {
            __DEFAULT -> fail_sgANS GHC.Prim.void#;
            1# ->
                case eqFloat# [ww1_sgANR 0.0#] of {
                  __DEFAULT -> fail_sgANS GHC.Prim.void#;
                  1# -> Data.Complex.$fFloatingComplex10;
                };
          };

Data.Complex.$fFloatingComplex_$s$c**1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Str=<L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>,
 Unf=OtherCon []] =
    [] \r [w_sgAOD w1_sgAOE]
        case w1_sgAOE of {
          Data.Complex.:+ ww1_sgAOG [Occ=Once!] ww2_sgAOH [Occ=Once!] ->
              case ww1_sgAOG of {
                GHC.Types.F# ww4_sgAOJ [Occ=Once] ->
                    case ww2_sgAOH of {
                      GHC.Types.F# ww6_sgAOL [Occ=Once] ->
                          Data.Complex.$w$s$c**1 w_sgAOD ww4_sgAOJ ww6_sgAOL;
                    };
              };
        };

Data.Complex.$w$c** [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> a -> a -> (# a, a #)
[GblId,
 Arity=4,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))><L,1*U(U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAOM w1_sgAON ww_sgAOO ww1_sgAOP]
        case
            GHC.Float.$p1RealFloat w_sgAOM
        of
        $dRealFrac_sgAOQ [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAOQ
              of
              $dReal_sgAOR [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p2Real $dReal_sgAOR
                    of
                    $dOrd_sgAOS [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A)>]
                    { __DEFAULT ->
                          case
                              GHC.Classes.$p1Ord $dOrd_sgAOS
                          of
                          $dEq_sgAOT [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                          { __DEFAULT ->
                                let {
                                  $dNum_sgAOU [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_sgxPv
                                  [LclId] =
                                      [$dReal_sgAOR] \u [] GHC.Real.$p1Real $dReal_sgAOR; } in
                                let {
                                  sat_sgAPy [Occ=Once] :: a_sgxPv
                                  [LclId] =
                                      [$dNum_sgAOU] \u []
                                          GHC.Num.fromInteger
                                              $dNum_sgAOU Data.Complex.$fFloatingComplex17;
                                } in 
                                  let-no-escape {
                                    fail_sgAOV [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                      :: GHC.Prim.Void# -> (# a_sgxPv, a_sgxPv #)
                                    [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                        sat-only [w_sgAOM
                                                  w1_sgAON
                                                  ww_sgAOO
                                                  ww1_sgAOP
                                                  $dRealFrac_sgAOQ
                                                  $dOrd_sgAOS
                                                  $dEq_sgAOT
                                                  $dNum_sgAOU] \r [ds_sgAOW]
                                            case w1_sgAON of {
                                              Data.Complex.:+ ds1_sgAOY ds2_sgAOZ ->
                                                  let {
                                                    $dFractional_sgAP0 [Dmd=<L,U(A,C(C1(U)),A,A)>]
                                                      :: GHC.Real.Fractional a_sgxPv
                                                    [LclId] =
                                                        [$dRealFrac_sgAOQ] \u []
                                                            GHC.Real.$p2RealFrac
                                                                $dRealFrac_sgAOQ; } in
                                                  let {
                                                    nan_sgAP1 [Dmd=<L,1*U>] :: a_sgxPv
                                                    [LclId] =
                                                        [$dNum_sgAOU $dFractional_sgAP0] \s []
                                                            let {
                                                              sat_sgAP3 [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgAOU] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgAOU
                                                                          Data.Complex.$fFloatingComplex17; } in
                                                            let {
                                                              sat_sgAP2 [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgAOU] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgAOU
                                                                          Data.Complex.$fFloatingComplex17;
                                                            } in 
                                                              GHC.Real./
                                                                  $dFractional_sgAP0
                                                                  sat_sgAP2
                                                                  sat_sgAP3; } in
                                                  let {
                                                    inf_sgAP4 [Dmd=<L,1*U>] :: a_sgxPv
                                                    [LclId] =
                                                        [$dNum_sgAOU $dFractional_sgAP0] \s []
                                                            let {
                                                              sat_sgAP6 [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgAOU] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgAOU
                                                                          Data.Complex.$fFloatingComplex17; } in
                                                            let {
                                                              sat_sgAP5 [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgAOU] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgAOU
                                                                          Data.Complex.$fFloatingComplex19;
                                                            } in 
                                                              GHC.Real./
                                                                  $dFractional_sgAP0
                                                                  sat_sgAP5
                                                                  sat_sgAP6; } in
                                                  let {
                                                    sat_sgAPo [Occ=Once] :: a_sgxPv
                                                    [LclId] =
                                                        [$dNum_sgAOU] \u []
                                                            GHC.Num.fromInteger
                                                                $dNum_sgAOU
                                                                Data.Complex.$fFloatingComplex17;
                                                  } in 
                                                    let-no-escape {
                                                      fail1_sgAP7 [Occ=Once*!T[1],
                                                                   Dmd=<L,1*C1(U(U,U))>]
                                                        :: GHC.Prim.Void# -> (# a_sgxPv, a_sgxPv #)
                                                      [LclId[JoinId(1)],
                                                       Arity=1,
                                                       Str=<L,A>,
                                                       Unf=OtherCon []] =
                                                          sat-only [w_sgAOM
                                                                    ww_sgAOO
                                                                    ww1_sgAOP
                                                                    $dOrd_sgAOS
                                                                    $dNum_sgAOU
                                                                    ds1_sgAOY
                                                                    ds2_sgAOZ
                                                                    nan_sgAP1
                                                                    inf_sgAP4] \r [ds3_sgAP8]
                                                              let-no-escape {
                                                                $j_sgAP9 [Occ=Once*T[0],
                                                                          Dmd=<L,1*U(U,U)>]
                                                                  :: (# a_sgxPv, a_sgxPv #)
                                                                [LclId[JoinId(0)],
                                                                 Unf=OtherCon []] =
                                                                    [ww_sgAOO
                                                                     $dOrd_sgAOS
                                                                     $dNum_sgAOU
                                                                     nan_sgAP1
                                                                     inf_sgAP4] \r []
                                                                        let {
                                                                          sat_sgAPa [Occ=Once]
                                                                            :: a_sgxPv
                                                                          [LclId] =
                                                                              [$dNum_sgAOU] \u []
                                                                                  GHC.Num.fromInteger
                                                                                      $dNum_sgAOU
                                                                                      Data.Complex.$fFloatingComplex17;
                                                                        } in 
                                                                          case
                                                                              GHC.Classes.compare
                                                                                  $dOrd_sgAOS
                                                                                  ww_sgAOO
                                                                                  sat_sgAPa
                                                                          of
                                                                          { GHC.Types.LT ->
                                                                                case
                                                                                    GHC.Num.fromInteger
                                                                                        $dNum_sgAOU
                                                                                        Data.Complex.$fFloatingComplex17
                                                                                of
                                                                                dt_sgAPc
                                                                                { __DEFAULT ->
                                                                                      (#,#) [dt_sgAPc
                                                                                             dt_sgAPc];
                                                                                };
                                                                            GHC.Types.EQ ->
                                                                                case
                                                                                    nan_sgAP1
                                                                                of
                                                                                dt_sgAPd
                                                                                { __DEFAULT ->
                                                                                      (#,#) [dt_sgAPd
                                                                                             dt_sgAPd];
                                                                                };
                                                                            GHC.Types.GT ->
                                                                                case
                                                                                    inf_sgAP4
                                                                                of
                                                                                dt_sgAPe
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          GHC.Num.fromInteger
                                                                                              $dNum_sgAOU
                                                                                              Data.Complex.$fFloatingComplex17
                                                                                      of
                                                                                      dt1_sgAPf
                                                                                      { __DEFAULT ->
                                                                                            (#,#) [dt_sgAPe
                                                                                                   dt1_sgAPf];
                                                                                      };
                                                                                };
                                                                          };
                                                              } in 
                                                                case
                                                                    GHC.Float.isInfinite
                                                                        w_sgAOM ds1_sgAOY
                                                                of
                                                                { GHC.Types.False ->
                                                                      case
                                                                          GHC.Float.isInfinite
                                                                              w_sgAOM ds2_sgAOZ
                                                                      of
                                                                      { GHC.Types.False ->
                                                                            case
                                                                                Data.Complex.$w$clog
                                                                                    w_sgAOM
                                                                                    ds1_sgAOY
                                                                                    ds2_sgAOZ
                                                                            of
                                                                            { (#,#) ww3_sgAPj [Occ=Once]
                                                                                    ww4_sgAPk [Occ=Once] ->
                                                                                  case
                                                                                      Data.Complex.$w$c*
                                                                                          w_sgAOM
                                                                                          ww3_sgAPj
                                                                                          ww4_sgAPk
                                                                                          ww_sgAOO
                                                                                          ww1_sgAOP
                                                                                  of
                                                                                  { (#,#) ww6_sgAPm [Occ=Once]
                                                                                          ww7_sgAPn [Occ=Once] ->
                                                                                        Data.Complex.$w$cexp
                                                                                            w_sgAOM
                                                                                            ww6_sgAPm
                                                                                            ww7_sgAPn;
                                                                                  };
                                                                            };
                                                                        GHC.Types.True -> $j_sgAP9;
                                                                      };
                                                                  GHC.Types.True -> $j_sgAP9;
                                                                };
                                                    } in 
                                                      case
                                                          GHC.Classes.==
                                                              $dEq_sgAOT ds1_sgAOY sat_sgAPo
                                                      of
                                                      { GHC.Types.False ->
                                                            fail1_sgAP7 GHC.Prim.void#;
                                                        GHC.Types.True ->
                                                            let {
                                                              sat_sgAPq [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgAOU] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgAOU
                                                                          Data.Complex.$fFloatingComplex17;
                                                            } in 
                                                              case
                                                                  GHC.Classes.==
                                                                      $dEq_sgAOT ds2_sgAOZ sat_sgAPq
                                                              of
                                                              { GHC.Types.False ->
                                                                    fail1_sgAP7 GHC.Prim.void#;
                                                                GHC.Types.True ->
                                                                    let {
                                                                      sat_sgAPs [Occ=Once]
                                                                        :: a_sgxPv
                                                                      [LclId] =
                                                                          [$dNum_sgAOU] \u []
                                                                              GHC.Num.fromInteger
                                                                                  $dNum_sgAOU
                                                                                  Data.Complex.$fFloatingComplex17;
                                                                    } in 
                                                                      case
                                                                          GHC.Classes.compare
                                                                              $dOrd_sgAOS
                                                                              ww_sgAOO
                                                                              sat_sgAPs
                                                                      of
                                                                      { GHC.Types.LT ->
                                                                            case
                                                                                inf_sgAP4
                                                                            of
                                                                            dt_sgAPu
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      GHC.Num.fromInteger
                                                                                          $dNum_sgAOU
                                                                                          Data.Complex.$fFloatingComplex17
                                                                                  of
                                                                                  dt1_sgAPv
                                                                                  { __DEFAULT ->
                                                                                        (#,#) [dt_sgAPu
                                                                                               dt1_sgAPv];
                                                                                  };
                                                                            };
                                                                        GHC.Types.EQ ->
                                                                            case
                                                                                nan_sgAP1
                                                                            of
                                                                            dt_sgAPw
                                                                            { __DEFAULT ->
                                                                                  (#,#) [dt_sgAPw
                                                                                         dt_sgAPw];
                                                                            };
                                                                        GHC.Types.GT ->
                                                                            case
                                                                                GHC.Num.fromInteger
                                                                                    $dNum_sgAOU
                                                                                    Data.Complex.$fFloatingComplex17
                                                                            of
                                                                            dt_sgAPx
                                                                            { __DEFAULT ->
                                                                                  (#,#) [dt_sgAPx
                                                                                         dt_sgAPx];
                                                                            };
                                                                      };
                                                              };
                                                      };
                                            };
                                  } in 
                                    case GHC.Classes.== $dEq_sgAOT ww_sgAOO sat_sgAPy of {
                                      GHC.Types.False -> fail_sgAOV GHC.Prim.void#;
                                      GHC.Types.True ->
                                          let {
                                            sat_sgAPA [Occ=Once] :: a_sgxPv
                                            [LclId] =
                                                [$dNum_sgAOU] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_sgAOU
                                                        Data.Complex.$fFloatingComplex17;
                                          } in 
                                            case GHC.Classes.== $dEq_sgAOT ww1_sgAOP sat_sgAPA of {
                                              GHC.Types.False -> fail_sgAOV GHC.Prim.void#;
                                              GHC.Types.True ->
                                                  case
                                                      GHC.Num.fromInteger
                                                          $dNum_sgAOU
                                                          Data.Complex.$fFloatingComplex19
                                                  of
                                                  dt_sgAPC
                                                  { __DEFAULT ->
                                                        case
                                                            GHC.Num.fromInteger
                                                                $dNum_sgAOU
                                                                Data.Complex.$fFloatingComplex17
                                                        of
                                                        dt1_sgAPD
                                                        { __DEFAULT -> (#,#) [dt_sgAPC dt1_sgAPD];
                                                        };
                                                  };
                                            };
                                    };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$c** [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))><L,1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAPE w1_sgAPF w2_sgAPG]
        case w2_sgAPG of {
          Data.Complex.:+ ww1_sgAPI [Occ=Once] ww2_sgAPJ [Occ=Once] ->
              case Data.Complex.$w$c** w_sgAPE w1_sgAPF ww1_sgAPI ww2_sgAPJ of {
                (#,#) ww4_sgAPL [Occ=Once] ww5_sgAPM [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAPL ww5_sgAPM];
              };
        };

Data.Complex.$fFloatingComplex_$s$cexpm2 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAPN]
        case eta_sgAPN of {
          Data.Complex.:+ a_sgAPP [Occ=Once!] b_sgAPQ [Occ=Once!] ->
              case a_sgAPP of {
                GHC.Types.F# x_sgAPS ->
                    case b_sgAPQ of {
                      GHC.Types.F# x1_sgAPU ->
                          case timesFloat# [x1_sgAPU x1_sgAPU] of sat_sgAPW {
                            __DEFAULT ->
                                case timesFloat# [x_sgAPS x_sgAPS] of sat_sgAPV {
                                  __DEFAULT ->
                                      case plusFloat# [sat_sgAPV sat_sgAPW] of sat_sgAPX {
                                        __DEFAULT ->
                                            case ltFloat# [sat_sgAPX 1.0#] of {
                                              __DEFAULT ->
                                                  case expFloat# [x_sgAPS] of expx_sgAPZ {
                                                    __DEFAULT ->
                                                        case sinFloat# [x1_sgAPU] of sat_sgAQ4 {
                                                          __DEFAULT ->
                                                              case
                                                                  timesFloat# [expx_sgAPZ sat_sgAQ4]
                                                              of
                                                              sat_sgAQ5
                                                              { __DEFAULT ->
                                                                    let {
                                                                      sat_sgAQ6 [Occ=Once]
                                                                        :: GHC.Types.Float
                                                                      [LclId] =
                                                                          CCCS GHC.Types.F#! [sat_sgAQ5];
                                                                    } in 
                                                                      case
                                                                          cosFloat# [x1_sgAPU]
                                                                      of
                                                                      sat_sgAQ0
                                                                      { __DEFAULT ->
                                                                            case
                                                                                timesFloat# [expx_sgAPZ
                                                                                             sat_sgAQ0]
                                                                            of
                                                                            sat_sgAQ1
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      minusFloat# [sat_sgAQ1
                                                                                                   1.0#]
                                                                                  of
                                                                                  sat_sgAQ2
                                                                                  { __DEFAULT ->
                                                                                        let {
                                                                                          sat_sgAQ3 [Occ=Once]
                                                                                            :: GHC.Types.Float
                                                                                          [LclId] =
                                                                                              CCCS GHC.Types.F#! [sat_sgAQ2];
                                                                                        } in 
                                                                                          Data.Complex.:+ [sat_sgAQ3
                                                                                                           sat_sgAQ6];
                                                                                  };
                                                                            };
                                                                      };
                                                              };
                                                        };
                                                  };
                                              1# ->
                                                  case
                                                      __pkg_ccall base-4.11.0.0 [x_sgAPS
                                                                                 GHC.Prim.realWorld#]
                                                  of
                                                  { (#,#) _ [Occ=Dead] ds4_sgAQa ->
                                                        case
                                                            divideFloat# [x1_sgAPU 2.0#]
                                                        of
                                                        sat_sgAQc
                                                        { __DEFAULT ->
                                                              case
                                                                  sinFloat# [sat_sgAQc]
                                                              of
                                                              v_sgAQb [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        plusFloat# [v_sgAQb v_sgAQb]
                                                                    of
                                                                    sat_sgAQe
                                                                    { __DEFAULT ->
                                                                          case
                                                                              timesFloat# [sat_sgAQe
                                                                                           v_sgAQb]
                                                                          of
                                                                          sat_sgAQf
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateFloat# [sat_sgAQf]
                                                                                of
                                                                                w_sgAQd
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          sinFloat# [x1_sgAPU]
                                                                                      of
                                                                                      sat_sgAQl
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                plusFloat# [ds4_sgAQa
                                                                                                            1.0#]
                                                                                            of
                                                                                            sat_sgAQk
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      timesFloat# [sat_sgAQk
                                                                                                                   sat_sgAQl]
                                                                                                  of
                                                                                                  sat_sgAQm
                                                                                                  { __DEFAULT ->
                                                                                                        let {
                                                                                                          sat_sgAQn [Occ=Once]
                                                                                                            :: GHC.Types.Float
                                                                                                          [LclId] =
                                                                                                              CCCS GHC.Types.F#! [sat_sgAQm];
                                                                                                        } in 
                                                                                                          case
                                                                                                              timesFloat# [ds4_sgAQa
                                                                                                                           w_sgAQd]
                                                                                                          of
                                                                                                          sat_sgAQg
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    plusFloat# [sat_sgAQg
                                                                                                                                ds4_sgAQa]
                                                                                                                of
                                                                                                                sat_sgAQh
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          plusFloat# [sat_sgAQh
                                                                                                                                      w_sgAQd]
                                                                                                                      of
                                                                                                                      sat_sgAQi
                                                                                                                      { __DEFAULT ->
                                                                                                                            let {
                                                                                                                              sat_sgAQj [Occ=Once]
                                                                                                                                :: GHC.Types.Float
                                                                                                                              [LclId] =
                                                                                                                                  CCCS GHC.Types.F#! [sat_sgAQi];
                                                                                                                            } in 
                                                                                                                              Data.Complex.:+ [sat_sgAQj
                                                                                                                                               sat_sgAQn];
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAQo]
        case eta_sgAQo of {
          Data.Complex.:+ a_sgAQq [Occ=Once!] b_sgAQr [Occ=Once!] ->
              case a_sgAQq of {
                GHC.Types.D# x_sgAQt ->
                    case b_sgAQr of {
                      GHC.Types.D# x1_sgAQv ->
                          case *## [x1_sgAQv x1_sgAQv] of sat_sgAQx {
                            __DEFAULT ->
                                case *## [x_sgAQt x_sgAQt] of sat_sgAQw {
                                  __DEFAULT ->
                                      case +## [sat_sgAQw sat_sgAQx] of sat_sgAQy {
                                        __DEFAULT ->
                                            case <## [sat_sgAQy 1.0##] of {
                                              __DEFAULT ->
                                                  case expDouble# [x_sgAQt] of expx_sgAQA {
                                                    __DEFAULT ->
                                                        case sinDouble# [x1_sgAQv] of sat_sgAQF {
                                                          __DEFAULT ->
                                                              case
                                                                  *## [expx_sgAQA sat_sgAQF]
                                                              of
                                                              sat_sgAQG
                                                              { __DEFAULT ->
                                                                    let {
                                                                      sat_sgAQH [Occ=Once]
                                                                        :: GHC.Types.Double
                                                                      [LclId] =
                                                                          CCCS GHC.Types.D#! [sat_sgAQG];
                                                                    } in 
                                                                      case
                                                                          cosDouble# [x1_sgAQv]
                                                                      of
                                                                      sat_sgAQB
                                                                      { __DEFAULT ->
                                                                            case
                                                                                *## [expx_sgAQA
                                                                                     sat_sgAQB]
                                                                            of
                                                                            sat_sgAQC
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      -## [sat_sgAQC
                                                                                           1.0##]
                                                                                  of
                                                                                  sat_sgAQD
                                                                                  { __DEFAULT ->
                                                                                        let {
                                                                                          sat_sgAQE [Occ=Once]
                                                                                            :: GHC.Types.Double
                                                                                          [LclId] =
                                                                                              CCCS GHC.Types.D#! [sat_sgAQD];
                                                                                        } in 
                                                                                          Data.Complex.:+ [sat_sgAQE
                                                                                                           sat_sgAQH];
                                                                                  };
                                                                            };
                                                                      };
                                                              };
                                                        };
                                                  };
                                              1# ->
                                                  case
                                                      __pkg_ccall base-4.11.0.0 [x_sgAQt
                                                                                 GHC.Prim.realWorld#]
                                                  of
                                                  { (#,#) _ [Occ=Dead] ds4_sgAQL ->
                                                        case /## [x1_sgAQv 2.0##] of sat_sgAQN {
                                                          __DEFAULT ->
                                                              case
                                                                  sinDouble# [sat_sgAQN]
                                                              of
                                                              v_sgAQM [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        +## [v_sgAQM v_sgAQM]
                                                                    of
                                                                    sat_sgAQP
                                                                    { __DEFAULT ->
                                                                          case
                                                                              *## [sat_sgAQP
                                                                                   v_sgAQM]
                                                                          of
                                                                          sat_sgAQQ
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateDouble# [sat_sgAQQ]
                                                                                of
                                                                                w_sgAQO
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          sinDouble# [x1_sgAQv]
                                                                                      of
                                                                                      sat_sgAQW
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                +## [ds4_sgAQL
                                                                                                     1.0##]
                                                                                            of
                                                                                            sat_sgAQV
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      *## [sat_sgAQV
                                                                                                           sat_sgAQW]
                                                                                                  of
                                                                                                  sat_sgAQX
                                                                                                  { __DEFAULT ->
                                                                                                        let {
                                                                                                          sat_sgAQY [Occ=Once]
                                                                                                            :: GHC.Types.Double
                                                                                                          [LclId] =
                                                                                                              CCCS GHC.Types.D#! [sat_sgAQX];
                                                                                                        } in 
                                                                                                          case
                                                                                                              *## [ds4_sgAQL
                                                                                                                   w_sgAQO]
                                                                                                          of
                                                                                                          sat_sgAQR
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    +## [sat_sgAQR
                                                                                                                         ds4_sgAQL]
                                                                                                                of
                                                                                                                sat_sgAQS
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          +## [sat_sgAQS
                                                                                                                               w_sgAQO]
                                                                                                                      of
                                                                                                                      sat_sgAQT
                                                                                                                      { __DEFAULT ->
                                                                                                                            let {
                                                                                                                              sat_sgAQU [Occ=Once]
                                                                                                                                :: GHC.Types.Double
                                                                                                                              [LclId] =
                                                                                                                                  CCCS GHC.Types.D#! [sat_sgAQT];
                                                                                                                            } in 
                                                                                                                              Data.Complex.:+ [sat_sgAQU
                                                                                                                                               sat_sgAQY];
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(LLC(C(S))LLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgAQZ eta_sgAR0]
        case eta_sgAR0 of {
          Data.Complex.:+ a1_sgAR2 b_sgAR3 ->
              case
                  GHC.Float.$p1RealFloat $dRealFloat_sgAQZ
              of
              $dRealFrac_sgAR4 [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1RealFrac $dRealFrac_sgAR4
                    of
                    $dReal_sgAR5 [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
                    { __DEFAULT ->
                          let {
                            $dNum_sgAR6 [Dmd=<L,U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U))>]
                              :: GHC.Num.Num a_agsO1
                            [LclId] =
                                [$dReal_sgAR5] \u [] GHC.Real.$p1Real $dReal_sgAR5; } in
                          let {
                            sat_sgARb [Occ=Once] :: a_agsO1
                            [LclId] =
                                [$dNum_sgAR6] \u []
                                    GHC.Num.fromInteger
                                        $dNum_sgAR6 Data.Complex.$fFloatingComplex19; } in
                          let {
                            sat_sgARa [Occ=Once] :: a_agsO1
                            [LclId] =
                                [a1_sgAR2 b_sgAR3 $dNum_sgAR6] \u []
                                    let {
                                      sat_sgAR9 [Occ=Once] :: a_agsO1
                                      [LclId] =
                                          [b_sgAR3 $dNum_sgAR6] \u []
                                              GHC.Num.* $dNum_sgAR6 b_sgAR3 b_sgAR3; } in
                                    let {
                                      sat_sgAR8 [Occ=Once] :: a_agsO1
                                      [LclId] =
                                          [a1_sgAR2 $dNum_sgAR6] \u []
                                              GHC.Num.* $dNum_sgAR6 a1_sgAR2 a1_sgAR2;
                                    } in  GHC.Num.+ $dNum_sgAR6 sat_sgAR8 sat_sgAR9;
                          } in 
                            case GHC.Real.$p2Real $dReal_sgAR5 of sat_sgAR7 {
                              __DEFAULT ->
                                  case GHC.Classes.< sat_sgAR7 sat_sgARa sat_sgARb of {
                                    GHC.Types.False ->
                                        case
                                            Data.Complex.$w$cexp $dRealFloat_sgAQZ a1_sgAR2 b_sgAR3
                                        of
                                        { (#,#) ww1_sgARe [Occ=Once] ww2_sgARf [Occ=Once] ->
                                              case
                                                  Data.Complex.$w$cfromInteger
                                                      $dRealFloat_sgAQZ
                                                      Data.Complex.$fFloatingComplex19
                                              of
                                              { (#,#) ww4_sgARh [Occ=Once] ww5_sgARi [Occ=Once] ->
                                                    case
                                                        Data.Complex.$w$c-
                                                            $dRealFloat_sgAQZ
                                                            ww1_sgARe
                                                            ww2_sgARf
                                                            ww4_sgARh
                                                            ww5_sgARi
                                                    of
                                                    { (#,#) ww7_sgARk [Occ=Once]
                                                            ww8_sgARl [Occ=Once] ->
                                                          Data.Complex.:+ [ww7_sgARk ww8_sgARl];
                                                    };
                                              };
                                        };
                                    GHC.Types.True ->
                                        let {
                                          $dFloating_sgARm [Dmd=<L,U(A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A)>]
                                            :: GHC.Float.Floating a_agsO1
                                          [LclId] =
                                              [$dRealFloat_sgAQZ] \u []
                                                  GHC.Float.$p2RealFloat $dRealFloat_sgAQZ; } in
                                        let {
                                          u_sgARn :: a_agsO1
                                          [LclId] =
                                              [a1_sgAR2 $dFloating_sgARm] \u []
                                                  GHC.Float.expm1 $dFloating_sgARm a1_sgAR2; } in
                                        let {
                                          w_sgARo :: a_agsO1
                                          [LclId] =
                                              [b_sgAR3
                                               $dRealFrac_sgAR4
                                               $dNum_sgAR6
                                               $dFloating_sgARm] \u []
                                                  let {
                                                    sat_sgARv [Occ=Once] :: a_agsO1
                                                    [LclId] =
                                                        [b_sgAR3
                                                         $dRealFrac_sgAR4
                                                         $dNum_sgAR6
                                                         $dFloating_sgARm] \u []
                                                            let {
                                                              v_sgARp :: a_agsO1
                                                              [LclId] =
                                                                  [b_sgAR3
                                                                   $dRealFrac_sgAR4
                                                                   $dNum_sgAR6
                                                                   $dFloating_sgARm] \u []
                                                                      let {
                                                                        sat_sgARs [Occ=Once]
                                                                          :: a_agsO1
                                                                        [LclId] =
                                                                            [b_sgAR3
                                                                             $dRealFrac_sgAR4
                                                                             $dNum_sgAR6] \u []
                                                                                let {
                                                                                  sat_sgARr [Occ=Once]
                                                                                    :: a_agsO1
                                                                                  [LclId] =
                                                                                      [$dNum_sgAR6] \u []
                                                                                          GHC.Num.fromInteger
                                                                                              $dNum_sgAR6
                                                                                              Data.Complex.$fFloatingComplex21;
                                                                                } in 
                                                                                  case
                                                                                      GHC.Real.$p2RealFrac
                                                                                          $dRealFrac_sgAR4
                                                                                  of
                                                                                  sat_sgARq
                                                                                  { __DEFAULT ->
                                                                                        GHC.Real./
                                                                                            sat_sgARq
                                                                                            b_sgAR3
                                                                                            sat_sgARr;
                                                                                  };
                                                                      } in 
                                                                        GHC.Float.sin
                                                                            $dFloating_sgARm
                                                                            sat_sgARs; } in
                                                            let {
                                                              sat_sgARu [Occ=Once] :: a_agsO1
                                                              [LclId] =
                                                                  [$dNum_sgAR6 v_sgARp] \u []
                                                                      let {
                                                                        sat_sgARt [Occ=Once]
                                                                          :: a_agsO1
                                                                        [LclId] =
                                                                            [$dNum_sgAR6] \u []
                                                                                GHC.Num.fromInteger
                                                                                    $dNum_sgAR6
                                                                                    Data.Complex.$fFloatingComplex21;
                                                                      } in 
                                                                        GHC.Num.*
                                                                            $dNum_sgAR6
                                                                            sat_sgARt
                                                                            v_sgARp;
                                                            } in 
                                                              GHC.Num.*
                                                                  $dNum_sgAR6 sat_sgARu v_sgARp;
                                                  } in  GHC.Num.negate $dNum_sgAR6 sat_sgARv; } in
                                        let {
                                          sat_sgARx [Occ=Once] :: a_agsO1
                                          [LclId] =
                                              [$dNum_sgAR6 u_sgARn w_sgARo] \u []
                                                  let {
                                                    sat_sgARw [Occ=Once] :: a_agsO1
                                                    [LclId] =
                                                        [$dNum_sgAR6 u_sgARn w_sgARo] \u []
                                                            GHC.Num.* $dNum_sgAR6 u_sgARn w_sgARo;
                                                  } in  GHC.Num.+ $dNum_sgAR6 sat_sgARw u_sgARn;
                                        } in 
                                          case GHC.Num.+ $dNum_sgAR6 sat_sgARx w_sgARo of dt_sgARy {
                                            __DEFAULT ->
                                                let {
                                                  sat_sgARB [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [b_sgAR3 $dFloating_sgARm] \u []
                                                          GHC.Float.sin
                                                              $dFloating_sgARm b_sgAR3; } in
                                                let {
                                                  sat_sgARA [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [$dNum_sgAR6 u_sgARn] \u []
                                                          let {
                                                            sat_sgARz [Occ=Once] :: a_agsO1
                                                            [LclId] =
                                                                [$dNum_sgAR6] \u []
                                                                    GHC.Num.fromInteger
                                                                        $dNum_sgAR6
                                                                        Data.Complex.$fFloatingComplex19;
                                                          } in 
                                                            GHC.Num.+ $dNum_sgAR6 u_sgARn sat_sgARz;
                                                } in 
                                                  case
                                                      GHC.Num.* $dNum_sgAR6 sat_sgARA sat_sgARB
                                                  of
                                                  dt1_sgARC
                                                  { __DEFAULT ->
                                                        Data.Complex.:+ [dt_sgARy dt1_sgARC];
                                                  };
                                          };
                                  };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1p1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgARD]
        case eta_sgARD of {
          Data.Complex.:+ a_sgARF [Occ=Once!] b_sgARG [Occ=Once!] ->
              case a_sgARF of {
                GHC.Types.F# x_sgARI ->
                    case b_sgARG of {
                      GHC.Types.F# y_sgARK ->
                          case fabsFloat# [x_sgARI] of sat_sgARS {
                            __DEFAULT ->
                                let-no-escape {
                                  $j_sgARL [Occ=Once*T[0], Dmd=<L,1*U(U,U)>]
                                    :: Data.Complex.Complex GHC.Types.Float
                                  [LclId[JoinId(0)], Str=m, Unf=OtherCon []] =
                                      [x_sgARI y_sgARK] \r []
                                          case plusFloat# [1.0# x_sgARI] of ww_sgARM [Dmd=<S,U>] {
                                            __DEFAULT ->
                                                case
                                                    Data.Complex.$w$smagnitude1 ww_sgARM y_sgARK
                                                of
                                                ww1_sgARN
                                                { __DEFAULT ->
                                                      case logFloat# [ww1_sgARN] of wild3_sgARO {
                                                        __DEFAULT ->
                                                            case
                                                                Data.Complex.$w$sphase1
                                                                    ww_sgARM y_sgARK
                                                            of
                                                            ww2_sgARP
                                                            { __DEFAULT ->
                                                                  let {
                                                                    sat_sgARR [Occ=Once]
                                                                      :: GHC.Types.Float
                                                                    [LclId] =
                                                                        CCCS GHC.Types.F#! [ww2_sgARP]; } in
                                                                  let {
                                                                    sat_sgARQ [Occ=Once]
                                                                      :: GHC.Types.Float
                                                                    [LclId] =
                                                                        CCCS GHC.Types.F#! [wild3_sgARO];
                                                                  } in 
                                                                    Data.Complex.:+ [sat_sgARQ
                                                                                     sat_sgARR];
                                                            };
                                                      };
                                                };
                                          };
                                } in 
                                  case ltFloat# [sat_sgARS 0.5#] of {
                                    __DEFAULT -> $j_sgARL;
                                    1# ->
                                        case fabsFloat# [y_sgARK] of sat_sgARU {
                                          __DEFAULT ->
                                              case ltFloat# [sat_sgARU 0.5#] of {
                                                __DEFAULT -> $j_sgARL;
                                                1# ->
                                                    case
                                                        timesFloat# [y_sgARK y_sgARK]
                                                    of
                                                    sat_sgAS0
                                                    { __DEFAULT ->
                                                          case
                                                              timesFloat# [x_sgARI x_sgARI]
                                                          of
                                                          sat_sgARY
                                                          { __DEFAULT ->
                                                                case
                                                                    plusFloat# [x_sgARI x_sgARI]
                                                                of
                                                                sat_sgARX
                                                                { __DEFAULT ->
                                                                      case
                                                                          plusFloat# [sat_sgARX
                                                                                      sat_sgARY]
                                                                      of
                                                                      sat_sgARZ
                                                                      { __DEFAULT ->
                                                                            case
                                                                                plusFloat# [sat_sgARZ
                                                                                            sat_sgAS0]
                                                                            of
                                                                            x1_sgARW [Dmd=<S,U>]
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      plusFloat# [x1_sgARW
                                                                                                  1.0#]
                                                                                  of
                                                                                  sat_sgAS1
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            sqrtFloat# [sat_sgAS1]
                                                                                        of
                                                                                        sat_sgAS2
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  plusFloat# [1.0#
                                                                                                              sat_sgAS2]
                                                                                              of
                                                                                              sat_sgAS3
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        divideFloat# [x1_sgARW
                                                                                                                      sat_sgAS3]
                                                                                                    of
                                                                                                    wild3_sgAS4
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              __pkg_ccall base-4.11.0.0 [wild3_sgAS4
                                                                                                                                         GHC.Prim.realWorld#]
                                                                                                          of
                                                                                                          { (#,#) _ [Occ=Dead]
                                                                                                                  ds4_sgAS8 [Occ=Once] ->
                                                                                                                case
                                                                                                                    plusFloat# [1.0#
                                                                                                                                x_sgARI]
                                                                                                                of
                                                                                                                sat_sgAS9
                                                                                                                { __DEFAULT ->
                                                                                                                      let {
                                                                                                                        sat_sgASa [Occ=Once]
                                                                                                                          :: GHC.Types.Float
                                                                                                                        [LclId] =
                                                                                                                            CCCS GHC.Types.F#! [sat_sgAS9];
                                                                                                                      } in 
                                                                                                                        case
                                                                                                                            GHC.Float.$w$catan1
                                                                                                                                sat_sgASa
                                                                                                                                y_sgARK
                                                                                                                        of
                                                                                                                        ww2_sgASb
                                                                                                                        { __DEFAULT ->
                                                                                                                              let {
                                                                                                                                sat_sgASd [Occ=Once]
                                                                                                                                  :: GHC.Types.Float
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.F#! [ww2_sgASb]; } in
                                                                                                                              let {
                                                                                                                                sat_sgASc [Occ=Once]
                                                                                                                                  :: GHC.Types.Float
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.F#! [ds4_sgAS8];
                                                                                                                              } in 
                                                                                                                                Data.Complex.:+ [sat_sgASc
                                                                                                                                                 sat_sgASd];
                                                                                                                        };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                        };
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1p [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgASe]
        case eta_sgASe of {
          Data.Complex.:+ a_sgASg [Occ=Once!] b_sgASh [Occ=Once!] ->
              case a_sgASg of {
                GHC.Types.D# x_sgASj ->
                    case b_sgASh of {
                      GHC.Types.D# y_sgASl ->
                          case fabsDouble# [x_sgASj] of sat_sgASt {
                            __DEFAULT ->
                                let-no-escape {
                                  $j_sgASm [Occ=Once*T[0], Dmd=<L,1*U(U,U)>]
                                    :: Data.Complex.Complex GHC.Types.Double
                                  [LclId[JoinId(0)], Str=m, Unf=OtherCon []] =
                                      [x_sgASj y_sgASl] \r []
                                          case +## [1.0## x_sgASj] of ww_sgASn [Dmd=<S,U>] {
                                            __DEFAULT ->
                                                case
                                                    Data.Complex.$w$smagnitude ww_sgASn y_sgASl
                                                of
                                                ww1_sgASo
                                                { __DEFAULT ->
                                                      case logDouble# [ww1_sgASo] of wild3_sgASp {
                                                        __DEFAULT ->
                                                            case
                                                                Data.Complex.$w$sphase
                                                                    ww_sgASn y_sgASl
                                                            of
                                                            ww2_sgASq
                                                            { __DEFAULT ->
                                                                  let {
                                                                    sat_sgASs [Occ=Once]
                                                                      :: GHC.Types.Double
                                                                    [LclId] =
                                                                        CCCS GHC.Types.D#! [ww2_sgASq]; } in
                                                                  let {
                                                                    sat_sgASr [Occ=Once]
                                                                      :: GHC.Types.Double
                                                                    [LclId] =
                                                                        CCCS GHC.Types.D#! [wild3_sgASp];
                                                                  } in 
                                                                    Data.Complex.:+ [sat_sgASr
                                                                                     sat_sgASs];
                                                            };
                                                      };
                                                };
                                          };
                                } in 
                                  case <## [sat_sgASt 0.5##] of {
                                    __DEFAULT -> $j_sgASm;
                                    1# ->
                                        case fabsDouble# [y_sgASl] of sat_sgASv {
                                          __DEFAULT ->
                                              case <## [sat_sgASv 0.5##] of {
                                                __DEFAULT -> $j_sgASm;
                                                1# ->
                                                    case *## [y_sgASl y_sgASl] of sat_sgASB {
                                                      __DEFAULT ->
                                                          case *## [x_sgASj x_sgASj] of sat_sgASz {
                                                            __DEFAULT ->
                                                                case
                                                                    +## [x_sgASj x_sgASj]
                                                                of
                                                                sat_sgASy
                                                                { __DEFAULT ->
                                                                      case
                                                                          +## [sat_sgASy sat_sgASz]
                                                                      of
                                                                      sat_sgASA
                                                                      { __DEFAULT ->
                                                                            case
                                                                                +## [sat_sgASA
                                                                                     sat_sgASB]
                                                                            of
                                                                            x1_sgASx [Dmd=<S,U>]
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      +## [x1_sgASx
                                                                                           1.0##]
                                                                                  of
                                                                                  sat_sgASC
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            sqrtDouble# [sat_sgASC]
                                                                                        of
                                                                                        sat_sgASD
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  +## [1.0##
                                                                                                       sat_sgASD]
                                                                                              of
                                                                                              sat_sgASE
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        /## [x1_sgASx
                                                                                                             sat_sgASE]
                                                                                                    of
                                                                                                    wild3_sgASF
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              __pkg_ccall base-4.11.0.0 [wild3_sgASF
                                                                                                                                         GHC.Prim.realWorld#]
                                                                                                          of
                                                                                                          { (#,#) _ [Occ=Dead]
                                                                                                                  ds4_sgASJ [Occ=Once] ->
                                                                                                                case
                                                                                                                    +## [1.0##
                                                                                                                         x_sgASj]
                                                                                                                of
                                                                                                                sat_sgASK
                                                                                                                { __DEFAULT ->
                                                                                                                      let {
                                                                                                                        sat_sgASL [Occ=Once]
                                                                                                                          :: GHC.Types.Double
                                                                                                                        [LclId] =
                                                                                                                            CCCS GHC.Types.D#! [sat_sgASK];
                                                                                                                      } in 
                                                                                                                        case
                                                                                                                            GHC.Float.$w$catan2
                                                                                                                                sat_sgASL
                                                                                                                                y_sgASl
                                                                                                                        of
                                                                                                                        ww2_sgASM
                                                                                                                        { __DEFAULT ->
                                                                                                                              let {
                                                                                                                                sat_sgASO [Occ=Once]
                                                                                                                                  :: GHC.Types.Double
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.D#! [ww2_sgASM]; } in
                                                                                                                              let {
                                                                                                                                sat_sgASN [Occ=Once]
                                                                                                                                  :: GHC.Types.Double
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.D#! [ds4_sgASJ];
                                                                                                                              } in 
                                                                                                                                Data.Complex.:+ [sat_sgASN
                                                                                                                                                 sat_sgASO];
                                                                                                                        };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                        };
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clog1p [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgASP eta_sgASQ]
        case eta_sgASQ of {
          Data.Complex.:+ a1_sgASS b_sgAST ->
              case
                  GHC.Float.$p1RealFloat $dRealFloat_sgASP
              of
              $dRealFrac_sgASU [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1RealFrac $dRealFrac_sgASU
                    of
                    $dReal_sgASV [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
                    { __DEFAULT ->
                          let {
                            $dNum_sgASW [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
                              :: GHC.Num.Num a_agsO1
                            [LclId] =
                                [$dReal_sgASV] \u [] GHC.Real.$p1Real $dReal_sgASV;
                          } in 
                            case
                                GHC.Real.$p2Real $dReal_sgASV
                            of
                            $dOrd_sgASX [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                            { __DEFAULT ->
                                  let {
                                    $dFractional_sgASY [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
                                      :: GHC.Real.Fractional a_agsO1
                                    [LclId] =
                                        [$dRealFrac_sgASU] \u []
                                            GHC.Real.$p2RealFrac $dRealFrac_sgASU; } in
                                  let {
                                    sat_sgAT0 [Occ=Once] :: a_agsO1
                                    [LclId] =
                                        [$dFractional_sgASY] \u []
                                            GHC.Real.fromRational
                                                $dFractional_sgASY
                                                Data.Complex.$fFloatingComplex20; } in
                                  let {
                                    sat_sgASZ [Occ=Once] :: a_agsO1
                                    [LclId] =
                                        [a1_sgASS $dNum_sgASW] \u []
                                            GHC.Num.abs $dNum_sgASW a1_sgASS;
                                  } in 
                                    case GHC.Classes.< $dOrd_sgASX sat_sgASZ sat_sgAT0 of {
                                      GHC.Types.False ->
                                          case
                                              Data.Complex.$w$cfromInteger
                                                  $dRealFloat_sgASP Data.Complex.$fFloatingComplex19
                                          of
                                          { (#,#) ww1_sgAT3 [Occ=Once] ww2_sgAT4 [Occ=Once] ->
                                                case
                                                    Data.Complex.$w$c+
                                                        $dRealFloat_sgASP
                                                        ww1_sgAT3
                                                        ww2_sgAT4
                                                        a1_sgASS
                                                        b_sgAST
                                                of
                                                { (#,#) ww4_sgAT6 [Occ=Once] ww5_sgAT7 [Occ=Once] ->
                                                      case
                                                          Data.Complex.$w$clog
                                                              $dRealFloat_sgASP ww4_sgAT6 ww5_sgAT7
                                                      of
                                                      { (#,#) ww7_sgAT9 [Occ=Once]
                                                              ww8_sgATa [Occ=Once] ->
                                                            Data.Complex.:+ [ww7_sgAT9 ww8_sgATa];
                                                      };
                                                };
                                          };
                                      GHC.Types.True ->
                                          let {
                                            sat_sgATc [Occ=Once] :: a_agsO1
                                            [LclId] =
                                                [$dFractional_sgASY] \u []
                                                    GHC.Real.fromRational
                                                        $dFractional_sgASY
                                                        Data.Complex.$fFloatingComplex20; } in
                                          let {
                                            sat_sgATb [Occ=Once] :: a_agsO1
                                            [LclId] =
                                                [b_sgAST $dNum_sgASW] \u []
                                                    GHC.Num.abs $dNum_sgASW b_sgAST;
                                          } in 
                                            case GHC.Classes.< $dOrd_sgASX sat_sgATb sat_sgATc of {
                                              GHC.Types.False ->
                                                  case
                                                      Data.Complex.$w$cfromInteger
                                                          $dRealFloat_sgASP
                                                          Data.Complex.$fFloatingComplex19
                                                  of
                                                  { (#,#) ww1_sgATf [Occ=Once]
                                                          ww2_sgATg [Occ=Once] ->
                                                        case
                                                            Data.Complex.$w$c+
                                                                $dRealFloat_sgASP
                                                                ww1_sgATf
                                                                ww2_sgATg
                                                                a1_sgASS
                                                                b_sgAST
                                                        of
                                                        { (#,#) ww4_sgATi [Occ=Once]
                                                                ww5_sgATj [Occ=Once] ->
                                                              case
                                                                  Data.Complex.$w$clog
                                                                      $dRealFloat_sgASP
                                                                      ww4_sgATi
                                                                      ww5_sgATj
                                                              of
                                                              { (#,#) ww7_sgATl [Occ=Once]
                                                                      ww8_sgATm [Occ=Once] ->
                                                                    Data.Complex.:+ [ww7_sgATl
                                                                                     ww8_sgATm];
                                                              };
                                                        };
                                                  };
                                              GHC.Types.True ->
                                                  case
                                                      GHC.Float.$p2RealFloat $dRealFloat_sgASP
                                                  of
                                                  $dFloating_sgATn [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_sgATz [Occ=Once] :: a_agsO1
                                                          [LclId] =
                                                              [a1_sgASS
                                                               b_sgAST
                                                               $dNum_sgASW
                                                               $dFractional_sgASY
                                                               $dFloating_sgATn] \u []
                                                                  let {
                                                                    u_sgATo :: a_agsO1
                                                                    [LclId] =
                                                                        [a1_sgASS
                                                                         b_sgAST
                                                                         $dNum_sgASW] \u []
                                                                            let {
                                                                              sat_sgATt [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [b_sgAST
                                                                                   $dNum_sgASW] \u []
                                                                                      GHC.Num.*
                                                                                          $dNum_sgASW
                                                                                          b_sgAST
                                                                                          b_sgAST; } in
                                                                            let {
                                                                              sat_sgATs [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [a1_sgASS
                                                                                   $dNum_sgASW] \u []
                                                                                      let {
                                                                                        sat_sgATr [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [a1_sgASS
                                                                                             $dNum_sgASW] \u []
                                                                                                GHC.Num.*
                                                                                                    $dNum_sgASW
                                                                                                    a1_sgASS
                                                                                                    a1_sgASS; } in
                                                                                      let {
                                                                                        sat_sgATq [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [a1_sgASS
                                                                                             $dNum_sgASW] \u []
                                                                                                let {
                                                                                                  sat_sgATp [Occ=Once]
                                                                                                    :: a_agsO1
                                                                                                  [LclId] =
                                                                                                      [$dNum_sgASW] \u []
                                                                                                          GHC.Num.fromInteger
                                                                                                              $dNum_sgASW
                                                                                                              Data.Complex.$fFloatingComplex21;
                                                                                                } in 
                                                                                                  GHC.Num.*
                                                                                                      $dNum_sgASW
                                                                                                      sat_sgATp
                                                                                                      a1_sgASS;
                                                                                      } in 
                                                                                        GHC.Num.+
                                                                                            $dNum_sgASW
                                                                                            sat_sgATq
                                                                                            sat_sgATr;
                                                                            } in 
                                                                              GHC.Num.+
                                                                                  $dNum_sgASW
                                                                                  sat_sgATs
                                                                                  sat_sgATt; } in
                                                                  let {
                                                                    sat_sgATy [Occ=Once] :: a_agsO1
                                                                    [LclId] =
                                                                        [$dNum_sgASW
                                                                         $dFloating_sgATn
                                                                         u_sgATo] \u []
                                                                            let {
                                                                              sat_sgATx [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [$dNum_sgASW
                                                                                   $dFloating_sgATn
                                                                                   u_sgATo] \u []
                                                                                      let {
                                                                                        sat_sgATw [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [$dNum_sgASW
                                                                                             u_sgATo] \u []
                                                                                                let {
                                                                                                  sat_sgATv [Occ=Once]
                                                                                                    :: a_agsO1
                                                                                                  [LclId] =
                                                                                                      [$dNum_sgASW] \u []
                                                                                                          GHC.Num.fromInteger
                                                                                                              $dNum_sgASW
                                                                                                              Data.Complex.$fFloatingComplex19;
                                                                                                } in 
                                                                                                  GHC.Num.+
                                                                                                      $dNum_sgASW
                                                                                                      u_sgATo
                                                                                                      sat_sgATv;
                                                                                      } in 
                                                                                        GHC.Float.sqrt
                                                                                            $dFloating_sgATn
                                                                                            sat_sgATw; } in
                                                                            let {
                                                                              sat_sgATu [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [$dNum_sgASW] \u []
                                                                                      GHC.Num.fromInteger
                                                                                          $dNum_sgASW
                                                                                          Data.Complex.$fFloatingComplex19;
                                                                            } in 
                                                                              GHC.Num.+
                                                                                  $dNum_sgASW
                                                                                  sat_sgATu
                                                                                  sat_sgATx;
                                                                  } in 
                                                                    GHC.Real./
                                                                        $dFractional_sgASY
                                                                        u_sgATo
                                                                        sat_sgATy;
                                                        } in 
                                                          case
                                                              GHC.Float.log1p
                                                                  $dFloating_sgATn sat_sgATz
                                                          of
                                                          dt_sgATA
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgATC [Occ=Once] :: a_agsO1
                                                                  [LclId] =
                                                                      [a1_sgASS $dNum_sgASW] \u []
                                                                          let {
                                                                            sat_sgATB [Occ=Once]
                                                                              :: a_agsO1
                                                                            [LclId] =
                                                                                [$dNum_sgASW] \u []
                                                                                    GHC.Num.fromInteger
                                                                                        $dNum_sgASW
                                                                                        Data.Complex.$fFloatingComplex19;
                                                                          } in 
                                                                            GHC.Num.+
                                                                                $dNum_sgASW
                                                                                sat_sgATB
                                                                                a1_sgASS;
                                                                } in 
                                                                  case
                                                                      GHC.Float.atan2
                                                                          $dRealFloat_sgASP
                                                                          sat_sgATC
                                                                          b_sgAST
                                                                  of
                                                                  dt1_sgATD
                                                                  { __DEFAULT ->
                                                                        Data.Complex.:+ [dt_sgATA
                                                                                         dt1_sgATD];
                                                                  };
                                                          };
                                                  };
                                            };
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1mexp1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgATE]
        case eta_sgATE of {
          Data.Complex.:+ x_sgATG [Occ=Once!] y_sgATH [Occ=Once!] ->
              case x_sgATG of {
                GHC.Types.F# x1_sgATJ [Occ=Once] ->
                    case y_sgATH of {
                      GHC.Types.F# x2_sgATL ->
                          case expFloat# [x1_sgATJ] of expx_sgATM [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosFloat# [x2_sgATL] of sat_sgATO {
                                  __DEFAULT ->
                                      case timesFloat# [expx_sgATM sat_sgATO] of sat_sgATP {
                                        __DEFAULT ->
                                            case negateFloat# [sat_sgATP] of dt_sgATN [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case sinFloat# [x2_sgATL] of sat_sgATR {
                                                    __DEFAULT ->
                                                        case
                                                            timesFloat# [expx_sgATM sat_sgATR]
                                                        of
                                                        sat_sgATS
                                                        { __DEFAULT ->
                                                              case
                                                                  negateFloat# [sat_sgATS]
                                                              of
                                                              dt1_sgATQ [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        fabsFloat# [dt_sgATN]
                                                                    of
                                                                    sat_sgAU0
                                                                    { __DEFAULT ->
                                                                          let-no-escape {
                                                                            $j_sgATT [Occ=Once*T[0],
                                                                                      Dmd=<L,1*U(U,U)>]
                                                                              :: Data.Complex.Complex
                                                                                   GHC.Types.Float
                                                                            [LclId[JoinId(0)],
                                                                             Str=m,
                                                                             Unf=OtherCon []] =
                                                                                [dt_sgATN
                                                                                 dt1_sgATQ] \r []
                                                                                    case
                                                                                        plusFloat# [1.0#
                                                                                                    dt_sgATN]
                                                                                    of
                                                                                    dt2_sgATU [Dmd=<S,U>]
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$smagnitude1
                                                                                                  dt2_sgATU
                                                                                                  dt1_sgATQ
                                                                                          of
                                                                                          ww_sgATV
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    logFloat# [ww_sgATV]
                                                                                                of
                                                                                                wild3_sgATW
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          Data.Complex.$w$sphase1
                                                                                                              dt2_sgATU
                                                                                                              dt1_sgATQ
                                                                                                      of
                                                                                                      ww1_sgATX
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgATZ [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [ww1_sgATX]; } in
                                                                                                            let {
                                                                                                              sat_sgATY [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [wild3_sgATW];
                                                                                                            } in 
                                                                                                              Data.Complex.:+ [sat_sgATY
                                                                                                                               sat_sgATZ];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                          } in 
                                                                            case
                                                                                ltFloat# [sat_sgAU0
                                                                                          0.5#]
                                                                            of
                                                                            { __DEFAULT -> $j_sgATT;
                                                                              1# ->
                                                                                  case
                                                                                      fabsFloat# [dt1_sgATQ]
                                                                                  of
                                                                                  sat_sgAU2
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            ltFloat# [sat_sgAU2
                                                                                                      0.5#]
                                                                                        of
                                                                                        { __DEFAULT ->
                                                                                              $j_sgATT;
                                                                                          1# ->
                                                                                              case
                                                                                                  timesFloat# [dt1_sgATQ
                                                                                                               dt1_sgATQ]
                                                                                              of
                                                                                              sat_sgAU8
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        timesFloat# [dt_sgATN
                                                                                                                     dt_sgATN]
                                                                                                    of
                                                                                                    sat_sgAU6
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              plusFloat# [dt_sgATN
                                                                                                                          dt_sgATN]
                                                                                                          of
                                                                                                          sat_sgAU5
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    plusFloat# [sat_sgAU5
                                                                                                                                sat_sgAU6]
                                                                                                                of
                                                                                                                sat_sgAU7
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          plusFloat# [sat_sgAU7
                                                                                                                                      sat_sgAU8]
                                                                                                                      of
                                                                                                                      u_sgAU4 [Dmd=<S,U>]
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                plusFloat# [u_sgAU4
                                                                                                                                            1.0#]
                                                                                                                            of
                                                                                                                            sat_sgAU9
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sqrtFloat# [sat_sgAU9]
                                                                                                                                  of
                                                                                                                                  sat_sgAUa
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            plusFloat# [1.0#
                                                                                                                                                        sat_sgAUa]
                                                                                                                                        of
                                                                                                                                        sat_sgAUb
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              case
                                                                                                                                                  divideFloat# [u_sgAU4
                                                                                                                                                                sat_sgAUb]
                                                                                                                                              of
                                                                                                                                              wild3_sgAUc
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    case
                                                                                                                                                        __pkg_ccall base-4.11.0.0 [wild3_sgAUc
                                                                                                                                                                                   GHC.Prim.realWorld#]
                                                                                                                                                    of
                                                                                                                                                    { (#,#) _ [Occ=Dead]
                                                                                                                                                            ds4_sgAUg [Occ=Once] ->
                                                                                                                                                          case
                                                                                                                                                              plusFloat# [1.0#
                                                                                                                                                                          dt_sgATN]
                                                                                                                                                          of
                                                                                                                                                          sat_sgAUh
                                                                                                                                                          { __DEFAULT ->
                                                                                                                                                                let {
                                                                                                                                                                  sat_sgAUi [Occ=Once]
                                                                                                                                                                    :: GHC.Types.Float
                                                                                                                                                                  [LclId] =
                                                                                                                                                                      CCCS GHC.Types.F#! [sat_sgAUh];
                                                                                                                                                                } in 
                                                                                                                                                                  case
                                                                                                                                                                      GHC.Float.$w$catan1
                                                                                                                                                                          sat_sgAUi
                                                                                                                                                                          dt1_sgATQ
                                                                                                                                                                  of
                                                                                                                                                                  ww2_sgAUj
                                                                                                                                                                  { __DEFAULT ->
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgAUl [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Float
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.F#! [ww2_sgAUj]; } in
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgAUk [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Float
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.F#! [ds4_sgAUg];
                                                                                                                                                                        } in 
                                                                                                                                                                          Data.Complex.:+ [sat_sgAUk
                                                                                                                                                                                           sat_sgAUl];
                                                                                                                                                                  };
                                                                                                                                                          };
                                                                                                                                                    };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAUm]
        case eta_sgAUm of {
          Data.Complex.:+ x_sgAUo [Occ=Once!] y_sgAUp [Occ=Once!] ->
              case x_sgAUo of {
                GHC.Types.D# x1_sgAUr [Occ=Once] ->
                    case y_sgAUp of {
                      GHC.Types.D# x2_sgAUt ->
                          case expDouble# [x1_sgAUr] of expx_sgAUu [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosDouble# [x2_sgAUt] of sat_sgAUw {
                                  __DEFAULT ->
                                      case *## [expx_sgAUu sat_sgAUw] of sat_sgAUx {
                                        __DEFAULT ->
                                            case negateDouble# [sat_sgAUx] of dt_sgAUv [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case sinDouble# [x2_sgAUt] of sat_sgAUz {
                                                    __DEFAULT ->
                                                        case
                                                            *## [expx_sgAUu sat_sgAUz]
                                                        of
                                                        sat_sgAUA
                                                        { __DEFAULT ->
                                                              case
                                                                  negateDouble# [sat_sgAUA]
                                                              of
                                                              dt1_sgAUy [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        fabsDouble# [dt_sgAUv]
                                                                    of
                                                                    sat_sgAUI
                                                                    { __DEFAULT ->
                                                                          let-no-escape {
                                                                            $j_sgAUB [Occ=Once*T[0],
                                                                                      Dmd=<L,1*U(U,U)>]
                                                                              :: Data.Complex.Complex
                                                                                   GHC.Types.Double
                                                                            [LclId[JoinId(0)],
                                                                             Str=m,
                                                                             Unf=OtherCon []] =
                                                                                [dt_sgAUv
                                                                                 dt1_sgAUy] \r []
                                                                                    case
                                                                                        +## [1.0##
                                                                                             dt_sgAUv]
                                                                                    of
                                                                                    dt2_sgAUC [Dmd=<S,U>]
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$smagnitude
                                                                                                  dt2_sgAUC
                                                                                                  dt1_sgAUy
                                                                                          of
                                                                                          ww_sgAUD
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    logDouble# [ww_sgAUD]
                                                                                                of
                                                                                                wild3_sgAUE
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          Data.Complex.$w$sphase
                                                                                                              dt2_sgAUC
                                                                                                              dt1_sgAUy
                                                                                                      of
                                                                                                      ww1_sgAUF
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgAUH [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [ww1_sgAUF]; } in
                                                                                                            let {
                                                                                                              sat_sgAUG [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [wild3_sgAUE];
                                                                                                            } in 
                                                                                                              Data.Complex.:+ [sat_sgAUG
                                                                                                                               sat_sgAUH];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                          } in 
                                                                            case
                                                                                <## [sat_sgAUI
                                                                                     0.5##]
                                                                            of
                                                                            { __DEFAULT -> $j_sgAUB;
                                                                              1# ->
                                                                                  case
                                                                                      fabsDouble# [dt1_sgAUy]
                                                                                  of
                                                                                  sat_sgAUK
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            <## [sat_sgAUK
                                                                                                 0.5##]
                                                                                        of
                                                                                        { __DEFAULT ->
                                                                                              $j_sgAUB;
                                                                                          1# ->
                                                                                              case
                                                                                                  *## [dt1_sgAUy
                                                                                                       dt1_sgAUy]
                                                                                              of
                                                                                              sat_sgAUQ
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        *## [dt_sgAUv
                                                                                                             dt_sgAUv]
                                                                                                    of
                                                                                                    sat_sgAUO
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              +## [dt_sgAUv
                                                                                                                   dt_sgAUv]
                                                                                                          of
                                                                                                          sat_sgAUN
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    +## [sat_sgAUN
                                                                                                                         sat_sgAUO]
                                                                                                                of
                                                                                                                sat_sgAUP
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          +## [sat_sgAUP
                                                                                                                               sat_sgAUQ]
                                                                                                                      of
                                                                                                                      u_sgAUM [Dmd=<S,U>]
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                +## [u_sgAUM
                                                                                                                                     1.0##]
                                                                                                                            of
                                                                                                                            sat_sgAUR
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sqrtDouble# [sat_sgAUR]
                                                                                                                                  of
                                                                                                                                  sat_sgAUS
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            +## [1.0##
                                                                                                                                                 sat_sgAUS]
                                                                                                                                        of
                                                                                                                                        sat_sgAUT
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              case
                                                                                                                                                  /## [u_sgAUM
                                                                                                                                                       sat_sgAUT]
                                                                                                                                              of
                                                                                                                                              wild3_sgAUU
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    case
                                                                                                                                                        __pkg_ccall base-4.11.0.0 [wild3_sgAUU
                                                                                                                                                                                   GHC.Prim.realWorld#]
                                                                                                                                                    of
                                                                                                                                                    { (#,#) _ [Occ=Dead]
                                                                                                                                                            ds4_sgAUY [Occ=Once] ->
                                                                                                                                                          case
                                                                                                                                                              +## [1.0##
                                                                                                                                                                   dt_sgAUv]
                                                                                                                                                          of
                                                                                                                                                          sat_sgAUZ
                                                                                                                                                          { __DEFAULT ->
                                                                                                                                                                let {
                                                                                                                                                                  sat_sgAV0 [Occ=Once]
                                                                                                                                                                    :: GHC.Types.Double
                                                                                                                                                                  [LclId] =
                                                                                                                                                                      CCCS GHC.Types.D#! [sat_sgAUZ];
                                                                                                                                                                } in 
                                                                                                                                                                  case
                                                                                                                                                                      GHC.Float.$w$catan2
                                                                                                                                                                          sat_sgAV0
                                                                                                                                                                          dt1_sgAUy
                                                                                                                                                                  of
                                                                                                                                                                  ww2_sgAV1
                                                                                                                                                                  { __DEFAULT ->
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgAV3 [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Double
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.D#! [ww2_sgAV1]; } in
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgAV2 [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Double
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.D#! [ds4_sgAUY];
                                                                                                                                                                        } in 
                                                                                                                                                                          Data.Complex.:+ [sat_sgAV2
                                                                                                                                                                                           sat_sgAV3];
                                                                                                                                                                  };
                                                                                                                                                          };
                                                                                                                                                    };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)S(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgAV4 eta_sgAV5]
        case eta_sgAV5 of {
          Data.Complex.:+ ww1_sgAV7 [Occ=Once] ww2_sgAV8 [Occ=Once] ->
              case
                  Data.Complex.$w$cexp $dRealFloat_sgAV4 ww1_sgAV7 ww2_sgAV8
              of
              { (#,#) ww4_sgAVa [Occ=Once] ww5_sgAVb [Occ=Once] ->
                    case
                        Data.Complex.$w$cnegate $dRealFloat_sgAV4 ww4_sgAVa ww5_sgAVb
                    of
                    { (#,#) ww7_sgAVd ww8_sgAVe ->
                          case
                              GHC.Float.$p1RealFloat $dRealFloat_sgAV4
                          of
                          $dRealFrac_sgAVf [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
                          { __DEFAULT ->
                                case
                                    GHC.Real.$p1RealFrac $dRealFrac_sgAVf
                                of
                                $dReal_sgAVg [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
                                { __DEFAULT ->
                                      let {
                                        $dNum_sgAVh [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
                                          :: GHC.Num.Num a_agsO1
                                        [LclId] =
                                            [$dReal_sgAVg] \u [] GHC.Real.$p1Real $dReal_sgAVg;
                                      } in 
                                        case
                                            GHC.Real.$p2Real $dReal_sgAVg
                                        of
                                        $dOrd_sgAVi [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                                        { __DEFAULT ->
                                              let {
                                                $dFractional_sgAVj [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
                                                  :: GHC.Real.Fractional a_agsO1
                                                [LclId] =
                                                    [$dRealFrac_sgAVf] \u []
                                                        GHC.Real.$p2RealFrac $dRealFrac_sgAVf; } in
                                              let {
                                                sat_sgAVl [Occ=Once] :: a_agsO1
                                                [LclId] =
                                                    [$dFractional_sgAVj] \u []
                                                        GHC.Real.fromRational
                                                            $dFractional_sgAVj
                                                            Data.Complex.$fFloatingComplex20; } in
                                              let {
                                                sat_sgAVk [Occ=Once] :: a_agsO1
                                                [LclId] =
                                                    [ww7_sgAVd $dNum_sgAVh] \u []
                                                        GHC.Num.abs $dNum_sgAVh ww7_sgAVd;
                                              } in 
                                                case
                                                    GHC.Classes.< $dOrd_sgAVi sat_sgAVk sat_sgAVl
                                                of
                                                { GHC.Types.False ->
                                                      case
                                                          Data.Complex.$w$cfromInteger
                                                              $dRealFloat_sgAV4
                                                              Data.Complex.$fFloatingComplex19
                                                      of
                                                      { (#,#) ww10_sgAVo [Occ=Once]
                                                              ww11_sgAVp [Occ=Once] ->
                                                            case
                                                                Data.Complex.$w$c+
                                                                    $dRealFloat_sgAV4
                                                                    ww10_sgAVo
                                                                    ww11_sgAVp
                                                                    ww7_sgAVd
                                                                    ww8_sgAVe
                                                            of
                                                            { (#,#) ww13_sgAVr [Occ=Once]
                                                                    ww14_sgAVs [Occ=Once] ->
                                                                  case
                                                                      Data.Complex.$w$clog
                                                                          $dRealFloat_sgAV4
                                                                          ww13_sgAVr
                                                                          ww14_sgAVs
                                                                  of
                                                                  { (#,#) ww16_sgAVu [Occ=Once]
                                                                          ww17_sgAVv [Occ=Once] ->
                                                                        Data.Complex.:+ [ww16_sgAVu
                                                                                         ww17_sgAVv];
                                                                  };
                                                            };
                                                      };
                                                  GHC.Types.True ->
                                                      let {
                                                        sat_sgAVx [Occ=Once] :: a_agsO1
                                                        [LclId] =
                                                            [$dFractional_sgAVj] \u []
                                                                GHC.Real.fromRational
                                                                    $dFractional_sgAVj
                                                                    Data.Complex.$fFloatingComplex20; } in
                                                      let {
                                                        sat_sgAVw [Occ=Once] :: a_agsO1
                                                        [LclId] =
                                                            [ww8_sgAVe $dNum_sgAVh] \u []
                                                                GHC.Num.abs $dNum_sgAVh ww8_sgAVe;
                                                      } in 
                                                        case
                                                            GHC.Classes.<
                                                                $dOrd_sgAVi sat_sgAVw sat_sgAVx
                                                        of
                                                        { GHC.Types.False ->
                                                              case
                                                                  Data.Complex.$w$cfromInteger
                                                                      $dRealFloat_sgAV4
                                                                      Data.Complex.$fFloatingComplex19
                                                              of
                                                              { (#,#) ww10_sgAVA [Occ=Once]
                                                                      ww11_sgAVB [Occ=Once] ->
                                                                    case
                                                                        Data.Complex.$w$c+
                                                                            $dRealFloat_sgAV4
                                                                            ww10_sgAVA
                                                                            ww11_sgAVB
                                                                            ww7_sgAVd
                                                                            ww8_sgAVe
                                                                    of
                                                                    { (#,#) ww13_sgAVD [Occ=Once]
                                                                            ww14_sgAVE [Occ=Once] ->
                                                                          case
                                                                              Data.Complex.$w$clog
                                                                                  $dRealFloat_sgAV4
                                                                                  ww13_sgAVD
                                                                                  ww14_sgAVE
                                                                          of
                                                                          { (#,#) ww16_sgAVG [Occ=Once]
                                                                                  ww17_sgAVH [Occ=Once] ->
                                                                                Data.Complex.:+ [ww16_sgAVG
                                                                                                 ww17_sgAVH];
                                                                          };
                                                                    };
                                                              };
                                                          GHC.Types.True ->
                                                              case
                                                                  GHC.Float.$p2RealFloat
                                                                      $dRealFloat_sgAV4
                                                              of
                                                              $dFloating_sgAVI [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                                                              { __DEFAULT ->
                                                                    let {
                                                                      sat_sgAVU [Occ=Once]
                                                                        :: a_agsO1
                                                                      [LclId] =
                                                                          [ww7_sgAVd
                                                                           ww8_sgAVe
                                                                           $dNum_sgAVh
                                                                           $dFractional_sgAVj
                                                                           $dFloating_sgAVI] \u []
                                                                              let {
                                                                                u_sgAVJ :: a_agsO1
                                                                                [LclId] =
                                                                                    [ww7_sgAVd
                                                                                     ww8_sgAVe
                                                                                     $dNum_sgAVh] \u []
                                                                                        let {
                                                                                          sat_sgAVO [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [ww8_sgAVe
                                                                                               $dNum_sgAVh] \u []
                                                                                                  GHC.Num.*
                                                                                                      $dNum_sgAVh
                                                                                                      ww8_sgAVe
                                                                                                      ww8_sgAVe; } in
                                                                                        let {
                                                                                          sat_sgAVN [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [ww7_sgAVd
                                                                                               $dNum_sgAVh] \u []
                                                                                                  let {
                                                                                                    sat_sgAVM [Occ=Once]
                                                                                                      :: a_agsO1
                                                                                                    [LclId] =
                                                                                                        [ww7_sgAVd
                                                                                                         $dNum_sgAVh] \u []
                                                                                                            GHC.Num.*
                                                                                                                $dNum_sgAVh
                                                                                                                ww7_sgAVd
                                                                                                                ww7_sgAVd; } in
                                                                                                  let {
                                                                                                    sat_sgAVL [Occ=Once]
                                                                                                      :: a_agsO1
                                                                                                    [LclId] =
                                                                                                        [ww7_sgAVd
                                                                                                         $dNum_sgAVh] \u []
                                                                                                            let {
                                                                                                              sat_sgAVK [Occ=Once]
                                                                                                                :: a_agsO1
                                                                                                              [LclId] =
                                                                                                                  [$dNum_sgAVh] \u []
                                                                                                                      GHC.Num.fromInteger
                                                                                                                          $dNum_sgAVh
                                                                                                                          Data.Complex.$fFloatingComplex21;
                                                                                                            } in 
                                                                                                              GHC.Num.*
                                                                                                                  $dNum_sgAVh
                                                                                                                  sat_sgAVK
                                                                                                                  ww7_sgAVd;
                                                                                                  } in 
                                                                                                    GHC.Num.+
                                                                                                        $dNum_sgAVh
                                                                                                        sat_sgAVL
                                                                                                        sat_sgAVM;
                                                                                        } in 
                                                                                          GHC.Num.+
                                                                                              $dNum_sgAVh
                                                                                              sat_sgAVN
                                                                                              sat_sgAVO; } in
                                                                              let {
                                                                                sat_sgAVT [Occ=Once]
                                                                                  :: a_agsO1
                                                                                [LclId] =
                                                                                    [$dNum_sgAVh
                                                                                     $dFloating_sgAVI
                                                                                     u_sgAVJ] \u []
                                                                                        let {
                                                                                          sat_sgAVS [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [$dNum_sgAVh
                                                                                               $dFloating_sgAVI
                                                                                               u_sgAVJ] \u []
                                                                                                  let {
                                                                                                    sat_sgAVR [Occ=Once]
                                                                                                      :: a_agsO1
                                                                                                    [LclId] =
                                                                                                        [$dNum_sgAVh
                                                                                                         u_sgAVJ] \u []
                                                                                                            let {
                                                                                                              sat_sgAVQ [Occ=Once]
                                                                                                                :: a_agsO1
                                                                                                              [LclId] =
                                                                                                                  [$dNum_sgAVh] \u []
                                                                                                                      GHC.Num.fromInteger
                                                                                                                          $dNum_sgAVh
                                                                                                                          Data.Complex.$fFloatingComplex19;
                                                                                                            } in 
                                                                                                              GHC.Num.+
                                                                                                                  $dNum_sgAVh
                                                                                                                  u_sgAVJ
                                                                                                                  sat_sgAVQ;
                                                                                                  } in 
                                                                                                    GHC.Float.sqrt
                                                                                                        $dFloating_sgAVI
                                                                                                        sat_sgAVR; } in
                                                                                        let {
                                                                                          sat_sgAVP [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [$dNum_sgAVh] \u []
                                                                                                  GHC.Num.fromInteger
                                                                                                      $dNum_sgAVh
                                                                                                      Data.Complex.$fFloatingComplex19;
                                                                                        } in 
                                                                                          GHC.Num.+
                                                                                              $dNum_sgAVh
                                                                                              sat_sgAVP
                                                                                              sat_sgAVS;
                                                                              } in 
                                                                                GHC.Real./
                                                                                    $dFractional_sgAVj
                                                                                    u_sgAVJ
                                                                                    sat_sgAVT;
                                                                    } in 
                                                                      case
                                                                          GHC.Float.log1p
                                                                              $dFloating_sgAVI
                                                                              sat_sgAVU
                                                                      of
                                                                      dt_sgAVV
                                                                      { __DEFAULT ->
                                                                            let {
                                                                              sat_sgAVX [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [ww7_sgAVd
                                                                                   $dNum_sgAVh] \u []
                                                                                      let {
                                                                                        sat_sgAVW [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [$dNum_sgAVh] \u []
                                                                                                GHC.Num.fromInteger
                                                                                                    $dNum_sgAVh
                                                                                                    Data.Complex.$fFloatingComplex19;
                                                                                      } in 
                                                                                        GHC.Num.+
                                                                                            $dNum_sgAVh
                                                                                            sat_sgAVW
                                                                                            ww7_sgAVd;
                                                                            } in 
                                                                              case
                                                                                  GHC.Float.atan2
                                                                                      $dRealFloat_sgAV4
                                                                                      sat_sgAVX
                                                                                      ww8_sgAVe
                                                                              of
                                                                              dt1_sgAVY
                                                                              { __DEFAULT ->
                                                                                    Data.Complex.:+ [dt_sgAVV
                                                                                                     dt1_sgAVY];
                                                                              };
                                                                      };
                                                              };
                                                        };
                                                };
                                        };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1pexp1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAVZ]
        case eta_sgAVZ of {
          Data.Complex.:+ x_sgAW1 [Occ=Once!] y_sgAW2 [Occ=Once!] ->
              case x_sgAW1 of {
                GHC.Types.F# x1_sgAW4 [Occ=Once] ->
                    case y_sgAW2 of {
                      GHC.Types.F# x2_sgAW6 ->
                          case expFloat# [x1_sgAW4] of expx_sgAW7 [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosFloat# [x2_sgAW6] of sat_sgAW9 {
                                  __DEFAULT ->
                                      case
                                          timesFloat# [expx_sgAW7 sat_sgAW9]
                                      of
                                      a_sgAW8 [Dmd=<S,U>]
                                      { __DEFAULT ->
                                            case sinFloat# [x2_sgAW6] of sat_sgAWb {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [expx_sgAW7 sat_sgAWb]
                                                  of
                                                  b_sgAWa [Dmd=<S,U>]
                                                  { __DEFAULT ->
                                                        case fabsFloat# [a_sgAW8] of sat_sgAWj {
                                                          __DEFAULT ->
                                                              let-no-escape {
                                                                $j_sgAWc [Occ=Once*T[0],
                                                                          Dmd=<L,1*U(U,U)>]
                                                                  :: Data.Complex.Complex
                                                                       GHC.Types.Float
                                                                [LclId[JoinId(0)],
                                                                 Str=m,
                                                                 Unf=OtherCon []] =
                                                                    [a_sgAW8 b_sgAWa] \r []
                                                                        case
                                                                            plusFloat# [1.0#
                                                                                        a_sgAW8]
                                                                        of
                                                                        dt_sgAWd [Dmd=<S,U>]
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  Data.Complex.$w$smagnitude1
                                                                                      dt_sgAWd
                                                                                      b_sgAWa
                                                                              of
                                                                              ww_sgAWe
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        logFloat# [ww_sgAWe]
                                                                                    of
                                                                                    wild3_sgAWf
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$sphase1
                                                                                                  dt_sgAWd
                                                                                                  b_sgAWa
                                                                                          of
                                                                                          ww1_sgAWg
                                                                                          { __DEFAULT ->
                                                                                                let {
                                                                                                  sat_sgAWi [Occ=Once]
                                                                                                    :: GHC.Types.Float
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.F#! [ww1_sgAWg]; } in
                                                                                                let {
                                                                                                  sat_sgAWh [Occ=Once]
                                                                                                    :: GHC.Types.Float
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.F#! [wild3_sgAWf];
                                                                                                } in 
                                                                                                  Data.Complex.:+ [sat_sgAWh
                                                                                                                   sat_sgAWi];
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                              } in 
                                                                case ltFloat# [sat_sgAWj 0.5#] of {
                                                                  __DEFAULT -> $j_sgAWc;
                                                                  1# ->
                                                                      case
                                                                          fabsFloat# [b_sgAWa]
                                                                      of
                                                                      sat_sgAWl
                                                                      { __DEFAULT ->
                                                                            case
                                                                                ltFloat# [sat_sgAWl
                                                                                          0.5#]
                                                                            of
                                                                            { __DEFAULT -> $j_sgAWc;
                                                                              1# ->
                                                                                  case
                                                                                      timesFloat# [b_sgAWa
                                                                                                   b_sgAWa]
                                                                                  of
                                                                                  sat_sgAWr
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            timesFloat# [a_sgAW8
                                                                                                         a_sgAW8]
                                                                                        of
                                                                                        sat_sgAWp
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  plusFloat# [a_sgAW8
                                                                                                              a_sgAW8]
                                                                                              of
                                                                                              sat_sgAWo
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        plusFloat# [sat_sgAWo
                                                                                                                    sat_sgAWp]
                                                                                                    of
                                                                                                    sat_sgAWq
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              plusFloat# [sat_sgAWq
                                                                                                                          sat_sgAWr]
                                                                                                          of
                                                                                                          u_sgAWn [Dmd=<S,U>]
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    plusFloat# [u_sgAWn
                                                                                                                                1.0#]
                                                                                                                of
                                                                                                                sat_sgAWs
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          sqrtFloat# [sat_sgAWs]
                                                                                                                      of
                                                                                                                      sat_sgAWt
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                plusFloat# [1.0#
                                                                                                                                            sat_sgAWt]
                                                                                                                            of
                                                                                                                            sat_sgAWu
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      divideFloat# [u_sgAWn
                                                                                                                                                    sat_sgAWu]
                                                                                                                                  of
                                                                                                                                  wild3_sgAWv
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            __pkg_ccall base-4.11.0.0 [wild3_sgAWv
                                                                                                                                                                       GHC.Prim.realWorld#]
                                                                                                                                        of
                                                                                                                                        { (#,#) _ [Occ=Dead]
                                                                                                                                                ds4_sgAWz [Occ=Once] ->
                                                                                                                                              case
                                                                                                                                                  plusFloat# [1.0#
                                                                                                                                                              a_sgAW8]
                                                                                                                                              of
                                                                                                                                              sat_sgAWA
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    let {
                                                                                                                                                      sat_sgAWB [Occ=Once]
                                                                                                                                                        :: GHC.Types.Float
                                                                                                                                                      [LclId] =
                                                                                                                                                          CCCS GHC.Types.F#! [sat_sgAWA];
                                                                                                                                                    } in 
                                                                                                                                                      case
                                                                                                                                                          GHC.Float.$w$catan1
                                                                                                                                                              sat_sgAWB
                                                                                                                                                              b_sgAWa
                                                                                                                                                      of
                                                                                                                                                      ww2_sgAWC
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgAWE [Occ=Once]
                                                                                                                                                                :: GHC.Types.Float
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.F#! [ww2_sgAWC]; } in
                                                                                                                                                            let {
                                                                                                                                                              sat_sgAWD [Occ=Once]
                                                                                                                                                                :: GHC.Types.Float
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.F#! [ds4_sgAWz];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgAWD
                                                                                                                                                                               sat_sgAWE];
                                                                                                                                                      };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAWF]
        case eta_sgAWF of {
          Data.Complex.:+ x_sgAWH [Occ=Once!] y_sgAWI [Occ=Once!] ->
              case x_sgAWH of {
                GHC.Types.D# x1_sgAWK [Occ=Once] ->
                    case y_sgAWI of {
                      GHC.Types.D# x2_sgAWM ->
                          case expDouble# [x1_sgAWK] of expx_sgAWN [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosDouble# [x2_sgAWM] of sat_sgAWP {
                                  __DEFAULT ->
                                      case *## [expx_sgAWN sat_sgAWP] of a_sgAWO [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinDouble# [x2_sgAWM] of sat_sgAWR {
                                              __DEFAULT ->
                                                  case
                                                      *## [expx_sgAWN sat_sgAWR]
                                                  of
                                                  b_sgAWQ [Dmd=<S,U>]
                                                  { __DEFAULT ->
                                                        case fabsDouble# [a_sgAWO] of sat_sgAWZ {
                                                          __DEFAULT ->
                                                              let-no-escape {
                                                                $j_sgAWS [Occ=Once*T[0],
                                                                          Dmd=<L,1*U(U,U)>]
                                                                  :: Data.Complex.Complex
                                                                       GHC.Types.Double
                                                                [LclId[JoinId(0)],
                                                                 Str=m,
                                                                 Unf=OtherCon []] =
                                                                    [a_sgAWO b_sgAWQ] \r []
                                                                        case
                                                                            +## [1.0## a_sgAWO]
                                                                        of
                                                                        dt_sgAWT [Dmd=<S,U>]
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  Data.Complex.$w$smagnitude
                                                                                      dt_sgAWT
                                                                                      b_sgAWQ
                                                                              of
                                                                              ww_sgAWU
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        logDouble# [ww_sgAWU]
                                                                                    of
                                                                                    wild3_sgAWV
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$sphase
                                                                                                  dt_sgAWT
                                                                                                  b_sgAWQ
                                                                                          of
                                                                                          ww1_sgAWW
                                                                                          { __DEFAULT ->
                                                                                                let {
                                                                                                  sat_sgAWY [Occ=Once]
                                                                                                    :: GHC.Types.Double
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.D#! [ww1_sgAWW]; } in
                                                                                                let {
                                                                                                  sat_sgAWX [Occ=Once]
                                                                                                    :: GHC.Types.Double
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.D#! [wild3_sgAWV];
                                                                                                } in 
                                                                                                  Data.Complex.:+ [sat_sgAWX
                                                                                                                   sat_sgAWY];
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                              } in 
                                                                case <## [sat_sgAWZ 0.5##] of {
                                                                  __DEFAULT -> $j_sgAWS;
                                                                  1# ->
                                                                      case
                                                                          fabsDouble# [b_sgAWQ]
                                                                      of
                                                                      sat_sgAX1
                                                                      { __DEFAULT ->
                                                                            case
                                                                                <## [sat_sgAX1
                                                                                     0.5##]
                                                                            of
                                                                            { __DEFAULT -> $j_sgAWS;
                                                                              1# ->
                                                                                  case
                                                                                      *## [b_sgAWQ
                                                                                           b_sgAWQ]
                                                                                  of
                                                                                  sat_sgAX7
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            *## [a_sgAWO
                                                                                                 a_sgAWO]
                                                                                        of
                                                                                        sat_sgAX5
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  +## [a_sgAWO
                                                                                                       a_sgAWO]
                                                                                              of
                                                                                              sat_sgAX4
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        +## [sat_sgAX4
                                                                                                             sat_sgAX5]
                                                                                                    of
                                                                                                    sat_sgAX6
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              +## [sat_sgAX6
                                                                                                                   sat_sgAX7]
                                                                                                          of
                                                                                                          u_sgAX3 [Dmd=<S,U>]
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    +## [u_sgAX3
                                                                                                                         1.0##]
                                                                                                                of
                                                                                                                sat_sgAX8
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          sqrtDouble# [sat_sgAX8]
                                                                                                                      of
                                                                                                                      sat_sgAX9
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                +## [1.0##
                                                                                                                                     sat_sgAX9]
                                                                                                                            of
                                                                                                                            sat_sgAXa
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      /## [u_sgAX3
                                                                                                                                           sat_sgAXa]
                                                                                                                                  of
                                                                                                                                  wild3_sgAXb
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            __pkg_ccall base-4.11.0.0 [wild3_sgAXb
                                                                                                                                                                       GHC.Prim.realWorld#]
                                                                                                                                        of
                                                                                                                                        { (#,#) _ [Occ=Dead]
                                                                                                                                                ds4_sgAXf [Occ=Once] ->
                                                                                                                                              case
                                                                                                                                                  +## [1.0##
                                                                                                                                                       a_sgAWO]
                                                                                                                                              of
                                                                                                                                              sat_sgAXg
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    let {
                                                                                                                                                      sat_sgAXh [Occ=Once]
                                                                                                                                                        :: GHC.Types.Double
                                                                                                                                                      [LclId] =
                                                                                                                                                          CCCS GHC.Types.D#! [sat_sgAXg];
                                                                                                                                                    } in 
                                                                                                                                                      case
                                                                                                                                                          GHC.Float.$w$catan2
                                                                                                                                                              sat_sgAXh
                                                                                                                                                              b_sgAWQ
                                                                                                                                                      of
                                                                                                                                                      ww2_sgAXi
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgAXk [Occ=Once]
                                                                                                                                                                :: GHC.Types.Double
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.D#! [ww2_sgAXi]; } in
                                                                                                                                                            let {
                                                                                                                                                              sat_sgAXj [Occ=Once]
                                                                                                                                                                :: GHC.Types.Double
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.D#! [ds4_sgAXf];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgAXj
                                                                                                                                                                               sat_sgAXk];
                                                                                                                                                      };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLC(C(S))LLLL)S(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgAXl eta_sgAXm]
        case eta_sgAXm of {
          Data.Complex.:+ ww1_sgAXo [Occ=Once] ww2_sgAXp [Occ=Once] ->
              case
                  Data.Complex.$w$cexp $dRealFloat_sgAXl ww1_sgAXo ww2_sgAXp
              of
              { (#,#) ww4_sgAXr ww5_sgAXs ->
                    case
                        GHC.Float.$p1RealFloat $dRealFloat_sgAXl
                    of
                    $dRealFrac_sgAXt [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
                    { __DEFAULT ->
                          case
                              GHC.Real.$p1RealFrac $dRealFrac_sgAXt
                          of
                          $dReal_sgAXu [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
                          { __DEFAULT ->
                                let {
                                  $dNum_sgAXv [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
                                    :: GHC.Num.Num a_agsO1
                                  [LclId] =
                                      [$dReal_sgAXu] \u [] GHC.Real.$p1Real $dReal_sgAXu;
                                } in 
                                  case
                                      GHC.Real.$p2Real $dReal_sgAXu
                                  of
                                  $dOrd_sgAXw [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                                  { __DEFAULT ->
                                        let {
                                          $dFractional_sgAXx [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
                                            :: GHC.Real.Fractional a_agsO1
                                          [LclId] =
                                              [$dRealFrac_sgAXt] \u []
                                                  GHC.Real.$p2RealFrac $dRealFrac_sgAXt; } in
                                        let {
                                          sat_sgAXz [Occ=Once] :: a_agsO1
                                          [LclId] =
                                              [$dFractional_sgAXx] \u []
                                                  GHC.Real.fromRational
                                                      $dFractional_sgAXx
                                                      Data.Complex.$fFloatingComplex20; } in
                                        let {
                                          sat_sgAXy [Occ=Once] :: a_agsO1
                                          [LclId] =
                                              [ww4_sgAXr $dNum_sgAXv] \u []
                                                  GHC.Num.abs $dNum_sgAXv ww4_sgAXr;
                                        } in 
                                          case GHC.Classes.< $dOrd_sgAXw sat_sgAXy sat_sgAXz of {
                                            GHC.Types.False ->
                                                case
                                                    Data.Complex.$w$cfromInteger
                                                        $dRealFloat_sgAXl
                                                        Data.Complex.$fFloatingComplex19
                                                of
                                                { (#,#) ww7_sgAXC [Occ=Once] ww8_sgAXD [Occ=Once] ->
                                                      case
                                                          Data.Complex.$w$c+
                                                              $dRealFloat_sgAXl
                                                              ww7_sgAXC
                                                              ww8_sgAXD
                                                              ww4_sgAXr
                                                              ww5_sgAXs
                                                      of
                                                      { (#,#) ww10_sgAXF [Occ=Once]
                                                              ww11_sgAXG [Occ=Once] ->
                                                            case
                                                                Data.Complex.$w$clog
                                                                    $dRealFloat_sgAXl
                                                                    ww10_sgAXF
                                                                    ww11_sgAXG
                                                            of
                                                            { (#,#) ww13_sgAXI [Occ=Once]
                                                                    ww14_sgAXJ [Occ=Once] ->
                                                                  Data.Complex.:+ [ww13_sgAXI
                                                                                   ww14_sgAXJ];
                                                            };
                                                      };
                                                };
                                            GHC.Types.True ->
                                                let {
                                                  sat_sgAXL [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [$dFractional_sgAXx] \u []
                                                          GHC.Real.fromRational
                                                              $dFractional_sgAXx
                                                              Data.Complex.$fFloatingComplex20; } in
                                                let {
                                                  sat_sgAXK [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [ww5_sgAXs $dNum_sgAXv] \u []
                                                          GHC.Num.abs $dNum_sgAXv ww5_sgAXs;
                                                } in 
                                                  case
                                                      GHC.Classes.< $dOrd_sgAXw sat_sgAXK sat_sgAXL
                                                  of
                                                  { GHC.Types.False ->
                                                        case
                                                            Data.Complex.$w$cfromInteger
                                                                $dRealFloat_sgAXl
                                                                Data.Complex.$fFloatingComplex19
                                                        of
                                                        { (#,#) ww7_sgAXO [Occ=Once]
                                                                ww8_sgAXP [Occ=Once] ->
                                                              case
                                                                  Data.Complex.$w$c+
                                                                      $dRealFloat_sgAXl
                                                                      ww7_sgAXO
                                                                      ww8_sgAXP
                                                                      ww4_sgAXr
                                                                      ww5_sgAXs
                                                              of
                                                              { (#,#) ww10_sgAXR [Occ=Once]
                                                                      ww11_sgAXS [Occ=Once] ->
                                                                    case
                                                                        Data.Complex.$w$clog
                                                                            $dRealFloat_sgAXl
                                                                            ww10_sgAXR
                                                                            ww11_sgAXS
                                                                    of
                                                                    { (#,#) ww13_sgAXU [Occ=Once]
                                                                            ww14_sgAXV [Occ=Once] ->
                                                                          Data.Complex.:+ [ww13_sgAXU
                                                                                           ww14_sgAXV];
                                                                    };
                                                              };
                                                        };
                                                    GHC.Types.True ->
                                                        case
                                                            GHC.Float.$p2RealFloat $dRealFloat_sgAXl
                                                        of
                                                        $dFloating_sgAXW [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_sgAY8 [Occ=Once] :: a_agsO1
                                                                [LclId] =
                                                                    [ww4_sgAXr
                                                                     ww5_sgAXs
                                                                     $dNum_sgAXv
                                                                     $dFractional_sgAXx
                                                                     $dFloating_sgAXW] \u []
                                                                        let {
                                                                          u_sgAXX :: a_agsO1
                                                                          [LclId] =
                                                                              [ww4_sgAXr
                                                                               ww5_sgAXs
                                                                               $dNum_sgAXv] \u []
                                                                                  let {
                                                                                    sat_sgAY2 [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [ww5_sgAXs
                                                                                         $dNum_sgAXv] \u []
                                                                                            GHC.Num.*
                                                                                                $dNum_sgAXv
                                                                                                ww5_sgAXs
                                                                                                ww5_sgAXs; } in
                                                                                  let {
                                                                                    sat_sgAY1 [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [ww4_sgAXr
                                                                                         $dNum_sgAXv] \u []
                                                                                            let {
                                                                                              sat_sgAY0 [Occ=Once]
                                                                                                :: a_agsO1
                                                                                              [LclId] =
                                                                                                  [ww4_sgAXr
                                                                                                   $dNum_sgAXv] \u []
                                                                                                      GHC.Num.*
                                                                                                          $dNum_sgAXv
                                                                                                          ww4_sgAXr
                                                                                                          ww4_sgAXr; } in
                                                                                            let {
                                                                                              sat_sgAXZ [Occ=Once]
                                                                                                :: a_agsO1
                                                                                              [LclId] =
                                                                                                  [ww4_sgAXr
                                                                                                   $dNum_sgAXv] \u []
                                                                                                      let {
                                                                                                        sat_sgAXY [Occ=Once]
                                                                                                          :: a_agsO1
                                                                                                        [LclId] =
                                                                                                            [$dNum_sgAXv] \u []
                                                                                                                GHC.Num.fromInteger
                                                                                                                    $dNum_sgAXv
                                                                                                                    Data.Complex.$fFloatingComplex21;
                                                                                                      } in 
                                                                                                        GHC.Num.*
                                                                                                            $dNum_sgAXv
                                                                                                            sat_sgAXY
                                                                                                            ww4_sgAXr;
                                                                                            } in 
                                                                                              GHC.Num.+
                                                                                                  $dNum_sgAXv
                                                                                                  sat_sgAXZ
                                                                                                  sat_sgAY0;
                                                                                  } in 
                                                                                    GHC.Num.+
                                                                                        $dNum_sgAXv
                                                                                        sat_sgAY1
                                                                                        sat_sgAY2; } in
                                                                        let {
                                                                          sat_sgAY7 [Occ=Once]
                                                                            :: a_agsO1
                                                                          [LclId] =
                                                                              [$dNum_sgAXv
                                                                               $dFloating_sgAXW
                                                                               u_sgAXX] \u []
                                                                                  let {
                                                                                    sat_sgAY6 [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [$dNum_sgAXv
                                                                                         $dFloating_sgAXW
                                                                                         u_sgAXX] \u []
                                                                                            let {
                                                                                              sat_sgAY5 [Occ=Once]
                                                                                                :: a_agsO1
                                                                                              [LclId] =
                                                                                                  [$dNum_sgAXv
                                                                                                   u_sgAXX] \u []
                                                                                                      let {
                                                                                                        sat_sgAY4 [Occ=Once]
                                                                                                          :: a_agsO1
                                                                                                        [LclId] =
                                                                                                            [$dNum_sgAXv] \u []
                                                                                                                GHC.Num.fromInteger
                                                                                                                    $dNum_sgAXv
                                                                                                                    Data.Complex.$fFloatingComplex19;
                                                                                                      } in 
                                                                                                        GHC.Num.+
                                                                                                            $dNum_sgAXv
                                                                                                            u_sgAXX
                                                                                                            sat_sgAY4;
                                                                                            } in 
                                                                                              GHC.Float.sqrt
                                                                                                  $dFloating_sgAXW
                                                                                                  sat_sgAY5; } in
                                                                                  let {
                                                                                    sat_sgAY3 [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [$dNum_sgAXv] \u []
                                                                                            GHC.Num.fromInteger
                                                                                                $dNum_sgAXv
                                                                                                Data.Complex.$fFloatingComplex19;
                                                                                  } in 
                                                                                    GHC.Num.+
                                                                                        $dNum_sgAXv
                                                                                        sat_sgAY3
                                                                                        sat_sgAY6;
                                                                        } in 
                                                                          GHC.Real./
                                                                              $dFractional_sgAXx
                                                                              u_sgAXX
                                                                              sat_sgAY7;
                                                              } in 
                                                                case
                                                                    GHC.Float.log1p
                                                                        $dFloating_sgAXW sat_sgAY8
                                                                of
                                                                dt_sgAY9
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_sgAYb [Occ=Once]
                                                                          :: a_agsO1
                                                                        [LclId] =
                                                                            [ww4_sgAXr
                                                                             $dNum_sgAXv] \u []
                                                                                let {
                                                                                  sat_sgAYa [Occ=Once]
                                                                                    :: a_agsO1
                                                                                  [LclId] =
                                                                                      [$dNum_sgAXv] \u []
                                                                                          GHC.Num.fromInteger
                                                                                              $dNum_sgAXv
                                                                                              Data.Complex.$fFloatingComplex19;
                                                                                } in 
                                                                                  GHC.Num.+
                                                                                      $dNum_sgAXv
                                                                                      sat_sgAYa
                                                                                      ww4_sgAXr;
                                                                      } in 
                                                                        case
                                                                            GHC.Float.atan2
                                                                                $dRealFloat_sgAXl
                                                                                sat_sgAYb
                                                                                ww5_sgAXs
                                                                        of
                                                                        dt1_sgAYc
                                                                        { __DEFAULT ->
                                                                              Data.Complex.:+ [dt_sgAY9
                                                                                               dt1_sgAYc];
                                                                        };
                                                                };
                                                        };
                                                  };
                                          };
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clogBase1 [InlPrag=INLINE (sat-args=2)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAYd eta1_sgAYe]
        case eta1_sgAYe of {
          Data.Complex.:+ ww1_sgAYg [Occ=Once!] ww2_sgAYh [Occ=Once!] ->
              case ww1_sgAYg of {
                GHC.Types.F# ww4_sgAYj ->
                    case ww2_sgAYh of {
                      GHC.Types.F# ww6_sgAYl ->
                          case Data.Complex.$w$smagnitude1 ww4_sgAYj ww6_sgAYl of ww7_sgAYm {
                            __DEFAULT ->
                                case logFloat# [ww7_sgAYm] of wild1_sgAYn {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$sphase1 ww4_sgAYj ww6_sgAYl
                                      of
                                      ww8_sgAYo
                                      { __DEFAULT ->
                                            case eta_sgAYd of {
                                              Data.Complex.:+ ww10_sgAYq [Occ=Once!]
                                                              ww11_sgAYr [Occ=Once!] ->
                                                  case ww10_sgAYq of {
                                                    GHC.Types.F# ww13_sgAYt ->
                                                        case ww11_sgAYr of {
                                                          GHC.Types.F# ww15_sgAYv ->
                                                              case
                                                                  Data.Complex.$w$smagnitude1
                                                                      ww13_sgAYt ww15_sgAYv
                                                              of
                                                              ww16_sgAYw
                                                              { __DEFAULT ->
                                                                    case
                                                                        logFloat# [ww16_sgAYw]
                                                                    of
                                                                    wild2_sgAYx
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$sphase1
                                                                                  ww13_sgAYt
                                                                                  ww15_sgAYv
                                                                          of
                                                                          ww17_sgAYy
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/1
                                                                                        wild1_sgAYn
                                                                                        ww8_sgAYo
                                                                                        wild2_sgAYx
                                                                                        ww17_sgAYy
                                                                                of
                                                                                { (#,#) ww19_sgAYA [Occ=Once]
                                                                                        ww20_sgAYB [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww19_sgAYA
                                                                                                       ww20_sgAYB];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clogBase [InlPrag=INLINE (sat-args=2)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAYC eta1_sgAYD]
        case eta1_sgAYD of {
          Data.Complex.:+ ww1_sgAYF [Occ=Once!] ww2_sgAYG [Occ=Once!] ->
              case ww1_sgAYF of {
                GHC.Types.D# ww4_sgAYI ->
                    case ww2_sgAYG of {
                      GHC.Types.D# ww6_sgAYK ->
                          case Data.Complex.$w$smagnitude ww4_sgAYI ww6_sgAYK of ww7_sgAYL {
                            __DEFAULT ->
                                case logDouble# [ww7_sgAYL] of wild1_sgAYM {
                                  __DEFAULT ->
                                      case Data.Complex.$w$sphase ww4_sgAYI ww6_sgAYK of ww8_sgAYN {
                                        __DEFAULT ->
                                            case eta_sgAYC of {
                                              Data.Complex.:+ ww10_sgAYP [Occ=Once!]
                                                              ww11_sgAYQ [Occ=Once!] ->
                                                  case ww10_sgAYP of {
                                                    GHC.Types.D# ww13_sgAYS ->
                                                        case ww11_sgAYQ of {
                                                          GHC.Types.D# ww15_sgAYU ->
                                                              case
                                                                  Data.Complex.$w$smagnitude
                                                                      ww13_sgAYS ww15_sgAYU
                                                              of
                                                              ww16_sgAYV
                                                              { __DEFAULT ->
                                                                    case
                                                                        logDouble# [ww16_sgAYV]
                                                                    of
                                                                    wild2_sgAYW
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$sphase
                                                                                  ww13_sgAYS
                                                                                  ww15_sgAYU
                                                                          of
                                                                          ww17_sgAYX
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/
                                                                                        wild1_sgAYM
                                                                                        ww8_sgAYN
                                                                                        wild2_sgAYW
                                                                                        ww17_sgAYX
                                                                                of
                                                                                { (#,#) ww19_sgAYZ [Occ=Once]
                                                                                        ww20_sgAZ0 [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww19_sgAYZ
                                                                                                       ww20_sgAZ0];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clogBase [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgAZ1 eta_sgAZ2 eta1_sgAZ3]
        case eta1_sgAZ3 of {
          Data.Complex.:+ ww1_sgAZ5 [Occ=Once] ww2_sgAZ6 [Occ=Once] ->
              case
                  Data.Complex.$w$clog $dRealFloat_sgAZ1 ww1_sgAZ5 ww2_sgAZ6
              of
              { (#,#) ww4_sgAZ8 [Occ=Once] ww5_sgAZ9 [Occ=Once] ->
                    case eta_sgAZ2 of {
                      Data.Complex.:+ ww7_sgAZb [Occ=Once] ww8_sgAZc [Occ=Once] ->
                          case
                              Data.Complex.$w$clog $dRealFloat_sgAZ1 ww7_sgAZb ww8_sgAZc
                          of
                          { (#,#) ww10_sgAZe [Occ=Once] ww11_sgAZf [Occ=Once] ->
                                case
                                    Data.Complex.$w$c/
                                        $dRealFloat_sgAZ1 ww4_sgAZ8 ww5_sgAZ9 ww10_sgAZe ww11_sgAZf
                                of
                                { (#,#) ww13_sgAZh [Occ=Once] ww14_sgAZi [Occ=Once] ->
                                      Data.Complex.:+ [ww13_sgAZh ww14_sgAZi];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$fFloatingComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Float.Floating (Data.Complex.Complex GHC.Types.Float)
[GblId] =
    CCS_DONT_CARE GHC.Float.C:Floating! [Data.Complex.$fFloatingComplex_$s$fFractionalComplex1
                                         Data.Complex.$fFloatingComplex_$s$cpi1
                                         Data.Complex.$fFloatingComplex_$s$cexp1
                                         Data.Complex.$fFloatingComplex_$s$clog1
                                         Data.Complex.$fFloatingComplex_$s$csqrt1
                                         Data.Complex.$fFloatingComplex_$s$c**1
                                         Data.Complex.$fFloatingComplex_$s$clogBase1
                                         Data.Complex.$fFloatingComplex_$s$csin1
                                         Data.Complex.$fFloatingComplex_$s$ccos1
                                         Data.Complex.$fFloatingComplex_$s$ctan1
                                         Data.Complex.$fFloatingComplex_$s$casin1
                                         Data.Complex.$fFloatingComplex_$s$cacos1
                                         Data.Complex.$fFloatingComplex_$s$catan1
                                         Data.Complex.$fFloatingComplex_$s$csinh1
                                         Data.Complex.$fFloatingComplex_$s$ccosh1
                                         Data.Complex.$fFloatingComplex_$s$ctanh1
                                         Data.Complex.$fFloatingComplex_$s$casinh1
                                         Data.Complex.$fFloatingComplex_$s$cacosh1
                                         Data.Complex.$fFloatingComplex_$s$catanh1
                                         Data.Complex.$fFloatingComplex_$s$clog1p1
                                         Data.Complex.$fFloatingComplex_$s$cexpm2
                                         Data.Complex.$fFloatingComplex_$s$clog1pexp1
                                         Data.Complex.$fFloatingComplex_$s$clog1mexp1];

Data.Complex.$fFloatingComplex_$s$fFloatingComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Float.Floating (Data.Complex.Complex GHC.Types.Double)
[GblId] =
    CCS_DONT_CARE GHC.Float.C:Floating! [Data.Complex.$fFloatingComplex_$s$fFractionalComplex
                                         Data.Complex.$fFloatingComplex_$s$cpi
                                         Data.Complex.$fFloatingComplex_$s$cexp
                                         Data.Complex.$fFloatingComplex_$s$clog
                                         Data.Complex.$fFloatingComplex_$s$csqrt
                                         Data.Complex.$fFloatingComplex_$s$c**
                                         Data.Complex.$fFloatingComplex_$s$clogBase
                                         Data.Complex.$fFloatingComplex_$s$csin
                                         Data.Complex.$fFloatingComplex_$s$ccos
                                         Data.Complex.$fFloatingComplex_$s$ctan
                                         Data.Complex.$fFloatingComplex_$s$casin
                                         Data.Complex.$fFloatingComplex_$s$cacos
                                         Data.Complex.$fFloatingComplex_$s$catan
                                         Data.Complex.$fFloatingComplex_$s$csinh
                                         Data.Complex.$fFloatingComplex_$s$ccosh
                                         Data.Complex.$fFloatingComplex_$s$ctanh
                                         Data.Complex.$fFloatingComplex_$s$casinh
                                         Data.Complex.$fFloatingComplex_$s$cacosh
                                         Data.Complex.$fFloatingComplex_$s$catanh
                                         Data.Complex.$fFloatingComplex_$s$clog1p
                                         Data.Complex.$fFloatingComplex_$s$cexpm1
                                         Data.Complex.$fFloatingComplex_$s$clog1pexp
                                         Data.Complex.$fFloatingComplex_$s$clog1mexp];

Data.Complex.$fFloatingComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Float.Floating (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,U,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))>] =
    [] \r [$dRealFloat_sgAZj]
        let {
          sat_sgAZG [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog1mexp
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZF [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog1pexp
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZE [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cexpm1
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZD [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog1p
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZC [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$catanh
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZB [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cacosh
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZA [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$casinh
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZz [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ctanh
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZy [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ccosh
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZx [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$csinh
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZw [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$catan
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZv [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cacos
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZu [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$casin
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZt [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ctan $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZs [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ccos $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZr [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$csin $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZq [Occ=Once]
            :: Data.Complex.Complex a_agsO1
               -> Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$clogBase
                      $dRealFloat_sgAZj eta_B2 eta_B1; } in
        let {
          sat_sgAZp [Occ=Once]
            :: Data.Complex.Complex a_agsO1
               -> Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c**
                      $dRealFloat_sgAZj eta_B2 eta_B1; } in
        let {
          sat_sgAZo [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$csqrt
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZn [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZm [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cexp $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZl [Occ=Once] :: Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \u []
                  Data.Complex.$fFloatingComplex_$cpi $dRealFloat_sgAZj; } in
        let {
          sat_sgAZk [Occ=Once]
            :: GHC.Real.Fractional (Data.Complex.Complex a_agsO1)
          [LclId] =
              [$dRealFloat_sgAZj] \u []
                  Data.Complex.$fFractionalComplex $dRealFloat_sgAZj;
        } in 
          GHC.Float.C:Floating [sat_sgAZk
                                sat_sgAZl
                                sat_sgAZm
                                sat_sgAZn
                                sat_sgAZo
                                sat_sgAZp
                                sat_sgAZq
                                sat_sgAZr
                                sat_sgAZs
                                sat_sgAZt
                                sat_sgAZu
                                sat_sgAZv
                                sat_sgAZw
                                sat_sgAZx
                                sat_sgAZy
                                sat_sgAZz
                                sat_sgAZA
                                sat_sgAZB
                                sat_sgAZC
                                sat_sgAZD
                                sat_sgAZE
                                sat_sgAZF
                                sat_sgAZG];

Data.Complex.:+ :: forall a. a -> a -> Data.Complex.Complex a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Complex.:+ [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:12:26.817428762 UTC

Data.Complex.$W:+ [InlPrag=INLINE[2]]
  :: forall a. a -> a -> Data.Complex.Complex a
[GblId[DataConWrapper],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>m,
 Unf=OtherCon []] =
    [] \r [dt_sgA6D dt_sgA6E]
        case dt_sgA6D of dt_sgA6F {
          __DEFAULT ->
              case dt_sgA6E of dt_sgA6G {
                __DEFAULT -> Data.Complex.:+ [dt_sgA6F dt_sgA6G];
              };
        };

Data.Complex.$fStorableComplex2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Complex.$fStorableComplex1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> Data.Complex.Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,U><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgA6H w1_sgA6I w2_sgA6J void_0E]
        case w2_sgA6J of {
          Data.Complex.:+ ww1_sgA6M [Occ=Once] ww2_sgA6N [Occ=Once] ->
              case
                  Foreign.Storable.poke w_sgA6H w1_sgA6I ww1_sgA6M GHC.Prim.void#
              of
              { Unit# _ [Occ=Dead] ->
                    Foreign.Storable.pokeElemOff
                        w_sgA6H
                        w1_sgA6I
                        Data.Complex.$fStorableComplex2
                        ww2_sgA6N
                        GHC.Prim.void#;
              };
        };

Data.Complex.$fStorableComplex3
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Complex.Complex a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,1*C1(C1(C1(U(U,U)))),A,A,A,1*C1(C1(U(U,U))),A)><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgA6R p_sgA6S void_0E]
        case
            Foreign.Storable.peek $dStorable_sgA6R p_sgA6S GHC.Prim.void#
        of
        { Unit# ipv1_sgA6W [Occ=Once] ->
              case
                  Foreign.Storable.peekElemOff
                      $dStorable_sgA6R
                      p_sgA6S
                      Data.Complex.$fStorableComplex2
                      GHC.Prim.void#
              of
              { Unit# ipv3_sgA6Z [Occ=Once] ->
                    let {
                      sat_sgA70 [Occ=Once] :: Data.Complex.Complex a_XgsQ1
                      [LclId] =
                          [ipv1_sgA6W ipv3_sgA6Z] \u []
                              Data.Complex.$W:+ ipv1_sgA6W ipv3_sgA6Z;
                    } in  Unit# [sat_sgA70];
              };
        };

Data.Complex.$fApplicativeComplex_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> Data.Complex.Complex a
     -> Data.Complex.Complex b
     -> Data.Complex.Complex c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgA71 w1_sgA72 w2_sgA73]
        case w1_sgA72 of {
          Data.Complex.:+ ww1_sgA75 [Occ=Once] ww2_sgA76 [Occ=Once] ->
              case w2_sgA73 of {
                Data.Complex.:+ ww4_sgA78 [Occ=Once] ww5_sgA79 [Occ=Once] ->
                    case w_sgA71 ww1_sgA75 ww4_sgA78 of dt_sgA7a {
                      __DEFAULT ->
                          case w_sgA71 ww2_sgA76 ww5_sgA79 of dt1_sgA7b {
                            __DEFAULT -> Data.Complex.:+ [dt_sgA7a dt1_sgA7b];
                          };
                    };
              };
        };

Data.Complex.$fApplicativeComplex_$c<*>
  :: forall a b.
     Data.Complex.Complex (a -> b)
     -> Data.Complex.Complex a -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)C(S)),1*U(C1(U),C1(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgA7c ds1_sgA7d]
        case ds_sgA7c of {
          Data.Complex.:+ f_sgA7f [Occ=Once!] g_sgA7g [Occ=Once!] ->
              case ds1_sgA7d of {
                Data.Complex.:+ a1_sgA7i [Occ=Once] b1_sgA7j [Occ=Once] ->
                    case f_sgA7f a1_sgA7i of dt_sgA7k {
                      __DEFAULT ->
                          case g_sgA7g b1_sgA7j of dt1_sgA7l {
                            __DEFAULT -> Data.Complex.:+ [dt_sgA7k dt1_sgA7l];
                          };
                    };
              };
        };

Data.Complex.$fApplicativeComplex_$cpure
  :: forall a. a -> Data.Complex.Complex a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>m, Unf=OtherCon []] =
    [] \r [a1_sgA7m] Data.Complex.$W:+ a1_sgA7m a1_sgA7m;

Data.Complex.$fTraversableComplex_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Complex.Complex a -> f (Data.Complex.Complex b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgA7n f1_sgA7o ds_sgA7p]
        case ds_sgA7p of {
          Data.Complex.:+ a1_sgA7r [Occ=Once] a2_sgA7s [Occ=Once] ->
              let {
                sat_sgA7u [Occ=Once] :: f_agsK7 b_agsK9
                [LclId] =
                    [f1_sgA7o a2_sgA7s] \u [] f1_sgA7o a2_sgA7s; } in
              let {
                sat_sgA7t [Occ=Once] :: f_agsK7 b_agsK9
                [LclId] =
                    [f1_sgA7o a1_sgA7r] \u [] f1_sgA7o a1_sgA7r;
              } in 
                GHC.Base.liftA2
                    $dApplicative_sgA7n Data.Complex.$W:+ sat_sgA7t sat_sgA7u;
        };

Data.Complex.$fFoldableComplex_$cnull
  :: forall a. Data.Complex.Complex a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_sgA7v]
        case ds_sgA7v of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Complex.$fFoldableComplex_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgA7z z_sgA7A ds_sgA7B]
        case ds_sgA7B of {
          Data.Complex.:+ a1_sgA7D [Occ=Once] a2_sgA7E [Occ=Once] ->
              let {
                sat_sgA7F [Occ=Once] :: b_agsHZ
                [LclId] =
                    [f_sgA7z z_sgA7A a2_sgA7E] \u [] f_sgA7z a2_sgA7E z_sgA7A;
              } in  f_sgA7z a1_sgA7D sat_sgA7F;
        };

Data.Complex.$fFoldableComplex_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Complex.Complex a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgA7G f_sgA7H ds_sgA7I]
        case ds_sgA7I of {
          Data.Complex.:+ a1_sgA7K [Occ=Once] a2_sgA7L [Occ=Once] ->
              let {
                sat_sgA7N [Occ=Once] :: m_agsHO
                [LclId] =
                    [f_sgA7H a2_sgA7L] \u [] f_sgA7H a2_sgA7L; } in
              let {
                sat_sgA7M [Occ=Once] :: m_agsHO
                [LclId] =
                    [f_sgA7H a1_sgA7K] \u [] f_sgA7H a1_sgA7K;
              } in  GHC.Base.mappend $dMonoid_sgA7G sat_sgA7M sat_sgA7N;
        };

Data.Complex.$fFoldableComplex_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Complex.Complex m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgA7O ds_sgA7P]
        case ds_sgA7P of {
          Data.Complex.:+ a1_sgA7R [Occ=Once] a2_sgA7S [Occ=Once] ->
              GHC.Base.mappend $dMonoid_sgA7O a1_sgA7R a2_sgA7S;
        };

Data.Complex.$fFoldableComplex2
  :: forall a.
     GHC.Num.Num a =>
     Data.Complex.Complex a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgA7T ds_sgA7U]
        case ds_sgA7U of {
          Data.Complex.:+ a1_sgA7W [Occ=Once] a2_sgA7X [Occ=Once] ->
              GHC.Num.+ $dNum_sgA7T a1_sgA7W a2_sgA7X;
        };

Data.Complex.$fFoldableComplex_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sgA7Y x_sgA7Z]
        case x_sgA7Z of {
          Data.Complex.:+ a1_sgA81 a2_sgA82 ->
              case GHC.Classes.<= $dOrd_sgA7Y a1_sgA81 a2_sgA82 of {
                GHC.Types.False -> a2_sgA82;
                GHC.Types.True -> a1_sgA81;
              };
        };

Data.Complex.$fFoldableComplex_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sgA84 x_sgA85]
        case x_sgA85 of {
          Data.Complex.:+ a1_sgA87 a2_sgA88 ->
              case GHC.Classes.>= $dOrd_sgA84 a1_sgA87 a2_sgA88 of {
                GHC.Types.False -> a2_sgA88;
                GHC.Types.True -> a1_sgA87;
              };
        };

Data.Complex.$fFoldableComplex_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Complex.Complex a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sgA8a eta_sgA8b]
        let {
          f_sgA8c [Dmd=<L,C(U)>] :: a_agsJ9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgA8a eta_sgA8b] \u []
                  GHC.Classes.== $dEq_sgA8a eta_sgA8b; } in
        let {
          sat_sgA8i [Occ=Once]
            :: Data.Complex.Complex a_agsJ9 -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_sgA8c] \r [ds_sgA8d]
                  case ds_sgA8d of {
                    Data.Complex.:+ a1_sgA8f [Occ=Once] a2_sgA8g [Occ=Once] ->
                        case f_sgA8c a1_sgA8f of {
                          GHC.Types.False -> f_sgA8c a2_sgA8g;
                          GHC.Types.True -> GHC.Types.True [];
                        };
                  };
        } in  sat_sgA8i;

Data.Complex.$fFoldableComplex_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgA8j xs_sgA8k]
        case xs_sgA8k of {
          Data.Complex.:+ a1_sgA8m [Occ=Once] a2_sgA8n [Occ=Once] ->
              f_sgA8j a1_sgA8m a2_sgA8n;
        };

Data.Complex.$fFoldableComplex_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgA8o z0_sgA8p xs_sgA8q]
        case xs_sgA8q of {
          Data.Complex.:+ a1_sgA8s [Occ=Once] a2_sgA8t [Occ=Once] ->
              case f_sgA8o z0_sgA8p a1_sgA8s of vx_sgA8u {
                __DEFAULT -> f_sgA8o vx_sgA8u a2_sgA8t;
              };
        };

lvl_rgA6e :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

Data.Complex.$fFoldableComplex_$clength
  :: forall a. Data.Complex.Complex a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_sgA8v]
        case xs_sgA8v of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> lvl_rgA6e;
        };

Data.Complex.$fFoldableComplex_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgA8z z_sgA8A t1_sgA8B]
        case t1_sgA8B of {
          Data.Complex.:+ a1_sgA8D [Occ=Once] a2_sgA8E [Occ=Once] ->
              let {
                sat_sgA8F [Occ=Once] :: b_agsIe
                [LclId] =
                    [f_sgA8z z_sgA8A a1_sgA8D] \u [] f_sgA8z z_sgA8A a1_sgA8D;
              } in  f_sgA8z sat_sgA8F a2_sgA8E;
        };

Data.Complex.$fFoldableComplex_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgA8G z0_sgA8H xs_sgA8I]
        case xs_sgA8I of {
          Data.Complex.:+ a1_sgA8K [Occ=Once] a2_sgA8L [Occ=Once] ->
              case f_sgA8G a2_sgA8L z0_sgA8H of vx_sgA8M {
                __DEFAULT -> f_sgA8G a1_sgA8K vx_sgA8M;
              };
        };

Data.Complex.$fFoldableComplex1
  :: forall a.
     GHC.Num.Num a =>
     Data.Complex.Complex a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgA8N ds_sgA8O]
        case ds_sgA8O of {
          Data.Complex.:+ a1_sgA8Q [Occ=Once] a2_sgA8R [Occ=Once] ->
              GHC.Num.* $dNum_sgA8N a1_sgA8Q a2_sgA8R;
        };

Data.Complex.$fFoldableComplex_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Complex.Complex a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_sgA8S]
        case eta_sgA8S of {
          Data.Complex.:+ a1_sgA8U [Occ=Once] a2_sgA8V [Occ=Once] ->
              let {
                sat_sgA8W [Occ=Once] :: [a_agsIO]
                [LclId] =
                    CCCS :! [a2_sgA8V GHC.Types.[]];
              } in  : [a1_sgA8U sat_sgA8W];
        };

Data.Complex.$fFoldableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Complex.$fFoldableComplex_$cfold
                                             Data.Complex.$fFoldableComplex_$cfoldMap
                                             Data.Complex.$fFoldableComplex_$cfoldr
                                             Data.Complex.$fFoldableComplex_$cfoldr'
                                             Data.Complex.$fFoldableComplex_$cfoldl
                                             Data.Complex.$fFoldableComplex_$cfoldl'
                                             Data.Complex.$fFoldableComplex_$cfoldr1
                                             Data.Complex.$fFoldableComplex_$cfoldr1
                                             Data.Complex.$fFoldableComplex_$ctoList
                                             Data.Complex.$fFoldableComplex_$cnull
                                             Data.Complex.$fFoldableComplex_$clength
                                             Data.Complex.$fFoldableComplex_$celem
                                             Data.Complex.$fFoldableComplex_$cmaximum
                                             Data.Complex.$fFoldableComplex_$cminimum
                                             Data.Complex.$fFoldableComplex2
                                             Data.Complex.$fFoldableComplex1];

Data.Complex.$fFunctorComplex_$c<$
  :: forall a b.
     a -> Data.Complex.Complex b -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [z_sgA8X ds_sgA8Y]
        case ds_sgA8Y of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Complex.$W:+ z_sgA8X z_sgA8X;
        };

Data.Complex.$fFunctorComplex_$cfmap
  :: forall a b.
     (a -> b) -> Data.Complex.Complex a -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sgA92 ds_sgA93]
        case ds_sgA93 of {
          Data.Complex.:+ a1_sgA95 [Occ=Once] a2_sgA96 [Occ=Once] ->
              case f_sgA92 a1_sgA95 of dt_sgA97 {
                __DEFAULT ->
                    case f_sgA92 a2_sgA96 of dt1_sgA98 {
                      __DEFAULT -> Data.Complex.:+ [dt_sgA97 dt1_sgA98];
                    };
              };
        };

Data.Complex.$fFunctorComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Complex.$fFunctorComplex_$cfmap
                                       Data.Complex.$fFunctorComplex_$c<$];

Data.Complex.$fTraversableComplex_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Complex.Complex (f a) -> f (Data.Complex.Complex a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgA99 ds_sgA9a]
        case ds_sgA9a of {
          Data.Complex.:+ a1_sgA9c [Occ=Once] a2_sgA9d [Occ=Once] ->
              GHC.Base.liftA2
                  $dApplicative_sgA99 Data.Complex.$W:+ a1_sgA9c a2_sgA9d;
        };

Data.Complex.$fTraversableComplex_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Complex.Complex a -> m (Data.Complex.Complex b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgA9e eta_sgA9f eta1_sgA9g]
        case eta1_sgA9g of {
          Data.Complex.:+ a1_sgA9i [Occ=Once] a2_sgA9j [Occ=Once] ->
              let {
                sat_sgA9m [Occ=Once] :: m_agsKy b_agsKA
                [LclId] =
                    [eta_sgA9f a2_sgA9j] \u [] eta_sgA9f a2_sgA9j; } in
              let {
                sat_sgA9l [Occ=Once] :: m_agsKy b_agsKA
                [LclId] =
                    [eta_sgA9f a1_sgA9i] \u [] eta_sgA9f a1_sgA9i;
              } in 
                case GHC.Base.$p1Monad $dMonad_sgA9e of sat_sgA9k {
                  __DEFAULT ->
                      GHC.Base.liftA2 sat_sgA9k Data.Complex.$W:+ sat_sgA9l sat_sgA9m;
                };
        };

Data.Complex.$fTraversableComplex_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Complex.Complex (m a) -> m (Data.Complex.Complex a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgA9n eta_sgA9o]
        case eta_sgA9o of {
          Data.Complex.:+ a1_sgA9q [Occ=Once] a2_sgA9r [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sgA9n of sat_sgA9s {
                __DEFAULT ->
                    GHC.Base.liftA2 sat_sgA9s Data.Complex.$W:+ a1_sgA9q a2_sgA9r;
              };
        };

Data.Complex.$fTraversableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Complex.$fFunctorComplex
                                                   Data.Complex.$fFoldableComplex
                                                   Data.Complex.$fTraversableComplex_$ctraverse
                                                   Data.Complex.$fTraversableComplex_$csequenceA
                                                   Data.Complex.$fTraversableComplex_$cmapM
                                                   Data.Complex.$fTraversableComplex_$csequence];

Data.Complex.$fApplicativeComplex_$c*>
  :: forall a b.
     Data.Complex.Complex a
     -> Data.Complex.Complex b -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [a1_sgA9t a2_sgA9u]
        case a1_sgA9t of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> a2_sgA9u;
        };

Data.Complex.$fApplicativeComplex_$c<*
  :: forall a b.
     Data.Complex.Complex a
     -> Data.Complex.Complex b -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [ds_sgA9y ds1_sgA9z]
        case ds_sgA9y of wild_sgA9A {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] ->
              case ds1_sgA9z of {
                Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> wild_sgA9A;
              };
        };

Data.Complex.$fApplicativeComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Complex.$fFunctorComplex
                                           Data.Complex.$fApplicativeComplex_$cpure
                                           Data.Complex.$fApplicativeComplex_$c<*>
                                           Data.Complex.$fApplicativeComplex_$cliftA2
                                           Data.Complex.$fApplicativeComplex_$c*>
                                           Data.Complex.$fApplicativeComplex_$c<*];

Data.Complex.$fGeneric1Complex_$cto1
  :: forall a.
     GHC.Generics.Rep1 Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgA9G]
        case ds_sgA9G of {
          GHC.Generics.:*: ds1_sgA9I [Occ=Once] ds2_sgA9J [Occ=Once] ->
              Data.Complex.$W:+ ds1_sgA9I ds2_sgA9J;
        };

Data.Complex.$fGeneric1Complex1
  :: forall a.
     Data.Complex.Complex a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             ":+"
             ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
             'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.SourceStrict
                'GHC.Generics.DecidedStrict)
             GHC.Generics.Par1
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.SourceStrict
                                 'GHC.Generics.DecidedStrict)
                              GHC.Generics.Par1)
          a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_sgA9K]
        case x_sgA9K of {
          Data.Complex.:+ g1_sgA9M [Occ=Once] g2_sgA9N [Occ=Once] ->
              GHC.Generics.:*: [g1_sgA9M g2_sgA9N];
        };

Data.Complex.$fGeneric1Complex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Complex.$fGeneric1Complex1
                                            Data.Complex.$fGeneric1Complex_$cto1];

Data.Complex.$fGenericComplex_$cto
  :: forall a x.
     GHC.Generics.Rep (Data.Complex.Complex a) x
     -> Data.Complex.Complex a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgA9O]
        case ds_sgA9O of {
          GHC.Generics.:*: ds1_sgA9Q [Occ=Once] ds2_sgA9R [Occ=Once] ->
              Data.Complex.$W:+ ds1_sgA9Q ds2_sgA9R;
        };

Data.Complex.$fGenericComplex1
  :: forall a x.
     Data.Complex.Complex a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             ":+"
             ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
             'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.SourceStrict
                'GHC.Generics.DecidedStrict)
             (GHC.Generics.K1 GHC.Generics.R a)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.SourceStrict
                                 'GHC.Generics.DecidedStrict)
                              (GHC.Generics.K1 GHC.Generics.R a))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x1_sgA9S]
        case x1_sgA9S of {
          Data.Complex.:+ g1_sgA9U [Occ=Once] g2_sgA9V [Occ=Once] ->
              GHC.Generics.:*: [g1_sgA9U g2_sgA9V];
        };

Data.Complex.$fGenericComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Complex.Complex a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Complex.$fGenericComplex1
                                           Data.Complex.$fGenericComplex_$cto];

Data.Complex.$fDataComplex_$cgunfold
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dData_sgA9W k_sgA9X z_sgA9Y ds_sgA9Z]
        let {
          sat_sgAa1 [Occ=Once]
            :: c_agsBB (a_agsBe -> Data.Complex.Complex a_agsBe)
          [LclId] =
              [$dData_sgA9W k_sgA9X z_sgA9Y] \u []
                  let {
                    sat_sgAa0 [Occ=Once]
                      :: c_agsBB (a_agsBe -> a_agsBe -> Data.Complex.Complex a_agsBe)
                    [LclId] =
                        [z_sgA9Y] \u [] z_sgA9Y Data.Complex.$W:+;
                  } in  k_sgA9X $dData_sgA9W sat_sgAa0;
        } in  k_sgA9X $dData_sgA9W sat_sgAa1;

Data.Complex.$fDataComplex_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Complex.Complex a
     -> c (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgAa2 k_sgAa3 z_sgAa4 ds_sgAa5]
        case ds_sgAa5 of {
          Data.Complex.:+ a1_sgAa7 [Occ=Once] a2_sgAa8 [Occ=Once] ->
              let {
                sat_sgAaa [Occ=Once]
                  :: c_agsBn (a_agsBe -> Data.Complex.Complex a_agsBe)
                [LclId] =
                    [$dData_sgAa2 k_sgAa3 z_sgAa4 a1_sgAa7] \u []
                        let {
                          sat_sgAa9 [Occ=Once]
                            :: c_agsBn (a_agsBe -> a_agsBe -> Data.Complex.Complex a_agsBe)
                          [LclId] =
                              [z_sgAa4] \u [] z_sgAa4 Data.Complex.$W:+;
                        } in  k_sgAa3 $dData_sgAa2 sat_sgAa9 a1_sgAa7;
              } in  k_sgAa3 $dData_sgAa2 sat_sgAaa a2_sgAa8;
        };

Data.Complex.$fReadComplex5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [7#];

Data.Complex.$fReadComplex4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":+"#;

Data.Complex.$fReadComplex3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Complex.$fReadComplex4;

Data.Complex.$fReadComplex2 :: Text.Read.Lex.Lexeme
[GblId, Str=m5, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Symbol! [Data.Complex.$fReadComplex3];

Data.Complex.$fReadComplex1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Complex.Complex a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sgAab eta_sgAac eta1_sgAad]
        let {
          ds1_sgAae [Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_agsAr
          [LclId] =
              [$dRead_sgAab] \u []
                  GHC.Read.readPrec $dRead_sgAab Data.Complex.$fReadComplex5; } in
        let {
          sat_sgAat [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Complex.Complex a_agsAr)
          [LclId] =
              [ds1_sgAae] \r [c_sgAaf eta2_sgAag]
                  case c_sgAaf of {
                    GHC.Types.I# x_sgAai [Occ=Once] ->
                        case <=# [x_sgAai 6#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sgAas [Occ=Once]
                                  :: a_agsAr -> Text.ParserCombinators.ReadP.P b1_i815E
                                [LclId] =
                                    [ds1_sgAae eta2_sgAag] \r [a1_sgAak]
                                        let {
                                          sat_sgAap [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                          [LclId] =
                                              [ds1_sgAae eta2_sgAag a1_sgAak] \r [a2_sgAal]
                                                  let {
                                                    sat_sgAao [Occ=Once]
                                                      :: a_agsAr
                                                         -> Text.ParserCombinators.ReadP.P b1_i815E
                                                    [LclId] =
                                                        [eta2_sgAag a1_sgAak] \r [a3_sgAam]
                                                            let {
                                                              sat_sgAan [Occ=Once]
                                                                :: Data.Complex.Complex a_agsAr
                                                              [LclId] =
                                                                  [a1_sgAak a3_sgAam] \u []
                                                                      Data.Complex.$W:+
                                                                          a1_sgAak a3_sgAam;
                                                            } in  eta2_sgAag sat_sgAan;
                                                  } in  ds1_sgAae sat_sgAao;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Complex.$fReadComplex2 sat_sgAap
                                          of
                                          { Unit# ww1_sgAar [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sgAar];
                                          };
                              } in  ds1_sgAae sat_sgAas;
                        };
                  };
        } in  GHC.Read.list3 sat_sgAat eta_sgAac eta1_sgAad;

Data.Complex.$fReadComplex_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Complex.Complex a)
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sgAau n_sgAav]
        let {
          sat_sgAaw [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Complex.Complex a_XgsEB)
          [LclId] =
              [$dRead_sgAau n_sgAav] \u []
                  Data.Complex.$fReadComplex1
                      $dRead_sgAau
                      n_sgAav
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgAaw;

Data.Complex.$fReadComplex_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Complex.Complex a]
[GblId, Arity=1, Str=<L,U(A,A,C(C(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sgAax]
        let {
          sat_sgAay [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Complex.Complex a_XgsEz)
          [LclId] =
              [$dRead_sgAax] \r [eta_B2 eta_B1]
                  Data.Complex.$fReadComplex1 $dRead_sgAax eta_B2 eta_B1;
        } in  GHC.Read.list sat_sgAay;

Data.Complex.$fReadComplex_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Complex.Complex a]
[GblId, Arity=1, Str=<L,U(A,A,C(C(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sgAaz]
        let {
          sat_sgAaB [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Complex.Complex a_XgsEA]
          [LclId] =
              [$dRead_sgAaz] \u []
                  let {
                    sat_sgAaA [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Complex.Complex a_XgsEA)
                    [LclId] =
                        [$dRead_sgAaz] \r [eta_B2 eta_B1]
                            Data.Complex.$fReadComplex1 $dRead_sgAaz eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sgAaA
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgAaB;

Data.Complex.$fReadComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Complex.Complex a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C(U)),A)>m] =
    [] \r [$dRead_sgAaC]
        let {
          sat_sgAaG [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Complex.Complex a_XgsEy]
          [LclId] =
              [$dRead_sgAaC] \u []
                  Data.Complex.$fReadComplex_$creadListPrec $dRead_sgAaC; } in
        let {
          sat_sgAaF [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Complex.Complex a_XgsEy)
          [LclId] =
              [$dRead_sgAaC] \r [eta_B2 eta_B1]
                  Data.Complex.$fReadComplex1 $dRead_sgAaC eta_B2 eta_B1; } in
        let {
          sat_sgAaE [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Complex.Complex a_XgsEy]
          [LclId] =
              [$dRead_sgAaC] \u []
                  Data.Complex.$fReadComplex_$creadList $dRead_sgAaC; } in
        let {
          sat_sgAaD [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Complex.Complex a_XgsEy)
          [LclId] =
              [$dRead_sgAaC] \r [eta_B1]
                  Data.Complex.$fReadComplex_$creadsPrec $dRead_sgAaC eta_B1;
        } in  GHC.Read.C:Read [sat_sgAaD sat_sgAaE sat_sgAaF sat_sgAaG];

Data.Complex.$fShowComplex2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    " :+ "#;

Data.Complex.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> a -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAaH ww_sgAaI ww1_sgAaJ ww2_sgAaK]
        let {
          f_sgAaL [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sgAaH ww1_sgAaJ] \u []
                  GHC.Show.showsPrec
                      w_sgAaH Data.Complex.$fReadComplex5 ww1_sgAaJ; } in
        let {
          g_sgAaM [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sgAaH ww2_sgAaK] \u []
                  GHC.Show.showsPrec w_sgAaH Data.Complex.$fReadComplex5 ww2_sgAaK;
        } in 
          case >=# [ww_sgAaI 7#] of {
            __DEFAULT ->
                let {
                  sat_sgAaR [Occ=OnceT[0]] :: GHC.Base.String -> GHC.Base.String
                  [LclId] =
                      [f_sgAaL g_sgAaM] \r [x_sgAaO]
                          let {
                            sat_sgAaQ [Occ=Once] :: GHC.Base.String
                            [LclId] =
                                [g_sgAaM x_sgAaO] \u []
                                    let {
                                      sat_sgAaP [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sgAaM x_sgAaO] \u [] g_sgAaM x_sgAaO;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Complex.$fShowComplex2 sat_sgAaP;
                          } in  f_sgAaL sat_sgAaQ;
                } in  sat_sgAaR;
            1# ->
                let {
                  sat_sgAaX [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sgAaL g_sgAaM] \r [x_sgAaS]
                          let {
                            sat_sgAaW [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sgAaL g_sgAaM x_sgAaS] \u []
                                    let {
                                      sat_sgAaV [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          [g_sgAaM x_sgAaS] \u []
                                              let {
                                                sat_sgAaU [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sgAaM x_sgAaS] \u []
                                                        let {
                                                          sat_sgAaT [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sgAaS];
                                                        } in  g_sgAaM sat_sgAaT;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Complex.$fShowComplex2 sat_sgAaU;
                                    } in  f_sgAaL sat_sgAaV;
                          } in  : [GHC.Show.$fShow(,)4 sat_sgAaW];
                } in  sat_sgAaX;
          };

Data.Complex.$fShowComplex_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Complex.Complex a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAaY w1_sgAaZ w2_sgAb0]
        case w1_sgAaZ of {
          GHC.Types.I# ww1_sgAb2 [Occ=Once] ->
              case w2_sgAb0 of {
                Data.Complex.:+ ww3_sgAb4 [Occ=Once] ww4_sgAb5 [Occ=Once] ->
                    Data.Complex.$w$cshowsPrec w_sgAaY ww1_sgAb2 ww3_sgAb4 ww4_sgAb5;
              };
        };

Data.Complex.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Show.Show a => a -> a -> GHC.Base.String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAb6 ww_sgAb7 ww1_sgAb8]
        let {
          sat_sgAba [Occ=Once] :: GHC.Base.String
          [LclId] =
              [w_sgAb6 ww1_sgAb8] \u []
                  let {
                    sat_sgAb9 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [w_sgAb6 ww1_sgAb8] \u []
                            GHC.Show.showsPrec
                                w_sgAb6 Data.Complex.$fReadComplex5 ww1_sgAb8 GHC.Types.[];
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Complex.$fShowComplex2 sat_sgAb9;
        } in 
          GHC.Show.showsPrec
              w_sgAb6 Data.Complex.$fReadComplex5 ww_sgAb7 sat_sgAba;

Data.Complex.$fShowComplex_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     Data.Complex.Complex a -> GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAbb w1_sgAbc]
        case w1_sgAbc of {
          Data.Complex.:+ ww1_sgAbe [Occ=Once] ww2_sgAbf [Occ=Once] ->
              Data.Complex.$w$cshow w_sgAbb ww1_sgAbe ww2_sgAbf;
        };

Data.Complex.$fShowComplex1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Complex.$fShowComplex_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Complex.Complex a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sgAbg ls_sgAbh s_sgAbi]
        let {
          sat_sgAbn [Occ=Once]
            :: Data.Complex.Complex a_agszX -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgAbg] \r [w_sgAbj]
                  case w_sgAbj of {
                    Data.Complex.:+ ww1_sgAbl [Occ=Once] ww2_sgAbm [Occ=Once] ->
                        Data.Complex.$w$cshowsPrec $dShow_sgAbg 0# ww1_sgAbl ww2_sgAbm;
                  };
        } in  GHC.Show.showList__ sat_sgAbn ls_sgAbh s_sgAbi;

Data.Complex.$fShowComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sgAbo]
        let {
          sat_sgAbr [Occ=Once]
            :: [Data.Complex.Complex a_agszX] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgAbo] \r [eta_B2 eta_B1]
                  Data.Complex.$fShowComplex_$cshowList
                      $dShow_sgAbo eta_B2 eta_B1; } in
        let {
          sat_sgAbq [Occ=Once]
            :: Data.Complex.Complex a_agszX -> GHC.Base.String
          [LclId] =
              [$dShow_sgAbo] \r [eta_B1]
                  Data.Complex.$fShowComplex_$cshow $dShow_sgAbo eta_B1; } in
        let {
          sat_sgAbp [Occ=Once]
            :: GHC.Types.Int -> Data.Complex.Complex a_agszX -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgAbo] \r [eta_B2 eta_B1]
                  Data.Complex.$fShowComplex_$cshowsPrec $dShow_sgAbo eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgAbp sat_sgAbq sat_sgAbr];

Data.Complex.$fEqComplex_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Complex.Complex a -> Data.Complex.Complex a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAbs w1_sgAbt w2_sgAbu]
        case w1_sgAbt of {
          Data.Complex.:+ ww1_sgAbw [Occ=Once] ww2_sgAbx [Occ=Once] ->
              case w2_sgAbu of {
                Data.Complex.:+ ww4_sgAbz [Occ=Once] ww5_sgAbA [Occ=Once] ->
                    case GHC.Classes.== w_sgAbs ww1_sgAbw ww4_sgAbz of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> GHC.Classes.== w_sgAbs ww2_sgAbx ww5_sgAbA;
                    };
              };
        };

Data.Complex.$fEqComplex_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Complex.Complex a -> Data.Complex.Complex a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sgAbC eta_sgAbD eta1_sgAbE]
        case eta_sgAbD of {
          Data.Complex.:+ ww1_sgAbG [Occ=Once] ww2_sgAbH [Occ=Once] ->
              case eta1_sgAbE of {
                Data.Complex.:+ ww4_sgAbJ [Occ=Once] ww5_sgAbK [Occ=Once] ->
                    case GHC.Classes.== $dEq_sgAbC ww1_sgAbG ww4_sgAbJ of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True ->
                          case GHC.Classes.== $dEq_sgAbC ww2_sgAbH ww5_sgAbK of {
                            GHC.Types.False -> GHC.Types.True [];
                            GHC.Types.True -> GHC.Types.False [];
                          };
                    };
              };
        };

Data.Complex.$fEqComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Complex.Complex a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sgAbN]
        let {
          sat_sgAbP [Occ=Once]
            :: Data.Complex.Complex a_agszG
               -> Data.Complex.Complex a_agszG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgAbN] \r [eta_B2 eta_B1]
                  Data.Complex.$fEqComplex_$c/= $dEq_sgAbN eta_B2 eta_B1; } in
        let {
          sat_sgAbO [Occ=Once]
            :: Data.Complex.Complex a_agszG
               -> Data.Complex.Complex a_agszG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgAbN] \r [eta_B2 eta_B1]
                  Data.Complex.$fEqComplex_$c== $dEq_sgAbN eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sgAbO sat_sgAbP];

Data.Complex.realPart :: forall a. Data.Complex.Complex a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_sgAbQ]
        case ds_sgAbQ of {
          Data.Complex.:+ x_sgAbS [Occ=Once] _ [Occ=Dead] -> x_sgAbS;
        };

Data.Complex.$fStorableComplex_$csizeOf
  :: forall a.
     Foreign.Storable.Storable a =>
     Data.Complex.Complex a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S(S))LLLLLLL),1*U(1*C1(U(U)),A,A,A,A,A,A,A)><L,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgAbU a1_sgAbV]
        let {
          sat_sgAbZ [Occ=Once] :: a_XgsQG
          [LclId] =
              [a1_sgAbV] \u []
                  case a1_sgAbV of {
                    Data.Complex.:+ x_sgAbX [Occ=Once] _ [Occ=Dead] -> x_sgAbX;
                  };
        } in 
          case Foreign.Storable.sizeOf $dStorable_sgAbU sat_sgAbZ of {
            GHC.Types.I# y_sgAc1 [Occ=Once] ->
                case *# [2# y_sgAc1] of sat_sgAc2 {
                  __DEFAULT -> GHC.Types.I# [sat_sgAc2];
                };
          };

Data.Complex.$fStorableComplex_$calignment
  :: forall a.
     Foreign.Storable.Storable a =>
     Data.Complex.Complex a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLLLL),1*U(A,1*C1(U(U)),A,A,A,A,A,A)><L,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgAc3 a1_sgAc4]
        let {
          sat_sgAc8 [Occ=Once] :: a_XgsQH
          [LclId] =
              [a1_sgAc4] \u []
                  case a1_sgAc4 of {
                    Data.Complex.:+ x_sgAc6 [Occ=Once] _ [Occ=Dead] -> x_sgAc6;
                  };
        } in  Foreign.Storable.alignment $dStorable_sgAc3 sat_sgAc8;

Data.Complex.$fStorableComplex5
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Complex.Complex a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgAc9 ptr_sgAca off_sgAcb void_0E]
        let {
          sat_sgAci [Occ=Once] :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQL)
          [LclId] =
              [ptr_sgAca off_sgAcb] \u []
                  case ptr_sgAca of {
                    GHC.Ptr.Ptr addr_sgAce [Occ=Once] ->
                        case off_sgAcb of {
                          GHC.Types.I# d_sgAcg [Occ=Once] ->
                              case plusAddr# [addr_sgAce d_sgAcg] of sat_sgAch {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_sgAch];
                              };
                        };
                  };
        } in 
          Data.Complex.$fStorableComplex3
              $dStorable_sgAc9 sat_sgAci GHC.Prim.void#;

lvl1_rgA6f :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "undefined"#;

lvl2_rgA6g :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl1_rgA6f;

Data.Complex.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl3_rgA6h :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Complex.$trModule4;

lvl4_rgA6i :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Foreign.Storable"#;

lvl5_rgA6j :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_rgA6i;

lvl6_rgA6k :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Foreign/Storable.hs"#;

lvl7_rgA6l :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl6_rgA6k;

lvl8_rgA6m :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [137#];

lvl9_rgA6n :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [31#];

lvl10_rgA6o :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [40#];

lvl11_rgA6p :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl3_rgA6h
                                           lvl5_rgA6j
                                           lvl7_rgA6l
                                           lvl8_rgA6m
                                           lvl9_rgA6n
                                           lvl8_rgA6m
                                           lvl10_rgA6o];

lvl12_rgA6q :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl2_rgA6g
                                                  lvl11_rgA6p
                                                  GHC.Stack.Types.EmptyCallStack];

Data.Complex.$fStorableComplex8 :: forall a. Data.Complex.Complex a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl12_rgA6q;

Data.Complex.$fStorableComplex7
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Complex.Complex a #)
[GblId,
 Arity=4,
 Str=<S(LLLLLLC(C(S(SL)))L),U(1*C1(U(U)),A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgAcj ptr_sgAck off_sgAcl void_0E]
        let {
          sat_sgAcx [Occ=Once] :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQM)
          [LclId] =
              [$dStorable_sgAcj ptr_sgAck off_sgAcl] \u []
                  case ptr_sgAck of {
                    GHC.Ptr.Ptr addr_sgAco [Occ=Once] ->
                        case off_sgAcl of {
                          GHC.Types.I# x_sgAcq [Occ=Once] ->
                              case
                                  Foreign.Storable.sizeOf
                                      $dStorable_sgAcj Data.Complex.$fStorableComplex8
                              of
                              { GHC.Types.I# y_sgAct [Occ=Once] ->
                                    case *# [2# y_sgAct] of sat_sgAcu {
                                      __DEFAULT ->
                                          case *# [x_sgAcq sat_sgAcu] of sat_sgAcv {
                                            __DEFAULT ->
                                                case plusAddr# [addr_sgAco sat_sgAcv] of sat_sgAcw {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_sgAcw];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          Data.Complex.$fStorableComplex3
              $dStorable_sgAcj sat_sgAcx GHC.Prim.void#;

Data.Complex.$fStorableComplex4
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> Data.Complex.Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgAcy ptr_sgAcz off_sgAcA eta_sgAcB void_0E]
        case eta_sgAcB of {
          Data.Complex.:+ ww1_sgAcE [Occ=Once] ww2_sgAcF [Occ=Once] ->
              let {
                w_sgAcG :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQJ)
                [LclId] =
                    [ptr_sgAcz off_sgAcA] \u []
                        case ptr_sgAcz of {
                          GHC.Ptr.Ptr addr_sgAcI [Occ=Once] ->
                              case off_sgAcA of {
                                GHC.Types.I# d_sgAcK [Occ=Once] ->
                                    case plusAddr# [addr_sgAcI d_sgAcK] of sat_sgAcL {
                                      __DEFAULT -> GHC.Ptr.Ptr [sat_sgAcL];
                                    };
                              };
                        };
              } in 
                case
                    Foreign.Storable.poke
                        $dStorable_sgAcy w_sgAcG ww1_sgAcE GHC.Prim.void#
                of
                { Unit# _ [Occ=Dead] ->
                      Foreign.Storable.pokeElemOff
                          $dStorable_sgAcy
                          w_sgAcG
                          Data.Complex.$fStorableComplex2
                          ww2_sgAcF
                          GHC.Prim.void#;
                };
        };

Data.Complex.$w$cpokeElemOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Types.Int
     -> a
     -> a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(1*C1(U(U)),A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAcP w1_sgAcQ w2_sgAcR ww_sgAcS ww1_sgAcT void_0E]
        let {
          w4_sgAcV :: GHC.Ptr.Ptr (Data.Complex.Complex a_sgxtm)
          [LclId] =
              [w_sgAcP w1_sgAcQ w2_sgAcR ww_sgAcS] \u []
                  case w1_sgAcQ of {
                    GHC.Ptr.Ptr addr_sgAcX [Occ=Once] ->
                        case w2_sgAcR of {
                          GHC.Types.I# x_sgAcZ [Occ=Once] ->
                              case Foreign.Storable.sizeOf w_sgAcP ww_sgAcS of {
                                GHC.Types.I# y_sgAd1 [Occ=Once] ->
                                    case *# [2# y_sgAd1] of sat_sgAd2 {
                                      __DEFAULT ->
                                          case *# [x_sgAcZ sat_sgAd2] of sat_sgAd3 {
                                            __DEFAULT ->
                                                case plusAddr# [addr_sgAcX sat_sgAd3] of sat_sgAd4 {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_sgAd4];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case
              Foreign.Storable.poke w_sgAcP w4_sgAcV ww_sgAcS GHC.Prim.void#
          of
          { Unit# _ [Occ=Dead] ->
                Foreign.Storable.pokeElemOff
                    w_sgAcP
                    w4_sgAcV
                    Data.Complex.$fStorableComplex2
                    ww1_sgAcT
                    GHC.Prim.void#;
          };

Data.Complex.$fStorableComplex6 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Types.Int
     -> Data.Complex.Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(C(U(U)),A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAd8 w1_sgAd9 w2_sgAda w3_sgAdb void_0E]
        case w3_sgAdb of {
          Data.Complex.:+ ww1_sgAde [Occ=Once] ww2_sgAdf [Occ=Once] ->
              Data.Complex.$w$cpokeElemOff
                  w_sgAd8 w1_sgAd9 w2_sgAda ww1_sgAde ww2_sgAdf GHC.Prim.void#;
        };

Data.Complex.$fStorableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Foreign.Storable.Storable a =>
     Foreign.Storable.Storable (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(U(U)),C(U(U)),C(C1(C1(U(U,U)))),C(C1(C1(C1(U(U,U))))),A,A,C(C1(U(U,U))),C(C1(C1(U(U,A)))))>m] =
    [] \r [$dStorable_sgAdg]
        let {
          sat_sgAdo [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> Data.Complex.Complex a_XgsQI -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B3 eta_B2 void_0E]
                  Data.Complex.$fStorableComplex1
                      $dStorable_sgAdg eta_B3 eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgAdn [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> GHC.Types.IO (Data.Complex.Complex a_XgsQI)
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B2 void_0E]
                  Data.Complex.$fStorableComplex3
                      $dStorable_sgAdg eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgAdm [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> Data.Complex.Complex a_XgsQI -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B4 eta_B3 eta_B2 void_0E]
                  Data.Complex.$fStorableComplex4
                      $dStorable_sgAdg eta_B4 eta_B3 eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgAdl [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> GHC.Types.IO (Data.Complex.Complex a_XgsQI)
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B3 eta_B2 void_0E]
                  Data.Complex.$fStorableComplex5
                      $dStorable_sgAdg eta_B3 eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgAdk [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> GHC.Types.Int -> Data.Complex.Complex a_XgsQI -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B4 eta_B3 eta_B2 void_0E]
                  Data.Complex.$fStorableComplex6
                      $dStorable_sgAdg eta_B4 eta_B3 eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgAdj [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> GHC.Types.Int -> GHC.Types.IO (Data.Complex.Complex a_XgsQI)
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B3 eta_B2 void_0E]
                  Data.Complex.$fStorableComplex7
                      $dStorable_sgAdg eta_B3 eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgAdi [Occ=Once]
            :: Data.Complex.Complex a_XgsQI -> GHC.Types.Int
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B1]
                  Data.Complex.$fStorableComplex_$calignment
                      $dStorable_sgAdg eta_B1; } in
        let {
          sat_sgAdh [Occ=Once]
            :: Data.Complex.Complex a_XgsQI -> GHC.Types.Int
          [LclId] =
              [$dStorable_sgAdg] \r [eta_B1]
                  Data.Complex.$fStorableComplex_$csizeOf $dStorable_sgAdg eta_B1;
        } in 
          Foreign.Storable.C:Storable [sat_sgAdh
                                       sat_sgAdi
                                       sat_sgAdj
                                       sat_sgAdk
                                       sat_sgAdl
                                       sat_sgAdm
                                       sat_sgAdn
                                       sat_sgAdo];

Data.Complex.imagPart :: forall a. Data.Complex.Complex a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgAdp]
        case ds_sgAdp of {
          Data.Complex.:+ _ [Occ=Dead] y_sgAds [Occ=Once] -> y_sgAds;
        };

Data.Complex.$fMonadComplex_$c>>=
  :: forall a b.
     Data.Complex.Complex a
     -> (a -> Data.Complex.Complex b) -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><C(S(SS)),C(U(U,U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAdt f_sgAdu]
        case ds_sgAdt of {
          Data.Complex.:+ a1_sgAdw [Occ=Once] b1_sgAdx [Occ=Once] ->
              case f_sgAdu a1_sgAdw of {
                Data.Complex.:+ x_sgAdz [Occ=Once] _ [Occ=Dead] ->
                    case f_sgAdu b1_sgAdx of {
                      Data.Complex.:+ _ [Occ=Dead] y_sgAdD [Occ=Once] ->
                          Data.Complex.:+ [x_sgAdz y_sgAdD];
                    };
              };
        };

Data.Complex.$fMonadComplex_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Complex.Complex a
     -> Data.Complex.Complex b -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Complex.$fApplicativeComplex_$c*> eta_B2 eta_B1;

lvl13_rgA6r :: forall a. [GHC.Types.Char] -> Data.Complex.Complex a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sgAdE] GHC.Err.errorWithoutStackTrace eta_sgAdE;

Data.Complex.$fMonadComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Complex.Complex
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Complex.$fApplicativeComplex
                                     Data.Complex.$fMonadComplex_$c>>=
                                     Data.Complex.$fMonadComplex_$c>>
                                     Data.Complex.$fApplicativeComplex_$cpure
                                     lvl13_rgA6r];

Data.Complex.$fDataComplex6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Complex"#;

Data.Complex.$fDataComplex9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Complex.$fDataComplex6;

go61_rgA6s
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgAdF _ys_sgAdG]
        case ds2_sgAdF of {
          [] -> GHC.List.badHead;
          : ipv_sgAdI [Occ=Once!] ipv1_sgAdJ [Occ=Once] ->
              case _ys_sgAdG of {
                [] -> GHC.List.badHead;
                : ipv2_sgAdL [Occ=Once] ipv3_sgAdM [Occ=Once] ->
                    case ipv_sgAdI of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgAdP [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sgAdP Data.Complex.$fReadComplex3 of {
                            GHC.Types.False -> go61_rgA6s ipv1_sgAdJ ipv3_sgAdM;
                            GHC.Types.True -> ipv2_sgAdL;
                          };
                    };
              };
        };

$c:+1_rgA6t :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$c:+2_rgA6u];
Data.Complex.$fDataComplex8 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Complex.$c:+ GHC.Types.[]];
Data.Complex.$fDataComplex7 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Complex.$fDataComplex8];
Data.Complex.$tComplex :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Complex.$fDataComplex9
                                       Data.Complex.$fDataComplex7];
Data.Complex.$c:+ [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$c:+1_rgA6t
                                     Data.Complex.$fReadComplex3
                                     GHC.Types.[]
                                     Data.Data.Infix
                                     Data.Complex.$tComplex];
$c:+2_rgA6u :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rgA6s Data.Complex.$fDataComplex8 Data.Data.mkConstr1;

Data.Complex.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$trModule4];

Data.Complex.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Complex"#;

Data.Complex.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$trModule2];

Data.Complex.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Complex.$trModule3
                                     Data.Complex.$trModule1];

$krep_rgA6v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Complex.$fDataComplex5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$fDataComplex6];

Data.Complex.$tcComplex :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1343342814679332338##
                                    7004386227939987578##
                                    Data.Complex.$trModule
                                    Data.Complex.$fDataComplex5
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep1_rgA6w :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgA6v GHC.Types.[]];

$krep2_rgA6x :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Complex.$tcComplex
                                              $krep1_rgA6w];

$krep3_rgA6y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgA6v $krep2_rgA6x];

Data.Complex.$tc':+1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgA6v $krep3_rgA6y];

Data.Complex.$tc':+3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "':+"#;

Data.Complex.$tc':+2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$tc':+3];

Data.Complex.$tc':+ :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6922641126191179007##
                                    8119904032930905711##
                                    Data.Complex.$trModule
                                    Data.Complex.$tc':+2
                                    1#
                                    Data.Complex.$tc':+1];

Data.Complex.$fDataComplex4
  :: Data.Typeable.Internal.TypeRep Data.Complex.Complex
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                1343342814679332338##
                7004386227939987578##
                Data.Complex.$trModule
                Data.Complex.$fDataComplex5
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sgAdV [Occ=Once]
                   ww9_sgAdW [Occ=Once]
                   ww10_sgAdX [Occ=Once]
                   ww11_sgAdY [Occ=Once]
                   ww12_sgAdZ [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sgAdV
                                              ww9_sgAdW
                                              ww10_sgAdX
                                              ww11_sgAdY
                                              ww12_sgAdZ];
        };

Data.Complex.$fDataComplex10
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Complex.Complex a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgAe0]
        case Data.Data.$p1Data $dData_sgAe0 of sat_sgAe1 {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Complex.$fDataComplex4 sat_sgAe1;
        };

Data.Complex.$fDataComplex_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Complex.Complex a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sgAe2 $dTypeable_sgAe3]
        let {
          lvl17_sgAe4 [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sgAe3] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sgAe3 Data.Complex.$fDataComplex4; } in
        let {
          sat_sgAe8 [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_agsBY (t_agsBX d))
               -> GHC.Base.Maybe (c_agsBY (Data.Complex.Complex a_XgsGb))
          [LclId] =
              [$dData_sgAe2 lvl17_sgAe4] \r [f_sgAe5]
                  case lvl17_sgAe4 of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sgAe7 [Occ=Once] :: c_agsBY (Data.Complex.Complex a_XgsGb)
                          [LclId] =
                              [$dData_sgAe2 f_sgAe5] \u [] f_sgAe5 $dData_sgAe2;
                        } in  GHC.Base.Just [sat_sgAe7];
                  };
        } in  sat_sgAe8;

Data.Complex.$fDataComplex1
  :: forall a. (a -> a -> Data.Complex.Complex a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Complex.$W:+ GHC.Types.False];

Data.Complex.$fDataComplex_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Complex.Complex a -> m (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgAe9 $dMonadPlus_sgAea ds_sgAeb eta_sgAec]
        let {
          lvl17_sgAed [Occ=OnceL] :: m_agsE3 (Data.Complex.Complex a_XgsGk)
          [LclId] =
              [$dMonadPlus_sgAea] \u [] GHC.Base.mzero $dMonadPlus_sgAea;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sgAea
          of
          $dMonad_sgAee [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgAeI [Occ=Once]
                    :: (Data.Complex.Complex a_XgsGk, GHC.Types.Bool)
                       -> m_agsE3 (Data.Complex.Complex a_XgsGk)
                  [LclId] =
                      [lvl17_sgAed $dMonad_sgAee] \r [ds1_sgAeD]
                          case ds1_sgAeD of {
                            (,) x'_sgAeF [Occ=Once] b_sgAeG [Occ=Once!] ->
                                case b_sgAeG of {
                                  GHC.Types.False -> lvl17_sgAed;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgAee x'_sgAeF;
                                };
                          }; } in
                let {
                  sat_sgAeC [Occ=Once]
                    :: m_agsE3 (Data.Complex.Complex a_XgsGk, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sgAe9
                       $dMonadPlus_sgAea
                       ds_sgAeb
                       eta_sgAec
                       $dMonad_sgAee] \u []
                          case eta_sgAec of {
                            Data.Complex.:+ a1_sgAeg [Occ=Once] a2_sgAeh [Occ=Once] ->
                                let {
                                  k_sgAei [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_agsE3 (d -> b)
                                       -> d -> m_agsE3 (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sgAea
                                                ds_sgAeb
                                                $dMonad_sgAee] \r [$dData1_sgAej ds1_sgAek y_sgAel]
                                          let {
                                            lvl18_sgAem [Occ=OnceL] :: m_agsE3 d_ae2Ws
                                            [LclId] =
                                                [ds_sgAeb $dData1_sgAej y_sgAel] \u []
                                                    ds_sgAeb $dData1_sgAej y_sgAel; } in
                                          let {
                                            sat_sgAez [Occ=Once]
                                              :: (d_ae2Ws -> b_ae2Wt, GHC.Types.Bool)
                                                 -> m_agsE3 (b_ae2Wt, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sgAea
                                                 $dMonad_sgAee
                                                 y_sgAel
                                                 lvl18_sgAem] \r [ds2_sgAen]
                                                    case ds2_sgAen of {
                                                      (,) h_sgAep b1_sgAeq [Occ=Once] ->
                                                          let {
                                                            sat_sgAey [Occ=Once]
                                                              :: m_agsE3 (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgAee
                                                                 y_sgAel
                                                                 h_sgAep
                                                                 b1_sgAeq] \u []
                                                                    let {
                                                                      sat_sgAew [Occ=Once]
                                                                        :: b_ae2Wt
                                                                      [LclId] =
                                                                          [y_sgAel h_sgAep] \u []
                                                                              h_sgAep y_sgAel; } in
                                                                    let {
                                                                      sat_sgAex [Occ=Once]
                                                                        :: (b_ae2Wt, GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sgAew
                                                                                     b1_sgAeq];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sgAee
                                                                          sat_sgAex; } in
                                                          let {
                                                            sat_sgAev [Occ=Once]
                                                              :: m_agsE3 (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgAee
                                                                 lvl18_sgAem
                                                                 h_sgAep] \u []
                                                                    let {
                                                                      sat_sgAeu [Occ=Once]
                                                                        :: d_ae2Ws
                                                                           -> m_agsE3 (b_ae2Wt,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sgAee
                                                                           h_sgAep] \r [y'_sgAer]
                                                                              let {
                                                                                sat_sgAes [Occ=Once]
                                                                                  :: b_ae2Wt
                                                                                [LclId] =
                                                                                    [h_sgAep
                                                                                     y'_sgAer] \u []
                                                                                        h_sgAep
                                                                                            y'_sgAer; } in
                                                                              let {
                                                                                sat_sgAet [Occ=Once]
                                                                                  :: (b_ae2Wt,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sgAes
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sgAee
                                                                                    sat_sgAet;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sgAee
                                                                          lvl18_sgAem
                                                                          sat_sgAeu;
                                                          } in 
                                                            GHC.Base.mplus
                                                                $dMonadPlus_sgAea
                                                                sat_sgAev
                                                                sat_sgAey;
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sgAee ds1_sgAek sat_sgAez; } in
                                let {
                                  sat_sgAeB [Occ=Once]
                                    :: Data.Data.Mp
                                         m_agsE3 (a_XgsGk -> Data.Complex.Complex a_XgsGk)
                                  [LclId] =
                                      [$dData_sgAe9 $dMonad_sgAee a1_sgAeg k_sgAei] \u []
                                          let {
                                            sat_sgAeA [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_agsE3
                                                   (a_XgsGk
                                                    -> a_XgsGk -> Data.Complex.Complex a_XgsGk)
                                            [LclId] =
                                                [$dMonad_sgAee] \u []
                                                    GHC.Base.return
                                                        $dMonad_sgAee Data.Complex.$fDataComplex1;
                                          } in  k_sgAei $dData_sgAe9 sat_sgAeA a1_sgAeg;
                                } in  k_sgAei $dData_sgAe9 sat_sgAeB a2_sgAeh;
                          };
                } in  GHC.Base.>>= $dMonad_sgAee sat_sgAeC sat_sgAeI;
          };

Data.Complex.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> a -> a -> m (Data.Complex.Complex a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAeJ w1_sgAeK w2_sgAeL ww_sgAeM ww1_sgAeN]
        let {
          k_sgAeO [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
            :: forall d b.
               Data.Data.Data d =>
               m_sgxtX (d -> b) -> d -> m_sgxtX b
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w1_sgAeK w2_sgAeL] \r [$dData1_sgAeP c_sgAeQ x_sgAeR]
                  let {
                    lvl17_sgAeS [Occ=OnceL] :: m_sgxtX d_ae2Vh
                    [LclId] =
                        [w2_sgAeL $dData1_sgAeP x_sgAeR] \u []
                            w2_sgAeL $dData1_sgAeP x_sgAeR; } in
                  let {
                    sat_sgAeX [Occ=Once] :: (d_ae2Vh -> b_ae2Vi) -> m_sgxtX b_ae2Vi
                    [LclId] =
                        [w1_sgAeK lvl17_sgAeS] \r [c'_sgAeT]
                            let {
                              sat_sgAeW [Occ=Once] :: d_ae2Vh -> m_sgxtX b_ae2Vi
                              [LclId] =
                                  [w1_sgAeK c'_sgAeT] \r [x'_sgAeU]
                                      let {
                                        sat_sgAeV [Occ=Once] :: b_ae2Vi
                                        [LclId] =
                                            [c'_sgAeT x'_sgAeU] \u [] c'_sgAeT x'_sgAeU;
                                      } in  GHC.Base.return w1_sgAeK sat_sgAeV;
                            } in  GHC.Base.>>= w1_sgAeK lvl17_sgAeS sat_sgAeW;
                  } in  GHC.Base.>>= w1_sgAeK c_sgAeQ sat_sgAeX; } in
        let {
          sat_sgAeZ [Occ=Once]
            :: m_sgxtX (a_sgxtV -> Data.Complex.Complex a_sgxtV)
          [LclId] =
              [w_sgAeJ w1_sgAeK ww_sgAeM k_sgAeO] \u []
                  let {
                    sat_sgAeY [Occ=Once]
                      :: m_sgxtX (a_sgxtV -> a_sgxtV -> Data.Complex.Complex a_sgxtV)
                    [LclId] =
                        [w1_sgAeK] \u [] GHC.Base.return w1_sgAeK Data.Complex.$W:+;
                  } in  k_sgAeO w_sgAeJ sat_sgAeY ww_sgAeM;
        } in  k_sgAeO w_sgAeJ sat_sgAeZ ww1_sgAeN;

Data.Complex.$fDataComplex_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Complex.Complex a -> m (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAf0 w1_sgAf1 w2_sgAf2 w3_sgAf3]
        case w3_sgAf3 of {
          Data.Complex.:+ ww1_sgAf5 [Occ=Once] ww2_sgAf6 [Occ=Once] ->
              Data.Complex.$w$cgmapM
                  w_sgAf0 w1_sgAf1 w2_sgAf2 ww1_sgAf5 ww2_sgAf6;
        };

Data.Complex.$fDataComplex_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Complex.Complex a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgAf7 ds_sgAf8 ds1_sgAf9 x_sgAfa]
        case x_sgAfa of {
          Data.Complex.:+ a1_sgAfc [Occ=Once] a2_sgAfd [Occ=Once] ->
              case ds_sgAf8 of {
                GHC.Types.I# x1_sgAff [Occ=Once!] ->
                    case x1_sgAff of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sgAf9 $dData_sgAf7 a1_sgAfc;
                      1# -> ds1_sgAf9 $dData_sgAf7 a2_sgAfd;
                    };
              };
        };

Data.Complex.$fDataComplex_$cgmapQr [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Complex.Complex a
     -> r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAfh w1_sgAfi w2_sgAfj w3_sgAfk w4_sgAfl]
        case w4_sgAfl of {
          Data.Complex.:+ ww1_sgAfn [Occ=Once] ww2_sgAfo [Occ=Once] ->
              let {
                sat_sgAfr [Occ=Once] :: r_sgxu9
                [LclId] =
                    [w_sgAfh w1_sgAfi w2_sgAfj w3_sgAfk ww2_sgAfo] \u []
                        let {
                          sat_sgAfq [Occ=Once] :: r'_sgxua
                          [LclId] =
                              [w_sgAfh w3_sgAfk ww2_sgAfo] \u [] w3_sgAfk w_sgAfh ww2_sgAfo;
                        } in  w1_sgAfi sat_sgAfq w2_sgAfj; } in
              let {
                sat_sgAfp [Occ=Once] :: r'_sgxua
                [LclId] =
                    [w_sgAfh w3_sgAfk ww1_sgAfn] \u [] w3_sgAfk w_sgAfh ww1_sgAfn;
              } in  w1_sgAfi sat_sgAfp sat_sgAfr;
        };

Data.Complex.$fDataComplex_$cgmapQ
  :: forall a.
     Data.Data.Data a =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Complex.Complex a -> [u]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,C(C1(U))><S(SS),1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [$dData_sgAfs ds_sgAft x0_sgAfu]
        case x0_sgAfu of {
          Data.Complex.:+ a1_sgAfw [Occ=Once] a2_sgAfx [Occ=Once] ->
              let {
                sat_sgAfz [Occ=Once] :: u_agsDl
                [LclId] =
                    [$dData_sgAfs ds_sgAft a2_sgAfx] \u []
                        ds_sgAft $dData_sgAfs a2_sgAfx; } in
              let {
                sat_sgAfA [Occ=Once] :: [u_agsDl]
                [LclId] =
                    CCCS :! [sat_sgAfz GHC.Types.[]]; } in
              let {
                sat_sgAfy [Occ=Once] :: u_agsDl
                [LclId] =
                    [$dData_sgAfs ds_sgAft a1_sgAfw] \u []
                        ds_sgAft $dData_sgAfs a1_sgAfw;
              } in  : [sat_sgAfy sat_sgAfA];
        };

Data.Complex.$fDataComplex2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Complex.Complex a
     -> Data.Functor.Const.Const r (Data.Complex.Complex a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAfB w1_sgAfC w2_sgAfD w3_sgAfE w4_sgAfF]
        case w4_sgAfF of {
          Data.Complex.:+ ww1_sgAfH [Occ=Once] ww2_sgAfI [Occ=Once] ->
              let {
                sat_sgAfL [Occ=Once] :: r'_XgxE2
                [LclId] =
                    [w_sgAfB w3_sgAfE ww2_sgAfI] \u [] w3_sgAfE w_sgAfB ww2_sgAfI; } in
              let {
                sat_sgAfK [Occ=Once] :: r_XgxE0
                [LclId] =
                    [w_sgAfB w1_sgAfC w2_sgAfD w3_sgAfE ww1_sgAfH] \u []
                        let {
                          sat_sgAfJ [Occ=Once] :: r'_XgxE2
                          [LclId] =
                              [w_sgAfB w3_sgAfE ww1_sgAfH] \u [] w3_sgAfE w_sgAfB ww1_sgAfH;
                        } in  w1_sgAfC w2_sgAfD sat_sgAfJ;
              } in  w1_sgAfC sat_sgAfK sat_sgAfL;
        };

Data.Complex.$fDataComplex3
  :: forall a.
     Data.Data.Data a =>
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Complex.Complex a
     -> Data.Functor.Identity.Identity (Data.Complex.Complex a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dData_sgAfM ds_sgAfN x0_sgAfO]
        case x0_sgAfO of {
          Data.Complex.:+ a1_sgAfQ [Occ=Once] a2_sgAfR [Occ=Once] ->
              case ds_sgAfN $dData_sgAfM a1_sgAfQ of dt_sgAfS {
                __DEFAULT ->
                    case ds_sgAfN $dData_sgAfM a2_sgAfR of dt1_sgAfT {
                      __DEFAULT -> Data.Complex.:+ [dt_sgAfS dt1_sgAfT];
                    };
              };
        };

Data.Complex.$fDataComplex_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Complex.Complex a -> m (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgAfU $dMonadPlus_sgAfV ds_sgAfW eta_sgAfX]
        let {
          lvl17_sgAfY [Occ=OnceL] :: m_agsEj (Data.Complex.Complex a_XgsGd)
          [LclId] =
              [$dMonadPlus_sgAfV] \u [] GHC.Base.mzero $dMonadPlus_sgAfV;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sgAfV
          of
          $dMonad_sgAfZ [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgAgw [Occ=Once]
                    :: (Data.Complex.Complex a_XgsGd, GHC.Types.Bool)
                       -> m_agsEj (Data.Complex.Complex a_XgsGd)
                  [LclId] =
                      [lvl17_sgAfY $dMonad_sgAfZ] \r [ds1_sgAgr]
                          case ds1_sgAgr of {
                            (,) x'_sgAgt [Occ=Once] b_sgAgu [Occ=Once!] ->
                                case b_sgAgu of {
                                  GHC.Types.False -> lvl17_sgAfY;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgAfZ x'_sgAgt;
                                };
                          }; } in
                let {
                  sat_sgAgq [Occ=Once]
                    :: m_agsEj (Data.Complex.Complex a_XgsGd, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sgAfU
                       $dMonadPlus_sgAfV
                       ds_sgAfW
                       eta_sgAfX
                       $dMonad_sgAfZ] \u []
                          case eta_sgAfX of {
                            Data.Complex.:+ a1_sgAg1 [Occ=Once] a2_sgAg2 [Occ=Once] ->
                                let {
                                  k_sgAg3 [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_agsEj (d -> b)
                                       -> d -> m_agsEj (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sgAfV
                                                ds_sgAfW
                                                $dMonad_sgAfZ] \r [$dData1_sgAg4 ds1_sgAg5 y_sgAg6]
                                          let {
                                            lvl18_sgAg7 [Occ=OnceL] :: m_agsEj d_ae2Ya
                                            [LclId] =
                                                [ds_sgAfW $dData1_sgAg4 y_sgAg6] \u []
                                                    ds_sgAfW $dData1_sgAg4 y_sgAg6; } in
                                          let {
                                            sat_sgAgn [Occ=Once]
                                              :: (d_ae2Ya -> b_ae2Yb, GHC.Types.Bool)
                                                 -> m_agsEj (b_ae2Yb, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sgAfV
                                                 $dMonad_sgAfZ
                                                 y_sgAg6
                                                 lvl18_sgAg7] \r [ds2_sgAg8]
                                                    case ds2_sgAg8 of {
                                                      (,) h_sgAga b1_sgAgb [Occ=Once!] ->
                                                          case b1_sgAgb of {
                                                            GHC.Types.False ->
                                                                let {
                                                                  sat_sgAgk [Occ=Once]
                                                                    :: m_agsEj (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sgAfZ
                                                                       y_sgAg6
                                                                       h_sgAga] \u []
                                                                          let {
                                                                            sat_sgAgi [Occ=Once]
                                                                              :: b_ae2Yb
                                                                            [LclId] =
                                                                                [y_sgAg6
                                                                                 h_sgAga] \u []
                                                                                    h_sgAga
                                                                                        y_sgAg6; } in
                                                                          let {
                                                                            sat_sgAgj [Occ=Once]
                                                                              :: (b_ae2Yb,
                                                                                  GHC.Types.Bool)
                                                                            [LclId] =
                                                                                CCCS (,)! [sat_sgAgi
                                                                                           GHC.Types.False];
                                                                          } in 
                                                                            GHC.Base.return
                                                                                $dMonad_sgAfZ
                                                                                sat_sgAgj; } in
                                                                let {
                                                                  sat_sgAgh [Occ=Once]
                                                                    :: m_agsEj (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sgAfZ
                                                                       lvl18_sgAg7
                                                                       h_sgAga] \u []
                                                                          let {
                                                                            sat_sgAgg [Occ=Once]
                                                                              :: d_ae2Ya
                                                                                 -> m_agsEj (b_ae2Yb,
                                                                                             GHC.Types.Bool)
                                                                            [LclId] =
                                                                                [$dMonad_sgAfZ
                                                                                 h_sgAga] \r [y'_sgAgd]
                                                                                    let {
                                                                                      sat_sgAge [Occ=Once]
                                                                                        :: b_ae2Yb
                                                                                      [LclId] =
                                                                                          [h_sgAga
                                                                                           y'_sgAgd] \u []
                                                                                              h_sgAga
                                                                                                  y'_sgAgd; } in
                                                                                    let {
                                                                                      sat_sgAgf [Occ=Once]
                                                                                        :: (b_ae2Yb,
                                                                                            GHC.Types.Bool)
                                                                                      [LclId] =
                                                                                          CCCS (,)! [sat_sgAge
                                                                                                     GHC.Types.True];
                                                                                    } in 
                                                                                      GHC.Base.return
                                                                                          $dMonad_sgAfZ
                                                                                          sat_sgAgf;
                                                                          } in 
                                                                            GHC.Base.>>=
                                                                                $dMonad_sgAfZ
                                                                                lvl18_sgAg7
                                                                                sat_sgAgg;
                                                                } in 
                                                                  GHC.Base.mplus
                                                                      $dMonadPlus_sgAfV
                                                                      sat_sgAgh
                                                                      sat_sgAgk;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_sgAgl [Occ=Once] :: b_ae2Yb
                                                                  [LclId] =
                                                                      [y_sgAg6 h_sgAga] \u []
                                                                          h_sgAga y_sgAg6; } in
                                                                let {
                                                                  sat_sgAgm [Occ=Once]
                                                                    :: (b_ae2Yb, GHC.Types.Bool)
                                                                  [LclId] =
                                                                      CCCS (,)! [sat_sgAgl
                                                                                 GHC.Types.True];
                                                                } in 
                                                                  GHC.Base.return
                                                                      $dMonad_sgAfZ sat_sgAgm;
                                                          };
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sgAfZ ds1_sgAg5 sat_sgAgn; } in
                                let {
                                  sat_sgAgp [Occ=Once]
                                    :: Data.Data.Mp
                                         m_agsEj (a_XgsGd -> Data.Complex.Complex a_XgsGd)
                                  [LclId] =
                                      [$dData_sgAfU $dMonad_sgAfZ a1_sgAg1 k_sgAg3] \u []
                                          let {
                                            sat_sgAgo [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_agsEj
                                                   (a_XgsGd
                                                    -> a_XgsGd -> Data.Complex.Complex a_XgsGd)
                                            [LclId] =
                                                [$dMonad_sgAfZ] \u []
                                                    GHC.Base.return
                                                        $dMonad_sgAfZ Data.Complex.$fDataComplex1;
                                          } in  k_sgAg3 $dData_sgAfU sat_sgAgo a1_sgAg1;
                                } in  k_sgAg3 $dData_sgAfU sat_sgAgp a2_sgAg2;
                          };
                } in  GHC.Base.>>= $dMonad_sgAfZ sat_sgAgq sat_sgAgw;
          };

lvl14_rgA6z :: forall a. Data.Complex.Complex a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_sgAgx]
        case ds_sgAgx of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> Data.Complex.$c:+;
        };

lvl15_rgA6A
  :: forall a. Data.Complex.Complex a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgAgB] Data.Complex.$tComplex;

lvl16_rgA6B
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Complex.Complex a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgAgC ds_sgAgD] GHC.Base.Nothing [];

Data.Complex.$fDataComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sgAgE]
        let {
          sat_sgAgQ [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Complex.Complex a_XgsGc -> m (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgAgE] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapMo
                      $dData_sgAgE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgP [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Complex.Complex a_XgsGc -> m (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgAgE] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapMp
                      $dData_sgAgE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgO [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Complex.Complex a_XgsGc -> m (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgAgE] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapM
                      $dData_sgAgE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgN [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Complex.Complex a_XgsGc
               -> u
          [LclId] =
              [$dData_sgAgE] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapQi
                      $dData_sgAgE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgM [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Complex.Complex a_XgsGc -> [u]
          [LclId] =
              [$dData_sgAgE] \r [eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapQ $dData_sgAgE eta_B2 eta_B1; } in
        let {
          sat_sgAgL [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Complex.Complex a_XgsGc
               -> r
          [LclId] =
              [$dData_sgAgE] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapQr
                      $dData_sgAgE eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgK [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Complex.Complex a_XgsGc
               -> r
          [LclId] =
              [$dData_sgAgE] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex2
                      $dData_sgAgE eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgJ [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Complex.Complex a_XgsGc -> Data.Complex.Complex a_XgsGc
          [LclId] =
              [$dData_sgAgE] \r [eta_B2 eta_B1]
                  Data.Complex.$fDataComplex3 $dData_sgAgE eta_B2 eta_B1; } in
        let {
          sat_sgAgI [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Complex.Complex a_XgsGc))
          [LclId] =
              [$dData_sgAgE] \r [eta_B1]
                  Data.Complex.$fDataComplex_$cdataCast1 $dData_sgAgE eta_B1; } in
        let {
          sat_sgAgH [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgAgE] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgunfold
                      $dData_sgAgE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgG [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Complex.Complex a_XgsGc
               -> c (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgAgE] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgfoldl
                      $dData_sgAgE eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgAgF [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgAgE] \u [] Data.Complex.$fDataComplex10 $dData_sgAgE;
        } in 
          Data.Data.C:Data [sat_sgAgF
                            sat_sgAgG
                            sat_sgAgH
                            lvl14_rgA6z
                            lvl15_rgA6A
                            sat_sgAgI
                            lvl16_rgA6B
                            sat_sgAgJ
                            sat_sgAgK
                            sat_sgAgL
                            sat_sgAgM
                            sat_sgAgN
                            sat_sgAgO
                            sat_sgAgP
                            sat_sgAgQ];

Data.Complex.$fFloatingComplex9 :: GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.F#! [0.0#];

Data.Complex.$fFloatingComplex_$s$cpi1
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [GHC.Float.$fFloatingFloat_$cpi
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$fFloatingComplex_$s$cexp1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAgR]
        case ds_sgAgR of {
          Data.Complex.:+ x_sgAgT [Occ=Once!] y_sgAgU [Occ=Once!] ->
              case x_sgAgT of {
                GHC.Types.F# x1_sgAgW [Occ=Once] ->
                    case y_sgAgU of {
                      GHC.Types.F# x2_sgAgY ->
                          case expFloat# [x1_sgAgW] of expx_sgAgZ {
                            __DEFAULT ->
                                case sinFloat# [x2_sgAgY] of sat_sgAh3 {
                                  __DEFAULT ->
                                      case timesFloat# [expx_sgAgZ sat_sgAh3] of sat_sgAh4 {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAh5 [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgAh4];
                                            } in 
                                              case cosFloat# [x2_sgAgY] of sat_sgAh0 {
                                                __DEFAULT ->
                                                    case
                                                        timesFloat# [expx_sgAgZ sat_sgAh0]
                                                    of
                                                    sat_sgAh1
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_sgAh2 [Occ=Once] :: GHC.Types.Float
                                                            [LclId] =
                                                                CCCS GHC.Types.F#! [sat_sgAh1];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgAh2 sat_sgAh5];
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$csin1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAh6]
        case ds_sgAh6 of {
          Data.Complex.:+ x_sgAh8 [Occ=Once!] y_sgAh9 [Occ=Once!] ->
              case y_sgAh9 of {
                GHC.Types.F# x1_sgAhb ->
                    case x_sgAh8 of {
                      GHC.Types.F# x2_sgAhd ->
                          case sinhFloat# [x1_sgAhb] of sat_sgAhj {
                            __DEFAULT ->
                                case cosFloat# [x2_sgAhd] of sat_sgAhi {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgAhi sat_sgAhj] of sat_sgAhk {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAhl [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgAhk];
                                            } in 
                                              case coshFloat# [x1_sgAhb] of sat_sgAhf {
                                                __DEFAULT ->
                                                    case sinFloat# [x2_sgAhd] of sat_sgAhe {
                                                      __DEFAULT ->
                                                          case
                                                              timesFloat# [sat_sgAhe sat_sgAhf]
                                                          of
                                                          sat_sgAhg
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgAhh [Occ=Once]
                                                                    :: GHC.Types.Float
                                                                  [LclId] =
                                                                      CCCS GHC.Types.F#! [sat_sgAhg];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgAhh
                                                                                   sat_sgAhl];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ccos1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAhm]
        case ds_sgAhm of {
          Data.Complex.:+ x_sgAho [Occ=Once!] y_sgAhp [Occ=Once!] ->
              case y_sgAhp of {
                GHC.Types.F# x1_sgAhr ->
                    case x_sgAho of {
                      GHC.Types.F# x2_sgAht ->
                          case sinhFloat# [x1_sgAhr] of sat_sgAhz {
                            __DEFAULT ->
                                case sinFloat# [x2_sgAht] of sat_sgAhy {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgAhy sat_sgAhz] of sat_sgAhA {
                                        __DEFAULT ->
                                            case negateFloat# [sat_sgAhA] of sat_sgAhB {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAhC [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [sat_sgAhB];
                                                  } in 
                                                    case coshFloat# [x1_sgAhr] of sat_sgAhv {
                                                      __DEFAULT ->
                                                          case cosFloat# [x2_sgAht] of sat_sgAhu {
                                                            __DEFAULT ->
                                                                case
                                                                    timesFloat# [sat_sgAhu
                                                                                 sat_sgAhv]
                                                                of
                                                                sat_sgAhw
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_sgAhx [Occ=Once]
                                                                          :: GHC.Types.Float
                                                                        [LclId] =
                                                                            CCCS GHC.Types.F#! [sat_sgAhw];
                                                                      } in 
                                                                        Data.Complex.:+ [sat_sgAhx
                                                                                         sat_sgAhC];
                                                                };
                                                          };
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$csinh1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAhD]
        case ds_sgAhD of {
          Data.Complex.:+ x_sgAhF [Occ=Once!] y_sgAhG [Occ=Once!] ->
              case x_sgAhF of {
                GHC.Types.F# x1_sgAhI ->
                    case y_sgAhG of {
                      GHC.Types.F# x2_sgAhK ->
                          case coshFloat# [x1_sgAhI] of sat_sgAhQ {
                            __DEFAULT ->
                                case sinFloat# [x2_sgAhK] of sat_sgAhP {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgAhP sat_sgAhQ] of sat_sgAhR {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAhS [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgAhR];
                                            } in 
                                              case sinhFloat# [x1_sgAhI] of sat_sgAhM {
                                                __DEFAULT ->
                                                    case cosFloat# [x2_sgAhK] of sat_sgAhL {
                                                      __DEFAULT ->
                                                          case
                                                              timesFloat# [sat_sgAhL sat_sgAhM]
                                                          of
                                                          sat_sgAhN
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgAhO [Occ=Once]
                                                                    :: GHC.Types.Float
                                                                  [LclId] =
                                                                      CCCS GHC.Types.F#! [sat_sgAhN];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgAhO
                                                                                   sat_sgAhS];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ccosh1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAhT]
        case ds_sgAhT of {
          Data.Complex.:+ x_sgAhV [Occ=Once!] y_sgAhW [Occ=Once!] ->
              case x_sgAhV of {
                GHC.Types.F# x1_sgAhY ->
                    case y_sgAhW of {
                      GHC.Types.F# x2_sgAi0 ->
                          case sinhFloat# [x1_sgAhY] of sat_sgAi6 {
                            __DEFAULT ->
                                case sinFloat# [x2_sgAi0] of sat_sgAi5 {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgAi5 sat_sgAi6] of sat_sgAi7 {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAi8 [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgAi7];
                                            } in 
                                              case coshFloat# [x1_sgAhY] of sat_sgAi2 {
                                                __DEFAULT ->
                                                    case cosFloat# [x2_sgAi0] of sat_sgAi1 {
                                                      __DEFAULT ->
                                                          case
                                                              timesFloat# [sat_sgAi1 sat_sgAi2]
                                                          of
                                                          sat_sgAi3
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgAi4 [Occ=Once]
                                                                    :: GHC.Types.Float
                                                                  [LclId] =
                                                                      CCCS GHC.Types.F#! [sat_sgAi3];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgAi4
                                                                                   sat_sgAi8];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$s$c/1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAi9 ww1_sgAia ww2_sgAib ww3_sgAic]
        case GHC.Float.$w$cexponent1 ww2_sgAib of ww4_sgAid {
          __DEFAULT ->
              case GHC.Float.$w$cexponent1 ww3_sgAic of ww5_sgAie {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgAif [Occ=Once*!T[1], Dmd=<C(S),1*C1(U(U,U))>]
                        :: GHC.Prim.Int# -> (# GHC.Types.Float, GHC.Types.Float #)
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgAi9 ww1_sgAia ww2_sgAib ww3_sgAic] \r [ww6_sgAig]
                              case GHC.Float.$w$cscaleFloat1 ww6_sgAig ww2_sgAib of ww7_sgAih {
                                __DEFAULT ->
                                    case
                                        GHC.Float.$w$cscaleFloat1 ww6_sgAig ww3_sgAic
                                    of
                                    ww8_sgAii
                                    { __DEFAULT ->
                                          case timesFloat# [ww3_sgAic ww8_sgAii] of sat_sgAil {
                                            __DEFAULT ->
                                                case
                                                    timesFloat# [ww2_sgAib ww7_sgAih]
                                                of
                                                sat_sgAik
                                                { __DEFAULT ->
                                                      case
                                                          plusFloat# [sat_sgAik sat_sgAil]
                                                      of
                                                      y_sgAij [Dmd=<S,U>]
                                                      { __DEFAULT ->
                                                            case
                                                                timesFloat# [ww1_sgAia ww8_sgAii]
                                                            of
                                                            sat_sgAin
                                                            { __DEFAULT ->
                                                                  case
                                                                      timesFloat# [ww_sgAi9
                                                                                   ww7_sgAih]
                                                                  of
                                                                  sat_sgAim
                                                                  { __DEFAULT ->
                                                                        case
                                                                            plusFloat# [sat_sgAim
                                                                                        sat_sgAin]
                                                                        of
                                                                        sat_sgAio
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  divideFloat# [sat_sgAio
                                                                                                y_sgAij]
                                                                              of
                                                                              wild2_sgAip
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        timesFloat# [ww_sgAi9
                                                                                                     ww8_sgAii]
                                                                                    of
                                                                                    sat_sgAir
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              timesFloat# [ww1_sgAia
                                                                                                           ww7_sgAih]
                                                                                          of
                                                                                          sat_sgAiq
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    minusFloat# [sat_sgAiq
                                                                                                                 sat_sgAir]
                                                                                                of
                                                                                                sat_sgAis
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          divideFloat# [sat_sgAis
                                                                                                                        y_sgAij]
                                                                                                      of
                                                                                                      wild1_sgAit
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgAiv [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [wild1_sgAit]; } in
                                                                                                            let {
                                                                                                              sat_sgAiu [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [wild2_sgAip];
                                                                                                            } in 
                                                                                                              (#,#) [sat_sgAiu
                                                                                                                     sat_sgAiv];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww4_sgAid ww5_sgAie] of {
                        __DEFAULT ->
                            case negateInt# [ww4_sgAid] of sat_sgAix {
                              __DEFAULT -> $j_sgAif sat_sgAix;
                            };
                        1# ->
                            case negateInt# [ww5_sgAie] of sat_sgAiy {
                              __DEFAULT -> $j_sgAif sat_sgAiy;
                            };
                      };
              };
        };

Data.Complex.$fFloatingComplex_$s$c/1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAiz w1_sgAiA]
        case w_sgAiz of {
          Data.Complex.:+ ww1_sgAiC [Occ=Once!] ww2_sgAiD [Occ=Once!] ->
              case ww1_sgAiC of {
                GHC.Types.F# ww4_sgAiF [Occ=Once] ->
                    case ww2_sgAiD of {
                      GHC.Types.F# ww6_sgAiH [Occ=Once] ->
                          case w1_sgAiA of {
                            Data.Complex.:+ ww8_sgAiJ [Occ=Once!] ww9_sgAiK [Occ=Once!] ->
                                case ww8_sgAiJ of {
                                  GHC.Types.F# ww11_sgAiM [Occ=Once] ->
                                      case ww9_sgAiK of {
                                        GHC.Types.F# ww13_sgAiO [Occ=Once] ->
                                            case
                                                Data.Complex.$w$s$c/1
                                                    ww4_sgAiF ww6_sgAiH ww11_sgAiM ww13_sgAiO
                                            of
                                            { (#,#) ww15_sgAiQ [Occ=Once] ww16_sgAiR [Occ=Once] ->
                                                  Data.Complex.:+ [ww15_sgAiQ ww16_sgAiR];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromRational1
  :: GHC.Real.Rational -> Data.Complex.Complex GHC.Types.Float
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [a_sgAiS]
        case a_sgAiS of {
          GHC.Real.:% n_sgAiU [Occ=Once] d_sgAiV [Occ=Once] ->
              case GHC.Float.rationalToFloat n_sgAiU d_sgAiV of dt_sgAiW {
                GHC.Types.F# _ [Occ=Dead] ->
                    Data.Complex.:+ [dt_sgAiW Data.Complex.$fFloatingComplex9];
              };
        };

Data.Complex.$fFloatingComplex_$s$c+1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAiY w1_sgAiZ]
        case w_sgAiY of {
          Data.Complex.:+ ww1_sgAj1 [Occ=Once!] ww2_sgAj2 [Occ=Once!] ->
              case ww1_sgAj1 of {
                GHC.Types.F# ww4_sgAj4 [Occ=Once] ->
                    case ww2_sgAj2 of {
                      GHC.Types.F# ww6_sgAj6 [Occ=Once] ->
                          case w1_sgAiZ of {
                            Data.Complex.:+ ww8_sgAj8 [Occ=Once!] ww9_sgAj9 [Occ=Once!] ->
                                case ww8_sgAj8 of {
                                  GHC.Types.F# ww11_sgAjb [Occ=Once] ->
                                      case ww9_sgAj9 of {
                                        GHC.Types.F# ww13_sgAjd [Occ=Once] ->
                                            case plusFloat# [ww6_sgAj6 ww13_sgAjd] of sat_sgAjg {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAjh [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [sat_sgAjg];
                                                  } in 
                                                    case
                                                        plusFloat# [ww4_sgAj4 ww11_sgAjb]
                                                    of
                                                    sat_sgAje
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_sgAjf [Occ=Once] :: GHC.Types.Float
                                                            [LclId] =
                                                                CCCS GHC.Types.F#! [sat_sgAje];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgAjf sat_sgAjh];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c-1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAji w1_sgAjj]
        case w_sgAji of {
          Data.Complex.:+ ww1_sgAjl [Occ=Once!] ww2_sgAjm [Occ=Once!] ->
              case ww1_sgAjl of {
                GHC.Types.F# ww4_sgAjo [Occ=Once] ->
                    case ww2_sgAjm of {
                      GHC.Types.F# ww6_sgAjq [Occ=Once] ->
                          case w1_sgAjj of {
                            Data.Complex.:+ ww8_sgAjs [Occ=Once!] ww9_sgAjt [Occ=Once!] ->
                                case ww8_sgAjs of {
                                  GHC.Types.F# ww11_sgAjv [Occ=Once] ->
                                      case ww9_sgAjt of {
                                        GHC.Types.F# ww13_sgAjx [Occ=Once] ->
                                            case minusFloat# [ww6_sgAjq ww13_sgAjx] of sat_sgAjA {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAjB [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [sat_sgAjA];
                                                  } in 
                                                    case
                                                        minusFloat# [ww4_sgAjo ww11_sgAjv]
                                                    of
                                                    sat_sgAjy
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_sgAjz [Occ=Once] :: GHC.Types.Float
                                                            [LclId] =
                                                                CCCS GHC.Types.F#! [sat_sgAjy];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgAjz sat_sgAjB];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c*1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAjC w1_sgAjD]
        case w_sgAjC of {
          Data.Complex.:+ ww1_sgAjF [Occ=Once!] ww2_sgAjG [Occ=Once!] ->
              case ww1_sgAjF of {
                GHC.Types.F# ww4_sgAjI ->
                    case ww2_sgAjG of {
                      GHC.Types.F# ww6_sgAjK ->
                          case w1_sgAjD of {
                            Data.Complex.:+ ww8_sgAjM [Occ=Once!] ww9_sgAjN [Occ=Once!] ->
                                case ww8_sgAjM of {
                                  GHC.Types.F# ww11_sgAjP ->
                                      case ww9_sgAjN of {
                                        GHC.Types.F# ww13_sgAjR ->
                                            case timesFloat# [ww6_sgAjK ww11_sgAjP] of sat_sgAjX {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [ww4_sgAjI ww13_sgAjR]
                                                  of
                                                  sat_sgAjW
                                                  { __DEFAULT ->
                                                        case
                                                            plusFloat# [sat_sgAjW sat_sgAjX]
                                                        of
                                                        sat_sgAjY
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_sgAjZ [Occ=Once]
                                                                  :: GHC.Types.Float
                                                                [LclId] =
                                                                    CCCS GHC.Types.F#! [sat_sgAjY];
                                                              } in 
                                                                case
                                                                    timesFloat# [ww6_sgAjK
                                                                                 ww13_sgAjR]
                                                                of
                                                                sat_sgAjT
                                                                { __DEFAULT ->
                                                                      case
                                                                          timesFloat# [ww4_sgAjI
                                                                                       ww11_sgAjP]
                                                                      of
                                                                      sat_sgAjS
                                                                      { __DEFAULT ->
                                                                            case
                                                                                minusFloat# [sat_sgAjS
                                                                                             sat_sgAjT]
                                                                            of
                                                                            sat_sgAjU
                                                                            { __DEFAULT ->
                                                                                  let {
                                                                                    sat_sgAjV [Occ=Once]
                                                                                      :: GHC.Types.Float
                                                                                    [LclId] =
                                                                                        CCCS GHC.Types.F#! [sat_sgAjU];
                                                                                  } in 
                                                                                    Data.Complex.:+ [sat_sgAjV
                                                                                                     sat_sgAjZ];
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cnegate1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAk0]
        case ds_sgAk0 of {
          Data.Complex.:+ x_sgAk2 [Occ=Once!] y_sgAk3 [Occ=Once!] ->
              case x_sgAk2 of {
                GHC.Types.F# x1_sgAk5 [Occ=Once] ->
                    case y_sgAk3 of {
                      GHC.Types.F# x2_sgAk7 [Occ=Once] ->
                          case negateFloat# [x2_sgAk7] of sat_sgAka {
                            __DEFAULT ->
                                let {
                                  sat_sgAkb [Occ=Once] :: GHC.Types.Float
                                  [LclId] =
                                      CCCS GHC.Types.F#! [sat_sgAka];
                                } in 
                                  case negateFloat# [x1_sgAk5] of sat_sgAk8 {
                                    __DEFAULT ->
                                        let {
                                          sat_sgAk9 [Occ=Once] :: GHC.Types.Float
                                          [LclId] =
                                              CCCS GHC.Types.F#! [sat_sgAk8];
                                        } in  Data.Complex.:+ [sat_sgAk9 sat_sgAkb];
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromInteger1
  :: GHC.Integer.Type.Integer -> Data.Complex.Complex GHC.Types.Float
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [n_sgAkc]
        case GHC.Integer.Type.floatFromInteger n_sgAkc of wild_sgAkd {
          __DEFAULT ->
              let {
                sat_sgAke [Occ=Once] :: GHC.Types.Float
                [LclId] =
                    CCCS GHC.Types.F#! [wild_sgAkd];
              } in  Data.Complex.:+ [sat_sgAke Data.Complex.$fFloatingComplex9];
        };

Data.Complex.conjugate_$sconjugate
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAkf]
        case ds_sgAkf of {
          Data.Complex.:+ x_sgAkh [Occ=Once] y_sgAki [Occ=Once!] ->
              case y_sgAki of {
                GHC.Types.D# x1_sgAkk [Occ=Once] ->
                    case negateDouble# [x1_sgAkk] of sat_sgAkl {
                      __DEFAULT ->
                          let {
                            sat_sgAkm [Occ=Once] :: GHC.Types.Double
                            [LclId] =
                                CCCS GHC.Types.D#! [sat_sgAkl];
                          } in  Data.Complex.:+ [x_sgAkh sat_sgAkm];
                    };
              };
        };

Data.Complex.conjugate
  :: forall a.
     GHC.Num.Num a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LLL),1*U(A,A,A,1*C1(U),A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dNum_sgAkn ds_sgAko]
        case ds_sgAko of {
          Data.Complex.:+ x_sgAkq [Occ=Once] y_sgAkr [Occ=Once] ->
              case GHC.Num.negate $dNum_sgAkn y_sgAkr of dt_sgAks {
                __DEFAULT -> Data.Complex.:+ [x_sgAkq dt_sgAks];
              };
        };

Data.Complex.cis_$scis
  :: GHC.Types.Double -> Data.Complex.Complex GHC.Types.Double
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [theta_sgAkt]
        case theta_sgAkt of {
          GHC.Types.D# x_sgAkv ->
              case sinDouble# [x_sgAkv] of sat_sgAky {
                __DEFAULT ->
                    let {
                      sat_sgAkz [Occ=Once] :: GHC.Types.Double
                      [LclId] =
                          CCCS GHC.Types.D#! [sat_sgAky];
                    } in 
                      case cosDouble# [x_sgAkv] of sat_sgAkw {
                        __DEFAULT ->
                            let {
                              sat_sgAkx [Occ=Once] :: GHC.Types.Double
                              [LclId] =
                                  CCCS GHC.Types.D#! [sat_sgAkw];
                            } in  Data.Complex.:+ [sat_sgAkx sat_sgAkz];
                      };
              };
        };

Data.Complex.cis
  :: forall a. GHC.Float.Floating a => a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)C(S)LLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgAkA theta_sgAkB]
        case GHC.Float.cos $dFloating_sgAkA theta_sgAkB of dt_sgAkC {
          __DEFAULT ->
              case GHC.Float.sin $dFloating_sgAkA theta_sgAkB of dt1_sgAkD {
                __DEFAULT -> Data.Complex.:+ [dt_sgAkC dt1_sgAkD];
              };
        };

Data.Complex.mkPolar_$smkPolar
  :: GHC.Types.Double
     -> GHC.Types.Double -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [r_sgAkE theta_sgAkF]
        case r_sgAkE of {
          GHC.Types.D# x_sgAkH ->
              case theta_sgAkF of {
                GHC.Types.D# x1_sgAkJ ->
                    case sinDouble# [x1_sgAkJ] of sat_sgAkN {
                      __DEFAULT ->
                          case *## [x_sgAkH sat_sgAkN] of sat_sgAkO {
                            __DEFAULT ->
                                let {
                                  sat_sgAkP [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [sat_sgAkO];
                                } in 
                                  case cosDouble# [x1_sgAkJ] of sat_sgAkK {
                                    __DEFAULT ->
                                        case *## [x_sgAkH sat_sgAkK] of sat_sgAkL {
                                          __DEFAULT ->
                                              let {
                                                sat_sgAkM [Occ=Once] :: GHC.Types.Double
                                                [LclId] =
                                                    CCCS GHC.Types.D#! [sat_sgAkL];
                                              } in  Data.Complex.:+ [sat_sgAkM sat_sgAkP];
                                        };
                                  };
                          };
                    };
              };
        };

Data.Complex.$wmkPolar [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.Floating a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LLC(C(S))LLLL)LLL)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A,A),A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAkQ w1_sgAkR w2_sgAkS]
        case
            GHC.Float.$p1Floating w_sgAkQ
        of
        $dFractional_sgAkT [Dmd=<S(S(LLC(C(S))LLLL)LLL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Fractional $dFractional_sgAkT
              of
              $dNum_sgAkU [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
              { __DEFAULT ->
                    let {
                      sat_sgAkV [Occ=Once] :: a_sgxwP
                      [LclId] =
                          [w_sgAkQ w2_sgAkS] \u [] GHC.Float.cos w_sgAkQ w2_sgAkS;
                    } in 
                      case GHC.Num.* $dNum_sgAkU w1_sgAkR sat_sgAkV of dt_sgAkW {
                        __DEFAULT ->
                            let {
                              sat_sgAkX [Occ=Once] :: a_sgxwP
                              [LclId] =
                                  [w_sgAkQ w2_sgAkS] \u [] GHC.Float.sin w_sgAkQ w2_sgAkS;
                            } in 
                              case GHC.Num.* $dNum_sgAkU w1_sgAkR sat_sgAkX of dt1_sgAkY {
                                __DEFAULT -> (#,#) [dt_sgAkW dt1_sgAkY];
                              };
                      };
              };
        };

Data.Complex.mkPolar [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.Floating a =>
     a -> a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LLC(C(S))LLLL)LLL)LLLLLLLLLLLLLLLLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),A,A,A),A,A,A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgAkZ w1_sgAl0 w2_sgAl1]
        case Data.Complex.$wmkPolar w_sgAkZ w1_sgAl0 w2_sgAl1 of {
          (#,#) ww1_sgAl3 [Occ=Once] ww2_sgAl4 [Occ=Once] ->
              Data.Complex.:+ [ww1_sgAl3 ww2_sgAl4];
        };

Data.Complex.$w$sphase [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> GHC.Prim.Double#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_sgAl5 ww1_sgAl6]
        case ==## [ww_sgAl5 0.0##] of {
          __DEFAULT ->
              let {
                sat_sgAl8 [Occ=Once] :: GHC.Types.Double
                [LclId] =
                    CCCS GHC.Types.D#! [ww1_sgAl6];
              } in  GHC.Float.$w$catan2 sat_sgAl8 ww_sgAl5;
          1# ->
              case ==## [ww1_sgAl6 0.0##] of {
                __DEFAULT ->
                    let {
                      sat_sgAla [Occ=Once] :: GHC.Types.Double
                      [LclId] =
                          CCCS GHC.Types.D#! [ww1_sgAl6];
                    } in  GHC.Float.$w$catan2 sat_sgAla ww_sgAl5;
                1# -> 0.0##;
              };
        };

Data.Complex.$fFloatingComplex_$sphase [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double -> GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAlb]
        case w_sgAlb of {
          Data.Complex.:+ ww1_sgAld [Occ=Once!] ww2_sgAle [Occ=Once!] ->
              case ww1_sgAld of {
                GHC.Types.D# ww4_sgAlg [Occ=Once] ->
                    case ww2_sgAle of {
                      GHC.Types.D# ww6_sgAli [Occ=Once] ->
                          case Data.Complex.$w$sphase ww4_sgAlg ww6_sgAli of ww7_sgAlj {
                            __DEFAULT -> GHC.Types.D# [ww7_sgAlj];
                          };
                    };
              };
        };

Data.Complex.$w$sphase1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> GHC.Prim.Float#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_sgAlk ww1_sgAll]
        case eqFloat# [ww_sgAlk 0.0#] of {
          __DEFAULT ->
              let {
                sat_sgAln [Occ=Once] :: GHC.Types.Float
                [LclId] =
                    CCCS GHC.Types.F#! [ww1_sgAll];
              } in  GHC.Float.$w$catan1 sat_sgAln ww_sgAlk;
          1# ->
              case eqFloat# [ww1_sgAll 0.0#] of {
                __DEFAULT ->
                    let {
                      sat_sgAlp [Occ=Once] :: GHC.Types.Float
                      [LclId] =
                          CCCS GHC.Types.F#! [ww1_sgAll];
                    } in  GHC.Float.$w$catan1 sat_sgAlp ww_sgAlk;
                1# -> 0.0#;
              };
        };

Data.Complex.$fFloatingComplex_$sphase1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float -> GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAlq]
        case w_sgAlq of {
          Data.Complex.:+ ww1_sgAls [Occ=Once!] ww2_sgAlt [Occ=Once!] ->
              case ww1_sgAls of {
                GHC.Types.F# ww4_sgAlv [Occ=Once] ->
                    case ww2_sgAlt of {
                      GHC.Types.F# ww6_sgAlx [Occ=Once] ->
                          case Data.Complex.$w$sphase1 ww4_sgAlv ww6_sgAlx of ww7_sgAly {
                            __DEFAULT -> GHC.Types.F# [ww7_sgAly];
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex17 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Complex.$wphase [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAlz ww_sgAlA ww1_sgAlB]
        case
            GHC.Float.$p1RealFloat w_sgAlz
        of
        $dRealFrac_sgAlC [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAlC
              of
              $dReal_sgAlD [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      $dNum_sgAlE [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_sgxxx
                      [LclId] =
                          [$dReal_sgAlD] \u [] GHC.Real.$p1Real $dReal_sgAlD;
                    } in 
                      case
                          GHC.Real.$p2Real $dReal_sgAlD
                      of
                      $dOrd_sgAlF [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                      { __DEFAULT ->
                            case
                                GHC.Classes.$p1Ord $dOrd_sgAlF
                            of
                            $dEq_sgAlG [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                            { __DEFAULT ->
                                  let {
                                    sat_sgAlH [Occ=Once] :: a_sgxxx
                                    [LclId] =
                                        [$dNum_sgAlE] \u []
                                            GHC.Num.fromInteger
                                                $dNum_sgAlE Data.Complex.$fFloatingComplex17;
                                  } in 
                                    case GHC.Classes.== $dEq_sgAlG ww_sgAlA sat_sgAlH of {
                                      GHC.Types.False -> GHC.Float.atan2 w_sgAlz ww1_sgAlB ww_sgAlA;
                                      GHC.Types.True ->
                                          let {
                                            sat_sgAlJ [Occ=Once] :: a_sgxxx
                                            [LclId] =
                                                [$dNum_sgAlE] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_sgAlE
                                                        Data.Complex.$fFloatingComplex17;
                                          } in 
                                            case GHC.Classes.== $dEq_sgAlG ww1_sgAlB sat_sgAlJ of {
                                              GHC.Types.False ->
                                                  GHC.Float.atan2 w_sgAlz ww1_sgAlB ww_sgAlA;
                                              GHC.Types.True ->
                                                  GHC.Num.fromInteger
                                                      $dNum_sgAlE Data.Complex.$fFloatingComplex17;
                                            };
                                    };
                            };
                      };
              };
        };

Data.Complex.phase [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAlL w1_sgAlM]
        case w1_sgAlM of {
          Data.Complex.:+ ww1_sgAlO [Occ=Once] ww2_sgAlP [Occ=Once] ->
              Data.Complex.$wphase w_sgAlL ww1_sgAlO ww2_sgAlP;
        };

Data.Complex.$w$smagnitude [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> GHC.Prim.Double#
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAlQ ww1_sgAlR]
        case GHC.Float.$w$cexponent ww_sgAlQ of ww2_sgAlS {
          __DEFAULT ->
              case GHC.Float.$w$cexponent ww1_sgAlR of ww3_sgAlT {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgAlU [Occ=Once*!T[1], Dmd=<C(S),1*C1(U)>]
                        :: GHC.Prim.Int# -> GHC.Prim.Double#
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgAlQ ww1_sgAlR] \r [x_sgAlV]
                              case negateInt# [x_sgAlV] of ww4_sgAlW [Dmd=<S,U>] {
                                __DEFAULT ->
                                    case GHC.Float.$w$cscaleFloat ww4_sgAlW ww_sgAlQ of ww5_sgAlX {
                                      __DEFAULT ->
                                          case
                                              GHC.Float.$w$cscaleFloat ww4_sgAlW ww1_sgAlR
                                          of
                                          ww6_sgAlY
                                          { __DEFAULT ->
                                                case *## [ww6_sgAlY ww6_sgAlY] of sat_sgAm0 {
                                                  __DEFAULT ->
                                                      case *## [ww5_sgAlX ww5_sgAlX] of sat_sgAlZ {
                                                        __DEFAULT ->
                                                            case
                                                                +## [sat_sgAlZ sat_sgAm0]
                                                            of
                                                            sat_sgAm1
                                                            { __DEFAULT ->
                                                                  case
                                                                      sqrtDouble# [sat_sgAm1]
                                                                  of
                                                                  sat_sgAm2
                                                                  { __DEFAULT ->
                                                                        GHC.Float.$w$cscaleFloat
                                                                            x_sgAlV sat_sgAm2;
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww2_sgAlS ww3_sgAlT] of {
                        __DEFAULT -> $j_sgAlU ww2_sgAlS;
                        1# -> $j_sgAlU ww3_sgAlT;
                      };
              };
        };

Data.Complex.$fFloatingComplex_$smagnitude [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double -> GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAm4]
        case w_sgAm4 of {
          Data.Complex.:+ ww1_sgAm6 [Occ=Once!] ww2_sgAm7 [Occ=Once!] ->
              case ww1_sgAm6 of {
                GHC.Types.D# ww4_sgAm9 [Occ=Once] ->
                    case ww2_sgAm7 of {
                      GHC.Types.D# ww6_sgAmb [Occ=Once] ->
                          case Data.Complex.$w$smagnitude ww4_sgAm9 ww6_sgAmb of ww7_sgAmc {
                            __DEFAULT -> GHC.Types.D# [ww7_sgAmc];
                          };
                    };
              };
        };

Data.Complex.$w$smagnitude1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> GHC.Prim.Float#
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAmd ww1_sgAme]
        case GHC.Float.$w$cexponent1 ww_sgAmd of ww2_sgAmf {
          __DEFAULT ->
              case GHC.Float.$w$cexponent1 ww1_sgAme of ww3_sgAmg {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgAmh [Occ=Once*!T[1], Dmd=<C(S),1*C1(U)>]
                        :: GHC.Prim.Int# -> GHC.Prim.Float#
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgAmd ww1_sgAme] \r [x_sgAmi]
                              case negateInt# [x_sgAmi] of ww4_sgAmj [Dmd=<S,U>] {
                                __DEFAULT ->
                                    case GHC.Float.$w$cscaleFloat1 ww4_sgAmj ww_sgAmd of ww5_sgAmk {
                                      __DEFAULT ->
                                          case
                                              GHC.Float.$w$cscaleFloat1 ww4_sgAmj ww1_sgAme
                                          of
                                          ww6_sgAml
                                          { __DEFAULT ->
                                                case
                                                    timesFloat# [ww6_sgAml ww6_sgAml]
                                                of
                                                sat_sgAmn
                                                { __DEFAULT ->
                                                      case
                                                          timesFloat# [ww5_sgAmk ww5_sgAmk]
                                                      of
                                                      sat_sgAmm
                                                      { __DEFAULT ->
                                                            case
                                                                plusFloat# [sat_sgAmm sat_sgAmn]
                                                            of
                                                            sat_sgAmo
                                                            { __DEFAULT ->
                                                                  case
                                                                      sqrtFloat# [sat_sgAmo]
                                                                  of
                                                                  sat_sgAmp
                                                                  { __DEFAULT ->
                                                                        GHC.Float.$w$cscaleFloat1
                                                                            x_sgAmi sat_sgAmp;
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww2_sgAmf ww3_sgAmg] of {
                        __DEFAULT -> $j_sgAmh ww2_sgAmf;
                        1# -> $j_sgAmh ww3_sgAmg;
                      };
              };
        };

Data.Complex.$fFloatingComplex_$smagnitude1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float -> GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAmr]
        case w_sgAmr of {
          Data.Complex.:+ ww1_sgAmt [Occ=Once!] ww2_sgAmu [Occ=Once!] ->
              case ww1_sgAmt of {
                GHC.Types.F# ww4_sgAmw [Occ=Once] ->
                    case ww2_sgAmu of {
                      GHC.Types.F# ww6_sgAmy [Occ=Once] ->
                          case Data.Complex.$w$smagnitude1 ww4_sgAmw ww6_sgAmy of ww7_sgAmz {
                            __DEFAULT -> GHC.Types.F# [ww7_sgAmz];
                          };
                    };
              };
        };

Data.Complex.$wmagnitude [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(C(S))LLLLLL),U(1*U(1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAmA ww_sgAmB ww1_sgAmC]
        let {
          k_sgAmD [Dmd=<L,U(U)>] :: GHC.Types.Int
          [LclId] =
              [w_sgAmA ww_sgAmB ww1_sgAmC] \u []
                  case GHC.Float.exponent w_sgAmA ww_sgAmB of wild_sgAmE {
                    GHC.Types.I# x1_sgAmF [Occ=Once] ->
                        case GHC.Float.exponent w_sgAmA ww1_sgAmC of wild1_sgAmG {
                          GHC.Types.I# y1_sgAmH [Occ=Once] ->
                              case <=# [x1_sgAmF y1_sgAmH] of {
                                __DEFAULT -> wild_sgAmE;
                                1# -> wild1_sgAmG;
                              };
                        };
                  }; } in
        let {
          sat_sgAmW [Occ=Once] :: a_sgxyi
          [LclId] =
              [w_sgAmA ww_sgAmB ww1_sgAmC k_sgAmD] \u []
                  let {
                    sat_sgAmV [Occ=Once] :: a_sgxyi
                    [LclId] =
                        [w_sgAmA ww_sgAmB ww1_sgAmC k_sgAmD] \u []
                            case
                                GHC.Float.$p1RealFloat w_sgAmA
                            of
                            $dRealFrac_sgAmK [Dmd=<S(S(S(C(C(S))LLLLLL)LL)LLLLLL),1*U(1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
                            { __DEFAULT ->
                                  case
                                      GHC.Real.$p1RealFrac $dRealFrac_sgAmK
                                  of
                                  $dReal_sgAmL [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A)>]
                                  { __DEFAULT ->
                                        case
                                            GHC.Real.$p1Real $dReal_sgAmL
                                        of
                                        $dNum_sgAmM [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A)>]
                                        { __DEFAULT ->
                                              let {
                                                mk_sgAmN :: GHC.Types.Int
                                                [LclId] =
                                                    [k_sgAmD] \u []
                                                        case k_sgAmD of {
                                                          GHC.Types.I# x_sgAmP [Occ=Once] ->
                                                              case
                                                                  negateInt# [x_sgAmP]
                                                              of
                                                              sat_sgAmQ
                                                              { __DEFAULT ->
                                                                    GHC.Types.I# [sat_sgAmQ];
                                                              };
                                                        }; } in
                                              let {
                                                sat_sgAmU [Occ=Once] :: a_sgxyi
                                                [LclId] =
                                                    [w_sgAmA ww1_sgAmC $dNum_sgAmM mk_sgAmN] \u []
                                                        let {
                                                          z_sgAmT :: a_sgxyi
                                                          [LclId] =
                                                              [w_sgAmA ww1_sgAmC mk_sgAmN] \u []
                                                                  GHC.Float.scaleFloat
                                                                      w_sgAmA mk_sgAmN ww1_sgAmC;
                                                        } in 
                                                          GHC.Num.*
                                                              $dNum_sgAmM z_sgAmT z_sgAmT; } in
                                              let {
                                                sat_sgAmS [Occ=Once] :: a_sgxyi
                                                [LclId] =
                                                    [w_sgAmA ww_sgAmB $dNum_sgAmM mk_sgAmN] \u []
                                                        let {
                                                          z_sgAmR :: a_sgxyi
                                                          [LclId] =
                                                              [w_sgAmA ww_sgAmB mk_sgAmN] \u []
                                                                  GHC.Float.scaleFloat
                                                                      w_sgAmA mk_sgAmN ww_sgAmB;
                                                        } in  GHC.Num.* $dNum_sgAmM z_sgAmR z_sgAmR;
                                              } in  GHC.Num.+ $dNum_sgAmM sat_sgAmS sat_sgAmU;
                                        };
                                  };
                            };
                  } in 
                    case GHC.Float.$p2RealFloat w_sgAmA of sat_sgAmJ {
                      __DEFAULT -> GHC.Float.sqrt sat_sgAmJ sat_sgAmV;
                    };
        } in  GHC.Float.scaleFloat w_sgAmA k_sgAmD sat_sgAmW;

Data.Complex.magnitude [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgAmX w1_sgAmY]
        case w1_sgAmY of {
          Data.Complex.:+ ww1_sgAn0 [Occ=Once] ww2_sgAn1 [Occ=Once] ->
              Data.Complex.$wmagnitude w_sgAmX ww1_sgAn0 ww2_sgAn1;
        };

Data.Complex.$fFloatingComplex_$s$clog1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAn2]
        case w_sgAn2 of {
          Data.Complex.:+ ww1_sgAn4 [Occ=Once!] ww2_sgAn5 [Occ=Once!] ->
              case ww1_sgAn4 of {
                GHC.Types.F# ww4_sgAn7 ->
                    case ww2_sgAn5 of {
                      GHC.Types.F# ww6_sgAn9 ->
                          case Data.Complex.$w$smagnitude1 ww4_sgAn7 ww6_sgAn9 of ww7_sgAna {
                            __DEFAULT ->
                                case logFloat# [ww7_sgAna] of wild1_sgAnb {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$sphase1 ww4_sgAn7 ww6_sgAn9
                                      of
                                      ww8_sgAnc
                                      { __DEFAULT ->
                                            let {
                                              sat_sgAne [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [ww8_sgAnc]; } in
                                            let {
                                              sat_sgAnd [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [wild1_sgAnb];
                                            } in  Data.Complex.:+ [sat_sgAnd sat_sgAne];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cabs1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [z_sgAnf]
        case z_sgAnf of {
          Data.Complex.:+ ww1_sgAnh [Occ=Once!] ww2_sgAni [Occ=Once!] ->
              case ww1_sgAnh of {
                GHC.Types.F# ww4_sgAnk [Occ=Once] ->
                    case ww2_sgAni of {
                      GHC.Types.F# ww6_sgAnm [Occ=Once] ->
                          case Data.Complex.$w$smagnitude1 ww4_sgAnk ww6_sgAnm of ww7_sgAnn {
                            __DEFAULT ->
                                let {
                                  sat_sgAno [Occ=Once] :: GHC.Types.Float
                                  [LclId] =
                                      CCCS GHC.Types.F#! [ww7_sgAnn];
                                } in  Data.Complex.:+ [sat_sgAno Data.Complex.$fFloatingComplex9];
                          };
                    };
              };
        };

Data.Complex.polar_$spolar
  :: Data.Complex.Complex GHC.Types.Double
     -> (GHC.Types.Double, GHC.Types.Double)
[GblId, Arity=1, Str=<L,U(U(U),U(U))>m, Unf=OtherCon []] =
    [] \r [z_sgAnp]
        let {
          sat_sgAnr [Occ=Once] :: GHC.Types.Double
          [LclId] =
              [z_sgAnp] \u []
                  Data.Complex.$fFloatingComplex_$sphase z_sgAnp; } in
        let {
          sat_sgAnq [Occ=Once] :: GHC.Types.Double
          [LclId] =
              [z_sgAnp] \u [] Data.Complex.$fFloatingComplex_$smagnitude z_sgAnp;
        } in  (,) [sat_sgAnq sat_sgAnr];

Data.Complex.polar
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> (a, a)
[GblId,
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgAns z_sgAnt]
        let {
          sat_sgAnv [Occ=Once] :: a_agsyd
          [LclId] =
              [$dRealFloat_sgAns z_sgAnt] \u []
                  Data.Complex.phase $dRealFloat_sgAns z_sgAnt; } in
        let {
          sat_sgAnu [Occ=Once] :: a_agsyd
          [LclId] =
              [$dRealFloat_sgAns z_sgAnt] \u []
                  Data.Complex.magnitude $dRealFloat_sgAns z_sgAnt;
        } in  (,) [sat_sgAnu sat_sgAnv];

Data.Complex.$fFloatingComplex1 :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.D#! [0.0##];

Data.Complex.$fFloatingComplex_$s$cpi
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [GHC.Float.$fFloatingDouble_$cpi
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$w$cpi [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => (# a, a #)
[GblId,
 Arity=1,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)S(LSLLLLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A),1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [w_sgAnw]
        case GHC.Float.$p2RealFloat w_sgAnw of sat_sgAnx {
          __DEFAULT ->
              case GHC.Float.pi sat_sgAnx of dt_sgAny {
                __DEFAULT ->
                    case GHC.Float.$p1RealFloat w_sgAnw of sat_sgAnz {
                      __DEFAULT ->
                          case GHC.Real.$p1RealFrac sat_sgAnz of sat_sgAnA {
                            __DEFAULT ->
                                case GHC.Real.$p1Real sat_sgAnA of sat_sgAnB {
                                  __DEFAULT ->
                                      case
                                          GHC.Num.fromInteger
                                              sat_sgAnB Data.Complex.$fFloatingComplex17
                                      of
                                      dt1_sgAnC
                                      { __DEFAULT -> (#,#) [dt_sgAny dt1_sgAnC];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cpi [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => Data.Complex.Complex a
[GblId,
 Arity=1,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)S(LSLLLLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAnD]
        case Data.Complex.$w$cpi w_sgAnD of {
          (#,#) ww1_sgAnF [Occ=Once] ww2_sgAnG [Occ=Once] ->
              Data.Complex.:+ [ww1_sgAnF ww2_sgAnG];
        };

Data.Complex.$fFloatingComplex_$s$cexp
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAnH]
        case ds_sgAnH of {
          Data.Complex.:+ x_sgAnJ [Occ=Once!] y_sgAnK [Occ=Once!] ->
              case x_sgAnJ of {
                GHC.Types.D# x1_sgAnM [Occ=Once] ->
                    case y_sgAnK of {
                      GHC.Types.D# x2_sgAnO ->
                          case expDouble# [x1_sgAnM] of expx_sgAnP {
                            __DEFAULT ->
                                case sinDouble# [x2_sgAnO] of sat_sgAnT {
                                  __DEFAULT ->
                                      case *## [expx_sgAnP sat_sgAnT] of sat_sgAnU {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAnV [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgAnU];
                                            } in 
                                              case cosDouble# [x2_sgAnO] of sat_sgAnQ {
                                                __DEFAULT ->
                                                    case *## [expx_sgAnP sat_sgAnQ] of sat_sgAnR {
                                                      __DEFAULT ->
                                                          let {
                                                            sat_sgAnS [Occ=Once] :: GHC.Types.Double
                                                            [LclId] =
                                                                CCCS GHC.Types.D#! [sat_sgAnR];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgAnS sat_sgAnV];
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$cexp [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAnW ww_sgAnX ww1_sgAnY]
        case
            GHC.Float.$p1RealFloat w_sgAnW
        of
        $dRealFrac_sgAnZ [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAnZ
              of
              $dReal_sgAo0 [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAo0
                    of
                    $dNum_sgAo1 [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dFloating_sgAo2 [Dmd=<L,U(A,A,1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
                              :: GHC.Float.Floating a_sgxyP
                            [LclId] =
                                [w_sgAnW] \u [] GHC.Float.$p2RealFloat w_sgAnW; } in
                          let {
                            expx_sgAo3 :: a_sgxyP
                            [LclId] =
                                [ww_sgAnX $dFloating_sgAo2] \u []
                                    GHC.Float.exp $dFloating_sgAo2 ww_sgAnX; } in
                          let {
                            sat_sgAo4 [Occ=Once] :: a_sgxyP
                            [LclId] =
                                [ww1_sgAnY $dFloating_sgAo2] \u []
                                    GHC.Float.cos $dFloating_sgAo2 ww1_sgAnY;
                          } in 
                            case GHC.Num.* $dNum_sgAo1 expx_sgAo3 sat_sgAo4 of dt_sgAo5 {
                              __DEFAULT ->
                                  let {
                                    sat_sgAo6 [Occ=Once] :: a_sgxyP
                                    [LclId] =
                                        [ww1_sgAnY $dFloating_sgAo2] \u []
                                            GHC.Float.sin $dFloating_sgAo2 ww1_sgAnY;
                                  } in 
                                    case GHC.Num.* $dNum_sgAo1 expx_sgAo3 sat_sgAo6 of dt1_sgAo7 {
                                      __DEFAULT -> (#,#) [dt_sgAo5 dt1_sgAo7];
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cexp [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAo8 w1_sgAo9]
        case w1_sgAo9 of {
          Data.Complex.:+ ww1_sgAob [Occ=Once] ww2_sgAoc [Occ=Once] ->
              case Data.Complex.$w$cexp w_sgAo8 ww1_sgAob ww2_sgAoc of {
                (#,#) ww4_sgAoe [Occ=Once] ww5_sgAof [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAoe ww5_sgAof];
              };
        };

Data.Complex.$fFloatingComplex_$s$clog [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAog]
        case w_sgAog of {
          Data.Complex.:+ ww1_sgAoi [Occ=Once!] ww2_sgAoj [Occ=Once!] ->
              case ww1_sgAoi of {
                GHC.Types.D# ww4_sgAol ->
                    case ww2_sgAoj of {
                      GHC.Types.D# ww6_sgAon ->
                          case Data.Complex.$w$smagnitude ww4_sgAol ww6_sgAon of ww7_sgAoo {
                            __DEFAULT ->
                                case logDouble# [ww7_sgAoo] of wild1_sgAop {
                                  __DEFAULT ->
                                      case Data.Complex.$w$sphase ww4_sgAol ww6_sgAon of ww8_sgAoq {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAos [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [ww8_sgAoq]; } in
                                            let {
                                              sat_sgAor [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [wild1_sgAop];
                                            } in  Data.Complex.:+ [sat_sgAor sat_sgAos];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$clog [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAot ww_sgAou ww1_sgAov]
        let {
          sat_sgAox [Occ=Once] :: a_sgxzj
          [LclId] =
              [w_sgAot ww_sgAou ww1_sgAov] \u []
                  Data.Complex.$wmagnitude w_sgAot ww_sgAou ww1_sgAov;
        } in 
          case GHC.Float.$p2RealFloat w_sgAot of sat_sgAow {
            __DEFAULT ->
                case GHC.Float.log sat_sgAow sat_sgAox of dt_sgAoy {
                  __DEFAULT ->
                      case Data.Complex.$wphase w_sgAot ww_sgAou ww1_sgAov of dt1_sgAoz {
                        __DEFAULT -> (#,#) [dt_sgAoy dt1_sgAoz];
                      };
                };
          };

Data.Complex.$fFloatingComplex_$clog [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAoA w1_sgAoB]
        case w1_sgAoB of {
          Data.Complex.:+ ww1_sgAoD [Occ=Once] ww2_sgAoE [Occ=Once] ->
              case Data.Complex.$w$clog w_sgAoA ww1_sgAoD ww2_sgAoE of {
                (#,#) ww4_sgAoG [Occ=Once] ww5_sgAoH [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAoG ww5_sgAoH];
              };
        };

Data.Complex.$fFloatingComplex_$s$csin
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAoI]
        case ds_sgAoI of {
          Data.Complex.:+ x_sgAoK [Occ=Once!] y_sgAoL [Occ=Once!] ->
              case y_sgAoL of {
                GHC.Types.D# x1_sgAoN ->
                    case x_sgAoK of {
                      GHC.Types.D# x2_sgAoP ->
                          case sinhDouble# [x1_sgAoN] of sat_sgAoV {
                            __DEFAULT ->
                                case cosDouble# [x2_sgAoP] of sat_sgAoU {
                                  __DEFAULT ->
                                      case *## [sat_sgAoU sat_sgAoV] of sat_sgAoW {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAoX [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgAoW];
                                            } in 
                                              case coshDouble# [x1_sgAoN] of sat_sgAoR {
                                                __DEFAULT ->
                                                    case sinDouble# [x2_sgAoP] of sat_sgAoQ {
                                                      __DEFAULT ->
                                                          case
                                                              *## [sat_sgAoQ sat_sgAoR]
                                                          of
                                                          sat_sgAoS
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgAoT [Occ=Once]
                                                                    :: GHC.Types.Double
                                                                  [LclId] =
                                                                      CCCS GHC.Types.D#! [sat_sgAoS];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgAoT
                                                                                   sat_sgAoX];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$csin [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAoY ww_sgAoZ ww1_sgAp0]
        let {
          $dFloating_sgAp1 [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxzv
          [LclId] =
              [w_sgAoY] \u [] GHC.Float.$p2RealFloat w_sgAoY;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgAoY
          of
          $dRealFrac_sgAp2 [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgAp2
                of
                $dReal_sgAp3 [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgAp3
                      of
                      $dNum_sgAp4 [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgAp6 [Occ=Once] :: a_sgxzv
                              [LclId] =
                                  [ww1_sgAp0 $dFloating_sgAp1] \u []
                                      GHC.Float.cosh $dFloating_sgAp1 ww1_sgAp0; } in
                            let {
                              sat_sgAp5 [Occ=Once] :: a_sgxzv
                              [LclId] =
                                  [ww_sgAoZ $dFloating_sgAp1] \u []
                                      GHC.Float.sin $dFloating_sgAp1 ww_sgAoZ;
                            } in 
                              case GHC.Num.* $dNum_sgAp4 sat_sgAp5 sat_sgAp6 of dt_sgAp7 {
                                __DEFAULT ->
                                    let {
                                      sat_sgAp9 [Occ=Once] :: a_sgxzv
                                      [LclId] =
                                          [ww1_sgAp0 $dFloating_sgAp1] \u []
                                              GHC.Float.sinh $dFloating_sgAp1 ww1_sgAp0; } in
                                    let {
                                      sat_sgAp8 [Occ=Once] :: a_sgxzv
                                      [LclId] =
                                          [ww_sgAoZ $dFloating_sgAp1] \u []
                                              GHC.Float.cos $dFloating_sgAp1 ww_sgAoZ;
                                    } in 
                                      case GHC.Num.* $dNum_sgAp4 sat_sgAp8 sat_sgAp9 of dt1_sgApa {
                                        __DEFAULT -> (#,#) [dt_sgAp7 dt1_sgApa];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$csin [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgApb w1_sgApc]
        case w1_sgApc of {
          Data.Complex.:+ ww1_sgApe [Occ=Once] ww2_sgApf [Occ=Once] ->
              case Data.Complex.$w$csin w_sgApb ww1_sgApe ww2_sgApf of {
                (#,#) ww4_sgAph [Occ=Once] ww5_sgApi [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAph ww5_sgApi];
              };
        };

Data.Complex.$fFloatingComplex_$s$ccos
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgApj]
        case ds_sgApj of {
          Data.Complex.:+ x_sgApl [Occ=Once!] y_sgApm [Occ=Once!] ->
              case y_sgApm of {
                GHC.Types.D# x1_sgApo ->
                    case x_sgApl of {
                      GHC.Types.D# x2_sgApq ->
                          case sinhDouble# [x1_sgApo] of sat_sgApw {
                            __DEFAULT ->
                                case sinDouble# [x2_sgApq] of sat_sgApv {
                                  __DEFAULT ->
                                      case *## [sat_sgApv sat_sgApw] of sat_sgApx {
                                        __DEFAULT ->
                                            case negateDouble# [sat_sgApx] of sat_sgApy {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgApz [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [sat_sgApy];
                                                  } in 
                                                    case coshDouble# [x1_sgApo] of sat_sgAps {
                                                      __DEFAULT ->
                                                          case cosDouble# [x2_sgApq] of sat_sgApr {
                                                            __DEFAULT ->
                                                                case
                                                                    *## [sat_sgApr sat_sgAps]
                                                                of
                                                                sat_sgApt
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_sgApu [Occ=Once]
                                                                          :: GHC.Types.Double
                                                                        [LclId] =
                                                                            CCCS GHC.Types.D#! [sat_sgApt];
                                                                      } in 
                                                                        Data.Complex.:+ [sat_sgApu
                                                                                         sat_sgApz];
                                                                };
                                                          };
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ccos [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgApA ww_sgApB ww1_sgApC]
        let {
          $dFloating_sgApD [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxzH
          [LclId] =
              [w_sgApA] \u [] GHC.Float.$p2RealFloat w_sgApA;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgApA
          of
          $dRealFrac_sgApE [Dmd=<S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgApE
                of
                $dReal_sgApF [Dmd=<S(S(LLC(C(S))C(S)LLL)LL),1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgApF
                      of
                      $dNum_sgApG [Dmd=<S(LLC(C(S))C(S)LLL),U(A,A,C(C1(U)),1*C1(U),A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgApI [Occ=Once] :: a_sgxzH
                              [LclId] =
                                  [ww1_sgApC $dFloating_sgApD] \u []
                                      GHC.Float.cosh $dFloating_sgApD ww1_sgApC; } in
                            let {
                              sat_sgApH [Occ=Once] :: a_sgxzH
                              [LclId] =
                                  [ww_sgApB $dFloating_sgApD] \u []
                                      GHC.Float.cos $dFloating_sgApD ww_sgApB;
                            } in 
                              case GHC.Num.* $dNum_sgApG sat_sgApH sat_sgApI of dt_sgApJ {
                                __DEFAULT ->
                                    let {
                                      sat_sgApM [Occ=Once] :: a_sgxzH
                                      [LclId] =
                                          [ww_sgApB ww1_sgApC $dFloating_sgApD $dNum_sgApG] \u []
                                              let {
                                                sat_sgApL [Occ=Once] :: a_sgxzH
                                                [LclId] =
                                                    [ww1_sgApC $dFloating_sgApD] \u []
                                                        GHC.Float.sinh
                                                            $dFloating_sgApD ww1_sgApC; } in
                                              let {
                                                sat_sgApK [Occ=Once] :: a_sgxzH
                                                [LclId] =
                                                    [ww_sgApB $dFloating_sgApD] \u []
                                                        GHC.Float.sin $dFloating_sgApD ww_sgApB;
                                              } in  GHC.Num.* $dNum_sgApG sat_sgApK sat_sgApL;
                                    } in 
                                      case GHC.Num.negate $dNum_sgApG sat_sgApM of dt1_sgApN {
                                        __DEFAULT -> (#,#) [dt_sgApJ dt1_sgApN];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$ccos [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),C(U),A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgApO w1_sgApP]
        case w1_sgApP of {
          Data.Complex.:+ ww1_sgApR [Occ=Once] ww2_sgApS [Occ=Once] ->
              case Data.Complex.$w$ccos w_sgApO ww1_sgApR ww2_sgApS of {
                (#,#) ww4_sgApU [Occ=Once] ww5_sgApV [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgApU ww5_sgApV];
              };
        };

Data.Complex.$fFloatingComplex_$s$csinh
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgApW]
        case ds_sgApW of {
          Data.Complex.:+ x_sgApY [Occ=Once!] y_sgApZ [Occ=Once!] ->
              case x_sgApY of {
                GHC.Types.D# x1_sgAq1 ->
                    case y_sgApZ of {
                      GHC.Types.D# x2_sgAq3 ->
                          case coshDouble# [x1_sgAq1] of sat_sgAq9 {
                            __DEFAULT ->
                                case sinDouble# [x2_sgAq3] of sat_sgAq8 {
                                  __DEFAULT ->
                                      case *## [sat_sgAq8 sat_sgAq9] of sat_sgAqa {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAqb [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgAqa];
                                            } in 
                                              case sinhDouble# [x1_sgAq1] of sat_sgAq5 {
                                                __DEFAULT ->
                                                    case cosDouble# [x2_sgAq3] of sat_sgAq4 {
                                                      __DEFAULT ->
                                                          case
                                                              *## [sat_sgAq4 sat_sgAq5]
                                                          of
                                                          sat_sgAq6
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgAq7 [Occ=Once]
                                                                    :: GHC.Types.Double
                                                                  [LclId] =
                                                                      CCCS GHC.Types.D#! [sat_sgAq6];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgAq7
                                                                                   sat_sgAqb];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$csinh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAqc ww_sgAqd ww1_sgAqe]
        let {
          $dFloating_sgAqf [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxzT
          [LclId] =
              [w_sgAqc] \u [] GHC.Float.$p2RealFloat w_sgAqc;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgAqc
          of
          $dRealFrac_sgAqg [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgAqg
                of
                $dReal_sgAqh [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgAqh
                      of
                      $dNum_sgAqi [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgAqk [Occ=Once] :: a_sgxzT
                              [LclId] =
                                  [ww_sgAqd $dFloating_sgAqf] \u []
                                      GHC.Float.sinh $dFloating_sgAqf ww_sgAqd; } in
                            let {
                              sat_sgAqj [Occ=Once] :: a_sgxzT
                              [LclId] =
                                  [ww1_sgAqe $dFloating_sgAqf] \u []
                                      GHC.Float.cos $dFloating_sgAqf ww1_sgAqe;
                            } in 
                              case GHC.Num.* $dNum_sgAqi sat_sgAqj sat_sgAqk of dt_sgAql {
                                __DEFAULT ->
                                    let {
                                      sat_sgAqn [Occ=Once] :: a_sgxzT
                                      [LclId] =
                                          [ww_sgAqd $dFloating_sgAqf] \u []
                                              GHC.Float.cosh $dFloating_sgAqf ww_sgAqd; } in
                                    let {
                                      sat_sgAqm [Occ=Once] :: a_sgxzT
                                      [LclId] =
                                          [ww1_sgAqe $dFloating_sgAqf] \u []
                                              GHC.Float.sin $dFloating_sgAqf ww1_sgAqe;
                                    } in 
                                      case GHC.Num.* $dNum_sgAqi sat_sgAqm sat_sgAqn of dt1_sgAqo {
                                        __DEFAULT -> (#,#) [dt_sgAql dt1_sgAqo];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$csinh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAqp w1_sgAqq]
        case w1_sgAqq of {
          Data.Complex.:+ ww1_sgAqs [Occ=Once] ww2_sgAqt [Occ=Once] ->
              case Data.Complex.$w$csinh w_sgAqp ww1_sgAqs ww2_sgAqt of {
                (#,#) ww4_sgAqv [Occ=Once] ww5_sgAqw [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAqv ww5_sgAqw];
              };
        };

Data.Complex.$fFloatingComplex_$s$ccosh
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAqx]
        case ds_sgAqx of {
          Data.Complex.:+ x_sgAqz [Occ=Once!] y_sgAqA [Occ=Once!] ->
              case x_sgAqz of {
                GHC.Types.D# x1_sgAqC ->
                    case y_sgAqA of {
                      GHC.Types.D# x2_sgAqE ->
                          case sinhDouble# [x1_sgAqC] of sat_sgAqK {
                            __DEFAULT ->
                                case sinDouble# [x2_sgAqE] of sat_sgAqJ {
                                  __DEFAULT ->
                                      case *## [sat_sgAqJ sat_sgAqK] of sat_sgAqL {
                                        __DEFAULT ->
                                            let {
                                              sat_sgAqM [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgAqL];
                                            } in 
                                              case coshDouble# [x1_sgAqC] of sat_sgAqG {
                                                __DEFAULT ->
                                                    case cosDouble# [x2_sgAqE] of sat_sgAqF {
                                                      __DEFAULT ->
                                                          case
                                                              *## [sat_sgAqF sat_sgAqG]
                                                          of
                                                          sat_sgAqH
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgAqI [Occ=Once]
                                                                    :: GHC.Types.Double
                                                                  [LclId] =
                                                                      CCCS GHC.Types.D#! [sat_sgAqH];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgAqI
                                                                                   sat_sgAqM];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ccosh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAqN ww_sgAqO ww1_sgAqP]
        let {
          $dFloating_sgAqQ [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxA5
          [LclId] =
              [w_sgAqN] \u [] GHC.Float.$p2RealFloat w_sgAqN;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgAqN
          of
          $dRealFrac_sgAqR [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgAqR
                of
                $dReal_sgAqS [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgAqS
                      of
                      $dNum_sgAqT [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgAqV [Occ=Once] :: a_sgxA5
                              [LclId] =
                                  [ww_sgAqO $dFloating_sgAqQ] \u []
                                      GHC.Float.cosh $dFloating_sgAqQ ww_sgAqO; } in
                            let {
                              sat_sgAqU [Occ=Once] :: a_sgxA5
                              [LclId] =
                                  [ww1_sgAqP $dFloating_sgAqQ] \u []
                                      GHC.Float.cos $dFloating_sgAqQ ww1_sgAqP;
                            } in 
                              case GHC.Num.* $dNum_sgAqT sat_sgAqU sat_sgAqV of dt_sgAqW {
                                __DEFAULT ->
                                    let {
                                      sat_sgAqY [Occ=Once] :: a_sgxA5
                                      [LclId] =
                                          [ww_sgAqO $dFloating_sgAqQ] \u []
                                              GHC.Float.sinh $dFloating_sgAqQ ww_sgAqO; } in
                                    let {
                                      sat_sgAqX [Occ=Once] :: a_sgxA5
                                      [LclId] =
                                          [ww1_sgAqP $dFloating_sgAqQ] \u []
                                              GHC.Float.sin $dFloating_sgAqQ ww1_sgAqP;
                                    } in 
                                      case GHC.Num.* $dNum_sgAqT sat_sgAqX sat_sgAqY of dt1_sgAqZ {
                                        __DEFAULT -> (#,#) [dt_sgAqW dt1_sgAqZ];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$ccosh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAr0 w1_sgAr1]
        case w1_sgAr1 of {
          Data.Complex.:+ ww1_sgAr3 [Occ=Once] ww2_sgAr4 [Occ=Once] ->
              case Data.Complex.$w$ccosh w_sgAr0 ww1_sgAr3 ww2_sgAr4 of {
                (#,#) ww4_sgAr6 [Occ=Once] ww5_sgAr7 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAr6 ww5_sgAr7];
              };
        };

Data.Complex.$w$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAr8 ww1_sgAr9 ww2_sgAra ww3_sgArb]
        case GHC.Float.$w$cexponent ww2_sgAra of ww4_sgArc {
          __DEFAULT ->
              case GHC.Float.$w$cexponent ww3_sgArb of ww5_sgArd {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgAre [Occ=Once*!T[1], Dmd=<C(S),1*C1(U(U,U))>]
                        :: GHC.Prim.Int# -> (# GHC.Types.Double, GHC.Types.Double #)
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgAr8 ww1_sgAr9 ww2_sgAra ww3_sgArb] \r [ww6_sgArf]
                              case GHC.Float.$w$cscaleFloat ww6_sgArf ww2_sgAra of ww7_sgArg {
                                __DEFAULT ->
                                    case GHC.Float.$w$cscaleFloat ww6_sgArf ww3_sgArb of ww8_sgArh {
                                      __DEFAULT ->
                                          case *## [ww3_sgArb ww8_sgArh] of sat_sgArk {
                                            __DEFAULT ->
                                                case *## [ww2_sgAra ww7_sgArg] of sat_sgArj {
                                                  __DEFAULT ->
                                                      case
                                                          +## [sat_sgArj sat_sgArk]
                                                      of
                                                      y_sgAri [Dmd=<S,U>]
                                                      { __DEFAULT ->
                                                            case
                                                                *## [ww1_sgAr9 ww8_sgArh]
                                                            of
                                                            sat_sgArm
                                                            { __DEFAULT ->
                                                                  case
                                                                      *## [ww_sgAr8 ww7_sgArg]
                                                                  of
                                                                  sat_sgArl
                                                                  { __DEFAULT ->
                                                                        case
                                                                            +## [sat_sgArl
                                                                                 sat_sgArm]
                                                                        of
                                                                        sat_sgArn
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  /## [sat_sgArn
                                                                                       y_sgAri]
                                                                              of
                                                                              wild2_sgAro
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        *## [ww_sgAr8
                                                                                             ww8_sgArh]
                                                                                    of
                                                                                    sat_sgArq
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              *## [ww1_sgAr9
                                                                                                   ww7_sgArg]
                                                                                          of
                                                                                          sat_sgArp
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    -## [sat_sgArp
                                                                                                         sat_sgArq]
                                                                                                of
                                                                                                sat_sgArr
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          /## [sat_sgArr
                                                                                                               y_sgAri]
                                                                                                      of
                                                                                                      wild1_sgArs
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgAru [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [wild1_sgArs]; } in
                                                                                                            let {
                                                                                                              sat_sgArt [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [wild2_sgAro];
                                                                                                            } in 
                                                                                                              (#,#) [sat_sgArt
                                                                                                                     sat_sgAru];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww4_sgArc ww5_sgArd] of {
                        __DEFAULT ->
                            case negateInt# [ww4_sgArc] of sat_sgArw {
                              __DEFAULT -> $j_sgAre sat_sgArw;
                            };
                        1# ->
                            case negateInt# [ww5_sgArd] of sat_sgArx {
                              __DEFAULT -> $j_sgAre sat_sgArx;
                            };
                      };
              };
        };

Data.Complex.$fFloatingComplex_$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAry w1_sgArz]
        case w_sgAry of {
          Data.Complex.:+ ww1_sgArB [Occ=Once!] ww2_sgArC [Occ=Once!] ->
              case ww1_sgArB of {
                GHC.Types.D# ww4_sgArE [Occ=Once] ->
                    case ww2_sgArC of {
                      GHC.Types.D# ww6_sgArG [Occ=Once] ->
                          case w1_sgArz of {
                            Data.Complex.:+ ww8_sgArI [Occ=Once!] ww9_sgArJ [Occ=Once!] ->
                                case ww8_sgArI of {
                                  GHC.Types.D# ww11_sgArL [Occ=Once] ->
                                      case ww9_sgArJ of {
                                        GHC.Types.D# ww13_sgArN [Occ=Once] ->
                                            case
                                                Data.Complex.$w$s$c/
                                                    ww4_sgArE ww6_sgArG ww11_sgArL ww13_sgArN
                                            of
                                            { (#,#) ww15_sgArP [Occ=Once] ww16_sgArQ [Occ=Once] ->
                                                  Data.Complex.:+ [ww15_sgArP ww16_sgArQ];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgArR ww_sgArS ww1_sgArT ww2_sgArU ww3_sgArV]
        case
            GHC.Float.$p1RealFloat w_sgArR
        of
        $dRealFrac_sgArW [Dmd=<S(LS(LC(C(S))LL)LLLLL),U(1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p2RealFrac $dRealFrac_sgArW
              of
              $dFractional_sgArX [Dmd=<S(LC(C(S))LL),U(A,C(C1(U)),A,A)>]
              { __DEFAULT ->
                    let {
                      $dReal_sgArY [Occ=OnceL,
                                    Dmd=<L,1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
                        :: GHC.Real.Real a_sgxAO
                      [LclId] =
                          [$dRealFrac_sgArW] \s []
                              GHC.Real.$p1RealFrac $dRealFrac_sgArW; } in
                    let {
                      $dNum_sgArZ [Dmd=<L,U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
                        :: GHC.Num.Num a_sgxAO
                      [LclId] =
                          [$dReal_sgArY] \u [] GHC.Real.$p1Real $dReal_sgArY; } in
                    let {
                      k_sgAs0 :: GHC.Types.Int
                      [LclId] =
                          [w_sgArR ww2_sgArU ww3_sgArV] \u []
                              case GHC.Float.exponent w_sgArR ww2_sgArU of {
                                GHC.Types.I# x1_sgAs2 ->
                                    case GHC.Float.exponent w_sgArR ww3_sgArV of {
                                      GHC.Types.I# y1_sgAs4 ->
                                          case <=# [x1_sgAs2 y1_sgAs4] of {
                                            __DEFAULT ->
                                                case negateInt# [x1_sgAs2] of sat_sgAs6 {
                                                  __DEFAULT -> GHC.Types.I# [sat_sgAs6];
                                                };
                                            1# ->
                                                case negateInt# [y1_sgAs4] of sat_sgAs7 {
                                                  __DEFAULT -> GHC.Types.I# [sat_sgAs7];
                                                };
                                          };
                                    };
                              }; } in
                    let {
                      y''_sgAs8 :: a_sgxAO
                      [LclId] =
                          [w_sgArR ww3_sgArV k_sgAs0] \u []
                              GHC.Float.scaleFloat w_sgArR k_sgAs0 ww3_sgArV; } in
                    let {
                      x''_sgAs9 :: a_sgxAO
                      [LclId] =
                          [w_sgArR ww2_sgArU k_sgAs0] \u []
                              GHC.Float.scaleFloat w_sgArR k_sgAs0 ww2_sgArU; } in
                    let {
                      d_sgAsa :: a_sgxAO
                      [LclId] =
                          [ww2_sgArU ww3_sgArV $dNum_sgArZ y''_sgAs8 x''_sgAs9] \u []
                              let {
                                sat_sgAsc [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww3_sgArV $dNum_sgArZ y''_sgAs8] \u []
                                        GHC.Num.* $dNum_sgArZ ww3_sgArV y''_sgAs8; } in
                              let {
                                sat_sgAsb [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww2_sgArU $dNum_sgArZ x''_sgAs9] \u []
                                        GHC.Num.* $dNum_sgArZ ww2_sgArU x''_sgAs9;
                              } in  GHC.Num.+ $dNum_sgArZ sat_sgAsb sat_sgAsc; } in
                    let {
                      sat_sgAsf [Occ=Once] :: a_sgxAO
                      [LclId] =
                          [ww_sgArS ww1_sgArT $dNum_sgArZ y''_sgAs8 x''_sgAs9] \u []
                              let {
                                sat_sgAse [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww1_sgArT $dNum_sgArZ y''_sgAs8] \u []
                                        GHC.Num.* $dNum_sgArZ ww1_sgArT y''_sgAs8; } in
                              let {
                                sat_sgAsd [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww_sgArS $dNum_sgArZ x''_sgAs9] \u []
                                        GHC.Num.* $dNum_sgArZ ww_sgArS x''_sgAs9;
                              } in  GHC.Num.+ $dNum_sgArZ sat_sgAsd sat_sgAse;
                    } in 
                      case GHC.Real./ $dFractional_sgArX sat_sgAsf d_sgAsa of dt_sgAsg {
                        __DEFAULT ->
                            let {
                              sat_sgAsj [Occ=Once] :: a_sgxAO
                              [LclId] =
                                  [ww_sgArS ww1_sgArT $dNum_sgArZ y''_sgAs8 x''_sgAs9] \u []
                                      let {
                                        sat_sgAsi [Occ=Once] :: a_sgxAO
                                        [LclId] =
                                            [ww_sgArS $dNum_sgArZ y''_sgAs8] \u []
                                                GHC.Num.* $dNum_sgArZ ww_sgArS y''_sgAs8; } in
                                      let {
                                        sat_sgAsh [Occ=Once] :: a_sgxAO
                                        [LclId] =
                                            [ww1_sgArT $dNum_sgArZ x''_sgAs9] \u []
                                                GHC.Num.* $dNum_sgArZ ww1_sgArT x''_sgAs9;
                                      } in  GHC.Num.- $dNum_sgArZ sat_sgAsh sat_sgAsi;
                            } in 
                              case GHC.Real./ $dFractional_sgArX sat_sgAsj d_sgAsa of dt1_sgAsk {
                                __DEFAULT -> (#,#) [dt_sgAsg dt1_sgAsk];
                              };
                      };
              };
        };

Data.Complex.$fFloatingComplex_$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAsl w1_sgAsm w2_sgAsn]
        case w1_sgAsm of {
          Data.Complex.:+ ww1_sgAsp [Occ=Once] ww2_sgAsq [Occ=Once] ->
              case w2_sgAsn of {
                Data.Complex.:+ ww4_sgAss [Occ=Once] ww5_sgAst [Occ=Once] ->
                    case
                        Data.Complex.$w$c/ w_sgAsl ww1_sgAsp ww2_sgAsq ww4_sgAss ww5_sgAst
                    of
                    { (#,#) ww7_sgAsv [Occ=Once] ww8_sgAsw [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgAsv ww8_sgAsw];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromRational
  :: GHC.Real.Rational -> Data.Complex.Complex GHC.Types.Double
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [a_sgAsx]
        case a_sgAsx of {
          GHC.Real.:% n_sgAsz [Occ=Once] d_sgAsA [Occ=Once] ->
              case GHC.Float.rationalToDouble n_sgAsz d_sgAsA of dt_sgAsB {
                GHC.Types.D# _ [Occ=Dead] ->
                    Data.Complex.:+ [dt_sgAsB Data.Complex.$fFloatingComplex1];
              };
        };

Data.Complex.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.Rational -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAsD w1_sgAsE]
        case
            GHC.Float.$p1RealFloat w_sgAsD
        of
        $dRealFrac_sgAsF [Dmd=<S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A)>]
        { __DEFAULT ->
              case GHC.Real.$p2RealFrac $dRealFrac_sgAsF of sat_sgAsG {
                __DEFAULT ->
                    case GHC.Real.fromRational sat_sgAsG w1_sgAsE of dt_sgAsH {
                      __DEFAULT ->
                          case GHC.Real.$p1RealFrac $dRealFrac_sgAsF of sat_sgAsI {
                            __DEFAULT ->
                                case GHC.Real.$p1Real sat_sgAsI of sat_sgAsJ {
                                  __DEFAULT ->
                                      case
                                          GHC.Num.fromInteger
                                              sat_sgAsJ Data.Complex.$fFloatingComplex17
                                      of
                                      dt1_sgAsK
                                      { __DEFAULT -> (#,#) [dt_sgAsH dt1_sgAsK];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFractionalComplex_$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.Rational -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgAsL w1_sgAsM]
        case Data.Complex.$w$cfromRational w_sgAsL w1_sgAsM of {
          (#,#) ww1_sgAsO [Occ=Once] ww2_sgAsP [Occ=Once] ->
              Data.Complex.:+ [ww1_sgAsO ww2_sgAsP];
        };

Data.Complex.$fFloatingComplex_$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAsQ w1_sgAsR]
        case w_sgAsQ of {
          Data.Complex.:+ ww1_sgAsT [Occ=Once!] ww2_sgAsU [Occ=Once!] ->
              case ww1_sgAsT of {
                GHC.Types.D# ww4_sgAsW [Occ=Once] ->
                    case ww2_sgAsU of {
                      GHC.Types.D# ww6_sgAsY [Occ=Once] ->
                          case w1_sgAsR of {
                            Data.Complex.:+ ww8_sgAt0 [Occ=Once!] ww9_sgAt1 [Occ=Once!] ->
                                case ww8_sgAt0 of {
                                  GHC.Types.D# ww11_sgAt3 [Occ=Once] ->
                                      case ww9_sgAt1 of {
                                        GHC.Types.D# ww13_sgAt5 [Occ=Once] ->
                                            case +## [ww6_sgAsY ww13_sgAt5] of sat_sgAt8 {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAt9 [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [sat_sgAt8];
                                                  } in 
                                                    case +## [ww4_sgAsW ww11_sgAt3] of sat_sgAt6 {
                                                      __DEFAULT ->
                                                          let {
                                                            sat_sgAt7 [Occ=Once] :: GHC.Types.Double
                                                            [LclId] =
                                                                CCCS GHC.Types.D#! [sat_sgAt6];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgAt7 sat_sgAt9];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))LLLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAta ww_sgAtb ww1_sgAtc ww2_sgAtd ww3_sgAte]
        case
            GHC.Float.$p1RealFloat w_sgAta
        of
        $dRealFrac_sgAtf [Dmd=<S(S(S(C(C(S))LLLLLL)LL)LLLLLL),1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAtf
              of
              $dReal_sgAtg [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAtg
                    of
                    $dNum_sgAth [Dmd=<S(C(C(S))LLLLLL),U(C(C1(U)),A,A,A,A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.+ $dNum_sgAth ww_sgAtb ww2_sgAtd of dt_sgAti {
                            __DEFAULT ->
                                case GHC.Num.+ $dNum_sgAth ww1_sgAtc ww3_sgAte of dt1_sgAtj {
                                  __DEFAULT -> (#,#) [dt_sgAti dt1_sgAtj];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))LLLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAtk w1_sgAtl w2_sgAtm]
        case w1_sgAtl of {
          Data.Complex.:+ ww1_sgAto [Occ=Once] ww2_sgAtp [Occ=Once] ->
              case w2_sgAtm of {
                Data.Complex.:+ ww4_sgAtr [Occ=Once] ww5_sgAts [Occ=Once] ->
                    case
                        Data.Complex.$w$c+ w_sgAtk ww1_sgAto ww2_sgAtp ww4_sgAtr ww5_sgAts
                    of
                    { (#,#) ww7_sgAtu [Occ=Once] ww8_sgAtv [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgAtu ww8_sgAtv];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c- [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAtw w1_sgAtx]
        case w_sgAtw of {
          Data.Complex.:+ ww1_sgAtz [Occ=Once!] ww2_sgAtA [Occ=Once!] ->
              case ww1_sgAtz of {
                GHC.Types.D# ww4_sgAtC [Occ=Once] ->
                    case ww2_sgAtA of {
                      GHC.Types.D# ww6_sgAtE [Occ=Once] ->
                          case w1_sgAtx of {
                            Data.Complex.:+ ww8_sgAtG [Occ=Once!] ww9_sgAtH [Occ=Once!] ->
                                case ww8_sgAtG of {
                                  GHC.Types.D# ww11_sgAtJ [Occ=Once] ->
                                      case ww9_sgAtH of {
                                        GHC.Types.D# ww13_sgAtL [Occ=Once] ->
                                            case -## [ww6_sgAtE ww13_sgAtL] of sat_sgAtO {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAtP [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [sat_sgAtO];
                                                  } in 
                                                    case -## [ww4_sgAtC ww11_sgAtJ] of sat_sgAtM {
                                                      __DEFAULT ->
                                                          let {
                                                            sat_sgAtN [Occ=Once] :: GHC.Types.Double
                                                            [LclId] =
                                                                CCCS GHC.Types.D#! [sat_sgAtM];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgAtN sat_sgAtP];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAtQ ww_sgAtR ww1_sgAtS ww2_sgAtT ww3_sgAtU]
        case
            GHC.Float.$p1RealFloat w_sgAtQ
        of
        $dRealFrac_sgAtV [Dmd=<S(S(S(LC(C(S))LLLLL)LL)LLLLLL),1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAtV
              of
              $dReal_sgAtW [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAtW
                    of
                    $dNum_sgAtX [Dmd=<S(LC(C(S))LLLLL),U(A,C(C1(U)),A,A,A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.- $dNum_sgAtX ww_sgAtR ww2_sgAtT of dt_sgAtY {
                            __DEFAULT ->
                                case GHC.Num.- $dNum_sgAtX ww1_sgAtS ww3_sgAtU of dt1_sgAtZ {
                                  __DEFAULT -> (#,#) [dt_sgAtY dt1_sgAtZ];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAu0 w1_sgAu1 w2_sgAu2]
        case w1_sgAu1 of {
          Data.Complex.:+ ww1_sgAu4 [Occ=Once] ww2_sgAu5 [Occ=Once] ->
              case w2_sgAu2 of {
                Data.Complex.:+ ww4_sgAu7 [Occ=Once] ww5_sgAu8 [Occ=Once] ->
                    case
                        Data.Complex.$w$c- w_sgAu0 ww1_sgAu4 ww2_sgAu5 ww4_sgAu7 ww5_sgAu8
                    of
                    { (#,#) ww7_sgAua [Occ=Once] ww8_sgAub [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgAua ww8_sgAub];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c* [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAuc w1_sgAud]
        case w_sgAuc of {
          Data.Complex.:+ ww1_sgAuf [Occ=Once!] ww2_sgAug [Occ=Once!] ->
              case ww1_sgAuf of {
                GHC.Types.D# ww4_sgAui ->
                    case ww2_sgAug of {
                      GHC.Types.D# ww6_sgAuk ->
                          case w1_sgAud of {
                            Data.Complex.:+ ww8_sgAum [Occ=Once!] ww9_sgAun [Occ=Once!] ->
                                case ww8_sgAum of {
                                  GHC.Types.D# ww11_sgAup ->
                                      case ww9_sgAun of {
                                        GHC.Types.D# ww13_sgAur ->
                                            case *## [ww6_sgAuk ww11_sgAup] of sat_sgAux {
                                              __DEFAULT ->
                                                  case *## [ww4_sgAui ww13_sgAur] of sat_sgAuw {
                                                    __DEFAULT ->
                                                        case
                                                            +## [sat_sgAuw sat_sgAux]
                                                        of
                                                        sat_sgAuy
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_sgAuz [Occ=Once]
                                                                  :: GHC.Types.Double
                                                                [LclId] =
                                                                    CCCS GHC.Types.D#! [sat_sgAuy];
                                                              } in 
                                                                case
                                                                    *## [ww6_sgAuk ww13_sgAur]
                                                                of
                                                                sat_sgAut
                                                                { __DEFAULT ->
                                                                      case
                                                                          *## [ww4_sgAui ww11_sgAup]
                                                                      of
                                                                      sat_sgAus
                                                                      { __DEFAULT ->
                                                                            case
                                                                                -## [sat_sgAus
                                                                                     sat_sgAut]
                                                                            of
                                                                            sat_sgAuu
                                                                            { __DEFAULT ->
                                                                                  let {
                                                                                    sat_sgAuv [Occ=Once]
                                                                                      :: GHC.Types.Double
                                                                                    [LclId] =
                                                                                        CCCS GHC.Types.D#! [sat_sgAuu];
                                                                                  } in 
                                                                                    Data.Complex.:+ [sat_sgAuv
                                                                                                     sat_sgAuz];
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAuA ww_sgAuB ww1_sgAuC ww2_sgAuD ww3_sgAuE]
        case
            GHC.Float.$p1RealFloat w_sgAuA
        of
        $dRealFrac_sgAuF [Dmd=<S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL),1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAuF
              of
              $dReal_sgAuG [Dmd=<S(S(C(C(S))C(C(S))LLLLL)LL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAuG
                    of
                    $dNum_sgAuH [Dmd=<S(C(C(S))C(C(S))LLLLL),U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            sat_sgAuJ [Occ=Once] :: a_sgxDl
                            [LclId] =
                                [ww1_sgAuC ww3_sgAuE $dNum_sgAuH] \u []
                                    GHC.Num.* $dNum_sgAuH ww1_sgAuC ww3_sgAuE; } in
                          let {
                            sat_sgAuI [Occ=Once] :: a_sgxDl
                            [LclId] =
                                [ww_sgAuB ww2_sgAuD $dNum_sgAuH] \u []
                                    GHC.Num.* $dNum_sgAuH ww_sgAuB ww2_sgAuD;
                          } in 
                            case GHC.Num.- $dNum_sgAuH sat_sgAuI sat_sgAuJ of dt_sgAuK {
                              __DEFAULT ->
                                  let {
                                    sat_sgAuM [Occ=Once] :: a_sgxDl
                                    [LclId] =
                                        [ww1_sgAuC ww2_sgAuD $dNum_sgAuH] \u []
                                            GHC.Num.* $dNum_sgAuH ww1_sgAuC ww2_sgAuD; } in
                                  let {
                                    sat_sgAuL [Occ=Once] :: a_sgxDl
                                    [LclId] =
                                        [ww_sgAuB ww3_sgAuE $dNum_sgAuH] \u []
                                            GHC.Num.* $dNum_sgAuH ww_sgAuB ww3_sgAuE;
                                  } in 
                                    case GHC.Num.+ $dNum_sgAuH sat_sgAuL sat_sgAuM of dt1_sgAuN {
                                      __DEFAULT -> (#,#) [dt_sgAuK dt1_sgAuN];
                                    };
                            };
                    };
              };
        };

Data.Complex.$fNumComplex_$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAuO w1_sgAuP w2_sgAuQ]
        case w1_sgAuP of {
          Data.Complex.:+ ww1_sgAuS [Occ=Once] ww2_sgAuT [Occ=Once] ->
              case w2_sgAuQ of {
                Data.Complex.:+ ww4_sgAuV [Occ=Once] ww5_sgAuW [Occ=Once] ->
                    case
                        Data.Complex.$w$c* w_sgAuO ww1_sgAuS ww2_sgAuT ww4_sgAuV ww5_sgAuW
                    of
                    { (#,#) ww7_sgAuY [Occ=Once] ww8_sgAuZ [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgAuY ww8_sgAuZ];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cnegate
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgAv0]
        case ds_sgAv0 of {
          Data.Complex.:+ x_sgAv2 [Occ=Once!] y_sgAv3 [Occ=Once!] ->
              case x_sgAv2 of {
                GHC.Types.D# x1_sgAv5 [Occ=Once] ->
                    case y_sgAv3 of {
                      GHC.Types.D# x2_sgAv7 [Occ=Once] ->
                          case negateDouble# [x2_sgAv7] of sat_sgAva {
                            __DEFAULT ->
                                let {
                                  sat_sgAvb [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [sat_sgAva];
                                } in 
                                  case negateDouble# [x1_sgAv5] of sat_sgAv8 {
                                    __DEFAULT ->
                                        let {
                                          sat_sgAv9 [Occ=Once] :: GHC.Types.Double
                                          [LclId] =
                                              CCCS GHC.Types.D#! [sat_sgAv8];
                                        } in  Data.Complex.:+ [sat_sgAv9 sat_sgAvb];
                                  };
                          };
                    };
              };
        };

Data.Complex.$w$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLLC(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAvc ww_sgAvd ww1_sgAve]
        case
            GHC.Float.$p1RealFloat w_sgAvc
        of
        $dRealFrac_sgAvf [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAvf
              of
              $dReal_sgAvg [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAvg
                    of
                    $dNum_sgAvh [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.negate $dNum_sgAvh ww_sgAvd of dt_sgAvi {
                            __DEFAULT ->
                                case GHC.Num.negate $dNum_sgAvh ww1_sgAve of dt1_sgAvj {
                                  __DEFAULT -> (#,#) [dt_sgAvi dt1_sgAvj];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLLC(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAvk w1_sgAvl]
        case w1_sgAvl of {
          Data.Complex.:+ ww1_sgAvn [Occ=Once] ww2_sgAvo [Occ=Once] ->
              case Data.Complex.$w$cnegate w_sgAvk ww1_sgAvn ww2_sgAvo of {
                (#,#) ww4_sgAvq [Occ=Once] ww5_sgAvr [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAvq ww5_sgAvr];
              };
        };

Data.Complex.$fFloatingComplex_$s$cabs
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [z_sgAvs]
        case z_sgAvs of {
          Data.Complex.:+ ww1_sgAvu [Occ=Once!] ww2_sgAvv [Occ=Once!] ->
              case ww1_sgAvu of {
                GHC.Types.D# ww4_sgAvx [Occ=Once] ->
                    case ww2_sgAvv of {
                      GHC.Types.D# ww6_sgAvz [Occ=Once] ->
                          case Data.Complex.$w$smagnitude ww4_sgAvx ww6_sgAvz of ww7_sgAvA {
                            __DEFAULT ->
                                let {
                                  sat_sgAvB [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [ww7_sgAvA];
                                } in  Data.Complex.:+ [sat_sgAvB Data.Complex.$fFloatingComplex1];
                          };
                    };
              };
        };

Data.Complex.$w$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,1*C1(U)),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAvC ww_sgAvD ww1_sgAvE]
        case
            Data.Complex.$wmagnitude w_sgAvC ww_sgAvD ww1_sgAvE
        of
        dt_sgAvF
        { __DEFAULT ->
              case GHC.Float.$p1RealFloat w_sgAvC of sat_sgAvG {
                __DEFAULT ->
                    case GHC.Real.$p1RealFrac sat_sgAvG of sat_sgAvH {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_sgAvH of sat_sgAvI {
                            __DEFAULT ->
                                case
                                    GHC.Num.fromInteger sat_sgAvI Data.Complex.$fFloatingComplex17
                                of
                                dt1_sgAvJ
                                { __DEFAULT -> (#,#) [dt_sgAvF dt1_sgAvJ];
                                };
                          };
                    };
              };
        };

Data.Complex.$fNumComplex_$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAvK w1_sgAvL]
        case w1_sgAvL of {
          Data.Complex.:+ ww1_sgAvN [Occ=Once] ww2_sgAvO [Occ=Once] ->
              case Data.Complex.$w$cabs w_sgAvK ww1_sgAvN ww2_sgAvO of {
                (#,#) ww4_sgAvQ [Occ=Once] ww5_sgAvR [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAvQ ww5_sgAvR];
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromInteger
  :: GHC.Integer.Type.Integer
     -> Data.Complex.Complex GHC.Types.Double
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [n_sgAvS]
        case GHC.Integer.Type.doubleFromInteger n_sgAvS of wild_sgAvT {
          __DEFAULT ->
              let {
                sat_sgAvU [Occ=Once] :: GHC.Types.Double
                [LclId] =
                    CCCS GHC.Types.D#! [wild_sgAvT];
              } in  Data.Complex.:+ [sat_sgAvU Data.Complex.$fFloatingComplex1];
        };

Data.Complex.$w$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Integer.Type.Integer -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAvV w1_sgAvW]
        case
            GHC.Float.$p1RealFloat w_sgAvV
        of
        $dRealFrac_sgAvX [Dmd=<S(S(S(LLLLLLC(S))LL)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAvX
              of
              $dReal_sgAvY [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAvY
                    of
                    $dNum_sgAvZ [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
                    { __DEFAULT ->
                          case GHC.Num.fromInteger $dNum_sgAvZ w1_sgAvW of dt_sgAw0 {
                            __DEFAULT ->
                                case
                                    GHC.Num.fromInteger $dNum_sgAvZ Data.Complex.$fFloatingComplex17
                                of
                                dt1_sgAw1
                                { __DEFAULT -> (#,#) [dt_sgAw0 dt1_sgAw1];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Integer.Type.Integer -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgAw2 w1_sgAw3]
        case Data.Complex.$w$cfromInteger w_sgAw2 w1_sgAw3 of {
          (#,#) ww1_sgAw5 [Occ=Once] ww2_sgAw6 [Occ=Once] ->
              Data.Complex.:+ [ww1_sgAw5 ww2_sgAw6];
        };

Data.Complex.$fFloatingComplex4
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex1
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$fFloatingComplex_$s$csignum [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAw7]
        case w_sgAw7 of {
          Data.Complex.:+ ww1_sgAw9 [Occ=Once!] ww2_sgAwa [Occ=Once!] ->
              case ww1_sgAw9 of {
                GHC.Types.D# ww4_sgAwc ->
                    case ww2_sgAwa of {
                      GHC.Types.D# ww6_sgAwe ->
                          case ==## [ww4_sgAwc 0.0##] of {
                            __DEFAULT ->
                                case Data.Complex.$w$smagnitude ww4_sgAwc ww6_sgAwe of ww7_sgAwg {
                                  __DEFAULT ->
                                      case /## [ww4_sgAwc ww7_sgAwg] of wild2_sgAwh {
                                        __DEFAULT ->
                                            case /## [ww6_sgAwe ww7_sgAwg] of wild1_sgAwi {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAwk [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [wild1_sgAwi]; } in
                                                  let {
                                                    sat_sgAwj [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [wild2_sgAwh];
                                                  } in  Data.Complex.:+ [sat_sgAwj sat_sgAwk];
                                            };
                                      };
                                };
                            1# ->
                                case ==## [ww6_sgAwe 0.0##] of {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$smagnitude ww4_sgAwc ww6_sgAwe
                                      of
                                      ww7_sgAwm
                                      { __DEFAULT ->
                                            case /## [ww4_sgAwc ww7_sgAwm] of wild2_sgAwn {
                                              __DEFAULT ->
                                                  case /## [ww6_sgAwe ww7_sgAwm] of wild1_sgAwo {
                                                    __DEFAULT ->
                                                        let {
                                                          sat_sgAwq [Occ=Once] :: GHC.Types.Double
                                                          [LclId] =
                                                              CCCS GHC.Types.D#! [wild1_sgAwo]; } in
                                                        let {
                                                          sat_sgAwp [Occ=Once] :: GHC.Types.Double
                                                          [LclId] =
                                                              CCCS GHC.Types.D#! [wild2_sgAwn];
                                                        } in  Data.Complex.:+ [sat_sgAwp sat_sgAwq];
                                                  };
                                            };
                                      };
                                  1# -> Data.Complex.$fFloatingComplex4;
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex12
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex9
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$fFloatingComplex_$s$csignum1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAwr]
        case w_sgAwr of {
          Data.Complex.:+ ww1_sgAwt [Occ=Once!] ww2_sgAwu [Occ=Once!] ->
              case ww1_sgAwt of {
                GHC.Types.F# ww4_sgAww ->
                    case ww2_sgAwu of {
                      GHC.Types.F# ww6_sgAwy ->
                          case eqFloat# [ww4_sgAww 0.0#] of {
                            __DEFAULT ->
                                case Data.Complex.$w$smagnitude1 ww4_sgAww ww6_sgAwy of ww7_sgAwA {
                                  __DEFAULT ->
                                      case divideFloat# [ww4_sgAww ww7_sgAwA] of wild2_sgAwB {
                                        __DEFAULT ->
                                            case divideFloat# [ww6_sgAwy ww7_sgAwA] of wild1_sgAwC {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgAwE [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [wild1_sgAwC]; } in
                                                  let {
                                                    sat_sgAwD [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [wild2_sgAwB];
                                                  } in  Data.Complex.:+ [sat_sgAwD sat_sgAwE];
                                            };
                                      };
                                };
                            1# ->
                                case eqFloat# [ww6_sgAwy 0.0#] of {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$smagnitude1 ww4_sgAww ww6_sgAwy
                                      of
                                      ww7_sgAwG
                                      { __DEFAULT ->
                                            case divideFloat# [ww4_sgAww ww7_sgAwG] of wild2_sgAwH {
                                              __DEFAULT ->
                                                  case
                                                      divideFloat# [ww6_sgAwy ww7_sgAwG]
                                                  of
                                                  wild1_sgAwI
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_sgAwK [Occ=Once] :: GHC.Types.Float
                                                          [LclId] =
                                                              CCCS GHC.Types.F#! [wild1_sgAwI]; } in
                                                        let {
                                                          sat_sgAwJ [Occ=Once] :: GHC.Types.Float
                                                          [LclId] =
                                                              CCCS GHC.Types.F#! [wild2_sgAwH];
                                                        } in  Data.Complex.:+ [sat_sgAwJ sat_sgAwK];
                                                  };
                                            };
                                      };
                                  1# -> Data.Complex.$fFloatingComplex12;
                                };
                          };
                    };
              };
        };

Data.Complex.$w$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAwL ww_sgAwM ww1_sgAwN]
        case
            GHC.Float.$p1RealFloat w_sgAwL
        of
        $dRealFrac_sgAwO [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAwO
              of
              $dReal_sgAwP [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      $dNum_sgAwQ [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_sgxEJ
                      [LclId] =
                          [$dReal_sgAwP] \u [] GHC.Real.$p1Real $dReal_sgAwP;
                    } in 
                      case
                          GHC.Real.$p2Real $dReal_sgAwP
                      of
                      $dOrd_sgAwR [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                      { __DEFAULT ->
                            case
                                GHC.Classes.$p1Ord $dOrd_sgAwR
                            of
                            $dEq_sgAwS [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                            { __DEFAULT ->
                                  let {
                                    sat_sgAwZ [Occ=Once] :: a_sgxEJ
                                    [LclId] =
                                        [$dNum_sgAwQ] \u []
                                            GHC.Num.fromInteger
                                                $dNum_sgAwQ Data.Complex.$fFloatingComplex17;
                                  } in 
                                    let-no-escape {
                                      fail_sgAwT [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> (# a_sgxEJ, a_sgxEJ #)
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [w_sgAwL
                                                    ww_sgAwM
                                                    ww1_sgAwN
                                                    $dRealFrac_sgAwO] \r [void_0E]
                                              case
                                                  GHC.Real.$p2RealFrac $dRealFrac_sgAwO
                                              of
                                              $dFractional_sgAwV [Dmd=<S(LC(C(S))LL),U(A,C(C1(U)),A,A)>]
                                              { __DEFAULT ->
                                                    let {
                                                      r_sgAwW :: a_sgxEJ
                                                      [LclId] =
                                                          [w_sgAwL ww_sgAwM ww1_sgAwN] \u []
                                                              Data.Complex.$wmagnitude
                                                                  w_sgAwL ww_sgAwM ww1_sgAwN;
                                                    } in 
                                                      case
                                                          GHC.Real./
                                                              $dFractional_sgAwV ww_sgAwM r_sgAwW
                                                      of
                                                      dt_sgAwX
                                                      { __DEFAULT ->
                                                            case
                                                                GHC.Real./
                                                                    $dFractional_sgAwV
                                                                    ww1_sgAwN
                                                                    r_sgAwW
                                                            of
                                                            dt1_sgAwY
                                                            { __DEFAULT ->
                                                                  (#,#) [dt_sgAwX dt1_sgAwY];
                                                            };
                                                      };
                                              };
                                    } in 
                                      case GHC.Classes.== $dEq_sgAwS ww_sgAwM sat_sgAwZ of {
                                        GHC.Types.False -> fail_sgAwT GHC.Prim.void#;
                                        GHC.Types.True ->
                                            let {
                                              sat_sgAx1 [Occ=Once] :: a_sgxEJ
                                              [LclId] =
                                                  [$dNum_sgAwQ] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_sgAwQ
                                                          Data.Complex.$fFloatingComplex17;
                                            } in 
                                              case
                                                  GHC.Classes.== $dEq_sgAwS ww1_sgAwN sat_sgAx1
                                              of
                                              { GHC.Types.False -> fail_sgAwT GHC.Prim.void#;
                                                GHC.Types.True ->
                                                    Data.Complex.$w$cfromInteger
                                                        w_sgAwL Data.Complex.$fFloatingComplex17;
                                              };
                                      };
                            };
                      };
              };
        };

Data.Complex.$fNumComplex_$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAx3 w1_sgAx4]
        case w1_sgAx4 of {
          Data.Complex.:+ ww1_sgAx6 [Occ=Once] ww2_sgAx7 [Occ=Once] ->
              case Data.Complex.$w$csignum w_sgAx3 ww1_sgAx6 ww2_sgAx7 of {
                (#,#) ww4_sgAx9 [Occ=Once] ww5_sgAxa [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAx9 ww5_sgAxa];
              };
        };

Data.Complex.$fFloatingComplex_$s$fNumComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Num.Num (Data.Complex.Complex GHC.Types.Double)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Num.C:Num! [Data.Complex.$fFloatingComplex_$s$c+
                                  Data.Complex.$fFloatingComplex_$s$c-
                                  Data.Complex.$fFloatingComplex_$s$c*
                                  Data.Complex.$fFloatingComplex_$s$cnegate
                                  Data.Complex.$fFloatingComplex_$s$cabs
                                  Data.Complex.$fFloatingComplex_$s$csignum
                                  Data.Complex.$fFloatingComplex_$s$cfromInteger];

Data.Complex.$fFloatingComplex_$s$fNumComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Num.Num (Data.Complex.Complex GHC.Types.Float)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Num.C:Num! [Data.Complex.$fFloatingComplex_$s$c+1
                                  Data.Complex.$fFloatingComplex_$s$c-1
                                  Data.Complex.$fFloatingComplex_$s$c*1
                                  Data.Complex.$fFloatingComplex_$s$cnegate1
                                  Data.Complex.$fFloatingComplex_$s$cabs1
                                  Data.Complex.$fFloatingComplex_$s$csignum1
                                  Data.Complex.$fFloatingComplex_$s$cfromInteger1];

Data.Complex.$fNumComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Num.Num (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dRealFloat_sgAxb]
        let {
          sat_sgAxi [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cfromInteger
                      $dRealFloat_sgAxb eta_B1; } in
        let {
          sat_sgAxh [Occ=Once]
            :: Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B1]
                  Data.Complex.$fNumComplex_$csignum $dRealFloat_sgAxb eta_B1; } in
        let {
          sat_sgAxg [Occ=Once]
            :: Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B1]
                  Data.Complex.$fNumComplex_$cabs $dRealFloat_sgAxb eta_B1; } in
        let {
          sat_sgAxf [Occ=Once]
            :: Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cnegate
                      $dRealFloat_sgAxb eta_B1; } in
        let {
          sat_sgAxe [Occ=Once]
            :: Data.Complex.Complex a_agt1x
               -> Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B2 eta_B1]
                  Data.Complex.$fNumComplex_$c* $dRealFloat_sgAxb eta_B2 eta_B1; } in
        let {
          sat_sgAxd [Occ=Once]
            :: Data.Complex.Complex a_agt1x
               -> Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c-
                      $dRealFloat_sgAxb eta_B2 eta_B1; } in
        let {
          sat_sgAxc [Occ=Once]
            :: Data.Complex.Complex a_agt1x
               -> Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgAxb] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c+ $dRealFloat_sgAxb eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [sat_sgAxc
                         sat_sgAxd
                         sat_sgAxe
                         sat_sgAxf
                         sat_sgAxg
                         sat_sgAxh
                         sat_sgAxi];

Data.Complex.$w$s$csqrt1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAxj ww1_sgAxk]
        let-no-escape {
          fail_sgAxl [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> (# GHC.Types.Float, GHC.Types.Float #)
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [ww_sgAxj ww1_sgAxk] \r [void_0E]
                  case ltFloat# [ww_sgAxj 0.0#] of {
                    __DEFAULT ->
                        case Data.Complex.$w$smagnitude1 ww_sgAxj ww1_sgAxk of ww2_sgAxo {
                          __DEFAULT ->
                              case fabsFloat# [ww_sgAxj] of sat_sgAxq {
                                __DEFAULT ->
                                    case plusFloat# [ww2_sgAxo sat_sgAxq] of sat_sgAxr {
                                      __DEFAULT ->
                                          case divideFloat# [sat_sgAxr 2.0#] of sat_sgAxs {
                                            __DEFAULT ->
                                                case
                                                    sqrtFloat# [sat_sgAxs]
                                                of
                                                ipv_sgAxp [Dmd=<S,U>]
                                                { __DEFAULT ->
                                                      case ltFloat# [ww1_sgAxk 0.0#] of {
                                                        __DEFAULT ->
                                                            case
                                                                plusFloat# [ipv_sgAxp ipv_sgAxp]
                                                            of
                                                            sat_sgAxv
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsFloat# [ww1_sgAxk]
                                                                  of
                                                                  sat_sgAxu
                                                                  { __DEFAULT ->
                                                                        case
                                                                            divideFloat# [sat_sgAxu
                                                                                          sat_sgAxv]
                                                                        of
                                                                        wild2_sgAxw
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgAxy [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [wild2_sgAxw]; } in
                                                                              let {
                                                                                sat_sgAxx [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [ipv_sgAxp];
                                                                              } in 
                                                                                (#,#) [sat_sgAxx
                                                                                       sat_sgAxy];
                                                                        };
                                                                  };
                                                            };
                                                        1# ->
                                                            case
                                                                plusFloat# [ipv_sgAxp ipv_sgAxp]
                                                            of
                                                            sat_sgAxA
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsFloat# [ww1_sgAxk]
                                                                  of
                                                                  sat_sgAxz
                                                                  { __DEFAULT ->
                                                                        case
                                                                            divideFloat# [sat_sgAxz
                                                                                          sat_sgAxA]
                                                                        of
                                                                        wild2_sgAxB
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  negateFloat# [wild2_sgAxB]
                                                                              of
                                                                              sat_sgAxD
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgAxE [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [sat_sgAxD]; } in
                                                                                    let {
                                                                                      sat_sgAxC [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [ipv_sgAxp];
                                                                                    } in 
                                                                                      (#,#) [sat_sgAxC
                                                                                             sat_sgAxE];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                    1# ->
                        case Data.Complex.$w$smagnitude1 ww_sgAxj ww1_sgAxk of ww2_sgAxF {
                          __DEFAULT ->
                              case fabsFloat# [ww_sgAxj] of sat_sgAxH {
                                __DEFAULT ->
                                    case plusFloat# [ww2_sgAxF sat_sgAxH] of sat_sgAxI {
                                      __DEFAULT ->
                                          case divideFloat# [sat_sgAxI 2.0#] of sat_sgAxJ {
                                            __DEFAULT ->
                                                case sqrtFloat# [sat_sgAxJ] of x_sgAxG [Dmd=<S,U>] {
                                                  __DEFAULT ->
                                                      case
                                                          plusFloat# [x_sgAxG x_sgAxG]
                                                      of
                                                      sat_sgAxL
                                                      { __DEFAULT ->
                                                            case
                                                                fabsFloat# [ww1_sgAxk]
                                                            of
                                                            sat_sgAxK
                                                            { __DEFAULT ->
                                                                  case
                                                                      divideFloat# [sat_sgAxK
                                                                                    sat_sgAxL]
                                                                  of
                                                                  wild2_sgAxM
                                                                  { __DEFAULT ->
                                                                        case
                                                                            ltFloat# [ww1_sgAxk
                                                                                      0.0#]
                                                                        of
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgAxP [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [x_sgAxG]; } in
                                                                              let {
                                                                                sat_sgAxO [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [wild2_sgAxM];
                                                                              } in 
                                                                                (#,#) [sat_sgAxO
                                                                                       sat_sgAxP];
                                                                          1# ->
                                                                              case
                                                                                  negateFloat# [x_sgAxG]
                                                                              of
                                                                              sat_sgAxR
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgAxS [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [sat_sgAxR]; } in
                                                                                    let {
                                                                                      sat_sgAxQ [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [wild2_sgAxM];
                                                                                    } in 
                                                                                      (#,#) [sat_sgAxQ
                                                                                             sat_sgAxS];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case eqFloat# [ww_sgAxj 0.0#] of {
            __DEFAULT -> fail_sgAxl GHC.Prim.void#;
            1# ->
                case eqFloat# [ww1_sgAxk 0.0#] of {
                  __DEFAULT -> fail_sgAxl GHC.Prim.void#;
                  1# ->
                      (#,#) [Data.Complex.$fFloatingComplex9
                             Data.Complex.$fFloatingComplex9];
                };
          };

Data.Complex.$fFloatingComplex_$s$csqrt1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAxV]
        case w_sgAxV of {
          Data.Complex.:+ ww1_sgAxX [Occ=Once!] ww2_sgAxY [Occ=Once!] ->
              case ww1_sgAxX of {
                GHC.Types.F# ww4_sgAy0 [Occ=Once] ->
                    case ww2_sgAxY of {
                      GHC.Types.F# ww6_sgAy2 [Occ=Once] ->
                          case Data.Complex.$w$s$csqrt1 ww4_sgAy0 ww6_sgAy2 of {
                            (#,#) ww8_sgAy4 [Occ=Once] ww9_sgAy5 [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAy4 ww9_sgAy5];
                          };
                    };
              };
        };

Data.Complex.$w$s$csqrt [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAy6 ww1_sgAy7]
        let-no-escape {
          fail_sgAy8 [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> (# GHC.Types.Double, GHC.Types.Double #)
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [ww_sgAy6 ww1_sgAy7] \r [void_0E]
                  case <## [ww_sgAy6 0.0##] of {
                    __DEFAULT ->
                        case Data.Complex.$w$smagnitude ww_sgAy6 ww1_sgAy7 of ww2_sgAyb {
                          __DEFAULT ->
                              case fabsDouble# [ww_sgAy6] of sat_sgAyd {
                                __DEFAULT ->
                                    case +## [ww2_sgAyb sat_sgAyd] of sat_sgAye {
                                      __DEFAULT ->
                                          case /## [sat_sgAye 2.0##] of sat_sgAyf {
                                            __DEFAULT ->
                                                case
                                                    sqrtDouble# [sat_sgAyf]
                                                of
                                                ipv_sgAyc [Dmd=<S,U>]
                                                { __DEFAULT ->
                                                      case <## [ww1_sgAy7 0.0##] of {
                                                        __DEFAULT ->
                                                            case
                                                                +## [ipv_sgAyc ipv_sgAyc]
                                                            of
                                                            sat_sgAyi
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsDouble# [ww1_sgAy7]
                                                                  of
                                                                  sat_sgAyh
                                                                  { __DEFAULT ->
                                                                        case
                                                                            /## [sat_sgAyh
                                                                                 sat_sgAyi]
                                                                        of
                                                                        wild2_sgAyj
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgAyl [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [wild2_sgAyj]; } in
                                                                              let {
                                                                                sat_sgAyk [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [ipv_sgAyc];
                                                                              } in 
                                                                                (#,#) [sat_sgAyk
                                                                                       sat_sgAyl];
                                                                        };
                                                                  };
                                                            };
                                                        1# ->
                                                            case
                                                                +## [ipv_sgAyc ipv_sgAyc]
                                                            of
                                                            sat_sgAyn
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsDouble# [ww1_sgAy7]
                                                                  of
                                                                  sat_sgAym
                                                                  { __DEFAULT ->
                                                                        case
                                                                            /## [sat_sgAym
                                                                                 sat_sgAyn]
                                                                        of
                                                                        wild2_sgAyo
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  negateDouble# [wild2_sgAyo]
                                                                              of
                                                                              sat_sgAyq
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgAyr [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [sat_sgAyq]; } in
                                                                                    let {
                                                                                      sat_sgAyp [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [ipv_sgAyc];
                                                                                    } in 
                                                                                      (#,#) [sat_sgAyp
                                                                                             sat_sgAyr];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                    1# ->
                        case Data.Complex.$w$smagnitude ww_sgAy6 ww1_sgAy7 of ww2_sgAys {
                          __DEFAULT ->
                              case fabsDouble# [ww_sgAy6] of sat_sgAyu {
                                __DEFAULT ->
                                    case +## [ww2_sgAys sat_sgAyu] of sat_sgAyv {
                                      __DEFAULT ->
                                          case /## [sat_sgAyv 2.0##] of sat_sgAyw {
                                            __DEFAULT ->
                                                case
                                                    sqrtDouble# [sat_sgAyw]
                                                of
                                                x_sgAyt [Dmd=<S,U>]
                                                { __DEFAULT ->
                                                      case +## [x_sgAyt x_sgAyt] of sat_sgAyy {
                                                        __DEFAULT ->
                                                            case
                                                                fabsDouble# [ww1_sgAy7]
                                                            of
                                                            sat_sgAyx
                                                            { __DEFAULT ->
                                                                  case
                                                                      /## [sat_sgAyx sat_sgAyy]
                                                                  of
                                                                  wild2_sgAyz
                                                                  { __DEFAULT ->
                                                                        case
                                                                            <## [ww1_sgAy7 0.0##]
                                                                        of
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgAyC [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [x_sgAyt]; } in
                                                                              let {
                                                                                sat_sgAyB [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [wild2_sgAyz];
                                                                              } in 
                                                                                (#,#) [sat_sgAyB
                                                                                       sat_sgAyC];
                                                                          1# ->
                                                                              case
                                                                                  negateDouble# [x_sgAyt]
                                                                              of
                                                                              sat_sgAyE
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgAyF [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [sat_sgAyE]; } in
                                                                                    let {
                                                                                      sat_sgAyD [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [wild2_sgAyz];
                                                                                    } in 
                                                                                      (#,#) [sat_sgAyD
                                                                                             sat_sgAyF];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case ==## [ww_sgAy6 0.0##] of {
            __DEFAULT -> fail_sgAy8 GHC.Prim.void#;
            1# ->
                case ==## [ww1_sgAy7 0.0##] of {
                  __DEFAULT -> fail_sgAy8 GHC.Prim.void#;
                  1# ->
                      (#,#) [Data.Complex.$fFloatingComplex1
                             Data.Complex.$fFloatingComplex1];
                };
          };

Data.Complex.$fFloatingComplex_$s$csqrt [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAyI]
        case w_sgAyI of {
          Data.Complex.:+ ww1_sgAyK [Occ=Once!] ww2_sgAyL [Occ=Once!] ->
              case ww1_sgAyK of {
                GHC.Types.D# ww4_sgAyN [Occ=Once] ->
                    case ww2_sgAyL of {
                      GHC.Types.D# ww6_sgAyP [Occ=Once] ->
                          case Data.Complex.$w$s$csqrt ww4_sgAyN ww6_sgAyP of {
                            (#,#) ww8_sgAyR [Occ=Once] ww9_sgAyS [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAyR ww9_sgAyS];
                          };
                    };
              };
        };

sat_sgAyT :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_sgAyU :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgAyT GHC.Types.[]];

Data.Complex.$fFloatingComplex21 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgAyU;

Data.Complex.$w$csqrt [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAyV ww_sgAyW ww1_sgAyX]
        case
            GHC.Float.$p1RealFloat w_sgAyV
        of
        $dRealFrac_sgAyY [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAyY
              of
              $dReal_sgAyZ [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p2Real $dReal_sgAyZ
                    of
                    $dOrd_sgAz0 [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dNum_sgAz1 [Dmd=<L,U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U))>]
                              :: GHC.Num.Num a_sgxFA
                            [LclId] =
                                [$dReal_sgAyZ] \u [] GHC.Real.$p1Real $dReal_sgAyZ;
                          } in 
                            case
                                GHC.Classes.$p1Ord $dOrd_sgAz0
                            of
                            $dEq_sgAz2 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                            { __DEFAULT ->
                                  let {
                                    sat_sgAzr [Occ=Once] :: a_sgxFA
                                    [LclId] =
                                        [$dNum_sgAz1] \u []
                                            GHC.Num.fromInteger
                                                $dNum_sgAz1 Data.Complex.$fFloatingComplex17;
                                  } in 
                                    let-no-escape {
                                      fail_sgAz3 [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> (# a_sgxFA, a_sgxFA #)
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [w_sgAyV
                                                    ww_sgAyW
                                                    ww1_sgAyX
                                                    $dRealFrac_sgAyY
                                                    $dOrd_sgAz0
                                                    $dNum_sgAz1] \r [void_0E]
                                              let {
                                                $dFractional_sgAz5 [Dmd=<L,U(A,C(C1(U)),A,A)>]
                                                  :: GHC.Real.Fractional a_sgxFA
                                                [LclId] =
                                                    [$dRealFrac_sgAyY] \u []
                                                        GHC.Real.$p2RealFrac $dRealFrac_sgAyY; } in
                                              let {
                                                u'_sgAz6 :: a_sgxFA
                                                [LclId] =
                                                    [w_sgAyV
                                                     ww_sgAyW
                                                     ww1_sgAyX
                                                     $dNum_sgAz1
                                                     $dFractional_sgAz5] \u []
                                                        let {
                                                          sat_sgAzc [Occ=Once] :: a_sgxFA
                                                          [LclId] =
                                                              [w_sgAyV
                                                               ww_sgAyW
                                                               ww1_sgAyX
                                                               $dNum_sgAz1
                                                               $dFractional_sgAz5] \u []
                                                                  let {
                                                                    sat_sgAzb [Occ=Once] :: a_sgxFA
                                                                    [LclId] =
                                                                        [$dNum_sgAz1] \u []
                                                                            GHC.Num.fromInteger
                                                                                $dNum_sgAz1
                                                                                Data.Complex.$fFloatingComplex21; } in
                                                                  let {
                                                                    sat_sgAza [Occ=Once] :: a_sgxFA
                                                                    [LclId] =
                                                                        [w_sgAyV
                                                                         ww_sgAyW
                                                                         ww1_sgAyX
                                                                         $dNum_sgAz1] \u []
                                                                            let {
                                                                              sat_sgAz9 [Occ=Once]
                                                                                :: a_sgxFA
                                                                              [LclId] =
                                                                                  [ww_sgAyW
                                                                                   $dNum_sgAz1] \u []
                                                                                      GHC.Num.abs
                                                                                          $dNum_sgAz1
                                                                                          ww_sgAyW; } in
                                                                            let {
                                                                              sat_sgAz8 [Occ=Once]
                                                                                :: a_sgxFA
                                                                              [LclId] =
                                                                                  [w_sgAyV
                                                                                   ww_sgAyW
                                                                                   ww1_sgAyX] \u []
                                                                                      Data.Complex.$wmagnitude
                                                                                          w_sgAyV
                                                                                          ww_sgAyW
                                                                                          ww1_sgAyX;
                                                                            } in 
                                                                              GHC.Num.+
                                                                                  $dNum_sgAz1
                                                                                  sat_sgAz8
                                                                                  sat_sgAz9;
                                                                  } in 
                                                                    GHC.Real./
                                                                        $dFractional_sgAz5
                                                                        sat_sgAza
                                                                        sat_sgAzb;
                                                        } in 
                                                          case
                                                              GHC.Float.$p2RealFloat w_sgAyV
                                                          of
                                                          sat_sgAz7
                                                          { __DEFAULT ->
                                                                GHC.Float.sqrt sat_sgAz7 sat_sgAzc;
                                                          }; } in
                                              let {
                                                v'_sgAzd [Occ=Once*] :: a_sgxFA
                                                [LclId] =
                                                    [ww1_sgAyX
                                                     $dNum_sgAz1
                                                     $dFractional_sgAz5
                                                     u'_sgAz6] \u []
                                                        let {
                                                          sat_sgAzg [Occ=Once] :: a_sgxFA
                                                          [LclId] =
                                                              [$dNum_sgAz1 u'_sgAz6] \u []
                                                                  let {
                                                                    sat_sgAzf [Occ=Once] :: a_sgxFA
                                                                    [LclId] =
                                                                        [$dNum_sgAz1] \u []
                                                                            GHC.Num.fromInteger
                                                                                $dNum_sgAz1
                                                                                Data.Complex.$fFloatingComplex21;
                                                                  } in 
                                                                    GHC.Num.*
                                                                        $dNum_sgAz1
                                                                        u'_sgAz6
                                                                        sat_sgAzf; } in
                                                        let {
                                                          sat_sgAze [Occ=Once] :: a_sgxFA
                                                          [LclId] =
                                                              [ww1_sgAyX $dNum_sgAz1] \u []
                                                                  GHC.Num.abs $dNum_sgAz1 ww1_sgAyX;
                                                        } in 
                                                          GHC.Real./
                                                              $dFractional_sgAz5
                                                              sat_sgAze
                                                              sat_sgAzg; } in
                                              let {
                                                sat_sgAzp [Occ=Once] :: a_sgxFA
                                                [LclId] =
                                                    [$dNum_sgAz1] \u []
                                                        GHC.Num.fromInteger
                                                            $dNum_sgAz1
                                                            Data.Complex.$fFloatingComplex17;
                                              } in 
                                                let-no-escape {
                                                  $j_sgAzh [Occ=Once*!T[2],
                                                            Dmd=<C(C(S)),1*C1(C1(U(U,U)))>]
                                                    :: a_sgxFA -> a_sgxFA -> (# a_sgxFA, a_sgxFA #)
                                                  [LclId[JoinId(2)],
                                                   Arity=2,
                                                   Str=<S,1*U><L,U>,
                                                   Unf=OtherCon []] =
                                                      sat-only [ww1_sgAyX
                                                                $dOrd_sgAz0
                                                                $dNum_sgAz1] \r [u_sgAzi v_sgAzj]
                                                          case u_sgAzi of dt_sgAzk {
                                                            __DEFAULT ->
                                                                let {
                                                                  sat_sgAzl [Occ=Once] :: a_sgxFA
                                                                  [LclId] =
                                                                      [$dNum_sgAz1] \u []
                                                                          GHC.Num.fromInteger
                                                                              $dNum_sgAz1
                                                                              Data.Complex.$fFloatingComplex17;
                                                                } in 
                                                                  case
                                                                      GHC.Classes.<
                                                                          $dOrd_sgAz0
                                                                          ww1_sgAyX
                                                                          sat_sgAzl
                                                                  of
                                                                  { GHC.Types.False ->
                                                                        case v_sgAzj of dt1_sgAzn {
                                                                          __DEFAULT ->
                                                                              (#,#) [dt_sgAzk
                                                                                     dt1_sgAzn];
                                                                        };
                                                                    GHC.Types.True ->
                                                                        case
                                                                            GHC.Num.negate
                                                                                $dNum_sgAz1 v_sgAzj
                                                                        of
                                                                        dt1_sgAzo
                                                                        { __DEFAULT ->
                                                                              (#,#) [dt_sgAzk
                                                                                     dt1_sgAzo];
                                                                        };
                                                                  };
                                                          };
                                                } in 
                                                  case
                                                      GHC.Classes.< $dOrd_sgAz0 ww_sgAyW sat_sgAzp
                                                  of
                                                  { GHC.Types.False -> $j_sgAzh u'_sgAz6 v'_sgAzd;
                                                    GHC.Types.True -> $j_sgAzh v'_sgAzd u'_sgAz6;
                                                  };
                                    } in 
                                      case GHC.Classes.== $dEq_sgAz2 ww_sgAyW sat_sgAzr of {
                                        GHC.Types.False -> fail_sgAz3 GHC.Prim.void#;
                                        GHC.Types.True ->
                                            let {
                                              sat_sgAzt [Occ=Once] :: a_sgxFA
                                              [LclId] =
                                                  [$dNum_sgAz1] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_sgAz1
                                                          Data.Complex.$fFloatingComplex17;
                                            } in 
                                              case
                                                  GHC.Classes.== $dEq_sgAz2 ww1_sgAyX sat_sgAzt
                                              of
                                              { GHC.Types.False -> fail_sgAz3 GHC.Prim.void#;
                                                GHC.Types.True ->
                                                    Data.Complex.$w$cfromInteger
                                                        w_sgAyV Data.Complex.$fFloatingComplex17;
                                              };
                                      };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$csqrt [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAzv w1_sgAzw]
        case w1_sgAzw of {
          Data.Complex.:+ ww1_sgAzy [Occ=Once] ww2_sgAzz [Occ=Once] ->
              case Data.Complex.$w$csqrt w_sgAzv ww1_sgAzy ww2_sgAzz of {
                (#,#) ww4_sgAzB [Occ=Once] ww5_sgAzC [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAzB ww5_sgAzC];
              };
        };

Data.Complex.$fFloatingComplex_$s$crecip [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAzD]
        case eta_sgAzD of {
          Data.Complex.:+ ww1_sgAzF [Occ=Once!] ww2_sgAzG [Occ=Once!] ->
              case ww1_sgAzF of {
                GHC.Types.D# ww4_sgAzI [Occ=Once] ->
                    case ww2_sgAzG of {
                      GHC.Types.D# ww6_sgAzK [Occ=Once] ->
                          case Data.Complex.$w$s$c/ 1.0## 0.0## ww4_sgAzI ww6_sgAzK of {
                            (#,#) ww8_sgAzM [Occ=Once] ww9_sgAzN [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAzM ww9_sgAzN];
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$crecip1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAzO]
        case eta_sgAzO of {
          Data.Complex.:+ ww1_sgAzQ [Occ=Once!] ww2_sgAzR [Occ=Once!] ->
              case ww1_sgAzQ of {
                GHC.Types.F# ww4_sgAzT [Occ=Once] ->
                    case ww2_sgAzR of {
                      GHC.Types.F# ww6_sgAzV [Occ=Once] ->
                          case Data.Complex.$w$s$c/1 1.0# 0.0# ww4_sgAzT ww6_sgAzV of {
                            (#,#) ww8_sgAzX [Occ=Once] ww9_sgAzY [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAzX ww9_sgAzY];
                          };
                    };
              };
        };

sat_sgAzZ :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sgAA0 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgAzZ GHC.Types.[]];

Data.Complex.$fFloatingComplex19 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgAA0;

Data.Complex.$fFractionalComplex_$crecip [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgAA1 eta_sgAA2]
        case
            Data.Complex.$w$cfromInteger
                $dRealFloat_sgAA1 Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww1_sgAA4 [Occ=Once] ww2_sgAA5 [Occ=Once] ->
              case eta_sgAA2 of {
                Data.Complex.:+ ww4_sgAA7 [Occ=Once] ww5_sgAA8 [Occ=Once] ->
                    case
                        Data.Complex.$w$c/
                            $dRealFloat_sgAA1 ww1_sgAA4 ww2_sgAA5 ww4_sgAA7 ww5_sgAA8
                    of
                    { (#,#) ww7_sgAAa [Occ=Once] ww8_sgAAb [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgAAa ww8_sgAAb];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$fFractionalComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Fractional (Data.Complex.Complex GHC.Types.Double)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Fractional! [Data.Complex.$fFloatingComplex_$s$fNumComplex
                                          Data.Complex.$fFloatingComplex_$s$c/
                                          Data.Complex.$fFloatingComplex_$s$crecip
                                          Data.Complex.$fFloatingComplex_$s$cfromRational];

Data.Complex.$fFloatingComplex_$s$fFractionalComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Fractional (Data.Complex.Complex GHC.Types.Float)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Fractional! [Data.Complex.$fFloatingComplex_$s$fNumComplex1
                                          Data.Complex.$fFloatingComplex_$s$c/1
                                          Data.Complex.$fFloatingComplex_$s$crecip1
                                          Data.Complex.$fFloatingComplex_$s$cfromRational1];

Data.Complex.$fFractionalComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.Fractional (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dRealFloat_sgAAc]
        let {
          sat_sgAAg [Occ=Once]
            :: GHC.Real.Rational -> Data.Complex.Complex a_agsZS
          [LclId] =
              [$dRealFloat_sgAAc] \r [eta_B1]
                  Data.Complex.$fFractionalComplex_$cfromRational
                      $dRealFloat_sgAAc eta_B1; } in
        let {
          sat_sgAAf [Occ=Once]
            :: Data.Complex.Complex a_agsZS -> Data.Complex.Complex a_agsZS
          [LclId] =
              [$dRealFloat_sgAAc] \r [eta_B1]
                  Data.Complex.$fFractionalComplex_$crecip
                      $dRealFloat_sgAAc eta_B1; } in
        let {
          sat_sgAAe [Occ=Once]
            :: Data.Complex.Complex a_agsZS
               -> Data.Complex.Complex a_agsZS -> Data.Complex.Complex a_agsZS
          [LclId] =
              [$dRealFloat_sgAAc] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c/
                      $dRealFloat_sgAAc eta_B2 eta_B1; } in
        let {
          sat_sgAAd [Occ=Once] :: GHC.Num.Num (Data.Complex.Complex a_agsZS)
          [LclId] =
              [$dRealFloat_sgAAc] \u []
                  Data.Complex.$fNumComplex $dRealFloat_sgAAc;
        } in 
          GHC.Real.C:Fractional [sat_sgAAd sat_sgAAe sat_sgAAf sat_sgAAg];

Data.Complex.$fFloatingComplex_$s$ctan1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAAh]
        case w_sgAAh of {
          Data.Complex.:+ ww1_sgAAj [Occ=Once!] ww2_sgAAk [Occ=Once!] ->
              case ww1_sgAAj of {
                GHC.Types.F# ww4_sgAAm ->
                    case ww2_sgAAk of {
                      GHC.Types.F# ww6_sgAAo ->
                          case coshFloat# [ww6_sgAAo] of coshy_sgAAp [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhFloat# [ww6_sgAAo] of sinhy_sgAAq [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosFloat# [ww4_sgAAm] of cosx_sgAAr [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinFloat# [ww4_sgAAm] of sinx_sgAAs [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [sinx_sgAAs sinhy_sgAAq]
                                                  of
                                                  sat_sgAAw
                                                  { __DEFAULT ->
                                                        case negateFloat# [sat_sgAAw] of sat_sgAAx {
                                                          __DEFAULT ->
                                                              case
                                                                  timesFloat# [cosx_sgAAr
                                                                               coshy_sgAAp]
                                                              of
                                                              sat_sgAAv
                                                              { __DEFAULT ->
                                                                    case
                                                                        timesFloat# [cosx_sgAAr
                                                                                     sinhy_sgAAq]
                                                                    of
                                                                    sat_sgAAu
                                                                    { __DEFAULT ->
                                                                          case
                                                                              timesFloat# [sinx_sgAAs
                                                                                           coshy_sgAAp]
                                                                          of
                                                                          sat_sgAAt
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/1
                                                                                        sat_sgAAt
                                                                                        sat_sgAAu
                                                                                        sat_sgAAv
                                                                                        sat_sgAAx
                                                                                of
                                                                                { (#,#) ww8_sgAAz [Occ=Once]
                                                                                        ww9_sgAAA [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww8_sgAAz
                                                                                                       ww9_sgAAA];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ctan [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAAB]
        case w_sgAAB of {
          Data.Complex.:+ ww1_sgAAD [Occ=Once!] ww2_sgAAE [Occ=Once!] ->
              case ww1_sgAAD of {
                GHC.Types.D# ww4_sgAAG ->
                    case ww2_sgAAE of {
                      GHC.Types.D# ww6_sgAAI ->
                          case coshDouble# [ww6_sgAAI] of coshy_sgAAJ [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhDouble# [ww6_sgAAI] of sinhy_sgAAK [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosDouble# [ww4_sgAAG] of cosx_sgAAL [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinDouble# [ww4_sgAAG] of sinx_sgAAM [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case *## [sinx_sgAAM sinhy_sgAAK] of sat_sgAAQ {
                                                    __DEFAULT ->
                                                        case
                                                            negateDouble# [sat_sgAAQ]
                                                        of
                                                        sat_sgAAR
                                                        { __DEFAULT ->
                                                              case
                                                                  *## [cosx_sgAAL coshy_sgAAJ]
                                                              of
                                                              sat_sgAAP
                                                              { __DEFAULT ->
                                                                    case
                                                                        *## [cosx_sgAAL sinhy_sgAAK]
                                                                    of
                                                                    sat_sgAAO
                                                                    { __DEFAULT ->
                                                                          case
                                                                              *## [sinx_sgAAM
                                                                                   coshy_sgAAJ]
                                                                          of
                                                                          sat_sgAAN
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/
                                                                                        sat_sgAAN
                                                                                        sat_sgAAO
                                                                                        sat_sgAAP
                                                                                        sat_sgAAR
                                                                                of
                                                                                { (#,#) ww8_sgAAT [Occ=Once]
                                                                                        ww9_sgAAU [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww8_sgAAT
                                                                                                       ww9_sgAAU];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ctan [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),1*C1(U),A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAAV ww_sgAAW ww1_sgAAX]
        case
            GHC.Float.$p1RealFloat w_sgAAV
        of
        $dRealFrac_sgAAY [Dmd=<S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAAY
              of
              $dReal_sgAAZ [Dmd=<S(S(LLC(C(S))C(S)LLL)LL),1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAAZ
                    of
                    $dNum_sgAB0 [Dmd=<S(LLC(C(S))C(S)LLL),U(A,A,C(C1(U)),1*C1(U),A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dFloating_sgAB1 [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
                              :: GHC.Float.Floating a_sgxGm
                            [LclId] =
                                [w_sgAAV] \u [] GHC.Float.$p2RealFloat w_sgAAV; } in
                          let {
                            coshy_sgAB2 :: a_sgxGm
                            [LclId] =
                                [ww1_sgAAX $dFloating_sgAB1] \u []
                                    GHC.Float.cosh $dFloating_sgAB1 ww1_sgAAX; } in
                          let {
                            sinx_sgAB3 :: a_sgxGm
                            [LclId] =
                                [ww_sgAAW $dFloating_sgAB1] \u []
                                    GHC.Float.sin $dFloating_sgAB1 ww_sgAAW;
                          } in 
                            case GHC.Num.* $dNum_sgAB0 sinx_sgAB3 coshy_sgAB2 of dt_sgAB4 {
                              __DEFAULT ->
                                  let {
                                    sinhy_sgAB5 :: a_sgxGm
                                    [LclId] =
                                        [ww1_sgAAX $dFloating_sgAB1] \u []
                                            GHC.Float.sinh $dFloating_sgAB1 ww1_sgAAX; } in
                                  let {
                                    cosx_sgAB6 :: a_sgxGm
                                    [LclId] =
                                        [ww_sgAAW $dFloating_sgAB1] \u []
                                            GHC.Float.cos $dFloating_sgAB1 ww_sgAAW;
                                  } in 
                                    case GHC.Num.* $dNum_sgAB0 cosx_sgAB6 sinhy_sgAB5 of dt1_sgAB7 {
                                      __DEFAULT ->
                                          case
                                              GHC.Num.* $dNum_sgAB0 cosx_sgAB6 coshy_sgAB2
                                          of
                                          dt2_sgAB8
                                          { __DEFAULT ->
                                                let {
                                                  sat_sgAB9 [Occ=Once] :: a_sgxGm
                                                  [LclId] =
                                                      [$dNum_sgAB0 sinx_sgAB3 sinhy_sgAB5] \u []
                                                          GHC.Num.*
                                                              $dNum_sgAB0 sinx_sgAB3 sinhy_sgAB5;
                                                } in 
                                                  case
                                                      GHC.Num.negate $dNum_sgAB0 sat_sgAB9
                                                  of
                                                  dt3_sgABa
                                                  { __DEFAULT ->
                                                        Data.Complex.$w$c/
                                                            w_sgAAV
                                                            dt_sgAB4
                                                            dt1_sgAB7
                                                            dt2_sgAB8
                                                            dt3_sgABa;
                                                  };
                                          };
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$ctan [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgABb w1_sgABc]
        case w1_sgABc of {
          Data.Complex.:+ ww1_sgABe [Occ=Once] ww2_sgABf [Occ=Once] ->
              case Data.Complex.$w$ctan w_sgABb ww1_sgABe ww2_sgABf of {
                (#,#) ww4_sgABh [Occ=Once] ww5_sgABi [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgABh ww5_sgABi];
              };
        };

Data.Complex.$fFloatingComplex_$s$ctanh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgABj]
        case w_sgABj of {
          Data.Complex.:+ ww1_sgABl [Occ=Once!] ww2_sgABm [Occ=Once!] ->
              case ww1_sgABl of {
                GHC.Types.F# ww4_sgABo ->
                    case ww2_sgABm of {
                      GHC.Types.F# ww6_sgABq ->
                          case coshFloat# [ww4_sgABo] of coshx_sgABr [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhFloat# [ww4_sgABo] of sinhx_sgABs [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosFloat# [ww6_sgABq] of cosy_sgABt [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinFloat# [ww6_sgABq] of siny_sgABu [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [siny_sgABu sinhx_sgABs]
                                                  of
                                                  sat_sgABy
                                                  { __DEFAULT ->
                                                        case
                                                            timesFloat# [cosy_sgABt coshx_sgABr]
                                                        of
                                                        sat_sgABx
                                                        { __DEFAULT ->
                                                              case
                                                                  timesFloat# [siny_sgABu
                                                                               coshx_sgABr]
                                                              of
                                                              sat_sgABw
                                                              { __DEFAULT ->
                                                                    case
                                                                        timesFloat# [cosy_sgABt
                                                                                     sinhx_sgABs]
                                                                    of
                                                                    sat_sgABv
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/1
                                                                                  sat_sgABv
                                                                                  sat_sgABw
                                                                                  sat_sgABx
                                                                                  sat_sgABy
                                                                          of
                                                                          { (#,#) ww8_sgABA [Occ=Once]
                                                                                  ww9_sgABB [Occ=Once] ->
                                                                                Data.Complex.:+ [ww8_sgABA
                                                                                                 ww9_sgABB];
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ctanh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgABC]
        case w_sgABC of {
          Data.Complex.:+ ww1_sgABE [Occ=Once!] ww2_sgABF [Occ=Once!] ->
              case ww1_sgABE of {
                GHC.Types.D# ww4_sgABH ->
                    case ww2_sgABF of {
                      GHC.Types.D# ww6_sgABJ ->
                          case coshDouble# [ww4_sgABH] of coshx_sgABK [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhDouble# [ww4_sgABH] of sinhx_sgABL [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosDouble# [ww6_sgABJ] of cosy_sgABM [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinDouble# [ww6_sgABJ] of siny_sgABN [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case *## [siny_sgABN sinhx_sgABL] of sat_sgABR {
                                                    __DEFAULT ->
                                                        case
                                                            *## [cosy_sgABM coshx_sgABK]
                                                        of
                                                        sat_sgABQ
                                                        { __DEFAULT ->
                                                              case
                                                                  *## [siny_sgABN coshx_sgABK]
                                                              of
                                                              sat_sgABP
                                                              { __DEFAULT ->
                                                                    case
                                                                        *## [cosy_sgABM sinhx_sgABL]
                                                                    of
                                                                    sat_sgABO
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/
                                                                                  sat_sgABO
                                                                                  sat_sgABP
                                                                                  sat_sgABQ
                                                                                  sat_sgABR
                                                                          of
                                                                          { (#,#) ww8_sgABT [Occ=Once]
                                                                                  ww9_sgABU [Occ=Once] ->
                                                                                Data.Complex.:+ [ww8_sgABT
                                                                                                 ww9_sgABU];
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ctanh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgABV ww_sgABW ww1_sgABX]
        case
            GHC.Float.$p1RealFloat w_sgABV
        of
        $dRealFrac_sgABY [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgABY
              of
              $dReal_sgABZ [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgABZ
                    of
                    $dNum_sgAC0 [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dFloating_sgAC1 [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
                              :: GHC.Float.Floating a_sgxH8
                            [LclId] =
                                [w_sgABV] \u [] GHC.Float.$p2RealFloat w_sgABV; } in
                          let {
                            sinhx_sgAC2 :: a_sgxH8
                            [LclId] =
                                [ww_sgABW $dFloating_sgAC1] \u []
                                    GHC.Float.sinh $dFloating_sgAC1 ww_sgABW; } in
                          let {
                            cosy_sgAC3 :: a_sgxH8
                            [LclId] =
                                [ww1_sgABX $dFloating_sgAC1] \u []
                                    GHC.Float.cos $dFloating_sgAC1 ww1_sgABX;
                          } in 
                            case GHC.Num.* $dNum_sgAC0 cosy_sgAC3 sinhx_sgAC2 of dt_sgAC4 {
                              __DEFAULT ->
                                  let {
                                    coshx_sgAC5 :: a_sgxH8
                                    [LclId] =
                                        [ww_sgABW $dFloating_sgAC1] \u []
                                            GHC.Float.cosh $dFloating_sgAC1 ww_sgABW; } in
                                  let {
                                    siny_sgAC6 :: a_sgxH8
                                    [LclId] =
                                        [ww1_sgABX $dFloating_sgAC1] \u []
                                            GHC.Float.sin $dFloating_sgAC1 ww1_sgABX;
                                  } in 
                                    case GHC.Num.* $dNum_sgAC0 siny_sgAC6 coshx_sgAC5 of dt1_sgAC7 {
                                      __DEFAULT ->
                                          case
                                              GHC.Num.* $dNum_sgAC0 cosy_sgAC3 coshx_sgAC5
                                          of
                                          dt2_sgAC8
                                          { __DEFAULT ->
                                                case
                                                    GHC.Num.* $dNum_sgAC0 siny_sgAC6 sinhx_sgAC2
                                                of
                                                dt3_sgAC9
                                                { __DEFAULT ->
                                                      Data.Complex.$w$c/
                                                          w_sgABV
                                                          dt_sgAC4
                                                          dt1_sgAC7
                                                          dt2_sgAC8
                                                          dt3_sgAC9;
                                                };
                                          };
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$ctanh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgACa w1_sgACb]
        case w1_sgACb of {
          Data.Complex.:+ ww1_sgACd [Occ=Once] ww2_sgACe [Occ=Once] ->
              case Data.Complex.$w$ctanh w_sgACa ww1_sgACd ww2_sgACe of {
                (#,#) ww4_sgACg [Occ=Once] ww5_sgACh [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgACg ww5_sgACh];
              };
        };

Data.Complex.$w$s$cacosh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgACi ww1_sgACj]
        case plusFloat# [ww_sgACi 1.0#] of sat_sgACk {
          __DEFAULT ->
              case Data.Complex.$w$s$csqrt1 sat_sgACk ww1_sgACj of {
                (#,#) ww3_sgACm [Occ=Once!] ww4_sgACn [Occ=Once!] ->
                    case ww4_sgACn of {
                      GHC.Types.F# x_sgACp ->
                          case ww3_sgACm of {
                            GHC.Types.F# x1_sgACr ->
                                case minusFloat# [ww_sgACi 1.0#] of sat_sgACs {
                                  __DEFAULT ->
                                      case Data.Complex.$w$s$csqrt1 sat_sgACs ww1_sgACj of {
                                        (#,#) ww6_sgACu [Occ=Once!] ww7_sgACv [Occ=Once!] ->
                                            case ww7_sgACv of {
                                              GHC.Types.F# y_sgACx ->
                                                  case ww6_sgACu of {
                                                    GHC.Types.F# y1_sgACz ->
                                                        case
                                                            timesFloat# [x_sgACp y1_sgACz]
                                                        of
                                                        sat_sgACC
                                                        { __DEFAULT ->
                                                              case
                                                                  timesFloat# [x1_sgACr y_sgACx]
                                                              of
                                                              sat_sgACB
                                                              { __DEFAULT ->
                                                                    case
                                                                        plusFloat# [sat_sgACB
                                                                                    sat_sgACC]
                                                                    of
                                                                    sat_sgACD
                                                                    { __DEFAULT ->
                                                                          case
                                                                              plusFloat# [ww1_sgACj
                                                                                          sat_sgACD]
                                                                          of
                                                                          ww8_sgACA [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    timesFloat# [x_sgACp
                                                                                                 y_sgACx]
                                                                                of
                                                                                sat_sgACG
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          timesFloat# [x1_sgACr
                                                                                                       y1_sgACz]
                                                                                      of
                                                                                      sat_sgACF
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                minusFloat# [sat_sgACF
                                                                                                             sat_sgACG]
                                                                                            of
                                                                                            sat_sgACH
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      plusFloat# [ww_sgACi
                                                                                                                  sat_sgACH]
                                                                                                  of
                                                                                                  ww9_sgACE [Dmd=<S,U>]
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$smagnitude1
                                                                                                                ww9_sgACE
                                                                                                                ww8_sgACA
                                                                                                        of
                                                                                                        ww10_sgACI
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  logFloat# [ww10_sgACI]
                                                                                                              of
                                                                                                              wild4_sgACJ
                                                                                                              { __DEFAULT ->
                                                                                                                    case
                                                                                                                        Data.Complex.$w$sphase1
                                                                                                                            ww9_sgACE
                                                                                                                            ww8_sgACA
                                                                                                                    of
                                                                                                                    ww11_sgACK
                                                                                                                    { __DEFAULT ->
                                                                                                                          let {
                                                                                                                            sat_sgACM [Occ=Once]
                                                                                                                              :: GHC.Types.Float
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.F#! [ww11_sgACK]; } in
                                                                                                                          let {
                                                                                                                            sat_sgACL [Occ=Once]
                                                                                                                              :: GHC.Types.Float
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.F#! [wild4_sgACJ];
                                                                                                                          } in 
                                                                                                                            (#,#) [sat_sgACL
                                                                                                                                   sat_sgACM];
                                                                                                                    };
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacosh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgACN]
        case w_sgACN of {
          Data.Complex.:+ ww1_sgACP [Occ=Once!] ww2_sgACQ [Occ=Once!] ->
              case ww1_sgACP of {
                GHC.Types.F# ww4_sgACS [Occ=Once] ->
                    case ww2_sgACQ of {
                      GHC.Types.F# ww6_sgACU [Occ=Once] ->
                          case Data.Complex.$w$s$cacosh1 ww4_sgACS ww6_sgACU of {
                            (#,#) ww8_sgACW [Occ=Once] ww9_sgACX [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgACW ww9_sgACX];
                          };
                    };
              };
        };

Data.Complex.$w$s$cacosh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgACY ww1_sgACZ]
        case +## [ww_sgACY 1.0##] of sat_sgAD0 {
          __DEFAULT ->
              case Data.Complex.$w$s$csqrt sat_sgAD0 ww1_sgACZ of {
                (#,#) ww3_sgAD2 [Occ=Once!] ww4_sgAD3 [Occ=Once!] ->
                    case ww4_sgAD3 of {
                      GHC.Types.D# x_sgAD5 ->
                          case ww3_sgAD2 of {
                            GHC.Types.D# x1_sgAD7 ->
                                case -## [ww_sgACY 1.0##] of sat_sgAD8 {
                                  __DEFAULT ->
                                      case Data.Complex.$w$s$csqrt sat_sgAD8 ww1_sgACZ of {
                                        (#,#) ww6_sgADa [Occ=Once!] ww7_sgADb [Occ=Once!] ->
                                            case ww7_sgADb of {
                                              GHC.Types.D# y_sgADd ->
                                                  case ww6_sgADa of {
                                                    GHC.Types.D# y1_sgADf ->
                                                        case *## [x_sgAD5 y1_sgADf] of sat_sgADi {
                                                          __DEFAULT ->
                                                              case
                                                                  *## [x1_sgAD7 y_sgADd]
                                                              of
                                                              sat_sgADh
                                                              { __DEFAULT ->
                                                                    case
                                                                        +## [sat_sgADh sat_sgADi]
                                                                    of
                                                                    sat_sgADj
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +## [ww1_sgACZ
                                                                                   sat_sgADj]
                                                                          of
                                                                          ww8_sgADg [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    *## [x_sgAD5
                                                                                         y_sgADd]
                                                                                of
                                                                                sat_sgADm
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          *## [x1_sgAD7
                                                                                               y1_sgADf]
                                                                                      of
                                                                                      sat_sgADl
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                -## [sat_sgADl
                                                                                                     sat_sgADm]
                                                                                            of
                                                                                            sat_sgADn
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      +## [ww_sgACY
                                                                                                           sat_sgADn]
                                                                                                  of
                                                                                                  ww9_sgADk [Dmd=<S,U>]
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$smagnitude
                                                                                                                ww9_sgADk
                                                                                                                ww8_sgADg
                                                                                                        of
                                                                                                        ww10_sgADo
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  logDouble# [ww10_sgADo]
                                                                                                              of
                                                                                                              wild4_sgADp
                                                                                                              { __DEFAULT ->
                                                                                                                    case
                                                                                                                        Data.Complex.$w$sphase
                                                                                                                            ww9_sgADk
                                                                                                                            ww8_sgADg
                                                                                                                    of
                                                                                                                    ww11_sgADq
                                                                                                                    { __DEFAULT ->
                                                                                                                          let {
                                                                                                                            sat_sgADs [Occ=Once]
                                                                                                                              :: GHC.Types.Double
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.D#! [ww11_sgADq]; } in
                                                                                                                          let {
                                                                                                                            sat_sgADr [Occ=Once]
                                                                                                                              :: GHC.Types.Double
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.D#! [wild4_sgADp];
                                                                                                                          } in 
                                                                                                                            (#,#) [sat_sgADr
                                                                                                                                   sat_sgADs];
                                                                                                                    };
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacosh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgADt]
        case w_sgADt of {
          Data.Complex.:+ ww1_sgADv [Occ=Once!] ww2_sgADw [Occ=Once!] ->
              case ww1_sgADv of {
                GHC.Types.D# ww4_sgADy [Occ=Once] ->
                    case ww2_sgADw of {
                      GHC.Types.D# ww6_sgADA [Occ=Once] ->
                          case Data.Complex.$w$s$cacosh ww4_sgADy ww6_sgADA of {
                            (#,#) ww8_sgADC [Occ=Once] ww9_sgADD [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgADC ww9_sgADD];
                          };
                    };
              };
        };

Data.Complex.$w$cacosh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgADE ww_sgADF ww1_sgADG]
        case
            Data.Complex.$w$cfromInteger
                w_sgADE Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww3_sgADI ww4_sgADJ ->
              case
                  Data.Complex.$w$c+ w_sgADE ww_sgADF ww1_sgADG ww3_sgADI ww4_sgADJ
              of
              { (#,#) ww6_sgADL [Occ=Once] ww7_sgADM [Occ=Once] ->
                    case Data.Complex.$w$csqrt w_sgADE ww6_sgADL ww7_sgADM of {
                      (#,#) ww9_sgADO [Occ=Once] ww10_sgADP [Occ=Once] ->
                          case
                              Data.Complex.$w$c- w_sgADE ww_sgADF ww1_sgADG ww3_sgADI ww4_sgADJ
                          of
                          { (#,#) ww12_sgADR [Occ=Once] ww13_sgADS [Occ=Once] ->
                                case Data.Complex.$w$csqrt w_sgADE ww12_sgADR ww13_sgADS of {
                                  (#,#) ww15_sgADU [Occ=Once] ww16_sgADV [Occ=Once] ->
                                      case
                                          Data.Complex.$w$c*
                                              w_sgADE ww9_sgADO ww10_sgADP ww15_sgADU ww16_sgADV
                                      of
                                      { (#,#) ww18_sgADX [Occ=Once] ww19_sgADY [Occ=Once] ->
                                            case
                                                Data.Complex.$w$c+
                                                    w_sgADE ww_sgADF ww1_sgADG ww18_sgADX ww19_sgADY
                                            of
                                            { (#,#) ww21_sgAE0 [Occ=Once] ww22_sgAE1 [Occ=Once] ->
                                                  Data.Complex.$w$clog
                                                      w_sgADE ww21_sgAE0 ww22_sgAE1;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cacosh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAE2 w1_sgAE3]
        case w1_sgAE3 of {
          Data.Complex.:+ ww1_sgAE5 [Occ=Once] ww2_sgAE6 [Occ=Once] ->
              case Data.Complex.$w$cacosh w_sgAE2 ww1_sgAE5 ww2_sgAE6 of {
                (#,#) ww4_sgAE8 [Occ=Once] ww5_sgAE9 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAE8 ww5_sgAE9];
              };
        };

Data.Complex.$w$s$casinh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAEa ww1_sgAEb]
        case timesFloat# [ww1_sgAEb ww_sgAEa] of sat_sgAEh {
          __DEFAULT ->
              case timesFloat# [ww_sgAEa ww1_sgAEb] of sat_sgAEg {
                __DEFAULT ->
                    case plusFloat# [sat_sgAEg sat_sgAEh] of sat_sgAEi {
                      __DEFAULT ->
                          case timesFloat# [ww1_sgAEb ww1_sgAEb] of sat_sgAEd {
                            __DEFAULT ->
                                case timesFloat# [ww_sgAEa ww_sgAEa] of sat_sgAEc {
                                  __DEFAULT ->
                                      case minusFloat# [sat_sgAEc sat_sgAEd] of sat_sgAEe {
                                        __DEFAULT ->
                                            case plusFloat# [1.0# sat_sgAEe] of sat_sgAEf {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt1 sat_sgAEf sat_sgAEi
                                                  of
                                                  { (#,#) ww3_sgAEk [Occ=Once!]
                                                          ww4_sgAEl [Occ=Once!] ->
                                                        case ww3_sgAEk of {
                                                          GHC.Types.F# y_sgAEn [Occ=Once] ->
                                                              case ww4_sgAEl of {
                                                                GHC.Types.F# y1_sgAEp [Occ=Once] ->
                                                                    case
                                                                        plusFloat# [ww1_sgAEb
                                                                                    y1_sgAEp]
                                                                    of
                                                                    ww5_sgAEq [Dmd=<S,U>]
                                                                    { __DEFAULT ->
                                                                          case
                                                                              plusFloat# [ww_sgAEa
                                                                                          y_sgAEn]
                                                                          of
                                                                          ww6_sgAEr [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$smagnitude1
                                                                                        ww6_sgAEr
                                                                                        ww5_sgAEq
                                                                                of
                                                                                ww7_sgAEs
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          logFloat# [ww7_sgAEs]
                                                                                      of
                                                                                      wild3_sgAEt
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$sphase1
                                                                                                    ww6_sgAEr
                                                                                                    ww5_sgAEq
                                                                                            of
                                                                                            ww8_sgAEu
                                                                                            { __DEFAULT ->
                                                                                                  let {
                                                                                                    sat_sgAEw [Occ=Once]
                                                                                                      :: GHC.Types.Float
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.F#! [ww8_sgAEu]; } in
                                                                                                  let {
                                                                                                    sat_sgAEv [Occ=Once]
                                                                                                      :: GHC.Types.Float
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.F#! [wild3_sgAEt];
                                                                                                  } in 
                                                                                                    (#,#) [sat_sgAEv
                                                                                                           sat_sgAEw];
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casinh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAEx]
        case w_sgAEx of {
          Data.Complex.:+ ww1_sgAEz [Occ=Once!] ww2_sgAEA [Occ=Once!] ->
              case ww1_sgAEz of {
                GHC.Types.F# ww4_sgAEC [Occ=Once] ->
                    case ww2_sgAEA of {
                      GHC.Types.F# ww6_sgAEE [Occ=Once] ->
                          case Data.Complex.$w$s$casinh1 ww4_sgAEC ww6_sgAEE of {
                            (#,#) ww8_sgAEG [Occ=Once] ww9_sgAEH [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAEG ww9_sgAEH];
                          };
                    };
              };
        };

Data.Complex.$w$s$casinh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAEI ww1_sgAEJ]
        case *## [ww1_sgAEJ ww_sgAEI] of sat_sgAEP {
          __DEFAULT ->
              case *## [ww_sgAEI ww1_sgAEJ] of sat_sgAEO {
                __DEFAULT ->
                    case +## [sat_sgAEO sat_sgAEP] of sat_sgAEQ {
                      __DEFAULT ->
                          case *## [ww1_sgAEJ ww1_sgAEJ] of sat_sgAEL {
                            __DEFAULT ->
                                case *## [ww_sgAEI ww_sgAEI] of sat_sgAEK {
                                  __DEFAULT ->
                                      case -## [sat_sgAEK sat_sgAEL] of sat_sgAEM {
                                        __DEFAULT ->
                                            case +## [1.0## sat_sgAEM] of sat_sgAEN {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt sat_sgAEN sat_sgAEQ
                                                  of
                                                  { (#,#) ww3_sgAES [Occ=Once!]
                                                          ww4_sgAET [Occ=Once!] ->
                                                        case ww3_sgAES of {
                                                          GHC.Types.D# y_sgAEV [Occ=Once] ->
                                                              case ww4_sgAET of {
                                                                GHC.Types.D# y1_sgAEX [Occ=Once] ->
                                                                    case
                                                                        +## [ww1_sgAEJ y1_sgAEX]
                                                                    of
                                                                    ww5_sgAEY [Dmd=<S,U>]
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +## [ww_sgAEI y_sgAEV]
                                                                          of
                                                                          ww6_sgAEZ [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$smagnitude
                                                                                        ww6_sgAEZ
                                                                                        ww5_sgAEY
                                                                                of
                                                                                ww7_sgAF0
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          logDouble# [ww7_sgAF0]
                                                                                      of
                                                                                      wild3_sgAF1
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$sphase
                                                                                                    ww6_sgAEZ
                                                                                                    ww5_sgAEY
                                                                                            of
                                                                                            ww8_sgAF2
                                                                                            { __DEFAULT ->
                                                                                                  let {
                                                                                                    sat_sgAF4 [Occ=Once]
                                                                                                      :: GHC.Types.Double
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.D#! [ww8_sgAF2]; } in
                                                                                                  let {
                                                                                                    sat_sgAF3 [Occ=Once]
                                                                                                      :: GHC.Types.Double
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.D#! [wild3_sgAF1];
                                                                                                  } in 
                                                                                                    (#,#) [sat_sgAF3
                                                                                                           sat_sgAF4];
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casinh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAF5]
        case w_sgAF5 of {
          Data.Complex.:+ ww1_sgAF7 [Occ=Once!] ww2_sgAF8 [Occ=Once!] ->
              case ww1_sgAF7 of {
                GHC.Types.D# ww4_sgAFa [Occ=Once] ->
                    case ww2_sgAF8 of {
                      GHC.Types.D# ww6_sgAFc [Occ=Once] ->
                          case Data.Complex.$w$s$casinh ww4_sgAFa ww6_sgAFc of {
                            (#,#) ww8_sgAFe [Occ=Once] ww9_sgAFf [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAFe ww9_sgAFf];
                          };
                    };
              };
        };

Data.Complex.$w$casinh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),1*C1(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAFg ww_sgAFh ww1_sgAFi]
        case
            Data.Complex.$w$cfromInteger
                w_sgAFg Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww3_sgAFk [Occ=Once] ww4_sgAFl [Occ=Once] ->
              case
                  Data.Complex.$w$c* w_sgAFg ww_sgAFh ww1_sgAFi ww_sgAFh ww1_sgAFi
              of
              { (#,#) ww6_sgAFn [Occ=Once] ww7_sgAFo [Occ=Once] ->
                    case
                        Data.Complex.$w$c+ w_sgAFg ww3_sgAFk ww4_sgAFl ww6_sgAFn ww7_sgAFo
                    of
                    { (#,#) ww9_sgAFq [Occ=Once] ww10_sgAFr [Occ=Once] ->
                          case Data.Complex.$w$csqrt w_sgAFg ww9_sgAFq ww10_sgAFr of {
                            (#,#) ww12_sgAFt [Occ=Once] ww13_sgAFu [Occ=Once] ->
                                case
                                    Data.Complex.$w$c+
                                        w_sgAFg ww_sgAFh ww1_sgAFi ww12_sgAFt ww13_sgAFu
                                of
                                { (#,#) ww15_sgAFw [Occ=Once] ww16_sgAFx [Occ=Once] ->
                                      Data.Complex.$w$clog w_sgAFg ww15_sgAFw ww16_sgAFx;
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$casinh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAFy w1_sgAFz]
        case w1_sgAFz of {
          Data.Complex.:+ ww1_sgAFB [Occ=Once] ww2_sgAFC [Occ=Once] ->
              case Data.Complex.$w$casinh w_sgAFy ww1_sgAFB ww2_sgAFC of {
                (#,#) ww4_sgAFE [Occ=Once] ww5_sgAFF [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAFE ww5_sgAFF];
              };
        };

Data.Complex.$w$s$catan1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAFG ww1_sgAFH]
        case timesFloat# [ww1_sgAFH ww_sgAFG] of sat_sgAFN {
          __DEFAULT ->
              case timesFloat# [ww_sgAFG ww1_sgAFH] of sat_sgAFM {
                __DEFAULT ->
                    case plusFloat# [sat_sgAFM sat_sgAFN] of sat_sgAFO {
                      __DEFAULT ->
                          case timesFloat# [ww1_sgAFH ww1_sgAFH] of sat_sgAFJ {
                            __DEFAULT ->
                                case timesFloat# [ww_sgAFG ww_sgAFG] of sat_sgAFI {
                                  __DEFAULT ->
                                      case minusFloat# [sat_sgAFI sat_sgAFJ] of sat_sgAFK {
                                        __DEFAULT ->
                                            case plusFloat# [1.0# sat_sgAFK] of sat_sgAFL {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt1 sat_sgAFL sat_sgAFO
                                                  of
                                                  { (#,#) ww3_sgAFQ [Occ=Once!]
                                                          ww4_sgAFR [Occ=Once!] ->
                                                        case ww3_sgAFQ of {
                                                          GHC.Types.F# ww6_sgAFT [Occ=Once] ->
                                                              case ww4_sgAFR of {
                                                                GHC.Types.F# ww8_sgAFV [Occ=Once] ->
                                                                    case
                                                                        minusFloat# [1.0# ww1_sgAFH]
                                                                    of
                                                                    sat_sgAFW
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/1
                                                                                  sat_sgAFW
                                                                                  ww_sgAFG
                                                                                  ww6_sgAFT
                                                                                  ww8_sgAFV
                                                                          of
                                                                          { (#,#) ww10_sgAFY [Occ=Once!]
                                                                                  ww11_sgAFZ [Occ=Once!] ->
                                                                                case ww10_sgAFY of {
                                                                                  GHC.Types.F# ww13_sgAG1 ->
                                                                                      case
                                                                                          ww11_sgAFZ
                                                                                      of
                                                                                      { GHC.Types.F# ww15_sgAG3 ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude1
                                                                                                    ww13_sgAG1
                                                                                                    ww15_sgAG3
                                                                                            of
                                                                                            ww16_sgAG4
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logFloat# [ww16_sgAG4]
                                                                                                  of
                                                                                                  wild1_sgAG5
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase1
                                                                                                                ww13_sgAG1
                                                                                                                ww15_sgAG3
                                                                                                        of
                                                                                                        ww17_sgAG6
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateFloat# [wild1_sgAG5]
                                                                                                              of
                                                                                                              sat_sgAG8
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgAG9 [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [sat_sgAG8]; } in
                                                                                                                    let {
                                                                                                                      sat_sgAG7 [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [ww17_sgAG6];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgAG7
                                                                                                                             sat_sgAG9];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catan1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAGa]
        case w_sgAGa of {
          Data.Complex.:+ ww1_sgAGc [Occ=Once!] ww2_sgAGd [Occ=Once!] ->
              case ww1_sgAGc of {
                GHC.Types.F# ww4_sgAGf [Occ=Once] ->
                    case ww2_sgAGd of {
                      GHC.Types.F# ww6_sgAGh [Occ=Once] ->
                          case Data.Complex.$w$s$catan1 ww4_sgAGf ww6_sgAGh of {
                            (#,#) ww8_sgAGj [Occ=Once] ww9_sgAGk [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAGj ww9_sgAGk];
                          };
                    };
              };
        };

Data.Complex.$w$s$catan [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAGl ww1_sgAGm]
        case *## [ww1_sgAGm ww_sgAGl] of sat_sgAGs {
          __DEFAULT ->
              case *## [ww_sgAGl ww1_sgAGm] of sat_sgAGr {
                __DEFAULT ->
                    case +## [sat_sgAGr sat_sgAGs] of sat_sgAGt {
                      __DEFAULT ->
                          case *## [ww1_sgAGm ww1_sgAGm] of sat_sgAGo {
                            __DEFAULT ->
                                case *## [ww_sgAGl ww_sgAGl] of sat_sgAGn {
                                  __DEFAULT ->
                                      case -## [sat_sgAGn sat_sgAGo] of sat_sgAGp {
                                        __DEFAULT ->
                                            case +## [1.0## sat_sgAGp] of sat_sgAGq {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt sat_sgAGq sat_sgAGt
                                                  of
                                                  { (#,#) ww3_sgAGv [Occ=Once!]
                                                          ww4_sgAGw [Occ=Once!] ->
                                                        case ww3_sgAGv of {
                                                          GHC.Types.D# ww6_sgAGy [Occ=Once] ->
                                                              case ww4_sgAGw of {
                                                                GHC.Types.D# ww8_sgAGA [Occ=Once] ->
                                                                    case
                                                                        -## [1.0## ww1_sgAGm]
                                                                    of
                                                                    sat_sgAGB
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/
                                                                                  sat_sgAGB
                                                                                  ww_sgAGl
                                                                                  ww6_sgAGy
                                                                                  ww8_sgAGA
                                                                          of
                                                                          { (#,#) ww10_sgAGD [Occ=Once!]
                                                                                  ww11_sgAGE [Occ=Once!] ->
                                                                                case ww10_sgAGD of {
                                                                                  GHC.Types.D# ww13_sgAGG ->
                                                                                      case
                                                                                          ww11_sgAGE
                                                                                      of
                                                                                      { GHC.Types.D# ww15_sgAGI ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude
                                                                                                    ww13_sgAGG
                                                                                                    ww15_sgAGI
                                                                                            of
                                                                                            ww16_sgAGJ
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logDouble# [ww16_sgAGJ]
                                                                                                  of
                                                                                                  wild1_sgAGK
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase
                                                                                                                ww13_sgAGG
                                                                                                                ww15_sgAGI
                                                                                                        of
                                                                                                        ww17_sgAGL
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateDouble# [wild1_sgAGK]
                                                                                                              of
                                                                                                              sat_sgAGN
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgAGO [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [sat_sgAGN]; } in
                                                                                                                    let {
                                                                                                                      sat_sgAGM [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [ww17_sgAGL];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgAGM
                                                                                                                             sat_sgAGO];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catan [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAGP]
        case w_sgAGP of {
          Data.Complex.:+ ww1_sgAGR [Occ=Once!] ww2_sgAGS [Occ=Once!] ->
              case ww1_sgAGR of {
                GHC.Types.D# ww4_sgAGU [Occ=Once] ->
                    case ww2_sgAGS of {
                      GHC.Types.D# ww6_sgAGW [Occ=Once] ->
                          case Data.Complex.$w$s$catan ww4_sgAGU ww6_sgAGW of {
                            (#,#) ww8_sgAGY [Occ=Once] ww9_sgAGZ [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAGY ww9_sgAGZ];
                          };
                    };
              };
        };

Data.Complex.$w$catan [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAH0 ww_sgAH1 ww1_sgAH2]
        case
            GHC.Float.$p1RealFloat w_sgAH0
        of
        $dRealFrac_sgAH3 [Dmd=<S(S(S(LC(C(S))LC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U)),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAH3
              of
              $dReal_sgAH4 [Dmd=<S(S(LC(C(S))LC(S)LLL)LL),1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U)),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAH4
                    of
                    $dNum_sgAH5 [Dmd=<S(LC(C(S))LC(S)LLL),U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U))>]
                    { __DEFAULT ->
                          let {
                            sat_sgAH6 [Occ=Once] :: a_sgxKN
                            [LclId] =
                                [$dNum_sgAH5] \u []
                                    GHC.Num.fromInteger
                                        $dNum_sgAH5 Data.Complex.$fFloatingComplex19;
                          } in 
                            case GHC.Num.- $dNum_sgAH5 sat_sgAH6 ww1_sgAH2 of dt_sgAH7 {
                              __DEFAULT ->
                                  case
                                      Data.Complex.$w$cfromInteger
                                          w_sgAH0 Data.Complex.$fFloatingComplex19
                                  of
                                  { (#,#) ww3_sgAH9 [Occ=Once] ww4_sgAHa [Occ=Once] ->
                                        case
                                            Data.Complex.$w$c*
                                                w_sgAH0 ww_sgAH1 ww1_sgAH2 ww_sgAH1 ww1_sgAH2
                                        of
                                        { (#,#) ww6_sgAHc [Occ=Once] ww7_sgAHd [Occ=Once] ->
                                              case
                                                  Data.Complex.$w$c+
                                                      w_sgAH0
                                                      ww3_sgAH9
                                                      ww4_sgAHa
                                                      ww6_sgAHc
                                                      ww7_sgAHd
                                              of
                                              { (#,#) ww9_sgAHf [Occ=Once] ww10_sgAHg [Occ=Once] ->
                                                    case
                                                        Data.Complex.$w$csqrt
                                                            w_sgAH0 ww9_sgAHf ww10_sgAHg
                                                    of
                                                    { (#,#) ww12_sgAHi [Occ=Once]
                                                            ww13_sgAHj [Occ=Once] ->
                                                          case
                                                              Data.Complex.$w$c/
                                                                  w_sgAH0
                                                                  dt_sgAH7
                                                                  ww_sgAH1
                                                                  ww12_sgAHi
                                                                  ww13_sgAHj
                                                          of
                                                          { (#,#) ww15_sgAHl ww16_sgAHm ->
                                                                let {
                                                                  sat_sgAHo [Occ=Once] :: a_sgxKN
                                                                  [LclId] =
                                                                      [w_sgAH0
                                                                       ww15_sgAHl
                                                                       ww16_sgAHm] \u []
                                                                          Data.Complex.$wmagnitude
                                                                              w_sgAH0
                                                                              ww15_sgAHl
                                                                              ww16_sgAHm;
                                                                } in 
                                                                  case
                                                                      GHC.Float.$p2RealFloat w_sgAH0
                                                                  of
                                                                  sat_sgAHn
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Float.log
                                                                                sat_sgAHn sat_sgAHo
                                                                        of
                                                                        dt1_sgAHp
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  Data.Complex.$wphase
                                                                                      w_sgAH0
                                                                                      ww15_sgAHl
                                                                                      ww16_sgAHm
                                                                              of
                                                                              dt2_sgAHq
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        GHC.Num.negate
                                                                                            $dNum_sgAH5
                                                                                            dt1_sgAHp
                                                                                    of
                                                                                    dt3_sgAHr
                                                                                    { __DEFAULT ->
                                                                                          (#,#) [dt2_sgAHq
                                                                                                 dt3_sgAHr];
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                          };
                                                    };
                                              };
                                        };
                                  };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$catan [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAHs w1_sgAHt]
        case w1_sgAHt of {
          Data.Complex.:+ ww1_sgAHv [Occ=Once] ww2_sgAHw [Occ=Once] ->
              case Data.Complex.$w$catan w_sgAHs ww1_sgAHv ww2_sgAHw of {
                (#,#) ww4_sgAHy [Occ=Once] ww5_sgAHz [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAHy ww5_sgAHz];
              };
        };

Data.Complex.$w$s$cacos1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAHA ww1_sgAHB]
        case timesFloat# [ww1_sgAHB ww_sgAHA] of sat_sgAHH {
          __DEFAULT ->
              case timesFloat# [ww_sgAHA ww1_sgAHB] of sat_sgAHG {
                __DEFAULT ->
                    case plusFloat# [sat_sgAHG sat_sgAHH] of sat_sgAHI {
                      __DEFAULT ->
                          case minusFloat# [0.0# sat_sgAHI] of sat_sgAHJ {
                            __DEFAULT ->
                                case timesFloat# [ww1_sgAHB ww1_sgAHB] of sat_sgAHD {
                                  __DEFAULT ->
                                      case timesFloat# [ww_sgAHA ww_sgAHA] of sat_sgAHC {
                                        __DEFAULT ->
                                            case minusFloat# [sat_sgAHC sat_sgAHD] of sat_sgAHE {
                                              __DEFAULT ->
                                                  case minusFloat# [1.0# sat_sgAHE] of sat_sgAHF {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt1
                                                                sat_sgAHF sat_sgAHJ
                                                        of
                                                        { (#,#) ww3_sgAHL [Occ=Once!]
                                                                ww4_sgAHM [Occ=Once!] ->
                                                              case ww4_sgAHM of {
                                                                GHC.Types.F# x_sgAHO [Occ=Once] ->
                                                                    case ww3_sgAHL of {
                                                                      GHC.Types.F# y_sgAHQ [Occ=Once] ->
                                                                          case
                                                                              plusFloat# [ww1_sgAHB
                                                                                          y_sgAHQ]
                                                                          of
                                                                          ww5_sgAHR [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateFloat# [x_sgAHO]
                                                                                of
                                                                                sat_sgAHT
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          plusFloat# [ww_sgAHA
                                                                                                      sat_sgAHT]
                                                                                      of
                                                                                      ww6_sgAHS [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude1
                                                                                                    ww6_sgAHS
                                                                                                    ww5_sgAHR
                                                                                            of
                                                                                            ww7_sgAHU
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logFloat# [ww7_sgAHU]
                                                                                                  of
                                                                                                  wild2_sgAHV
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase1
                                                                                                                ww6_sgAHS
                                                                                                                ww5_sgAHR
                                                                                                        of
                                                                                                        ww8_sgAHW
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateFloat# [wild2_sgAHV]
                                                                                                              of
                                                                                                              sat_sgAHY
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgAHZ [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [sat_sgAHY]; } in
                                                                                                                    let {
                                                                                                                      sat_sgAHX [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [ww8_sgAHW];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgAHX
                                                                                                                             sat_sgAHZ];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacos1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAI0]
        case w_sgAI0 of {
          Data.Complex.:+ ww1_sgAI2 [Occ=Once!] ww2_sgAI3 [Occ=Once!] ->
              case ww1_sgAI2 of {
                GHC.Types.F# ww4_sgAI5 [Occ=Once] ->
                    case ww2_sgAI3 of {
                      GHC.Types.F# ww6_sgAI7 [Occ=Once] ->
                          case Data.Complex.$w$s$cacos1 ww4_sgAI5 ww6_sgAI7 of {
                            (#,#) ww8_sgAI9 [Occ=Once] ww9_sgAIa [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAI9 ww9_sgAIa];
                          };
                    };
              };
        };

Data.Complex.$w$s$cacos [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAIb ww1_sgAIc]
        case *## [ww1_sgAIc ww_sgAIb] of sat_sgAIi {
          __DEFAULT ->
              case *## [ww_sgAIb ww1_sgAIc] of sat_sgAIh {
                __DEFAULT ->
                    case +## [sat_sgAIh sat_sgAIi] of sat_sgAIj {
                      __DEFAULT ->
                          case -## [0.0## sat_sgAIj] of sat_sgAIk {
                            __DEFAULT ->
                                case *## [ww1_sgAIc ww1_sgAIc] of sat_sgAIe {
                                  __DEFAULT ->
                                      case *## [ww_sgAIb ww_sgAIb] of sat_sgAId {
                                        __DEFAULT ->
                                            case -## [sat_sgAId sat_sgAIe] of sat_sgAIf {
                                              __DEFAULT ->
                                                  case -## [1.0## sat_sgAIf] of sat_sgAIg {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt
                                                                sat_sgAIg sat_sgAIk
                                                        of
                                                        { (#,#) ww3_sgAIm [Occ=Once!]
                                                                ww4_sgAIn [Occ=Once!] ->
                                                              case ww4_sgAIn of {
                                                                GHC.Types.D# x_sgAIp [Occ=Once] ->
                                                                    case ww3_sgAIm of {
                                                                      GHC.Types.D# y_sgAIr [Occ=Once] ->
                                                                          case
                                                                              +## [ww1_sgAIc
                                                                                   y_sgAIr]
                                                                          of
                                                                          ww5_sgAIs [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateDouble# [x_sgAIp]
                                                                                of
                                                                                sat_sgAIu
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          +## [ww_sgAIb
                                                                                               sat_sgAIu]
                                                                                      of
                                                                                      ww6_sgAIt [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude
                                                                                                    ww6_sgAIt
                                                                                                    ww5_sgAIs
                                                                                            of
                                                                                            ww7_sgAIv
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logDouble# [ww7_sgAIv]
                                                                                                  of
                                                                                                  wild2_sgAIw
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase
                                                                                                                ww6_sgAIt
                                                                                                                ww5_sgAIs
                                                                                                        of
                                                                                                        ww8_sgAIx
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateDouble# [wild2_sgAIw]
                                                                                                              of
                                                                                                              sat_sgAIz
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgAIA [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [sat_sgAIz]; } in
                                                                                                                    let {
                                                                                                                      sat_sgAIy [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [ww8_sgAIx];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgAIy
                                                                                                                             sat_sgAIA];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacos [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAIB]
        case w_sgAIB of {
          Data.Complex.:+ ww1_sgAID [Occ=Once!] ww2_sgAIE [Occ=Once!] ->
              case ww1_sgAID of {
                GHC.Types.D# ww4_sgAIG [Occ=Once] ->
                    case ww2_sgAIE of {
                      GHC.Types.D# ww6_sgAII [Occ=Once] ->
                          case Data.Complex.$w$s$cacos ww4_sgAIG ww6_sgAII of {
                            (#,#) ww8_sgAIK [Occ=Once] ww9_sgAIL [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAIK ww9_sgAIL];
                          };
                    };
              };
        };

Data.Complex.$w$cacos [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAIM ww_sgAIN ww1_sgAIO]
        case
            Data.Complex.$w$cfromInteger
                w_sgAIM Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww3_sgAIQ [Occ=Once] ww4_sgAIR [Occ=Once] ->
              case
                  Data.Complex.$w$c* w_sgAIM ww_sgAIN ww1_sgAIO ww_sgAIN ww1_sgAIO
              of
              { (#,#) ww6_sgAIT [Occ=Once] ww7_sgAIU [Occ=Once] ->
                    case
                        Data.Complex.$w$c- w_sgAIM ww3_sgAIQ ww4_sgAIR ww6_sgAIT ww7_sgAIU
                    of
                    { (#,#) ww9_sgAIW [Occ=Once] ww10_sgAIX [Occ=Once] ->
                          case Data.Complex.$w$csqrt w_sgAIM ww9_sgAIW ww10_sgAIX of {
                            (#,#) ww12_sgAIZ [Occ=Once] ww13_sgAJ0 [Occ=Once] ->
                                case
                                    GHC.Float.$p1RealFloat w_sgAIM
                                of
                                $dRealFrac_sgAJ1 [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
                                { __DEFAULT ->
                                      case
                                          GHC.Real.$p1RealFrac $dRealFrac_sgAJ1
                                      of
                                      $dReal_sgAJ2 [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
                                      { __DEFAULT ->
                                            case
                                                GHC.Real.$p1Real $dReal_sgAJ2
                                            of
                                            $dNum_sgAJ3 [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Num.negate $dNum_sgAJ3 ww13_sgAJ0
                                                  of
                                                  dt_sgAJ4
                                                  { __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$c+
                                                                w_sgAIM
                                                                ww_sgAIN
                                                                ww1_sgAIO
                                                                dt_sgAJ4
                                                                ww12_sgAIZ
                                                        of
                                                        { (#,#) ww15_sgAJ6 ww16_sgAJ7 ->
                                                              let {
                                                                sat_sgAJ9 [Occ=Once] :: a_sgxM9
                                                                [LclId] =
                                                                    [w_sgAIM
                                                                     ww15_sgAJ6
                                                                     ww16_sgAJ7] \u []
                                                                        Data.Complex.$wmagnitude
                                                                            w_sgAIM
                                                                            ww15_sgAJ6
                                                                            ww16_sgAJ7;
                                                              } in 
                                                                case
                                                                    GHC.Float.$p2RealFloat w_sgAIM
                                                                of
                                                                sat_sgAJ8
                                                                { __DEFAULT ->
                                                                      case
                                                                          GHC.Float.log
                                                                              sat_sgAJ8 sat_sgAJ9
                                                                      of
                                                                      dt1_sgAJa
                                                                      { __DEFAULT ->
                                                                            case
                                                                                Data.Complex.$wphase
                                                                                    w_sgAIM
                                                                                    ww15_sgAJ6
                                                                                    ww16_sgAJ7
                                                                            of
                                                                            dt2_sgAJb
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      GHC.Num.negate
                                                                                          $dNum_sgAJ3
                                                                                          dt1_sgAJa
                                                                                  of
                                                                                  dt3_sgAJc
                                                                                  { __DEFAULT ->
                                                                                        (#,#) [dt2_sgAJb
                                                                                               dt3_sgAJc];
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cacos [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAJd w1_sgAJe]
        case w1_sgAJe of {
          Data.Complex.:+ ww1_sgAJg [Occ=Once] ww2_sgAJh [Occ=Once] ->
              case Data.Complex.$w$cacos w_sgAJd ww1_sgAJg ww2_sgAJh of {
                (#,#) ww4_sgAJj [Occ=Once] ww5_sgAJk [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAJj ww5_sgAJk];
              };
        };

Data.Complex.$w$s$casin1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAJl ww1_sgAJm]
        case timesFloat# [ww1_sgAJm ww_sgAJl] of sat_sgAJs {
          __DEFAULT ->
              case timesFloat# [ww_sgAJl ww1_sgAJm] of sat_sgAJr {
                __DEFAULT ->
                    case plusFloat# [sat_sgAJr sat_sgAJs] of sat_sgAJt {
                      __DEFAULT ->
                          case minusFloat# [0.0# sat_sgAJt] of sat_sgAJu {
                            __DEFAULT ->
                                case timesFloat# [ww1_sgAJm ww1_sgAJm] of sat_sgAJo {
                                  __DEFAULT ->
                                      case timesFloat# [ww_sgAJl ww_sgAJl] of sat_sgAJn {
                                        __DEFAULT ->
                                            case minusFloat# [sat_sgAJn sat_sgAJo] of sat_sgAJp {
                                              __DEFAULT ->
                                                  case minusFloat# [1.0# sat_sgAJp] of sat_sgAJq {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt1
                                                                sat_sgAJq sat_sgAJu
                                                        of
                                                        { (#,#) ww3_sgAJw [Occ=Once!]
                                                                ww4_sgAJx [Occ=Once!] ->
                                                              case ww3_sgAJw of {
                                                                GHC.Types.F# y_sgAJz [Occ=Once] ->
                                                                    case ww4_sgAJx of {
                                                                      GHC.Types.F# y1_sgAJB [Occ=Once] ->
                                                                          case
                                                                              plusFloat# [ww_sgAJl
                                                                                          y1_sgAJB]
                                                                          of
                                                                          ww5_sgAJC [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateFloat# [ww1_sgAJm]
                                                                                of
                                                                                sat_sgAJE
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          plusFloat# [sat_sgAJE
                                                                                                      y_sgAJz]
                                                                                      of
                                                                                      ww6_sgAJD [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude1
                                                                                                    ww6_sgAJD
                                                                                                    ww5_sgAJC
                                                                                            of
                                                                                            ww7_sgAJF
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logFloat# [ww7_sgAJF]
                                                                                                  of
                                                                                                  wild3_sgAJG
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase1
                                                                                                                ww6_sgAJD
                                                                                                                ww5_sgAJC
                                                                                                        of
                                                                                                        ww8_sgAJH
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateFloat# [wild3_sgAJG]
                                                                                                              of
                                                                                                              sat_sgAJJ
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgAJK [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [sat_sgAJJ]; } in
                                                                                                                    let {
                                                                                                                      sat_sgAJI [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [ww8_sgAJH];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgAJI
                                                                                                                             sat_sgAJK];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casin1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAJL]
        case w_sgAJL of {
          Data.Complex.:+ ww1_sgAJN [Occ=Once!] ww2_sgAJO [Occ=Once!] ->
              case ww1_sgAJN of {
                GHC.Types.F# ww4_sgAJQ [Occ=Once] ->
                    case ww2_sgAJO of {
                      GHC.Types.F# ww6_sgAJS [Occ=Once] ->
                          case Data.Complex.$w$s$casin1 ww4_sgAJQ ww6_sgAJS of {
                            (#,#) ww8_sgAJU [Occ=Once] ww9_sgAJV [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAJU ww9_sgAJV];
                          };
                    };
              };
        };

Data.Complex.$w$s$casin [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAJW ww1_sgAJX]
        case *## [ww1_sgAJX ww_sgAJW] of sat_sgAK3 {
          __DEFAULT ->
              case *## [ww_sgAJW ww1_sgAJX] of sat_sgAK2 {
                __DEFAULT ->
                    case +## [sat_sgAK2 sat_sgAK3] of sat_sgAK4 {
                      __DEFAULT ->
                          case -## [0.0## sat_sgAK4] of sat_sgAK5 {
                            __DEFAULT ->
                                case *## [ww1_sgAJX ww1_sgAJX] of sat_sgAJZ {
                                  __DEFAULT ->
                                      case *## [ww_sgAJW ww_sgAJW] of sat_sgAJY {
                                        __DEFAULT ->
                                            case -## [sat_sgAJY sat_sgAJZ] of sat_sgAK0 {
                                              __DEFAULT ->
                                                  case -## [1.0## sat_sgAK0] of sat_sgAK1 {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt
                                                                sat_sgAK1 sat_sgAK5
                                                        of
                                                        { (#,#) ww3_sgAK7 [Occ=Once!]
                                                                ww4_sgAK8 [Occ=Once!] ->
                                                              case ww3_sgAK7 of {
                                                                GHC.Types.D# y_sgAKa [Occ=Once] ->
                                                                    case ww4_sgAK8 of {
                                                                      GHC.Types.D# y1_sgAKc [Occ=Once] ->
                                                                          case
                                                                              +## [ww_sgAJW
                                                                                   y1_sgAKc]
                                                                          of
                                                                          ww5_sgAKd [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateDouble# [ww1_sgAJX]
                                                                                of
                                                                                sat_sgAKf
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          +## [sat_sgAKf
                                                                                               y_sgAKa]
                                                                                      of
                                                                                      ww6_sgAKe [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude
                                                                                                    ww6_sgAKe
                                                                                                    ww5_sgAKd
                                                                                            of
                                                                                            ww7_sgAKg
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logDouble# [ww7_sgAKg]
                                                                                                  of
                                                                                                  wild3_sgAKh
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase
                                                                                                                ww6_sgAKe
                                                                                                                ww5_sgAKd
                                                                                                        of
                                                                                                        ww8_sgAKi
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateDouble# [wild3_sgAKh]
                                                                                                              of
                                                                                                              sat_sgAKk
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgAKl [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [sat_sgAKk]; } in
                                                                                                                    let {
                                                                                                                      sat_sgAKj [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [ww8_sgAKi];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgAKj
                                                                                                                             sat_sgAKl];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casin [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAKm]
        case w_sgAKm of {
          Data.Complex.:+ ww1_sgAKo [Occ=Once!] ww2_sgAKp [Occ=Once!] ->
              case ww1_sgAKo of {
                GHC.Types.D# ww4_sgAKr [Occ=Once] ->
                    case ww2_sgAKp of {
                      GHC.Types.D# ww6_sgAKt [Occ=Once] ->
                          case Data.Complex.$w$s$casin ww4_sgAKr ww6_sgAKt of {
                            (#,#) ww8_sgAKv [Occ=Once] ww9_sgAKw [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAKv ww9_sgAKw];
                          };
                    };
              };
        };

Data.Complex.$w$casin [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAKx ww_sgAKy ww1_sgAKz]
        case
            GHC.Float.$p1RealFloat w_sgAKx
        of
        $dRealFrac_sgAKA [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAKA
              of
              $dReal_sgAKB [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgAKB
                    of
                    $dNum_sgAKC [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.negate $dNum_sgAKC ww1_sgAKz of dt_sgAKD {
                            __DEFAULT ->
                                case
                                    Data.Complex.$w$cfromInteger
                                        w_sgAKx Data.Complex.$fFloatingComplex19
                                of
                                { (#,#) ww3_sgAKF [Occ=Once] ww4_sgAKG [Occ=Once] ->
                                      case
                                          Data.Complex.$w$c*
                                              w_sgAKx ww_sgAKy ww1_sgAKz ww_sgAKy ww1_sgAKz
                                      of
                                      { (#,#) ww6_sgAKI [Occ=Once] ww7_sgAKJ [Occ=Once] ->
                                            case
                                                Data.Complex.$w$c-
                                                    w_sgAKx ww3_sgAKF ww4_sgAKG ww6_sgAKI ww7_sgAKJ
                                            of
                                            { (#,#) ww9_sgAKL [Occ=Once] ww10_sgAKM [Occ=Once] ->
                                                  case
                                                      Data.Complex.$w$csqrt
                                                          w_sgAKx ww9_sgAKL ww10_sgAKM
                                                  of
                                                  { (#,#) ww12_sgAKO [Occ=Once]
                                                          ww13_sgAKP [Occ=Once] ->
                                                        case
                                                            Data.Complex.$w$c+
                                                                w_sgAKx
                                                                dt_sgAKD
                                                                ww_sgAKy
                                                                ww12_sgAKO
                                                                ww13_sgAKP
                                                        of
                                                        { (#,#) ww15_sgAKR ww16_sgAKS ->
                                                              let {
                                                                sat_sgAKU [Occ=Once] :: a_sgxNq
                                                                [LclId] =
                                                                    [w_sgAKx
                                                                     ww15_sgAKR
                                                                     ww16_sgAKS] \u []
                                                                        Data.Complex.$wmagnitude
                                                                            w_sgAKx
                                                                            ww15_sgAKR
                                                                            ww16_sgAKS;
                                                              } in 
                                                                case
                                                                    GHC.Float.$p2RealFloat w_sgAKx
                                                                of
                                                                sat_sgAKT
                                                                { __DEFAULT ->
                                                                      case
                                                                          GHC.Float.log
                                                                              sat_sgAKT sat_sgAKU
                                                                      of
                                                                      dt1_sgAKV
                                                                      { __DEFAULT ->
                                                                            case
                                                                                Data.Complex.$wphase
                                                                                    w_sgAKx
                                                                                    ww15_sgAKR
                                                                                    ww16_sgAKS
                                                                            of
                                                                            dt2_sgAKW
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      GHC.Num.negate
                                                                                          $dNum_sgAKC
                                                                                          dt1_sgAKV
                                                                                  of
                                                                                  dt3_sgAKX
                                                                                  { __DEFAULT ->
                                                                                        (#,#) [dt2_sgAKW
                                                                                               dt3_sgAKX];
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$casin [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAKY w1_sgAKZ]
        case w1_sgAKZ of {
          Data.Complex.:+ ww1_sgAL1 [Occ=Once] ww2_sgAL2 [Occ=Once] ->
              case Data.Complex.$w$casin w_sgAKY ww1_sgAL1 ww2_sgAL2 of {
                (#,#) ww4_sgAL4 [Occ=Once] ww5_sgAL5 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAL4 ww5_sgAL5];
              };
        };

Data.Complex.$w$s$catanh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgAL6 ww1_sgAL7]
        case minusFloat# [0.0# ww1_sgAL7] of sat_sgALa {
          __DEFAULT ->
              case minusFloat# [1.0# ww_sgAL6] of sat_sgAL9 {
                __DEFAULT ->
                    case plusFloat# [1.0# ww_sgAL6] of sat_sgAL8 {
                      __DEFAULT ->
                          case
                              Data.Complex.$w$s$c/1 sat_sgAL8 ww1_sgAL7 sat_sgAL9 sat_sgALa
                          of
                          { (#,#) ww3_sgALc [Occ=Once!] ww4_sgALd [Occ=Once!] ->
                                case ww3_sgALc of {
                                  GHC.Types.F# ww6_sgALf ->
                                      case ww4_sgALd of {
                                        GHC.Types.F# ww8_sgALh ->
                                            case
                                                Data.Complex.$w$smagnitude1 ww6_sgALf ww8_sgALh
                                            of
                                            ww9_sgALi
                                            { __DEFAULT ->
                                                  case logFloat# [ww9_sgALi] of wild1_sgALj {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$sphase1
                                                                ww6_sgALf ww8_sgALh
                                                        of
                                                        ww10_sgALk
                                                        { __DEFAULT ->
                                                              case
                                                                  timesFloat# [0.0# wild1_sgALj]
                                                              of
                                                              sat_sgALq
                                                              { __DEFAULT ->
                                                                    case
                                                                        timesFloat# [0.5#
                                                                                     ww10_sgALk]
                                                                    of
                                                                    sat_sgALp
                                                                    { __DEFAULT ->
                                                                          case
                                                                              plusFloat# [sat_sgALp
                                                                                          sat_sgALq]
                                                                          of
                                                                          sat_sgALr
                                                                          { __DEFAULT ->
                                                                                let {
                                                                                  sat_sgALs [Occ=Once]
                                                                                    :: GHC.Types.Float
                                                                                  [LclId] =
                                                                                      CCCS GHC.Types.F#! [sat_sgALr];
                                                                                } in 
                                                                                  case
                                                                                      timesFloat# [0.0#
                                                                                                   ww10_sgALk]
                                                                                  of
                                                                                  sat_sgALm
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            timesFloat# [0.5#
                                                                                                         wild1_sgALj]
                                                                                        of
                                                                                        sat_sgALl
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  minusFloat# [sat_sgALl
                                                                                                               sat_sgALm]
                                                                                              of
                                                                                              sat_sgALn
                                                                                              { __DEFAULT ->
                                                                                                    let {
                                                                                                      sat_sgALo [Occ=Once]
                                                                                                        :: GHC.Types.Float
                                                                                                      [LclId] =
                                                                                                          CCCS GHC.Types.F#! [sat_sgALn];
                                                                                                    } in 
                                                                                                      (#,#) [sat_sgALo
                                                                                                             sat_sgALs];
                                                                                              };
                                                                                        };
                                                                                  };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catanh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgALt]
        case w_sgALt of {
          Data.Complex.:+ ww1_sgALv [Occ=Once!] ww2_sgALw [Occ=Once!] ->
              case ww1_sgALv of {
                GHC.Types.F# ww4_sgALy [Occ=Once] ->
                    case ww2_sgALw of {
                      GHC.Types.F# ww6_sgALA [Occ=Once] ->
                          case Data.Complex.$w$s$catanh1 ww4_sgALy ww6_sgALA of {
                            (#,#) ww8_sgALC [Occ=Once] ww9_sgALD [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgALC ww9_sgALD];
                          };
                    };
              };
        };

Data.Complex.$w$s$catanh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgALE ww1_sgALF]
        case -## [0.0## ww1_sgALF] of sat_sgALI {
          __DEFAULT ->
              case -## [1.0## ww_sgALE] of sat_sgALH {
                __DEFAULT ->
                    case +## [1.0## ww_sgALE] of sat_sgALG {
                      __DEFAULT ->
                          case
                              Data.Complex.$w$s$c/ sat_sgALG ww1_sgALF sat_sgALH sat_sgALI
                          of
                          { (#,#) ww3_sgALK [Occ=Once!] ww4_sgALL [Occ=Once!] ->
                                case ww3_sgALK of {
                                  GHC.Types.D# ww6_sgALN ->
                                      case ww4_sgALL of {
                                        GHC.Types.D# ww8_sgALP ->
                                            case
                                                Data.Complex.$w$smagnitude ww6_sgALN ww8_sgALP
                                            of
                                            ww9_sgALQ
                                            { __DEFAULT ->
                                                  case logDouble# [ww9_sgALQ] of wild1_sgALR {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$sphase
                                                                ww6_sgALN ww8_sgALP
                                                        of
                                                        ww10_sgALS
                                                        { __DEFAULT ->
                                                              case
                                                                  *## [0.0## wild1_sgALR]
                                                              of
                                                              sat_sgALY
                                                              { __DEFAULT ->
                                                                    case
                                                                        *## [0.5## ww10_sgALS]
                                                                    of
                                                                    sat_sgALX
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +## [sat_sgALX
                                                                                   sat_sgALY]
                                                                          of
                                                                          sat_sgALZ
                                                                          { __DEFAULT ->
                                                                                let {
                                                                                  sat_sgAM0 [Occ=Once]
                                                                                    :: GHC.Types.Double
                                                                                  [LclId] =
                                                                                      CCCS GHC.Types.D#! [sat_sgALZ];
                                                                                } in 
                                                                                  case
                                                                                      *## [0.0##
                                                                                           ww10_sgALS]
                                                                                  of
                                                                                  sat_sgALU
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            *## [0.5##
                                                                                                 wild1_sgALR]
                                                                                        of
                                                                                        sat_sgALT
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  -## [sat_sgALT
                                                                                                       sat_sgALU]
                                                                                              of
                                                                                              sat_sgALV
                                                                                              { __DEFAULT ->
                                                                                                    let {
                                                                                                      sat_sgALW [Occ=Once]
                                                                                                        :: GHC.Types.Double
                                                                                                      [LclId] =
                                                                                                          CCCS GHC.Types.D#! [sat_sgALV];
                                                                                                    } in 
                                                                                                      (#,#) [sat_sgALW
                                                                                                             sat_sgAM0];
                                                                                              };
                                                                                        };
                                                                                  };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catanh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgAM1]
        case w_sgAM1 of {
          Data.Complex.:+ ww1_sgAM3 [Occ=Once!] ww2_sgAM4 [Occ=Once!] ->
              case ww1_sgAM3 of {
                GHC.Types.D# ww4_sgAM6 [Occ=Once] ->
                    case ww2_sgAM4 of {
                      GHC.Types.D# ww6_sgAM8 [Occ=Once] ->
                          case Data.Complex.$w$s$catanh ww4_sgAM6 ww6_sgAM8 of {
                            (#,#) ww8_sgAMa [Occ=Once] ww9_sgAMb [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgAMa ww9_sgAMb];
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex20
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [Data.Complex.$fFloatingComplex19
                                Data.Complex.$fFloatingComplex21];

Data.Complex.$fFloatingComplex18
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [Data.Complex.$fFloatingComplex19
                                Data.Complex.$fFloatingComplex19];

Data.Complex.$w$catanh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LC(S))LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAMc ww_sgAMd ww1_sgAMe]
        case
            Data.Complex.$w$cfromRational
                w_sgAMc Data.Complex.$fFloatingComplex20
        of
        { (#,#) ww3_sgAMg [Occ=Once] ww4_sgAMh [Occ=Once] ->
              case
                  Data.Complex.$w$cfromRational
                      w_sgAMc Data.Complex.$fFloatingComplex18
              of
              { (#,#) ww6_sgAMj ww7_sgAMk ->
                    case
                        Data.Complex.$w$c+ w_sgAMc ww6_sgAMj ww7_sgAMk ww_sgAMd ww1_sgAMe
                    of
                    { (#,#) ww9_sgAMm [Occ=Once] ww10_sgAMn [Occ=Once] ->
                          case
                              Data.Complex.$w$c- w_sgAMc ww6_sgAMj ww7_sgAMk ww_sgAMd ww1_sgAMe
                          of
                          { (#,#) ww12_sgAMp [Occ=Once] ww13_sgAMq [Occ=Once] ->
                                case
                                    Data.Complex.$w$c/
                                        w_sgAMc ww9_sgAMm ww10_sgAMn ww12_sgAMp ww13_sgAMq
                                of
                                { (#,#) ww15_sgAMs ww16_sgAMt ->
                                      let {
                                        sat_sgAMv [Occ=Once] :: a_sgxOH
                                        [LclId] =
                                            [w_sgAMc ww15_sgAMs ww16_sgAMt] \u []
                                                Data.Complex.$wmagnitude
                                                    w_sgAMc ww15_sgAMs ww16_sgAMt;
                                      } in 
                                        case GHC.Float.$p2RealFloat w_sgAMc of sat_sgAMu {
                                          __DEFAULT ->
                                              case GHC.Float.log sat_sgAMu sat_sgAMv of dt_sgAMw {
                                                __DEFAULT ->
                                                    case
                                                        Data.Complex.$wphase
                                                            w_sgAMc ww15_sgAMs ww16_sgAMt
                                                    of
                                                    dt1_sgAMx
                                                    { __DEFAULT ->
                                                          Data.Complex.$w$c*
                                                              w_sgAMc
                                                              ww3_sgAMg
                                                              ww4_sgAMh
                                                              dt_sgAMw
                                                              dt1_sgAMx;
                                                    };
                                              };
                                        };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$catanh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LC(S))LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAMy w1_sgAMz]
        case w1_sgAMz of {
          Data.Complex.:+ ww1_sgAMB [Occ=Once] ww2_sgAMC [Occ=Once] ->
              case Data.Complex.$w$catanh w_sgAMy ww1_sgAMB ww2_sgAMC of {
                (#,#) ww4_sgAME [Occ=Once] ww5_sgAMF [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAME ww5_sgAMF];
              };
        };

Data.Complex.$fFloatingComplex_nan :: GHC.Types.Double
[GblId] =
    [] \u []
        case /## [0.0## 0.0##] of wild2_sgAMG {
          __DEFAULT -> GHC.Types.D# [wild2_sgAMG];
        };

Data.Complex.$fFloatingComplex_inf :: GHC.Types.Double
[GblId] =
    [] \u []
        case /## [1.0## 0.0##] of wild2_sgAMH {
          __DEFAULT -> GHC.Types.D# [wild2_sgAMH];
        };

Data.Complex.$fFloatingComplex6
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_nan
                                    Data.Complex.$fFloatingComplex_nan];

Data.Complex.$fFloatingComplex5
  :: Data.Complex.Complex GHC.Types.Double
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_nan of {
          GHC.Types.D# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex6;
        };

Data.Complex.$fFloatingComplex8
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_inf
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$fFloatingComplex7
  :: Data.Complex.Complex GHC.Types.Double
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_inf of {
          GHC.Types.D# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex8;
        };

Data.Complex.$fFloatingComplex3 :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.D#! [1.0##];

Data.Complex.$fFloatingComplex2
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex3
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$w$s$c** [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=3,
 Str=<L,1*U(U(U),U(U))><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAMM ww_sgAMN ww1_sgAMO]
        let-no-escape {
          fail_sgAMP [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Double
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [w_sgAMM ww_sgAMN ww1_sgAMO] \r [void_0E]
                  case w_sgAMM of {
                    Data.Complex.:+ ds1_sgAMS [Occ=Once!] ds2_sgAMT [Occ=Once!] ->
                        case ds2_sgAMT of {
                          GHC.Types.D# ds4_sgAMV ->
                              case ds1_sgAMS of {
                                GHC.Types.D# ds6_sgAMX ->
                                    let-no-escape {
                                      fail1_sgAMY [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Double
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [ww_sgAMN
                                                    ww1_sgAMO
                                                    ds4_sgAMV
                                                    ds6_sgAMX] \r [void_0E]
                                              case
                                                  __pkg_ccall base-4.11.0.0 [ds6_sgAMX
                                                                             GHC.Prim.realWorld#]
                                              of
                                              { Unit# ds9_sgAN3 [Occ=Once!] ->
                                                    case ds9_sgAN3 of {
                                                      __DEFAULT ->
                                                          case <## [ww_sgAMN 0.0##] of {
                                                            __DEFAULT ->
                                                                case ==## [ww_sgAMN 0.0##] of {
                                                                  __DEFAULT ->
                                                                      Data.Complex.$fFloatingComplex7;
                                                                  1# ->
                                                                      Data.Complex.$fFloatingComplex5;
                                                                };
                                                            1# -> Data.Complex.$fFloatingComplex4;
                                                          };
                                                      0# ->
                                                          case
                                                              __pkg_ccall base-4.11.0.0 [ds4_sgAMV
                                                                                         GHC.Prim.realWorld#]
                                                          of
                                                          { Unit# ds11_sgANa [Occ=Once!] ->
                                                                case ds11_sgANa of {
                                                                  __DEFAULT ->
                                                                      case <## [ww_sgAMN 0.0##] of {
                                                                        __DEFAULT ->
                                                                            case
                                                                                ==## [ww_sgAMN
                                                                                      0.0##]
                                                                            of
                                                                            { __DEFAULT ->
                                                                                  Data.Complex.$fFloatingComplex7;
                                                                              1# ->
                                                                                  Data.Complex.$fFloatingComplex5;
                                                                            };
                                                                        1# ->
                                                                            Data.Complex.$fFloatingComplex4;
                                                                      };
                                                                  0# ->
                                                                      case
                                                                          Data.Complex.$w$smagnitude
                                                                              ds6_sgAMX ds4_sgAMV
                                                                      of
                                                                      ww2_sgANe
                                                                      { __DEFAULT ->
                                                                            case
                                                                                logDouble# [ww2_sgANe]
                                                                            of
                                                                            wild5_sgANf
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      Data.Complex.$w$sphase
                                                                                          ds6_sgAMX
                                                                                          ds4_sgAMV
                                                                                  of
                                                                                  ww3_sgANg
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            *## [ww3_sgANg
                                                                                                 ww_sgAMN]
                                                                                        of
                                                                                        sat_sgANj
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  *## [wild5_sgANf
                                                                                                       ww1_sgAMO]
                                                                                              of
                                                                                              sat_sgANi
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        +## [sat_sgANi
                                                                                                             sat_sgANj]
                                                                                                    of
                                                                                                    y_sgANh
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              *## [ww3_sgANg
                                                                                                                   ww1_sgAMO]
                                                                                                          of
                                                                                                          sat_sgANm
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    *## [wild5_sgANf
                                                                                                                         ww_sgAMN]
                                                                                                                of
                                                                                                                sat_sgANl
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          -## [sat_sgANl
                                                                                                                               sat_sgANm]
                                                                                                                      of
                                                                                                                      sat_sgANn
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                expDouble# [sat_sgANn]
                                                                                                                            of
                                                                                                                            expx_sgANk
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sinDouble# [y_sgANh]
                                                                                                                                  of
                                                                                                                                  sat_sgANr
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            *## [expx_sgANk
                                                                                                                                                 sat_sgANr]
                                                                                                                                        of
                                                                                                                                        sat_sgANs
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              let {
                                                                                                                                                sat_sgANt [Occ=Once]
                                                                                                                                                  :: GHC.Types.Double
                                                                                                                                                [LclId] =
                                                                                                                                                    CCCS GHC.Types.D#! [sat_sgANs];
                                                                                                                                              } in 
                                                                                                                                                case
                                                                                                                                                    cosDouble# [y_sgANh]
                                                                                                                                                of
                                                                                                                                                sat_sgANo
                                                                                                                                                { __DEFAULT ->
                                                                                                                                                      case
                                                                                                                                                          *## [expx_sgANk
                                                                                                                                                               sat_sgANo]
                                                                                                                                                      of
                                                                                                                                                      sat_sgANp
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgANq [Occ=Once]
                                                                                                                                                                :: GHC.Types.Double
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.D#! [sat_sgANp];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgANq
                                                                                                                                                                               sat_sgANt];
                                                                                                                                                      };
                                                                                                                                                };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                    } in 
                                      case ==## [ds6_sgAMX 0.0##] of {
                                        __DEFAULT -> fail1_sgAMY GHC.Prim.void#;
                                        1# ->
                                            case ==## [ds4_sgAMV 0.0##] of {
                                              __DEFAULT -> fail1_sgAMY GHC.Prim.void#;
                                              1# ->
                                                  case <## [ww_sgAMN 0.0##] of {
                                                    __DEFAULT ->
                                                        case ==## [ww_sgAMN 0.0##] of {
                                                          __DEFAULT ->
                                                              Data.Complex.$fFloatingComplex4;
                                                          1# -> Data.Complex.$fFloatingComplex5;
                                                        };
                                                    1# -> Data.Complex.$fFloatingComplex7;
                                                  };
                                            };
                                      };
                              };
                        };
                  };
        } in 
          case ==## [ww_sgAMN 0.0##] of {
            __DEFAULT -> fail_sgAMP GHC.Prim.void#;
            1# ->
                case ==## [ww1_sgAMO 0.0##] of {
                  __DEFAULT -> fail_sgAMP GHC.Prim.void#;
                  1# -> Data.Complex.$fFloatingComplex2;
                };
          };

Data.Complex.$fFloatingComplex_$s$c** [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Str=<L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>,
 Unf=OtherCon []] =
    [] \r [w_sgANA w1_sgANB]
        case w1_sgANB of {
          Data.Complex.:+ ww1_sgAND [Occ=Once!] ww2_sgANE [Occ=Once!] ->
              case ww1_sgAND of {
                GHC.Types.D# ww4_sgANG [Occ=Once] ->
                    case ww2_sgANE of {
                      GHC.Types.D# ww6_sgANI [Occ=Once] ->
                          Data.Complex.$w$s$c** w_sgANA ww4_sgANG ww6_sgANI;
                    };
              };
        };

Data.Complex.$fFloatingComplex_nan1 :: GHC.Types.Float
[GblId] =
    [] \u []
        case divideFloat# [0.0# 0.0#] of wild2_sgANJ {
          __DEFAULT -> GHC.Types.F# [wild2_sgANJ];
        };

Data.Complex.$fFloatingComplex_inf1 :: GHC.Types.Float
[GblId] =
    [] \u []
        case divideFloat# [1.0# 0.0#] of wild2_sgANK {
          __DEFAULT -> GHC.Types.F# [wild2_sgANK];
        };

Data.Complex.$fFloatingComplex14
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_nan1
                                    Data.Complex.$fFloatingComplex_nan1];

Data.Complex.$fFloatingComplex13
  :: Data.Complex.Complex GHC.Types.Float
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_nan1 of {
          GHC.Types.F# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex14;
        };

Data.Complex.$fFloatingComplex16
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_inf1
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$fFloatingComplex15
  :: Data.Complex.Complex GHC.Types.Float
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_inf1 of {
          GHC.Types.F# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex16;
        };

Data.Complex.$fFloatingComplex11 :: GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.F#! [1.0#];

Data.Complex.$fFloatingComplex10
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex11
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$w$s$c**1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=3,
 Str=<L,1*U(U(U),U(U))><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgANP ww_sgANQ ww1_sgANR]
        let-no-escape {
          fail_sgANS [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Float
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [w_sgANP ww_sgANQ ww1_sgANR] \r [void_0E]
                  case w_sgANP of {
                    Data.Complex.:+ ds1_sgANV [Occ=Once!] ds2_sgANW [Occ=Once!] ->
                        case ds2_sgANW of {
                          GHC.Types.F# ds4_sgANY ->
                              case ds1_sgANV of {
                                GHC.Types.F# ds6_sgAO0 ->
                                    let-no-escape {
                                      fail1_sgAO1 [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Float
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [ww_sgANQ
                                                    ww1_sgANR
                                                    ds4_sgANY
                                                    ds6_sgAO0] \r [void_0E]
                                              case
                                                  __pkg_ccall base-4.11.0.0 [ds6_sgAO0
                                                                             GHC.Prim.realWorld#]
                                              of
                                              { Unit# ds9_sgAO6 [Occ=Once!] ->
                                                    case ds9_sgAO6 of {
                                                      __DEFAULT ->
                                                          case ltFloat# [ww_sgANQ 0.0#] of {
                                                            __DEFAULT ->
                                                                case eqFloat# [ww_sgANQ 0.0#] of {
                                                                  __DEFAULT ->
                                                                      Data.Complex.$fFloatingComplex15;
                                                                  1# ->
                                                                      Data.Complex.$fFloatingComplex13;
                                                                };
                                                            1# -> Data.Complex.$fFloatingComplex12;
                                                          };
                                                      0# ->
                                                          case
                                                              __pkg_ccall base-4.11.0.0 [ds4_sgANY
                                                                                         GHC.Prim.realWorld#]
                                                          of
                                                          { Unit# ds11_sgAOd [Occ=Once!] ->
                                                                case ds11_sgAOd of {
                                                                  __DEFAULT ->
                                                                      case
                                                                          ltFloat# [ww_sgANQ 0.0#]
                                                                      of
                                                                      { __DEFAULT ->
                                                                            case
                                                                                eqFloat# [ww_sgANQ
                                                                                          0.0#]
                                                                            of
                                                                            { __DEFAULT ->
                                                                                  Data.Complex.$fFloatingComplex15;
                                                                              1# ->
                                                                                  Data.Complex.$fFloatingComplex13;
                                                                            };
                                                                        1# ->
                                                                            Data.Complex.$fFloatingComplex12;
                                                                      };
                                                                  0# ->
                                                                      case
                                                                          Data.Complex.$w$smagnitude1
                                                                              ds6_sgAO0 ds4_sgANY
                                                                      of
                                                                      ww2_sgAOh
                                                                      { __DEFAULT ->
                                                                            case
                                                                                logFloat# [ww2_sgAOh]
                                                                            of
                                                                            wild5_sgAOi
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      Data.Complex.$w$sphase1
                                                                                          ds6_sgAO0
                                                                                          ds4_sgANY
                                                                                  of
                                                                                  ww3_sgAOj
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            timesFloat# [ww3_sgAOj
                                                                                                         ww_sgANQ]
                                                                                        of
                                                                                        sat_sgAOm
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  timesFloat# [wild5_sgAOi
                                                                                                               ww1_sgANR]
                                                                                              of
                                                                                              sat_sgAOl
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        plusFloat# [sat_sgAOl
                                                                                                                    sat_sgAOm]
                                                                                                    of
                                                                                                    y_sgAOk
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              timesFloat# [ww3_sgAOj
                                                                                                                           ww1_sgANR]
                                                                                                          of
                                                                                                          sat_sgAOp
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    timesFloat# [wild5_sgAOi
                                                                                                                                 ww_sgANQ]
                                                                                                                of
                                                                                                                sat_sgAOo
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          minusFloat# [sat_sgAOo
                                                                                                                                       sat_sgAOp]
                                                                                                                      of
                                                                                                                      sat_sgAOq
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                expFloat# [sat_sgAOq]
                                                                                                                            of
                                                                                                                            expx_sgAOn
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sinFloat# [y_sgAOk]
                                                                                                                                  of
                                                                                                                                  sat_sgAOu
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            timesFloat# [expx_sgAOn
                                                                                                                                                         sat_sgAOu]
                                                                                                                                        of
                                                                                                                                        sat_sgAOv
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              let {
                                                                                                                                                sat_sgAOw [Occ=Once]
                                                                                                                                                  :: GHC.Types.Float
                                                                                                                                                [LclId] =
                                                                                                                                                    CCCS GHC.Types.F#! [sat_sgAOv];
                                                                                                                                              } in 
                                                                                                                                                case
                                                                                                                                                    cosFloat# [y_sgAOk]
                                                                                                                                                of
                                                                                                                                                sat_sgAOr
                                                                                                                                                { __DEFAULT ->
                                                                                                                                                      case
                                                                                                                                                          timesFloat# [expx_sgAOn
                                                                                                                                                                       sat_sgAOr]
                                                                                                                                                      of
                                                                                                                                                      sat_sgAOs
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgAOt [Occ=Once]
                                                                                                                                                                :: GHC.Types.Float
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.F#! [sat_sgAOs];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgAOt
                                                                                                                                                                               sat_sgAOw];
                                                                                                                                                      };
                                                                                                                                                };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                    } in 
                                      case eqFloat# [ds6_sgAO0 0.0#] of {
                                        __DEFAULT -> fail1_sgAO1 GHC.Prim.void#;
                                        1# ->
                                            case eqFloat# [ds4_sgANY 0.0#] of {
                                              __DEFAULT -> fail1_sgAO1 GHC.Prim.void#;
                                              1# ->
                                                  case ltFloat# [ww_sgANQ 0.0#] of {
                                                    __DEFAULT ->
                                                        case eqFloat# [ww_sgANQ 0.0#] of {
                                                          __DEFAULT ->
                                                              Data.Complex.$fFloatingComplex12;
                                                          1# -> Data.Complex.$fFloatingComplex13;
                                                        };
                                                    1# -> Data.Complex.$fFloatingComplex15;
                                                  };
                                            };
                                      };
                              };
                        };
                  };
        } in 
          case eqFloat# [ww_sgANQ 0.0#] of {
            __DEFAULT -> fail_sgANS GHC.Prim.void#;
            1# ->
                case eqFloat# [ww1_sgANR 0.0#] of {
                  __DEFAULT -> fail_sgANS GHC.Prim.void#;
                  1# -> Data.Complex.$fFloatingComplex10;
                };
          };

Data.Complex.$fFloatingComplex_$s$c**1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Str=<L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>,
 Unf=OtherCon []] =
    [] \r [w_sgAOD w1_sgAOE]
        case w1_sgAOE of {
          Data.Complex.:+ ww1_sgAOG [Occ=Once!] ww2_sgAOH [Occ=Once!] ->
              case ww1_sgAOG of {
                GHC.Types.F# ww4_sgAOJ [Occ=Once] ->
                    case ww2_sgAOH of {
                      GHC.Types.F# ww6_sgAOL [Occ=Once] ->
                          Data.Complex.$w$s$c**1 w_sgAOD ww4_sgAOJ ww6_sgAOL;
                    };
              };
        };

Data.Complex.$w$c** [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> a -> a -> (# a, a #)
[GblId,
 Arity=4,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))><L,1*U(U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgAOM w1_sgAON ww_sgAOO ww1_sgAOP]
        case
            GHC.Float.$p1RealFloat w_sgAOM
        of
        $dRealFrac_sgAOQ [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgAOQ
              of
              $dReal_sgAOR [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p2Real $dReal_sgAOR
                    of
                    $dOrd_sgAOS [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A)>]
                    { __DEFAULT ->
                          case
                              GHC.Classes.$p1Ord $dOrd_sgAOS
                          of
                          $dEq_sgAOT [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                          { __DEFAULT ->
                                let {
                                  $dNum_sgAOU [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_sgxPv
                                  [LclId] =
                                      [$dReal_sgAOR] \u [] GHC.Real.$p1Real $dReal_sgAOR; } in
                                let {
                                  sat_sgAPy [Occ=Once] :: a_sgxPv
                                  [LclId] =
                                      [$dNum_sgAOU] \u []
                                          GHC.Num.fromInteger
                                              $dNum_sgAOU Data.Complex.$fFloatingComplex17;
                                } in 
                                  let-no-escape {
                                    fail_sgAOV [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                      :: GHC.Prim.Void# -> (# a_sgxPv, a_sgxPv #)
                                    [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                        sat-only [w_sgAOM
                                                  w1_sgAON
                                                  ww_sgAOO
                                                  ww1_sgAOP
                                                  $dRealFrac_sgAOQ
                                                  $dOrd_sgAOS
                                                  $dEq_sgAOT
                                                  $dNum_sgAOU] \r [void_0E]
                                            case w1_sgAON of {
                                              Data.Complex.:+ ds1_sgAOY ds2_sgAOZ ->
                                                  let {
                                                    $dFractional_sgAP0 [Dmd=<L,U(A,C(C1(U)),A,A)>]
                                                      :: GHC.Real.Fractional a_sgxPv
                                                    [LclId] =
                                                        [$dRealFrac_sgAOQ] \u []
                                                            GHC.Real.$p2RealFrac
                                                                $dRealFrac_sgAOQ; } in
                                                  let {
                                                    nan_sgAP1 [Dmd=<L,1*U>] :: a_sgxPv
                                                    [LclId] =
                                                        [$dNum_sgAOU $dFractional_sgAP0] \s []
                                                            let {
                                                              sat_sgAP3 [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgAOU] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgAOU
                                                                          Data.Complex.$fFloatingComplex17; } in
                                                            let {
                                                              sat_sgAP2 [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgAOU] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgAOU
                                                                          Data.Complex.$fFloatingComplex17;
                                                            } in 
                                                              GHC.Real./
                                                                  $dFractional_sgAP0
                                                                  sat_sgAP2
                                                                  sat_sgAP3; } in
                                                  let {
                                                    inf_sgAP4 [Dmd=<L,1*U>] :: a_sgxPv
                                                    [LclId] =
                                                        [$dNum_sgAOU $dFractional_sgAP0] \s []
                                                            let {
                                                              sat_sgAP6 [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgAOU] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgAOU
                                                                          Data.Complex.$fFloatingComplex17; } in
                                                            let {
                                                              sat_sgAP5 [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgAOU] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgAOU
                                                                          Data.Complex.$fFloatingComplex19;
                                                            } in 
                                                              GHC.Real./
                                                                  $dFractional_sgAP0
                                                                  sat_sgAP5
                                                                  sat_sgAP6; } in
                                                  let {
                                                    sat_sgAPo [Occ=Once] :: a_sgxPv
                                                    [LclId] =
                                                        [$dNum_sgAOU] \u []
                                                            GHC.Num.fromInteger
                                                                $dNum_sgAOU
                                                                Data.Complex.$fFloatingComplex17;
                                                  } in 
                                                    let-no-escape {
                                                      fail1_sgAP7 [Occ=Once*!T[1],
                                                                   Dmd=<L,1*C1(U(U,U))>]
                                                        :: GHC.Prim.Void# -> (# a_sgxPv, a_sgxPv #)
                                                      [LclId[JoinId(1)],
                                                       Arity=1,
                                                       Str=<L,A>,
                                                       Unf=OtherCon []] =
                                                          sat-only [w_sgAOM
                                                                    ww_sgAOO
                                                                    ww1_sgAOP
                                                                    $dOrd_sgAOS
                                                                    $dNum_sgAOU
                                                                    ds1_sgAOY
                                                                    ds2_sgAOZ
                                                                    nan_sgAP1
                                                                    inf_sgAP4] \r [void_0E]
                                                              let-no-escape {
                                                                $j_sgAP9 [Occ=Once*T[0],
                                                                          Dmd=<L,1*U(U,U)>]
                                                                  :: (# a_sgxPv, a_sgxPv #)
                                                                [LclId[JoinId(0)],
                                                                 Unf=OtherCon []] =
                                                                    [ww_sgAOO
                                                                     $dOrd_sgAOS
                                                                     $dNum_sgAOU
                                                                     nan_sgAP1
                                                                     inf_sgAP4] \r []
                                                                        let {
                                                                          sat_sgAPa [Occ=Once]
                                                                            :: a_sgxPv
                                                                          [LclId] =
                                                                              [$dNum_sgAOU] \u []
                                                                                  GHC.Num.fromInteger
                                                                                      $dNum_sgAOU
                                                                                      Data.Complex.$fFloatingComplex17;
                                                                        } in 
                                                                          case
                                                                              GHC.Classes.compare
                                                                                  $dOrd_sgAOS
                                                                                  ww_sgAOO
                                                                                  sat_sgAPa
                                                                          of
                                                                          { GHC.Types.LT ->
                                                                                case
                                                                                    GHC.Num.fromInteger
                                                                                        $dNum_sgAOU
                                                                                        Data.Complex.$fFloatingComplex17
                                                                                of
                                                                                dt_sgAPc
                                                                                { __DEFAULT ->
                                                                                      (#,#) [dt_sgAPc
                                                                                             dt_sgAPc];
                                                                                };
                                                                            GHC.Types.EQ ->
                                                                                case
                                                                                    nan_sgAP1
                                                                                of
                                                                                dt_sgAPd
                                                                                { __DEFAULT ->
                                                                                      (#,#) [dt_sgAPd
                                                                                             dt_sgAPd];
                                                                                };
                                                                            GHC.Types.GT ->
                                                                                case
                                                                                    inf_sgAP4
                                                                                of
                                                                                dt_sgAPe
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          GHC.Num.fromInteger
                                                                                              $dNum_sgAOU
                                                                                              Data.Complex.$fFloatingComplex17
                                                                                      of
                                                                                      dt1_sgAPf
                                                                                      { __DEFAULT ->
                                                                                            (#,#) [dt_sgAPe
                                                                                                   dt1_sgAPf];
                                                                                      };
                                                                                };
                                                                          };
                                                              } in 
                                                                case
                                                                    GHC.Float.isInfinite
                                                                        w_sgAOM ds1_sgAOY
                                                                of
                                                                { GHC.Types.False ->
                                                                      case
                                                                          GHC.Float.isInfinite
                                                                              w_sgAOM ds2_sgAOZ
                                                                      of
                                                                      { GHC.Types.False ->
                                                                            case
                                                                                Data.Complex.$w$clog
                                                                                    w_sgAOM
                                                                                    ds1_sgAOY
                                                                                    ds2_sgAOZ
                                                                            of
                                                                            { (#,#) ww3_sgAPj [Occ=Once]
                                                                                    ww4_sgAPk [Occ=Once] ->
                                                                                  case
                                                                                      Data.Complex.$w$c*
                                                                                          w_sgAOM
                                                                                          ww3_sgAPj
                                                                                          ww4_sgAPk
                                                                                          ww_sgAOO
                                                                                          ww1_sgAOP
                                                                                  of
                                                                                  { (#,#) ww6_sgAPm [Occ=Once]
                                                                                          ww7_sgAPn [Occ=Once] ->
                                                                                        Data.Complex.$w$cexp
                                                                                            w_sgAOM
                                                                                            ww6_sgAPm
                                                                                            ww7_sgAPn;
                                                                                  };
                                                                            };
                                                                        GHC.Types.True -> $j_sgAP9;
                                                                      };
                                                                  GHC.Types.True -> $j_sgAP9;
                                                                };
                                                    } in 
                                                      case
                                                          GHC.Classes.==
                                                              $dEq_sgAOT ds1_sgAOY sat_sgAPo
                                                      of
                                                      { GHC.Types.False ->
                                                            fail1_sgAP7 GHC.Prim.void#;
                                                        GHC.Types.True ->
                                                            let {
                                                              sat_sgAPq [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgAOU] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgAOU
                                                                          Data.Complex.$fFloatingComplex17;
                                                            } in 
                                                              case
                                                                  GHC.Classes.==
                                                                      $dEq_sgAOT ds2_sgAOZ sat_sgAPq
                                                              of
                                                              { GHC.Types.False ->
                                                                    fail1_sgAP7 GHC.Prim.void#;
                                                                GHC.Types.True ->
                                                                    let {
                                                                      sat_sgAPs [Occ=Once]
                                                                        :: a_sgxPv
                                                                      [LclId] =
                                                                          [$dNum_sgAOU] \u []
                                                                              GHC.Num.fromInteger
                                                                                  $dNum_sgAOU
                                                                                  Data.Complex.$fFloatingComplex17;
                                                                    } in 
                                                                      case
                                                                          GHC.Classes.compare
                                                                              $dOrd_sgAOS
                                                                              ww_sgAOO
                                                                              sat_sgAPs
                                                                      of
                                                                      { GHC.Types.LT ->
                                                                            case
                                                                                inf_sgAP4
                                                                            of
                                                                            dt_sgAPu
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      GHC.Num.fromInteger
                                                                                          $dNum_sgAOU
                                                                                          Data.Complex.$fFloatingComplex17
                                                                                  of
                                                                                  dt1_sgAPv
                                                                                  { __DEFAULT ->
                                                                                        (#,#) [dt_sgAPu
                                                                                               dt1_sgAPv];
                                                                                  };
                                                                            };
                                                                        GHC.Types.EQ ->
                                                                            case
                                                                                nan_sgAP1
                                                                            of
                                                                            dt_sgAPw
                                                                            { __DEFAULT ->
                                                                                  (#,#) [dt_sgAPw
                                                                                         dt_sgAPw];
                                                                            };
                                                                        GHC.Types.GT ->
                                                                            case
                                                                                GHC.Num.fromInteger
                                                                                    $dNum_sgAOU
                                                                                    Data.Complex.$fFloatingComplex17
                                                                            of
                                                                            dt_sgAPx
                                                                            { __DEFAULT ->
                                                                                  (#,#) [dt_sgAPx
                                                                                         dt_sgAPx];
                                                                            };
                                                                      };
                                                              };
                                                      };
                                            };
                                  } in 
                                    case GHC.Classes.== $dEq_sgAOT ww_sgAOO sat_sgAPy of {
                                      GHC.Types.False -> fail_sgAOV GHC.Prim.void#;
                                      GHC.Types.True ->
                                          let {
                                            sat_sgAPA [Occ=Once] :: a_sgxPv
                                            [LclId] =
                                                [$dNum_sgAOU] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_sgAOU
                                                        Data.Complex.$fFloatingComplex17;
                                          } in 
                                            case GHC.Classes.== $dEq_sgAOT ww1_sgAOP sat_sgAPA of {
                                              GHC.Types.False -> fail_sgAOV GHC.Prim.void#;
                                              GHC.Types.True ->
                                                  case
                                                      GHC.Num.fromInteger
                                                          $dNum_sgAOU
                                                          Data.Complex.$fFloatingComplex19
                                                  of
                                                  dt_sgAPC
                                                  { __DEFAULT ->
                                                        case
                                                            GHC.Num.fromInteger
                                                                $dNum_sgAOU
                                                                Data.Complex.$fFloatingComplex17
                                                        of
                                                        dt1_sgAPD
                                                        { __DEFAULT -> (#,#) [dt_sgAPC dt1_sgAPD];
                                                        };
                                                  };
                                            };
                                    };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$c** [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))><L,1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgAPE w1_sgAPF w2_sgAPG]
        case w2_sgAPG of {
          Data.Complex.:+ ww1_sgAPI [Occ=Once] ww2_sgAPJ [Occ=Once] ->
              case Data.Complex.$w$c** w_sgAPE w1_sgAPF ww1_sgAPI ww2_sgAPJ of {
                (#,#) ww4_sgAPL [Occ=Once] ww5_sgAPM [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgAPL ww5_sgAPM];
              };
        };

Data.Complex.$fFloatingComplex_$s$cexpm2 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAPN]
        case eta_sgAPN of {
          Data.Complex.:+ a_sgAPP [Occ=Once!] b_sgAPQ [Occ=Once!] ->
              case a_sgAPP of {
                GHC.Types.F# x_sgAPS ->
                    case b_sgAPQ of {
                      GHC.Types.F# x1_sgAPU ->
                          case timesFloat# [x1_sgAPU x1_sgAPU] of sat_sgAPW {
                            __DEFAULT ->
                                case timesFloat# [x_sgAPS x_sgAPS] of sat_sgAPV {
                                  __DEFAULT ->
                                      case plusFloat# [sat_sgAPV sat_sgAPW] of sat_sgAPX {
                                        __DEFAULT ->
                                            case ltFloat# [sat_sgAPX 1.0#] of {
                                              __DEFAULT ->
                                                  case expFloat# [x_sgAPS] of expx_sgAPZ {
                                                    __DEFAULT ->
                                                        case sinFloat# [x1_sgAPU] of sat_sgAQ4 {
                                                          __DEFAULT ->
                                                              case
                                                                  timesFloat# [expx_sgAPZ sat_sgAQ4]
                                                              of
                                                              sat_sgAQ5
                                                              { __DEFAULT ->
                                                                    let {
                                                                      sat_sgAQ6 [Occ=Once]
                                                                        :: GHC.Types.Float
                                                                      [LclId] =
                                                                          CCCS GHC.Types.F#! [sat_sgAQ5];
                                                                    } in 
                                                                      case
                                                                          cosFloat# [x1_sgAPU]
                                                                      of
                                                                      sat_sgAQ0
                                                                      { __DEFAULT ->
                                                                            case
                                                                                timesFloat# [expx_sgAPZ
                                                                                             sat_sgAQ0]
                                                                            of
                                                                            sat_sgAQ1
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      minusFloat# [sat_sgAQ1
                                                                                                   1.0#]
                                                                                  of
                                                                                  sat_sgAQ2
                                                                                  { __DEFAULT ->
                                                                                        let {
                                                                                          sat_sgAQ3 [Occ=Once]
                                                                                            :: GHC.Types.Float
                                                                                          [LclId] =
                                                                                              CCCS GHC.Types.F#! [sat_sgAQ2];
                                                                                        } in 
                                                                                          Data.Complex.:+ [sat_sgAQ3
                                                                                                           sat_sgAQ6];
                                                                                  };
                                                                            };
                                                                      };
                                                              };
                                                        };
                                                  };
                                              1# ->
                                                  case
                                                      __pkg_ccall base-4.11.0.0 [x_sgAPS
                                                                                 GHC.Prim.realWorld#]
                                                  of
                                                  { Unit# ds4_sgAQa ->
                                                        case
                                                            divideFloat# [x1_sgAPU 2.0#]
                                                        of
                                                        sat_sgAQc
                                                        { __DEFAULT ->
                                                              case
                                                                  sinFloat# [sat_sgAQc]
                                                              of
                                                              v_sgAQb [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        plusFloat# [v_sgAQb v_sgAQb]
                                                                    of
                                                                    sat_sgAQe
                                                                    { __DEFAULT ->
                                                                          case
                                                                              timesFloat# [sat_sgAQe
                                                                                           v_sgAQb]
                                                                          of
                                                                          sat_sgAQf
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateFloat# [sat_sgAQf]
                                                                                of
                                                                                w_sgAQd
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          sinFloat# [x1_sgAPU]
                                                                                      of
                                                                                      sat_sgAQl
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                plusFloat# [ds4_sgAQa
                                                                                                            1.0#]
                                                                                            of
                                                                                            sat_sgAQk
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      timesFloat# [sat_sgAQk
                                                                                                                   sat_sgAQl]
                                                                                                  of
                                                                                                  sat_sgAQm
                                                                                                  { __DEFAULT ->
                                                                                                        let {
                                                                                                          sat_sgAQn [Occ=Once]
                                                                                                            :: GHC.Types.Float
                                                                                                          [LclId] =
                                                                                                              CCCS GHC.Types.F#! [sat_sgAQm];
                                                                                                        } in 
                                                                                                          case
                                                                                                              timesFloat# [ds4_sgAQa
                                                                                                                           w_sgAQd]
                                                                                                          of
                                                                                                          sat_sgAQg
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    plusFloat# [sat_sgAQg
                                                                                                                                ds4_sgAQa]
                                                                                                                of
                                                                                                                sat_sgAQh
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          plusFloat# [sat_sgAQh
                                                                                                                                      w_sgAQd]
                                                                                                                      of
                                                                                                                      sat_sgAQi
                                                                                                                      { __DEFAULT ->
                                                                                                                            let {
                                                                                                                              sat_sgAQj [Occ=Once]
                                                                                                                                :: GHC.Types.Float
                                                                                                                              [LclId] =
                                                                                                                                  CCCS GHC.Types.F#! [sat_sgAQi];
                                                                                                                            } in 
                                                                                                                              Data.Complex.:+ [sat_sgAQj
                                                                                                                                               sat_sgAQn];
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAQo]
        case eta_sgAQo of {
          Data.Complex.:+ a_sgAQq [Occ=Once!] b_sgAQr [Occ=Once!] ->
              case a_sgAQq of {
                GHC.Types.D# x_sgAQt ->
                    case b_sgAQr of {
                      GHC.Types.D# x1_sgAQv ->
                          case *## [x1_sgAQv x1_sgAQv] of sat_sgAQx {
                            __DEFAULT ->
                                case *## [x_sgAQt x_sgAQt] of sat_sgAQw {
                                  __DEFAULT ->
                                      case +## [sat_sgAQw sat_sgAQx] of sat_sgAQy {
                                        __DEFAULT ->
                                            case <## [sat_sgAQy 1.0##] of {
                                              __DEFAULT ->
                                                  case expDouble# [x_sgAQt] of expx_sgAQA {
                                                    __DEFAULT ->
                                                        case sinDouble# [x1_sgAQv] of sat_sgAQF {
                                                          __DEFAULT ->
                                                              case
                                                                  *## [expx_sgAQA sat_sgAQF]
                                                              of
                                                              sat_sgAQG
                                                              { __DEFAULT ->
                                                                    let {
                                                                      sat_sgAQH [Occ=Once]
                                                                        :: GHC.Types.Double
                                                                      [LclId] =
                                                                          CCCS GHC.Types.D#! [sat_sgAQG];
                                                                    } in 
                                                                      case
                                                                          cosDouble# [x1_sgAQv]
                                                                      of
                                                                      sat_sgAQB
                                                                      { __DEFAULT ->
                                                                            case
                                                                                *## [expx_sgAQA
                                                                                     sat_sgAQB]
                                                                            of
                                                                            sat_sgAQC
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      -## [sat_sgAQC
                                                                                           1.0##]
                                                                                  of
                                                                                  sat_sgAQD
                                                                                  { __DEFAULT ->
                                                                                        let {
                                                                                          sat_sgAQE [Occ=Once]
                                                                                            :: GHC.Types.Double
                                                                                          [LclId] =
                                                                                              CCCS GHC.Types.D#! [sat_sgAQD];
                                                                                        } in 
                                                                                          Data.Complex.:+ [sat_sgAQE
                                                                                                           sat_sgAQH];
                                                                                  };
                                                                            };
                                                                      };
                                                              };
                                                        };
                                                  };
                                              1# ->
                                                  case
                                                      __pkg_ccall base-4.11.0.0 [x_sgAQt
                                                                                 GHC.Prim.realWorld#]
                                                  of
                                                  { Unit# ds4_sgAQL ->
                                                        case /## [x1_sgAQv 2.0##] of sat_sgAQN {
                                                          __DEFAULT ->
                                                              case
                                                                  sinDouble# [sat_sgAQN]
                                                              of
                                                              v_sgAQM [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        +## [v_sgAQM v_sgAQM]
                                                                    of
                                                                    sat_sgAQP
                                                                    { __DEFAULT ->
                                                                          case
                                                                              *## [sat_sgAQP
                                                                                   v_sgAQM]
                                                                          of
                                                                          sat_sgAQQ
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateDouble# [sat_sgAQQ]
                                                                                of
                                                                                w_sgAQO
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          sinDouble# [x1_sgAQv]
                                                                                      of
                                                                                      sat_sgAQW
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                +## [ds4_sgAQL
                                                                                                     1.0##]
                                                                                            of
                                                                                            sat_sgAQV
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      *## [sat_sgAQV
                                                                                                           sat_sgAQW]
                                                                                                  of
                                                                                                  sat_sgAQX
                                                                                                  { __DEFAULT ->
                                                                                                        let {
                                                                                                          sat_sgAQY [Occ=Once]
                                                                                                            :: GHC.Types.Double
                                                                                                          [LclId] =
                                                                                                              CCCS GHC.Types.D#! [sat_sgAQX];
                                                                                                        } in 
                                                                                                          case
                                                                                                              *## [ds4_sgAQL
                                                                                                                   w_sgAQO]
                                                                                                          of
                                                                                                          sat_sgAQR
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    +## [sat_sgAQR
                                                                                                                         ds4_sgAQL]
                                                                                                                of
                                                                                                                sat_sgAQS
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          +## [sat_sgAQS
                                                                                                                               w_sgAQO]
                                                                                                                      of
                                                                                                                      sat_sgAQT
                                                                                                                      { __DEFAULT ->
                                                                                                                            let {
                                                                                                                              sat_sgAQU [Occ=Once]
                                                                                                                                :: GHC.Types.Double
                                                                                                                              [LclId] =
                                                                                                                                  CCCS GHC.Types.D#! [sat_sgAQT];
                                                                                                                            } in 
                                                                                                                              Data.Complex.:+ [sat_sgAQU
                                                                                                                                               sat_sgAQY];
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(LLC(C(S))LLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgAQZ eta_sgAR0]
        case eta_sgAR0 of {
          Data.Complex.:+ a1_sgAR2 b_sgAR3 ->
              case
                  GHC.Float.$p1RealFloat $dRealFloat_sgAQZ
              of
              $dRealFrac_sgAR4 [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1RealFrac $dRealFrac_sgAR4
                    of
                    $dReal_sgAR5 [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
                    { __DEFAULT ->
                          let {
                            $dNum_sgAR6 [Dmd=<L,U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U))>]
                              :: GHC.Num.Num a_agsO1
                            [LclId] =
                                [$dReal_sgAR5] \u [] GHC.Real.$p1Real $dReal_sgAR5; } in
                          let {
                            sat_sgARb [Occ=Once] :: a_agsO1
                            [LclId] =
                                [$dNum_sgAR6] \u []
                                    GHC.Num.fromInteger
                                        $dNum_sgAR6 Data.Complex.$fFloatingComplex19; } in
                          let {
                            sat_sgARa [Occ=Once] :: a_agsO1
                            [LclId] =
                                [a1_sgAR2 b_sgAR3 $dNum_sgAR6] \u []
                                    let {
                                      sat_sgAR9 [Occ=Once] :: a_agsO1
                                      [LclId] =
                                          [b_sgAR3 $dNum_sgAR6] \u []
                                              GHC.Num.* $dNum_sgAR6 b_sgAR3 b_sgAR3; } in
                                    let {
                                      sat_sgAR8 [Occ=Once] :: a_agsO1
                                      [LclId] =
                                          [a1_sgAR2 $dNum_sgAR6] \u []
                                              GHC.Num.* $dNum_sgAR6 a1_sgAR2 a1_sgAR2;
                                    } in  GHC.Num.+ $dNum_sgAR6 sat_sgAR8 sat_sgAR9;
                          } in 
                            case GHC.Real.$p2Real $dReal_sgAR5 of sat_sgAR7 {
                              __DEFAULT ->
                                  case GHC.Classes.< sat_sgAR7 sat_sgARa sat_sgARb of {
                                    GHC.Types.False ->
                                        case
                                            Data.Complex.$w$cexp $dRealFloat_sgAQZ a1_sgAR2 b_sgAR3
                                        of
                                        { (#,#) ww1_sgARe [Occ=Once] ww2_sgARf [Occ=Once] ->
                                              case
                                                  Data.Complex.$w$cfromInteger
                                                      $dRealFloat_sgAQZ
                                                      Data.Complex.$fFloatingComplex19
                                              of
                                              { (#,#) ww4_sgARh [Occ=Once] ww5_sgARi [Occ=Once] ->
                                                    case
                                                        Data.Complex.$w$c-
                                                            $dRealFloat_sgAQZ
                                                            ww1_sgARe
                                                            ww2_sgARf
                                                            ww4_sgARh
                                                            ww5_sgARi
                                                    of
                                                    { (#,#) ww7_sgARk [Occ=Once]
                                                            ww8_sgARl [Occ=Once] ->
                                                          Data.Complex.:+ [ww7_sgARk ww8_sgARl];
                                                    };
                                              };
                                        };
                                    GHC.Types.True ->
                                        let {
                                          $dFloating_sgARm [Dmd=<L,U(A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A)>]
                                            :: GHC.Float.Floating a_agsO1
                                          [LclId] =
                                              [$dRealFloat_sgAQZ] \u []
                                                  GHC.Float.$p2RealFloat $dRealFloat_sgAQZ; } in
                                        let {
                                          u_sgARn :: a_agsO1
                                          [LclId] =
                                              [a1_sgAR2 $dFloating_sgARm] \u []
                                                  GHC.Float.expm1 $dFloating_sgARm a1_sgAR2; } in
                                        let {
                                          w_sgARo :: a_agsO1
                                          [LclId] =
                                              [b_sgAR3
                                               $dRealFrac_sgAR4
                                               $dNum_sgAR6
                                               $dFloating_sgARm] \u []
                                                  let {
                                                    sat_sgARv [Occ=Once] :: a_agsO1
                                                    [LclId] =
                                                        [b_sgAR3
                                                         $dRealFrac_sgAR4
                                                         $dNum_sgAR6
                                                         $dFloating_sgARm] \u []
                                                            let {
                                                              v_sgARp :: a_agsO1
                                                              [LclId] =
                                                                  [b_sgAR3
                                                                   $dRealFrac_sgAR4
                                                                   $dNum_sgAR6
                                                                   $dFloating_sgARm] \u []
                                                                      let {
                                                                        sat_sgARs [Occ=Once]
                                                                          :: a_agsO1
                                                                        [LclId] =
                                                                            [b_sgAR3
                                                                             $dRealFrac_sgAR4
                                                                             $dNum_sgAR6] \u []
                                                                                let {
                                                                                  sat_sgARr [Occ=Once]
                                                                                    :: a_agsO1
                                                                                  [LclId] =
                                                                                      [$dNum_sgAR6] \u []
                                                                                          GHC.Num.fromInteger
                                                                                              $dNum_sgAR6
                                                                                              Data.Complex.$fFloatingComplex21;
                                                                                } in 
                                                                                  case
                                                                                      GHC.Real.$p2RealFrac
                                                                                          $dRealFrac_sgAR4
                                                                                  of
                                                                                  sat_sgARq
                                                                                  { __DEFAULT ->
                                                                                        GHC.Real./
                                                                                            sat_sgARq
                                                                                            b_sgAR3
                                                                                            sat_sgARr;
                                                                                  };
                                                                      } in 
                                                                        GHC.Float.sin
                                                                            $dFloating_sgARm
                                                                            sat_sgARs; } in
                                                            let {
                                                              sat_sgARu [Occ=Once] :: a_agsO1
                                                              [LclId] =
                                                                  [$dNum_sgAR6 v_sgARp] \u []
                                                                      let {
                                                                        sat_sgARt [Occ=Once]
                                                                          :: a_agsO1
                                                                        [LclId] =
                                                                            [$dNum_sgAR6] \u []
                                                                                GHC.Num.fromInteger
                                                                                    $dNum_sgAR6
                                                                                    Data.Complex.$fFloatingComplex21;
                                                                      } in 
                                                                        GHC.Num.*
                                                                            $dNum_sgAR6
                                                                            sat_sgARt
                                                                            v_sgARp;
                                                            } in 
                                                              GHC.Num.*
                                                                  $dNum_sgAR6 sat_sgARu v_sgARp;
                                                  } in  GHC.Num.negate $dNum_sgAR6 sat_sgARv; } in
                                        let {
                                          sat_sgARx [Occ=Once] :: a_agsO1
                                          [LclId] =
                                              [$dNum_sgAR6 u_sgARn w_sgARo] \u []
                                                  let {
                                                    sat_sgARw [Occ=Once] :: a_agsO1
                                                    [LclId] =
                                                        [$dNum_sgAR6 u_sgARn w_sgARo] \u []
                                                            GHC.Num.* $dNum_sgAR6 u_sgARn w_sgARo;
                                                  } in  GHC.Num.+ $dNum_sgAR6 sat_sgARw u_sgARn;
                                        } in 
                                          case GHC.Num.+ $dNum_sgAR6 sat_sgARx w_sgARo of dt_sgARy {
                                            __DEFAULT ->
                                                let {
                                                  sat_sgARB [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [b_sgAR3 $dFloating_sgARm] \u []
                                                          GHC.Float.sin
                                                              $dFloating_sgARm b_sgAR3; } in
                                                let {
                                                  sat_sgARA [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [$dNum_sgAR6 u_sgARn] \u []
                                                          let {
                                                            sat_sgARz [Occ=Once] :: a_agsO1
                                                            [LclId] =
                                                                [$dNum_sgAR6] \u []
                                                                    GHC.Num.fromInteger
                                                                        $dNum_sgAR6
                                                                        Data.Complex.$fFloatingComplex19;
                                                          } in 
                                                            GHC.Num.+ $dNum_sgAR6 u_sgARn sat_sgARz;
                                                } in 
                                                  case
                                                      GHC.Num.* $dNum_sgAR6 sat_sgARA sat_sgARB
                                                  of
                                                  dt1_sgARC
                                                  { __DEFAULT ->
                                                        Data.Complex.:+ [dt_sgARy dt1_sgARC];
                                                  };
                                          };
                                  };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1p1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgARD]
        case eta_sgARD of {
          Data.Complex.:+ a_sgARF [Occ=Once!] b_sgARG [Occ=Once!] ->
              case a_sgARF of {
                GHC.Types.F# x_sgARI ->
                    case b_sgARG of {
                      GHC.Types.F# y_sgARK ->
                          case fabsFloat# [x_sgARI] of sat_sgARS {
                            __DEFAULT ->
                                let-no-escape {
                                  $j_sgARL [Occ=Once*T[0], Dmd=<L,1*U(U,U)>]
                                    :: Data.Complex.Complex GHC.Types.Float
                                  [LclId[JoinId(0)], Str=m, Unf=OtherCon []] =
                                      [x_sgARI y_sgARK] \r []
                                          case plusFloat# [1.0# x_sgARI] of ww_sgARM [Dmd=<S,U>] {
                                            __DEFAULT ->
                                                case
                                                    Data.Complex.$w$smagnitude1 ww_sgARM y_sgARK
                                                of
                                                ww1_sgARN
                                                { __DEFAULT ->
                                                      case logFloat# [ww1_sgARN] of wild3_sgARO {
                                                        __DEFAULT ->
                                                            case
                                                                Data.Complex.$w$sphase1
                                                                    ww_sgARM y_sgARK
                                                            of
                                                            ww2_sgARP
                                                            { __DEFAULT ->
                                                                  let {
                                                                    sat_sgARR [Occ=Once]
                                                                      :: GHC.Types.Float
                                                                    [LclId] =
                                                                        CCCS GHC.Types.F#! [ww2_sgARP]; } in
                                                                  let {
                                                                    sat_sgARQ [Occ=Once]
                                                                      :: GHC.Types.Float
                                                                    [LclId] =
                                                                        CCCS GHC.Types.F#! [wild3_sgARO];
                                                                  } in 
                                                                    Data.Complex.:+ [sat_sgARQ
                                                                                     sat_sgARR];
                                                            };
                                                      };
                                                };
                                          };
                                } in 
                                  case ltFloat# [sat_sgARS 0.5#] of {
                                    __DEFAULT -> $j_sgARL;
                                    1# ->
                                        case fabsFloat# [y_sgARK] of sat_sgARU {
                                          __DEFAULT ->
                                              case ltFloat# [sat_sgARU 0.5#] of {
                                                __DEFAULT -> $j_sgARL;
                                                1# ->
                                                    case
                                                        timesFloat# [y_sgARK y_sgARK]
                                                    of
                                                    sat_sgAS0
                                                    { __DEFAULT ->
                                                          case
                                                              timesFloat# [x_sgARI x_sgARI]
                                                          of
                                                          sat_sgARY
                                                          { __DEFAULT ->
                                                                case
                                                                    plusFloat# [x_sgARI x_sgARI]
                                                                of
                                                                sat_sgARX
                                                                { __DEFAULT ->
                                                                      case
                                                                          plusFloat# [sat_sgARX
                                                                                      sat_sgARY]
                                                                      of
                                                                      sat_sgARZ
                                                                      { __DEFAULT ->
                                                                            case
                                                                                plusFloat# [sat_sgARZ
                                                                                            sat_sgAS0]
                                                                            of
                                                                            x1_sgARW [Dmd=<S,U>]
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      plusFloat# [x1_sgARW
                                                                                                  1.0#]
                                                                                  of
                                                                                  sat_sgAS1
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            sqrtFloat# [sat_sgAS1]
                                                                                        of
                                                                                        sat_sgAS2
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  plusFloat# [1.0#
                                                                                                              sat_sgAS2]
                                                                                              of
                                                                                              sat_sgAS3
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        divideFloat# [x1_sgARW
                                                                                                                      sat_sgAS3]
                                                                                                    of
                                                                                                    wild3_sgAS4
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              __pkg_ccall base-4.11.0.0 [wild3_sgAS4
                                                                                                                                         GHC.Prim.realWorld#]
                                                                                                          of
                                                                                                          { Unit# ds4_sgAS8 [Occ=Once] ->
                                                                                                                case
                                                                                                                    plusFloat# [1.0#
                                                                                                                                x_sgARI]
                                                                                                                of
                                                                                                                sat_sgAS9
                                                                                                                { __DEFAULT ->
                                                                                                                      let {
                                                                                                                        sat_sgASa [Occ=Once]
                                                                                                                          :: GHC.Types.Float
                                                                                                                        [LclId] =
                                                                                                                            CCCS GHC.Types.F#! [sat_sgAS9];
                                                                                                                      } in 
                                                                                                                        case
                                                                                                                            GHC.Float.$w$catan1
                                                                                                                                sat_sgASa
                                                                                                                                y_sgARK
                                                                                                                        of
                                                                                                                        ww2_sgASb
                                                                                                                        { __DEFAULT ->
                                                                                                                              let {
                                                                                                                                sat_sgASd [Occ=Once]
                                                                                                                                  :: GHC.Types.Float
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.F#! [ww2_sgASb]; } in
                                                                                                                              let {
                                                                                                                                sat_sgASc [Occ=Once]
                                                                                                                                  :: GHC.Types.Float
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.F#! [ds4_sgAS8];
                                                                                                                              } in 
                                                                                                                                Data.Complex.:+ [sat_sgASc
                                                                                                                                                 sat_sgASd];
                                                                                                                        };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                        };
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1p [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgASe]
        case eta_sgASe of {
          Data.Complex.:+ a_sgASg [Occ=Once!] b_sgASh [Occ=Once!] ->
              case a_sgASg of {
                GHC.Types.D# x_sgASj ->
                    case b_sgASh of {
                      GHC.Types.D# y_sgASl ->
                          case fabsDouble# [x_sgASj] of sat_sgASt {
                            __DEFAULT ->
                                let-no-escape {
                                  $j_sgASm [Occ=Once*T[0], Dmd=<L,1*U(U,U)>]
                                    :: Data.Complex.Complex GHC.Types.Double
                                  [LclId[JoinId(0)], Str=m, Unf=OtherCon []] =
                                      [x_sgASj y_sgASl] \r []
                                          case +## [1.0## x_sgASj] of ww_sgASn [Dmd=<S,U>] {
                                            __DEFAULT ->
                                                case
                                                    Data.Complex.$w$smagnitude ww_sgASn y_sgASl
                                                of
                                                ww1_sgASo
                                                { __DEFAULT ->
                                                      case logDouble# [ww1_sgASo] of wild3_sgASp {
                                                        __DEFAULT ->
                                                            case
                                                                Data.Complex.$w$sphase
                                                                    ww_sgASn y_sgASl
                                                            of
                                                            ww2_sgASq
                                                            { __DEFAULT ->
                                                                  let {
                                                                    sat_sgASs [Occ=Once]
                                                                      :: GHC.Types.Double
                                                                    [LclId] =
                                                                        CCCS GHC.Types.D#! [ww2_sgASq]; } in
                                                                  let {
                                                                    sat_sgASr [Occ=Once]
                                                                      :: GHC.Types.Double
                                                                    [LclId] =
                                                                        CCCS GHC.Types.D#! [wild3_sgASp];
                                                                  } in 
                                                                    Data.Complex.:+ [sat_sgASr
                                                                                     sat_sgASs];
                                                            };
                                                      };
                                                };
                                          };
                                } in 
                                  case <## [sat_sgASt 0.5##] of {
                                    __DEFAULT -> $j_sgASm;
                                    1# ->
                                        case fabsDouble# [y_sgASl] of sat_sgASv {
                                          __DEFAULT ->
                                              case <## [sat_sgASv 0.5##] of {
                                                __DEFAULT -> $j_sgASm;
                                                1# ->
                                                    case *## [y_sgASl y_sgASl] of sat_sgASB {
                                                      __DEFAULT ->
                                                          case *## [x_sgASj x_sgASj] of sat_sgASz {
                                                            __DEFAULT ->
                                                                case
                                                                    +## [x_sgASj x_sgASj]
                                                                of
                                                                sat_sgASy
                                                                { __DEFAULT ->
                                                                      case
                                                                          +## [sat_sgASy sat_sgASz]
                                                                      of
                                                                      sat_sgASA
                                                                      { __DEFAULT ->
                                                                            case
                                                                                +## [sat_sgASA
                                                                                     sat_sgASB]
                                                                            of
                                                                            x1_sgASx [Dmd=<S,U>]
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      +## [x1_sgASx
                                                                                           1.0##]
                                                                                  of
                                                                                  sat_sgASC
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            sqrtDouble# [sat_sgASC]
                                                                                        of
                                                                                        sat_sgASD
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  +## [1.0##
                                                                                                       sat_sgASD]
                                                                                              of
                                                                                              sat_sgASE
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        /## [x1_sgASx
                                                                                                             sat_sgASE]
                                                                                                    of
                                                                                                    wild3_sgASF
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              __pkg_ccall base-4.11.0.0 [wild3_sgASF
                                                                                                                                         GHC.Prim.realWorld#]
                                                                                                          of
                                                                                                          { Unit# ds4_sgASJ [Occ=Once] ->
                                                                                                                case
                                                                                                                    +## [1.0##
                                                                                                                         x_sgASj]
                                                                                                                of
                                                                                                                sat_sgASK
                                                                                                                { __DEFAULT ->
                                                                                                                      let {
                                                                                                                        sat_sgASL [Occ=Once]
                                                                                                                          :: GHC.Types.Double
                                                                                                                        [LclId] =
                                                                                                                            CCCS GHC.Types.D#! [sat_sgASK];
                                                                                                                      } in 
                                                                                                                        case
                                                                                                                            GHC.Float.$w$catan2
                                                                                                                                sat_sgASL
                                                                                                                                y_sgASl
                                                                                                                        of
                                                                                                                        ww2_sgASM
                                                                                                                        { __DEFAULT ->
                                                                                                                              let {
                                                                                                                                sat_sgASO [Occ=Once]
                                                                                                                                  :: GHC.Types.Double
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.D#! [ww2_sgASM]; } in
                                                                                                                              let {
                                                                                                                                sat_sgASN [Occ=Once]
                                                                                                                                  :: GHC.Types.Double
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.D#! [ds4_sgASJ];
                                                                                                                              } in 
                                                                                                                                Data.Complex.:+ [sat_sgASN
                                                                                                                                                 sat_sgASO];
                                                                                                                        };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                        };
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clog1p [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgASP eta_sgASQ]
        case eta_sgASQ of {
          Data.Complex.:+ a1_sgASS b_sgAST ->
              case
                  GHC.Float.$p1RealFloat $dRealFloat_sgASP
              of
              $dRealFrac_sgASU [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1RealFrac $dRealFrac_sgASU
                    of
                    $dReal_sgASV [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
                    { __DEFAULT ->
                          let {
                            $dNum_sgASW [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
                              :: GHC.Num.Num a_agsO1
                            [LclId] =
                                [$dReal_sgASV] \u [] GHC.Real.$p1Real $dReal_sgASV;
                          } in 
                            case
                                GHC.Real.$p2Real $dReal_sgASV
                            of
                            $dOrd_sgASX [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                            { __DEFAULT ->
                                  let {
                                    $dFractional_sgASY [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
                                      :: GHC.Real.Fractional a_agsO1
                                    [LclId] =
                                        [$dRealFrac_sgASU] \u []
                                            GHC.Real.$p2RealFrac $dRealFrac_sgASU; } in
                                  let {
                                    sat_sgAT0 [Occ=Once] :: a_agsO1
                                    [LclId] =
                                        [$dFractional_sgASY] \u []
                                            GHC.Real.fromRational
                                                $dFractional_sgASY
                                                Data.Complex.$fFloatingComplex20; } in
                                  let {
                                    sat_sgASZ [Occ=Once] :: a_agsO1
                                    [LclId] =
                                        [a1_sgASS $dNum_sgASW] \u []
                                            GHC.Num.abs $dNum_sgASW a1_sgASS;
                                  } in 
                                    case GHC.Classes.< $dOrd_sgASX sat_sgASZ sat_sgAT0 of {
                                      GHC.Types.False ->
                                          case
                                              Data.Complex.$w$cfromInteger
                                                  $dRealFloat_sgASP Data.Complex.$fFloatingComplex19
                                          of
                                          { (#,#) ww1_sgAT3 [Occ=Once] ww2_sgAT4 [Occ=Once] ->
                                                case
                                                    Data.Complex.$w$c+
                                                        $dRealFloat_sgASP
                                                        ww1_sgAT3
                                                        ww2_sgAT4
                                                        a1_sgASS
                                                        b_sgAST
                                                of
                                                { (#,#) ww4_sgAT6 [Occ=Once] ww5_sgAT7 [Occ=Once] ->
                                                      case
                                                          Data.Complex.$w$clog
                                                              $dRealFloat_sgASP ww4_sgAT6 ww5_sgAT7
                                                      of
                                                      { (#,#) ww7_sgAT9 [Occ=Once]
                                                              ww8_sgATa [Occ=Once] ->
                                                            Data.Complex.:+ [ww7_sgAT9 ww8_sgATa];
                                                      };
                                                };
                                          };
                                      GHC.Types.True ->
                                          let {
                                            sat_sgATc [Occ=Once] :: a_agsO1
                                            [LclId] =
                                                [$dFractional_sgASY] \u []
                                                    GHC.Real.fromRational
                                                        $dFractional_sgASY
                                                        Data.Complex.$fFloatingComplex20; } in
                                          let {
                                            sat_sgATb [Occ=Once] :: a_agsO1
                                            [LclId] =
                                                [b_sgAST $dNum_sgASW] \u []
                                                    GHC.Num.abs $dNum_sgASW b_sgAST;
                                          } in 
                                            case GHC.Classes.< $dOrd_sgASX sat_sgATb sat_sgATc of {
                                              GHC.Types.False ->
                                                  case
                                                      Data.Complex.$w$cfromInteger
                                                          $dRealFloat_sgASP
                                                          Data.Complex.$fFloatingComplex19
                                                  of
                                                  { (#,#) ww1_sgATf [Occ=Once]
                                                          ww2_sgATg [Occ=Once] ->
                                                        case
                                                            Data.Complex.$w$c+
                                                                $dRealFloat_sgASP
                                                                ww1_sgATf
                                                                ww2_sgATg
                                                                a1_sgASS
                                                                b_sgAST
                                                        of
                                                        { (#,#) ww4_sgATi [Occ=Once]
                                                                ww5_sgATj [Occ=Once] ->
                                                              case
                                                                  Data.Complex.$w$clog
                                                                      $dRealFloat_sgASP
                                                                      ww4_sgATi
                                                                      ww5_sgATj
                                                              of
                                                              { (#,#) ww7_sgATl [Occ=Once]
                                                                      ww8_sgATm [Occ=Once] ->
                                                                    Data.Complex.:+ [ww7_sgATl
                                                                                     ww8_sgATm];
                                                              };
                                                        };
                                                  };
                                              GHC.Types.True ->
                                                  case
                                                      GHC.Float.$p2RealFloat $dRealFloat_sgASP
                                                  of
                                                  $dFloating_sgATn [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_sgATz [Occ=Once] :: a_agsO1
                                                          [LclId] =
                                                              [a1_sgASS
                                                               b_sgAST
                                                               $dNum_sgASW
                                                               $dFractional_sgASY
                                                               $dFloating_sgATn] \u []
                                                                  let {
                                                                    u_sgATo :: a_agsO1
                                                                    [LclId] =
                                                                        [a1_sgASS
                                                                         b_sgAST
                                                                         $dNum_sgASW] \u []
                                                                            let {
                                                                              sat_sgATt [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [b_sgAST
                                                                                   $dNum_sgASW] \u []
                                                                                      GHC.Num.*
                                                                                          $dNum_sgASW
                                                                                          b_sgAST
                                                                                          b_sgAST; } in
                                                                            let {
                                                                              sat_sgATs [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [a1_sgASS
                                                                                   $dNum_sgASW] \u []
                                                                                      let {
                                                                                        sat_sgATr [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [a1_sgASS
                                                                                             $dNum_sgASW] \u []
                                                                                                GHC.Num.*
                                                                                                    $dNum_sgASW
                                                                                                    a1_sgASS
                                                                                                    a1_sgASS; } in
                                                                                      let {
                                                                                        sat_sgATq [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [a1_sgASS
                                                                                             $dNum_sgASW] \u []
                                                                                                let {
                                                                                                  sat_sgATp [Occ=Once]
                                                                                                    :: a_agsO1
                                                                                                  [LclId] =
                                                                                                      [$dNum_sgASW] \u []
                                                                                                          GHC.Num.fromInteger
                                                                                                              $dNum_sgASW
                                                                                                              Data.Complex.$fFloatingComplex21;
                                                                                                } in 
                                                                                                  GHC.Num.*
                                                                                                      $dNum_sgASW
                                                                                                      sat_sgATp
                                                                                                      a1_sgASS;
                                                                                      } in 
                                                                                        GHC.Num.+
                                                                                            $dNum_sgASW
                                                                                            sat_sgATq
                                                                                            sat_sgATr;
                                                                            } in 
                                                                              GHC.Num.+
                                                                                  $dNum_sgASW
                                                                                  sat_sgATs
                                                                                  sat_sgATt; } in
                                                                  let {
                                                                    sat_sgATy [Occ=Once] :: a_agsO1
                                                                    [LclId] =
                                                                        [$dNum_sgASW
                                                                         $dFloating_sgATn
                                                                         u_sgATo] \u []
                                                                            let {
                                                                              sat_sgATx [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [$dNum_sgASW
                                                                                   $dFloating_sgATn
                                                                                   u_sgATo] \u []
                                                                                      let {
                                                                                        sat_sgATw [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [$dNum_sgASW
                                                                                             u_sgATo] \u []
                                                                                                let {
                                                                                                  sat_sgATv [Occ=Once]
                                                                                                    :: a_agsO1
                                                                                                  [LclId] =
                                                                                                      [$dNum_sgASW] \u []
                                                                                                          GHC.Num.fromInteger
                                                                                                              $dNum_sgASW
                                                                                                              Data.Complex.$fFloatingComplex19;
                                                                                                } in 
                                                                                                  GHC.Num.+
                                                                                                      $dNum_sgASW
                                                                                                      u_sgATo
                                                                                                      sat_sgATv;
                                                                                      } in 
                                                                                        GHC.Float.sqrt
                                                                                            $dFloating_sgATn
                                                                                            sat_sgATw; } in
                                                                            let {
                                                                              sat_sgATu [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [$dNum_sgASW] \u []
                                                                                      GHC.Num.fromInteger
                                                                                          $dNum_sgASW
                                                                                          Data.Complex.$fFloatingComplex19;
                                                                            } in 
                                                                              GHC.Num.+
                                                                                  $dNum_sgASW
                                                                                  sat_sgATu
                                                                                  sat_sgATx;
                                                                  } in 
                                                                    GHC.Real./
                                                                        $dFractional_sgASY
                                                                        u_sgATo
                                                                        sat_sgATy;
                                                        } in 
                                                          case
                                                              GHC.Float.log1p
                                                                  $dFloating_sgATn sat_sgATz
                                                          of
                                                          dt_sgATA
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgATC [Occ=Once] :: a_agsO1
                                                                  [LclId] =
                                                                      [a1_sgASS $dNum_sgASW] \u []
                                                                          let {
                                                                            sat_sgATB [Occ=Once]
                                                                              :: a_agsO1
                                                                            [LclId] =
                                                                                [$dNum_sgASW] \u []
                                                                                    GHC.Num.fromInteger
                                                                                        $dNum_sgASW
                                                                                        Data.Complex.$fFloatingComplex19;
                                                                          } in 
                                                                            GHC.Num.+
                                                                                $dNum_sgASW
                                                                                sat_sgATB
                                                                                a1_sgASS;
                                                                } in 
                                                                  case
                                                                      GHC.Float.atan2
                                                                          $dRealFloat_sgASP
                                                                          sat_sgATC
                                                                          b_sgAST
                                                                  of
                                                                  dt1_sgATD
                                                                  { __DEFAULT ->
                                                                        Data.Complex.:+ [dt_sgATA
                                                                                         dt1_sgATD];
                                                                  };
                                                          };
                                                  };
                                            };
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1mexp1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgATE]
        case eta_sgATE of {
          Data.Complex.:+ x_sgATG [Occ=Once!] y_sgATH [Occ=Once!] ->
              case x_sgATG of {
                GHC.Types.F# x1_sgATJ [Occ=Once] ->
                    case y_sgATH of {
                      GHC.Types.F# x2_sgATL ->
                          case expFloat# [x1_sgATJ] of expx_sgATM [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosFloat# [x2_sgATL] of sat_sgATO {
                                  __DEFAULT ->
                                      case timesFloat# [expx_sgATM sat_sgATO] of sat_sgATP {
                                        __DEFAULT ->
                                            case negateFloat# [sat_sgATP] of dt_sgATN [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case sinFloat# [x2_sgATL] of sat_sgATR {
                                                    __DEFAULT ->
                                                        case
                                                            timesFloat# [expx_sgATM sat_sgATR]
                                                        of
                                                        sat_sgATS
                                                        { __DEFAULT ->
                                                              case
                                                                  negateFloat# [sat_sgATS]
                                                              of
                                                              dt1_sgATQ [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        fabsFloat# [dt_sgATN]
                                                                    of
                                                                    sat_sgAU0
                                                                    { __DEFAULT ->
                                                                          let-no-escape {
                                                                            $j_sgATT [Occ=Once*T[0],
                                                                                      Dmd=<L,1*U(U,U)>]
                                                                              :: Data.Complex.Complex
                                                                                   GHC.Types.Float
                                                                            [LclId[JoinId(0)],
                                                                             Str=m,
                                                                             Unf=OtherCon []] =
                                                                                [dt_sgATN
                                                                                 dt1_sgATQ] \r []
                                                                                    case
                                                                                        plusFloat# [1.0#
                                                                                                    dt_sgATN]
                                                                                    of
                                                                                    dt2_sgATU [Dmd=<S,U>]
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$smagnitude1
                                                                                                  dt2_sgATU
                                                                                                  dt1_sgATQ
                                                                                          of
                                                                                          ww_sgATV
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    logFloat# [ww_sgATV]
                                                                                                of
                                                                                                wild3_sgATW
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          Data.Complex.$w$sphase1
                                                                                                              dt2_sgATU
                                                                                                              dt1_sgATQ
                                                                                                      of
                                                                                                      ww1_sgATX
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgATZ [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [ww1_sgATX]; } in
                                                                                                            let {
                                                                                                              sat_sgATY [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [wild3_sgATW];
                                                                                                            } in 
                                                                                                              Data.Complex.:+ [sat_sgATY
                                                                                                                               sat_sgATZ];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                          } in 
                                                                            case
                                                                                ltFloat# [sat_sgAU0
                                                                                          0.5#]
                                                                            of
                                                                            { __DEFAULT -> $j_sgATT;
                                                                              1# ->
                                                                                  case
                                                                                      fabsFloat# [dt1_sgATQ]
                                                                                  of
                                                                                  sat_sgAU2
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            ltFloat# [sat_sgAU2
                                                                                                      0.5#]
                                                                                        of
                                                                                        { __DEFAULT ->
                                                                                              $j_sgATT;
                                                                                          1# ->
                                                                                              case
                                                                                                  timesFloat# [dt1_sgATQ
                                                                                                               dt1_sgATQ]
                                                                                              of
                                                                                              sat_sgAU8
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        timesFloat# [dt_sgATN
                                                                                                                     dt_sgATN]
                                                                                                    of
                                                                                                    sat_sgAU6
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              plusFloat# [dt_sgATN
                                                                                                                          dt_sgATN]
                                                                                                          of
                                                                                                          sat_sgAU5
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    plusFloat# [sat_sgAU5
                                                                                                                                sat_sgAU6]
                                                                                                                of
                                                                                                                sat_sgAU7
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          plusFloat# [sat_sgAU7
                                                                                                                                      sat_sgAU8]
                                                                                                                      of
                                                                                                                      u_sgAU4 [Dmd=<S,U>]
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                plusFloat# [u_sgAU4
                                                                                                                                            1.0#]
                                                                                                                            of
                                                                                                                            sat_sgAU9
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sqrtFloat# [sat_sgAU9]
                                                                                                                                  of
                                                                                                                                  sat_sgAUa
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            plusFloat# [1.0#
                                                                                                                                                        sat_sgAUa]
                                                                                                                                        of
                                                                                                                                        sat_sgAUb
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              case
                                                                                                                                                  divideFloat# [u_sgAU4
                                                                                                                                                                sat_sgAUb]
                                                                                                                                              of
                                                                                                                                              wild3_sgAUc
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    case
                                                                                                                                                        __pkg_ccall base-4.11.0.0 [wild3_sgAUc
                                                                                                                                                                                   GHC.Prim.realWorld#]
                                                                                                                                                    of
                                                                                                                                                    { Unit# ds4_sgAUg [Occ=Once] ->
                                                                                                                                                          case
                                                                                                                                                              plusFloat# [1.0#
                                                                                                                                                                          dt_sgATN]
                                                                                                                                                          of
                                                                                                                                                          sat_sgAUh
                                                                                                                                                          { __DEFAULT ->
                                                                                                                                                                let {
                                                                                                                                                                  sat_sgAUi [Occ=Once]
                                                                                                                                                                    :: GHC.Types.Float
                                                                                                                                                                  [LclId] =
                                                                                                                                                                      CCCS GHC.Types.F#! [sat_sgAUh];
                                                                                                                                                                } in 
                                                                                                                                                                  case
                                                                                                                                                                      GHC.Float.$w$catan1
                                                                                                                                                                          sat_sgAUi
                                                                                                                                                                          dt1_sgATQ
                                                                                                                                                                  of
                                                                                                                                                                  ww2_sgAUj
                                                                                                                                                                  { __DEFAULT ->
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgAUl [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Float
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.F#! [ww2_sgAUj]; } in
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgAUk [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Float
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.F#! [ds4_sgAUg];
                                                                                                                                                                        } in 
                                                                                                                                                                          Data.Complex.:+ [sat_sgAUk
                                                                                                                                                                                           sat_sgAUl];
                                                                                                                                                                  };
                                                                                                                                                          };
                                                                                                                                                    };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAUm]
        case eta_sgAUm of {
          Data.Complex.:+ x_sgAUo [Occ=Once!] y_sgAUp [Occ=Once!] ->
              case x_sgAUo of {
                GHC.Types.D# x1_sgAUr [Occ=Once] ->
                    case y_sgAUp of {
                      GHC.Types.D# x2_sgAUt ->
                          case expDouble# [x1_sgAUr] of expx_sgAUu [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosDouble# [x2_sgAUt] of sat_sgAUw {
                                  __DEFAULT ->
                                      case *## [expx_sgAUu sat_sgAUw] of sat_sgAUx {
                                        __DEFAULT ->
                                            case negateDouble# [sat_sgAUx] of dt_sgAUv [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case sinDouble# [x2_sgAUt] of sat_sgAUz {
                                                    __DEFAULT ->
                                                        case
                                                            *## [expx_sgAUu sat_sgAUz]
                                                        of
                                                        sat_sgAUA
                                                        { __DEFAULT ->
                                                              case
                                                                  negateDouble# [sat_sgAUA]
                                                              of
                                                              dt1_sgAUy [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        fabsDouble# [dt_sgAUv]
                                                                    of
                                                                    sat_sgAUI
                                                                    { __DEFAULT ->
                                                                          let-no-escape {
                                                                            $j_sgAUB [Occ=Once*T[0],
                                                                                      Dmd=<L,1*U(U,U)>]
                                                                              :: Data.Complex.Complex
                                                                                   GHC.Types.Double
                                                                            [LclId[JoinId(0)],
                                                                             Str=m,
                                                                             Unf=OtherCon []] =
                                                                                [dt_sgAUv
                                                                                 dt1_sgAUy] \r []
                                                                                    case
                                                                                        +## [1.0##
                                                                                             dt_sgAUv]
                                                                                    of
                                                                                    dt2_sgAUC [Dmd=<S,U>]
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$smagnitude
                                                                                                  dt2_sgAUC
                                                                                                  dt1_sgAUy
                                                                                          of
                                                                                          ww_sgAUD
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    logDouble# [ww_sgAUD]
                                                                                                of
                                                                                                wild3_sgAUE
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          Data.Complex.$w$sphase
                                                                                                              dt2_sgAUC
                                                                                                              dt1_sgAUy
                                                                                                      of
                                                                                                      ww1_sgAUF
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgAUH [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [ww1_sgAUF]; } in
                                                                                                            let {
                                                                                                              sat_sgAUG [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [wild3_sgAUE];
                                                                                                            } in 
                                                                                                              Data.Complex.:+ [sat_sgAUG
                                                                                                                               sat_sgAUH];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                          } in 
                                                                            case
                                                                                <## [sat_sgAUI
                                                                                     0.5##]
                                                                            of
                                                                            { __DEFAULT -> $j_sgAUB;
                                                                              1# ->
                                                                                  case
                                                                                      fabsDouble# [dt1_sgAUy]
                                                                                  of
                                                                                  sat_sgAUK
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            <## [sat_sgAUK
                                                                                                 0.5##]
                                                                                        of
                                                                                        { __DEFAULT ->
                                                                                              $j_sgAUB;
                                                                                          1# ->
                                                                                              case
                                                                                                  *## [dt1_sgAUy
                                                                                                       dt1_sgAUy]
                                                                                              of
                                                                                              sat_sgAUQ
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        *## [dt_sgAUv
                                                                                                             dt_sgAUv]
                                                                                                    of
                                                                                                    sat_sgAUO
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              +## [dt_sgAUv
                                                                                                                   dt_sgAUv]
                                                                                                          of
                                                                                                          sat_sgAUN
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    +## [sat_sgAUN
                                                                                                                         sat_sgAUO]
                                                                                                                of
                                                                                                                sat_sgAUP
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          +## [sat_sgAUP
                                                                                                                               sat_sgAUQ]
                                                                                                                      of
                                                                                                                      u_sgAUM [Dmd=<S,U>]
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                +## [u_sgAUM
                                                                                                                                     1.0##]
                                                                                                                            of
                                                                                                                            sat_sgAUR
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sqrtDouble# [sat_sgAUR]
                                                                                                                                  of
                                                                                                                                  sat_sgAUS
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            +## [1.0##
                                                                                                                                                 sat_sgAUS]
                                                                                                                                        of
                                                                                                                                        sat_sgAUT
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              case
                                                                                                                                                  /## [u_sgAUM
                                                                                                                                                       sat_sgAUT]
                                                                                                                                              of
                                                                                                                                              wild3_sgAUU
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    case
                                                                                                                                                        __pkg_ccall base-4.11.0.0 [wild3_sgAUU
                                                                                                                                                                                   GHC.Prim.realWorld#]
                                                                                                                                                    of
                                                                                                                                                    { Unit# ds4_sgAUY [Occ=Once] ->
                                                                                                                                                          case
                                                                                                                                                              +## [1.0##
                                                                                                                                                                   dt_sgAUv]
                                                                                                                                                          of
                                                                                                                                                          sat_sgAUZ
                                                                                                                                                          { __DEFAULT ->
                                                                                                                                                                let {
                                                                                                                                                                  sat_sgAV0 [Occ=Once]
                                                                                                                                                                    :: GHC.Types.Double
                                                                                                                                                                  [LclId] =
                                                                                                                                                                      CCCS GHC.Types.D#! [sat_sgAUZ];
                                                                                                                                                                } in 
                                                                                                                                                                  case
                                                                                                                                                                      GHC.Float.$w$catan2
                                                                                                                                                                          sat_sgAV0
                                                                                                                                                                          dt1_sgAUy
                                                                                                                                                                  of
                                                                                                                                                                  ww2_sgAV1
                                                                                                                                                                  { __DEFAULT ->
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgAV3 [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Double
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.D#! [ww2_sgAV1]; } in
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgAV2 [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Double
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.D#! [ds4_sgAUY];
                                                                                                                                                                        } in 
                                                                                                                                                                          Data.Complex.:+ [sat_sgAV2
                                                                                                                                                                                           sat_sgAV3];
                                                                                                                                                                  };
                                                                                                                                                          };
                                                                                                                                                    };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)S(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgAV4 eta_sgAV5]
        case eta_sgAV5 of {
          Data.Complex.:+ ww1_sgAV7 [Occ=Once] ww2_sgAV8 [Occ=Once] ->
              case
                  Data.Complex.$w$cexp $dRealFloat_sgAV4 ww1_sgAV7 ww2_sgAV8
              of
              { (#,#) ww4_sgAVa [Occ=Once] ww5_sgAVb [Occ=Once] ->
                    case
                        Data.Complex.$w$cnegate $dRealFloat_sgAV4 ww4_sgAVa ww5_sgAVb
                    of
                    { (#,#) ww7_sgAVd ww8_sgAVe ->
                          case
                              GHC.Float.$p1RealFloat $dRealFloat_sgAV4
                          of
                          $dRealFrac_sgAVf [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
                          { __DEFAULT ->
                                case
                                    GHC.Real.$p1RealFrac $dRealFrac_sgAVf
                                of
                                $dReal_sgAVg [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
                                { __DEFAULT ->
                                      let {
                                        $dNum_sgAVh [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
                                          :: GHC.Num.Num a_agsO1
                                        [LclId] =
                                            [$dReal_sgAVg] \u [] GHC.Real.$p1Real $dReal_sgAVg;
                                      } in 
                                        case
                                            GHC.Real.$p2Real $dReal_sgAVg
                                        of
                                        $dOrd_sgAVi [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                                        { __DEFAULT ->
                                              let {
                                                $dFractional_sgAVj [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
                                                  :: GHC.Real.Fractional a_agsO1
                                                [LclId] =
                                                    [$dRealFrac_sgAVf] \u []
                                                        GHC.Real.$p2RealFrac $dRealFrac_sgAVf; } in
                                              let {
                                                sat_sgAVl [Occ=Once] :: a_agsO1
                                                [LclId] =
                                                    [$dFractional_sgAVj] \u []
                                                        GHC.Real.fromRational
                                                            $dFractional_sgAVj
                                                            Data.Complex.$fFloatingComplex20; } in
                                              let {
                                                sat_sgAVk [Occ=Once] :: a_agsO1
                                                [LclId] =
                                                    [ww7_sgAVd $dNum_sgAVh] \u []
                                                        GHC.Num.abs $dNum_sgAVh ww7_sgAVd;
                                              } in 
                                                case
                                                    GHC.Classes.< $dOrd_sgAVi sat_sgAVk sat_sgAVl
                                                of
                                                { GHC.Types.False ->
                                                      case
                                                          Data.Complex.$w$cfromInteger
                                                              $dRealFloat_sgAV4
                                                              Data.Complex.$fFloatingComplex19
                                                      of
                                                      { (#,#) ww10_sgAVo [Occ=Once]
                                                              ww11_sgAVp [Occ=Once] ->
                                                            case
                                                                Data.Complex.$w$c+
                                                                    $dRealFloat_sgAV4
                                                                    ww10_sgAVo
                                                                    ww11_sgAVp
                                                                    ww7_sgAVd
                                                                    ww8_sgAVe
                                                            of
                                                            { (#,#) ww13_sgAVr [Occ=Once]
                                                                    ww14_sgAVs [Occ=Once] ->
                                                                  case
                                                                      Data.Complex.$w$clog
                                                                          $dRealFloat_sgAV4
                                                                          ww13_sgAVr
                                                                          ww14_sgAVs
                                                                  of
                                                                  { (#,#) ww16_sgAVu [Occ=Once]
                                                                          ww17_sgAVv [Occ=Once] ->
                                                                        Data.Complex.:+ [ww16_sgAVu
                                                                                         ww17_sgAVv];
                                                                  };
                                                            };
                                                      };
                                                  GHC.Types.True ->
                                                      let {
                                                        sat_sgAVx [Occ=Once] :: a_agsO1
                                                        [LclId] =
                                                            [$dFractional_sgAVj] \u []
                                                                GHC.Real.fromRational
                                                                    $dFractional_sgAVj
                                                                    Data.Complex.$fFloatingComplex20; } in
                                                      let {
                                                        sat_sgAVw [Occ=Once] :: a_agsO1
                                                        [LclId] =
                                                            [ww8_sgAVe $dNum_sgAVh] \u []
                                                                GHC.Num.abs $dNum_sgAVh ww8_sgAVe;
                                                      } in 
                                                        case
                                                            GHC.Classes.<
                                                                $dOrd_sgAVi sat_sgAVw sat_sgAVx
                                                        of
                                                        { GHC.Types.False ->
                                                              case
                                                                  Data.Complex.$w$cfromInteger
                                                                      $dRealFloat_sgAV4
                                                                      Data.Complex.$fFloatingComplex19
                                                              of
                                                              { (#,#) ww10_sgAVA [Occ=Once]
                                                                      ww11_sgAVB [Occ=Once] ->
                                                                    case
                                                                        Data.Complex.$w$c+
                                                                            $dRealFloat_sgAV4
                                                                            ww10_sgAVA
                                                                            ww11_sgAVB
                                                                            ww7_sgAVd
                                                                            ww8_sgAVe
                                                                    of
                                                                    { (#,#) ww13_sgAVD [Occ=Once]
                                                                            ww14_sgAVE [Occ=Once] ->
                                                                          case
                                                                              Data.Complex.$w$clog
                                                                                  $dRealFloat_sgAV4
                                                                                  ww13_sgAVD
                                                                                  ww14_sgAVE
                                                                          of
                                                                          { (#,#) ww16_sgAVG [Occ=Once]
                                                                                  ww17_sgAVH [Occ=Once] ->
                                                                                Data.Complex.:+ [ww16_sgAVG
                                                                                                 ww17_sgAVH];
                                                                          };
                                                                    };
                                                              };
                                                          GHC.Types.True ->
                                                              case
                                                                  GHC.Float.$p2RealFloat
                                                                      $dRealFloat_sgAV4
                                                              of
                                                              $dFloating_sgAVI [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                                                              { __DEFAULT ->
                                                                    let {
                                                                      sat_sgAVU [Occ=Once]
                                                                        :: a_agsO1
                                                                      [LclId] =
                                                                          [ww7_sgAVd
                                                                           ww8_sgAVe
                                                                           $dNum_sgAVh
                                                                           $dFractional_sgAVj
                                                                           $dFloating_sgAVI] \u []
                                                                              let {
                                                                                u_sgAVJ :: a_agsO1
                                                                                [LclId] =
                                                                                    [ww7_sgAVd
                                                                                     ww8_sgAVe
                                                                                     $dNum_sgAVh] \u []
                                                                                        let {
                                                                                          sat_sgAVO [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [ww8_sgAVe
                                                                                               $dNum_sgAVh] \u []
                                                                                                  GHC.Num.*
                                                                                                      $dNum_sgAVh
                                                                                                      ww8_sgAVe
                                                                                                      ww8_sgAVe; } in
                                                                                        let {
                                                                                          sat_sgAVN [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [ww7_sgAVd
                                                                                               $dNum_sgAVh] \u []
                                                                                                  let {
                                                                                                    sat_sgAVM [Occ=Once]
                                                                                                      :: a_agsO1
                                                                                                    [LclId] =
                                                                                                        [ww7_sgAVd
                                                                                                         $dNum_sgAVh] \u []
                                                                                                            GHC.Num.*
                                                                                                                $dNum_sgAVh
                                                                                                                ww7_sgAVd
                                                                                                                ww7_sgAVd; } in
                                                                                                  let {
                                                                                                    sat_sgAVL [Occ=Once]
                                                                                                      :: a_agsO1
                                                                                                    [LclId] =
                                                                                                        [ww7_sgAVd
                                                                                                         $dNum_sgAVh] \u []
                                                                                                            let {
                                                                                                              sat_sgAVK [Occ=Once]
                                                                                                                :: a_agsO1
                                                                                                              [LclId] =
                                                                                                                  [$dNum_sgAVh] \u []
                                                                                                                      GHC.Num.fromInteger
                                                                                                                          $dNum_sgAVh
                                                                                                                          Data.Complex.$fFloatingComplex21;
                                                                                                            } in 
                                                                                                              GHC.Num.*
                                                                                                                  $dNum_sgAVh
                                                                                                                  sat_sgAVK
                                                                                                                  ww7_sgAVd;
                                                                                                  } in 
                                                                                                    GHC.Num.+
                                                                                                        $dNum_sgAVh
                                                                                                        sat_sgAVL
                                                                                                        sat_sgAVM;
                                                                                        } in 
                                                                                          GHC.Num.+
                                                                                              $dNum_sgAVh
                                                                                              sat_sgAVN
                                                                                              sat_sgAVO; } in
                                                                              let {
                                                                                sat_sgAVT [Occ=Once]
                                                                                  :: a_agsO1
                                                                                [LclId] =
                                                                                    [$dNum_sgAVh
                                                                                     $dFloating_sgAVI
                                                                                     u_sgAVJ] \u []
                                                                                        let {
                                                                                          sat_sgAVS [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [$dNum_sgAVh
                                                                                               $dFloating_sgAVI
                                                                                               u_sgAVJ] \u []
                                                                                                  let {
                                                                                                    sat_sgAVR [Occ=Once]
                                                                                                      :: a_agsO1
                                                                                                    [LclId] =
                                                                                                        [$dNum_sgAVh
                                                                                                         u_sgAVJ] \u []
                                                                                                            let {
                                                                                                              sat_sgAVQ [Occ=Once]
                                                                                                                :: a_agsO1
                                                                                                              [LclId] =
                                                                                                                  [$dNum_sgAVh] \u []
                                                                                                                      GHC.Num.fromInteger
                                                                                                                          $dNum_sgAVh
                                                                                                                          Data.Complex.$fFloatingComplex19;
                                                                                                            } in 
                                                                                                              GHC.Num.+
                                                                                                                  $dNum_sgAVh
                                                                                                                  u_sgAVJ
                                                                                                                  sat_sgAVQ;
                                                                                                  } in 
                                                                                                    GHC.Float.sqrt
                                                                                                        $dFloating_sgAVI
                                                                                                        sat_sgAVR; } in
                                                                                        let {
                                                                                          sat_sgAVP [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [$dNum_sgAVh] \u []
                                                                                                  GHC.Num.fromInteger
                                                                                                      $dNum_sgAVh
                                                                                                      Data.Complex.$fFloatingComplex19;
                                                                                        } in 
                                                                                          GHC.Num.+
                                                                                              $dNum_sgAVh
                                                                                              sat_sgAVP
                                                                                              sat_sgAVS;
                                                                              } in 
                                                                                GHC.Real./
                                                                                    $dFractional_sgAVj
                                                                                    u_sgAVJ
                                                                                    sat_sgAVT;
                                                                    } in 
                                                                      case
                                                                          GHC.Float.log1p
                                                                              $dFloating_sgAVI
                                                                              sat_sgAVU
                                                                      of
                                                                      dt_sgAVV
                                                                      { __DEFAULT ->
                                                                            let {
                                                                              sat_sgAVX [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [ww7_sgAVd
                                                                                   $dNum_sgAVh] \u []
                                                                                      let {
                                                                                        sat_sgAVW [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [$dNum_sgAVh] \u []
                                                                                                GHC.Num.fromInteger
                                                                                                    $dNum_sgAVh
                                                                                                    Data.Complex.$fFloatingComplex19;
                                                                                      } in 
                                                                                        GHC.Num.+
                                                                                            $dNum_sgAVh
                                                                                            sat_sgAVW
                                                                                            ww7_sgAVd;
                                                                            } in 
                                                                              case
                                                                                  GHC.Float.atan2
                                                                                      $dRealFloat_sgAV4
                                                                                      sat_sgAVX
                                                                                      ww8_sgAVe
                                                                              of
                                                                              dt1_sgAVY
                                                                              { __DEFAULT ->
                                                                                    Data.Complex.:+ [dt_sgAVV
                                                                                                     dt1_sgAVY];
                                                                              };
                                                                      };
                                                              };
                                                        };
                                                };
                                        };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1pexp1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAVZ]
        case eta_sgAVZ of {
          Data.Complex.:+ x_sgAW1 [Occ=Once!] y_sgAW2 [Occ=Once!] ->
              case x_sgAW1 of {
                GHC.Types.F# x1_sgAW4 [Occ=Once] ->
                    case y_sgAW2 of {
                      GHC.Types.F# x2_sgAW6 ->
                          case expFloat# [x1_sgAW4] of expx_sgAW7 [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosFloat# [x2_sgAW6] of sat_sgAW9 {
                                  __DEFAULT ->
                                      case
                                          timesFloat# [expx_sgAW7 sat_sgAW9]
                                      of
                                      a_sgAW8 [Dmd=<S,U>]
                                      { __DEFAULT ->
                                            case sinFloat# [x2_sgAW6] of sat_sgAWb {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [expx_sgAW7 sat_sgAWb]
                                                  of
                                                  b_sgAWa [Dmd=<S,U>]
                                                  { __DEFAULT ->
                                                        case fabsFloat# [a_sgAW8] of sat_sgAWj {
                                                          __DEFAULT ->
                                                              let-no-escape {
                                                                $j_sgAWc [Occ=Once*T[0],
                                                                          Dmd=<L,1*U(U,U)>]
                                                                  :: Data.Complex.Complex
                                                                       GHC.Types.Float
                                                                [LclId[JoinId(0)],
                                                                 Str=m,
                                                                 Unf=OtherCon []] =
                                                                    [a_sgAW8 b_sgAWa] \r []
                                                                        case
                                                                            plusFloat# [1.0#
                                                                                        a_sgAW8]
                                                                        of
                                                                        dt_sgAWd [Dmd=<S,U>]
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  Data.Complex.$w$smagnitude1
                                                                                      dt_sgAWd
                                                                                      b_sgAWa
                                                                              of
                                                                              ww_sgAWe
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        logFloat# [ww_sgAWe]
                                                                                    of
                                                                                    wild3_sgAWf
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$sphase1
                                                                                                  dt_sgAWd
                                                                                                  b_sgAWa
                                                                                          of
                                                                                          ww1_sgAWg
                                                                                          { __DEFAULT ->
                                                                                                let {
                                                                                                  sat_sgAWi [Occ=Once]
                                                                                                    :: GHC.Types.Float
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.F#! [ww1_sgAWg]; } in
                                                                                                let {
                                                                                                  sat_sgAWh [Occ=Once]
                                                                                                    :: GHC.Types.Float
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.F#! [wild3_sgAWf];
                                                                                                } in 
                                                                                                  Data.Complex.:+ [sat_sgAWh
                                                                                                                   sat_sgAWi];
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                              } in 
                                                                case ltFloat# [sat_sgAWj 0.5#] of {
                                                                  __DEFAULT -> $j_sgAWc;
                                                                  1# ->
                                                                      case
                                                                          fabsFloat# [b_sgAWa]
                                                                      of
                                                                      sat_sgAWl
                                                                      { __DEFAULT ->
                                                                            case
                                                                                ltFloat# [sat_sgAWl
                                                                                          0.5#]
                                                                            of
                                                                            { __DEFAULT -> $j_sgAWc;
                                                                              1# ->
                                                                                  case
                                                                                      timesFloat# [b_sgAWa
                                                                                                   b_sgAWa]
                                                                                  of
                                                                                  sat_sgAWr
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            timesFloat# [a_sgAW8
                                                                                                         a_sgAW8]
                                                                                        of
                                                                                        sat_sgAWp
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  plusFloat# [a_sgAW8
                                                                                                              a_sgAW8]
                                                                                              of
                                                                                              sat_sgAWo
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        plusFloat# [sat_sgAWo
                                                                                                                    sat_sgAWp]
                                                                                                    of
                                                                                                    sat_sgAWq
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              plusFloat# [sat_sgAWq
                                                                                                                          sat_sgAWr]
                                                                                                          of
                                                                                                          u_sgAWn [Dmd=<S,U>]
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    plusFloat# [u_sgAWn
                                                                                                                                1.0#]
                                                                                                                of
                                                                                                                sat_sgAWs
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          sqrtFloat# [sat_sgAWs]
                                                                                                                      of
                                                                                                                      sat_sgAWt
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                plusFloat# [1.0#
                                                                                                                                            sat_sgAWt]
                                                                                                                            of
                                                                                                                            sat_sgAWu
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      divideFloat# [u_sgAWn
                                                                                                                                                    sat_sgAWu]
                                                                                                                                  of
                                                                                                                                  wild3_sgAWv
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            __pkg_ccall base-4.11.0.0 [wild3_sgAWv
                                                                                                                                                                       GHC.Prim.realWorld#]
                                                                                                                                        of
                                                                                                                                        { Unit# ds4_sgAWz [Occ=Once] ->
                                                                                                                                              case
                                                                                                                                                  plusFloat# [1.0#
                                                                                                                                                              a_sgAW8]
                                                                                                                                              of
                                                                                                                                              sat_sgAWA
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    let {
                                                                                                                                                      sat_sgAWB [Occ=Once]
                                                                                                                                                        :: GHC.Types.Float
                                                                                                                                                      [LclId] =
                                                                                                                                                          CCCS GHC.Types.F#! [sat_sgAWA];
                                                                                                                                                    } in 
                                                                                                                                                      case
                                                                                                                                                          GHC.Float.$w$catan1
                                                                                                                                                              sat_sgAWB
                                                                                                                                                              b_sgAWa
                                                                                                                                                      of
                                                                                                                                                      ww2_sgAWC
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgAWE [Occ=Once]
                                                                                                                                                                :: GHC.Types.Float
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.F#! [ww2_sgAWC]; } in
                                                                                                                                                            let {
                                                                                                                                                              sat_sgAWD [Occ=Once]
                                                                                                                                                                :: GHC.Types.Float
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.F#! [ds4_sgAWz];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgAWD
                                                                                                                                                                               sat_sgAWE];
                                                                                                                                                      };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAWF]
        case eta_sgAWF of {
          Data.Complex.:+ x_sgAWH [Occ=Once!] y_sgAWI [Occ=Once!] ->
              case x_sgAWH of {
                GHC.Types.D# x1_sgAWK [Occ=Once] ->
                    case y_sgAWI of {
                      GHC.Types.D# x2_sgAWM ->
                          case expDouble# [x1_sgAWK] of expx_sgAWN [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosDouble# [x2_sgAWM] of sat_sgAWP {
                                  __DEFAULT ->
                                      case *## [expx_sgAWN sat_sgAWP] of a_sgAWO [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinDouble# [x2_sgAWM] of sat_sgAWR {
                                              __DEFAULT ->
                                                  case
                                                      *## [expx_sgAWN sat_sgAWR]
                                                  of
                                                  b_sgAWQ [Dmd=<S,U>]
                                                  { __DEFAULT ->
                                                        case fabsDouble# [a_sgAWO] of sat_sgAWZ {
                                                          __DEFAULT ->
                                                              let-no-escape {
                                                                $j_sgAWS [Occ=Once*T[0],
                                                                          Dmd=<L,1*U(U,U)>]
                                                                  :: Data.Complex.Complex
                                                                       GHC.Types.Double
                                                                [LclId[JoinId(0)],
                                                                 Str=m,
                                                                 Unf=OtherCon []] =
                                                                    [a_sgAWO b_sgAWQ] \r []
                                                                        case
                                                                            +## [1.0## a_sgAWO]
                                                                        of
                                                                        dt_sgAWT [Dmd=<S,U>]
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  Data.Complex.$w$smagnitude
                                                                                      dt_sgAWT
                                                                                      b_sgAWQ
                                                                              of
                                                                              ww_sgAWU
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        logDouble# [ww_sgAWU]
                                                                                    of
                                                                                    wild3_sgAWV
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$sphase
                                                                                                  dt_sgAWT
                                                                                                  b_sgAWQ
                                                                                          of
                                                                                          ww1_sgAWW
                                                                                          { __DEFAULT ->
                                                                                                let {
                                                                                                  sat_sgAWY [Occ=Once]
                                                                                                    :: GHC.Types.Double
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.D#! [ww1_sgAWW]; } in
                                                                                                let {
                                                                                                  sat_sgAWX [Occ=Once]
                                                                                                    :: GHC.Types.Double
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.D#! [wild3_sgAWV];
                                                                                                } in 
                                                                                                  Data.Complex.:+ [sat_sgAWX
                                                                                                                   sat_sgAWY];
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                              } in 
                                                                case <## [sat_sgAWZ 0.5##] of {
                                                                  __DEFAULT -> $j_sgAWS;
                                                                  1# ->
                                                                      case
                                                                          fabsDouble# [b_sgAWQ]
                                                                      of
                                                                      sat_sgAX1
                                                                      { __DEFAULT ->
                                                                            case
                                                                                <## [sat_sgAX1
                                                                                     0.5##]
                                                                            of
                                                                            { __DEFAULT -> $j_sgAWS;
                                                                              1# ->
                                                                                  case
                                                                                      *## [b_sgAWQ
                                                                                           b_sgAWQ]
                                                                                  of
                                                                                  sat_sgAX7
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            *## [a_sgAWO
                                                                                                 a_sgAWO]
                                                                                        of
                                                                                        sat_sgAX5
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  +## [a_sgAWO
                                                                                                       a_sgAWO]
                                                                                              of
                                                                                              sat_sgAX4
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        +## [sat_sgAX4
                                                                                                             sat_sgAX5]
                                                                                                    of
                                                                                                    sat_sgAX6
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              +## [sat_sgAX6
                                                                                                                   sat_sgAX7]
                                                                                                          of
                                                                                                          u_sgAX3 [Dmd=<S,U>]
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    +## [u_sgAX3
                                                                                                                         1.0##]
                                                                                                                of
                                                                                                                sat_sgAX8
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          sqrtDouble# [sat_sgAX8]
                                                                                                                      of
                                                                                                                      sat_sgAX9
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                +## [1.0##
                                                                                                                                     sat_sgAX9]
                                                                                                                            of
                                                                                                                            sat_sgAXa
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      /## [u_sgAX3
                                                                                                                                           sat_sgAXa]
                                                                                                                                  of
                                                                                                                                  wild3_sgAXb
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            __pkg_ccall base-4.11.0.0 [wild3_sgAXb
                                                                                                                                                                       GHC.Prim.realWorld#]
                                                                                                                                        of
                                                                                                                                        { Unit# ds4_sgAXf [Occ=Once] ->
                                                                                                                                              case
                                                                                                                                                  +## [1.0##
                                                                                                                                                       a_sgAWO]
                                                                                                                                              of
                                                                                                                                              sat_sgAXg
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    let {
                                                                                                                                                      sat_sgAXh [Occ=Once]
                                                                                                                                                        :: GHC.Types.Double
                                                                                                                                                      [LclId] =
                                                                                                                                                          CCCS GHC.Types.D#! [sat_sgAXg];
                                                                                                                                                    } in 
                                                                                                                                                      case
                                                                                                                                                          GHC.Float.$w$catan2
                                                                                                                                                              sat_sgAXh
                                                                                                                                                              b_sgAWQ
                                                                                                                                                      of
                                                                                                                                                      ww2_sgAXi
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgAXk [Occ=Once]
                                                                                                                                                                :: GHC.Types.Double
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.D#! [ww2_sgAXi]; } in
                                                                                                                                                            let {
                                                                                                                                                              sat_sgAXj [Occ=Once]
                                                                                                                                                                :: GHC.Types.Double
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.D#! [ds4_sgAXf];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgAXj
                                                                                                                                                                               sat_sgAXk];
                                                                                                                                                      };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLC(C(S))LLLL)S(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgAXl eta_sgAXm]
        case eta_sgAXm of {
          Data.Complex.:+ ww1_sgAXo [Occ=Once] ww2_sgAXp [Occ=Once] ->
              case
                  Data.Complex.$w$cexp $dRealFloat_sgAXl ww1_sgAXo ww2_sgAXp
              of
              { (#,#) ww4_sgAXr ww5_sgAXs ->
                    case
                        GHC.Float.$p1RealFloat $dRealFloat_sgAXl
                    of
                    $dRealFrac_sgAXt [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
                    { __DEFAULT ->
                          case
                              GHC.Real.$p1RealFrac $dRealFrac_sgAXt
                          of
                          $dReal_sgAXu [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
                          { __DEFAULT ->
                                let {
                                  $dNum_sgAXv [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
                                    :: GHC.Num.Num a_agsO1
                                  [LclId] =
                                      [$dReal_sgAXu] \u [] GHC.Real.$p1Real $dReal_sgAXu;
                                } in 
                                  case
                                      GHC.Real.$p2Real $dReal_sgAXu
                                  of
                                  $dOrd_sgAXw [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                                  { __DEFAULT ->
                                        let {
                                          $dFractional_sgAXx [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
                                            :: GHC.Real.Fractional a_agsO1
                                          [LclId] =
                                              [$dRealFrac_sgAXt] \u []
                                                  GHC.Real.$p2RealFrac $dRealFrac_sgAXt; } in
                                        let {
                                          sat_sgAXz [Occ=Once] :: a_agsO1
                                          [LclId] =
                                              [$dFractional_sgAXx] \u []
                                                  GHC.Real.fromRational
                                                      $dFractional_sgAXx
                                                      Data.Complex.$fFloatingComplex20; } in
                                        let {
                                          sat_sgAXy [Occ=Once] :: a_agsO1
                                          [LclId] =
                                              [ww4_sgAXr $dNum_sgAXv] \u []
                                                  GHC.Num.abs $dNum_sgAXv ww4_sgAXr;
                                        } in 
                                          case GHC.Classes.< $dOrd_sgAXw sat_sgAXy sat_sgAXz of {
                                            GHC.Types.False ->
                                                case
                                                    Data.Complex.$w$cfromInteger
                                                        $dRealFloat_sgAXl
                                                        Data.Complex.$fFloatingComplex19
                                                of
                                                { (#,#) ww7_sgAXC [Occ=Once] ww8_sgAXD [Occ=Once] ->
                                                      case
                                                          Data.Complex.$w$c+
                                                              $dRealFloat_sgAXl
                                                              ww7_sgAXC
                                                              ww8_sgAXD
                                                              ww4_sgAXr
                                                              ww5_sgAXs
                                                      of
                                                      { (#,#) ww10_sgAXF [Occ=Once]
                                                              ww11_sgAXG [Occ=Once] ->
                                                            case
                                                                Data.Complex.$w$clog
                                                                    $dRealFloat_sgAXl
                                                                    ww10_sgAXF
                                                                    ww11_sgAXG
                                                            of
                                                            { (#,#) ww13_sgAXI [Occ=Once]
                                                                    ww14_sgAXJ [Occ=Once] ->
                                                                  Data.Complex.:+ [ww13_sgAXI
                                                                                   ww14_sgAXJ];
                                                            };
                                                      };
                                                };
                                            GHC.Types.True ->
                                                let {
                                                  sat_sgAXL [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [$dFractional_sgAXx] \u []
                                                          GHC.Real.fromRational
                                                              $dFractional_sgAXx
                                                              Data.Complex.$fFloatingComplex20; } in
                                                let {
                                                  sat_sgAXK [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [ww5_sgAXs $dNum_sgAXv] \u []
                                                          GHC.Num.abs $dNum_sgAXv ww5_sgAXs;
                                                } in 
                                                  case
                                                      GHC.Classes.< $dOrd_sgAXw sat_sgAXK sat_sgAXL
                                                  of
                                                  { GHC.Types.False ->
                                                        case
                                                            Data.Complex.$w$cfromInteger
                                                                $dRealFloat_sgAXl
                                                                Data.Complex.$fFloatingComplex19
                                                        of
                                                        { (#,#) ww7_sgAXO [Occ=Once]
                                                                ww8_sgAXP [Occ=Once] ->
                                                              case
                                                                  Data.Complex.$w$c+
                                                                      $dRealFloat_sgAXl
                                                                      ww7_sgAXO
                                                                      ww8_sgAXP
                                                                      ww4_sgAXr
                                                                      ww5_sgAXs
                                                              of
                                                              { (#,#) ww10_sgAXR [Occ=Once]
                                                                      ww11_sgAXS [Occ=Once] ->
                                                                    case
                                                                        Data.Complex.$w$clog
                                                                            $dRealFloat_sgAXl
                                                                            ww10_sgAXR
                                                                            ww11_sgAXS
                                                                    of
                                                                    { (#,#) ww13_sgAXU [Occ=Once]
                                                                            ww14_sgAXV [Occ=Once] ->
                                                                          Data.Complex.:+ [ww13_sgAXU
                                                                                           ww14_sgAXV];
                                                                    };
                                                              };
                                                        };
                                                    GHC.Types.True ->
                                                        case
                                                            GHC.Float.$p2RealFloat $dRealFloat_sgAXl
                                                        of
                                                        $dFloating_sgAXW [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_sgAY8 [Occ=Once] :: a_agsO1
                                                                [LclId] =
                                                                    [ww4_sgAXr
                                                                     ww5_sgAXs
                                                                     $dNum_sgAXv
                                                                     $dFractional_sgAXx
                                                                     $dFloating_sgAXW] \u []
                                                                        let {
                                                                          u_sgAXX :: a_agsO1
                                                                          [LclId] =
                                                                              [ww4_sgAXr
                                                                               ww5_sgAXs
                                                                               $dNum_sgAXv] \u []
                                                                                  let {
                                                                                    sat_sgAY2 [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [ww5_sgAXs
                                                                                         $dNum_sgAXv] \u []
                                                                                            GHC.Num.*
                                                                                                $dNum_sgAXv
                                                                                                ww5_sgAXs
                                                                                                ww5_sgAXs; } in
                                                                                  let {
                                                                                    sat_sgAY1 [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [ww4_sgAXr
                                                                                         $dNum_sgAXv] \u []
                                                                                            let {
                                                                                              sat_sgAY0 [Occ=Once]
                                                                                                :: a_agsO1
                                                                                              [LclId] =
                                                                                                  [ww4_sgAXr
                                                                                                   $dNum_sgAXv] \u []
                                                                                                      GHC.Num.*
                                                                                                          $dNum_sgAXv
                                                                                                          ww4_sgAXr
                                                                                                          ww4_sgAXr; } in
                                                                                            let {
                                                                                              sat_sgAXZ [Occ=Once]
                                                                                                :: a_agsO1
                                                                                              [LclId] =
                                                                                                  [ww4_sgAXr
                                                                                                   $dNum_sgAXv] \u []
                                                                                                      let {
                                                                                                        sat_sgAXY [Occ=Once]
                                                                                                          :: a_agsO1
                                                                                                        [LclId] =
                                                                                                            [$dNum_sgAXv] \u []
                                                                                                                GHC.Num.fromInteger
                                                                                                                    $dNum_sgAXv
                                                                                                                    Data.Complex.$fFloatingComplex21;
                                                                                                      } in 
                                                                                                        GHC.Num.*
                                                                                                            $dNum_sgAXv
                                                                                                            sat_sgAXY
                                                                                                            ww4_sgAXr;
                                                                                            } in 
                                                                                              GHC.Num.+
                                                                                                  $dNum_sgAXv
                                                                                                  sat_sgAXZ
                                                                                                  sat_sgAY0;
                                                                                  } in 
                                                                                    GHC.Num.+
                                                                                        $dNum_sgAXv
                                                                                        sat_sgAY1
                                                                                        sat_sgAY2; } in
                                                                        let {
                                                                          sat_sgAY7 [Occ=Once]
                                                                            :: a_agsO1
                                                                          [LclId] =
                                                                              [$dNum_sgAXv
                                                                               $dFloating_sgAXW
                                                                               u_sgAXX] \u []
                                                                                  let {
                                                                                    sat_sgAY6 [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [$dNum_sgAXv
                                                                                         $dFloating_sgAXW
                                                                                         u_sgAXX] \u []
                                                                                            let {
                                                                                              sat_sgAY5 [Occ=Once]
                                                                                                :: a_agsO1
                                                                                              [LclId] =
                                                                                                  [$dNum_sgAXv
                                                                                                   u_sgAXX] \u []
                                                                                                      let {
                                                                                                        sat_sgAY4 [Occ=Once]
                                                                                                          :: a_agsO1
                                                                                                        [LclId] =
                                                                                                            [$dNum_sgAXv] \u []
                                                                                                                GHC.Num.fromInteger
                                                                                                                    $dNum_sgAXv
                                                                                                                    Data.Complex.$fFloatingComplex19;
                                                                                                      } in 
                                                                                                        GHC.Num.+
                                                                                                            $dNum_sgAXv
                                                                                                            u_sgAXX
                                                                                                            sat_sgAY4;
                                                                                            } in 
                                                                                              GHC.Float.sqrt
                                                                                                  $dFloating_sgAXW
                                                                                                  sat_sgAY5; } in
                                                                                  let {
                                                                                    sat_sgAY3 [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [$dNum_sgAXv] \u []
                                                                                            GHC.Num.fromInteger
                                                                                                $dNum_sgAXv
                                                                                                Data.Complex.$fFloatingComplex19;
                                                                                  } in 
                                                                                    GHC.Num.+
                                                                                        $dNum_sgAXv
                                                                                        sat_sgAY3
                                                                                        sat_sgAY6;
                                                                        } in 
                                                                          GHC.Real./
                                                                              $dFractional_sgAXx
                                                                              u_sgAXX
                                                                              sat_sgAY7;
                                                              } in 
                                                                case
                                                                    GHC.Float.log1p
                                                                        $dFloating_sgAXW sat_sgAY8
                                                                of
                                                                dt_sgAY9
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_sgAYb [Occ=Once]
                                                                          :: a_agsO1
                                                                        [LclId] =
                                                                            [ww4_sgAXr
                                                                             $dNum_sgAXv] \u []
                                                                                let {
                                                                                  sat_sgAYa [Occ=Once]
                                                                                    :: a_agsO1
                                                                                  [LclId] =
                                                                                      [$dNum_sgAXv] \u []
                                                                                          GHC.Num.fromInteger
                                                                                              $dNum_sgAXv
                                                                                              Data.Complex.$fFloatingComplex19;
                                                                                } in 
                                                                                  GHC.Num.+
                                                                                      $dNum_sgAXv
                                                                                      sat_sgAYa
                                                                                      ww4_sgAXr;
                                                                      } in 
                                                                        case
                                                                            GHC.Float.atan2
                                                                                $dRealFloat_sgAXl
                                                                                sat_sgAYb
                                                                                ww5_sgAXs
                                                                        of
                                                                        dt1_sgAYc
                                                                        { __DEFAULT ->
                                                                              Data.Complex.:+ [dt_sgAY9
                                                                                               dt1_sgAYc];
                                                                        };
                                                                };
                                                        };
                                                  };
                                          };
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clogBase1 [InlPrag=INLINE (sat-args=2)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAYd eta1_sgAYe]
        case eta1_sgAYe of {
          Data.Complex.:+ ww1_sgAYg [Occ=Once!] ww2_sgAYh [Occ=Once!] ->
              case ww1_sgAYg of {
                GHC.Types.F# ww4_sgAYj ->
                    case ww2_sgAYh of {
                      GHC.Types.F# ww6_sgAYl ->
                          case Data.Complex.$w$smagnitude1 ww4_sgAYj ww6_sgAYl of ww7_sgAYm {
                            __DEFAULT ->
                                case logFloat# [ww7_sgAYm] of wild1_sgAYn {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$sphase1 ww4_sgAYj ww6_sgAYl
                                      of
                                      ww8_sgAYo
                                      { __DEFAULT ->
                                            case eta_sgAYd of {
                                              Data.Complex.:+ ww10_sgAYq [Occ=Once!]
                                                              ww11_sgAYr [Occ=Once!] ->
                                                  case ww10_sgAYq of {
                                                    GHC.Types.F# ww13_sgAYt ->
                                                        case ww11_sgAYr of {
                                                          GHC.Types.F# ww15_sgAYv ->
                                                              case
                                                                  Data.Complex.$w$smagnitude1
                                                                      ww13_sgAYt ww15_sgAYv
                                                              of
                                                              ww16_sgAYw
                                                              { __DEFAULT ->
                                                                    case
                                                                        logFloat# [ww16_sgAYw]
                                                                    of
                                                                    wild2_sgAYx
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$sphase1
                                                                                  ww13_sgAYt
                                                                                  ww15_sgAYv
                                                                          of
                                                                          ww17_sgAYy
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/1
                                                                                        wild1_sgAYn
                                                                                        ww8_sgAYo
                                                                                        wild2_sgAYx
                                                                                        ww17_sgAYy
                                                                                of
                                                                                { (#,#) ww19_sgAYA [Occ=Once]
                                                                                        ww20_sgAYB [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww19_sgAYA
                                                                                                       ww20_sgAYB];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clogBase [InlPrag=INLINE (sat-args=2)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgAYC eta1_sgAYD]
        case eta1_sgAYD of {
          Data.Complex.:+ ww1_sgAYF [Occ=Once!] ww2_sgAYG [Occ=Once!] ->
              case ww1_sgAYF of {
                GHC.Types.D# ww4_sgAYI ->
                    case ww2_sgAYG of {
                      GHC.Types.D# ww6_sgAYK ->
                          case Data.Complex.$w$smagnitude ww4_sgAYI ww6_sgAYK of ww7_sgAYL {
                            __DEFAULT ->
                                case logDouble# [ww7_sgAYL] of wild1_sgAYM {
                                  __DEFAULT ->
                                      case Data.Complex.$w$sphase ww4_sgAYI ww6_sgAYK of ww8_sgAYN {
                                        __DEFAULT ->
                                            case eta_sgAYC of {
                                              Data.Complex.:+ ww10_sgAYP [Occ=Once!]
                                                              ww11_sgAYQ [Occ=Once!] ->
                                                  case ww10_sgAYP of {
                                                    GHC.Types.D# ww13_sgAYS ->
                                                        case ww11_sgAYQ of {
                                                          GHC.Types.D# ww15_sgAYU ->
                                                              case
                                                                  Data.Complex.$w$smagnitude
                                                                      ww13_sgAYS ww15_sgAYU
                                                              of
                                                              ww16_sgAYV
                                                              { __DEFAULT ->
                                                                    case
                                                                        logDouble# [ww16_sgAYV]
                                                                    of
                                                                    wild2_sgAYW
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$sphase
                                                                                  ww13_sgAYS
                                                                                  ww15_sgAYU
                                                                          of
                                                                          ww17_sgAYX
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/
                                                                                        wild1_sgAYM
                                                                                        ww8_sgAYN
                                                                                        wild2_sgAYW
                                                                                        ww17_sgAYX
                                                                                of
                                                                                { (#,#) ww19_sgAYZ [Occ=Once]
                                                                                        ww20_sgAZ0 [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww19_sgAYZ
                                                                                                       ww20_sgAZ0];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clogBase [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgAZ1 eta_sgAZ2 eta1_sgAZ3]
        case eta1_sgAZ3 of {
          Data.Complex.:+ ww1_sgAZ5 [Occ=Once] ww2_sgAZ6 [Occ=Once] ->
              case
                  Data.Complex.$w$clog $dRealFloat_sgAZ1 ww1_sgAZ5 ww2_sgAZ6
              of
              { (#,#) ww4_sgAZ8 [Occ=Once] ww5_sgAZ9 [Occ=Once] ->
                    case eta_sgAZ2 of {
                      Data.Complex.:+ ww7_sgAZb [Occ=Once] ww8_sgAZc [Occ=Once] ->
                          case
                              Data.Complex.$w$clog $dRealFloat_sgAZ1 ww7_sgAZb ww8_sgAZc
                          of
                          { (#,#) ww10_sgAZe [Occ=Once] ww11_sgAZf [Occ=Once] ->
                                case
                                    Data.Complex.$w$c/
                                        $dRealFloat_sgAZ1 ww4_sgAZ8 ww5_sgAZ9 ww10_sgAZe ww11_sgAZf
                                of
                                { (#,#) ww13_sgAZh [Occ=Once] ww14_sgAZi [Occ=Once] ->
                                      Data.Complex.:+ [ww13_sgAZh ww14_sgAZi];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$fFloatingComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Float.Floating (Data.Complex.Complex GHC.Types.Float)
[GblId] =
    CCS_DONT_CARE GHC.Float.C:Floating! [Data.Complex.$fFloatingComplex_$s$fFractionalComplex1
                                         Data.Complex.$fFloatingComplex_$s$cpi1
                                         Data.Complex.$fFloatingComplex_$s$cexp1
                                         Data.Complex.$fFloatingComplex_$s$clog1
                                         Data.Complex.$fFloatingComplex_$s$csqrt1
                                         Data.Complex.$fFloatingComplex_$s$c**1
                                         Data.Complex.$fFloatingComplex_$s$clogBase1
                                         Data.Complex.$fFloatingComplex_$s$csin1
                                         Data.Complex.$fFloatingComplex_$s$ccos1
                                         Data.Complex.$fFloatingComplex_$s$ctan1
                                         Data.Complex.$fFloatingComplex_$s$casin1
                                         Data.Complex.$fFloatingComplex_$s$cacos1
                                         Data.Complex.$fFloatingComplex_$s$catan1
                                         Data.Complex.$fFloatingComplex_$s$csinh1
                                         Data.Complex.$fFloatingComplex_$s$ccosh1
                                         Data.Complex.$fFloatingComplex_$s$ctanh1
                                         Data.Complex.$fFloatingComplex_$s$casinh1
                                         Data.Complex.$fFloatingComplex_$s$cacosh1
                                         Data.Complex.$fFloatingComplex_$s$catanh1
                                         Data.Complex.$fFloatingComplex_$s$clog1p1
                                         Data.Complex.$fFloatingComplex_$s$cexpm2
                                         Data.Complex.$fFloatingComplex_$s$clog1pexp1
                                         Data.Complex.$fFloatingComplex_$s$clog1mexp1];

Data.Complex.$fFloatingComplex_$s$fFloatingComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Float.Floating (Data.Complex.Complex GHC.Types.Double)
[GblId] =
    CCS_DONT_CARE GHC.Float.C:Floating! [Data.Complex.$fFloatingComplex_$s$fFractionalComplex
                                         Data.Complex.$fFloatingComplex_$s$cpi
                                         Data.Complex.$fFloatingComplex_$s$cexp
                                         Data.Complex.$fFloatingComplex_$s$clog
                                         Data.Complex.$fFloatingComplex_$s$csqrt
                                         Data.Complex.$fFloatingComplex_$s$c**
                                         Data.Complex.$fFloatingComplex_$s$clogBase
                                         Data.Complex.$fFloatingComplex_$s$csin
                                         Data.Complex.$fFloatingComplex_$s$ccos
                                         Data.Complex.$fFloatingComplex_$s$ctan
                                         Data.Complex.$fFloatingComplex_$s$casin
                                         Data.Complex.$fFloatingComplex_$s$cacos
                                         Data.Complex.$fFloatingComplex_$s$catan
                                         Data.Complex.$fFloatingComplex_$s$csinh
                                         Data.Complex.$fFloatingComplex_$s$ccosh
                                         Data.Complex.$fFloatingComplex_$s$ctanh
                                         Data.Complex.$fFloatingComplex_$s$casinh
                                         Data.Complex.$fFloatingComplex_$s$cacosh
                                         Data.Complex.$fFloatingComplex_$s$catanh
                                         Data.Complex.$fFloatingComplex_$s$clog1p
                                         Data.Complex.$fFloatingComplex_$s$cexpm1
                                         Data.Complex.$fFloatingComplex_$s$clog1pexp
                                         Data.Complex.$fFloatingComplex_$s$clog1mexp];

Data.Complex.$fFloatingComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Float.Floating (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,U,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))>] =
    [] \r [$dRealFloat_sgAZj]
        let {
          sat_sgAZG [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog1mexp
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZF [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog1pexp
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZE [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cexpm1
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZD [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog1p
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZC [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$catanh
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZB [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cacosh
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZA [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$casinh
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZz [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ctanh
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZy [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ccosh
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZx [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$csinh
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZw [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$catan
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZv [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cacos
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZu [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$casin
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZt [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ctan $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZs [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ccos $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZr [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$csin $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZq [Occ=Once]
            :: Data.Complex.Complex a_agsO1
               -> Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$clogBase
                      $dRealFloat_sgAZj eta_B2 eta_B1; } in
        let {
          sat_sgAZp [Occ=Once]
            :: Data.Complex.Complex a_agsO1
               -> Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c**
                      $dRealFloat_sgAZj eta_B2 eta_B1; } in
        let {
          sat_sgAZo [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$csqrt
                      $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZn [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZm [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cexp $dRealFloat_sgAZj eta_B1; } in
        let {
          sat_sgAZl [Occ=Once] :: Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgAZj] \u []
                  Data.Complex.$fFloatingComplex_$cpi $dRealFloat_sgAZj; } in
        let {
          sat_sgAZk [Occ=Once]
            :: GHC.Real.Fractional (Data.Complex.Complex a_agsO1)
          [LclId] =
              [$dRealFloat_sgAZj] \u []
                  Data.Complex.$fFractionalComplex $dRealFloat_sgAZj;
        } in 
          GHC.Float.C:Floating [sat_sgAZk
                                sat_sgAZl
                                sat_sgAZm
                                sat_sgAZn
                                sat_sgAZo
                                sat_sgAZp
                                sat_sgAZq
                                sat_sgAZr
                                sat_sgAZs
                                sat_sgAZt
                                sat_sgAZu
                                sat_sgAZv
                                sat_sgAZw
                                sat_sgAZx
                                sat_sgAZy
                                sat_sgAZz
                                sat_sgAZA
                                sat_sgAZB
                                sat_sgAZC
                                sat_sgAZD
                                sat_sgAZE
                                sat_sgAZF
                                sat_sgAZG];

Data.Complex.:+ :: forall a. a -> a -> Data.Complex.Complex a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Complex.:+ [eta_B2 eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:12:44.279419493 UTC

Data.Complex.$W:+ [InlPrag=INLINE[2]]
  :: forall a. a -> a -> Data.Complex.Complex a
[GblId[DataConWrapper],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>m,
 Unf=OtherCon []] =
    [] \r [dt_sgMF4 dt_sgMF5]
        case dt_sgMF4 of dt_sgMF6 {
          __DEFAULT ->
              case dt_sgMF5 of dt_sgMF7 {
                __DEFAULT -> Data.Complex.:+ [dt_sgMF6 dt_sgMF7];
              };
        };

Data.Complex.$fStorableComplex2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Complex.$fStorableComplex1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> Data.Complex.Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,U><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMF8 w1_sgMF9 w2_sgMFa w3_sgMFb]
        case w2_sgMFa of {
          Data.Complex.:+ ww1_sgMFd [Occ=Once] ww2_sgMFe [Occ=Once] ->
              case Foreign.Storable.poke w_sgMF8 w1_sgMF9 ww1_sgMFd w3_sgMFb of {
                (#,#) ipv_sgMFg [Occ=Once] _ [Occ=Dead] ->
                    Foreign.Storable.pokeElemOff
                        w_sgMF8
                        w1_sgMF9
                        Data.Complex.$fStorableComplex2
                        ww2_sgMFe
                        ipv_sgMFg;
              };
        };

Data.Complex.$fStorableComplex3
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Complex.Complex a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,1*C1(C1(C1(U(U,U)))),A,A,A,1*C1(C1(U(U,U))),A)><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgMFi p_sgMFj s_sgMFk]
        case Foreign.Storable.peek $dStorable_sgMFi p_sgMFj s_sgMFk of {
          (#,#) ipv_sgMFm [Occ=Once] ipv1_sgMFn [Occ=Once] ->
              case
                  Foreign.Storable.peekElemOff
                      $dStorable_sgMFi p_sgMFj Data.Complex.$fStorableComplex2 ipv_sgMFm
              of
              { (#,#) ipv2_sgMFp [Occ=Once] ipv3_sgMFq [Occ=Once] ->
                    let {
                      sat_sgMFr [Occ=Once] :: Data.Complex.Complex a_XgsQ1
                      [LclId] =
                          [ipv1_sgMFn ipv3_sgMFq] \u []
                              Data.Complex.$W:+ ipv1_sgMFn ipv3_sgMFq;
                    } in  (#,#) [ipv2_sgMFp sat_sgMFr];
              };
        };

Data.Complex.$fApplicativeComplex_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> Data.Complex.Complex a
     -> Data.Complex.Complex b
     -> Data.Complex.Complex c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMFs w1_sgMFt w2_sgMFu]
        case w1_sgMFt of {
          Data.Complex.:+ ww1_sgMFw [Occ=Once] ww2_sgMFx [Occ=Once] ->
              case w2_sgMFu of {
                Data.Complex.:+ ww4_sgMFz [Occ=Once] ww5_sgMFA [Occ=Once] ->
                    case w_sgMFs ww1_sgMFw ww4_sgMFz of dt_sgMFB {
                      __DEFAULT ->
                          case w_sgMFs ww2_sgMFx ww5_sgMFA of dt1_sgMFC {
                            __DEFAULT -> Data.Complex.:+ [dt_sgMFB dt1_sgMFC];
                          };
                    };
              };
        };

Data.Complex.$fApplicativeComplex_$c<*>
  :: forall a b.
     Data.Complex.Complex (a -> b)
     -> Data.Complex.Complex a -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)C(S)),1*U(C1(U),C1(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMFD ds1_sgMFE]
        case ds_sgMFD of {
          Data.Complex.:+ f_sgMFG [Occ=Once!] g_sgMFH [Occ=Once!] ->
              case ds1_sgMFE of {
                Data.Complex.:+ a1_sgMFJ [Occ=Once] b1_sgMFK [Occ=Once] ->
                    case f_sgMFG a1_sgMFJ of dt_sgMFL {
                      __DEFAULT ->
                          case g_sgMFH b1_sgMFK of dt1_sgMFM {
                            __DEFAULT -> Data.Complex.:+ [dt_sgMFL dt1_sgMFM];
                          };
                    };
              };
        };

Data.Complex.$fApplicativeComplex_$cpure
  :: forall a. a -> Data.Complex.Complex a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>m, Unf=OtherCon []] =
    [] \r [a1_sgMFN] Data.Complex.$W:+ a1_sgMFN a1_sgMFN;

Data.Complex.$fTraversableComplex_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Complex.Complex a -> f (Data.Complex.Complex b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgMFO f1_sgMFP ds_sgMFQ]
        case ds_sgMFQ of {
          Data.Complex.:+ a1_sgMFS [Occ=Once] a2_sgMFT [Occ=Once] ->
              let {
                sat_sgMFV [Occ=Once] :: f_agsK7 b_agsK9
                [LclId] =
                    [f1_sgMFP a2_sgMFT] \u [] f1_sgMFP a2_sgMFT; } in
              let {
                sat_sgMFU [Occ=Once] :: f_agsK7 b_agsK9
                [LclId] =
                    [f1_sgMFP a1_sgMFS] \u [] f1_sgMFP a1_sgMFS;
              } in 
                GHC.Base.liftA2
                    $dApplicative_sgMFO Data.Complex.$W:+ sat_sgMFU sat_sgMFV;
        };

Data.Complex.$fFoldableComplex_$cnull
  :: forall a. Data.Complex.Complex a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_sgMFW]
        case ds_sgMFW of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Complex.$fFoldableComplex_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgMG0 z_sgMG1 ds_sgMG2]
        case ds_sgMG2 of {
          Data.Complex.:+ a1_sgMG4 [Occ=Once] a2_sgMG5 [Occ=Once] ->
              let {
                sat_sgMG6 [Occ=Once] :: b_agsHZ
                [LclId] =
                    [f_sgMG0 z_sgMG1 a2_sgMG5] \u [] f_sgMG0 a2_sgMG5 z_sgMG1;
              } in  f_sgMG0 a1_sgMG4 sat_sgMG6;
        };

Data.Complex.$fFoldableComplex_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Complex.Complex a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgMG7 f_sgMG8 ds_sgMG9]
        case ds_sgMG9 of {
          Data.Complex.:+ a1_sgMGb [Occ=Once] a2_sgMGc [Occ=Once] ->
              let {
                sat_sgMGe [Occ=Once] :: m_agsHO
                [LclId] =
                    [f_sgMG8 a2_sgMGc] \u [] f_sgMG8 a2_sgMGc; } in
              let {
                sat_sgMGd [Occ=Once] :: m_agsHO
                [LclId] =
                    [f_sgMG8 a1_sgMGb] \u [] f_sgMG8 a1_sgMGb;
              } in  GHC.Base.mappend $dMonoid_sgMG7 sat_sgMGd sat_sgMGe;
        };

Data.Complex.$fFoldableComplex_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Complex.Complex m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgMGf ds_sgMGg]
        case ds_sgMGg of {
          Data.Complex.:+ a1_sgMGi [Occ=Once] a2_sgMGj [Occ=Once] ->
              GHC.Base.mappend $dMonoid_sgMGf a1_sgMGi a2_sgMGj;
        };

Data.Complex.$fFoldableComplex2
  :: forall a.
     GHC.Num.Num a =>
     Data.Complex.Complex a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgMGk ds_sgMGl]
        case ds_sgMGl of {
          Data.Complex.:+ a1_sgMGn [Occ=Once] a2_sgMGo [Occ=Once] ->
              GHC.Num.+ $dNum_sgMGk a1_sgMGn a2_sgMGo;
        };

Data.Complex.$fFoldableComplex_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sgMGp x_sgMGq]
        case x_sgMGq of {
          Data.Complex.:+ a1_sgMGs a2_sgMGt ->
              case GHC.Classes.<= $dOrd_sgMGp a1_sgMGs a2_sgMGt of {
                GHC.Types.False -> a2_sgMGt;
                GHC.Types.True -> a1_sgMGs;
              };
        };

Data.Complex.$fFoldableComplex_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sgMGv x_sgMGw]
        case x_sgMGw of {
          Data.Complex.:+ a1_sgMGy a2_sgMGz ->
              case GHC.Classes.>= $dOrd_sgMGv a1_sgMGy a2_sgMGz of {
                GHC.Types.False -> a2_sgMGz;
                GHC.Types.True -> a1_sgMGy;
              };
        };

Data.Complex.$fFoldableComplex_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Complex.Complex a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sgMGB eta_sgMGC]
        let {
          f_sgMGD [Dmd=<L,C(U)>] :: a_agsJ9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgMGB eta_sgMGC] \u []
                  GHC.Classes.== $dEq_sgMGB eta_sgMGC; } in
        let {
          sat_sgMGJ [Occ=Once]
            :: Data.Complex.Complex a_agsJ9 -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_sgMGD] \r [ds_sgMGE]
                  case ds_sgMGE of {
                    Data.Complex.:+ a1_sgMGG [Occ=Once] a2_sgMGH [Occ=Once] ->
                        case f_sgMGD a1_sgMGG of {
                          GHC.Types.False -> f_sgMGD a2_sgMGH;
                          GHC.Types.True -> GHC.Types.True [];
                        };
                  };
        } in  sat_sgMGJ;

Data.Complex.$fFoldableComplex_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgMGK xs_sgMGL]
        case xs_sgMGL of {
          Data.Complex.:+ a1_sgMGN [Occ=Once] a2_sgMGO [Occ=Once] ->
              f_sgMGK a1_sgMGN a2_sgMGO;
        };

Data.Complex.$fFoldableComplex_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgMGP z0_sgMGQ xs_sgMGR]
        case xs_sgMGR of {
          Data.Complex.:+ a1_sgMGT [Occ=Once] a2_sgMGU [Occ=Once] ->
              case f_sgMGP z0_sgMGQ a1_sgMGT of vx_sgMGV {
                __DEFAULT -> f_sgMGP vx_sgMGV a2_sgMGU;
              };
        };

lvl_rgA6e :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

Data.Complex.$fFoldableComplex_$clength
  :: forall a. Data.Complex.Complex a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_sgMGW]
        case xs_sgMGW of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> lvl_rgA6e;
        };

Data.Complex.$fFoldableComplex_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgMH0 z_sgMH1 t1_sgMH2]
        case t1_sgMH2 of {
          Data.Complex.:+ a1_sgMH4 [Occ=Once] a2_sgMH5 [Occ=Once] ->
              let {
                sat_sgMH6 [Occ=Once] :: b_agsIe
                [LclId] =
                    [f_sgMH0 z_sgMH1 a1_sgMH4] \u [] f_sgMH0 z_sgMH1 a1_sgMH4;
              } in  f_sgMH0 sat_sgMH6 a2_sgMH5;
        };

Data.Complex.$fFoldableComplex_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgMH7 z0_sgMH8 xs_sgMH9]
        case xs_sgMH9 of {
          Data.Complex.:+ a1_sgMHb [Occ=Once] a2_sgMHc [Occ=Once] ->
              case f_sgMH7 a2_sgMHc z0_sgMH8 of vx_sgMHd {
                __DEFAULT -> f_sgMH7 a1_sgMHb vx_sgMHd;
              };
        };

Data.Complex.$fFoldableComplex1
  :: forall a.
     GHC.Num.Num a =>
     Data.Complex.Complex a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgMHe ds_sgMHf]
        case ds_sgMHf of {
          Data.Complex.:+ a1_sgMHh [Occ=Once] a2_sgMHi [Occ=Once] ->
              GHC.Num.* $dNum_sgMHe a1_sgMHh a2_sgMHi;
        };

Data.Complex.$fFoldableComplex_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Complex.Complex a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_sgMHj]
        case eta_sgMHj of {
          Data.Complex.:+ a1_sgMHl [Occ=Once] a2_sgMHm [Occ=Once] ->
              let {
                sat_sgMHn [Occ=Once] :: [a_agsIO]
                [LclId] =
                    CCCS :! [a2_sgMHm GHC.Types.[]];
              } in  : [a1_sgMHl sat_sgMHn];
        };

Data.Complex.$fFoldableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Complex.$fFoldableComplex_$cfold
                                             Data.Complex.$fFoldableComplex_$cfoldMap
                                             Data.Complex.$fFoldableComplex_$cfoldr
                                             Data.Complex.$fFoldableComplex_$cfoldr'
                                             Data.Complex.$fFoldableComplex_$cfoldl
                                             Data.Complex.$fFoldableComplex_$cfoldl'
                                             Data.Complex.$fFoldableComplex_$cfoldr1
                                             Data.Complex.$fFoldableComplex_$cfoldr1
                                             Data.Complex.$fFoldableComplex_$ctoList
                                             Data.Complex.$fFoldableComplex_$cnull
                                             Data.Complex.$fFoldableComplex_$clength
                                             Data.Complex.$fFoldableComplex_$celem
                                             Data.Complex.$fFoldableComplex_$cmaximum
                                             Data.Complex.$fFoldableComplex_$cminimum
                                             Data.Complex.$fFoldableComplex2
                                             Data.Complex.$fFoldableComplex1];

Data.Complex.$fFunctorComplex_$c<$
  :: forall a b.
     a -> Data.Complex.Complex b -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [z_sgMHo ds_sgMHp]
        case ds_sgMHp of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Complex.$W:+ z_sgMHo z_sgMHo;
        };

Data.Complex.$fFunctorComplex_$cfmap
  :: forall a b.
     (a -> b) -> Data.Complex.Complex a -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sgMHt ds_sgMHu]
        case ds_sgMHu of {
          Data.Complex.:+ a1_sgMHw [Occ=Once] a2_sgMHx [Occ=Once] ->
              case f_sgMHt a1_sgMHw of dt_sgMHy {
                __DEFAULT ->
                    case f_sgMHt a2_sgMHx of dt1_sgMHz {
                      __DEFAULT -> Data.Complex.:+ [dt_sgMHy dt1_sgMHz];
                    };
              };
        };

Data.Complex.$fFunctorComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Complex.$fFunctorComplex_$cfmap
                                       Data.Complex.$fFunctorComplex_$c<$];

Data.Complex.$fTraversableComplex_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Complex.Complex (f a) -> f (Data.Complex.Complex a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgMHA ds_sgMHB]
        case ds_sgMHB of {
          Data.Complex.:+ a1_sgMHD [Occ=Once] a2_sgMHE [Occ=Once] ->
              GHC.Base.liftA2
                  $dApplicative_sgMHA Data.Complex.$W:+ a1_sgMHD a2_sgMHE;
        };

Data.Complex.$fTraversableComplex_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Complex.Complex a -> m (Data.Complex.Complex b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgMHF eta_sgMHG eta1_sgMHH]
        case eta1_sgMHH of {
          Data.Complex.:+ a1_sgMHJ [Occ=Once] a2_sgMHK [Occ=Once] ->
              let {
                sat_sgMHN [Occ=Once] :: m_agsKy b_agsKA
                [LclId] =
                    [eta_sgMHG a2_sgMHK] \u [] eta_sgMHG a2_sgMHK; } in
              let {
                sat_sgMHM [Occ=Once] :: m_agsKy b_agsKA
                [LclId] =
                    [eta_sgMHG a1_sgMHJ] \u [] eta_sgMHG a1_sgMHJ;
              } in 
                case GHC.Base.$p1Monad $dMonad_sgMHF of sat_sgMHL {
                  __DEFAULT ->
                      GHC.Base.liftA2 sat_sgMHL Data.Complex.$W:+ sat_sgMHM sat_sgMHN;
                };
        };

Data.Complex.$fTraversableComplex_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Complex.Complex (m a) -> m (Data.Complex.Complex a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgMHO eta_sgMHP]
        case eta_sgMHP of {
          Data.Complex.:+ a1_sgMHR [Occ=Once] a2_sgMHS [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sgMHO of sat_sgMHT {
                __DEFAULT ->
                    GHC.Base.liftA2 sat_sgMHT Data.Complex.$W:+ a1_sgMHR a2_sgMHS;
              };
        };

Data.Complex.$fTraversableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Complex.$fFunctorComplex
                                                   Data.Complex.$fFoldableComplex
                                                   Data.Complex.$fTraversableComplex_$ctraverse
                                                   Data.Complex.$fTraversableComplex_$csequenceA
                                                   Data.Complex.$fTraversableComplex_$cmapM
                                                   Data.Complex.$fTraversableComplex_$csequence];

Data.Complex.$fApplicativeComplex_$c*>
  :: forall a b.
     Data.Complex.Complex a
     -> Data.Complex.Complex b -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [a1_sgMHU a2_sgMHV]
        case a1_sgMHU of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> a2_sgMHV;
        };

Data.Complex.$fApplicativeComplex_$c<*
  :: forall a b.
     Data.Complex.Complex a
     -> Data.Complex.Complex b -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMHZ ds1_sgMI0]
        case ds_sgMHZ of wild_sgMI1 {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] ->
              case ds1_sgMI0 of {
                Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> wild_sgMI1;
              };
        };

Data.Complex.$fApplicativeComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Complex.$fFunctorComplex
                                           Data.Complex.$fApplicativeComplex_$cpure
                                           Data.Complex.$fApplicativeComplex_$c<*>
                                           Data.Complex.$fApplicativeComplex_$cliftA2
                                           Data.Complex.$fApplicativeComplex_$c*>
                                           Data.Complex.$fApplicativeComplex_$c<*];

Data.Complex.$fGeneric1Complex_$cto1
  :: forall a.
     GHC.Generics.Rep1 Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMI7]
        case ds_sgMI7 of {
          GHC.Generics.:*: ds1_sgMI9 [Occ=Once] ds2_sgMIa [Occ=Once] ->
              Data.Complex.$W:+ ds1_sgMI9 ds2_sgMIa;
        };

Data.Complex.$fGeneric1Complex1
  :: forall a.
     Data.Complex.Complex a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             ":+"
             ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
             'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.SourceStrict
                'GHC.Generics.DecidedStrict)
             GHC.Generics.Par1
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.SourceStrict
                                 'GHC.Generics.DecidedStrict)
                              GHC.Generics.Par1)
          a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_sgMIb]
        case x_sgMIb of {
          Data.Complex.:+ g1_sgMId [Occ=Once] g2_sgMIe [Occ=Once] ->
              GHC.Generics.:*: [g1_sgMId g2_sgMIe];
        };

Data.Complex.$fGeneric1Complex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Complex.$fGeneric1Complex1
                                            Data.Complex.$fGeneric1Complex_$cto1];

Data.Complex.$fGenericComplex_$cto
  :: forall a x.
     GHC.Generics.Rep (Data.Complex.Complex a) x
     -> Data.Complex.Complex a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMIf]
        case ds_sgMIf of {
          GHC.Generics.:*: ds1_sgMIh [Occ=Once] ds2_sgMIi [Occ=Once] ->
              Data.Complex.$W:+ ds1_sgMIh ds2_sgMIi;
        };

Data.Complex.$fGenericComplex1
  :: forall a x.
     Data.Complex.Complex a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             ":+"
             ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
             'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.SourceStrict
                'GHC.Generics.DecidedStrict)
             (GHC.Generics.K1 GHC.Generics.R a)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.SourceStrict
                                 'GHC.Generics.DecidedStrict)
                              (GHC.Generics.K1 GHC.Generics.R a))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x1_sgMIj]
        case x1_sgMIj of {
          Data.Complex.:+ g1_sgMIl [Occ=Once] g2_sgMIm [Occ=Once] ->
              GHC.Generics.:*: [g1_sgMIl g2_sgMIm];
        };

Data.Complex.$fGenericComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Complex.Complex a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Complex.$fGenericComplex1
                                           Data.Complex.$fGenericComplex_$cto];

Data.Complex.$fDataComplex_$cgunfold
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dData_sgMIn k_sgMIo z_sgMIp ds_sgMIq]
        let {
          sat_sgMIs [Occ=Once]
            :: c_agsBB (a_agsBe -> Data.Complex.Complex a_agsBe)
          [LclId] =
              [$dData_sgMIn k_sgMIo z_sgMIp] \u []
                  let {
                    sat_sgMIr [Occ=Once]
                      :: c_agsBB (a_agsBe -> a_agsBe -> Data.Complex.Complex a_agsBe)
                    [LclId] =
                        [z_sgMIp] \u [] z_sgMIp Data.Complex.$W:+;
                  } in  k_sgMIo $dData_sgMIn sat_sgMIr;
        } in  k_sgMIo $dData_sgMIn sat_sgMIs;

Data.Complex.$fDataComplex_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Complex.Complex a
     -> c (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgMIt k_sgMIu z_sgMIv ds_sgMIw]
        case ds_sgMIw of {
          Data.Complex.:+ a1_sgMIy [Occ=Once] a2_sgMIz [Occ=Once] ->
              let {
                sat_sgMIB [Occ=Once]
                  :: c_agsBn (a_agsBe -> Data.Complex.Complex a_agsBe)
                [LclId] =
                    [$dData_sgMIt k_sgMIu z_sgMIv a1_sgMIy] \u []
                        let {
                          sat_sgMIA [Occ=Once]
                            :: c_agsBn (a_agsBe -> a_agsBe -> Data.Complex.Complex a_agsBe)
                          [LclId] =
                              [z_sgMIv] \u [] z_sgMIv Data.Complex.$W:+;
                        } in  k_sgMIu $dData_sgMIt sat_sgMIA a1_sgMIy;
              } in  k_sgMIu $dData_sgMIt sat_sgMIB a2_sgMIz;
        };

Data.Complex.$fReadComplex5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [7#];

Data.Complex.$fReadComplex4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":+"#;

Data.Complex.$fReadComplex3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Complex.$fReadComplex4;

Data.Complex.$fReadComplex2 :: Text.Read.Lex.Lexeme
[GblId, Str=m5, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Symbol! [Data.Complex.$fReadComplex3];

Data.Complex.$fReadComplex1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Complex.Complex a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sgMIC eta_sgMID eta1_sgMIE]
        let {
          ds1_sgMIF [Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_agsAr
          [LclId] =
              [$dRead_sgMIC] \u []
                  GHC.Read.readPrec $dRead_sgMIC Data.Complex.$fReadComplex5; } in
        let {
          sat_sgMIU [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Complex.Complex a_agsAr)
          [LclId] =
              [ds1_sgMIF] \r [c_sgMIG eta2_sgMIH]
                  case c_sgMIG of {
                    GHC.Types.I# x_sgMIJ [Occ=Once] ->
                        case <=# [x_sgMIJ 6#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sgMIT [Occ=Once]
                                  :: a_agsAr -> Text.ParserCombinators.ReadP.P b1_i815E
                                [LclId] =
                                    [ds1_sgMIF eta2_sgMIH] \r [a1_sgMIL]
                                        let {
                                          sat_sgMIQ [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                          [LclId] =
                                              [ds1_sgMIF eta2_sgMIH a1_sgMIL] \r [a2_sgMIM]
                                                  let {
                                                    sat_sgMIP [Occ=Once]
                                                      :: a_agsAr
                                                         -> Text.ParserCombinators.ReadP.P b1_i815E
                                                    [LclId] =
                                                        [eta2_sgMIH a1_sgMIL] \r [a3_sgMIN]
                                                            let {
                                                              sat_sgMIO [Occ=Once]
                                                                :: Data.Complex.Complex a_agsAr
                                                              [LclId] =
                                                                  [a1_sgMIL a3_sgMIN] \u []
                                                                      Data.Complex.$W:+
                                                                          a1_sgMIL a3_sgMIN;
                                                            } in  eta2_sgMIH sat_sgMIO;
                                                  } in  ds1_sgMIF sat_sgMIP;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Complex.$fReadComplex2 sat_sgMIQ
                                          of
                                          { Unit# ww1_sgMIS [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sgMIS];
                                          };
                              } in  ds1_sgMIF sat_sgMIT;
                        };
                  };
        } in  GHC.Read.list3 sat_sgMIU eta_sgMID eta1_sgMIE;

Data.Complex.$fReadComplex_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Complex.Complex a)
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sgMIV n_sgMIW]
        let {
          sat_sgMIX [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Complex.Complex a_XgsEB)
          [LclId] =
              [$dRead_sgMIV n_sgMIW] \u []
                  Data.Complex.$fReadComplex1
                      $dRead_sgMIV
                      n_sgMIW
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgMIX;

Data.Complex.$fReadComplex_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Complex.Complex a]
[GblId, Arity=1, Str=<L,U(A,A,C(C(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sgMIY]
        let {
          sat_sgMIZ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Complex.Complex a_XgsEz)
          [LclId] =
              [$dRead_sgMIY] \r [eta_B2 eta_B1]
                  Data.Complex.$fReadComplex1 $dRead_sgMIY eta_B2 eta_B1;
        } in  GHC.Read.list sat_sgMIZ;

Data.Complex.$fReadComplex_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Complex.Complex a]
[GblId, Arity=1, Str=<L,U(A,A,C(C(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sgMJ0]
        let {
          sat_sgMJ2 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Complex.Complex a_XgsEA]
          [LclId] =
              [$dRead_sgMJ0] \u []
                  let {
                    sat_sgMJ1 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Complex.Complex a_XgsEA)
                    [LclId] =
                        [$dRead_sgMJ0] \r [eta_B2 eta_B1]
                            Data.Complex.$fReadComplex1 $dRead_sgMJ0 eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sgMJ1
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgMJ2;

Data.Complex.$fReadComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Complex.Complex a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C(U)),A)>m] =
    [] \r [$dRead_sgMJ3]
        let {
          sat_sgMJ7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Complex.Complex a_XgsEy]
          [LclId] =
              [$dRead_sgMJ3] \u []
                  Data.Complex.$fReadComplex_$creadListPrec $dRead_sgMJ3; } in
        let {
          sat_sgMJ6 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Complex.Complex a_XgsEy)
          [LclId] =
              [$dRead_sgMJ3] \r [eta_B2 eta_B1]
                  Data.Complex.$fReadComplex1 $dRead_sgMJ3 eta_B2 eta_B1; } in
        let {
          sat_sgMJ5 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Complex.Complex a_XgsEy]
          [LclId] =
              [$dRead_sgMJ3] \u []
                  Data.Complex.$fReadComplex_$creadList $dRead_sgMJ3; } in
        let {
          sat_sgMJ4 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Complex.Complex a_XgsEy)
          [LclId] =
              [$dRead_sgMJ3] \r [eta_B1]
                  Data.Complex.$fReadComplex_$creadsPrec $dRead_sgMJ3 eta_B1;
        } in  GHC.Read.C:Read [sat_sgMJ4 sat_sgMJ5 sat_sgMJ6 sat_sgMJ7];

Data.Complex.$fShowComplex2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    " :+ "#;

Data.Complex.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> a -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMJ8 ww_sgMJ9 ww1_sgMJa ww2_sgMJb]
        let {
          f_sgMJc [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sgMJ8 ww1_sgMJa] \u []
                  GHC.Show.showsPrec
                      w_sgMJ8 Data.Complex.$fReadComplex5 ww1_sgMJa; } in
        let {
          g_sgMJd [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sgMJ8 ww2_sgMJb] \u []
                  GHC.Show.showsPrec w_sgMJ8 Data.Complex.$fReadComplex5 ww2_sgMJb;
        } in 
          case >=# [ww_sgMJ9 7#] of {
            __DEFAULT ->
                let {
                  sat_sgMJi [Occ=OnceT[0]] :: GHC.Base.String -> GHC.Base.String
                  [LclId] =
                      [f_sgMJc g_sgMJd] \r [x_sgMJf]
                          let {
                            sat_sgMJh [Occ=Once] :: GHC.Base.String
                            [LclId] =
                                [g_sgMJd x_sgMJf] \u []
                                    let {
                                      sat_sgMJg [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sgMJd x_sgMJf] \u [] g_sgMJd x_sgMJf;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Complex.$fShowComplex2 sat_sgMJg;
                          } in  f_sgMJc sat_sgMJh;
                } in  sat_sgMJi;
            1# ->
                let {
                  sat_sgMJo [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sgMJc g_sgMJd] \r [x_sgMJj]
                          let {
                            sat_sgMJn [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sgMJc g_sgMJd x_sgMJj] \u []
                                    let {
                                      sat_sgMJm [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          [g_sgMJd x_sgMJj] \u []
                                              let {
                                                sat_sgMJl [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sgMJd x_sgMJj] \u []
                                                        let {
                                                          sat_sgMJk [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sgMJj];
                                                        } in  g_sgMJd sat_sgMJk;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Complex.$fShowComplex2 sat_sgMJl;
                                    } in  f_sgMJc sat_sgMJm;
                          } in  : [GHC.Show.$fShow(,)4 sat_sgMJn];
                } in  sat_sgMJo;
          };

Data.Complex.$fShowComplex_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Complex.Complex a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMJp w1_sgMJq w2_sgMJr]
        case w1_sgMJq of {
          GHC.Types.I# ww1_sgMJt [Occ=Once] ->
              case w2_sgMJr of {
                Data.Complex.:+ ww3_sgMJv [Occ=Once] ww4_sgMJw [Occ=Once] ->
                    Data.Complex.$w$cshowsPrec w_sgMJp ww1_sgMJt ww3_sgMJv ww4_sgMJw;
              };
        };

Data.Complex.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Show.Show a => a -> a -> GHC.Base.String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMJx ww_sgMJy ww1_sgMJz]
        let {
          sat_sgMJB [Occ=Once] :: GHC.Base.String
          [LclId] =
              [w_sgMJx ww1_sgMJz] \u []
                  let {
                    sat_sgMJA [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [w_sgMJx ww1_sgMJz] \u []
                            GHC.Show.showsPrec
                                w_sgMJx Data.Complex.$fReadComplex5 ww1_sgMJz GHC.Types.[];
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Complex.$fShowComplex2 sat_sgMJA;
        } in 
          GHC.Show.showsPrec
              w_sgMJx Data.Complex.$fReadComplex5 ww_sgMJy sat_sgMJB;

Data.Complex.$fShowComplex_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     Data.Complex.Complex a -> GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMJC w1_sgMJD]
        case w1_sgMJD of {
          Data.Complex.:+ ww1_sgMJF [Occ=Once] ww2_sgMJG [Occ=Once] ->
              Data.Complex.$w$cshow w_sgMJC ww1_sgMJF ww2_sgMJG;
        };

Data.Complex.$fShowComplex1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Complex.$fShowComplex_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Complex.Complex a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sgMJH ls_sgMJI s_sgMJJ]
        let {
          sat_sgMJO [Occ=Once]
            :: Data.Complex.Complex a_agszX -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgMJH] \r [w_sgMJK]
                  case w_sgMJK of {
                    Data.Complex.:+ ww1_sgMJM [Occ=Once] ww2_sgMJN [Occ=Once] ->
                        Data.Complex.$w$cshowsPrec $dShow_sgMJH 0# ww1_sgMJM ww2_sgMJN;
                  };
        } in  GHC.Show.showList__ sat_sgMJO ls_sgMJI s_sgMJJ;

Data.Complex.$fShowComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sgMJP]
        let {
          sat_sgMJS [Occ=Once]
            :: [Data.Complex.Complex a_agszX] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgMJP] \r [eta_B2 eta_B1]
                  Data.Complex.$fShowComplex_$cshowList
                      $dShow_sgMJP eta_B2 eta_B1; } in
        let {
          sat_sgMJR [Occ=Once]
            :: Data.Complex.Complex a_agszX -> GHC.Base.String
          [LclId] =
              [$dShow_sgMJP] \r [eta_B1]
                  Data.Complex.$fShowComplex_$cshow $dShow_sgMJP eta_B1; } in
        let {
          sat_sgMJQ [Occ=Once]
            :: GHC.Types.Int -> Data.Complex.Complex a_agszX -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgMJP] \r [eta_B2 eta_B1]
                  Data.Complex.$fShowComplex_$cshowsPrec $dShow_sgMJP eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgMJQ sat_sgMJR sat_sgMJS];

Data.Complex.$fEqComplex_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Complex.Complex a -> Data.Complex.Complex a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMJT w1_sgMJU w2_sgMJV]
        case w1_sgMJU of {
          Data.Complex.:+ ww1_sgMJX [Occ=Once] ww2_sgMJY [Occ=Once] ->
              case w2_sgMJV of {
                Data.Complex.:+ ww4_sgMK0 [Occ=Once] ww5_sgMK1 [Occ=Once] ->
                    case GHC.Classes.== w_sgMJT ww1_sgMJX ww4_sgMK0 of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> GHC.Classes.== w_sgMJT ww2_sgMJY ww5_sgMK1;
                    };
              };
        };

Data.Complex.$fEqComplex_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Complex.Complex a -> Data.Complex.Complex a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sgMK3 eta_sgMK4 eta1_sgMK5]
        case eta_sgMK4 of {
          Data.Complex.:+ ww1_sgMK7 [Occ=Once] ww2_sgMK8 [Occ=Once] ->
              case eta1_sgMK5 of {
                Data.Complex.:+ ww4_sgMKa [Occ=Once] ww5_sgMKb [Occ=Once] ->
                    case GHC.Classes.== $dEq_sgMK3 ww1_sgMK7 ww4_sgMKa of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True ->
                          case GHC.Classes.== $dEq_sgMK3 ww2_sgMK8 ww5_sgMKb of {
                            GHC.Types.False -> GHC.Types.True [];
                            GHC.Types.True -> GHC.Types.False [];
                          };
                    };
              };
        };

Data.Complex.$fEqComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Complex.Complex a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sgMKe]
        let {
          sat_sgMKg [Occ=Once]
            :: Data.Complex.Complex a_agszG
               -> Data.Complex.Complex a_agszG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgMKe] \r [eta_B2 eta_B1]
                  Data.Complex.$fEqComplex_$c/= $dEq_sgMKe eta_B2 eta_B1; } in
        let {
          sat_sgMKf [Occ=Once]
            :: Data.Complex.Complex a_agszG
               -> Data.Complex.Complex a_agszG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgMKe] \r [eta_B2 eta_B1]
                  Data.Complex.$fEqComplex_$c== $dEq_sgMKe eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sgMKf sat_sgMKg];

Data.Complex.realPart :: forall a. Data.Complex.Complex a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_sgMKh]
        case ds_sgMKh of {
          Data.Complex.:+ x_sgMKj [Occ=Once] _ [Occ=Dead] -> x_sgMKj;
        };

Data.Complex.$fStorableComplex_$csizeOf
  :: forall a.
     Foreign.Storable.Storable a =>
     Data.Complex.Complex a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S(S))LLLLLLL),1*U(1*C1(U(U)),A,A,A,A,A,A,A)><L,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgMKl a1_sgMKm]
        let {
          sat_sgMKq [Occ=Once] :: a_XgsQG
          [LclId] =
              [a1_sgMKm] \u []
                  case a1_sgMKm of {
                    Data.Complex.:+ x_sgMKo [Occ=Once] _ [Occ=Dead] -> x_sgMKo;
                  };
        } in 
          case Foreign.Storable.sizeOf $dStorable_sgMKl sat_sgMKq of {
            GHC.Types.I# y_sgMKs [Occ=Once] ->
                case *# [2# y_sgMKs] of sat_sgMKt {
                  __DEFAULT -> GHC.Types.I# [sat_sgMKt];
                };
          };

Data.Complex.$fStorableComplex_$calignment
  :: forall a.
     Foreign.Storable.Storable a =>
     Data.Complex.Complex a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLLLL),1*U(A,1*C1(U(U)),A,A,A,A,A,A)><L,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgMKu a1_sgMKv]
        let {
          sat_sgMKz [Occ=Once] :: a_XgsQH
          [LclId] =
              [a1_sgMKv] \u []
                  case a1_sgMKv of {
                    Data.Complex.:+ x_sgMKx [Occ=Once] _ [Occ=Dead] -> x_sgMKx;
                  };
        } in  Foreign.Storable.alignment $dStorable_sgMKu sat_sgMKz;

Data.Complex.$fStorableComplex5
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Complex.Complex a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgMKA ptr_sgMKB off_sgMKC eta_sgMKD]
        let {
          sat_sgMKJ [Occ=Once] :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQL)
          [LclId] =
              [ptr_sgMKB off_sgMKC] \u []
                  case ptr_sgMKB of {
                    GHC.Ptr.Ptr addr_sgMKF [Occ=Once] ->
                        case off_sgMKC of {
                          GHC.Types.I# d_sgMKH [Occ=Once] ->
                              case plusAddr# [addr_sgMKF d_sgMKH] of sat_sgMKI {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_sgMKI];
                              };
                        };
                  };
        } in 
          Data.Complex.$fStorableComplex3
              $dStorable_sgMKA sat_sgMKJ eta_sgMKD;

lvl1_rgA6f :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "undefined"#;

lvl2_rgA6g :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl1_rgA6f;

Data.Complex.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl3_rgA6h :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Complex.$trModule4;

lvl4_rgA6i :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Foreign.Storable"#;

lvl5_rgA6j :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_rgA6i;

lvl6_rgA6k :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Foreign/Storable.hs"#;

lvl7_rgA6l :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl6_rgA6k;

lvl8_rgA6m :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [137#];

lvl9_rgA6n :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [31#];

lvl10_rgA6o :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [40#];

lvl11_rgA6p :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl3_rgA6h
                                           lvl5_rgA6j
                                           lvl7_rgA6l
                                           lvl8_rgA6m
                                           lvl9_rgA6n
                                           lvl8_rgA6m
                                           lvl10_rgA6o];

lvl12_rgA6q :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl2_rgA6g
                                                  lvl11_rgA6p
                                                  GHC.Stack.Types.EmptyCallStack];

Data.Complex.$fStorableComplex8 :: forall a. Data.Complex.Complex a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl12_rgA6q;

Data.Complex.$fStorableComplex7
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Complex.Complex a #)
[GblId,
 Arity=4,
 Str=<S(LLLLLLC(C(S(SL)))L),U(1*C1(U(U)),A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgMKK ptr_sgMKL off_sgMKM eta_sgMKN]
        let {
          sat_sgMKY [Occ=Once] :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQM)
          [LclId] =
              [$dStorable_sgMKK ptr_sgMKL off_sgMKM] \u []
                  case ptr_sgMKL of {
                    GHC.Ptr.Ptr addr_sgMKP [Occ=Once] ->
                        case off_sgMKM of {
                          GHC.Types.I# x_sgMKR [Occ=Once] ->
                              case
                                  Foreign.Storable.sizeOf
                                      $dStorable_sgMKK Data.Complex.$fStorableComplex8
                              of
                              { GHC.Types.I# y_sgMKU [Occ=Once] ->
                                    case *# [2# y_sgMKU] of sat_sgMKV {
                                      __DEFAULT ->
                                          case *# [x_sgMKR sat_sgMKV] of sat_sgMKW {
                                            __DEFAULT ->
                                                case plusAddr# [addr_sgMKP sat_sgMKW] of sat_sgMKX {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_sgMKX];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          Data.Complex.$fStorableComplex3
              $dStorable_sgMKK sat_sgMKY eta_sgMKN;

Data.Complex.$fStorableComplex4
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> Data.Complex.Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgMKZ ptr_sgML0 off_sgML1 eta_sgML2 eta1_sgML3]
        case eta_sgML2 of {
          Data.Complex.:+ ww1_sgML5 [Occ=Once] ww2_sgML6 [Occ=Once] ->
              let {
                w_sgML7 :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQJ)
                [LclId] =
                    [ptr_sgML0 off_sgML1] \u []
                        case ptr_sgML0 of {
                          GHC.Ptr.Ptr addr_sgML9 [Occ=Once] ->
                              case off_sgML1 of {
                                GHC.Types.I# d_sgMLb [Occ=Once] ->
                                    case plusAddr# [addr_sgML9 d_sgMLb] of sat_sgMLc {
                                      __DEFAULT -> GHC.Ptr.Ptr [sat_sgMLc];
                                    };
                              };
                        };
              } in 
                case
                    Foreign.Storable.poke $dStorable_sgMKZ w_sgML7 ww1_sgML5 eta1_sgML3
                of
                { (#,#) ipv_sgMLe [Occ=Once] _ [Occ=Dead] ->
                      Foreign.Storable.pokeElemOff
                          $dStorable_sgMKZ
                          w_sgML7
                          Data.Complex.$fStorableComplex2
                          ww2_sgML6
                          ipv_sgMLe;
                };
        };

Data.Complex.$w$cpokeElemOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Types.Int
     -> a
     -> a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(1*C1(U(U)),A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMLg w1_sgMLh w2_sgMLi ww_sgMLj ww1_sgMLk w3_sgMLl]
        let {
          w4_sgMLm :: GHC.Ptr.Ptr (Data.Complex.Complex a_sgxtm)
          [LclId] =
              [w_sgMLg w1_sgMLh w2_sgMLi ww_sgMLj] \u []
                  case w1_sgMLh of {
                    GHC.Ptr.Ptr addr_sgMLo [Occ=Once] ->
                        case w2_sgMLi of {
                          GHC.Types.I# x_sgMLq [Occ=Once] ->
                              case Foreign.Storable.sizeOf w_sgMLg ww_sgMLj of {
                                GHC.Types.I# y_sgMLs [Occ=Once] ->
                                    case *# [2# y_sgMLs] of sat_sgMLt {
                                      __DEFAULT ->
                                          case *# [x_sgMLq sat_sgMLt] of sat_sgMLu {
                                            __DEFAULT ->
                                                case plusAddr# [addr_sgMLo sat_sgMLu] of sat_sgMLv {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_sgMLv];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case Foreign.Storable.poke w_sgMLg w4_sgMLm ww_sgMLj w3_sgMLl of {
            (#,#) ipv_sgMLx [Occ=Once] _ [Occ=Dead] ->
                Foreign.Storable.pokeElemOff
                    w_sgMLg
                    w4_sgMLm
                    Data.Complex.$fStorableComplex2
                    ww1_sgMLk
                    ipv_sgMLx;
          };

Data.Complex.$fStorableComplex6 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Types.Int
     -> Data.Complex.Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(C(U(U)),A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMLz w1_sgMLA w2_sgMLB w3_sgMLC w4_sgMLD]
        case w3_sgMLC of {
          Data.Complex.:+ ww1_sgMLF [Occ=Once] ww2_sgMLG [Occ=Once] ->
              Data.Complex.$w$cpokeElemOff
                  w_sgMLz w1_sgMLA w2_sgMLB ww1_sgMLF ww2_sgMLG w4_sgMLD;
        };

Data.Complex.$fStorableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Foreign.Storable.Storable a =>
     Foreign.Storable.Storable (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(U(U)),C(U(U)),C(C1(C1(U(U,U)))),C(C1(C1(C1(U(U,U))))),A,A,C(C1(U(U,U))),C(C1(C1(U(U,A)))))>m] =
    [] \r [$dStorable_sgMLH]
        let {
          sat_sgMLP [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> Data.Complex.Complex a_XgsQI -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fStorableComplex1
                      $dStorable_sgMLH eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMLO [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> GHC.Types.IO (Data.Complex.Complex a_XgsQI)
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B2 eta_B1]
                  Data.Complex.$fStorableComplex3
                      $dStorable_sgMLH eta_B2 eta_B1; } in
        let {
          sat_sgMLN [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> Data.Complex.Complex a_XgsQI -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fStorableComplex4
                      $dStorable_sgMLH eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMLM [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> GHC.Types.IO (Data.Complex.Complex a_XgsQI)
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fStorableComplex5
                      $dStorable_sgMLH eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMLL [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> GHC.Types.Int -> Data.Complex.Complex a_XgsQI -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fStorableComplex6
                      $dStorable_sgMLH eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMLK [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> GHC.Types.Int -> GHC.Types.IO (Data.Complex.Complex a_XgsQI)
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fStorableComplex7
                      $dStorable_sgMLH eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMLJ [Occ=Once]
            :: Data.Complex.Complex a_XgsQI -> GHC.Types.Int
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B1]
                  Data.Complex.$fStorableComplex_$calignment
                      $dStorable_sgMLH eta_B1; } in
        let {
          sat_sgMLI [Occ=Once]
            :: Data.Complex.Complex a_XgsQI -> GHC.Types.Int
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B1]
                  Data.Complex.$fStorableComplex_$csizeOf $dStorable_sgMLH eta_B1;
        } in 
          Foreign.Storable.C:Storable [sat_sgMLI
                                       sat_sgMLJ
                                       sat_sgMLK
                                       sat_sgMLL
                                       sat_sgMLM
                                       sat_sgMLN
                                       sat_sgMLO
                                       sat_sgMLP];

Data.Complex.imagPart :: forall a. Data.Complex.Complex a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgMLQ]
        case ds_sgMLQ of {
          Data.Complex.:+ _ [Occ=Dead] y_sgMLT [Occ=Once] -> y_sgMLT;
        };

Data.Complex.$fMonadComplex_$c>>=
  :: forall a b.
     Data.Complex.Complex a
     -> (a -> Data.Complex.Complex b) -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><C(S(SS)),C(U(U,U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMLU f_sgMLV]
        case ds_sgMLU of {
          Data.Complex.:+ a1_sgMLX [Occ=Once] b1_sgMLY [Occ=Once] ->
              case f_sgMLV a1_sgMLX of {
                Data.Complex.:+ x_sgMM0 [Occ=Once] _ [Occ=Dead] ->
                    case f_sgMLV b1_sgMLY of {
                      Data.Complex.:+ _ [Occ=Dead] y_sgMM4 [Occ=Once] ->
                          Data.Complex.:+ [x_sgMM0 y_sgMM4];
                    };
              };
        };

Data.Complex.$fMonadComplex_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Complex.Complex a
     -> Data.Complex.Complex b -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Complex.$fApplicativeComplex_$c*> eta_B2 eta_B1;

lvl13_rgA6r :: forall a. [GHC.Types.Char] -> Data.Complex.Complex a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sgMM5] GHC.Err.errorWithoutStackTrace eta_sgMM5;

Data.Complex.$fMonadComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Complex.Complex
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Complex.$fApplicativeComplex
                                     Data.Complex.$fMonadComplex_$c>>=
                                     Data.Complex.$fMonadComplex_$c>>
                                     Data.Complex.$fApplicativeComplex_$cpure
                                     lvl13_rgA6r];

Data.Complex.$fDataComplex6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Complex"#;

Data.Complex.$fDataComplex9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Complex.$fDataComplex6;

go61_rgA6s
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgMM6 _ys_sgMM7]
        case ds2_sgMM6 of {
          [] -> GHC.List.badHead;
          : ipv_sgMM9 [Occ=Once!] ipv1_sgMMa [Occ=Once] ->
              case _ys_sgMM7 of {
                [] -> GHC.List.badHead;
                : ipv2_sgMMc [Occ=Once] ipv3_sgMMd [Occ=Once] ->
                    case ipv_sgMM9 of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgMMg [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sgMMg Data.Complex.$fReadComplex3 of {
                            GHC.Types.False -> go61_rgA6s ipv1_sgMMa ipv3_sgMMd;
                            GHC.Types.True -> ipv2_sgMMc;
                          };
                    };
              };
        };

$c:+1_rgA6t :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$c:+2_rgA6u];
Data.Complex.$fDataComplex8 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Complex.$c:+ GHC.Types.[]];
Data.Complex.$fDataComplex7 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Complex.$fDataComplex8];
Data.Complex.$tComplex :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Complex.$fDataComplex9
                                       Data.Complex.$fDataComplex7];
Data.Complex.$c:+ [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$c:+1_rgA6t
                                     Data.Complex.$fReadComplex3
                                     GHC.Types.[]
                                     Data.Data.Infix
                                     Data.Complex.$tComplex];
$c:+2_rgA6u :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rgA6s Data.Complex.$fDataComplex8 Data.Data.mkConstr1;

Data.Complex.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$trModule4];

Data.Complex.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Complex"#;

Data.Complex.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$trModule2];

Data.Complex.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Complex.$trModule3
                                     Data.Complex.$trModule1];

$krep_rgA6v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Complex.$fDataComplex5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$fDataComplex6];

Data.Complex.$tcComplex :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1343342814679332338##
                                    7004386227939987578##
                                    Data.Complex.$trModule
                                    Data.Complex.$fDataComplex5
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep1_rgA6w :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgA6v GHC.Types.[]];

$krep2_rgA6x :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Complex.$tcComplex
                                              $krep1_rgA6w];

$krep3_rgA6y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgA6v $krep2_rgA6x];

Data.Complex.$tc':+1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgA6v $krep3_rgA6y];

Data.Complex.$tc':+3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "':+"#;

Data.Complex.$tc':+2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$tc':+3];

Data.Complex.$tc':+ :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6922641126191179007##
                                    8119904032930905711##
                                    Data.Complex.$trModule
                                    Data.Complex.$tc':+2
                                    1#
                                    Data.Complex.$tc':+1];

Data.Complex.$fDataComplex4
  :: Data.Typeable.Internal.TypeRep Data.Complex.Complex
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                1343342814679332338##
                7004386227939987578##
                Data.Complex.$trModule
                Data.Complex.$fDataComplex5
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sgMMm [Occ=Once]
                   ww9_sgMMn [Occ=Once]
                   ww10_sgMMo [Occ=Once]
                   ww11_sgMMp [Occ=Once]
                   ww12_sgMMq [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sgMMm
                                              ww9_sgMMn
                                              ww10_sgMMo
                                              ww11_sgMMp
                                              ww12_sgMMq];
        };

Data.Complex.$fDataComplex10
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Complex.Complex a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgMMr]
        case Data.Data.$p1Data $dData_sgMMr of sat_sgMMs {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Complex.$fDataComplex4 sat_sgMMs;
        };

Data.Complex.$fDataComplex_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Complex.Complex a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sgMMt $dTypeable_sgMMu]
        let {
          lvl17_sgMMv [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sgMMu] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sgMMu Data.Complex.$fDataComplex4; } in
        let {
          sat_sgMMz [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_agsBY (t_agsBX d))
               -> GHC.Base.Maybe (c_agsBY (Data.Complex.Complex a_XgsGb))
          [LclId] =
              [$dData_sgMMt lvl17_sgMMv] \r [f_sgMMw]
                  case lvl17_sgMMv of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sgMMy [Occ=Once] :: c_agsBY (Data.Complex.Complex a_XgsGb)
                          [LclId] =
                              [$dData_sgMMt f_sgMMw] \u [] f_sgMMw $dData_sgMMt;
                        } in  GHC.Base.Just [sat_sgMMy];
                  };
        } in  sat_sgMMz;

Data.Complex.$fDataComplex1
  :: forall a. (a -> a -> Data.Complex.Complex a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Complex.$W:+ GHC.Types.False];

Data.Complex.$fDataComplex_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Complex.Complex a -> m (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgMMA $dMonadPlus_sgMMB ds_sgMMC eta_sgMMD]
        let {
          lvl17_sgMME [Occ=OnceL] :: m_agsE3 (Data.Complex.Complex a_XgsGk)
          [LclId] =
              [$dMonadPlus_sgMMB] \u [] GHC.Base.mzero $dMonadPlus_sgMMB;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sgMMB
          of
          $dMonad_sgMMF [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgMN9 [Occ=Once]
                    :: (Data.Complex.Complex a_XgsGk, GHC.Types.Bool)
                       -> m_agsE3 (Data.Complex.Complex a_XgsGk)
                  [LclId] =
                      [lvl17_sgMME $dMonad_sgMMF] \r [ds1_sgMN4]
                          case ds1_sgMN4 of {
                            (,) x'_sgMN6 [Occ=Once] b_sgMN7 [Occ=Once!] ->
                                case b_sgMN7 of {
                                  GHC.Types.False -> lvl17_sgMME;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgMMF x'_sgMN6;
                                };
                          }; } in
                let {
                  sat_sgMN3 [Occ=Once]
                    :: m_agsE3 (Data.Complex.Complex a_XgsGk, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sgMMA
                       $dMonadPlus_sgMMB
                       ds_sgMMC
                       eta_sgMMD
                       $dMonad_sgMMF] \u []
                          case eta_sgMMD of {
                            Data.Complex.:+ a1_sgMMH [Occ=Once] a2_sgMMI [Occ=Once] ->
                                let {
                                  k_sgMMJ [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_agsE3 (d -> b)
                                       -> d -> m_agsE3 (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sgMMB
                                                ds_sgMMC
                                                $dMonad_sgMMF] \r [$dData1_sgMMK ds1_sgMML y_sgMMM]
                                          let {
                                            lvl18_sgMMN [Occ=OnceL] :: m_agsE3 d_ae2Ws
                                            [LclId] =
                                                [ds_sgMMC $dData1_sgMMK y_sgMMM] \u []
                                                    ds_sgMMC $dData1_sgMMK y_sgMMM; } in
                                          let {
                                            sat_sgMN0 [Occ=Once]
                                              :: (d_ae2Ws -> b_ae2Wt, GHC.Types.Bool)
                                                 -> m_agsE3 (b_ae2Wt, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sgMMB
                                                 $dMonad_sgMMF
                                                 y_sgMMM
                                                 lvl18_sgMMN] \r [ds2_sgMMO]
                                                    case ds2_sgMMO of {
                                                      (,) h_sgMMQ b1_sgMMR [Occ=Once] ->
                                                          let {
                                                            sat_sgMMZ [Occ=Once]
                                                              :: m_agsE3 (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgMMF
                                                                 y_sgMMM
                                                                 h_sgMMQ
                                                                 b1_sgMMR] \u []
                                                                    let {
                                                                      sat_sgMMX [Occ=Once]
                                                                        :: b_ae2Wt
                                                                      [LclId] =
                                                                          [y_sgMMM h_sgMMQ] \u []
                                                                              h_sgMMQ y_sgMMM; } in
                                                                    let {
                                                                      sat_sgMMY [Occ=Once]
                                                                        :: (b_ae2Wt, GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sgMMX
                                                                                     b1_sgMMR];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sgMMF
                                                                          sat_sgMMY; } in
                                                          let {
                                                            sat_sgMMW [Occ=Once]
                                                              :: m_agsE3 (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgMMF
                                                                 lvl18_sgMMN
                                                                 h_sgMMQ] \u []
                                                                    let {
                                                                      sat_sgMMV [Occ=Once]
                                                                        :: d_ae2Ws
                                                                           -> m_agsE3 (b_ae2Wt,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sgMMF
                                                                           h_sgMMQ] \r [y'_sgMMS]
                                                                              let {
                                                                                sat_sgMMT [Occ=Once]
                                                                                  :: b_ae2Wt
                                                                                [LclId] =
                                                                                    [h_sgMMQ
                                                                                     y'_sgMMS] \u []
                                                                                        h_sgMMQ
                                                                                            y'_sgMMS; } in
                                                                              let {
                                                                                sat_sgMMU [Occ=Once]
                                                                                  :: (b_ae2Wt,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sgMMT
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sgMMF
                                                                                    sat_sgMMU;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sgMMF
                                                                          lvl18_sgMMN
                                                                          sat_sgMMV;
                                                          } in 
                                                            GHC.Base.mplus
                                                                $dMonadPlus_sgMMB
                                                                sat_sgMMW
                                                                sat_sgMMZ;
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sgMMF ds1_sgMML sat_sgMN0; } in
                                let {
                                  sat_sgMN2 [Occ=Once]
                                    :: Data.Data.Mp
                                         m_agsE3 (a_XgsGk -> Data.Complex.Complex a_XgsGk)
                                  [LclId] =
                                      [$dData_sgMMA $dMonad_sgMMF a1_sgMMH k_sgMMJ] \u []
                                          let {
                                            sat_sgMN1 [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_agsE3
                                                   (a_XgsGk
                                                    -> a_XgsGk -> Data.Complex.Complex a_XgsGk)
                                            [LclId] =
                                                [$dMonad_sgMMF] \u []
                                                    GHC.Base.return
                                                        $dMonad_sgMMF Data.Complex.$fDataComplex1;
                                          } in  k_sgMMJ $dData_sgMMA sat_sgMN1 a1_sgMMH;
                                } in  k_sgMMJ $dData_sgMMA sat_sgMN2 a2_sgMMI;
                          };
                } in  GHC.Base.>>= $dMonad_sgMMF sat_sgMN3 sat_sgMN9;
          };

Data.Complex.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> a -> a -> m (Data.Complex.Complex a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMNa w1_sgMNb w2_sgMNc ww_sgMNd ww1_sgMNe]
        let {
          k_sgMNf [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
            :: forall d b.
               Data.Data.Data d =>
               m_sgxtX (d -> b) -> d -> m_sgxtX b
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w1_sgMNb w2_sgMNc] \r [$dData1_sgMNg c_sgMNh x_sgMNi]
                  let {
                    lvl17_sgMNj [Occ=OnceL] :: m_sgxtX d_ae2Vh
                    [LclId] =
                        [w2_sgMNc $dData1_sgMNg x_sgMNi] \u []
                            w2_sgMNc $dData1_sgMNg x_sgMNi; } in
                  let {
                    sat_sgMNo [Occ=Once] :: (d_ae2Vh -> b_ae2Vi) -> m_sgxtX b_ae2Vi
                    [LclId] =
                        [w1_sgMNb lvl17_sgMNj] \r [c'_sgMNk]
                            let {
                              sat_sgMNn [Occ=Once] :: d_ae2Vh -> m_sgxtX b_ae2Vi
                              [LclId] =
                                  [w1_sgMNb c'_sgMNk] \r [x'_sgMNl]
                                      let {
                                        sat_sgMNm [Occ=Once] :: b_ae2Vi
                                        [LclId] =
                                            [c'_sgMNk x'_sgMNl] \u [] c'_sgMNk x'_sgMNl;
                                      } in  GHC.Base.return w1_sgMNb sat_sgMNm;
                            } in  GHC.Base.>>= w1_sgMNb lvl17_sgMNj sat_sgMNn;
                  } in  GHC.Base.>>= w1_sgMNb c_sgMNh sat_sgMNo; } in
        let {
          sat_sgMNq [Occ=Once]
            :: m_sgxtX (a_sgxtV -> Data.Complex.Complex a_sgxtV)
          [LclId] =
              [w_sgMNa w1_sgMNb ww_sgMNd k_sgMNf] \u []
                  let {
                    sat_sgMNp [Occ=Once]
                      :: m_sgxtX (a_sgxtV -> a_sgxtV -> Data.Complex.Complex a_sgxtV)
                    [LclId] =
                        [w1_sgMNb] \u [] GHC.Base.return w1_sgMNb Data.Complex.$W:+;
                  } in  k_sgMNf w_sgMNa sat_sgMNp ww_sgMNd;
        } in  k_sgMNf w_sgMNa sat_sgMNq ww1_sgMNe;

Data.Complex.$fDataComplex_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Complex.Complex a -> m (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMNr w1_sgMNs w2_sgMNt w3_sgMNu]
        case w3_sgMNu of {
          Data.Complex.:+ ww1_sgMNw [Occ=Once] ww2_sgMNx [Occ=Once] ->
              Data.Complex.$w$cgmapM
                  w_sgMNr w1_sgMNs w2_sgMNt ww1_sgMNw ww2_sgMNx;
        };

Data.Complex.$fDataComplex_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Complex.Complex a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgMNy ds_sgMNz ds1_sgMNA x_sgMNB]
        case x_sgMNB of {
          Data.Complex.:+ a1_sgMND [Occ=Once] a2_sgMNE [Occ=Once] ->
              case ds_sgMNz of {
                GHC.Types.I# x1_sgMNG [Occ=Once!] ->
                    case x1_sgMNG of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sgMNA $dData_sgMNy a1_sgMND;
                      1# -> ds1_sgMNA $dData_sgMNy a2_sgMNE;
                    };
              };
        };

Data.Complex.$fDataComplex_$cgmapQr [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Complex.Complex a
     -> r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMNI w1_sgMNJ w2_sgMNK w3_sgMNL w4_sgMNM]
        case w4_sgMNM of {
          Data.Complex.:+ ww1_sgMNO [Occ=Once] ww2_sgMNP [Occ=Once] ->
              let {
                sat_sgMNS [Occ=Once] :: r_sgxu9
                [LclId] =
                    [w_sgMNI w1_sgMNJ w2_sgMNK w3_sgMNL ww2_sgMNP] \u []
                        let {
                          sat_sgMNR [Occ=Once] :: r'_sgxua
                          [LclId] =
                              [w_sgMNI w3_sgMNL ww2_sgMNP] \u [] w3_sgMNL w_sgMNI ww2_sgMNP;
                        } in  w1_sgMNJ sat_sgMNR w2_sgMNK; } in
              let {
                sat_sgMNQ [Occ=Once] :: r'_sgxua
                [LclId] =
                    [w_sgMNI w3_sgMNL ww1_sgMNO] \u [] w3_sgMNL w_sgMNI ww1_sgMNO;
              } in  w1_sgMNJ sat_sgMNQ sat_sgMNS;
        };

Data.Complex.$fDataComplex_$cgmapQ
  :: forall a.
     Data.Data.Data a =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Complex.Complex a -> [u]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,C(C1(U))><S(SS),1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [$dData_sgMNT ds_sgMNU x0_sgMNV]
        case x0_sgMNV of {
          Data.Complex.:+ a1_sgMNX [Occ=Once] a2_sgMNY [Occ=Once] ->
              let {
                sat_sgMO0 [Occ=Once] :: u_agsDl
                [LclId] =
                    [$dData_sgMNT ds_sgMNU a2_sgMNY] \u []
                        ds_sgMNU $dData_sgMNT a2_sgMNY; } in
              let {
                sat_sgMO1 [Occ=Once] :: [u_agsDl]
                [LclId] =
                    CCCS :! [sat_sgMO0 GHC.Types.[]]; } in
              let {
                sat_sgMNZ [Occ=Once] :: u_agsDl
                [LclId] =
                    [$dData_sgMNT ds_sgMNU a1_sgMNX] \u []
                        ds_sgMNU $dData_sgMNT a1_sgMNX;
              } in  : [sat_sgMNZ sat_sgMO1];
        };

Data.Complex.$fDataComplex2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Complex.Complex a
     -> Data.Functor.Const.Const r (Data.Complex.Complex a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMO2 w1_sgMO3 w2_sgMO4 w3_sgMO5 w4_sgMO6]
        case w4_sgMO6 of {
          Data.Complex.:+ ww1_sgMO8 [Occ=Once] ww2_sgMO9 [Occ=Once] ->
              let {
                sat_sgMOc [Occ=Once] :: r'_XgxE2
                [LclId] =
                    [w_sgMO2 w3_sgMO5 ww2_sgMO9] \u [] w3_sgMO5 w_sgMO2 ww2_sgMO9; } in
              let {
                sat_sgMOb [Occ=Once] :: r_XgxE0
                [LclId] =
                    [w_sgMO2 w1_sgMO3 w2_sgMO4 w3_sgMO5 ww1_sgMO8] \u []
                        let {
                          sat_sgMOa [Occ=Once] :: r'_XgxE2
                          [LclId] =
                              [w_sgMO2 w3_sgMO5 ww1_sgMO8] \u [] w3_sgMO5 w_sgMO2 ww1_sgMO8;
                        } in  w1_sgMO3 w2_sgMO4 sat_sgMOa;
              } in  w1_sgMO3 sat_sgMOb sat_sgMOc;
        };

Data.Complex.$fDataComplex3
  :: forall a.
     Data.Data.Data a =>
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Complex.Complex a
     -> Data.Functor.Identity.Identity (Data.Complex.Complex a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dData_sgMOd ds_sgMOe x0_sgMOf]
        case x0_sgMOf of {
          Data.Complex.:+ a1_sgMOh [Occ=Once] a2_sgMOi [Occ=Once] ->
              case ds_sgMOe $dData_sgMOd a1_sgMOh of dt_sgMOj {
                __DEFAULT ->
                    case ds_sgMOe $dData_sgMOd a2_sgMOi of dt1_sgMOk {
                      __DEFAULT -> Data.Complex.:+ [dt_sgMOj dt1_sgMOk];
                    };
              };
        };

Data.Complex.$fDataComplex_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Complex.Complex a -> m (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgMOl $dMonadPlus_sgMOm ds_sgMOn eta_sgMOo]
        let {
          lvl17_sgMOp [Occ=OnceL] :: m_agsEj (Data.Complex.Complex a_XgsGd)
          [LclId] =
              [$dMonadPlus_sgMOm] \u [] GHC.Base.mzero $dMonadPlus_sgMOm;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sgMOm
          of
          $dMonad_sgMOq [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgMOX [Occ=Once]
                    :: (Data.Complex.Complex a_XgsGd, GHC.Types.Bool)
                       -> m_agsEj (Data.Complex.Complex a_XgsGd)
                  [LclId] =
                      [lvl17_sgMOp $dMonad_sgMOq] \r [ds1_sgMOS]
                          case ds1_sgMOS of {
                            (,) x'_sgMOU [Occ=Once] b_sgMOV [Occ=Once!] ->
                                case b_sgMOV of {
                                  GHC.Types.False -> lvl17_sgMOp;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgMOq x'_sgMOU;
                                };
                          }; } in
                let {
                  sat_sgMOR [Occ=Once]
                    :: m_agsEj (Data.Complex.Complex a_XgsGd, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sgMOl
                       $dMonadPlus_sgMOm
                       ds_sgMOn
                       eta_sgMOo
                       $dMonad_sgMOq] \u []
                          case eta_sgMOo of {
                            Data.Complex.:+ a1_sgMOs [Occ=Once] a2_sgMOt [Occ=Once] ->
                                let {
                                  k_sgMOu [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_agsEj (d -> b)
                                       -> d -> m_agsEj (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sgMOm
                                                ds_sgMOn
                                                $dMonad_sgMOq] \r [$dData1_sgMOv ds1_sgMOw y_sgMOx]
                                          let {
                                            lvl18_sgMOy [Occ=OnceL] :: m_agsEj d_ae2Ya
                                            [LclId] =
                                                [ds_sgMOn $dData1_sgMOv y_sgMOx] \u []
                                                    ds_sgMOn $dData1_sgMOv y_sgMOx; } in
                                          let {
                                            sat_sgMOO [Occ=Once]
                                              :: (d_ae2Ya -> b_ae2Yb, GHC.Types.Bool)
                                                 -> m_agsEj (b_ae2Yb, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sgMOm
                                                 $dMonad_sgMOq
                                                 y_sgMOx
                                                 lvl18_sgMOy] \r [ds2_sgMOz]
                                                    case ds2_sgMOz of {
                                                      (,) h_sgMOB b1_sgMOC [Occ=Once!] ->
                                                          case b1_sgMOC of {
                                                            GHC.Types.False ->
                                                                let {
                                                                  sat_sgMOL [Occ=Once]
                                                                    :: m_agsEj (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sgMOq
                                                                       y_sgMOx
                                                                       h_sgMOB] \u []
                                                                          let {
                                                                            sat_sgMOJ [Occ=Once]
                                                                              :: b_ae2Yb
                                                                            [LclId] =
                                                                                [y_sgMOx
                                                                                 h_sgMOB] \u []
                                                                                    h_sgMOB
                                                                                        y_sgMOx; } in
                                                                          let {
                                                                            sat_sgMOK [Occ=Once]
                                                                              :: (b_ae2Yb,
                                                                                  GHC.Types.Bool)
                                                                            [LclId] =
                                                                                CCCS (,)! [sat_sgMOJ
                                                                                           GHC.Types.False];
                                                                          } in 
                                                                            GHC.Base.return
                                                                                $dMonad_sgMOq
                                                                                sat_sgMOK; } in
                                                                let {
                                                                  sat_sgMOI [Occ=Once]
                                                                    :: m_agsEj (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sgMOq
                                                                       lvl18_sgMOy
                                                                       h_sgMOB] \u []
                                                                          let {
                                                                            sat_sgMOH [Occ=Once]
                                                                              :: d_ae2Ya
                                                                                 -> m_agsEj (b_ae2Yb,
                                                                                             GHC.Types.Bool)
                                                                            [LclId] =
                                                                                [$dMonad_sgMOq
                                                                                 h_sgMOB] \r [y'_sgMOE]
                                                                                    let {
                                                                                      sat_sgMOF [Occ=Once]
                                                                                        :: b_ae2Yb
                                                                                      [LclId] =
                                                                                          [h_sgMOB
                                                                                           y'_sgMOE] \u []
                                                                                              h_sgMOB
                                                                                                  y'_sgMOE; } in
                                                                                    let {
                                                                                      sat_sgMOG [Occ=Once]
                                                                                        :: (b_ae2Yb,
                                                                                            GHC.Types.Bool)
                                                                                      [LclId] =
                                                                                          CCCS (,)! [sat_sgMOF
                                                                                                     GHC.Types.True];
                                                                                    } in 
                                                                                      GHC.Base.return
                                                                                          $dMonad_sgMOq
                                                                                          sat_sgMOG;
                                                                          } in 
                                                                            GHC.Base.>>=
                                                                                $dMonad_sgMOq
                                                                                lvl18_sgMOy
                                                                                sat_sgMOH;
                                                                } in 
                                                                  GHC.Base.mplus
                                                                      $dMonadPlus_sgMOm
                                                                      sat_sgMOI
                                                                      sat_sgMOL;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_sgMOM [Occ=Once] :: b_ae2Yb
                                                                  [LclId] =
                                                                      [y_sgMOx h_sgMOB] \u []
                                                                          h_sgMOB y_sgMOx; } in
                                                                let {
                                                                  sat_sgMON [Occ=Once]
                                                                    :: (b_ae2Yb, GHC.Types.Bool)
                                                                  [LclId] =
                                                                      CCCS (,)! [sat_sgMOM
                                                                                 GHC.Types.True];
                                                                } in 
                                                                  GHC.Base.return
                                                                      $dMonad_sgMOq sat_sgMON;
                                                          };
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sgMOq ds1_sgMOw sat_sgMOO; } in
                                let {
                                  sat_sgMOQ [Occ=Once]
                                    :: Data.Data.Mp
                                         m_agsEj (a_XgsGd -> Data.Complex.Complex a_XgsGd)
                                  [LclId] =
                                      [$dData_sgMOl $dMonad_sgMOq a1_sgMOs k_sgMOu] \u []
                                          let {
                                            sat_sgMOP [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_agsEj
                                                   (a_XgsGd
                                                    -> a_XgsGd -> Data.Complex.Complex a_XgsGd)
                                            [LclId] =
                                                [$dMonad_sgMOq] \u []
                                                    GHC.Base.return
                                                        $dMonad_sgMOq Data.Complex.$fDataComplex1;
                                          } in  k_sgMOu $dData_sgMOl sat_sgMOP a1_sgMOs;
                                } in  k_sgMOu $dData_sgMOl sat_sgMOQ a2_sgMOt;
                          };
                } in  GHC.Base.>>= $dMonad_sgMOq sat_sgMOR sat_sgMOX;
          };

lvl14_rgA6z :: forall a. Data.Complex.Complex a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_sgMOY]
        case ds_sgMOY of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> Data.Complex.$c:+;
        };

lvl15_rgA6A
  :: forall a. Data.Complex.Complex a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgMP2] Data.Complex.$tComplex;

lvl16_rgA6B
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Complex.Complex a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgMP3 ds_sgMP4] GHC.Base.Nothing [];

Data.Complex.$fDataComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sgMP5]
        let {
          sat_sgMPh [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Complex.Complex a_XgsGc -> m (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgMP5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapMo
                      $dData_sgMP5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMPg [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Complex.Complex a_XgsGc -> m (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgMP5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapMp
                      $dData_sgMP5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMPf [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Complex.Complex a_XgsGc -> m (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgMP5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapM
                      $dData_sgMP5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMPe [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Complex.Complex a_XgsGc
               -> u
          [LclId] =
              [$dData_sgMP5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapQi
                      $dData_sgMP5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMPd [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Complex.Complex a_XgsGc -> [u]
          [LclId] =
              [$dData_sgMP5] \r [eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapQ $dData_sgMP5 eta_B2 eta_B1; } in
        let {
          sat_sgMPc [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Complex.Complex a_XgsGc
               -> r
          [LclId] =
              [$dData_sgMP5] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapQr
                      $dData_sgMP5 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMPb [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Complex.Complex a_XgsGc
               -> r
          [LclId] =
              [$dData_sgMP5] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex2
                      $dData_sgMP5 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMPa [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Complex.Complex a_XgsGc -> Data.Complex.Complex a_XgsGc
          [LclId] =
              [$dData_sgMP5] \r [eta_B2 eta_B1]
                  Data.Complex.$fDataComplex3 $dData_sgMP5 eta_B2 eta_B1; } in
        let {
          sat_sgMP9 [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Complex.Complex a_XgsGc))
          [LclId] =
              [$dData_sgMP5] \r [eta_B1]
                  Data.Complex.$fDataComplex_$cdataCast1 $dData_sgMP5 eta_B1; } in
        let {
          sat_sgMP8 [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgMP5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgunfold
                      $dData_sgMP5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMP7 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Complex.Complex a_XgsGc
               -> c (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgMP5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgfoldl
                      $dData_sgMP5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMP6 [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgMP5] \u [] Data.Complex.$fDataComplex10 $dData_sgMP5;
        } in 
          Data.Data.C:Data [sat_sgMP6
                            sat_sgMP7
                            sat_sgMP8
                            lvl14_rgA6z
                            lvl15_rgA6A
                            sat_sgMP9
                            lvl16_rgA6B
                            sat_sgMPa
                            sat_sgMPb
                            sat_sgMPc
                            sat_sgMPd
                            sat_sgMPe
                            sat_sgMPf
                            sat_sgMPg
                            sat_sgMPh];

Data.Complex.$fFloatingComplex9 :: GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.F#! [0.0#];

Data.Complex.$fFloatingComplex_$s$cpi1
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [GHC.Float.$fFloatingFloat_$cpi
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$fFloatingComplex_$s$cexp1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMPi]
        case ds_sgMPi of {
          Data.Complex.:+ x_sgMPk [Occ=Once!] y_sgMPl [Occ=Once!] ->
              case x_sgMPk of {
                GHC.Types.F# x1_sgMPn [Occ=Once] ->
                    case y_sgMPl of {
                      GHC.Types.F# x2_sgMPp ->
                          case expFloat# [x1_sgMPn] of expx_sgMPq {
                            __DEFAULT ->
                                case sinFloat# [x2_sgMPp] of sat_sgMPu {
                                  __DEFAULT ->
                                      case timesFloat# [expx_sgMPq sat_sgMPu] of sat_sgMPv {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMPw [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgMPv];
                                            } in 
                                              case cosFloat# [x2_sgMPp] of sat_sgMPr {
                                                __DEFAULT ->
                                                    case
                                                        timesFloat# [expx_sgMPq sat_sgMPr]
                                                    of
                                                    sat_sgMPs
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_sgMPt [Occ=Once] :: GHC.Types.Float
                                                            [LclId] =
                                                                CCCS GHC.Types.F#! [sat_sgMPs];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgMPt sat_sgMPw];
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$csin1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMPx]
        case ds_sgMPx of {
          Data.Complex.:+ x_sgMPz [Occ=Once!] y_sgMPA [Occ=Once!] ->
              case y_sgMPA of {
                GHC.Types.F# x1_sgMPC ->
                    case x_sgMPz of {
                      GHC.Types.F# x2_sgMPE ->
                          case sinhFloat# [x1_sgMPC] of sat_sgMPK {
                            __DEFAULT ->
                                case cosFloat# [x2_sgMPE] of sat_sgMPJ {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgMPJ sat_sgMPK] of sat_sgMPL {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMPM [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgMPL];
                                            } in 
                                              case coshFloat# [x1_sgMPC] of sat_sgMPG {
                                                __DEFAULT ->
                                                    case sinFloat# [x2_sgMPE] of sat_sgMPF {
                                                      __DEFAULT ->
                                                          case
                                                              timesFloat# [sat_sgMPF sat_sgMPG]
                                                          of
                                                          sat_sgMPH
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgMPI [Occ=Once]
                                                                    :: GHC.Types.Float
                                                                  [LclId] =
                                                                      CCCS GHC.Types.F#! [sat_sgMPH];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgMPI
                                                                                   sat_sgMPM];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ccos1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMPN]
        case ds_sgMPN of {
          Data.Complex.:+ x_sgMPP [Occ=Once!] y_sgMPQ [Occ=Once!] ->
              case y_sgMPQ of {
                GHC.Types.F# x1_sgMPS ->
                    case x_sgMPP of {
                      GHC.Types.F# x2_sgMPU ->
                          case sinhFloat# [x1_sgMPS] of sat_sgMQ0 {
                            __DEFAULT ->
                                case sinFloat# [x2_sgMPU] of sat_sgMPZ {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgMPZ sat_sgMQ0] of sat_sgMQ1 {
                                        __DEFAULT ->
                                            case negateFloat# [sat_sgMQ1] of sat_sgMQ2 {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgMQ3 [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [sat_sgMQ2];
                                                  } in 
                                                    case coshFloat# [x1_sgMPS] of sat_sgMPW {
                                                      __DEFAULT ->
                                                          case cosFloat# [x2_sgMPU] of sat_sgMPV {
                                                            __DEFAULT ->
                                                                case
                                                                    timesFloat# [sat_sgMPV
                                                                                 sat_sgMPW]
                                                                of
                                                                sat_sgMPX
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_sgMPY [Occ=Once]
                                                                          :: GHC.Types.Float
                                                                        [LclId] =
                                                                            CCCS GHC.Types.F#! [sat_sgMPX];
                                                                      } in 
                                                                        Data.Complex.:+ [sat_sgMPY
                                                                                         sat_sgMQ3];
                                                                };
                                                          };
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$csinh1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMQ4]
        case ds_sgMQ4 of {
          Data.Complex.:+ x_sgMQ6 [Occ=Once!] y_sgMQ7 [Occ=Once!] ->
              case x_sgMQ6 of {
                GHC.Types.F# x1_sgMQ9 ->
                    case y_sgMQ7 of {
                      GHC.Types.F# x2_sgMQb ->
                          case coshFloat# [x1_sgMQ9] of sat_sgMQh {
                            __DEFAULT ->
                                case sinFloat# [x2_sgMQb] of sat_sgMQg {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgMQg sat_sgMQh] of sat_sgMQi {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMQj [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgMQi];
                                            } in 
                                              case sinhFloat# [x1_sgMQ9] of sat_sgMQd {
                                                __DEFAULT ->
                                                    case cosFloat# [x2_sgMQb] of sat_sgMQc {
                                                      __DEFAULT ->
                                                          case
                                                              timesFloat# [sat_sgMQc sat_sgMQd]
                                                          of
                                                          sat_sgMQe
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgMQf [Occ=Once]
                                                                    :: GHC.Types.Float
                                                                  [LclId] =
                                                                      CCCS GHC.Types.F#! [sat_sgMQe];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgMQf
                                                                                   sat_sgMQj];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ccosh1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMQk]
        case ds_sgMQk of {
          Data.Complex.:+ x_sgMQm [Occ=Once!] y_sgMQn [Occ=Once!] ->
              case x_sgMQm of {
                GHC.Types.F# x1_sgMQp ->
                    case y_sgMQn of {
                      GHC.Types.F# x2_sgMQr ->
                          case sinhFloat# [x1_sgMQp] of sat_sgMQx {
                            __DEFAULT ->
                                case sinFloat# [x2_sgMQr] of sat_sgMQw {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgMQw sat_sgMQx] of sat_sgMQy {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMQz [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgMQy];
                                            } in 
                                              case coshFloat# [x1_sgMQp] of sat_sgMQt {
                                                __DEFAULT ->
                                                    case cosFloat# [x2_sgMQr] of sat_sgMQs {
                                                      __DEFAULT ->
                                                          case
                                                              timesFloat# [sat_sgMQs sat_sgMQt]
                                                          of
                                                          sat_sgMQu
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgMQv [Occ=Once]
                                                                    :: GHC.Types.Float
                                                                  [LclId] =
                                                                      CCCS GHC.Types.F#! [sat_sgMQu];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgMQv
                                                                                   sat_sgMQz];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$s$c/1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgMQA ww1_sgMQB ww2_sgMQC ww3_sgMQD]
        case GHC.Float.$w$cexponent1 ww2_sgMQC of ww4_sgMQE {
          __DEFAULT ->
              case GHC.Float.$w$cexponent1 ww3_sgMQD of ww5_sgMQF {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgMQG [Occ=Once*!T[1], Dmd=<C(S),1*C1(U(U,U))>]
                        :: GHC.Prim.Int# -> (# GHC.Types.Float, GHC.Types.Float #)
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgMQA ww1_sgMQB ww2_sgMQC ww3_sgMQD] \r [ww6_sgMQH]
                              case GHC.Float.$w$cscaleFloat1 ww6_sgMQH ww2_sgMQC of ww7_sgMQI {
                                __DEFAULT ->
                                    case
                                        GHC.Float.$w$cscaleFloat1 ww6_sgMQH ww3_sgMQD
                                    of
                                    ww8_sgMQJ
                                    { __DEFAULT ->
                                          case timesFloat# [ww3_sgMQD ww8_sgMQJ] of sat_sgMQM {
                                            __DEFAULT ->
                                                case
                                                    timesFloat# [ww2_sgMQC ww7_sgMQI]
                                                of
                                                sat_sgMQL
                                                { __DEFAULT ->
                                                      case
                                                          plusFloat# [sat_sgMQL sat_sgMQM]
                                                      of
                                                      y_sgMQK [Dmd=<S,U>]
                                                      { __DEFAULT ->
                                                            case
                                                                timesFloat# [ww1_sgMQB ww8_sgMQJ]
                                                            of
                                                            sat_sgMQO
                                                            { __DEFAULT ->
                                                                  case
                                                                      timesFloat# [ww_sgMQA
                                                                                   ww7_sgMQI]
                                                                  of
                                                                  sat_sgMQN
                                                                  { __DEFAULT ->
                                                                        case
                                                                            plusFloat# [sat_sgMQN
                                                                                        sat_sgMQO]
                                                                        of
                                                                        sat_sgMQP
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  divideFloat# [sat_sgMQP
                                                                                                y_sgMQK]
                                                                              of
                                                                              wild2_sgMQQ
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        timesFloat# [ww_sgMQA
                                                                                                     ww8_sgMQJ]
                                                                                    of
                                                                                    sat_sgMQS
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              timesFloat# [ww1_sgMQB
                                                                                                           ww7_sgMQI]
                                                                                          of
                                                                                          sat_sgMQR
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    minusFloat# [sat_sgMQR
                                                                                                                 sat_sgMQS]
                                                                                                of
                                                                                                sat_sgMQT
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          divideFloat# [sat_sgMQT
                                                                                                                        y_sgMQK]
                                                                                                      of
                                                                                                      wild1_sgMQU
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgMQW [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [wild1_sgMQU]; } in
                                                                                                            let {
                                                                                                              sat_sgMQV [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [wild2_sgMQQ];
                                                                                                            } in 
                                                                                                              (#,#) [sat_sgMQV
                                                                                                                     sat_sgMQW];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww4_sgMQE ww5_sgMQF] of {
                        __DEFAULT ->
                            case negateInt# [ww4_sgMQE] of sat_sgMQY {
                              __DEFAULT -> $j_sgMQG sat_sgMQY;
                            };
                        1# ->
                            case negateInt# [ww5_sgMQF] of sat_sgMQZ {
                              __DEFAULT -> $j_sgMQG sat_sgMQZ;
                            };
                      };
              };
        };

Data.Complex.$fFloatingComplex_$s$c/1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMR0 w1_sgMR1]
        case w_sgMR0 of {
          Data.Complex.:+ ww1_sgMR3 [Occ=Once!] ww2_sgMR4 [Occ=Once!] ->
              case ww1_sgMR3 of {
                GHC.Types.F# ww4_sgMR6 [Occ=Once] ->
                    case ww2_sgMR4 of {
                      GHC.Types.F# ww6_sgMR8 [Occ=Once] ->
                          case w1_sgMR1 of {
                            Data.Complex.:+ ww8_sgMRa [Occ=Once!] ww9_sgMRb [Occ=Once!] ->
                                case ww8_sgMRa of {
                                  GHC.Types.F# ww11_sgMRd [Occ=Once] ->
                                      case ww9_sgMRb of {
                                        GHC.Types.F# ww13_sgMRf [Occ=Once] ->
                                            case
                                                Data.Complex.$w$s$c/1
                                                    ww4_sgMR6 ww6_sgMR8 ww11_sgMRd ww13_sgMRf
                                            of
                                            { (#,#) ww15_sgMRh [Occ=Once] ww16_sgMRi [Occ=Once] ->
                                                  Data.Complex.:+ [ww15_sgMRh ww16_sgMRi];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromRational1
  :: GHC.Real.Rational -> Data.Complex.Complex GHC.Types.Float
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [a_sgMRj]
        case a_sgMRj of {
          GHC.Real.:% n_sgMRl [Occ=Once] d_sgMRm [Occ=Once] ->
              case GHC.Float.rationalToFloat n_sgMRl d_sgMRm of dt_sgMRn {
                GHC.Types.F# _ [Occ=Dead] ->
                    Data.Complex.:+ [dt_sgMRn Data.Complex.$fFloatingComplex9];
              };
        };

Data.Complex.$fFloatingComplex_$s$c+1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMRp w1_sgMRq]
        case w_sgMRp of {
          Data.Complex.:+ ww1_sgMRs [Occ=Once!] ww2_sgMRt [Occ=Once!] ->
              case ww1_sgMRs of {
                GHC.Types.F# ww4_sgMRv [Occ=Once] ->
                    case ww2_sgMRt of {
                      GHC.Types.F# ww6_sgMRx [Occ=Once] ->
                          case w1_sgMRq of {
                            Data.Complex.:+ ww8_sgMRz [Occ=Once!] ww9_sgMRA [Occ=Once!] ->
                                case ww8_sgMRz of {
                                  GHC.Types.F# ww11_sgMRC [Occ=Once] ->
                                      case ww9_sgMRA of {
                                        GHC.Types.F# ww13_sgMRE [Occ=Once] ->
                                            case plusFloat# [ww6_sgMRx ww13_sgMRE] of sat_sgMRH {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgMRI [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [sat_sgMRH];
                                                  } in 
                                                    case
                                                        plusFloat# [ww4_sgMRv ww11_sgMRC]
                                                    of
                                                    sat_sgMRF
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_sgMRG [Occ=Once] :: GHC.Types.Float
                                                            [LclId] =
                                                                CCCS GHC.Types.F#! [sat_sgMRF];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgMRG sat_sgMRI];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c-1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMRJ w1_sgMRK]
        case w_sgMRJ of {
          Data.Complex.:+ ww1_sgMRM [Occ=Once!] ww2_sgMRN [Occ=Once!] ->
              case ww1_sgMRM of {
                GHC.Types.F# ww4_sgMRP [Occ=Once] ->
                    case ww2_sgMRN of {
                      GHC.Types.F# ww6_sgMRR [Occ=Once] ->
                          case w1_sgMRK of {
                            Data.Complex.:+ ww8_sgMRT [Occ=Once!] ww9_sgMRU [Occ=Once!] ->
                                case ww8_sgMRT of {
                                  GHC.Types.F# ww11_sgMRW [Occ=Once] ->
                                      case ww9_sgMRU of {
                                        GHC.Types.F# ww13_sgMRY [Occ=Once] ->
                                            case minusFloat# [ww6_sgMRR ww13_sgMRY] of sat_sgMS1 {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgMS2 [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [sat_sgMS1];
                                                  } in 
                                                    case
                                                        minusFloat# [ww4_sgMRP ww11_sgMRW]
                                                    of
                                                    sat_sgMRZ
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_sgMS0 [Occ=Once] :: GHC.Types.Float
                                                            [LclId] =
                                                                CCCS GHC.Types.F#! [sat_sgMRZ];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgMS0 sat_sgMS2];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c*1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMS3 w1_sgMS4]
        case w_sgMS3 of {
          Data.Complex.:+ ww1_sgMS6 [Occ=Once!] ww2_sgMS7 [Occ=Once!] ->
              case ww1_sgMS6 of {
                GHC.Types.F# ww4_sgMS9 ->
                    case ww2_sgMS7 of {
                      GHC.Types.F# ww6_sgMSb ->
                          case w1_sgMS4 of {
                            Data.Complex.:+ ww8_sgMSd [Occ=Once!] ww9_sgMSe [Occ=Once!] ->
                                case ww8_sgMSd of {
                                  GHC.Types.F# ww11_sgMSg ->
                                      case ww9_sgMSe of {
                                        GHC.Types.F# ww13_sgMSi ->
                                            case timesFloat# [ww6_sgMSb ww11_sgMSg] of sat_sgMSo {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [ww4_sgMS9 ww13_sgMSi]
                                                  of
                                                  sat_sgMSn
                                                  { __DEFAULT ->
                                                        case
                                                            plusFloat# [sat_sgMSn sat_sgMSo]
                                                        of
                                                        sat_sgMSp
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_sgMSq [Occ=Once]
                                                                  :: GHC.Types.Float
                                                                [LclId] =
                                                                    CCCS GHC.Types.F#! [sat_sgMSp];
                                                              } in 
                                                                case
                                                                    timesFloat# [ww6_sgMSb
                                                                                 ww13_sgMSi]
                                                                of
                                                                sat_sgMSk
                                                                { __DEFAULT ->
                                                                      case
                                                                          timesFloat# [ww4_sgMS9
                                                                                       ww11_sgMSg]
                                                                      of
                                                                      sat_sgMSj
                                                                      { __DEFAULT ->
                                                                            case
                                                                                minusFloat# [sat_sgMSj
                                                                                             sat_sgMSk]
                                                                            of
                                                                            sat_sgMSl
                                                                            { __DEFAULT ->
                                                                                  let {
                                                                                    sat_sgMSm [Occ=Once]
                                                                                      :: GHC.Types.Float
                                                                                    [LclId] =
                                                                                        CCCS GHC.Types.F#! [sat_sgMSl];
                                                                                  } in 
                                                                                    Data.Complex.:+ [sat_sgMSm
                                                                                                     sat_sgMSq];
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cnegate1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMSr]
        case ds_sgMSr of {
          Data.Complex.:+ x_sgMSt [Occ=Once!] y_sgMSu [Occ=Once!] ->
              case x_sgMSt of {
                GHC.Types.F# x1_sgMSw [Occ=Once] ->
                    case y_sgMSu of {
                      GHC.Types.F# x2_sgMSy [Occ=Once] ->
                          case negateFloat# [x2_sgMSy] of sat_sgMSB {
                            __DEFAULT ->
                                let {
                                  sat_sgMSC [Occ=Once] :: GHC.Types.Float
                                  [LclId] =
                                      CCCS GHC.Types.F#! [sat_sgMSB];
                                } in 
                                  case negateFloat# [x1_sgMSw] of sat_sgMSz {
                                    __DEFAULT ->
                                        let {
                                          sat_sgMSA [Occ=Once] :: GHC.Types.Float
                                          [LclId] =
                                              CCCS GHC.Types.F#! [sat_sgMSz];
                                        } in  Data.Complex.:+ [sat_sgMSA sat_sgMSC];
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromInteger1
  :: GHC.Integer.Type.Integer -> Data.Complex.Complex GHC.Types.Float
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [n_sgMSD]
        case GHC.Integer.Type.floatFromInteger n_sgMSD of wild_sgMSE {
          __DEFAULT ->
              let {
                sat_sgMSF [Occ=Once] :: GHC.Types.Float
                [LclId] =
                    CCCS GHC.Types.F#! [wild_sgMSE];
              } in  Data.Complex.:+ [sat_sgMSF Data.Complex.$fFloatingComplex9];
        };

Data.Complex.conjugate_$sconjugate
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMSG]
        case ds_sgMSG of {
          Data.Complex.:+ x_sgMSI [Occ=Once] y_sgMSJ [Occ=Once!] ->
              case y_sgMSJ of {
                GHC.Types.D# x1_sgMSL [Occ=Once] ->
                    case negateDouble# [x1_sgMSL] of sat_sgMSM {
                      __DEFAULT ->
                          let {
                            sat_sgMSN [Occ=Once] :: GHC.Types.Double
                            [LclId] =
                                CCCS GHC.Types.D#! [sat_sgMSM];
                          } in  Data.Complex.:+ [x_sgMSI sat_sgMSN];
                    };
              };
        };

Data.Complex.conjugate
  :: forall a.
     GHC.Num.Num a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LLL),1*U(A,A,A,1*C1(U),A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dNum_sgMSO ds_sgMSP]
        case ds_sgMSP of {
          Data.Complex.:+ x_sgMSR [Occ=Once] y_sgMSS [Occ=Once] ->
              case GHC.Num.negate $dNum_sgMSO y_sgMSS of dt_sgMST {
                __DEFAULT -> Data.Complex.:+ [x_sgMSR dt_sgMST];
              };
        };

Data.Complex.cis_$scis
  :: GHC.Types.Double -> Data.Complex.Complex GHC.Types.Double
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [theta_sgMSU]
        case theta_sgMSU of {
          GHC.Types.D# x_sgMSW ->
              case sinDouble# [x_sgMSW] of sat_sgMSZ {
                __DEFAULT ->
                    let {
                      sat_sgMT0 [Occ=Once] :: GHC.Types.Double
                      [LclId] =
                          CCCS GHC.Types.D#! [sat_sgMSZ];
                    } in 
                      case cosDouble# [x_sgMSW] of sat_sgMSX {
                        __DEFAULT ->
                            let {
                              sat_sgMSY [Occ=Once] :: GHC.Types.Double
                              [LclId] =
                                  CCCS GHC.Types.D#! [sat_sgMSX];
                            } in  Data.Complex.:+ [sat_sgMSY sat_sgMT0];
                      };
              };
        };

Data.Complex.cis
  :: forall a. GHC.Float.Floating a => a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)C(S)LLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgMT1 theta_sgMT2]
        case GHC.Float.cos $dFloating_sgMT1 theta_sgMT2 of dt_sgMT3 {
          __DEFAULT ->
              case GHC.Float.sin $dFloating_sgMT1 theta_sgMT2 of dt1_sgMT4 {
                __DEFAULT -> Data.Complex.:+ [dt_sgMT3 dt1_sgMT4];
              };
        };

Data.Complex.mkPolar_$smkPolar
  :: GHC.Types.Double
     -> GHC.Types.Double -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [r_sgMT5 theta_sgMT6]
        case r_sgMT5 of {
          GHC.Types.D# x_sgMT8 ->
              case theta_sgMT6 of {
                GHC.Types.D# x1_sgMTa ->
                    case sinDouble# [x1_sgMTa] of sat_sgMTe {
                      __DEFAULT ->
                          case *## [x_sgMT8 sat_sgMTe] of sat_sgMTf {
                            __DEFAULT ->
                                let {
                                  sat_sgMTg [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [sat_sgMTf];
                                } in 
                                  case cosDouble# [x1_sgMTa] of sat_sgMTb {
                                    __DEFAULT ->
                                        case *## [x_sgMT8 sat_sgMTb] of sat_sgMTc {
                                          __DEFAULT ->
                                              let {
                                                sat_sgMTd [Occ=Once] :: GHC.Types.Double
                                                [LclId] =
                                                    CCCS GHC.Types.D#! [sat_sgMTc];
                                              } in  Data.Complex.:+ [sat_sgMTd sat_sgMTg];
                                        };
                                  };
                          };
                    };
              };
        };

Data.Complex.$wmkPolar [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.Floating a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LLC(C(S))LLLL)LLL)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A,A),A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMTh w1_sgMTi w2_sgMTj]
        case
            GHC.Float.$p1Floating w_sgMTh
        of
        $dFractional_sgMTk [Dmd=<S(S(LLC(C(S))LLLL)LLL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Fractional $dFractional_sgMTk
              of
              $dNum_sgMTl [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
              { __DEFAULT ->
                    let {
                      sat_sgMTm [Occ=Once] :: a_sgxwP
                      [LclId] =
                          [w_sgMTh w2_sgMTj] \u [] GHC.Float.cos w_sgMTh w2_sgMTj;
                    } in 
                      case GHC.Num.* $dNum_sgMTl w1_sgMTi sat_sgMTm of dt_sgMTn {
                        __DEFAULT ->
                            let {
                              sat_sgMTo [Occ=Once] :: a_sgxwP
                              [LclId] =
                                  [w_sgMTh w2_sgMTj] \u [] GHC.Float.sin w_sgMTh w2_sgMTj;
                            } in 
                              case GHC.Num.* $dNum_sgMTl w1_sgMTi sat_sgMTo of dt1_sgMTp {
                                __DEFAULT -> (#,#) [dt_sgMTn dt1_sgMTp];
                              };
                      };
              };
        };

Data.Complex.mkPolar [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.Floating a =>
     a -> a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LLC(C(S))LLLL)LLL)LLLLLLLLLLLLLLLLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),A,A,A),A,A,A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgMTq w1_sgMTr w2_sgMTs]
        case Data.Complex.$wmkPolar w_sgMTq w1_sgMTr w2_sgMTs of {
          (#,#) ww1_sgMTu [Occ=Once] ww2_sgMTv [Occ=Once] ->
              Data.Complex.:+ [ww1_sgMTu ww2_sgMTv];
        };

Data.Complex.$w$sphase [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> GHC.Prim.Double#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_sgMTw ww1_sgMTx]
        case ==## [ww_sgMTw 0.0##] of {
          __DEFAULT ->
              let {
                sat_sgMTz [Occ=Once] :: GHC.Types.Double
                [LclId] =
                    CCCS GHC.Types.D#! [ww1_sgMTx];
              } in  GHC.Float.$w$catan2 sat_sgMTz ww_sgMTw;
          1# ->
              case ==## [ww1_sgMTx 0.0##] of {
                __DEFAULT ->
                    let {
                      sat_sgMTB [Occ=Once] :: GHC.Types.Double
                      [LclId] =
                          CCCS GHC.Types.D#! [ww1_sgMTx];
                    } in  GHC.Float.$w$catan2 sat_sgMTB ww_sgMTw;
                1# -> 0.0##;
              };
        };

Data.Complex.$fFloatingComplex_$sphase [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double -> GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMTC]
        case w_sgMTC of {
          Data.Complex.:+ ww1_sgMTE [Occ=Once!] ww2_sgMTF [Occ=Once!] ->
              case ww1_sgMTE of {
                GHC.Types.D# ww4_sgMTH [Occ=Once] ->
                    case ww2_sgMTF of {
                      GHC.Types.D# ww6_sgMTJ [Occ=Once] ->
                          case Data.Complex.$w$sphase ww4_sgMTH ww6_sgMTJ of ww7_sgMTK {
                            __DEFAULT -> GHC.Types.D# [ww7_sgMTK];
                          };
                    };
              };
        };

Data.Complex.$w$sphase1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> GHC.Prim.Float#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_sgMTL ww1_sgMTM]
        case eqFloat# [ww_sgMTL 0.0#] of {
          __DEFAULT ->
              let {
                sat_sgMTO [Occ=Once] :: GHC.Types.Float
                [LclId] =
                    CCCS GHC.Types.F#! [ww1_sgMTM];
              } in  GHC.Float.$w$catan1 sat_sgMTO ww_sgMTL;
          1# ->
              case eqFloat# [ww1_sgMTM 0.0#] of {
                __DEFAULT ->
                    let {
                      sat_sgMTQ [Occ=Once] :: GHC.Types.Float
                      [LclId] =
                          CCCS GHC.Types.F#! [ww1_sgMTM];
                    } in  GHC.Float.$w$catan1 sat_sgMTQ ww_sgMTL;
                1# -> 0.0#;
              };
        };

Data.Complex.$fFloatingComplex_$sphase1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float -> GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMTR]
        case w_sgMTR of {
          Data.Complex.:+ ww1_sgMTT [Occ=Once!] ww2_sgMTU [Occ=Once!] ->
              case ww1_sgMTT of {
                GHC.Types.F# ww4_sgMTW [Occ=Once] ->
                    case ww2_sgMTU of {
                      GHC.Types.F# ww6_sgMTY [Occ=Once] ->
                          case Data.Complex.$w$sphase1 ww4_sgMTW ww6_sgMTY of ww7_sgMTZ {
                            __DEFAULT -> GHC.Types.F# [ww7_sgMTZ];
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex17 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Complex.$wphase [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMU0 ww_sgMU1 ww1_sgMU2]
        case
            GHC.Float.$p1RealFloat w_sgMU0
        of
        $dRealFrac_sgMU3 [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgMU3
              of
              $dReal_sgMU4 [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      $dNum_sgMU5 [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_sgxxx
                      [LclId] =
                          [$dReal_sgMU4] \u [] GHC.Real.$p1Real $dReal_sgMU4;
                    } in 
                      case
                          GHC.Real.$p2Real $dReal_sgMU4
                      of
                      $dOrd_sgMU6 [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                      { __DEFAULT ->
                            case
                                GHC.Classes.$p1Ord $dOrd_sgMU6
                            of
                            $dEq_sgMU7 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                            { __DEFAULT ->
                                  let {
                                    sat_sgMU8 [Occ=Once] :: a_sgxxx
                                    [LclId] =
                                        [$dNum_sgMU5] \u []
                                            GHC.Num.fromInteger
                                                $dNum_sgMU5 Data.Complex.$fFloatingComplex17;
                                  } in 
                                    case GHC.Classes.== $dEq_sgMU7 ww_sgMU1 sat_sgMU8 of {
                                      GHC.Types.False -> GHC.Float.atan2 w_sgMU0 ww1_sgMU2 ww_sgMU1;
                                      GHC.Types.True ->
                                          let {
                                            sat_sgMUa [Occ=Once] :: a_sgxxx
                                            [LclId] =
                                                [$dNum_sgMU5] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_sgMU5
                                                        Data.Complex.$fFloatingComplex17;
                                          } in 
                                            case GHC.Classes.== $dEq_sgMU7 ww1_sgMU2 sat_sgMUa of {
                                              GHC.Types.False ->
                                                  GHC.Float.atan2 w_sgMU0 ww1_sgMU2 ww_sgMU1;
                                              GHC.Types.True ->
                                                  GHC.Num.fromInteger
                                                      $dNum_sgMU5 Data.Complex.$fFloatingComplex17;
                                            };
                                    };
                            };
                      };
              };
        };

Data.Complex.phase [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMUc w1_sgMUd]
        case w1_sgMUd of {
          Data.Complex.:+ ww1_sgMUf [Occ=Once] ww2_sgMUg [Occ=Once] ->
              Data.Complex.$wphase w_sgMUc ww1_sgMUf ww2_sgMUg;
        };

Data.Complex.$w$smagnitude [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> GHC.Prim.Double#
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgMUh ww1_sgMUi]
        case GHC.Float.$w$cexponent ww_sgMUh of ww2_sgMUj {
          __DEFAULT ->
              case GHC.Float.$w$cexponent ww1_sgMUi of ww3_sgMUk {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgMUl [Occ=Once*!T[1], Dmd=<C(S),1*C1(U)>]
                        :: GHC.Prim.Int# -> GHC.Prim.Double#
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgMUh ww1_sgMUi] \r [x_sgMUm]
                              case negateInt# [x_sgMUm] of ww4_sgMUn [Dmd=<S,U>] {
                                __DEFAULT ->
                                    case GHC.Float.$w$cscaleFloat ww4_sgMUn ww_sgMUh of ww5_sgMUo {
                                      __DEFAULT ->
                                          case
                                              GHC.Float.$w$cscaleFloat ww4_sgMUn ww1_sgMUi
                                          of
                                          ww6_sgMUp
                                          { __DEFAULT ->
                                                case *## [ww6_sgMUp ww6_sgMUp] of sat_sgMUr {
                                                  __DEFAULT ->
                                                      case *## [ww5_sgMUo ww5_sgMUo] of sat_sgMUq {
                                                        __DEFAULT ->
                                                            case
                                                                +## [sat_sgMUq sat_sgMUr]
                                                            of
                                                            sat_sgMUs
                                                            { __DEFAULT ->
                                                                  case
                                                                      sqrtDouble# [sat_sgMUs]
                                                                  of
                                                                  sat_sgMUt
                                                                  { __DEFAULT ->
                                                                        GHC.Float.$w$cscaleFloat
                                                                            x_sgMUm sat_sgMUt;
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww2_sgMUj ww3_sgMUk] of {
                        __DEFAULT -> $j_sgMUl ww2_sgMUj;
                        1# -> $j_sgMUl ww3_sgMUk;
                      };
              };
        };

Data.Complex.$fFloatingComplex_$smagnitude [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double -> GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMUv]
        case w_sgMUv of {
          Data.Complex.:+ ww1_sgMUx [Occ=Once!] ww2_sgMUy [Occ=Once!] ->
              case ww1_sgMUx of {
                GHC.Types.D# ww4_sgMUA [Occ=Once] ->
                    case ww2_sgMUy of {
                      GHC.Types.D# ww6_sgMUC [Occ=Once] ->
                          case Data.Complex.$w$smagnitude ww4_sgMUA ww6_sgMUC of ww7_sgMUD {
                            __DEFAULT -> GHC.Types.D# [ww7_sgMUD];
                          };
                    };
              };
        };

Data.Complex.$w$smagnitude1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> GHC.Prim.Float#
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgMUE ww1_sgMUF]
        case GHC.Float.$w$cexponent1 ww_sgMUE of ww2_sgMUG {
          __DEFAULT ->
              case GHC.Float.$w$cexponent1 ww1_sgMUF of ww3_sgMUH {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgMUI [Occ=Once*!T[1], Dmd=<C(S),1*C1(U)>]
                        :: GHC.Prim.Int# -> GHC.Prim.Float#
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgMUE ww1_sgMUF] \r [x_sgMUJ]
                              case negateInt# [x_sgMUJ] of ww4_sgMUK [Dmd=<S,U>] {
                                __DEFAULT ->
                                    case GHC.Float.$w$cscaleFloat1 ww4_sgMUK ww_sgMUE of ww5_sgMUL {
                                      __DEFAULT ->
                                          case
                                              GHC.Float.$w$cscaleFloat1 ww4_sgMUK ww1_sgMUF
                                          of
                                          ww6_sgMUM
                                          { __DEFAULT ->
                                                case
                                                    timesFloat# [ww6_sgMUM ww6_sgMUM]
                                                of
                                                sat_sgMUO
                                                { __DEFAULT ->
                                                      case
                                                          timesFloat# [ww5_sgMUL ww5_sgMUL]
                                                      of
                                                      sat_sgMUN
                                                      { __DEFAULT ->
                                                            case
                                                                plusFloat# [sat_sgMUN sat_sgMUO]
                                                            of
                                                            sat_sgMUP
                                                            { __DEFAULT ->
                                                                  case
                                                                      sqrtFloat# [sat_sgMUP]
                                                                  of
                                                                  sat_sgMUQ
                                                                  { __DEFAULT ->
                                                                        GHC.Float.$w$cscaleFloat1
                                                                            x_sgMUJ sat_sgMUQ;
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww2_sgMUG ww3_sgMUH] of {
                        __DEFAULT -> $j_sgMUI ww2_sgMUG;
                        1# -> $j_sgMUI ww3_sgMUH;
                      };
              };
        };

Data.Complex.$fFloatingComplex_$smagnitude1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float -> GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMUS]
        case w_sgMUS of {
          Data.Complex.:+ ww1_sgMUU [Occ=Once!] ww2_sgMUV [Occ=Once!] ->
              case ww1_sgMUU of {
                GHC.Types.F# ww4_sgMUX [Occ=Once] ->
                    case ww2_sgMUV of {
                      GHC.Types.F# ww6_sgMUZ [Occ=Once] ->
                          case Data.Complex.$w$smagnitude1 ww4_sgMUX ww6_sgMUZ of ww7_sgMV0 {
                            __DEFAULT -> GHC.Types.F# [ww7_sgMV0];
                          };
                    };
              };
        };

Data.Complex.$wmagnitude [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(C(S))LLLLLL),U(1*U(1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMV1 ww_sgMV2 ww1_sgMV3]
        let {
          k_sgMV4 [Dmd=<L,U(U)>] :: GHC.Types.Int
          [LclId] =
              [w_sgMV1 ww_sgMV2 ww1_sgMV3] \u []
                  case GHC.Float.exponent w_sgMV1 ww_sgMV2 of wild_sgMV5 {
                    GHC.Types.I# x1_sgMV6 [Occ=Once] ->
                        case GHC.Float.exponent w_sgMV1 ww1_sgMV3 of wild1_sgMV7 {
                          GHC.Types.I# y1_sgMV8 [Occ=Once] ->
                              case <=# [x1_sgMV6 y1_sgMV8] of {
                                __DEFAULT -> wild_sgMV5;
                                1# -> wild1_sgMV7;
                              };
                        };
                  }; } in
        let {
          sat_sgMVn [Occ=Once] :: a_sgxyi
          [LclId] =
              [w_sgMV1 ww_sgMV2 ww1_sgMV3 k_sgMV4] \u []
                  let {
                    sat_sgMVm [Occ=Once] :: a_sgxyi
                    [LclId] =
                        [w_sgMV1 ww_sgMV2 ww1_sgMV3 k_sgMV4] \u []
                            case
                                GHC.Float.$p1RealFloat w_sgMV1
                            of
                            $dRealFrac_sgMVb [Dmd=<S(S(S(C(C(S))LLLLLL)LL)LLLLLL),1*U(1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
                            { __DEFAULT ->
                                  case
                                      GHC.Real.$p1RealFrac $dRealFrac_sgMVb
                                  of
                                  $dReal_sgMVc [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A)>]
                                  { __DEFAULT ->
                                        case
                                            GHC.Real.$p1Real $dReal_sgMVc
                                        of
                                        $dNum_sgMVd [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A)>]
                                        { __DEFAULT ->
                                              let {
                                                mk_sgMVe :: GHC.Types.Int
                                                [LclId] =
                                                    [k_sgMV4] \u []
                                                        case k_sgMV4 of {
                                                          GHC.Types.I# x_sgMVg [Occ=Once] ->
                                                              case
                                                                  negateInt# [x_sgMVg]
                                                              of
                                                              sat_sgMVh
                                                              { __DEFAULT ->
                                                                    GHC.Types.I# [sat_sgMVh];
                                                              };
                                                        }; } in
                                              let {
                                                sat_sgMVl [Occ=Once] :: a_sgxyi
                                                [LclId] =
                                                    [w_sgMV1 ww1_sgMV3 $dNum_sgMVd mk_sgMVe] \u []
                                                        let {
                                                          z_sgMVk :: a_sgxyi
                                                          [LclId] =
                                                              [w_sgMV1 ww1_sgMV3 mk_sgMVe] \u []
                                                                  GHC.Float.scaleFloat
                                                                      w_sgMV1 mk_sgMVe ww1_sgMV3;
                                                        } in 
                                                          GHC.Num.*
                                                              $dNum_sgMVd z_sgMVk z_sgMVk; } in
                                              let {
                                                sat_sgMVj [Occ=Once] :: a_sgxyi
                                                [LclId] =
                                                    [w_sgMV1 ww_sgMV2 $dNum_sgMVd mk_sgMVe] \u []
                                                        let {
                                                          z_sgMVi :: a_sgxyi
                                                          [LclId] =
                                                              [w_sgMV1 ww_sgMV2 mk_sgMVe] \u []
                                                                  GHC.Float.scaleFloat
                                                                      w_sgMV1 mk_sgMVe ww_sgMV2;
                                                        } in  GHC.Num.* $dNum_sgMVd z_sgMVi z_sgMVi;
                                              } in  GHC.Num.+ $dNum_sgMVd sat_sgMVj sat_sgMVl;
                                        };
                                  };
                            };
                  } in 
                    case GHC.Float.$p2RealFloat w_sgMV1 of sat_sgMVa {
                      __DEFAULT -> GHC.Float.sqrt sat_sgMVa sat_sgMVm;
                    };
        } in  GHC.Float.scaleFloat w_sgMV1 k_sgMV4 sat_sgMVn;

Data.Complex.magnitude [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMVo w1_sgMVp]
        case w1_sgMVp of {
          Data.Complex.:+ ww1_sgMVr [Occ=Once] ww2_sgMVs [Occ=Once] ->
              Data.Complex.$wmagnitude w_sgMVo ww1_sgMVr ww2_sgMVs;
        };

Data.Complex.$fFloatingComplex_$s$clog1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMVt]
        case w_sgMVt of {
          Data.Complex.:+ ww1_sgMVv [Occ=Once!] ww2_sgMVw [Occ=Once!] ->
              case ww1_sgMVv of {
                GHC.Types.F# ww4_sgMVy ->
                    case ww2_sgMVw of {
                      GHC.Types.F# ww6_sgMVA ->
                          case Data.Complex.$w$smagnitude1 ww4_sgMVy ww6_sgMVA of ww7_sgMVB {
                            __DEFAULT ->
                                case logFloat# [ww7_sgMVB] of wild1_sgMVC {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$sphase1 ww4_sgMVy ww6_sgMVA
                                      of
                                      ww8_sgMVD
                                      { __DEFAULT ->
                                            let {
                                              sat_sgMVF [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [ww8_sgMVD]; } in
                                            let {
                                              sat_sgMVE [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [wild1_sgMVC];
                                            } in  Data.Complex.:+ [sat_sgMVE sat_sgMVF];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cabs1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [z_sgMVG]
        case z_sgMVG of {
          Data.Complex.:+ ww1_sgMVI [Occ=Once!] ww2_sgMVJ [Occ=Once!] ->
              case ww1_sgMVI of {
                GHC.Types.F# ww4_sgMVL [Occ=Once] ->
                    case ww2_sgMVJ of {
                      GHC.Types.F# ww6_sgMVN [Occ=Once] ->
                          case Data.Complex.$w$smagnitude1 ww4_sgMVL ww6_sgMVN of ww7_sgMVO {
                            __DEFAULT ->
                                let {
                                  sat_sgMVP [Occ=Once] :: GHC.Types.Float
                                  [LclId] =
                                      CCCS GHC.Types.F#! [ww7_sgMVO];
                                } in  Data.Complex.:+ [sat_sgMVP Data.Complex.$fFloatingComplex9];
                          };
                    };
              };
        };

Data.Complex.polar_$spolar
  :: Data.Complex.Complex GHC.Types.Double
     -> (GHC.Types.Double, GHC.Types.Double)
[GblId, Arity=1, Str=<L,U(U(U),U(U))>m, Unf=OtherCon []] =
    [] \r [z_sgMVQ]
        let {
          sat_sgMVS [Occ=Once] :: GHC.Types.Double
          [LclId] =
              [z_sgMVQ] \u []
                  Data.Complex.$fFloatingComplex_$sphase z_sgMVQ; } in
        let {
          sat_sgMVR [Occ=Once] :: GHC.Types.Double
          [LclId] =
              [z_sgMVQ] \u [] Data.Complex.$fFloatingComplex_$smagnitude z_sgMVQ;
        } in  (,) [sat_sgMVR sat_sgMVS];

Data.Complex.polar
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> (a, a)
[GblId,
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgMVT z_sgMVU]
        let {
          sat_sgMVW [Occ=Once] :: a_agsyd
          [LclId] =
              [$dRealFloat_sgMVT z_sgMVU] \u []
                  Data.Complex.phase $dRealFloat_sgMVT z_sgMVU; } in
        let {
          sat_sgMVV [Occ=Once] :: a_agsyd
          [LclId] =
              [$dRealFloat_sgMVT z_sgMVU] \u []
                  Data.Complex.magnitude $dRealFloat_sgMVT z_sgMVU;
        } in  (,) [sat_sgMVV sat_sgMVW];

Data.Complex.$fFloatingComplex1 :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.D#! [0.0##];

Data.Complex.$fFloatingComplex_$s$cpi
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [GHC.Float.$fFloatingDouble_$cpi
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$w$cpi [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => (# a, a #)
[GblId,
 Arity=1,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)S(LSLLLLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A),1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [w_sgMVX]
        case GHC.Float.$p2RealFloat w_sgMVX of sat_sgMVY {
          __DEFAULT ->
              case GHC.Float.pi sat_sgMVY of dt_sgMVZ {
                __DEFAULT ->
                    case GHC.Float.$p1RealFloat w_sgMVX of sat_sgMW0 {
                      __DEFAULT ->
                          case GHC.Real.$p1RealFrac sat_sgMW0 of sat_sgMW1 {
                            __DEFAULT ->
                                case GHC.Real.$p1Real sat_sgMW1 of sat_sgMW2 {
                                  __DEFAULT ->
                                      case
                                          GHC.Num.fromInteger
                                              sat_sgMW2 Data.Complex.$fFloatingComplex17
                                      of
                                      dt1_sgMW3
                                      { __DEFAULT -> (#,#) [dt_sgMVZ dt1_sgMW3];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cpi [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => Data.Complex.Complex a
[GblId,
 Arity=1,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)S(LSLLLLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMW4]
        case Data.Complex.$w$cpi w_sgMW4 of {
          (#,#) ww1_sgMW6 [Occ=Once] ww2_sgMW7 [Occ=Once] ->
              Data.Complex.:+ [ww1_sgMW6 ww2_sgMW7];
        };

Data.Complex.$fFloatingComplex_$s$cexp
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMW8]
        case ds_sgMW8 of {
          Data.Complex.:+ x_sgMWa [Occ=Once!] y_sgMWb [Occ=Once!] ->
              case x_sgMWa of {
                GHC.Types.D# x1_sgMWd [Occ=Once] ->
                    case y_sgMWb of {
                      GHC.Types.D# x2_sgMWf ->
                          case expDouble# [x1_sgMWd] of expx_sgMWg {
                            __DEFAULT ->
                                case sinDouble# [x2_sgMWf] of sat_sgMWk {
                                  __DEFAULT ->
                                      case *## [expx_sgMWg sat_sgMWk] of sat_sgMWl {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMWm [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgMWl];
                                            } in 
                                              case cosDouble# [x2_sgMWf] of sat_sgMWh {
                                                __DEFAULT ->
                                                    case *## [expx_sgMWg sat_sgMWh] of sat_sgMWi {
                                                      __DEFAULT ->
                                                          let {
                                                            sat_sgMWj [Occ=Once] :: GHC.Types.Double
                                                            [LclId] =
                                                                CCCS GHC.Types.D#! [sat_sgMWi];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgMWj sat_sgMWm];
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$cexp [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMWn ww_sgMWo ww1_sgMWp]
        case
            GHC.Float.$p1RealFloat w_sgMWn
        of
        $dRealFrac_sgMWq [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgMWq
              of
              $dReal_sgMWr [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgMWr
                    of
                    $dNum_sgMWs [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dFloating_sgMWt [Dmd=<L,U(A,A,1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
                              :: GHC.Float.Floating a_sgxyP
                            [LclId] =
                                [w_sgMWn] \u [] GHC.Float.$p2RealFloat w_sgMWn; } in
                          let {
                            expx_sgMWu :: a_sgxyP
                            [LclId] =
                                [ww_sgMWo $dFloating_sgMWt] \u []
                                    GHC.Float.exp $dFloating_sgMWt ww_sgMWo; } in
                          let {
                            sat_sgMWv [Occ=Once] :: a_sgxyP
                            [LclId] =
                                [ww1_sgMWp $dFloating_sgMWt] \u []
                                    GHC.Float.cos $dFloating_sgMWt ww1_sgMWp;
                          } in 
                            case GHC.Num.* $dNum_sgMWs expx_sgMWu sat_sgMWv of dt_sgMWw {
                              __DEFAULT ->
                                  let {
                                    sat_sgMWx [Occ=Once] :: a_sgxyP
                                    [LclId] =
                                        [ww1_sgMWp $dFloating_sgMWt] \u []
                                            GHC.Float.sin $dFloating_sgMWt ww1_sgMWp;
                                  } in 
                                    case GHC.Num.* $dNum_sgMWs expx_sgMWu sat_sgMWx of dt1_sgMWy {
                                      __DEFAULT -> (#,#) [dt_sgMWw dt1_sgMWy];
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cexp [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMWz w1_sgMWA]
        case w1_sgMWA of {
          Data.Complex.:+ ww1_sgMWC [Occ=Once] ww2_sgMWD [Occ=Once] ->
              case Data.Complex.$w$cexp w_sgMWz ww1_sgMWC ww2_sgMWD of {
                (#,#) ww4_sgMWF [Occ=Once] ww5_sgMWG [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgMWF ww5_sgMWG];
              };
        };

Data.Complex.$fFloatingComplex_$s$clog [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMWH]
        case w_sgMWH of {
          Data.Complex.:+ ww1_sgMWJ [Occ=Once!] ww2_sgMWK [Occ=Once!] ->
              case ww1_sgMWJ of {
                GHC.Types.D# ww4_sgMWM ->
                    case ww2_sgMWK of {
                      GHC.Types.D# ww6_sgMWO ->
                          case Data.Complex.$w$smagnitude ww4_sgMWM ww6_sgMWO of ww7_sgMWP {
                            __DEFAULT ->
                                case logDouble# [ww7_sgMWP] of wild1_sgMWQ {
                                  __DEFAULT ->
                                      case Data.Complex.$w$sphase ww4_sgMWM ww6_sgMWO of ww8_sgMWR {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMWT [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [ww8_sgMWR]; } in
                                            let {
                                              sat_sgMWS [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [wild1_sgMWQ];
                                            } in  Data.Complex.:+ [sat_sgMWS sat_sgMWT];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$clog [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMWU ww_sgMWV ww1_sgMWW]
        let {
          sat_sgMWY [Occ=Once] :: a_sgxzj
          [LclId] =
              [w_sgMWU ww_sgMWV ww1_sgMWW] \u []
                  Data.Complex.$wmagnitude w_sgMWU ww_sgMWV ww1_sgMWW;
        } in 
          case GHC.Float.$p2RealFloat w_sgMWU of sat_sgMWX {
            __DEFAULT ->
                case GHC.Float.log sat_sgMWX sat_sgMWY of dt_sgMWZ {
                  __DEFAULT ->
                      case Data.Complex.$wphase w_sgMWU ww_sgMWV ww1_sgMWW of dt1_sgMX0 {
                        __DEFAULT -> (#,#) [dt_sgMWZ dt1_sgMX0];
                      };
                };
          };

Data.Complex.$fFloatingComplex_$clog [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMX1 w1_sgMX2]
        case w1_sgMX2 of {
          Data.Complex.:+ ww1_sgMX4 [Occ=Once] ww2_sgMX5 [Occ=Once] ->
              case Data.Complex.$w$clog w_sgMX1 ww1_sgMX4 ww2_sgMX5 of {
                (#,#) ww4_sgMX7 [Occ=Once] ww5_sgMX8 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgMX7 ww5_sgMX8];
              };
        };

Data.Complex.$fFloatingComplex_$s$csin
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMX9]
        case ds_sgMX9 of {
          Data.Complex.:+ x_sgMXb [Occ=Once!] y_sgMXc [Occ=Once!] ->
              case y_sgMXc of {
                GHC.Types.D# x1_sgMXe ->
                    case x_sgMXb of {
                      GHC.Types.D# x2_sgMXg ->
                          case sinhDouble# [x1_sgMXe] of sat_sgMXm {
                            __DEFAULT ->
                                case cosDouble# [x2_sgMXg] of sat_sgMXl {
                                  __DEFAULT ->
                                      case *## [sat_sgMXl sat_sgMXm] of sat_sgMXn {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMXo [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgMXn];
                                            } in 
                                              case coshDouble# [x1_sgMXe] of sat_sgMXi {
                                                __DEFAULT ->
                                                    case sinDouble# [x2_sgMXg] of sat_sgMXh {
                                                      __DEFAULT ->
                                                          case
                                                              *## [sat_sgMXh sat_sgMXi]
                                                          of
                                                          sat_sgMXj
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgMXk [Occ=Once]
                                                                    :: GHC.Types.Double
                                                                  [LclId] =
                                                                      CCCS GHC.Types.D#! [sat_sgMXj];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgMXk
                                                                                   sat_sgMXo];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$csin [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMXp ww_sgMXq ww1_sgMXr]
        let {
          $dFloating_sgMXs [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxzv
          [LclId] =
              [w_sgMXp] \u [] GHC.Float.$p2RealFloat w_sgMXp;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgMXp
          of
          $dRealFrac_sgMXt [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgMXt
                of
                $dReal_sgMXu [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgMXu
                      of
                      $dNum_sgMXv [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgMXx [Occ=Once] :: a_sgxzv
                              [LclId] =
                                  [ww1_sgMXr $dFloating_sgMXs] \u []
                                      GHC.Float.cosh $dFloating_sgMXs ww1_sgMXr; } in
                            let {
                              sat_sgMXw [Occ=Once] :: a_sgxzv
                              [LclId] =
                                  [ww_sgMXq $dFloating_sgMXs] \u []
                                      GHC.Float.sin $dFloating_sgMXs ww_sgMXq;
                            } in 
                              case GHC.Num.* $dNum_sgMXv sat_sgMXw sat_sgMXx of dt_sgMXy {
                                __DEFAULT ->
                                    let {
                                      sat_sgMXA [Occ=Once] :: a_sgxzv
                                      [LclId] =
                                          [ww1_sgMXr $dFloating_sgMXs] \u []
                                              GHC.Float.sinh $dFloating_sgMXs ww1_sgMXr; } in
                                    let {
                                      sat_sgMXz [Occ=Once] :: a_sgxzv
                                      [LclId] =
                                          [ww_sgMXq $dFloating_sgMXs] \u []
                                              GHC.Float.cos $dFloating_sgMXs ww_sgMXq;
                                    } in 
                                      case GHC.Num.* $dNum_sgMXv sat_sgMXz sat_sgMXA of dt1_sgMXB {
                                        __DEFAULT -> (#,#) [dt_sgMXy dt1_sgMXB];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$csin [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMXC w1_sgMXD]
        case w1_sgMXD of {
          Data.Complex.:+ ww1_sgMXF [Occ=Once] ww2_sgMXG [Occ=Once] ->
              case Data.Complex.$w$csin w_sgMXC ww1_sgMXF ww2_sgMXG of {
                (#,#) ww4_sgMXI [Occ=Once] ww5_sgMXJ [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgMXI ww5_sgMXJ];
              };
        };

Data.Complex.$fFloatingComplex_$s$ccos
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMXK]
        case ds_sgMXK of {
          Data.Complex.:+ x_sgMXM [Occ=Once!] y_sgMXN [Occ=Once!] ->
              case y_sgMXN of {
                GHC.Types.D# x1_sgMXP ->
                    case x_sgMXM of {
                      GHC.Types.D# x2_sgMXR ->
                          case sinhDouble# [x1_sgMXP] of sat_sgMXX {
                            __DEFAULT ->
                                case sinDouble# [x2_sgMXR] of sat_sgMXW {
                                  __DEFAULT ->
                                      case *## [sat_sgMXW sat_sgMXX] of sat_sgMXY {
                                        __DEFAULT ->
                                            case negateDouble# [sat_sgMXY] of sat_sgMXZ {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgMY0 [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [sat_sgMXZ];
                                                  } in 
                                                    case coshDouble# [x1_sgMXP] of sat_sgMXT {
                                                      __DEFAULT ->
                                                          case cosDouble# [x2_sgMXR] of sat_sgMXS {
                                                            __DEFAULT ->
                                                                case
                                                                    *## [sat_sgMXS sat_sgMXT]
                                                                of
                                                                sat_sgMXU
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_sgMXV [Occ=Once]
                                                                          :: GHC.Types.Double
                                                                        [LclId] =
                                                                            CCCS GHC.Types.D#! [sat_sgMXU];
                                                                      } in 
                                                                        Data.Complex.:+ [sat_sgMXV
                                                                                         sat_sgMY0];
                                                                };
                                                          };
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ccos [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMY1 ww_sgMY2 ww1_sgMY3]
        let {
          $dFloating_sgMY4 [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxzH
          [LclId] =
              [w_sgMY1] \u [] GHC.Float.$p2RealFloat w_sgMY1;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgMY1
          of
          $dRealFrac_sgMY5 [Dmd=<S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgMY5
                of
                $dReal_sgMY6 [Dmd=<S(S(LLC(C(S))C(S)LLL)LL),1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgMY6
                      of
                      $dNum_sgMY7 [Dmd=<S(LLC(C(S))C(S)LLL),U(A,A,C(C1(U)),1*C1(U),A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgMY9 [Occ=Once] :: a_sgxzH
                              [LclId] =
                                  [ww1_sgMY3 $dFloating_sgMY4] \u []
                                      GHC.Float.cosh $dFloating_sgMY4 ww1_sgMY3; } in
                            let {
                              sat_sgMY8 [Occ=Once] :: a_sgxzH
                              [LclId] =
                                  [ww_sgMY2 $dFloating_sgMY4] \u []
                                      GHC.Float.cos $dFloating_sgMY4 ww_sgMY2;
                            } in 
                              case GHC.Num.* $dNum_sgMY7 sat_sgMY8 sat_sgMY9 of dt_sgMYa {
                                __DEFAULT ->
                                    let {
                                      sat_sgMYd [Occ=Once] :: a_sgxzH
                                      [LclId] =
                                          [ww_sgMY2 ww1_sgMY3 $dFloating_sgMY4 $dNum_sgMY7] \u []
                                              let {
                                                sat_sgMYc [Occ=Once] :: a_sgxzH
                                                [LclId] =
                                                    [ww1_sgMY3 $dFloating_sgMY4] \u []
                                                        GHC.Float.sinh
                                                            $dFloating_sgMY4 ww1_sgMY3; } in
                                              let {
                                                sat_sgMYb [Occ=Once] :: a_sgxzH
                                                [LclId] =
                                                    [ww_sgMY2 $dFloating_sgMY4] \u []
                                                        GHC.Float.sin $dFloating_sgMY4 ww_sgMY2;
                                              } in  GHC.Num.* $dNum_sgMY7 sat_sgMYb sat_sgMYc;
                                    } in 
                                      case GHC.Num.negate $dNum_sgMY7 sat_sgMYd of dt1_sgMYe {
                                        __DEFAULT -> (#,#) [dt_sgMYa dt1_sgMYe];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$ccos [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),C(U),A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMYf w1_sgMYg]
        case w1_sgMYg of {
          Data.Complex.:+ ww1_sgMYi [Occ=Once] ww2_sgMYj [Occ=Once] ->
              case Data.Complex.$w$ccos w_sgMYf ww1_sgMYi ww2_sgMYj of {
                (#,#) ww4_sgMYl [Occ=Once] ww5_sgMYm [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgMYl ww5_sgMYm];
              };
        };

Data.Complex.$fFloatingComplex_$s$csinh
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMYn]
        case ds_sgMYn of {
          Data.Complex.:+ x_sgMYp [Occ=Once!] y_sgMYq [Occ=Once!] ->
              case x_sgMYp of {
                GHC.Types.D# x1_sgMYs ->
                    case y_sgMYq of {
                      GHC.Types.D# x2_sgMYu ->
                          case coshDouble# [x1_sgMYs] of sat_sgMYA {
                            __DEFAULT ->
                                case sinDouble# [x2_sgMYu] of sat_sgMYz {
                                  __DEFAULT ->
                                      case *## [sat_sgMYz sat_sgMYA] of sat_sgMYB {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMYC [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgMYB];
                                            } in 
                                              case sinhDouble# [x1_sgMYs] of sat_sgMYw {
                                                __DEFAULT ->
                                                    case cosDouble# [x2_sgMYu] of sat_sgMYv {
                                                      __DEFAULT ->
                                                          case
                                                              *## [sat_sgMYv sat_sgMYw]
                                                          of
                                                          sat_sgMYx
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgMYy [Occ=Once]
                                                                    :: GHC.Types.Double
                                                                  [LclId] =
                                                                      CCCS GHC.Types.D#! [sat_sgMYx];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgMYy
                                                                                   sat_sgMYC];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$csinh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMYD ww_sgMYE ww1_sgMYF]
        let {
          $dFloating_sgMYG [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxzT
          [LclId] =
              [w_sgMYD] \u [] GHC.Float.$p2RealFloat w_sgMYD;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgMYD
          of
          $dRealFrac_sgMYH [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgMYH
                of
                $dReal_sgMYI [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgMYI
                      of
                      $dNum_sgMYJ [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgMYL [Occ=Once] :: a_sgxzT
                              [LclId] =
                                  [ww_sgMYE $dFloating_sgMYG] \u []
                                      GHC.Float.sinh $dFloating_sgMYG ww_sgMYE; } in
                            let {
                              sat_sgMYK [Occ=Once] :: a_sgxzT
                              [LclId] =
                                  [ww1_sgMYF $dFloating_sgMYG] \u []
                                      GHC.Float.cos $dFloating_sgMYG ww1_sgMYF;
                            } in 
                              case GHC.Num.* $dNum_sgMYJ sat_sgMYK sat_sgMYL of dt_sgMYM {
                                __DEFAULT ->
                                    let {
                                      sat_sgMYO [Occ=Once] :: a_sgxzT
                                      [LclId] =
                                          [ww_sgMYE $dFloating_sgMYG] \u []
                                              GHC.Float.cosh $dFloating_sgMYG ww_sgMYE; } in
                                    let {
                                      sat_sgMYN [Occ=Once] :: a_sgxzT
                                      [LclId] =
                                          [ww1_sgMYF $dFloating_sgMYG] \u []
                                              GHC.Float.sin $dFloating_sgMYG ww1_sgMYF;
                                    } in 
                                      case GHC.Num.* $dNum_sgMYJ sat_sgMYN sat_sgMYO of dt1_sgMYP {
                                        __DEFAULT -> (#,#) [dt_sgMYM dt1_sgMYP];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$csinh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMYQ w1_sgMYR]
        case w1_sgMYR of {
          Data.Complex.:+ ww1_sgMYT [Occ=Once] ww2_sgMYU [Occ=Once] ->
              case Data.Complex.$w$csinh w_sgMYQ ww1_sgMYT ww2_sgMYU of {
                (#,#) ww4_sgMYW [Occ=Once] ww5_sgMYX [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgMYW ww5_sgMYX];
              };
        };

Data.Complex.$fFloatingComplex_$s$ccosh
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMYY]
        case ds_sgMYY of {
          Data.Complex.:+ x_sgMZ0 [Occ=Once!] y_sgMZ1 [Occ=Once!] ->
              case x_sgMZ0 of {
                GHC.Types.D# x1_sgMZ3 ->
                    case y_sgMZ1 of {
                      GHC.Types.D# x2_sgMZ5 ->
                          case sinhDouble# [x1_sgMZ3] of sat_sgMZb {
                            __DEFAULT ->
                                case sinDouble# [x2_sgMZ5] of sat_sgMZa {
                                  __DEFAULT ->
                                      case *## [sat_sgMZa sat_sgMZb] of sat_sgMZc {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMZd [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgMZc];
                                            } in 
                                              case coshDouble# [x1_sgMZ3] of sat_sgMZ7 {
                                                __DEFAULT ->
                                                    case cosDouble# [x2_sgMZ5] of sat_sgMZ6 {
                                                      __DEFAULT ->
                                                          case
                                                              *## [sat_sgMZ6 sat_sgMZ7]
                                                          of
                                                          sat_sgMZ8
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgMZ9 [Occ=Once]
                                                                    :: GHC.Types.Double
                                                                  [LclId] =
                                                                      CCCS GHC.Types.D#! [sat_sgMZ8];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgMZ9
                                                                                   sat_sgMZd];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ccosh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMZe ww_sgMZf ww1_sgMZg]
        let {
          $dFloating_sgMZh [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxA5
          [LclId] =
              [w_sgMZe] \u [] GHC.Float.$p2RealFloat w_sgMZe;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgMZe
          of
          $dRealFrac_sgMZi [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgMZi
                of
                $dReal_sgMZj [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgMZj
                      of
                      $dNum_sgMZk [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgMZm [Occ=Once] :: a_sgxA5
                              [LclId] =
                                  [ww_sgMZf $dFloating_sgMZh] \u []
                                      GHC.Float.cosh $dFloating_sgMZh ww_sgMZf; } in
                            let {
                              sat_sgMZl [Occ=Once] :: a_sgxA5
                              [LclId] =
                                  [ww1_sgMZg $dFloating_sgMZh] \u []
                                      GHC.Float.cos $dFloating_sgMZh ww1_sgMZg;
                            } in 
                              case GHC.Num.* $dNum_sgMZk sat_sgMZl sat_sgMZm of dt_sgMZn {
                                __DEFAULT ->
                                    let {
                                      sat_sgMZp [Occ=Once] :: a_sgxA5
                                      [LclId] =
                                          [ww_sgMZf $dFloating_sgMZh] \u []
                                              GHC.Float.sinh $dFloating_sgMZh ww_sgMZf; } in
                                    let {
                                      sat_sgMZo [Occ=Once] :: a_sgxA5
                                      [LclId] =
                                          [ww1_sgMZg $dFloating_sgMZh] \u []
                                              GHC.Float.sin $dFloating_sgMZh ww1_sgMZg;
                                    } in 
                                      case GHC.Num.* $dNum_sgMZk sat_sgMZo sat_sgMZp of dt1_sgMZq {
                                        __DEFAULT -> (#,#) [dt_sgMZn dt1_sgMZq];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$ccosh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMZr w1_sgMZs]
        case w1_sgMZs of {
          Data.Complex.:+ ww1_sgMZu [Occ=Once] ww2_sgMZv [Occ=Once] ->
              case Data.Complex.$w$ccosh w_sgMZr ww1_sgMZu ww2_sgMZv of {
                (#,#) ww4_sgMZx [Occ=Once] ww5_sgMZy [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgMZx ww5_sgMZy];
              };
        };

Data.Complex.$w$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgMZz ww1_sgMZA ww2_sgMZB ww3_sgMZC]
        case GHC.Float.$w$cexponent ww2_sgMZB of ww4_sgMZD {
          __DEFAULT ->
              case GHC.Float.$w$cexponent ww3_sgMZC of ww5_sgMZE {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgMZF [Occ=Once*!T[1], Dmd=<C(S),1*C1(U(U,U))>]
                        :: GHC.Prim.Int# -> (# GHC.Types.Double, GHC.Types.Double #)
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgMZz ww1_sgMZA ww2_sgMZB ww3_sgMZC] \r [ww6_sgMZG]
                              case GHC.Float.$w$cscaleFloat ww6_sgMZG ww2_sgMZB of ww7_sgMZH {
                                __DEFAULT ->
                                    case GHC.Float.$w$cscaleFloat ww6_sgMZG ww3_sgMZC of ww8_sgMZI {
                                      __DEFAULT ->
                                          case *## [ww3_sgMZC ww8_sgMZI] of sat_sgMZL {
                                            __DEFAULT ->
                                                case *## [ww2_sgMZB ww7_sgMZH] of sat_sgMZK {
                                                  __DEFAULT ->
                                                      case
                                                          +## [sat_sgMZK sat_sgMZL]
                                                      of
                                                      y_sgMZJ [Dmd=<S,U>]
                                                      { __DEFAULT ->
                                                            case
                                                                *## [ww1_sgMZA ww8_sgMZI]
                                                            of
                                                            sat_sgMZN
                                                            { __DEFAULT ->
                                                                  case
                                                                      *## [ww_sgMZz ww7_sgMZH]
                                                                  of
                                                                  sat_sgMZM
                                                                  { __DEFAULT ->
                                                                        case
                                                                            +## [sat_sgMZM
                                                                                 sat_sgMZN]
                                                                        of
                                                                        sat_sgMZO
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  /## [sat_sgMZO
                                                                                       y_sgMZJ]
                                                                              of
                                                                              wild2_sgMZP
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        *## [ww_sgMZz
                                                                                             ww8_sgMZI]
                                                                                    of
                                                                                    sat_sgMZR
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              *## [ww1_sgMZA
                                                                                                   ww7_sgMZH]
                                                                                          of
                                                                                          sat_sgMZQ
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    -## [sat_sgMZQ
                                                                                                         sat_sgMZR]
                                                                                                of
                                                                                                sat_sgMZS
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          /## [sat_sgMZS
                                                                                                               y_sgMZJ]
                                                                                                      of
                                                                                                      wild1_sgMZT
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgMZV [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [wild1_sgMZT]; } in
                                                                                                            let {
                                                                                                              sat_sgMZU [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [wild2_sgMZP];
                                                                                                            } in 
                                                                                                              (#,#) [sat_sgMZU
                                                                                                                     sat_sgMZV];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww4_sgMZD ww5_sgMZE] of {
                        __DEFAULT ->
                            case negateInt# [ww4_sgMZD] of sat_sgMZX {
                              __DEFAULT -> $j_sgMZF sat_sgMZX;
                            };
                        1# ->
                            case negateInt# [ww5_sgMZE] of sat_sgMZY {
                              __DEFAULT -> $j_sgMZF sat_sgMZY;
                            };
                      };
              };
        };

Data.Complex.$fFloatingComplex_$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMZZ w1_sgN00]
        case w_sgMZZ of {
          Data.Complex.:+ ww1_sgN02 [Occ=Once!] ww2_sgN03 [Occ=Once!] ->
              case ww1_sgN02 of {
                GHC.Types.D# ww4_sgN05 [Occ=Once] ->
                    case ww2_sgN03 of {
                      GHC.Types.D# ww6_sgN07 [Occ=Once] ->
                          case w1_sgN00 of {
                            Data.Complex.:+ ww8_sgN09 [Occ=Once!] ww9_sgN0a [Occ=Once!] ->
                                case ww8_sgN09 of {
                                  GHC.Types.D# ww11_sgN0c [Occ=Once] ->
                                      case ww9_sgN0a of {
                                        GHC.Types.D# ww13_sgN0e [Occ=Once] ->
                                            case
                                                Data.Complex.$w$s$c/
                                                    ww4_sgN05 ww6_sgN07 ww11_sgN0c ww13_sgN0e
                                            of
                                            { (#,#) ww15_sgN0g [Occ=Once] ww16_sgN0h [Occ=Once] ->
                                                  Data.Complex.:+ [ww15_sgN0g ww16_sgN0h];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN0i ww_sgN0j ww1_sgN0k ww2_sgN0l ww3_sgN0m]
        case
            GHC.Float.$p1RealFloat w_sgN0i
        of
        $dRealFrac_sgN0n [Dmd=<S(LS(LC(C(S))LL)LLLLL),U(1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p2RealFrac $dRealFrac_sgN0n
              of
              $dFractional_sgN0o [Dmd=<S(LC(C(S))LL),U(A,C(C1(U)),A,A)>]
              { __DEFAULT ->
                    let {
                      $dReal_sgN0p [Occ=OnceL,
                                    Dmd=<L,1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
                        :: GHC.Real.Real a_sgxAO
                      [LclId] =
                          [$dRealFrac_sgN0n] \s []
                              GHC.Real.$p1RealFrac $dRealFrac_sgN0n; } in
                    let {
                      $dNum_sgN0q [Dmd=<L,U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
                        :: GHC.Num.Num a_sgxAO
                      [LclId] =
                          [$dReal_sgN0p] \u [] GHC.Real.$p1Real $dReal_sgN0p; } in
                    let {
                      k_sgN0r :: GHC.Types.Int
                      [LclId] =
                          [w_sgN0i ww2_sgN0l ww3_sgN0m] \u []
                              case GHC.Float.exponent w_sgN0i ww2_sgN0l of {
                                GHC.Types.I# x1_sgN0t ->
                                    case GHC.Float.exponent w_sgN0i ww3_sgN0m of {
                                      GHC.Types.I# y1_sgN0v ->
                                          case <=# [x1_sgN0t y1_sgN0v] of {
                                            __DEFAULT ->
                                                case negateInt# [x1_sgN0t] of sat_sgN0x {
                                                  __DEFAULT -> GHC.Types.I# [sat_sgN0x];
                                                };
                                            1# ->
                                                case negateInt# [y1_sgN0v] of sat_sgN0y {
                                                  __DEFAULT -> GHC.Types.I# [sat_sgN0y];
                                                };
                                          };
                                    };
                              }; } in
                    let {
                      y''_sgN0z :: a_sgxAO
                      [LclId] =
                          [w_sgN0i ww3_sgN0m k_sgN0r] \u []
                              GHC.Float.scaleFloat w_sgN0i k_sgN0r ww3_sgN0m; } in
                    let {
                      x''_sgN0A :: a_sgxAO
                      [LclId] =
                          [w_sgN0i ww2_sgN0l k_sgN0r] \u []
                              GHC.Float.scaleFloat w_sgN0i k_sgN0r ww2_sgN0l; } in
                    let {
                      d_sgN0B :: a_sgxAO
                      [LclId] =
                          [ww2_sgN0l ww3_sgN0m $dNum_sgN0q y''_sgN0z x''_sgN0A] \u []
                              let {
                                sat_sgN0D [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww3_sgN0m $dNum_sgN0q y''_sgN0z] \u []
                                        GHC.Num.* $dNum_sgN0q ww3_sgN0m y''_sgN0z; } in
                              let {
                                sat_sgN0C [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww2_sgN0l $dNum_sgN0q x''_sgN0A] \u []
                                        GHC.Num.* $dNum_sgN0q ww2_sgN0l x''_sgN0A;
                              } in  GHC.Num.+ $dNum_sgN0q sat_sgN0C sat_sgN0D; } in
                    let {
                      sat_sgN0G [Occ=Once] :: a_sgxAO
                      [LclId] =
                          [ww_sgN0j ww1_sgN0k $dNum_sgN0q y''_sgN0z x''_sgN0A] \u []
                              let {
                                sat_sgN0F [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww1_sgN0k $dNum_sgN0q y''_sgN0z] \u []
                                        GHC.Num.* $dNum_sgN0q ww1_sgN0k y''_sgN0z; } in
                              let {
                                sat_sgN0E [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww_sgN0j $dNum_sgN0q x''_sgN0A] \u []
                                        GHC.Num.* $dNum_sgN0q ww_sgN0j x''_sgN0A;
                              } in  GHC.Num.+ $dNum_sgN0q sat_sgN0E sat_sgN0F;
                    } in 
                      case GHC.Real./ $dFractional_sgN0o sat_sgN0G d_sgN0B of dt_sgN0H {
                        __DEFAULT ->
                            let {
                              sat_sgN0K [Occ=Once] :: a_sgxAO
                              [LclId] =
                                  [ww_sgN0j ww1_sgN0k $dNum_sgN0q y''_sgN0z x''_sgN0A] \u []
                                      let {
                                        sat_sgN0J [Occ=Once] :: a_sgxAO
                                        [LclId] =
                                            [ww_sgN0j $dNum_sgN0q y''_sgN0z] \u []
                                                GHC.Num.* $dNum_sgN0q ww_sgN0j y''_sgN0z; } in
                                      let {
                                        sat_sgN0I [Occ=Once] :: a_sgxAO
                                        [LclId] =
                                            [ww1_sgN0k $dNum_sgN0q x''_sgN0A] \u []
                                                GHC.Num.* $dNum_sgN0q ww1_sgN0k x''_sgN0A;
                                      } in  GHC.Num.- $dNum_sgN0q sat_sgN0I sat_sgN0J;
                            } in 
                              case GHC.Real./ $dFractional_sgN0o sat_sgN0K d_sgN0B of dt1_sgN0L {
                                __DEFAULT -> (#,#) [dt_sgN0H dt1_sgN0L];
                              };
                      };
              };
        };

Data.Complex.$fFloatingComplex_$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN0M w1_sgN0N w2_sgN0O]
        case w1_sgN0N of {
          Data.Complex.:+ ww1_sgN0Q [Occ=Once] ww2_sgN0R [Occ=Once] ->
              case w2_sgN0O of {
                Data.Complex.:+ ww4_sgN0T [Occ=Once] ww5_sgN0U [Occ=Once] ->
                    case
                        Data.Complex.$w$c/ w_sgN0M ww1_sgN0Q ww2_sgN0R ww4_sgN0T ww5_sgN0U
                    of
                    { (#,#) ww7_sgN0W [Occ=Once] ww8_sgN0X [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgN0W ww8_sgN0X];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromRational
  :: GHC.Real.Rational -> Data.Complex.Complex GHC.Types.Double
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [a_sgN0Y]
        case a_sgN0Y of {
          GHC.Real.:% n_sgN10 [Occ=Once] d_sgN11 [Occ=Once] ->
              case GHC.Float.rationalToDouble n_sgN10 d_sgN11 of dt_sgN12 {
                GHC.Types.D# _ [Occ=Dead] ->
                    Data.Complex.:+ [dt_sgN12 Data.Complex.$fFloatingComplex1];
              };
        };

Data.Complex.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.Rational -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN14 w1_sgN15]
        case
            GHC.Float.$p1RealFloat w_sgN14
        of
        $dRealFrac_sgN16 [Dmd=<S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A)>]
        { __DEFAULT ->
              case GHC.Real.$p2RealFrac $dRealFrac_sgN16 of sat_sgN17 {
                __DEFAULT ->
                    case GHC.Real.fromRational sat_sgN17 w1_sgN15 of dt_sgN18 {
                      __DEFAULT ->
                          case GHC.Real.$p1RealFrac $dRealFrac_sgN16 of sat_sgN19 {
                            __DEFAULT ->
                                case GHC.Real.$p1Real sat_sgN19 of sat_sgN1a {
                                  __DEFAULT ->
                                      case
                                          GHC.Num.fromInteger
                                              sat_sgN1a Data.Complex.$fFloatingComplex17
                                      of
                                      dt1_sgN1b
                                      { __DEFAULT -> (#,#) [dt_sgN18 dt1_sgN1b];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFractionalComplex_$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.Rational -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgN1c w1_sgN1d]
        case Data.Complex.$w$cfromRational w_sgN1c w1_sgN1d of {
          (#,#) ww1_sgN1f [Occ=Once] ww2_sgN1g [Occ=Once] ->
              Data.Complex.:+ [ww1_sgN1f ww2_sgN1g];
        };

Data.Complex.$fFloatingComplex_$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN1h w1_sgN1i]
        case w_sgN1h of {
          Data.Complex.:+ ww1_sgN1k [Occ=Once!] ww2_sgN1l [Occ=Once!] ->
              case ww1_sgN1k of {
                GHC.Types.D# ww4_sgN1n [Occ=Once] ->
                    case ww2_sgN1l of {
                      GHC.Types.D# ww6_sgN1p [Occ=Once] ->
                          case w1_sgN1i of {
                            Data.Complex.:+ ww8_sgN1r [Occ=Once!] ww9_sgN1s [Occ=Once!] ->
                                case ww8_sgN1r of {
                                  GHC.Types.D# ww11_sgN1u [Occ=Once] ->
                                      case ww9_sgN1s of {
                                        GHC.Types.D# ww13_sgN1w [Occ=Once] ->
                                            case +## [ww6_sgN1p ww13_sgN1w] of sat_sgN1z {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgN1A [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [sat_sgN1z];
                                                  } in 
                                                    case +## [ww4_sgN1n ww11_sgN1u] of sat_sgN1x {
                                                      __DEFAULT ->
                                                          let {
                                                            sat_sgN1y [Occ=Once] :: GHC.Types.Double
                                                            [LclId] =
                                                                CCCS GHC.Types.D#! [sat_sgN1x];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgN1y sat_sgN1A];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))LLLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN1B ww_sgN1C ww1_sgN1D ww2_sgN1E ww3_sgN1F]
        case
            GHC.Float.$p1RealFloat w_sgN1B
        of
        $dRealFrac_sgN1G [Dmd=<S(S(S(C(C(S))LLLLLL)LL)LLLLLL),1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN1G
              of
              $dReal_sgN1H [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgN1H
                    of
                    $dNum_sgN1I [Dmd=<S(C(C(S))LLLLLL),U(C(C1(U)),A,A,A,A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.+ $dNum_sgN1I ww_sgN1C ww2_sgN1E of dt_sgN1J {
                            __DEFAULT ->
                                case GHC.Num.+ $dNum_sgN1I ww1_sgN1D ww3_sgN1F of dt1_sgN1K {
                                  __DEFAULT -> (#,#) [dt_sgN1J dt1_sgN1K];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))LLLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN1L w1_sgN1M w2_sgN1N]
        case w1_sgN1M of {
          Data.Complex.:+ ww1_sgN1P [Occ=Once] ww2_sgN1Q [Occ=Once] ->
              case w2_sgN1N of {
                Data.Complex.:+ ww4_sgN1S [Occ=Once] ww5_sgN1T [Occ=Once] ->
                    case
                        Data.Complex.$w$c+ w_sgN1L ww1_sgN1P ww2_sgN1Q ww4_sgN1S ww5_sgN1T
                    of
                    { (#,#) ww7_sgN1V [Occ=Once] ww8_sgN1W [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgN1V ww8_sgN1W];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c- [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN1X w1_sgN1Y]
        case w_sgN1X of {
          Data.Complex.:+ ww1_sgN20 [Occ=Once!] ww2_sgN21 [Occ=Once!] ->
              case ww1_sgN20 of {
                GHC.Types.D# ww4_sgN23 [Occ=Once] ->
                    case ww2_sgN21 of {
                      GHC.Types.D# ww6_sgN25 [Occ=Once] ->
                          case w1_sgN1Y of {
                            Data.Complex.:+ ww8_sgN27 [Occ=Once!] ww9_sgN28 [Occ=Once!] ->
                                case ww8_sgN27 of {
                                  GHC.Types.D# ww11_sgN2a [Occ=Once] ->
                                      case ww9_sgN28 of {
                                        GHC.Types.D# ww13_sgN2c [Occ=Once] ->
                                            case -## [ww6_sgN25 ww13_sgN2c] of sat_sgN2f {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgN2g [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [sat_sgN2f];
                                                  } in 
                                                    case -## [ww4_sgN23 ww11_sgN2a] of sat_sgN2d {
                                                      __DEFAULT ->
                                                          let {
                                                            sat_sgN2e [Occ=Once] :: GHC.Types.Double
                                                            [LclId] =
                                                                CCCS GHC.Types.D#! [sat_sgN2d];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgN2e sat_sgN2g];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN2h ww_sgN2i ww1_sgN2j ww2_sgN2k ww3_sgN2l]
        case
            GHC.Float.$p1RealFloat w_sgN2h
        of
        $dRealFrac_sgN2m [Dmd=<S(S(S(LC(C(S))LLLLL)LL)LLLLLL),1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN2m
              of
              $dReal_sgN2n [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgN2n
                    of
                    $dNum_sgN2o [Dmd=<S(LC(C(S))LLLLL),U(A,C(C1(U)),A,A,A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.- $dNum_sgN2o ww_sgN2i ww2_sgN2k of dt_sgN2p {
                            __DEFAULT ->
                                case GHC.Num.- $dNum_sgN2o ww1_sgN2j ww3_sgN2l of dt1_sgN2q {
                                  __DEFAULT -> (#,#) [dt_sgN2p dt1_sgN2q];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN2r w1_sgN2s w2_sgN2t]
        case w1_sgN2s of {
          Data.Complex.:+ ww1_sgN2v [Occ=Once] ww2_sgN2w [Occ=Once] ->
              case w2_sgN2t of {
                Data.Complex.:+ ww4_sgN2y [Occ=Once] ww5_sgN2z [Occ=Once] ->
                    case
                        Data.Complex.$w$c- w_sgN2r ww1_sgN2v ww2_sgN2w ww4_sgN2y ww5_sgN2z
                    of
                    { (#,#) ww7_sgN2B [Occ=Once] ww8_sgN2C [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgN2B ww8_sgN2C];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c* [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN2D w1_sgN2E]
        case w_sgN2D of {
          Data.Complex.:+ ww1_sgN2G [Occ=Once!] ww2_sgN2H [Occ=Once!] ->
              case ww1_sgN2G of {
                GHC.Types.D# ww4_sgN2J ->
                    case ww2_sgN2H of {
                      GHC.Types.D# ww6_sgN2L ->
                          case w1_sgN2E of {
                            Data.Complex.:+ ww8_sgN2N [Occ=Once!] ww9_sgN2O [Occ=Once!] ->
                                case ww8_sgN2N of {
                                  GHC.Types.D# ww11_sgN2Q ->
                                      case ww9_sgN2O of {
                                        GHC.Types.D# ww13_sgN2S ->
                                            case *## [ww6_sgN2L ww11_sgN2Q] of sat_sgN2Y {
                                              __DEFAULT ->
                                                  case *## [ww4_sgN2J ww13_sgN2S] of sat_sgN2X {
                                                    __DEFAULT ->
                                                        case
                                                            +## [sat_sgN2X sat_sgN2Y]
                                                        of
                                                        sat_sgN2Z
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_sgN30 [Occ=Once]
                                                                  :: GHC.Types.Double
                                                                [LclId] =
                                                                    CCCS GHC.Types.D#! [sat_sgN2Z];
                                                              } in 
                                                                case
                                                                    *## [ww6_sgN2L ww13_sgN2S]
                                                                of
                                                                sat_sgN2U
                                                                { __DEFAULT ->
                                                                      case
                                                                          *## [ww4_sgN2J ww11_sgN2Q]
                                                                      of
                                                                      sat_sgN2T
                                                                      { __DEFAULT ->
                                                                            case
                                                                                -## [sat_sgN2T
                                                                                     sat_sgN2U]
                                                                            of
                                                                            sat_sgN2V
                                                                            { __DEFAULT ->
                                                                                  let {
                                                                                    sat_sgN2W [Occ=Once]
                                                                                      :: GHC.Types.Double
                                                                                    [LclId] =
                                                                                        CCCS GHC.Types.D#! [sat_sgN2V];
                                                                                  } in 
                                                                                    Data.Complex.:+ [sat_sgN2W
                                                                                                     sat_sgN30];
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN31 ww_sgN32 ww1_sgN33 ww2_sgN34 ww3_sgN35]
        case
            GHC.Float.$p1RealFloat w_sgN31
        of
        $dRealFrac_sgN36 [Dmd=<S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL),1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN36
              of
              $dReal_sgN37 [Dmd=<S(S(C(C(S))C(C(S))LLLLL)LL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgN37
                    of
                    $dNum_sgN38 [Dmd=<S(C(C(S))C(C(S))LLLLL),U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            sat_sgN3a [Occ=Once] :: a_sgxDl
                            [LclId] =
                                [ww1_sgN33 ww3_sgN35 $dNum_sgN38] \u []
                                    GHC.Num.* $dNum_sgN38 ww1_sgN33 ww3_sgN35; } in
                          let {
                            sat_sgN39 [Occ=Once] :: a_sgxDl
                            [LclId] =
                                [ww_sgN32 ww2_sgN34 $dNum_sgN38] \u []
                                    GHC.Num.* $dNum_sgN38 ww_sgN32 ww2_sgN34;
                          } in 
                            case GHC.Num.- $dNum_sgN38 sat_sgN39 sat_sgN3a of dt_sgN3b {
                              __DEFAULT ->
                                  let {
                                    sat_sgN3d [Occ=Once] :: a_sgxDl
                                    [LclId] =
                                        [ww1_sgN33 ww2_sgN34 $dNum_sgN38] \u []
                                            GHC.Num.* $dNum_sgN38 ww1_sgN33 ww2_sgN34; } in
                                  let {
                                    sat_sgN3c [Occ=Once] :: a_sgxDl
                                    [LclId] =
                                        [ww_sgN32 ww3_sgN35 $dNum_sgN38] \u []
                                            GHC.Num.* $dNum_sgN38 ww_sgN32 ww3_sgN35;
                                  } in 
                                    case GHC.Num.+ $dNum_sgN38 sat_sgN3c sat_sgN3d of dt1_sgN3e {
                                      __DEFAULT -> (#,#) [dt_sgN3b dt1_sgN3e];
                                    };
                            };
                    };
              };
        };

Data.Complex.$fNumComplex_$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN3f w1_sgN3g w2_sgN3h]
        case w1_sgN3g of {
          Data.Complex.:+ ww1_sgN3j [Occ=Once] ww2_sgN3k [Occ=Once] ->
              case w2_sgN3h of {
                Data.Complex.:+ ww4_sgN3m [Occ=Once] ww5_sgN3n [Occ=Once] ->
                    case
                        Data.Complex.$w$c* w_sgN3f ww1_sgN3j ww2_sgN3k ww4_sgN3m ww5_sgN3n
                    of
                    { (#,#) ww7_sgN3p [Occ=Once] ww8_sgN3q [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgN3p ww8_sgN3q];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cnegate
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgN3r]
        case ds_sgN3r of {
          Data.Complex.:+ x_sgN3t [Occ=Once!] y_sgN3u [Occ=Once!] ->
              case x_sgN3t of {
                GHC.Types.D# x1_sgN3w [Occ=Once] ->
                    case y_sgN3u of {
                      GHC.Types.D# x2_sgN3y [Occ=Once] ->
                          case negateDouble# [x2_sgN3y] of sat_sgN3B {
                            __DEFAULT ->
                                let {
                                  sat_sgN3C [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [sat_sgN3B];
                                } in 
                                  case negateDouble# [x1_sgN3w] of sat_sgN3z {
                                    __DEFAULT ->
                                        let {
                                          sat_sgN3A [Occ=Once] :: GHC.Types.Double
                                          [LclId] =
                                              CCCS GHC.Types.D#! [sat_sgN3z];
                                        } in  Data.Complex.:+ [sat_sgN3A sat_sgN3C];
                                  };
                          };
                    };
              };
        };

Data.Complex.$w$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLLC(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN3D ww_sgN3E ww1_sgN3F]
        case
            GHC.Float.$p1RealFloat w_sgN3D
        of
        $dRealFrac_sgN3G [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN3G
              of
              $dReal_sgN3H [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgN3H
                    of
                    $dNum_sgN3I [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.negate $dNum_sgN3I ww_sgN3E of dt_sgN3J {
                            __DEFAULT ->
                                case GHC.Num.negate $dNum_sgN3I ww1_sgN3F of dt1_sgN3K {
                                  __DEFAULT -> (#,#) [dt_sgN3J dt1_sgN3K];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLLC(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN3L w1_sgN3M]
        case w1_sgN3M of {
          Data.Complex.:+ ww1_sgN3O [Occ=Once] ww2_sgN3P [Occ=Once] ->
              case Data.Complex.$w$cnegate w_sgN3L ww1_sgN3O ww2_sgN3P of {
                (#,#) ww4_sgN3R [Occ=Once] ww5_sgN3S [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgN3R ww5_sgN3S];
              };
        };

Data.Complex.$fFloatingComplex_$s$cabs
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [z_sgN3T]
        case z_sgN3T of {
          Data.Complex.:+ ww1_sgN3V [Occ=Once!] ww2_sgN3W [Occ=Once!] ->
              case ww1_sgN3V of {
                GHC.Types.D# ww4_sgN3Y [Occ=Once] ->
                    case ww2_sgN3W of {
                      GHC.Types.D# ww6_sgN40 [Occ=Once] ->
                          case Data.Complex.$w$smagnitude ww4_sgN3Y ww6_sgN40 of ww7_sgN41 {
                            __DEFAULT ->
                                let {
                                  sat_sgN42 [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [ww7_sgN41];
                                } in  Data.Complex.:+ [sat_sgN42 Data.Complex.$fFloatingComplex1];
                          };
                    };
              };
        };

Data.Complex.$w$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,1*C1(U)),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN43 ww_sgN44 ww1_sgN45]
        case
            Data.Complex.$wmagnitude w_sgN43 ww_sgN44 ww1_sgN45
        of
        dt_sgN46
        { __DEFAULT ->
              case GHC.Float.$p1RealFloat w_sgN43 of sat_sgN47 {
                __DEFAULT ->
                    case GHC.Real.$p1RealFrac sat_sgN47 of sat_sgN48 {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_sgN48 of sat_sgN49 {
                            __DEFAULT ->
                                case
                                    GHC.Num.fromInteger sat_sgN49 Data.Complex.$fFloatingComplex17
                                of
                                dt1_sgN4a
                                { __DEFAULT -> (#,#) [dt_sgN46 dt1_sgN4a];
                                };
                          };
                    };
              };
        };

Data.Complex.$fNumComplex_$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN4b w1_sgN4c]
        case w1_sgN4c of {
          Data.Complex.:+ ww1_sgN4e [Occ=Once] ww2_sgN4f [Occ=Once] ->
              case Data.Complex.$w$cabs w_sgN4b ww1_sgN4e ww2_sgN4f of {
                (#,#) ww4_sgN4h [Occ=Once] ww5_sgN4i [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgN4h ww5_sgN4i];
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromInteger
  :: GHC.Integer.Type.Integer
     -> Data.Complex.Complex GHC.Types.Double
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [n_sgN4j]
        case GHC.Integer.Type.doubleFromInteger n_sgN4j of wild_sgN4k {
          __DEFAULT ->
              let {
                sat_sgN4l [Occ=Once] :: GHC.Types.Double
                [LclId] =
                    CCCS GHC.Types.D#! [wild_sgN4k];
              } in  Data.Complex.:+ [sat_sgN4l Data.Complex.$fFloatingComplex1];
        };

Data.Complex.$w$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Integer.Type.Integer -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN4m w1_sgN4n]
        case
            GHC.Float.$p1RealFloat w_sgN4m
        of
        $dRealFrac_sgN4o [Dmd=<S(S(S(LLLLLLC(S))LL)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN4o
              of
              $dReal_sgN4p [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgN4p
                    of
                    $dNum_sgN4q [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
                    { __DEFAULT ->
                          case GHC.Num.fromInteger $dNum_sgN4q w1_sgN4n of dt_sgN4r {
                            __DEFAULT ->
                                case
                                    GHC.Num.fromInteger $dNum_sgN4q Data.Complex.$fFloatingComplex17
                                of
                                dt1_sgN4s
                                { __DEFAULT -> (#,#) [dt_sgN4r dt1_sgN4s];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Integer.Type.Integer -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgN4t w1_sgN4u]
        case Data.Complex.$w$cfromInteger w_sgN4t w1_sgN4u of {
          (#,#) ww1_sgN4w [Occ=Once] ww2_sgN4x [Occ=Once] ->
              Data.Complex.:+ [ww1_sgN4w ww2_sgN4x];
        };

Data.Complex.$fFloatingComplex4
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex1
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$fFloatingComplex_$s$csignum [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN4y]
        case w_sgN4y of {
          Data.Complex.:+ ww1_sgN4A [Occ=Once!] ww2_sgN4B [Occ=Once!] ->
              case ww1_sgN4A of {
                GHC.Types.D# ww4_sgN4D ->
                    case ww2_sgN4B of {
                      GHC.Types.D# ww6_sgN4F ->
                          case ==## [ww4_sgN4D 0.0##] of {
                            __DEFAULT ->
                                case Data.Complex.$w$smagnitude ww4_sgN4D ww6_sgN4F of ww7_sgN4H {
                                  __DEFAULT ->
                                      case /## [ww4_sgN4D ww7_sgN4H] of wild2_sgN4I {
                                        __DEFAULT ->
                                            case /## [ww6_sgN4F ww7_sgN4H] of wild1_sgN4J {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgN4L [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [wild1_sgN4J]; } in
                                                  let {
                                                    sat_sgN4K [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [wild2_sgN4I];
                                                  } in  Data.Complex.:+ [sat_sgN4K sat_sgN4L];
                                            };
                                      };
                                };
                            1# ->
                                case ==## [ww6_sgN4F 0.0##] of {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$smagnitude ww4_sgN4D ww6_sgN4F
                                      of
                                      ww7_sgN4N
                                      { __DEFAULT ->
                                            case /## [ww4_sgN4D ww7_sgN4N] of wild2_sgN4O {
                                              __DEFAULT ->
                                                  case /## [ww6_sgN4F ww7_sgN4N] of wild1_sgN4P {
                                                    __DEFAULT ->
                                                        let {
                                                          sat_sgN4R [Occ=Once] :: GHC.Types.Double
                                                          [LclId] =
                                                              CCCS GHC.Types.D#! [wild1_sgN4P]; } in
                                                        let {
                                                          sat_sgN4Q [Occ=Once] :: GHC.Types.Double
                                                          [LclId] =
                                                              CCCS GHC.Types.D#! [wild2_sgN4O];
                                                        } in  Data.Complex.:+ [sat_sgN4Q sat_sgN4R];
                                                  };
                                            };
                                      };
                                  1# -> Data.Complex.$fFloatingComplex4;
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex12
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex9
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$fFloatingComplex_$s$csignum1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN4S]
        case w_sgN4S of {
          Data.Complex.:+ ww1_sgN4U [Occ=Once!] ww2_sgN4V [Occ=Once!] ->
              case ww1_sgN4U of {
                GHC.Types.F# ww4_sgN4X ->
                    case ww2_sgN4V of {
                      GHC.Types.F# ww6_sgN4Z ->
                          case eqFloat# [ww4_sgN4X 0.0#] of {
                            __DEFAULT ->
                                case Data.Complex.$w$smagnitude1 ww4_sgN4X ww6_sgN4Z of ww7_sgN51 {
                                  __DEFAULT ->
                                      case divideFloat# [ww4_sgN4X ww7_sgN51] of wild2_sgN52 {
                                        __DEFAULT ->
                                            case divideFloat# [ww6_sgN4Z ww7_sgN51] of wild1_sgN53 {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgN55 [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [wild1_sgN53]; } in
                                                  let {
                                                    sat_sgN54 [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [wild2_sgN52];
                                                  } in  Data.Complex.:+ [sat_sgN54 sat_sgN55];
                                            };
                                      };
                                };
                            1# ->
                                case eqFloat# [ww6_sgN4Z 0.0#] of {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$smagnitude1 ww4_sgN4X ww6_sgN4Z
                                      of
                                      ww7_sgN57
                                      { __DEFAULT ->
                                            case divideFloat# [ww4_sgN4X ww7_sgN57] of wild2_sgN58 {
                                              __DEFAULT ->
                                                  case
                                                      divideFloat# [ww6_sgN4Z ww7_sgN57]
                                                  of
                                                  wild1_sgN59
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_sgN5b [Occ=Once] :: GHC.Types.Float
                                                          [LclId] =
                                                              CCCS GHC.Types.F#! [wild1_sgN59]; } in
                                                        let {
                                                          sat_sgN5a [Occ=Once] :: GHC.Types.Float
                                                          [LclId] =
                                                              CCCS GHC.Types.F#! [wild2_sgN58];
                                                        } in  Data.Complex.:+ [sat_sgN5a sat_sgN5b];
                                                  };
                                            };
                                      };
                                  1# -> Data.Complex.$fFloatingComplex12;
                                };
                          };
                    };
              };
        };

Data.Complex.$w$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN5c ww_sgN5d ww1_sgN5e]
        case
            GHC.Float.$p1RealFloat w_sgN5c
        of
        $dRealFrac_sgN5f [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN5f
              of
              $dReal_sgN5g [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      $dNum_sgN5h [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_sgxEJ
                      [LclId] =
                          [$dReal_sgN5g] \u [] GHC.Real.$p1Real $dReal_sgN5g;
                    } in 
                      case
                          GHC.Real.$p2Real $dReal_sgN5g
                      of
                      $dOrd_sgN5i [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                      { __DEFAULT ->
                            case
                                GHC.Classes.$p1Ord $dOrd_sgN5i
                            of
                            $dEq_sgN5j [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                            { __DEFAULT ->
                                  let {
                                    sat_sgN5q [Occ=Once] :: a_sgxEJ
                                    [LclId] =
                                        [$dNum_sgN5h] \u []
                                            GHC.Num.fromInteger
                                                $dNum_sgN5h Data.Complex.$fFloatingComplex17;
                                  } in 
                                    let-no-escape {
                                      fail_sgN5k [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> (# a_sgxEJ, a_sgxEJ #)
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [w_sgN5c
                                                    ww_sgN5d
                                                    ww1_sgN5e
                                                    $dRealFrac_sgN5f] \r [ds_sgN5l]
                                              case
                                                  GHC.Real.$p2RealFrac $dRealFrac_sgN5f
                                              of
                                              $dFractional_sgN5m [Dmd=<S(LC(C(S))LL),U(A,C(C1(U)),A,A)>]
                                              { __DEFAULT ->
                                                    let {
                                                      r_sgN5n :: a_sgxEJ
                                                      [LclId] =
                                                          [w_sgN5c ww_sgN5d ww1_sgN5e] \u []
                                                              Data.Complex.$wmagnitude
                                                                  w_sgN5c ww_sgN5d ww1_sgN5e;
                                                    } in 
                                                      case
                                                          GHC.Real./
                                                              $dFractional_sgN5m ww_sgN5d r_sgN5n
                                                      of
                                                      dt_sgN5o
                                                      { __DEFAULT ->
                                                            case
                                                                GHC.Real./
                                                                    $dFractional_sgN5m
                                                                    ww1_sgN5e
                                                                    r_sgN5n
                                                            of
                                                            dt1_sgN5p
                                                            { __DEFAULT ->
                                                                  (#,#) [dt_sgN5o dt1_sgN5p];
                                                            };
                                                      };
                                              };
                                    } in 
                                      case GHC.Classes.== $dEq_sgN5j ww_sgN5d sat_sgN5q of {
                                        GHC.Types.False -> fail_sgN5k GHC.Prim.void#;
                                        GHC.Types.True ->
                                            let {
                                              sat_sgN5s [Occ=Once] :: a_sgxEJ
                                              [LclId] =
                                                  [$dNum_sgN5h] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_sgN5h
                                                          Data.Complex.$fFloatingComplex17;
                                            } in 
                                              case
                                                  GHC.Classes.== $dEq_sgN5j ww1_sgN5e sat_sgN5s
                                              of
                                              { GHC.Types.False -> fail_sgN5k GHC.Prim.void#;
                                                GHC.Types.True ->
                                                    Data.Complex.$w$cfromInteger
                                                        w_sgN5c Data.Complex.$fFloatingComplex17;
                                              };
                                      };
                            };
                      };
              };
        };

Data.Complex.$fNumComplex_$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN5u w1_sgN5v]
        case w1_sgN5v of {
          Data.Complex.:+ ww1_sgN5x [Occ=Once] ww2_sgN5y [Occ=Once] ->
              case Data.Complex.$w$csignum w_sgN5u ww1_sgN5x ww2_sgN5y of {
                (#,#) ww4_sgN5A [Occ=Once] ww5_sgN5B [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgN5A ww5_sgN5B];
              };
        };

Data.Complex.$fFloatingComplex_$s$fNumComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Num.Num (Data.Complex.Complex GHC.Types.Double)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Num.C:Num! [Data.Complex.$fFloatingComplex_$s$c+
                                  Data.Complex.$fFloatingComplex_$s$c-
                                  Data.Complex.$fFloatingComplex_$s$c*
                                  Data.Complex.$fFloatingComplex_$s$cnegate
                                  Data.Complex.$fFloatingComplex_$s$cabs
                                  Data.Complex.$fFloatingComplex_$s$csignum
                                  Data.Complex.$fFloatingComplex_$s$cfromInteger];

Data.Complex.$fFloatingComplex_$s$fNumComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Num.Num (Data.Complex.Complex GHC.Types.Float)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Num.C:Num! [Data.Complex.$fFloatingComplex_$s$c+1
                                  Data.Complex.$fFloatingComplex_$s$c-1
                                  Data.Complex.$fFloatingComplex_$s$c*1
                                  Data.Complex.$fFloatingComplex_$s$cnegate1
                                  Data.Complex.$fFloatingComplex_$s$cabs1
                                  Data.Complex.$fFloatingComplex_$s$csignum1
                                  Data.Complex.$fFloatingComplex_$s$cfromInteger1];

Data.Complex.$fNumComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Num.Num (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dRealFloat_sgN5C]
        let {
          sat_sgN5J [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cfromInteger
                      $dRealFloat_sgN5C eta_B1; } in
        let {
          sat_sgN5I [Occ=Once]
            :: Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B1]
                  Data.Complex.$fNumComplex_$csignum $dRealFloat_sgN5C eta_B1; } in
        let {
          sat_sgN5H [Occ=Once]
            :: Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B1]
                  Data.Complex.$fNumComplex_$cabs $dRealFloat_sgN5C eta_B1; } in
        let {
          sat_sgN5G [Occ=Once]
            :: Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cnegate
                      $dRealFloat_sgN5C eta_B1; } in
        let {
          sat_sgN5F [Occ=Once]
            :: Data.Complex.Complex a_agt1x
               -> Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B2 eta_B1]
                  Data.Complex.$fNumComplex_$c* $dRealFloat_sgN5C eta_B2 eta_B1; } in
        let {
          sat_sgN5E [Occ=Once]
            :: Data.Complex.Complex a_agt1x
               -> Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c-
                      $dRealFloat_sgN5C eta_B2 eta_B1; } in
        let {
          sat_sgN5D [Occ=Once]
            :: Data.Complex.Complex a_agt1x
               -> Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c+ $dRealFloat_sgN5C eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [sat_sgN5D
                         sat_sgN5E
                         sat_sgN5F
                         sat_sgN5G
                         sat_sgN5H
                         sat_sgN5I
                         sat_sgN5J];

Data.Complex.$w$s$csqrt1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgN5K ww1_sgN5L]
        let-no-escape {
          fail_sgN5M [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> (# GHC.Types.Float, GHC.Types.Float #)
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [ww_sgN5K ww1_sgN5L] \r [ds_sgN5N]
                  case ltFloat# [ww_sgN5K 0.0#] of {
                    __DEFAULT ->
                        case Data.Complex.$w$smagnitude1 ww_sgN5K ww1_sgN5L of ww2_sgN5P {
                          __DEFAULT ->
                              case fabsFloat# [ww_sgN5K] of sat_sgN5R {
                                __DEFAULT ->
                                    case plusFloat# [ww2_sgN5P sat_sgN5R] of sat_sgN5S {
                                      __DEFAULT ->
                                          case divideFloat# [sat_sgN5S 2.0#] of sat_sgN5T {
                                            __DEFAULT ->
                                                case
                                                    sqrtFloat# [sat_sgN5T]
                                                of
                                                ipv_sgN5Q [Dmd=<S,U>]
                                                { __DEFAULT ->
                                                      case ltFloat# [ww1_sgN5L 0.0#] of {
                                                        __DEFAULT ->
                                                            case
                                                                plusFloat# [ipv_sgN5Q ipv_sgN5Q]
                                                            of
                                                            sat_sgN5W
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsFloat# [ww1_sgN5L]
                                                                  of
                                                                  sat_sgN5V
                                                                  { __DEFAULT ->
                                                                        case
                                                                            divideFloat# [sat_sgN5V
                                                                                          sat_sgN5W]
                                                                        of
                                                                        wild2_sgN5X
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgN5Z [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [wild2_sgN5X]; } in
                                                                              let {
                                                                                sat_sgN5Y [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [ipv_sgN5Q];
                                                                              } in 
                                                                                (#,#) [sat_sgN5Y
                                                                                       sat_sgN5Z];
                                                                        };
                                                                  };
                                                            };
                                                        1# ->
                                                            case
                                                                plusFloat# [ipv_sgN5Q ipv_sgN5Q]
                                                            of
                                                            sat_sgN61
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsFloat# [ww1_sgN5L]
                                                                  of
                                                                  sat_sgN60
                                                                  { __DEFAULT ->
                                                                        case
                                                                            divideFloat# [sat_sgN60
                                                                                          sat_sgN61]
                                                                        of
                                                                        wild2_sgN62
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  negateFloat# [wild2_sgN62]
                                                                              of
                                                                              sat_sgN64
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgN65 [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [sat_sgN64]; } in
                                                                                    let {
                                                                                      sat_sgN63 [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [ipv_sgN5Q];
                                                                                    } in 
                                                                                      (#,#) [sat_sgN63
                                                                                             sat_sgN65];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                    1# ->
                        case Data.Complex.$w$smagnitude1 ww_sgN5K ww1_sgN5L of ww2_sgN66 {
                          __DEFAULT ->
                              case fabsFloat# [ww_sgN5K] of sat_sgN68 {
                                __DEFAULT ->
                                    case plusFloat# [ww2_sgN66 sat_sgN68] of sat_sgN69 {
                                      __DEFAULT ->
                                          case divideFloat# [sat_sgN69 2.0#] of sat_sgN6a {
                                            __DEFAULT ->
                                                case sqrtFloat# [sat_sgN6a] of x_sgN67 [Dmd=<S,U>] {
                                                  __DEFAULT ->
                                                      case
                                                          plusFloat# [x_sgN67 x_sgN67]
                                                      of
                                                      sat_sgN6c
                                                      { __DEFAULT ->
                                                            case
                                                                fabsFloat# [ww1_sgN5L]
                                                            of
                                                            sat_sgN6b
                                                            { __DEFAULT ->
                                                                  case
                                                                      divideFloat# [sat_sgN6b
                                                                                    sat_sgN6c]
                                                                  of
                                                                  wild2_sgN6d
                                                                  { __DEFAULT ->
                                                                        case
                                                                            ltFloat# [ww1_sgN5L
                                                                                      0.0#]
                                                                        of
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgN6g [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [x_sgN67]; } in
                                                                              let {
                                                                                sat_sgN6f [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [wild2_sgN6d];
                                                                              } in 
                                                                                (#,#) [sat_sgN6f
                                                                                       sat_sgN6g];
                                                                          1# ->
                                                                              case
                                                                                  negateFloat# [x_sgN67]
                                                                              of
                                                                              sat_sgN6i
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgN6j [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [sat_sgN6i]; } in
                                                                                    let {
                                                                                      sat_sgN6h [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [wild2_sgN6d];
                                                                                    } in 
                                                                                      (#,#) [sat_sgN6h
                                                                                             sat_sgN6j];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case eqFloat# [ww_sgN5K 0.0#] of {
            __DEFAULT -> fail_sgN5M GHC.Prim.void#;
            1# ->
                case eqFloat# [ww1_sgN5L 0.0#] of {
                  __DEFAULT -> fail_sgN5M GHC.Prim.void#;
                  1# ->
                      (#,#) [Data.Complex.$fFloatingComplex9
                             Data.Complex.$fFloatingComplex9];
                };
          };

Data.Complex.$fFloatingComplex_$s$csqrt1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN6m]
        case w_sgN6m of {
          Data.Complex.:+ ww1_sgN6o [Occ=Once!] ww2_sgN6p [Occ=Once!] ->
              case ww1_sgN6o of {
                GHC.Types.F# ww4_sgN6r [Occ=Once] ->
                    case ww2_sgN6p of {
                      GHC.Types.F# ww6_sgN6t [Occ=Once] ->
                          case Data.Complex.$w$s$csqrt1 ww4_sgN6r ww6_sgN6t of {
                            (#,#) ww8_sgN6v [Occ=Once] ww9_sgN6w [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgN6v ww9_sgN6w];
                          };
                    };
              };
        };

Data.Complex.$w$s$csqrt [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgN6x ww1_sgN6y]
        let-no-escape {
          fail_sgN6z [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> (# GHC.Types.Double, GHC.Types.Double #)
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [ww_sgN6x ww1_sgN6y] \r [ds_sgN6A]
                  case <## [ww_sgN6x 0.0##] of {
                    __DEFAULT ->
                        case Data.Complex.$w$smagnitude ww_sgN6x ww1_sgN6y of ww2_sgN6C {
                          __DEFAULT ->
                              case fabsDouble# [ww_sgN6x] of sat_sgN6E {
                                __DEFAULT ->
                                    case +## [ww2_sgN6C sat_sgN6E] of sat_sgN6F {
                                      __DEFAULT ->
                                          case /## [sat_sgN6F 2.0##] of sat_sgN6G {
                                            __DEFAULT ->
                                                case
                                                    sqrtDouble# [sat_sgN6G]
                                                of
                                                ipv_sgN6D [Dmd=<S,U>]
                                                { __DEFAULT ->
                                                      case <## [ww1_sgN6y 0.0##] of {
                                                        __DEFAULT ->
                                                            case
                                                                +## [ipv_sgN6D ipv_sgN6D]
                                                            of
                                                            sat_sgN6J
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsDouble# [ww1_sgN6y]
                                                                  of
                                                                  sat_sgN6I
                                                                  { __DEFAULT ->
                                                                        case
                                                                            /## [sat_sgN6I
                                                                                 sat_sgN6J]
                                                                        of
                                                                        wild2_sgN6K
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgN6M [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [wild2_sgN6K]; } in
                                                                              let {
                                                                                sat_sgN6L [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [ipv_sgN6D];
                                                                              } in 
                                                                                (#,#) [sat_sgN6L
                                                                                       sat_sgN6M];
                                                                        };
                                                                  };
                                                            };
                                                        1# ->
                                                            case
                                                                +## [ipv_sgN6D ipv_sgN6D]
                                                            of
                                                            sat_sgN6O
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsDouble# [ww1_sgN6y]
                                                                  of
                                                                  sat_sgN6N
                                                                  { __DEFAULT ->
                                                                        case
                                                                            /## [sat_sgN6N
                                                                                 sat_sgN6O]
                                                                        of
                                                                        wild2_sgN6P
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  negateDouble# [wild2_sgN6P]
                                                                              of
                                                                              sat_sgN6R
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgN6S [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [sat_sgN6R]; } in
                                                                                    let {
                                                                                      sat_sgN6Q [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [ipv_sgN6D];
                                                                                    } in 
                                                                                      (#,#) [sat_sgN6Q
                                                                                             sat_sgN6S];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                    1# ->
                        case Data.Complex.$w$smagnitude ww_sgN6x ww1_sgN6y of ww2_sgN6T {
                          __DEFAULT ->
                              case fabsDouble# [ww_sgN6x] of sat_sgN6V {
                                __DEFAULT ->
                                    case +## [ww2_sgN6T sat_sgN6V] of sat_sgN6W {
                                      __DEFAULT ->
                                          case /## [sat_sgN6W 2.0##] of sat_sgN6X {
                                            __DEFAULT ->
                                                case
                                                    sqrtDouble# [sat_sgN6X]
                                                of
                                                x_sgN6U [Dmd=<S,U>]
                                                { __DEFAULT ->
                                                      case +## [x_sgN6U x_sgN6U] of sat_sgN6Z {
                                                        __DEFAULT ->
                                                            case
                                                                fabsDouble# [ww1_sgN6y]
                                                            of
                                                            sat_sgN6Y
                                                            { __DEFAULT ->
                                                                  case
                                                                      /## [sat_sgN6Y sat_sgN6Z]
                                                                  of
                                                                  wild2_sgN70
                                                                  { __DEFAULT ->
                                                                        case
                                                                            <## [ww1_sgN6y 0.0##]
                                                                        of
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgN73 [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [x_sgN6U]; } in
                                                                              let {
                                                                                sat_sgN72 [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [wild2_sgN70];
                                                                              } in 
                                                                                (#,#) [sat_sgN72
                                                                                       sat_sgN73];
                                                                          1# ->
                                                                              case
                                                                                  negateDouble# [x_sgN6U]
                                                                              of
                                                                              sat_sgN75
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgN76 [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [sat_sgN75]; } in
                                                                                    let {
                                                                                      sat_sgN74 [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [wild2_sgN70];
                                                                                    } in 
                                                                                      (#,#) [sat_sgN74
                                                                                             sat_sgN76];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case ==## [ww_sgN6x 0.0##] of {
            __DEFAULT -> fail_sgN6z GHC.Prim.void#;
            1# ->
                case ==## [ww1_sgN6y 0.0##] of {
                  __DEFAULT -> fail_sgN6z GHC.Prim.void#;
                  1# ->
                      (#,#) [Data.Complex.$fFloatingComplex1
                             Data.Complex.$fFloatingComplex1];
                };
          };

Data.Complex.$fFloatingComplex_$s$csqrt [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN79]
        case w_sgN79 of {
          Data.Complex.:+ ww1_sgN7b [Occ=Once!] ww2_sgN7c [Occ=Once!] ->
              case ww1_sgN7b of {
                GHC.Types.D# ww4_sgN7e [Occ=Once] ->
                    case ww2_sgN7c of {
                      GHC.Types.D# ww6_sgN7g [Occ=Once] ->
                          case Data.Complex.$w$s$csqrt ww4_sgN7e ww6_sgN7g of {
                            (#,#) ww8_sgN7i [Occ=Once] ww9_sgN7j [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgN7i ww9_sgN7j];
                          };
                    };
              };
        };

sat_sgN7k :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_sgN7l :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgN7k GHC.Types.[]];

Data.Complex.$fFloatingComplex21 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgN7l;

Data.Complex.$w$csqrt [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN7m ww_sgN7n ww1_sgN7o]
        case
            GHC.Float.$p1RealFloat w_sgN7m
        of
        $dRealFrac_sgN7p [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN7p
              of
              $dReal_sgN7q [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p2Real $dReal_sgN7q
                    of
                    $dOrd_sgN7r [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dNum_sgN7s [Dmd=<L,U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U))>]
                              :: GHC.Num.Num a_sgxFA
                            [LclId] =
                                [$dReal_sgN7q] \u [] GHC.Real.$p1Real $dReal_sgN7q;
                          } in 
                            case
                                GHC.Classes.$p1Ord $dOrd_sgN7r
                            of
                            $dEq_sgN7t [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                            { __DEFAULT ->
                                  let {
                                    sat_sgN7S [Occ=Once] :: a_sgxFA
                                    [LclId] =
                                        [$dNum_sgN7s] \u []
                                            GHC.Num.fromInteger
                                                $dNum_sgN7s Data.Complex.$fFloatingComplex17;
                                  } in 
                                    let-no-escape {
                                      fail_sgN7u [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> (# a_sgxFA, a_sgxFA #)
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [w_sgN7m
                                                    ww_sgN7n
                                                    ww1_sgN7o
                                                    $dRealFrac_sgN7p
                                                    $dOrd_sgN7r
                                                    $dNum_sgN7s] \r [ds_sgN7v]
                                              let {
                                                $dFractional_sgN7w [Dmd=<L,U(A,C(C1(U)),A,A)>]
                                                  :: GHC.Real.Fractional a_sgxFA
                                                [LclId] =
                                                    [$dRealFrac_sgN7p] \u []
                                                        GHC.Real.$p2RealFrac $dRealFrac_sgN7p; } in
                                              let {
                                                u'_sgN7x :: a_sgxFA
                                                [LclId] =
                                                    [w_sgN7m
                                                     ww_sgN7n
                                                     ww1_sgN7o
                                                     $dNum_sgN7s
                                                     $dFractional_sgN7w] \u []
                                                        let {
                                                          sat_sgN7D [Occ=Once] :: a_sgxFA
                                                          [LclId] =
                                                              [w_sgN7m
                                                               ww_sgN7n
                                                               ww1_sgN7o
                                                               $dNum_sgN7s
                                                               $dFractional_sgN7w] \u []
                                                                  let {
                                                                    sat_sgN7C [Occ=Once] :: a_sgxFA
                                                                    [LclId] =
                                                                        [$dNum_sgN7s] \u []
                                                                            GHC.Num.fromInteger
                                                                                $dNum_sgN7s
                                                                                Data.Complex.$fFloatingComplex21; } in
                                                                  let {
                                                                    sat_sgN7B [Occ=Once] :: a_sgxFA
                                                                    [LclId] =
                                                                        [w_sgN7m
                                                                         ww_sgN7n
                                                                         ww1_sgN7o
                                                                         $dNum_sgN7s] \u []
                                                                            let {
                                                                              sat_sgN7A [Occ=Once]
                                                                                :: a_sgxFA
                                                                              [LclId] =
                                                                                  [ww_sgN7n
                                                                                   $dNum_sgN7s] \u []
                                                                                      GHC.Num.abs
                                                                                          $dNum_sgN7s
                                                                                          ww_sgN7n; } in
                                                                            let {
                                                                              sat_sgN7z [Occ=Once]
                                                                                :: a_sgxFA
                                                                              [LclId] =
                                                                                  [w_sgN7m
                                                                                   ww_sgN7n
                                                                                   ww1_sgN7o] \u []
                                                                                      Data.Complex.$wmagnitude
                                                                                          w_sgN7m
                                                                                          ww_sgN7n
                                                                                          ww1_sgN7o;
                                                                            } in 
                                                                              GHC.Num.+
                                                                                  $dNum_sgN7s
                                                                                  sat_sgN7z
                                                                                  sat_sgN7A;
                                                                  } in 
                                                                    GHC.Real./
                                                                        $dFractional_sgN7w
                                                                        sat_sgN7B
                                                                        sat_sgN7C;
                                                        } in 
                                                          case
                                                              GHC.Float.$p2RealFloat w_sgN7m
                                                          of
                                                          sat_sgN7y
                                                          { __DEFAULT ->
                                                                GHC.Float.sqrt sat_sgN7y sat_sgN7D;
                                                          }; } in
                                              let {
                                                v'_sgN7E [Occ=Once*] :: a_sgxFA
                                                [LclId] =
                                                    [ww1_sgN7o
                                                     $dNum_sgN7s
                                                     $dFractional_sgN7w
                                                     u'_sgN7x] \u []
                                                        let {
                                                          sat_sgN7H [Occ=Once] :: a_sgxFA
                                                          [LclId] =
                                                              [$dNum_sgN7s u'_sgN7x] \u []
                                                                  let {
                                                                    sat_sgN7G [Occ=Once] :: a_sgxFA
                                                                    [LclId] =
                                                                        [$dNum_sgN7s] \u []
                                                                            GHC.Num.fromInteger
                                                                                $dNum_sgN7s
                                                                                Data.Complex.$fFloatingComplex21;
                                                                  } in 
                                                                    GHC.Num.*
                                                                        $dNum_sgN7s
                                                                        u'_sgN7x
                                                                        sat_sgN7G; } in
                                                        let {
                                                          sat_sgN7F [Occ=Once] :: a_sgxFA
                                                          [LclId] =
                                                              [ww1_sgN7o $dNum_sgN7s] \u []
                                                                  GHC.Num.abs $dNum_sgN7s ww1_sgN7o;
                                                        } in 
                                                          GHC.Real./
                                                              $dFractional_sgN7w
                                                              sat_sgN7F
                                                              sat_sgN7H; } in
                                              let {
                                                sat_sgN7Q [Occ=Once] :: a_sgxFA
                                                [LclId] =
                                                    [$dNum_sgN7s] \u []
                                                        GHC.Num.fromInteger
                                                            $dNum_sgN7s
                                                            Data.Complex.$fFloatingComplex17;
                                              } in 
                                                let-no-escape {
                                                  $j_sgN7I [Occ=Once*!T[2],
                                                            Dmd=<C(C(S)),1*C1(C1(U(U,U)))>]
                                                    :: a_sgxFA -> a_sgxFA -> (# a_sgxFA, a_sgxFA #)
                                                  [LclId[JoinId(2)],
                                                   Arity=2,
                                                   Str=<S,1*U><L,U>,
                                                   Unf=OtherCon []] =
                                                      sat-only [ww1_sgN7o
                                                                $dOrd_sgN7r
                                                                $dNum_sgN7s] \r [u_sgN7J v_sgN7K]
                                                          case u_sgN7J of dt_sgN7L {
                                                            __DEFAULT ->
                                                                let {
                                                                  sat_sgN7M [Occ=Once] :: a_sgxFA
                                                                  [LclId] =
                                                                      [$dNum_sgN7s] \u []
                                                                          GHC.Num.fromInteger
                                                                              $dNum_sgN7s
                                                                              Data.Complex.$fFloatingComplex17;
                                                                } in 
                                                                  case
                                                                      GHC.Classes.<
                                                                          $dOrd_sgN7r
                                                                          ww1_sgN7o
                                                                          sat_sgN7M
                                                                  of
                                                                  { GHC.Types.False ->
                                                                        case v_sgN7K of dt1_sgN7O {
                                                                          __DEFAULT ->
                                                                              (#,#) [dt_sgN7L
                                                                                     dt1_sgN7O];
                                                                        };
                                                                    GHC.Types.True ->
                                                                        case
                                                                            GHC.Num.negate
                                                                                $dNum_sgN7s v_sgN7K
                                                                        of
                                                                        dt1_sgN7P
                                                                        { __DEFAULT ->
                                                                              (#,#) [dt_sgN7L
                                                                                     dt1_sgN7P];
                                                                        };
                                                                  };
                                                          };
                                                } in 
                                                  case
                                                      GHC.Classes.< $dOrd_sgN7r ww_sgN7n sat_sgN7Q
                                                  of
                                                  { GHC.Types.False -> $j_sgN7I u'_sgN7x v'_sgN7E;
                                                    GHC.Types.True -> $j_sgN7I v'_sgN7E u'_sgN7x;
                                                  };
                                    } in 
                                      case GHC.Classes.== $dEq_sgN7t ww_sgN7n sat_sgN7S of {
                                        GHC.Types.False -> fail_sgN7u GHC.Prim.void#;
                                        GHC.Types.True ->
                                            let {
                                              sat_sgN7U [Occ=Once] :: a_sgxFA
                                              [LclId] =
                                                  [$dNum_sgN7s] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_sgN7s
                                                          Data.Complex.$fFloatingComplex17;
                                            } in 
                                              case
                                                  GHC.Classes.== $dEq_sgN7t ww1_sgN7o sat_sgN7U
                                              of
                                              { GHC.Types.False -> fail_sgN7u GHC.Prim.void#;
                                                GHC.Types.True ->
                                                    Data.Complex.$w$cfromInteger
                                                        w_sgN7m Data.Complex.$fFloatingComplex17;
                                              };
                                      };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$csqrt [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN7W w1_sgN7X]
        case w1_sgN7X of {
          Data.Complex.:+ ww1_sgN7Z [Occ=Once] ww2_sgN80 [Occ=Once] ->
              case Data.Complex.$w$csqrt w_sgN7W ww1_sgN7Z ww2_sgN80 of {
                (#,#) ww4_sgN82 [Occ=Once] ww5_sgN83 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgN82 ww5_sgN83];
              };
        };

Data.Complex.$fFloatingComplex_$s$crecip [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgN84]
        case eta_sgN84 of {
          Data.Complex.:+ ww1_sgN86 [Occ=Once!] ww2_sgN87 [Occ=Once!] ->
              case ww1_sgN86 of {
                GHC.Types.D# ww4_sgN89 [Occ=Once] ->
                    case ww2_sgN87 of {
                      GHC.Types.D# ww6_sgN8b [Occ=Once] ->
                          case Data.Complex.$w$s$c/ 1.0## 0.0## ww4_sgN89 ww6_sgN8b of {
                            (#,#) ww8_sgN8d [Occ=Once] ww9_sgN8e [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgN8d ww9_sgN8e];
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$crecip1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgN8f]
        case eta_sgN8f of {
          Data.Complex.:+ ww1_sgN8h [Occ=Once!] ww2_sgN8i [Occ=Once!] ->
              case ww1_sgN8h of {
                GHC.Types.F# ww4_sgN8k [Occ=Once] ->
                    case ww2_sgN8i of {
                      GHC.Types.F# ww6_sgN8m [Occ=Once] ->
                          case Data.Complex.$w$s$c/1 1.0# 0.0# ww4_sgN8k ww6_sgN8m of {
                            (#,#) ww8_sgN8o [Occ=Once] ww9_sgN8p [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgN8o ww9_sgN8p];
                          };
                    };
              };
        };

sat_sgN8q :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sgN8r :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgN8q GHC.Types.[]];

Data.Complex.$fFloatingComplex19 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgN8r;

Data.Complex.$fFractionalComplex_$crecip [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgN8s eta_sgN8t]
        case
            Data.Complex.$w$cfromInteger
                $dRealFloat_sgN8s Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww1_sgN8v [Occ=Once] ww2_sgN8w [Occ=Once] ->
              case eta_sgN8t of {
                Data.Complex.:+ ww4_sgN8y [Occ=Once] ww5_sgN8z [Occ=Once] ->
                    case
                        Data.Complex.$w$c/
                            $dRealFloat_sgN8s ww1_sgN8v ww2_sgN8w ww4_sgN8y ww5_sgN8z
                    of
                    { (#,#) ww7_sgN8B [Occ=Once] ww8_sgN8C [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgN8B ww8_sgN8C];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$fFractionalComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Fractional (Data.Complex.Complex GHC.Types.Double)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Fractional! [Data.Complex.$fFloatingComplex_$s$fNumComplex
                                          Data.Complex.$fFloatingComplex_$s$c/
                                          Data.Complex.$fFloatingComplex_$s$crecip
                                          Data.Complex.$fFloatingComplex_$s$cfromRational];

Data.Complex.$fFloatingComplex_$s$fFractionalComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Fractional (Data.Complex.Complex GHC.Types.Float)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Fractional! [Data.Complex.$fFloatingComplex_$s$fNumComplex1
                                          Data.Complex.$fFloatingComplex_$s$c/1
                                          Data.Complex.$fFloatingComplex_$s$crecip1
                                          Data.Complex.$fFloatingComplex_$s$cfromRational1];

Data.Complex.$fFractionalComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.Fractional (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dRealFloat_sgN8D]
        let {
          sat_sgN8H [Occ=Once]
            :: GHC.Real.Rational -> Data.Complex.Complex a_agsZS
          [LclId] =
              [$dRealFloat_sgN8D] \r [eta_B1]
                  Data.Complex.$fFractionalComplex_$cfromRational
                      $dRealFloat_sgN8D eta_B1; } in
        let {
          sat_sgN8G [Occ=Once]
            :: Data.Complex.Complex a_agsZS -> Data.Complex.Complex a_agsZS
          [LclId] =
              [$dRealFloat_sgN8D] \r [eta_B1]
                  Data.Complex.$fFractionalComplex_$crecip
                      $dRealFloat_sgN8D eta_B1; } in
        let {
          sat_sgN8F [Occ=Once]
            :: Data.Complex.Complex a_agsZS
               -> Data.Complex.Complex a_agsZS -> Data.Complex.Complex a_agsZS
          [LclId] =
              [$dRealFloat_sgN8D] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c/
                      $dRealFloat_sgN8D eta_B2 eta_B1; } in
        let {
          sat_sgN8E [Occ=Once] :: GHC.Num.Num (Data.Complex.Complex a_agsZS)
          [LclId] =
              [$dRealFloat_sgN8D] \u []
                  Data.Complex.$fNumComplex $dRealFloat_sgN8D;
        } in 
          GHC.Real.C:Fractional [sat_sgN8E sat_sgN8F sat_sgN8G sat_sgN8H];

Data.Complex.$fFloatingComplex_$s$ctan1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN8I]
        case w_sgN8I of {
          Data.Complex.:+ ww1_sgN8K [Occ=Once!] ww2_sgN8L [Occ=Once!] ->
              case ww1_sgN8K of {
                GHC.Types.F# ww4_sgN8N ->
                    case ww2_sgN8L of {
                      GHC.Types.F# ww6_sgN8P ->
                          case coshFloat# [ww6_sgN8P] of coshy_sgN8Q [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhFloat# [ww6_sgN8P] of sinhy_sgN8R [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosFloat# [ww4_sgN8N] of cosx_sgN8S [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinFloat# [ww4_sgN8N] of sinx_sgN8T [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [sinx_sgN8T sinhy_sgN8R]
                                                  of
                                                  sat_sgN8X
                                                  { __DEFAULT ->
                                                        case negateFloat# [sat_sgN8X] of sat_sgN8Y {
                                                          __DEFAULT ->
                                                              case
                                                                  timesFloat# [cosx_sgN8S
                                                                               coshy_sgN8Q]
                                                              of
                                                              sat_sgN8W
                                                              { __DEFAULT ->
                                                                    case
                                                                        timesFloat# [cosx_sgN8S
                                                                                     sinhy_sgN8R]
                                                                    of
                                                                    sat_sgN8V
                                                                    { __DEFAULT ->
                                                                          case
                                                                              timesFloat# [sinx_sgN8T
                                                                                           coshy_sgN8Q]
                                                                          of
                                                                          sat_sgN8U
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/1
                                                                                        sat_sgN8U
                                                                                        sat_sgN8V
                                                                                        sat_sgN8W
                                                                                        sat_sgN8Y
                                                                                of
                                                                                { (#,#) ww8_sgN90 [Occ=Once]
                                                                                        ww9_sgN91 [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww8_sgN90
                                                                                                       ww9_sgN91];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ctan [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN92]
        case w_sgN92 of {
          Data.Complex.:+ ww1_sgN94 [Occ=Once!] ww2_sgN95 [Occ=Once!] ->
              case ww1_sgN94 of {
                GHC.Types.D# ww4_sgN97 ->
                    case ww2_sgN95 of {
                      GHC.Types.D# ww6_sgN99 ->
                          case coshDouble# [ww6_sgN99] of coshy_sgN9a [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhDouble# [ww6_sgN99] of sinhy_sgN9b [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosDouble# [ww4_sgN97] of cosx_sgN9c [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinDouble# [ww4_sgN97] of sinx_sgN9d [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case *## [sinx_sgN9d sinhy_sgN9b] of sat_sgN9h {
                                                    __DEFAULT ->
                                                        case
                                                            negateDouble# [sat_sgN9h]
                                                        of
                                                        sat_sgN9i
                                                        { __DEFAULT ->
                                                              case
                                                                  *## [cosx_sgN9c coshy_sgN9a]
                                                              of
                                                              sat_sgN9g
                                                              { __DEFAULT ->
                                                                    case
                                                                        *## [cosx_sgN9c sinhy_sgN9b]
                                                                    of
                                                                    sat_sgN9f
                                                                    { __DEFAULT ->
                                                                          case
                                                                              *## [sinx_sgN9d
                                                                                   coshy_sgN9a]
                                                                          of
                                                                          sat_sgN9e
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/
                                                                                        sat_sgN9e
                                                                                        sat_sgN9f
                                                                                        sat_sgN9g
                                                                                        sat_sgN9i
                                                                                of
                                                                                { (#,#) ww8_sgN9k [Occ=Once]
                                                                                        ww9_sgN9l [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww8_sgN9k
                                                                                                       ww9_sgN9l];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ctan [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),1*C1(U),A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN9m ww_sgN9n ww1_sgN9o]
        case
            GHC.Float.$p1RealFloat w_sgN9m
        of
        $dRealFrac_sgN9p [Dmd=<S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN9p
              of
              $dReal_sgN9q [Dmd=<S(S(LLC(C(S))C(S)LLL)LL),1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgN9q
                    of
                    $dNum_sgN9r [Dmd=<S(LLC(C(S))C(S)LLL),U(A,A,C(C1(U)),1*C1(U),A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dFloating_sgN9s [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
                              :: GHC.Float.Floating a_sgxGm
                            [LclId] =
                                [w_sgN9m] \u [] GHC.Float.$p2RealFloat w_sgN9m; } in
                          let {
                            coshy_sgN9t :: a_sgxGm
                            [LclId] =
                                [ww1_sgN9o $dFloating_sgN9s] \u []
                                    GHC.Float.cosh $dFloating_sgN9s ww1_sgN9o; } in
                          let {
                            sinx_sgN9u :: a_sgxGm
                            [LclId] =
                                [ww_sgN9n $dFloating_sgN9s] \u []
                                    GHC.Float.sin $dFloating_sgN9s ww_sgN9n;
                          } in 
                            case GHC.Num.* $dNum_sgN9r sinx_sgN9u coshy_sgN9t of dt_sgN9v {
                              __DEFAULT ->
                                  let {
                                    sinhy_sgN9w :: a_sgxGm
                                    [LclId] =
                                        [ww1_sgN9o $dFloating_sgN9s] \u []
                                            GHC.Float.sinh $dFloating_sgN9s ww1_sgN9o; } in
                                  let {
                                    cosx_sgN9x :: a_sgxGm
                                    [LclId] =
                                        [ww_sgN9n $dFloating_sgN9s] \u []
                                            GHC.Float.cos $dFloating_sgN9s ww_sgN9n;
                                  } in 
                                    case GHC.Num.* $dNum_sgN9r cosx_sgN9x sinhy_sgN9w of dt1_sgN9y {
                                      __DEFAULT ->
                                          case
                                              GHC.Num.* $dNum_sgN9r cosx_sgN9x coshy_sgN9t
                                          of
                                          dt2_sgN9z
                                          { __DEFAULT ->
                                                let {
                                                  sat_sgN9A [Occ=Once] :: a_sgxGm
                                                  [LclId] =
                                                      [$dNum_sgN9r sinx_sgN9u sinhy_sgN9w] \u []
                                                          GHC.Num.*
                                                              $dNum_sgN9r sinx_sgN9u sinhy_sgN9w;
                                                } in 
                                                  case
                                                      GHC.Num.negate $dNum_sgN9r sat_sgN9A
                                                  of
                                                  dt3_sgN9B
                                                  { __DEFAULT ->
                                                        Data.Complex.$w$c/
                                                            w_sgN9m
                                                            dt_sgN9v
                                                            dt1_sgN9y
                                                            dt2_sgN9z
                                                            dt3_sgN9B;
                                                  };
                                          };
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$ctan [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN9C w1_sgN9D]
        case w1_sgN9D of {
          Data.Complex.:+ ww1_sgN9F [Occ=Once] ww2_sgN9G [Occ=Once] ->
              case Data.Complex.$w$ctan w_sgN9C ww1_sgN9F ww2_sgN9G of {
                (#,#) ww4_sgN9I [Occ=Once] ww5_sgN9J [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgN9I ww5_sgN9J];
              };
        };

Data.Complex.$fFloatingComplex_$s$ctanh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN9K]
        case w_sgN9K of {
          Data.Complex.:+ ww1_sgN9M [Occ=Once!] ww2_sgN9N [Occ=Once!] ->
              case ww1_sgN9M of {
                GHC.Types.F# ww4_sgN9P ->
                    case ww2_sgN9N of {
                      GHC.Types.F# ww6_sgN9R ->
                          case coshFloat# [ww4_sgN9P] of coshx_sgN9S [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhFloat# [ww4_sgN9P] of sinhx_sgN9T [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosFloat# [ww6_sgN9R] of cosy_sgN9U [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinFloat# [ww6_sgN9R] of siny_sgN9V [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [siny_sgN9V sinhx_sgN9T]
                                                  of
                                                  sat_sgN9Z
                                                  { __DEFAULT ->
                                                        case
                                                            timesFloat# [cosy_sgN9U coshx_sgN9S]
                                                        of
                                                        sat_sgN9Y
                                                        { __DEFAULT ->
                                                              case
                                                                  timesFloat# [siny_sgN9V
                                                                               coshx_sgN9S]
                                                              of
                                                              sat_sgN9X
                                                              { __DEFAULT ->
                                                                    case
                                                                        timesFloat# [cosy_sgN9U
                                                                                     sinhx_sgN9T]
                                                                    of
                                                                    sat_sgN9W
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/1
                                                                                  sat_sgN9W
                                                                                  sat_sgN9X
                                                                                  sat_sgN9Y
                                                                                  sat_sgN9Z
                                                                          of
                                                                          { (#,#) ww8_sgNa1 [Occ=Once]
                                                                                  ww9_sgNa2 [Occ=Once] ->
                                                                                Data.Complex.:+ [ww8_sgNa1
                                                                                                 ww9_sgNa2];
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ctanh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNa3]
        case w_sgNa3 of {
          Data.Complex.:+ ww1_sgNa5 [Occ=Once!] ww2_sgNa6 [Occ=Once!] ->
              case ww1_sgNa5 of {
                GHC.Types.D# ww4_sgNa8 ->
                    case ww2_sgNa6 of {
                      GHC.Types.D# ww6_sgNaa ->
                          case coshDouble# [ww4_sgNa8] of coshx_sgNab [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhDouble# [ww4_sgNa8] of sinhx_sgNac [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosDouble# [ww6_sgNaa] of cosy_sgNad [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinDouble# [ww6_sgNaa] of siny_sgNae [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case *## [siny_sgNae sinhx_sgNac] of sat_sgNai {
                                                    __DEFAULT ->
                                                        case
                                                            *## [cosy_sgNad coshx_sgNab]
                                                        of
                                                        sat_sgNah
                                                        { __DEFAULT ->
                                                              case
                                                                  *## [siny_sgNae coshx_sgNab]
                                                              of
                                                              sat_sgNag
                                                              { __DEFAULT ->
                                                                    case
                                                                        *## [cosy_sgNad sinhx_sgNac]
                                                                    of
                                                                    sat_sgNaf
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/
                                                                                  sat_sgNaf
                                                                                  sat_sgNag
                                                                                  sat_sgNah
                                                                                  sat_sgNai
                                                                          of
                                                                          { (#,#) ww8_sgNak [Occ=Once]
                                                                                  ww9_sgNal [Occ=Once] ->
                                                                                Data.Complex.:+ [ww8_sgNak
                                                                                                 ww9_sgNal];
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ctanh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNam ww_sgNan ww1_sgNao]
        case
            GHC.Float.$p1RealFloat w_sgNam
        of
        $dRealFrac_sgNap [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgNap
              of
              $dReal_sgNaq [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgNaq
                    of
                    $dNum_sgNar [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dFloating_sgNas [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
                              :: GHC.Float.Floating a_sgxH8
                            [LclId] =
                                [w_sgNam] \u [] GHC.Float.$p2RealFloat w_sgNam; } in
                          let {
                            sinhx_sgNat :: a_sgxH8
                            [LclId] =
                                [ww_sgNan $dFloating_sgNas] \u []
                                    GHC.Float.sinh $dFloating_sgNas ww_sgNan; } in
                          let {
                            cosy_sgNau :: a_sgxH8
                            [LclId] =
                                [ww1_sgNao $dFloating_sgNas] \u []
                                    GHC.Float.cos $dFloating_sgNas ww1_sgNao;
                          } in 
                            case GHC.Num.* $dNum_sgNar cosy_sgNau sinhx_sgNat of dt_sgNav {
                              __DEFAULT ->
                                  let {
                                    coshx_sgNaw :: a_sgxH8
                                    [LclId] =
                                        [ww_sgNan $dFloating_sgNas] \u []
                                            GHC.Float.cosh $dFloating_sgNas ww_sgNan; } in
                                  let {
                                    siny_sgNax :: a_sgxH8
                                    [LclId] =
                                        [ww1_sgNao $dFloating_sgNas] \u []
                                            GHC.Float.sin $dFloating_sgNas ww1_sgNao;
                                  } in 
                                    case GHC.Num.* $dNum_sgNar siny_sgNax coshx_sgNaw of dt1_sgNay {
                                      __DEFAULT ->
                                          case
                                              GHC.Num.* $dNum_sgNar cosy_sgNau coshx_sgNaw
                                          of
                                          dt2_sgNaz
                                          { __DEFAULT ->
                                                case
                                                    GHC.Num.* $dNum_sgNar siny_sgNax sinhx_sgNat
                                                of
                                                dt3_sgNaA
                                                { __DEFAULT ->
                                                      Data.Complex.$w$c/
                                                          w_sgNam
                                                          dt_sgNav
                                                          dt1_sgNay
                                                          dt2_sgNaz
                                                          dt3_sgNaA;
                                                };
                                          };
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$ctanh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNaB w1_sgNaC]
        case w1_sgNaC of {
          Data.Complex.:+ ww1_sgNaE [Occ=Once] ww2_sgNaF [Occ=Once] ->
              case Data.Complex.$w$ctanh w_sgNaB ww1_sgNaE ww2_sgNaF of {
                (#,#) ww4_sgNaH [Occ=Once] ww5_sgNaI [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNaH ww5_sgNaI];
              };
        };

Data.Complex.$w$s$cacosh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNaJ ww1_sgNaK]
        case plusFloat# [ww_sgNaJ 1.0#] of sat_sgNaL {
          __DEFAULT ->
              case Data.Complex.$w$s$csqrt1 sat_sgNaL ww1_sgNaK of {
                (#,#) ww3_sgNaN [Occ=Once!] ww4_sgNaO [Occ=Once!] ->
                    case ww4_sgNaO of {
                      GHC.Types.F# x_sgNaQ ->
                          case ww3_sgNaN of {
                            GHC.Types.F# x1_sgNaS ->
                                case minusFloat# [ww_sgNaJ 1.0#] of sat_sgNaT {
                                  __DEFAULT ->
                                      case Data.Complex.$w$s$csqrt1 sat_sgNaT ww1_sgNaK of {
                                        (#,#) ww6_sgNaV [Occ=Once!] ww7_sgNaW [Occ=Once!] ->
                                            case ww7_sgNaW of {
                                              GHC.Types.F# y_sgNaY ->
                                                  case ww6_sgNaV of {
                                                    GHC.Types.F# y1_sgNb0 ->
                                                        case
                                                            timesFloat# [x_sgNaQ y1_sgNb0]
                                                        of
                                                        sat_sgNb3
                                                        { __DEFAULT ->
                                                              case
                                                                  timesFloat# [x1_sgNaS y_sgNaY]
                                                              of
                                                              sat_sgNb2
                                                              { __DEFAULT ->
                                                                    case
                                                                        plusFloat# [sat_sgNb2
                                                                                    sat_sgNb3]
                                                                    of
                                                                    sat_sgNb4
                                                                    { __DEFAULT ->
                                                                          case
                                                                              plusFloat# [ww1_sgNaK
                                                                                          sat_sgNb4]
                                                                          of
                                                                          ww8_sgNb1 [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    timesFloat# [x_sgNaQ
                                                                                                 y_sgNaY]
                                                                                of
                                                                                sat_sgNb7
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          timesFloat# [x1_sgNaS
                                                                                                       y1_sgNb0]
                                                                                      of
                                                                                      sat_sgNb6
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                minusFloat# [sat_sgNb6
                                                                                                             sat_sgNb7]
                                                                                            of
                                                                                            sat_sgNb8
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      plusFloat# [ww_sgNaJ
                                                                                                                  sat_sgNb8]
                                                                                                  of
                                                                                                  ww9_sgNb5 [Dmd=<S,U>]
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$smagnitude1
                                                                                                                ww9_sgNb5
                                                                                                                ww8_sgNb1
                                                                                                        of
                                                                                                        ww10_sgNb9
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  logFloat# [ww10_sgNb9]
                                                                                                              of
                                                                                                              wild4_sgNba
                                                                                                              { __DEFAULT ->
                                                                                                                    case
                                                                                                                        Data.Complex.$w$sphase1
                                                                                                                            ww9_sgNb5
                                                                                                                            ww8_sgNb1
                                                                                                                    of
                                                                                                                    ww11_sgNbb
                                                                                                                    { __DEFAULT ->
                                                                                                                          let {
                                                                                                                            sat_sgNbd [Occ=Once]
                                                                                                                              :: GHC.Types.Float
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.F#! [ww11_sgNbb]; } in
                                                                                                                          let {
                                                                                                                            sat_sgNbc [Occ=Once]
                                                                                                                              :: GHC.Types.Float
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.F#! [wild4_sgNba];
                                                                                                                          } in 
                                                                                                                            (#,#) [sat_sgNbc
                                                                                                                                   sat_sgNbd];
                                                                                                                    };
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacosh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNbe]
        case w_sgNbe of {
          Data.Complex.:+ ww1_sgNbg [Occ=Once!] ww2_sgNbh [Occ=Once!] ->
              case ww1_sgNbg of {
                GHC.Types.F# ww4_sgNbj [Occ=Once] ->
                    case ww2_sgNbh of {
                      GHC.Types.F# ww6_sgNbl [Occ=Once] ->
                          case Data.Complex.$w$s$cacosh1 ww4_sgNbj ww6_sgNbl of {
                            (#,#) ww8_sgNbn [Occ=Once] ww9_sgNbo [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNbn ww9_sgNbo];
                          };
                    };
              };
        };

Data.Complex.$w$s$cacosh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNbp ww1_sgNbq]
        case +## [ww_sgNbp 1.0##] of sat_sgNbr {
          __DEFAULT ->
              case Data.Complex.$w$s$csqrt sat_sgNbr ww1_sgNbq of {
                (#,#) ww3_sgNbt [Occ=Once!] ww4_sgNbu [Occ=Once!] ->
                    case ww4_sgNbu of {
                      GHC.Types.D# x_sgNbw ->
                          case ww3_sgNbt of {
                            GHC.Types.D# x1_sgNby ->
                                case -## [ww_sgNbp 1.0##] of sat_sgNbz {
                                  __DEFAULT ->
                                      case Data.Complex.$w$s$csqrt sat_sgNbz ww1_sgNbq of {
                                        (#,#) ww6_sgNbB [Occ=Once!] ww7_sgNbC [Occ=Once!] ->
                                            case ww7_sgNbC of {
                                              GHC.Types.D# y_sgNbE ->
                                                  case ww6_sgNbB of {
                                                    GHC.Types.D# y1_sgNbG ->
                                                        case *## [x_sgNbw y1_sgNbG] of sat_sgNbJ {
                                                          __DEFAULT ->
                                                              case
                                                                  *## [x1_sgNby y_sgNbE]
                                                              of
                                                              sat_sgNbI
                                                              { __DEFAULT ->
                                                                    case
                                                                        +## [sat_sgNbI sat_sgNbJ]
                                                                    of
                                                                    sat_sgNbK
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +## [ww1_sgNbq
                                                                                   sat_sgNbK]
                                                                          of
                                                                          ww8_sgNbH [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    *## [x_sgNbw
                                                                                         y_sgNbE]
                                                                                of
                                                                                sat_sgNbN
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          *## [x1_sgNby
                                                                                               y1_sgNbG]
                                                                                      of
                                                                                      sat_sgNbM
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                -## [sat_sgNbM
                                                                                                     sat_sgNbN]
                                                                                            of
                                                                                            sat_sgNbO
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      +## [ww_sgNbp
                                                                                                           sat_sgNbO]
                                                                                                  of
                                                                                                  ww9_sgNbL [Dmd=<S,U>]
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$smagnitude
                                                                                                                ww9_sgNbL
                                                                                                                ww8_sgNbH
                                                                                                        of
                                                                                                        ww10_sgNbP
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  logDouble# [ww10_sgNbP]
                                                                                                              of
                                                                                                              wild4_sgNbQ
                                                                                                              { __DEFAULT ->
                                                                                                                    case
                                                                                                                        Data.Complex.$w$sphase
                                                                                                                            ww9_sgNbL
                                                                                                                            ww8_sgNbH
                                                                                                                    of
                                                                                                                    ww11_sgNbR
                                                                                                                    { __DEFAULT ->
                                                                                                                          let {
                                                                                                                            sat_sgNbT [Occ=Once]
                                                                                                                              :: GHC.Types.Double
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.D#! [ww11_sgNbR]; } in
                                                                                                                          let {
                                                                                                                            sat_sgNbS [Occ=Once]
                                                                                                                              :: GHC.Types.Double
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.D#! [wild4_sgNbQ];
                                                                                                                          } in 
                                                                                                                            (#,#) [sat_sgNbS
                                                                                                                                   sat_sgNbT];
                                                                                                                    };
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacosh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNbU]
        case w_sgNbU of {
          Data.Complex.:+ ww1_sgNbW [Occ=Once!] ww2_sgNbX [Occ=Once!] ->
              case ww1_sgNbW of {
                GHC.Types.D# ww4_sgNbZ [Occ=Once] ->
                    case ww2_sgNbX of {
                      GHC.Types.D# ww6_sgNc1 [Occ=Once] ->
                          case Data.Complex.$w$s$cacosh ww4_sgNbZ ww6_sgNc1 of {
                            (#,#) ww8_sgNc3 [Occ=Once] ww9_sgNc4 [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNc3 ww9_sgNc4];
                          };
                    };
              };
        };

Data.Complex.$w$cacosh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNc5 ww_sgNc6 ww1_sgNc7]
        case
            Data.Complex.$w$cfromInteger
                w_sgNc5 Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww3_sgNc9 ww4_sgNca ->
              case
                  Data.Complex.$w$c+ w_sgNc5 ww_sgNc6 ww1_sgNc7 ww3_sgNc9 ww4_sgNca
              of
              { (#,#) ww6_sgNcc [Occ=Once] ww7_sgNcd [Occ=Once] ->
                    case Data.Complex.$w$csqrt w_sgNc5 ww6_sgNcc ww7_sgNcd of {
                      (#,#) ww9_sgNcf [Occ=Once] ww10_sgNcg [Occ=Once] ->
                          case
                              Data.Complex.$w$c- w_sgNc5 ww_sgNc6 ww1_sgNc7 ww3_sgNc9 ww4_sgNca
                          of
                          { (#,#) ww12_sgNci [Occ=Once] ww13_sgNcj [Occ=Once] ->
                                case Data.Complex.$w$csqrt w_sgNc5 ww12_sgNci ww13_sgNcj of {
                                  (#,#) ww15_sgNcl [Occ=Once] ww16_sgNcm [Occ=Once] ->
                                      case
                                          Data.Complex.$w$c*
                                              w_sgNc5 ww9_sgNcf ww10_sgNcg ww15_sgNcl ww16_sgNcm
                                      of
                                      { (#,#) ww18_sgNco [Occ=Once] ww19_sgNcp [Occ=Once] ->
                                            case
                                                Data.Complex.$w$c+
                                                    w_sgNc5 ww_sgNc6 ww1_sgNc7 ww18_sgNco ww19_sgNcp
                                            of
                                            { (#,#) ww21_sgNcr [Occ=Once] ww22_sgNcs [Occ=Once] ->
                                                  Data.Complex.$w$clog
                                                      w_sgNc5 ww21_sgNcr ww22_sgNcs;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cacosh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNct w1_sgNcu]
        case w1_sgNcu of {
          Data.Complex.:+ ww1_sgNcw [Occ=Once] ww2_sgNcx [Occ=Once] ->
              case Data.Complex.$w$cacosh w_sgNct ww1_sgNcw ww2_sgNcx of {
                (#,#) ww4_sgNcz [Occ=Once] ww5_sgNcA [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNcz ww5_sgNcA];
              };
        };

Data.Complex.$w$s$casinh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNcB ww1_sgNcC]
        case timesFloat# [ww1_sgNcC ww_sgNcB] of sat_sgNcI {
          __DEFAULT ->
              case timesFloat# [ww_sgNcB ww1_sgNcC] of sat_sgNcH {
                __DEFAULT ->
                    case plusFloat# [sat_sgNcH sat_sgNcI] of sat_sgNcJ {
                      __DEFAULT ->
                          case timesFloat# [ww1_sgNcC ww1_sgNcC] of sat_sgNcE {
                            __DEFAULT ->
                                case timesFloat# [ww_sgNcB ww_sgNcB] of sat_sgNcD {
                                  __DEFAULT ->
                                      case minusFloat# [sat_sgNcD sat_sgNcE] of sat_sgNcF {
                                        __DEFAULT ->
                                            case plusFloat# [1.0# sat_sgNcF] of sat_sgNcG {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt1 sat_sgNcG sat_sgNcJ
                                                  of
                                                  { (#,#) ww3_sgNcL [Occ=Once!]
                                                          ww4_sgNcM [Occ=Once!] ->
                                                        case ww3_sgNcL of {
                                                          GHC.Types.F# y_sgNcO [Occ=Once] ->
                                                              case ww4_sgNcM of {
                                                                GHC.Types.F# y1_sgNcQ [Occ=Once] ->
                                                                    case
                                                                        plusFloat# [ww1_sgNcC
                                                                                    y1_sgNcQ]
                                                                    of
                                                                    ww5_sgNcR [Dmd=<S,U>]
                                                                    { __DEFAULT ->
                                                                          case
                                                                              plusFloat# [ww_sgNcB
                                                                                          y_sgNcO]
                                                                          of
                                                                          ww6_sgNcS [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$smagnitude1
                                                                                        ww6_sgNcS
                                                                                        ww5_sgNcR
                                                                                of
                                                                                ww7_sgNcT
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          logFloat# [ww7_sgNcT]
                                                                                      of
                                                                                      wild3_sgNcU
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$sphase1
                                                                                                    ww6_sgNcS
                                                                                                    ww5_sgNcR
                                                                                            of
                                                                                            ww8_sgNcV
                                                                                            { __DEFAULT ->
                                                                                                  let {
                                                                                                    sat_sgNcX [Occ=Once]
                                                                                                      :: GHC.Types.Float
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.F#! [ww8_sgNcV]; } in
                                                                                                  let {
                                                                                                    sat_sgNcW [Occ=Once]
                                                                                                      :: GHC.Types.Float
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.F#! [wild3_sgNcU];
                                                                                                  } in 
                                                                                                    (#,#) [sat_sgNcW
                                                                                                           sat_sgNcX];
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casinh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNcY]
        case w_sgNcY of {
          Data.Complex.:+ ww1_sgNd0 [Occ=Once!] ww2_sgNd1 [Occ=Once!] ->
              case ww1_sgNd0 of {
                GHC.Types.F# ww4_sgNd3 [Occ=Once] ->
                    case ww2_sgNd1 of {
                      GHC.Types.F# ww6_sgNd5 [Occ=Once] ->
                          case Data.Complex.$w$s$casinh1 ww4_sgNd3 ww6_sgNd5 of {
                            (#,#) ww8_sgNd7 [Occ=Once] ww9_sgNd8 [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNd7 ww9_sgNd8];
                          };
                    };
              };
        };

Data.Complex.$w$s$casinh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNd9 ww1_sgNda]
        case *## [ww1_sgNda ww_sgNd9] of sat_sgNdg {
          __DEFAULT ->
              case *## [ww_sgNd9 ww1_sgNda] of sat_sgNdf {
                __DEFAULT ->
                    case +## [sat_sgNdf sat_sgNdg] of sat_sgNdh {
                      __DEFAULT ->
                          case *## [ww1_sgNda ww1_sgNda] of sat_sgNdc {
                            __DEFAULT ->
                                case *## [ww_sgNd9 ww_sgNd9] of sat_sgNdb {
                                  __DEFAULT ->
                                      case -## [sat_sgNdb sat_sgNdc] of sat_sgNdd {
                                        __DEFAULT ->
                                            case +## [1.0## sat_sgNdd] of sat_sgNde {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt sat_sgNde sat_sgNdh
                                                  of
                                                  { (#,#) ww3_sgNdj [Occ=Once!]
                                                          ww4_sgNdk [Occ=Once!] ->
                                                        case ww3_sgNdj of {
                                                          GHC.Types.D# y_sgNdm [Occ=Once] ->
                                                              case ww4_sgNdk of {
                                                                GHC.Types.D# y1_sgNdo [Occ=Once] ->
                                                                    case
                                                                        +## [ww1_sgNda y1_sgNdo]
                                                                    of
                                                                    ww5_sgNdp [Dmd=<S,U>]
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +## [ww_sgNd9 y_sgNdm]
                                                                          of
                                                                          ww6_sgNdq [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$smagnitude
                                                                                        ww6_sgNdq
                                                                                        ww5_sgNdp
                                                                                of
                                                                                ww7_sgNdr
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          logDouble# [ww7_sgNdr]
                                                                                      of
                                                                                      wild3_sgNds
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$sphase
                                                                                                    ww6_sgNdq
                                                                                                    ww5_sgNdp
                                                                                            of
                                                                                            ww8_sgNdt
                                                                                            { __DEFAULT ->
                                                                                                  let {
                                                                                                    sat_sgNdv [Occ=Once]
                                                                                                      :: GHC.Types.Double
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.D#! [ww8_sgNdt]; } in
                                                                                                  let {
                                                                                                    sat_sgNdu [Occ=Once]
                                                                                                      :: GHC.Types.Double
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.D#! [wild3_sgNds];
                                                                                                  } in 
                                                                                                    (#,#) [sat_sgNdu
                                                                                                           sat_sgNdv];
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casinh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNdw]
        case w_sgNdw of {
          Data.Complex.:+ ww1_sgNdy [Occ=Once!] ww2_sgNdz [Occ=Once!] ->
              case ww1_sgNdy of {
                GHC.Types.D# ww4_sgNdB [Occ=Once] ->
                    case ww2_sgNdz of {
                      GHC.Types.D# ww6_sgNdD [Occ=Once] ->
                          case Data.Complex.$w$s$casinh ww4_sgNdB ww6_sgNdD of {
                            (#,#) ww8_sgNdF [Occ=Once] ww9_sgNdG [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNdF ww9_sgNdG];
                          };
                    };
              };
        };

Data.Complex.$w$casinh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),1*C1(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNdH ww_sgNdI ww1_sgNdJ]
        case
            Data.Complex.$w$cfromInteger
                w_sgNdH Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww3_sgNdL [Occ=Once] ww4_sgNdM [Occ=Once] ->
              case
                  Data.Complex.$w$c* w_sgNdH ww_sgNdI ww1_sgNdJ ww_sgNdI ww1_sgNdJ
              of
              { (#,#) ww6_sgNdO [Occ=Once] ww7_sgNdP [Occ=Once] ->
                    case
                        Data.Complex.$w$c+ w_sgNdH ww3_sgNdL ww4_sgNdM ww6_sgNdO ww7_sgNdP
                    of
                    { (#,#) ww9_sgNdR [Occ=Once] ww10_sgNdS [Occ=Once] ->
                          case Data.Complex.$w$csqrt w_sgNdH ww9_sgNdR ww10_sgNdS of {
                            (#,#) ww12_sgNdU [Occ=Once] ww13_sgNdV [Occ=Once] ->
                                case
                                    Data.Complex.$w$c+
                                        w_sgNdH ww_sgNdI ww1_sgNdJ ww12_sgNdU ww13_sgNdV
                                of
                                { (#,#) ww15_sgNdX [Occ=Once] ww16_sgNdY [Occ=Once] ->
                                      Data.Complex.$w$clog w_sgNdH ww15_sgNdX ww16_sgNdY;
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$casinh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNdZ w1_sgNe0]
        case w1_sgNe0 of {
          Data.Complex.:+ ww1_sgNe2 [Occ=Once] ww2_sgNe3 [Occ=Once] ->
              case Data.Complex.$w$casinh w_sgNdZ ww1_sgNe2 ww2_sgNe3 of {
                (#,#) ww4_sgNe5 [Occ=Once] ww5_sgNe6 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNe5 ww5_sgNe6];
              };
        };

Data.Complex.$w$s$catan1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNe7 ww1_sgNe8]
        case timesFloat# [ww1_sgNe8 ww_sgNe7] of sat_sgNee {
          __DEFAULT ->
              case timesFloat# [ww_sgNe7 ww1_sgNe8] of sat_sgNed {
                __DEFAULT ->
                    case plusFloat# [sat_sgNed sat_sgNee] of sat_sgNef {
                      __DEFAULT ->
                          case timesFloat# [ww1_sgNe8 ww1_sgNe8] of sat_sgNea {
                            __DEFAULT ->
                                case timesFloat# [ww_sgNe7 ww_sgNe7] of sat_sgNe9 {
                                  __DEFAULT ->
                                      case minusFloat# [sat_sgNe9 sat_sgNea] of sat_sgNeb {
                                        __DEFAULT ->
                                            case plusFloat# [1.0# sat_sgNeb] of sat_sgNec {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt1 sat_sgNec sat_sgNef
                                                  of
                                                  { (#,#) ww3_sgNeh [Occ=Once!]
                                                          ww4_sgNei [Occ=Once!] ->
                                                        case ww3_sgNeh of {
                                                          GHC.Types.F# ww6_sgNek [Occ=Once] ->
                                                              case ww4_sgNei of {
                                                                GHC.Types.F# ww8_sgNem [Occ=Once] ->
                                                                    case
                                                                        minusFloat# [1.0# ww1_sgNe8]
                                                                    of
                                                                    sat_sgNen
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/1
                                                                                  sat_sgNen
                                                                                  ww_sgNe7
                                                                                  ww6_sgNek
                                                                                  ww8_sgNem
                                                                          of
                                                                          { (#,#) ww10_sgNep [Occ=Once!]
                                                                                  ww11_sgNeq [Occ=Once!] ->
                                                                                case ww10_sgNep of {
                                                                                  GHC.Types.F# ww13_sgNes ->
                                                                                      case
                                                                                          ww11_sgNeq
                                                                                      of
                                                                                      { GHC.Types.F# ww15_sgNeu ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude1
                                                                                                    ww13_sgNes
                                                                                                    ww15_sgNeu
                                                                                            of
                                                                                            ww16_sgNev
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logFloat# [ww16_sgNev]
                                                                                                  of
                                                                                                  wild1_sgNew
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase1
                                                                                                                ww13_sgNes
                                                                                                                ww15_sgNeu
                                                                                                        of
                                                                                                        ww17_sgNex
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateFloat# [wild1_sgNew]
                                                                                                              of
                                                                                                              sat_sgNez
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgNeA [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [sat_sgNez]; } in
                                                                                                                    let {
                                                                                                                      sat_sgNey [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [ww17_sgNex];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgNey
                                                                                                                             sat_sgNeA];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catan1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNeB]
        case w_sgNeB of {
          Data.Complex.:+ ww1_sgNeD [Occ=Once!] ww2_sgNeE [Occ=Once!] ->
              case ww1_sgNeD of {
                GHC.Types.F# ww4_sgNeG [Occ=Once] ->
                    case ww2_sgNeE of {
                      GHC.Types.F# ww6_sgNeI [Occ=Once] ->
                          case Data.Complex.$w$s$catan1 ww4_sgNeG ww6_sgNeI of {
                            (#,#) ww8_sgNeK [Occ=Once] ww9_sgNeL [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNeK ww9_sgNeL];
                          };
                    };
              };
        };

Data.Complex.$w$s$catan [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNeM ww1_sgNeN]
        case *## [ww1_sgNeN ww_sgNeM] of sat_sgNeT {
          __DEFAULT ->
              case *## [ww_sgNeM ww1_sgNeN] of sat_sgNeS {
                __DEFAULT ->
                    case +## [sat_sgNeS sat_sgNeT] of sat_sgNeU {
                      __DEFAULT ->
                          case *## [ww1_sgNeN ww1_sgNeN] of sat_sgNeP {
                            __DEFAULT ->
                                case *## [ww_sgNeM ww_sgNeM] of sat_sgNeO {
                                  __DEFAULT ->
                                      case -## [sat_sgNeO sat_sgNeP] of sat_sgNeQ {
                                        __DEFAULT ->
                                            case +## [1.0## sat_sgNeQ] of sat_sgNeR {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt sat_sgNeR sat_sgNeU
                                                  of
                                                  { (#,#) ww3_sgNeW [Occ=Once!]
                                                          ww4_sgNeX [Occ=Once!] ->
                                                        case ww3_sgNeW of {
                                                          GHC.Types.D# ww6_sgNeZ [Occ=Once] ->
                                                              case ww4_sgNeX of {
                                                                GHC.Types.D# ww8_sgNf1 [Occ=Once] ->
                                                                    case
                                                                        -## [1.0## ww1_sgNeN]
                                                                    of
                                                                    sat_sgNf2
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/
                                                                                  sat_sgNf2
                                                                                  ww_sgNeM
                                                                                  ww6_sgNeZ
                                                                                  ww8_sgNf1
                                                                          of
                                                                          { (#,#) ww10_sgNf4 [Occ=Once!]
                                                                                  ww11_sgNf5 [Occ=Once!] ->
                                                                                case ww10_sgNf4 of {
                                                                                  GHC.Types.D# ww13_sgNf7 ->
                                                                                      case
                                                                                          ww11_sgNf5
                                                                                      of
                                                                                      { GHC.Types.D# ww15_sgNf9 ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude
                                                                                                    ww13_sgNf7
                                                                                                    ww15_sgNf9
                                                                                            of
                                                                                            ww16_sgNfa
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logDouble# [ww16_sgNfa]
                                                                                                  of
                                                                                                  wild1_sgNfb
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase
                                                                                                                ww13_sgNf7
                                                                                                                ww15_sgNf9
                                                                                                        of
                                                                                                        ww17_sgNfc
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateDouble# [wild1_sgNfb]
                                                                                                              of
                                                                                                              sat_sgNfe
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgNff [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [sat_sgNfe]; } in
                                                                                                                    let {
                                                                                                                      sat_sgNfd [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [ww17_sgNfc];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgNfd
                                                                                                                             sat_sgNff];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catan [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNfg]
        case w_sgNfg of {
          Data.Complex.:+ ww1_sgNfi [Occ=Once!] ww2_sgNfj [Occ=Once!] ->
              case ww1_sgNfi of {
                GHC.Types.D# ww4_sgNfl [Occ=Once] ->
                    case ww2_sgNfj of {
                      GHC.Types.D# ww6_sgNfn [Occ=Once] ->
                          case Data.Complex.$w$s$catan ww4_sgNfl ww6_sgNfn of {
                            (#,#) ww8_sgNfp [Occ=Once] ww9_sgNfq [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNfp ww9_sgNfq];
                          };
                    };
              };
        };

Data.Complex.$w$catan [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNfr ww_sgNfs ww1_sgNft]
        case
            GHC.Float.$p1RealFloat w_sgNfr
        of
        $dRealFrac_sgNfu [Dmd=<S(S(S(LC(C(S))LC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U)),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgNfu
              of
              $dReal_sgNfv [Dmd=<S(S(LC(C(S))LC(S)LLL)LL),1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U)),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgNfv
                    of
                    $dNum_sgNfw [Dmd=<S(LC(C(S))LC(S)LLL),U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U))>]
                    { __DEFAULT ->
                          let {
                            sat_sgNfx [Occ=Once] :: a_sgxKN
                            [LclId] =
                                [$dNum_sgNfw] \u []
                                    GHC.Num.fromInteger
                                        $dNum_sgNfw Data.Complex.$fFloatingComplex19;
                          } in 
                            case GHC.Num.- $dNum_sgNfw sat_sgNfx ww1_sgNft of dt_sgNfy {
                              __DEFAULT ->
                                  case
                                      Data.Complex.$w$cfromInteger
                                          w_sgNfr Data.Complex.$fFloatingComplex19
                                  of
                                  { (#,#) ww3_sgNfA [Occ=Once] ww4_sgNfB [Occ=Once] ->
                                        case
                                            Data.Complex.$w$c*
                                                w_sgNfr ww_sgNfs ww1_sgNft ww_sgNfs ww1_sgNft
                                        of
                                        { (#,#) ww6_sgNfD [Occ=Once] ww7_sgNfE [Occ=Once] ->
                                              case
                                                  Data.Complex.$w$c+
                                                      w_sgNfr
                                                      ww3_sgNfA
                                                      ww4_sgNfB
                                                      ww6_sgNfD
                                                      ww7_sgNfE
                                              of
                                              { (#,#) ww9_sgNfG [Occ=Once] ww10_sgNfH [Occ=Once] ->
                                                    case
                                                        Data.Complex.$w$csqrt
                                                            w_sgNfr ww9_sgNfG ww10_sgNfH
                                                    of
                                                    { (#,#) ww12_sgNfJ [Occ=Once]
                                                            ww13_sgNfK [Occ=Once] ->
                                                          case
                                                              Data.Complex.$w$c/
                                                                  w_sgNfr
                                                                  dt_sgNfy
                                                                  ww_sgNfs
                                                                  ww12_sgNfJ
                                                                  ww13_sgNfK
                                                          of
                                                          { (#,#) ww15_sgNfM ww16_sgNfN ->
                                                                let {
                                                                  sat_sgNfP [Occ=Once] :: a_sgxKN
                                                                  [LclId] =
                                                                      [w_sgNfr
                                                                       ww15_sgNfM
                                                                       ww16_sgNfN] \u []
                                                                          Data.Complex.$wmagnitude
                                                                              w_sgNfr
                                                                              ww15_sgNfM
                                                                              ww16_sgNfN;
                                                                } in 
                                                                  case
                                                                      GHC.Float.$p2RealFloat w_sgNfr
                                                                  of
                                                                  sat_sgNfO
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Float.log
                                                                                sat_sgNfO sat_sgNfP
                                                                        of
                                                                        dt1_sgNfQ
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  Data.Complex.$wphase
                                                                                      w_sgNfr
                                                                                      ww15_sgNfM
                                                                                      ww16_sgNfN
                                                                              of
                                                                              dt2_sgNfR
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        GHC.Num.negate
                                                                                            $dNum_sgNfw
                                                                                            dt1_sgNfQ
                                                                                    of
                                                                                    dt3_sgNfS
                                                                                    { __DEFAULT ->
                                                                                          (#,#) [dt2_sgNfR
                                                                                                 dt3_sgNfS];
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                          };
                                                    };
                                              };
                                        };
                                  };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$catan [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNfT w1_sgNfU]
        case w1_sgNfU of {
          Data.Complex.:+ ww1_sgNfW [Occ=Once] ww2_sgNfX [Occ=Once] ->
              case Data.Complex.$w$catan w_sgNfT ww1_sgNfW ww2_sgNfX of {
                (#,#) ww4_sgNfZ [Occ=Once] ww5_sgNg0 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNfZ ww5_sgNg0];
              };
        };

Data.Complex.$w$s$cacos1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNg1 ww1_sgNg2]
        case timesFloat# [ww1_sgNg2 ww_sgNg1] of sat_sgNg8 {
          __DEFAULT ->
              case timesFloat# [ww_sgNg1 ww1_sgNg2] of sat_sgNg7 {
                __DEFAULT ->
                    case plusFloat# [sat_sgNg7 sat_sgNg8] of sat_sgNg9 {
                      __DEFAULT ->
                          case minusFloat# [0.0# sat_sgNg9] of sat_sgNga {
                            __DEFAULT ->
                                case timesFloat# [ww1_sgNg2 ww1_sgNg2] of sat_sgNg4 {
                                  __DEFAULT ->
                                      case timesFloat# [ww_sgNg1 ww_sgNg1] of sat_sgNg3 {
                                        __DEFAULT ->
                                            case minusFloat# [sat_sgNg3 sat_sgNg4] of sat_sgNg5 {
                                              __DEFAULT ->
                                                  case minusFloat# [1.0# sat_sgNg5] of sat_sgNg6 {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt1
                                                                sat_sgNg6 sat_sgNga
                                                        of
                                                        { (#,#) ww3_sgNgc [Occ=Once!]
                                                                ww4_sgNgd [Occ=Once!] ->
                                                              case ww4_sgNgd of {
                                                                GHC.Types.F# x_sgNgf [Occ=Once] ->
                                                                    case ww3_sgNgc of {
                                                                      GHC.Types.F# y_sgNgh [Occ=Once] ->
                                                                          case
                                                                              plusFloat# [ww1_sgNg2
                                                                                          y_sgNgh]
                                                                          of
                                                                          ww5_sgNgi [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateFloat# [x_sgNgf]
                                                                                of
                                                                                sat_sgNgk
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          plusFloat# [ww_sgNg1
                                                                                                      sat_sgNgk]
                                                                                      of
                                                                                      ww6_sgNgj [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude1
                                                                                                    ww6_sgNgj
                                                                                                    ww5_sgNgi
                                                                                            of
                                                                                            ww7_sgNgl
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logFloat# [ww7_sgNgl]
                                                                                                  of
                                                                                                  wild2_sgNgm
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase1
                                                                                                                ww6_sgNgj
                                                                                                                ww5_sgNgi
                                                                                                        of
                                                                                                        ww8_sgNgn
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateFloat# [wild2_sgNgm]
                                                                                                              of
                                                                                                              sat_sgNgp
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgNgq [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [sat_sgNgp]; } in
                                                                                                                    let {
                                                                                                                      sat_sgNgo [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [ww8_sgNgn];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgNgo
                                                                                                                             sat_sgNgq];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacos1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNgr]
        case w_sgNgr of {
          Data.Complex.:+ ww1_sgNgt [Occ=Once!] ww2_sgNgu [Occ=Once!] ->
              case ww1_sgNgt of {
                GHC.Types.F# ww4_sgNgw [Occ=Once] ->
                    case ww2_sgNgu of {
                      GHC.Types.F# ww6_sgNgy [Occ=Once] ->
                          case Data.Complex.$w$s$cacos1 ww4_sgNgw ww6_sgNgy of {
                            (#,#) ww8_sgNgA [Occ=Once] ww9_sgNgB [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNgA ww9_sgNgB];
                          };
                    };
              };
        };

Data.Complex.$w$s$cacos [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNgC ww1_sgNgD]
        case *## [ww1_sgNgD ww_sgNgC] of sat_sgNgJ {
          __DEFAULT ->
              case *## [ww_sgNgC ww1_sgNgD] of sat_sgNgI {
                __DEFAULT ->
                    case +## [sat_sgNgI sat_sgNgJ] of sat_sgNgK {
                      __DEFAULT ->
                          case -## [0.0## sat_sgNgK] of sat_sgNgL {
                            __DEFAULT ->
                                case *## [ww1_sgNgD ww1_sgNgD] of sat_sgNgF {
                                  __DEFAULT ->
                                      case *## [ww_sgNgC ww_sgNgC] of sat_sgNgE {
                                        __DEFAULT ->
                                            case -## [sat_sgNgE sat_sgNgF] of sat_sgNgG {
                                              __DEFAULT ->
                                                  case -## [1.0## sat_sgNgG] of sat_sgNgH {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt
                                                                sat_sgNgH sat_sgNgL
                                                        of
                                                        { (#,#) ww3_sgNgN [Occ=Once!]
                                                                ww4_sgNgO [Occ=Once!] ->
                                                              case ww4_sgNgO of {
                                                                GHC.Types.D# x_sgNgQ [Occ=Once] ->
                                                                    case ww3_sgNgN of {
                                                                      GHC.Types.D# y_sgNgS [Occ=Once] ->
                                                                          case
                                                                              +## [ww1_sgNgD
                                                                                   y_sgNgS]
                                                                          of
                                                                          ww5_sgNgT [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateDouble# [x_sgNgQ]
                                                                                of
                                                                                sat_sgNgV
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          +## [ww_sgNgC
                                                                                               sat_sgNgV]
                                                                                      of
                                                                                      ww6_sgNgU [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude
                                                                                                    ww6_sgNgU
                                                                                                    ww5_sgNgT
                                                                                            of
                                                                                            ww7_sgNgW
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logDouble# [ww7_sgNgW]
                                                                                                  of
                                                                                                  wild2_sgNgX
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase
                                                                                                                ww6_sgNgU
                                                                                                                ww5_sgNgT
                                                                                                        of
                                                                                                        ww8_sgNgY
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateDouble# [wild2_sgNgX]
                                                                                                              of
                                                                                                              sat_sgNh0
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgNh1 [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [sat_sgNh0]; } in
                                                                                                                    let {
                                                                                                                      sat_sgNgZ [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [ww8_sgNgY];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgNgZ
                                                                                                                             sat_sgNh1];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacos [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNh2]
        case w_sgNh2 of {
          Data.Complex.:+ ww1_sgNh4 [Occ=Once!] ww2_sgNh5 [Occ=Once!] ->
              case ww1_sgNh4 of {
                GHC.Types.D# ww4_sgNh7 [Occ=Once] ->
                    case ww2_sgNh5 of {
                      GHC.Types.D# ww6_sgNh9 [Occ=Once] ->
                          case Data.Complex.$w$s$cacos ww4_sgNh7 ww6_sgNh9 of {
                            (#,#) ww8_sgNhb [Occ=Once] ww9_sgNhc [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNhb ww9_sgNhc];
                          };
                    };
              };
        };

Data.Complex.$w$cacos [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNhd ww_sgNhe ww1_sgNhf]
        case
            Data.Complex.$w$cfromInteger
                w_sgNhd Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww3_sgNhh [Occ=Once] ww4_sgNhi [Occ=Once] ->
              case
                  Data.Complex.$w$c* w_sgNhd ww_sgNhe ww1_sgNhf ww_sgNhe ww1_sgNhf
              of
              { (#,#) ww6_sgNhk [Occ=Once] ww7_sgNhl [Occ=Once] ->
                    case
                        Data.Complex.$w$c- w_sgNhd ww3_sgNhh ww4_sgNhi ww6_sgNhk ww7_sgNhl
                    of
                    { (#,#) ww9_sgNhn [Occ=Once] ww10_sgNho [Occ=Once] ->
                          case Data.Complex.$w$csqrt w_sgNhd ww9_sgNhn ww10_sgNho of {
                            (#,#) ww12_sgNhq [Occ=Once] ww13_sgNhr [Occ=Once] ->
                                case
                                    GHC.Float.$p1RealFloat w_sgNhd
                                of
                                $dRealFrac_sgNhs [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
                                { __DEFAULT ->
                                      case
                                          GHC.Real.$p1RealFrac $dRealFrac_sgNhs
                                      of
                                      $dReal_sgNht [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
                                      { __DEFAULT ->
                                            case
                                                GHC.Real.$p1Real $dReal_sgNht
                                            of
                                            $dNum_sgNhu [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Num.negate $dNum_sgNhu ww13_sgNhr
                                                  of
                                                  dt_sgNhv
                                                  { __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$c+
                                                                w_sgNhd
                                                                ww_sgNhe
                                                                ww1_sgNhf
                                                                dt_sgNhv
                                                                ww12_sgNhq
                                                        of
                                                        { (#,#) ww15_sgNhx ww16_sgNhy ->
                                                              let {
                                                                sat_sgNhA [Occ=Once] :: a_sgxM9
                                                                [LclId] =
                                                                    [w_sgNhd
                                                                     ww15_sgNhx
                                                                     ww16_sgNhy] \u []
                                                                        Data.Complex.$wmagnitude
                                                                            w_sgNhd
                                                                            ww15_sgNhx
                                                                            ww16_sgNhy;
                                                              } in 
                                                                case
                                                                    GHC.Float.$p2RealFloat w_sgNhd
                                                                of
                                                                sat_sgNhz
                                                                { __DEFAULT ->
                                                                      case
                                                                          GHC.Float.log
                                                                              sat_sgNhz sat_sgNhA
                                                                      of
                                                                      dt1_sgNhB
                                                                      { __DEFAULT ->
                                                                            case
                                                                                Data.Complex.$wphase
                                                                                    w_sgNhd
                                                                                    ww15_sgNhx
                                                                                    ww16_sgNhy
                                                                            of
                                                                            dt2_sgNhC
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      GHC.Num.negate
                                                                                          $dNum_sgNhu
                                                                                          dt1_sgNhB
                                                                                  of
                                                                                  dt3_sgNhD
                                                                                  { __DEFAULT ->
                                                                                        (#,#) [dt2_sgNhC
                                                                                               dt3_sgNhD];
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cacos [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNhE w1_sgNhF]
        case w1_sgNhF of {
          Data.Complex.:+ ww1_sgNhH [Occ=Once] ww2_sgNhI [Occ=Once] ->
              case Data.Complex.$w$cacos w_sgNhE ww1_sgNhH ww2_sgNhI of {
                (#,#) ww4_sgNhK [Occ=Once] ww5_sgNhL [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNhK ww5_sgNhL];
              };
        };

Data.Complex.$w$s$casin1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNhM ww1_sgNhN]
        case timesFloat# [ww1_sgNhN ww_sgNhM] of sat_sgNhT {
          __DEFAULT ->
              case timesFloat# [ww_sgNhM ww1_sgNhN] of sat_sgNhS {
                __DEFAULT ->
                    case plusFloat# [sat_sgNhS sat_sgNhT] of sat_sgNhU {
                      __DEFAULT ->
                          case minusFloat# [0.0# sat_sgNhU] of sat_sgNhV {
                            __DEFAULT ->
                                case timesFloat# [ww1_sgNhN ww1_sgNhN] of sat_sgNhP {
                                  __DEFAULT ->
                                      case timesFloat# [ww_sgNhM ww_sgNhM] of sat_sgNhO {
                                        __DEFAULT ->
                                            case minusFloat# [sat_sgNhO sat_sgNhP] of sat_sgNhQ {
                                              __DEFAULT ->
                                                  case minusFloat# [1.0# sat_sgNhQ] of sat_sgNhR {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt1
                                                                sat_sgNhR sat_sgNhV
                                                        of
                                                        { (#,#) ww3_sgNhX [Occ=Once!]
                                                                ww4_sgNhY [Occ=Once!] ->
                                                              case ww3_sgNhX of {
                                                                GHC.Types.F# y_sgNi0 [Occ=Once] ->
                                                                    case ww4_sgNhY of {
                                                                      GHC.Types.F# y1_sgNi2 [Occ=Once] ->
                                                                          case
                                                                              plusFloat# [ww_sgNhM
                                                                                          y1_sgNi2]
                                                                          of
                                                                          ww5_sgNi3 [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateFloat# [ww1_sgNhN]
                                                                                of
                                                                                sat_sgNi5
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          plusFloat# [sat_sgNi5
                                                                                                      y_sgNi0]
                                                                                      of
                                                                                      ww6_sgNi4 [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude1
                                                                                                    ww6_sgNi4
                                                                                                    ww5_sgNi3
                                                                                            of
                                                                                            ww7_sgNi6
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logFloat# [ww7_sgNi6]
                                                                                                  of
                                                                                                  wild3_sgNi7
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase1
                                                                                                                ww6_sgNi4
                                                                                                                ww5_sgNi3
                                                                                                        of
                                                                                                        ww8_sgNi8
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateFloat# [wild3_sgNi7]
                                                                                                              of
                                                                                                              sat_sgNia
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgNib [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [sat_sgNia]; } in
                                                                                                                    let {
                                                                                                                      sat_sgNi9 [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [ww8_sgNi8];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgNi9
                                                                                                                             sat_sgNib];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casin1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNic]
        case w_sgNic of {
          Data.Complex.:+ ww1_sgNie [Occ=Once!] ww2_sgNif [Occ=Once!] ->
              case ww1_sgNie of {
                GHC.Types.F# ww4_sgNih [Occ=Once] ->
                    case ww2_sgNif of {
                      GHC.Types.F# ww6_sgNij [Occ=Once] ->
                          case Data.Complex.$w$s$casin1 ww4_sgNih ww6_sgNij of {
                            (#,#) ww8_sgNil [Occ=Once] ww9_sgNim [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNil ww9_sgNim];
                          };
                    };
              };
        };

Data.Complex.$w$s$casin [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNin ww1_sgNio]
        case *## [ww1_sgNio ww_sgNin] of sat_sgNiu {
          __DEFAULT ->
              case *## [ww_sgNin ww1_sgNio] of sat_sgNit {
                __DEFAULT ->
                    case +## [sat_sgNit sat_sgNiu] of sat_sgNiv {
                      __DEFAULT ->
                          case -## [0.0## sat_sgNiv] of sat_sgNiw {
                            __DEFAULT ->
                                case *## [ww1_sgNio ww1_sgNio] of sat_sgNiq {
                                  __DEFAULT ->
                                      case *## [ww_sgNin ww_sgNin] of sat_sgNip {
                                        __DEFAULT ->
                                            case -## [sat_sgNip sat_sgNiq] of sat_sgNir {
                                              __DEFAULT ->
                                                  case -## [1.0## sat_sgNir] of sat_sgNis {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt
                                                                sat_sgNis sat_sgNiw
                                                        of
                                                        { (#,#) ww3_sgNiy [Occ=Once!]
                                                                ww4_sgNiz [Occ=Once!] ->
                                                              case ww3_sgNiy of {
                                                                GHC.Types.D# y_sgNiB [Occ=Once] ->
                                                                    case ww4_sgNiz of {
                                                                      GHC.Types.D# y1_sgNiD [Occ=Once] ->
                                                                          case
                                                                              +## [ww_sgNin
                                                                                   y1_sgNiD]
                                                                          of
                                                                          ww5_sgNiE [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateDouble# [ww1_sgNio]
                                                                                of
                                                                                sat_sgNiG
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          +## [sat_sgNiG
                                                                                               y_sgNiB]
                                                                                      of
                                                                                      ww6_sgNiF [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude
                                                                                                    ww6_sgNiF
                                                                                                    ww5_sgNiE
                                                                                            of
                                                                                            ww7_sgNiH
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logDouble# [ww7_sgNiH]
                                                                                                  of
                                                                                                  wild3_sgNiI
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase
                                                                                                                ww6_sgNiF
                                                                                                                ww5_sgNiE
                                                                                                        of
                                                                                                        ww8_sgNiJ
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateDouble# [wild3_sgNiI]
                                                                                                              of
                                                                                                              sat_sgNiL
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgNiM [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [sat_sgNiL]; } in
                                                                                                                    let {
                                                                                                                      sat_sgNiK [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [ww8_sgNiJ];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgNiK
                                                                                                                             sat_sgNiM];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casin [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNiN]
        case w_sgNiN of {
          Data.Complex.:+ ww1_sgNiP [Occ=Once!] ww2_sgNiQ [Occ=Once!] ->
              case ww1_sgNiP of {
                GHC.Types.D# ww4_sgNiS [Occ=Once] ->
                    case ww2_sgNiQ of {
                      GHC.Types.D# ww6_sgNiU [Occ=Once] ->
                          case Data.Complex.$w$s$casin ww4_sgNiS ww6_sgNiU of {
                            (#,#) ww8_sgNiW [Occ=Once] ww9_sgNiX [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNiW ww9_sgNiX];
                          };
                    };
              };
        };

Data.Complex.$w$casin [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNiY ww_sgNiZ ww1_sgNj0]
        case
            GHC.Float.$p1RealFloat w_sgNiY
        of
        $dRealFrac_sgNj1 [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgNj1
              of
              $dReal_sgNj2 [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgNj2
                    of
                    $dNum_sgNj3 [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.negate $dNum_sgNj3 ww1_sgNj0 of dt_sgNj4 {
                            __DEFAULT ->
                                case
                                    Data.Complex.$w$cfromInteger
                                        w_sgNiY Data.Complex.$fFloatingComplex19
                                of
                                { (#,#) ww3_sgNj6 [Occ=Once] ww4_sgNj7 [Occ=Once] ->
                                      case
                                          Data.Complex.$w$c*
                                              w_sgNiY ww_sgNiZ ww1_sgNj0 ww_sgNiZ ww1_sgNj0
                                      of
                                      { (#,#) ww6_sgNj9 [Occ=Once] ww7_sgNja [Occ=Once] ->
                                            case
                                                Data.Complex.$w$c-
                                                    w_sgNiY ww3_sgNj6 ww4_sgNj7 ww6_sgNj9 ww7_sgNja
                                            of
                                            { (#,#) ww9_sgNjc [Occ=Once] ww10_sgNjd [Occ=Once] ->
                                                  case
                                                      Data.Complex.$w$csqrt
                                                          w_sgNiY ww9_sgNjc ww10_sgNjd
                                                  of
                                                  { (#,#) ww12_sgNjf [Occ=Once]
                                                          ww13_sgNjg [Occ=Once] ->
                                                        case
                                                            Data.Complex.$w$c+
                                                                w_sgNiY
                                                                dt_sgNj4
                                                                ww_sgNiZ
                                                                ww12_sgNjf
                                                                ww13_sgNjg
                                                        of
                                                        { (#,#) ww15_sgNji ww16_sgNjj ->
                                                              let {
                                                                sat_sgNjl [Occ=Once] :: a_sgxNq
                                                                [LclId] =
                                                                    [w_sgNiY
                                                                     ww15_sgNji
                                                                     ww16_sgNjj] \u []
                                                                        Data.Complex.$wmagnitude
                                                                            w_sgNiY
                                                                            ww15_sgNji
                                                                            ww16_sgNjj;
                                                              } in 
                                                                case
                                                                    GHC.Float.$p2RealFloat w_sgNiY
                                                                of
                                                                sat_sgNjk
                                                                { __DEFAULT ->
                                                                      case
                                                                          GHC.Float.log
                                                                              sat_sgNjk sat_sgNjl
                                                                      of
                                                                      dt1_sgNjm
                                                                      { __DEFAULT ->
                                                                            case
                                                                                Data.Complex.$wphase
                                                                                    w_sgNiY
                                                                                    ww15_sgNji
                                                                                    ww16_sgNjj
                                                                            of
                                                                            dt2_sgNjn
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      GHC.Num.negate
                                                                                          $dNum_sgNj3
                                                                                          dt1_sgNjm
                                                                                  of
                                                                                  dt3_sgNjo
                                                                                  { __DEFAULT ->
                                                                                        (#,#) [dt2_sgNjn
                                                                                               dt3_sgNjo];
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$casin [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNjp w1_sgNjq]
        case w1_sgNjq of {
          Data.Complex.:+ ww1_sgNjs [Occ=Once] ww2_sgNjt [Occ=Once] ->
              case Data.Complex.$w$casin w_sgNjp ww1_sgNjs ww2_sgNjt of {
                (#,#) ww4_sgNjv [Occ=Once] ww5_sgNjw [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNjv ww5_sgNjw];
              };
        };

Data.Complex.$w$s$catanh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNjx ww1_sgNjy]
        case minusFloat# [0.0# ww1_sgNjy] of sat_sgNjB {
          __DEFAULT ->
              case minusFloat# [1.0# ww_sgNjx] of sat_sgNjA {
                __DEFAULT ->
                    case plusFloat# [1.0# ww_sgNjx] of sat_sgNjz {
                      __DEFAULT ->
                          case
                              Data.Complex.$w$s$c/1 sat_sgNjz ww1_sgNjy sat_sgNjA sat_sgNjB
                          of
                          { (#,#) ww3_sgNjD [Occ=Once!] ww4_sgNjE [Occ=Once!] ->
                                case ww3_sgNjD of {
                                  GHC.Types.F# ww6_sgNjG ->
                                      case ww4_sgNjE of {
                                        GHC.Types.F# ww8_sgNjI ->
                                            case
                                                Data.Complex.$w$smagnitude1 ww6_sgNjG ww8_sgNjI
                                            of
                                            ww9_sgNjJ
                                            { __DEFAULT ->
                                                  case logFloat# [ww9_sgNjJ] of wild1_sgNjK {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$sphase1
                                                                ww6_sgNjG ww8_sgNjI
                                                        of
                                                        ww10_sgNjL
                                                        { __DEFAULT ->
                                                              case
                                                                  timesFloat# [0.0# wild1_sgNjK]
                                                              of
                                                              sat_sgNjR
                                                              { __DEFAULT ->
                                                                    case
                                                                        timesFloat# [0.5#
                                                                                     ww10_sgNjL]
                                                                    of
                                                                    sat_sgNjQ
                                                                    { __DEFAULT ->
                                                                          case
                                                                              plusFloat# [sat_sgNjQ
                                                                                          sat_sgNjR]
                                                                          of
                                                                          sat_sgNjS
                                                                          { __DEFAULT ->
                                                                                let {
                                                                                  sat_sgNjT [Occ=Once]
                                                                                    :: GHC.Types.Float
                                                                                  [LclId] =
                                                                                      CCCS GHC.Types.F#! [sat_sgNjS];
                                                                                } in 
                                                                                  case
                                                                                      timesFloat# [0.0#
                                                                                                   ww10_sgNjL]
                                                                                  of
                                                                                  sat_sgNjN
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            timesFloat# [0.5#
                                                                                                         wild1_sgNjK]
                                                                                        of
                                                                                        sat_sgNjM
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  minusFloat# [sat_sgNjM
                                                                                                               sat_sgNjN]
                                                                                              of
                                                                                              sat_sgNjO
                                                                                              { __DEFAULT ->
                                                                                                    let {
                                                                                                      sat_sgNjP [Occ=Once]
                                                                                                        :: GHC.Types.Float
                                                                                                      [LclId] =
                                                                                                          CCCS GHC.Types.F#! [sat_sgNjO];
                                                                                                    } in 
                                                                                                      (#,#) [sat_sgNjP
                                                                                                             sat_sgNjT];
                                                                                              };
                                                                                        };
                                                                                  };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catanh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNjU]
        case w_sgNjU of {
          Data.Complex.:+ ww1_sgNjW [Occ=Once!] ww2_sgNjX [Occ=Once!] ->
              case ww1_sgNjW of {
                GHC.Types.F# ww4_sgNjZ [Occ=Once] ->
                    case ww2_sgNjX of {
                      GHC.Types.F# ww6_sgNk1 [Occ=Once] ->
                          case Data.Complex.$w$s$catanh1 ww4_sgNjZ ww6_sgNk1 of {
                            (#,#) ww8_sgNk3 [Occ=Once] ww9_sgNk4 [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNk3 ww9_sgNk4];
                          };
                    };
              };
        };

Data.Complex.$w$s$catanh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNk5 ww1_sgNk6]
        case -## [0.0## ww1_sgNk6] of sat_sgNk9 {
          __DEFAULT ->
              case -## [1.0## ww_sgNk5] of sat_sgNk8 {
                __DEFAULT ->
                    case +## [1.0## ww_sgNk5] of sat_sgNk7 {
                      __DEFAULT ->
                          case
                              Data.Complex.$w$s$c/ sat_sgNk7 ww1_sgNk6 sat_sgNk8 sat_sgNk9
                          of
                          { (#,#) ww3_sgNkb [Occ=Once!] ww4_sgNkc [Occ=Once!] ->
                                case ww3_sgNkb of {
                                  GHC.Types.D# ww6_sgNke ->
                                      case ww4_sgNkc of {
                                        GHC.Types.D# ww8_sgNkg ->
                                            case
                                                Data.Complex.$w$smagnitude ww6_sgNke ww8_sgNkg
                                            of
                                            ww9_sgNkh
                                            { __DEFAULT ->
                                                  case logDouble# [ww9_sgNkh] of wild1_sgNki {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$sphase
                                                                ww6_sgNke ww8_sgNkg
                                                        of
                                                        ww10_sgNkj
                                                        { __DEFAULT ->
                                                              case
                                                                  *## [0.0## wild1_sgNki]
                                                              of
                                                              sat_sgNkp
                                                              { __DEFAULT ->
                                                                    case
                                                                        *## [0.5## ww10_sgNkj]
                                                                    of
                                                                    sat_sgNko
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +## [sat_sgNko
                                                                                   sat_sgNkp]
                                                                          of
                                                                          sat_sgNkq
                                                                          { __DEFAULT ->
                                                                                let {
                                                                                  sat_sgNkr [Occ=Once]
                                                                                    :: GHC.Types.Double
                                                                                  [LclId] =
                                                                                      CCCS GHC.Types.D#! [sat_sgNkq];
                                                                                } in 
                                                                                  case
                                                                                      *## [0.0##
                                                                                           ww10_sgNkj]
                                                                                  of
                                                                                  sat_sgNkl
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            *## [0.5##
                                                                                                 wild1_sgNki]
                                                                                        of
                                                                                        sat_sgNkk
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  -## [sat_sgNkk
                                                                                                       sat_sgNkl]
                                                                                              of
                                                                                              sat_sgNkm
                                                                                              { __DEFAULT ->
                                                                                                    let {
                                                                                                      sat_sgNkn [Occ=Once]
                                                                                                        :: GHC.Types.Double
                                                                                                      [LclId] =
                                                                                                          CCCS GHC.Types.D#! [sat_sgNkm];
                                                                                                    } in 
                                                                                                      (#,#) [sat_sgNkn
                                                                                                             sat_sgNkr];
                                                                                              };
                                                                                        };
                                                                                  };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catanh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNks]
        case w_sgNks of {
          Data.Complex.:+ ww1_sgNku [Occ=Once!] ww2_sgNkv [Occ=Once!] ->
              case ww1_sgNku of {
                GHC.Types.D# ww4_sgNkx [Occ=Once] ->
                    case ww2_sgNkv of {
                      GHC.Types.D# ww6_sgNkz [Occ=Once] ->
                          case Data.Complex.$w$s$catanh ww4_sgNkx ww6_sgNkz of {
                            (#,#) ww8_sgNkB [Occ=Once] ww9_sgNkC [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNkB ww9_sgNkC];
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex20
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [Data.Complex.$fFloatingComplex19
                                Data.Complex.$fFloatingComplex21];

Data.Complex.$fFloatingComplex18
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [Data.Complex.$fFloatingComplex19
                                Data.Complex.$fFloatingComplex19];

Data.Complex.$w$catanh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LC(S))LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNkD ww_sgNkE ww1_sgNkF]
        case
            Data.Complex.$w$cfromRational
                w_sgNkD Data.Complex.$fFloatingComplex20
        of
        { (#,#) ww3_sgNkH [Occ=Once] ww4_sgNkI [Occ=Once] ->
              case
                  Data.Complex.$w$cfromRational
                      w_sgNkD Data.Complex.$fFloatingComplex18
              of
              { (#,#) ww6_sgNkK ww7_sgNkL ->
                    case
                        Data.Complex.$w$c+ w_sgNkD ww6_sgNkK ww7_sgNkL ww_sgNkE ww1_sgNkF
                    of
                    { (#,#) ww9_sgNkN [Occ=Once] ww10_sgNkO [Occ=Once] ->
                          case
                              Data.Complex.$w$c- w_sgNkD ww6_sgNkK ww7_sgNkL ww_sgNkE ww1_sgNkF
                          of
                          { (#,#) ww12_sgNkQ [Occ=Once] ww13_sgNkR [Occ=Once] ->
                                case
                                    Data.Complex.$w$c/
                                        w_sgNkD ww9_sgNkN ww10_sgNkO ww12_sgNkQ ww13_sgNkR
                                of
                                { (#,#) ww15_sgNkT ww16_sgNkU ->
                                      let {
                                        sat_sgNkW [Occ=Once] :: a_sgxOH
                                        [LclId] =
                                            [w_sgNkD ww15_sgNkT ww16_sgNkU] \u []
                                                Data.Complex.$wmagnitude
                                                    w_sgNkD ww15_sgNkT ww16_sgNkU;
                                      } in 
                                        case GHC.Float.$p2RealFloat w_sgNkD of sat_sgNkV {
                                          __DEFAULT ->
                                              case GHC.Float.log sat_sgNkV sat_sgNkW of dt_sgNkX {
                                                __DEFAULT ->
                                                    case
                                                        Data.Complex.$wphase
                                                            w_sgNkD ww15_sgNkT ww16_sgNkU
                                                    of
                                                    dt1_sgNkY
                                                    { __DEFAULT ->
                                                          Data.Complex.$w$c*
                                                              w_sgNkD
                                                              ww3_sgNkH
                                                              ww4_sgNkI
                                                              dt_sgNkX
                                                              dt1_sgNkY;
                                                    };
                                              };
                                        };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$catanh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LC(S))LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNkZ w1_sgNl0]
        case w1_sgNl0 of {
          Data.Complex.:+ ww1_sgNl2 [Occ=Once] ww2_sgNl3 [Occ=Once] ->
              case Data.Complex.$w$catanh w_sgNkZ ww1_sgNl2 ww2_sgNl3 of {
                (#,#) ww4_sgNl5 [Occ=Once] ww5_sgNl6 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNl5 ww5_sgNl6];
              };
        };

Data.Complex.$fFloatingComplex_nan :: GHC.Types.Double
[GblId] =
    [] \u []
        case /## [0.0## 0.0##] of wild2_sgNl7 {
          __DEFAULT -> GHC.Types.D# [wild2_sgNl7];
        };

Data.Complex.$fFloatingComplex_inf :: GHC.Types.Double
[GblId] =
    [] \u []
        case /## [1.0## 0.0##] of wild2_sgNl8 {
          __DEFAULT -> GHC.Types.D# [wild2_sgNl8];
        };

Data.Complex.$fFloatingComplex6
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_nan
                                    Data.Complex.$fFloatingComplex_nan];

Data.Complex.$fFloatingComplex5
  :: Data.Complex.Complex GHC.Types.Double
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_nan of {
          GHC.Types.D# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex6;
        };

Data.Complex.$fFloatingComplex8
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_inf
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$fFloatingComplex7
  :: Data.Complex.Complex GHC.Types.Double
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_inf of {
          GHC.Types.D# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex8;
        };

Data.Complex.$fFloatingComplex3 :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.D#! [1.0##];

Data.Complex.$fFloatingComplex2
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex3
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$w$s$c** [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=3,
 Str=<L,1*U(U(U),U(U))><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNld ww_sgNle ww1_sgNlf]
        let-no-escape {
          fail_sgNlg [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Double
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [w_sgNld ww_sgNle ww1_sgNlf] \r [ds_sgNlh]
                  case w_sgNld of {
                    Data.Complex.:+ ds1_sgNlj [Occ=Once!] ds2_sgNlk [Occ=Once!] ->
                        case ds2_sgNlk of {
                          GHC.Types.D# ds4_sgNlm ->
                              case ds1_sgNlj of {
                                GHC.Types.D# ds6_sgNlo ->
                                    let-no-escape {
                                      fail1_sgNlp [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Double
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [ww_sgNle
                                                    ww1_sgNlf
                                                    ds4_sgNlm
                                                    ds6_sgNlo] \r [ds7_sgNlq]
                                              case
                                                  __pkg_ccall base-4.11.0.0 [ds6_sgNlo
                                                                             GHC.Prim.realWorld#]
                                              of
                                              { (#,#) _ [Occ=Dead] ds9_sgNlu [Occ=Once!] ->
                                                    case ds9_sgNlu of {
                                                      __DEFAULT ->
                                                          case <## [ww_sgNle 0.0##] of {
                                                            __DEFAULT ->
                                                                case ==## [ww_sgNle 0.0##] of {
                                                                  __DEFAULT ->
                                                                      Data.Complex.$fFloatingComplex7;
                                                                  1# ->
                                                                      Data.Complex.$fFloatingComplex5;
                                                                };
                                                            1# -> Data.Complex.$fFloatingComplex4;
                                                          };
                                                      0# ->
                                                          case
                                                              __pkg_ccall base-4.11.0.0 [ds4_sgNlm
                                                                                         GHC.Prim.realWorld#]
                                                          of
                                                          { (#,#) _ [Occ=Dead]
                                                                  ds11_sgNlB [Occ=Once!] ->
                                                                case ds11_sgNlB of {
                                                                  __DEFAULT ->
                                                                      case <## [ww_sgNle 0.0##] of {
                                                                        __DEFAULT ->
                                                                            case
                                                                                ==## [ww_sgNle
                                                                                      0.0##]
                                                                            of
                                                                            { __DEFAULT ->
                                                                                  Data.Complex.$fFloatingComplex7;
                                                                              1# ->
                                                                                  Data.Complex.$fFloatingComplex5;
                                                                            };
                                                                        1# ->
                                                                            Data.Complex.$fFloatingComplex4;
                                                                      };
                                                                  0# ->
                                                                      case
                                                                          Data.Complex.$w$smagnitude
                                                                              ds6_sgNlo ds4_sgNlm
                                                                      of
                                                                      ww2_sgNlF
                                                                      { __DEFAULT ->
                                                                            case
                                                                                logDouble# [ww2_sgNlF]
                                                                            of
                                                                            wild5_sgNlG
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      Data.Complex.$w$sphase
                                                                                          ds6_sgNlo
                                                                                          ds4_sgNlm
                                                                                  of
                                                                                  ww3_sgNlH
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            *## [ww3_sgNlH
                                                                                                 ww_sgNle]
                                                                                        of
                                                                                        sat_sgNlK
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  *## [wild5_sgNlG
                                                                                                       ww1_sgNlf]
                                                                                              of
                                                                                              sat_sgNlJ
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        +## [sat_sgNlJ
                                                                                                             sat_sgNlK]
                                                                                                    of
                                                                                                    y_sgNlI
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              *## [ww3_sgNlH
                                                                                                                   ww1_sgNlf]
                                                                                                          of
                                                                                                          sat_sgNlN
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    *## [wild5_sgNlG
                                                                                                                         ww_sgNle]
                                                                                                                of
                                                                                                                sat_sgNlM
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          -## [sat_sgNlM
                                                                                                                               sat_sgNlN]
                                                                                                                      of
                                                                                                                      sat_sgNlO
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                expDouble# [sat_sgNlO]
                                                                                                                            of
                                                                                                                            expx_sgNlL
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sinDouble# [y_sgNlI]
                                                                                                                                  of
                                                                                                                                  sat_sgNlS
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            *## [expx_sgNlL
                                                                                                                                                 sat_sgNlS]
                                                                                                                                        of
                                                                                                                                        sat_sgNlT
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              let {
                                                                                                                                                sat_sgNlU [Occ=Once]
                                                                                                                                                  :: GHC.Types.Double
                                                                                                                                                [LclId] =
                                                                                                                                                    CCCS GHC.Types.D#! [sat_sgNlT];
                                                                                                                                              } in 
                                                                                                                                                case
                                                                                                                                                    cosDouble# [y_sgNlI]
                                                                                                                                                of
                                                                                                                                                sat_sgNlP
                                                                                                                                                { __DEFAULT ->
                                                                                                                                                      case
                                                                                                                                                          *## [expx_sgNlL
                                                                                                                                                               sat_sgNlP]
                                                                                                                                                      of
                                                                                                                                                      sat_sgNlQ
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgNlR [Occ=Once]
                                                                                                                                                                :: GHC.Types.Double
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.D#! [sat_sgNlQ];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgNlR
                                                                                                                                                                               sat_sgNlU];
                                                                                                                                                      };
                                                                                                                                                };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                    } in 
                                      case ==## [ds6_sgNlo 0.0##] of {
                                        __DEFAULT -> fail1_sgNlp GHC.Prim.void#;
                                        1# ->
                                            case ==## [ds4_sgNlm 0.0##] of {
                                              __DEFAULT -> fail1_sgNlp GHC.Prim.void#;
                                              1# ->
                                                  case <## [ww_sgNle 0.0##] of {
                                                    __DEFAULT ->
                                                        case ==## [ww_sgNle 0.0##] of {
                                                          __DEFAULT ->
                                                              Data.Complex.$fFloatingComplex4;
                                                          1# -> Data.Complex.$fFloatingComplex5;
                                                        };
                                                    1# -> Data.Complex.$fFloatingComplex7;
                                                  };
                                            };
                                      };
                              };
                        };
                  };
        } in 
          case ==## [ww_sgNle 0.0##] of {
            __DEFAULT -> fail_sgNlg GHC.Prim.void#;
            1# ->
                case ==## [ww1_sgNlf 0.0##] of {
                  __DEFAULT -> fail_sgNlg GHC.Prim.void#;
                  1# -> Data.Complex.$fFloatingComplex2;
                };
          };

Data.Complex.$fFloatingComplex_$s$c** [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Str=<L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>,
 Unf=OtherCon []] =
    [] \r [w_sgNm1 w1_sgNm2]
        case w1_sgNm2 of {
          Data.Complex.:+ ww1_sgNm4 [Occ=Once!] ww2_sgNm5 [Occ=Once!] ->
              case ww1_sgNm4 of {
                GHC.Types.D# ww4_sgNm7 [Occ=Once] ->
                    case ww2_sgNm5 of {
                      GHC.Types.D# ww6_sgNm9 [Occ=Once] ->
                          Data.Complex.$w$s$c** w_sgNm1 ww4_sgNm7 ww6_sgNm9;
                    };
              };
        };

Data.Complex.$fFloatingComplex_nan1 :: GHC.Types.Float
[GblId] =
    [] \u []
        case divideFloat# [0.0# 0.0#] of wild2_sgNma {
          __DEFAULT -> GHC.Types.F# [wild2_sgNma];
        };

Data.Complex.$fFloatingComplex_inf1 :: GHC.Types.Float
[GblId] =
    [] \u []
        case divideFloat# [1.0# 0.0#] of wild2_sgNmb {
          __DEFAULT -> GHC.Types.F# [wild2_sgNmb];
        };

Data.Complex.$fFloatingComplex14
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_nan1
                                    Data.Complex.$fFloatingComplex_nan1];

Data.Complex.$fFloatingComplex13
  :: Data.Complex.Complex GHC.Types.Float
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_nan1 of {
          GHC.Types.F# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex14;
        };

Data.Complex.$fFloatingComplex16
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_inf1
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$fFloatingComplex15
  :: Data.Complex.Complex GHC.Types.Float
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_inf1 of {
          GHC.Types.F# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex16;
        };

Data.Complex.$fFloatingComplex11 :: GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.F#! [1.0#];

Data.Complex.$fFloatingComplex10
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex11
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$w$s$c**1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=3,
 Str=<L,1*U(U(U),U(U))><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNmg ww_sgNmh ww1_sgNmi]
        let-no-escape {
          fail_sgNmj [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Float
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [w_sgNmg ww_sgNmh ww1_sgNmi] \r [ds_sgNmk]
                  case w_sgNmg of {
                    Data.Complex.:+ ds1_sgNmm [Occ=Once!] ds2_sgNmn [Occ=Once!] ->
                        case ds2_sgNmn of {
                          GHC.Types.F# ds4_sgNmp ->
                              case ds1_sgNmm of {
                                GHC.Types.F# ds6_sgNmr ->
                                    let-no-escape {
                                      fail1_sgNms [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Float
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [ww_sgNmh
                                                    ww1_sgNmi
                                                    ds4_sgNmp
                                                    ds6_sgNmr] \r [ds7_sgNmt]
                                              case
                                                  __pkg_ccall base-4.11.0.0 [ds6_sgNmr
                                                                             GHC.Prim.realWorld#]
                                              of
                                              { (#,#) _ [Occ=Dead] ds9_sgNmx [Occ=Once!] ->
                                                    case ds9_sgNmx of {
                                                      __DEFAULT ->
                                                          case ltFloat# [ww_sgNmh 0.0#] of {
                                                            __DEFAULT ->
                                                                case eqFloat# [ww_sgNmh 0.0#] of {
                                                                  __DEFAULT ->
                                                                      Data.Complex.$fFloatingComplex15;
                                                                  1# ->
                                                                      Data.Complex.$fFloatingComplex13;
                                                                };
                                                            1# -> Data.Complex.$fFloatingComplex12;
                                                          };
                                                      0# ->
                                                          case
                                                              __pkg_ccall base-4.11.0.0 [ds4_sgNmp
                                                                                         GHC.Prim.realWorld#]
                                                          of
                                                          { (#,#) _ [Occ=Dead]
                                                                  ds11_sgNmE [Occ=Once!] ->
                                                                case ds11_sgNmE of {
                                                                  __DEFAULT ->
                                                                      case
                                                                          ltFloat# [ww_sgNmh 0.0#]
                                                                      of
                                                                      { __DEFAULT ->
                                                                            case
                                                                                eqFloat# [ww_sgNmh
                                                                                          0.0#]
                                                                            of
                                                                            { __DEFAULT ->
                                                                                  Data.Complex.$fFloatingComplex15;
                                                                              1# ->
                                                                                  Data.Complex.$fFloatingComplex13;
                                                                            };
                                                                        1# ->
                                                                            Data.Complex.$fFloatingComplex12;
                                                                      };
                                                                  0# ->
                                                                      case
                                                                          Data.Complex.$w$smagnitude1
                                                                              ds6_sgNmr ds4_sgNmp
                                                                      of
                                                                      ww2_sgNmI
                                                                      { __DEFAULT ->
                                                                            case
                                                                                logFloat# [ww2_sgNmI]
                                                                            of
                                                                            wild5_sgNmJ
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      Data.Complex.$w$sphase1
                                                                                          ds6_sgNmr
                                                                                          ds4_sgNmp
                                                                                  of
                                                                                  ww3_sgNmK
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            timesFloat# [ww3_sgNmK
                                                                                                         ww_sgNmh]
                                                                                        of
                                                                                        sat_sgNmN
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  timesFloat# [wild5_sgNmJ
                                                                                                               ww1_sgNmi]
                                                                                              of
                                                                                              sat_sgNmM
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        plusFloat# [sat_sgNmM
                                                                                                                    sat_sgNmN]
                                                                                                    of
                                                                                                    y_sgNmL
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              timesFloat# [ww3_sgNmK
                                                                                                                           ww1_sgNmi]
                                                                                                          of
                                                                                                          sat_sgNmQ
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    timesFloat# [wild5_sgNmJ
                                                                                                                                 ww_sgNmh]
                                                                                                                of
                                                                                                                sat_sgNmP
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          minusFloat# [sat_sgNmP
                                                                                                                                       sat_sgNmQ]
                                                                                                                      of
                                                                                                                      sat_sgNmR
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                expFloat# [sat_sgNmR]
                                                                                                                            of
                                                                                                                            expx_sgNmO
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sinFloat# [y_sgNmL]
                                                                                                                                  of
                                                                                                                                  sat_sgNmV
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            timesFloat# [expx_sgNmO
                                                                                                                                                         sat_sgNmV]
                                                                                                                                        of
                                                                                                                                        sat_sgNmW
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              let {
                                                                                                                                                sat_sgNmX [Occ=Once]
                                                                                                                                                  :: GHC.Types.Float
                                                                                                                                                [LclId] =
                                                                                                                                                    CCCS GHC.Types.F#! [sat_sgNmW];
                                                                                                                                              } in 
                                                                                                                                                case
                                                                                                                                                    cosFloat# [y_sgNmL]
                                                                                                                                                of
                                                                                                                                                sat_sgNmS
                                                                                                                                                { __DEFAULT ->
                                                                                                                                                      case
                                                                                                                                                          timesFloat# [expx_sgNmO
                                                                                                                                                                       sat_sgNmS]
                                                                                                                                                      of
                                                                                                                                                      sat_sgNmT
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgNmU [Occ=Once]
                                                                                                                                                                :: GHC.Types.Float
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.F#! [sat_sgNmT];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgNmU
                                                                                                                                                                               sat_sgNmX];
                                                                                                                                                      };
                                                                                                                                                };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                    } in 
                                      case eqFloat# [ds6_sgNmr 0.0#] of {
                                        __DEFAULT -> fail1_sgNms GHC.Prim.void#;
                                        1# ->
                                            case eqFloat# [ds4_sgNmp 0.0#] of {
                                              __DEFAULT -> fail1_sgNms GHC.Prim.void#;
                                              1# ->
                                                  case ltFloat# [ww_sgNmh 0.0#] of {
                                                    __DEFAULT ->
                                                        case eqFloat# [ww_sgNmh 0.0#] of {
                                                          __DEFAULT ->
                                                              Data.Complex.$fFloatingComplex12;
                                                          1# -> Data.Complex.$fFloatingComplex13;
                                                        };
                                                    1# -> Data.Complex.$fFloatingComplex15;
                                                  };
                                            };
                                      };
                              };
                        };
                  };
        } in 
          case eqFloat# [ww_sgNmh 0.0#] of {
            __DEFAULT -> fail_sgNmj GHC.Prim.void#;
            1# ->
                case eqFloat# [ww1_sgNmi 0.0#] of {
                  __DEFAULT -> fail_sgNmj GHC.Prim.void#;
                  1# -> Data.Complex.$fFloatingComplex10;
                };
          };

Data.Complex.$fFloatingComplex_$s$c**1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Str=<L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>,
 Unf=OtherCon []] =
    [] \r [w_sgNn4 w1_sgNn5]
        case w1_sgNn5 of {
          Data.Complex.:+ ww1_sgNn7 [Occ=Once!] ww2_sgNn8 [Occ=Once!] ->
              case ww1_sgNn7 of {
                GHC.Types.F# ww4_sgNna [Occ=Once] ->
                    case ww2_sgNn8 of {
                      GHC.Types.F# ww6_sgNnc [Occ=Once] ->
                          Data.Complex.$w$s$c**1 w_sgNn4 ww4_sgNna ww6_sgNnc;
                    };
              };
        };

Data.Complex.$w$c** [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> a -> a -> (# a, a #)
[GblId,
 Arity=4,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))><L,1*U(U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNnd w1_sgNne ww_sgNnf ww1_sgNng]
        case
            GHC.Float.$p1RealFloat w_sgNnd
        of
        $dRealFrac_sgNnh [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgNnh
              of
              $dReal_sgNni [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p2Real $dReal_sgNni
                    of
                    $dOrd_sgNnj [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A)>]
                    { __DEFAULT ->
                          case
                              GHC.Classes.$p1Ord $dOrd_sgNnj
                          of
                          $dEq_sgNnk [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                          { __DEFAULT ->
                                let {
                                  $dNum_sgNnl [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_sgxPv
                                  [LclId] =
                                      [$dReal_sgNni] \u [] GHC.Real.$p1Real $dReal_sgNni; } in
                                let {
                                  sat_sgNnZ [Occ=Once] :: a_sgxPv
                                  [LclId] =
                                      [$dNum_sgNnl] \u []
                                          GHC.Num.fromInteger
                                              $dNum_sgNnl Data.Complex.$fFloatingComplex17;
                                } in 
                                  let-no-escape {
                                    fail_sgNnm [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                      :: GHC.Prim.Void# -> (# a_sgxPv, a_sgxPv #)
                                    [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                        sat-only [w_sgNnd
                                                  w1_sgNne
                                                  ww_sgNnf
                                                  ww1_sgNng
                                                  $dRealFrac_sgNnh
                                                  $dOrd_sgNnj
                                                  $dEq_sgNnk
                                                  $dNum_sgNnl] \r [ds_sgNnn]
                                            case w1_sgNne of {
                                              Data.Complex.:+ ds1_sgNnp ds2_sgNnq ->
                                                  let {
                                                    $dFractional_sgNnr [Dmd=<L,U(A,C(C1(U)),A,A)>]
                                                      :: GHC.Real.Fractional a_sgxPv
                                                    [LclId] =
                                                        [$dRealFrac_sgNnh] \u []
                                                            GHC.Real.$p2RealFrac
                                                                $dRealFrac_sgNnh; } in
                                                  let {
                                                    nan_sgNns [Dmd=<L,1*U>] :: a_sgxPv
                                                    [LclId] =
                                                        [$dNum_sgNnl $dFractional_sgNnr] \s []
                                                            let {
                                                              sat_sgNnu [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgNnl] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgNnl
                                                                          Data.Complex.$fFloatingComplex17; } in
                                                            let {
                                                              sat_sgNnt [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgNnl] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgNnl
                                                                          Data.Complex.$fFloatingComplex17;
                                                            } in 
                                                              GHC.Real./
                                                                  $dFractional_sgNnr
                                                                  sat_sgNnt
                                                                  sat_sgNnu; } in
                                                  let {
                                                    inf_sgNnv [Dmd=<L,1*U>] :: a_sgxPv
                                                    [LclId] =
                                                        [$dNum_sgNnl $dFractional_sgNnr] \s []
                                                            let {
                                                              sat_sgNnx [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgNnl] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgNnl
                                                                          Data.Complex.$fFloatingComplex17; } in
                                                            let {
                                                              sat_sgNnw [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgNnl] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgNnl
                                                                          Data.Complex.$fFloatingComplex19;
                                                            } in 
                                                              GHC.Real./
                                                                  $dFractional_sgNnr
                                                                  sat_sgNnw
                                                                  sat_sgNnx; } in
                                                  let {
                                                    sat_sgNnP [Occ=Once] :: a_sgxPv
                                                    [LclId] =
                                                        [$dNum_sgNnl] \u []
                                                            GHC.Num.fromInteger
                                                                $dNum_sgNnl
                                                                Data.Complex.$fFloatingComplex17;
                                                  } in 
                                                    let-no-escape {
                                                      fail1_sgNny [Occ=Once*!T[1],
                                                                   Dmd=<L,1*C1(U(U,U))>]
                                                        :: GHC.Prim.Void# -> (# a_sgxPv, a_sgxPv #)
                                                      [LclId[JoinId(1)],
                                                       Arity=1,
                                                       Str=<L,A>,
                                                       Unf=OtherCon []] =
                                                          sat-only [w_sgNnd
                                                                    ww_sgNnf
                                                                    ww1_sgNng
                                                                    $dOrd_sgNnj
                                                                    $dNum_sgNnl
                                                                    ds1_sgNnp
                                                                    ds2_sgNnq
                                                                    nan_sgNns
                                                                    inf_sgNnv] \r [ds3_sgNnz]
                                                              let-no-escape {
                                                                $j_sgNnA [Occ=Once*T[0],
                                                                          Dmd=<L,1*U(U,U)>]
                                                                  :: (# a_sgxPv, a_sgxPv #)
                                                                [LclId[JoinId(0)],
                                                                 Unf=OtherCon []] =
                                                                    [ww_sgNnf
                                                                     $dOrd_sgNnj
                                                                     $dNum_sgNnl
                                                                     nan_sgNns
                                                                     inf_sgNnv] \r []
                                                                        let {
                                                                          sat_sgNnB [Occ=Once]
                                                                            :: a_sgxPv
                                                                          [LclId] =
                                                                              [$dNum_sgNnl] \u []
                                                                                  GHC.Num.fromInteger
                                                                                      $dNum_sgNnl
                                                                                      Data.Complex.$fFloatingComplex17;
                                                                        } in 
                                                                          case
                                                                              GHC.Classes.compare
                                                                                  $dOrd_sgNnj
                                                                                  ww_sgNnf
                                                                                  sat_sgNnB
                                                                          of
                                                                          { GHC.Types.LT ->
                                                                                case
                                                                                    GHC.Num.fromInteger
                                                                                        $dNum_sgNnl
                                                                                        Data.Complex.$fFloatingComplex17
                                                                                of
                                                                                dt_sgNnD
                                                                                { __DEFAULT ->
                                                                                      (#,#) [dt_sgNnD
                                                                                             dt_sgNnD];
                                                                                };
                                                                            GHC.Types.EQ ->
                                                                                case
                                                                                    nan_sgNns
                                                                                of
                                                                                dt_sgNnE
                                                                                { __DEFAULT ->
                                                                                      (#,#) [dt_sgNnE
                                                                                             dt_sgNnE];
                                                                                };
                                                                            GHC.Types.GT ->
                                                                                case
                                                                                    inf_sgNnv
                                                                                of
                                                                                dt_sgNnF
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          GHC.Num.fromInteger
                                                                                              $dNum_sgNnl
                                                                                              Data.Complex.$fFloatingComplex17
                                                                                      of
                                                                                      dt1_sgNnG
                                                                                      { __DEFAULT ->
                                                                                            (#,#) [dt_sgNnF
                                                                                                   dt1_sgNnG];
                                                                                      };
                                                                                };
                                                                          };
                                                              } in 
                                                                case
                                                                    GHC.Float.isInfinite
                                                                        w_sgNnd ds1_sgNnp
                                                                of
                                                                { GHC.Types.False ->
                                                                      case
                                                                          GHC.Float.isInfinite
                                                                              w_sgNnd ds2_sgNnq
                                                                      of
                                                                      { GHC.Types.False ->
                                                                            case
                                                                                Data.Complex.$w$clog
                                                                                    w_sgNnd
                                                                                    ds1_sgNnp
                                                                                    ds2_sgNnq
                                                                            of
                                                                            { (#,#) ww3_sgNnK [Occ=Once]
                                                                                    ww4_sgNnL [Occ=Once] ->
                                                                                  case
                                                                                      Data.Complex.$w$c*
                                                                                          w_sgNnd
                                                                                          ww3_sgNnK
                                                                                          ww4_sgNnL
                                                                                          ww_sgNnf
                                                                                          ww1_sgNng
                                                                                  of
                                                                                  { (#,#) ww6_sgNnN [Occ=Once]
                                                                                          ww7_sgNnO [Occ=Once] ->
                                                                                        Data.Complex.$w$cexp
                                                                                            w_sgNnd
                                                                                            ww6_sgNnN
                                                                                            ww7_sgNnO;
                                                                                  };
                                                                            };
                                                                        GHC.Types.True -> $j_sgNnA;
                                                                      };
                                                                  GHC.Types.True -> $j_sgNnA;
                                                                };
                                                    } in 
                                                      case
                                                          GHC.Classes.==
                                                              $dEq_sgNnk ds1_sgNnp sat_sgNnP
                                                      of
                                                      { GHC.Types.False ->
                                                            fail1_sgNny GHC.Prim.void#;
                                                        GHC.Types.True ->
                                                            let {
                                                              sat_sgNnR [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgNnl] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgNnl
                                                                          Data.Complex.$fFloatingComplex17;
                                                            } in 
                                                              case
                                                                  GHC.Classes.==
                                                                      $dEq_sgNnk ds2_sgNnq sat_sgNnR
                                                              of
                                                              { GHC.Types.False ->
                                                                    fail1_sgNny GHC.Prim.void#;
                                                                GHC.Types.True ->
                                                                    let {
                                                                      sat_sgNnT [Occ=Once]
                                                                        :: a_sgxPv
                                                                      [LclId] =
                                                                          [$dNum_sgNnl] \u []
                                                                              GHC.Num.fromInteger
                                                                                  $dNum_sgNnl
                                                                                  Data.Complex.$fFloatingComplex17;
                                                                    } in 
                                                                      case
                                                                          GHC.Classes.compare
                                                                              $dOrd_sgNnj
                                                                              ww_sgNnf
                                                                              sat_sgNnT
                                                                      of
                                                                      { GHC.Types.LT ->
                                                                            case
                                                                                inf_sgNnv
                                                                            of
                                                                            dt_sgNnV
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      GHC.Num.fromInteger
                                                                                          $dNum_sgNnl
                                                                                          Data.Complex.$fFloatingComplex17
                                                                                  of
                                                                                  dt1_sgNnW
                                                                                  { __DEFAULT ->
                                                                                        (#,#) [dt_sgNnV
                                                                                               dt1_sgNnW];
                                                                                  };
                                                                            };
                                                                        GHC.Types.EQ ->
                                                                            case
                                                                                nan_sgNns
                                                                            of
                                                                            dt_sgNnX
                                                                            { __DEFAULT ->
                                                                                  (#,#) [dt_sgNnX
                                                                                         dt_sgNnX];
                                                                            };
                                                                        GHC.Types.GT ->
                                                                            case
                                                                                GHC.Num.fromInteger
                                                                                    $dNum_sgNnl
                                                                                    Data.Complex.$fFloatingComplex17
                                                                            of
                                                                            dt_sgNnY
                                                                            { __DEFAULT ->
                                                                                  (#,#) [dt_sgNnY
                                                                                         dt_sgNnY];
                                                                            };
                                                                      };
                                                              };
                                                      };
                                            };
                                  } in 
                                    case GHC.Classes.== $dEq_sgNnk ww_sgNnf sat_sgNnZ of {
                                      GHC.Types.False -> fail_sgNnm GHC.Prim.void#;
                                      GHC.Types.True ->
                                          let {
                                            sat_sgNo1 [Occ=Once] :: a_sgxPv
                                            [LclId] =
                                                [$dNum_sgNnl] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_sgNnl
                                                        Data.Complex.$fFloatingComplex17;
                                          } in 
                                            case GHC.Classes.== $dEq_sgNnk ww1_sgNng sat_sgNo1 of {
                                              GHC.Types.False -> fail_sgNnm GHC.Prim.void#;
                                              GHC.Types.True ->
                                                  case
                                                      GHC.Num.fromInteger
                                                          $dNum_sgNnl
                                                          Data.Complex.$fFloatingComplex19
                                                  of
                                                  dt_sgNo3
                                                  { __DEFAULT ->
                                                        case
                                                            GHC.Num.fromInteger
                                                                $dNum_sgNnl
                                                                Data.Complex.$fFloatingComplex17
                                                        of
                                                        dt1_sgNo4
                                                        { __DEFAULT -> (#,#) [dt_sgNo3 dt1_sgNo4];
                                                        };
                                                  };
                                            };
                                    };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$c** [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))><L,1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNo5 w1_sgNo6 w2_sgNo7]
        case w2_sgNo7 of {
          Data.Complex.:+ ww1_sgNo9 [Occ=Once] ww2_sgNoa [Occ=Once] ->
              case Data.Complex.$w$c** w_sgNo5 w1_sgNo6 ww1_sgNo9 ww2_sgNoa of {
                (#,#) ww4_sgNoc [Occ=Once] ww5_sgNod [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNoc ww5_sgNod];
              };
        };

Data.Complex.$fFloatingComplex_$s$cexpm2 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNoe]
        case eta_sgNoe of {
          Data.Complex.:+ a_sgNog [Occ=Once!] b_sgNoh [Occ=Once!] ->
              case a_sgNog of {
                GHC.Types.F# x_sgNoj ->
                    case b_sgNoh of {
                      GHC.Types.F# x1_sgNol ->
                          case timesFloat# [x1_sgNol x1_sgNol] of sat_sgNon {
                            __DEFAULT ->
                                case timesFloat# [x_sgNoj x_sgNoj] of sat_sgNom {
                                  __DEFAULT ->
                                      case plusFloat# [sat_sgNom sat_sgNon] of sat_sgNoo {
                                        __DEFAULT ->
                                            case ltFloat# [sat_sgNoo 1.0#] of {
                                              __DEFAULT ->
                                                  case expFloat# [x_sgNoj] of expx_sgNoq {
                                                    __DEFAULT ->
                                                        case sinFloat# [x1_sgNol] of sat_sgNov {
                                                          __DEFAULT ->
                                                              case
                                                                  timesFloat# [expx_sgNoq sat_sgNov]
                                                              of
                                                              sat_sgNow
                                                              { __DEFAULT ->
                                                                    let {
                                                                      sat_sgNox [Occ=Once]
                                                                        :: GHC.Types.Float
                                                                      [LclId] =
                                                                          CCCS GHC.Types.F#! [sat_sgNow];
                                                                    } in 
                                                                      case
                                                                          cosFloat# [x1_sgNol]
                                                                      of
                                                                      sat_sgNor
                                                                      { __DEFAULT ->
                                                                            case
                                                                                timesFloat# [expx_sgNoq
                                                                                             sat_sgNor]
                                                                            of
                                                                            sat_sgNos
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      minusFloat# [sat_sgNos
                                                                                                   1.0#]
                                                                                  of
                                                                                  sat_sgNot
                                                                                  { __DEFAULT ->
                                                                                        let {
                                                                                          sat_sgNou [Occ=Once]
                                                                                            :: GHC.Types.Float
                                                                                          [LclId] =
                                                                                              CCCS GHC.Types.F#! [sat_sgNot];
                                                                                        } in 
                                                                                          Data.Complex.:+ [sat_sgNou
                                                                                                           sat_sgNox];
                                                                                  };
                                                                            };
                                                                      };
                                                              };
                                                        };
                                                  };
                                              1# ->
                                                  case
                                                      __pkg_ccall base-4.11.0.0 [x_sgNoj
                                                                                 GHC.Prim.realWorld#]
                                                  of
                                                  { (#,#) _ [Occ=Dead] ds4_sgNoB ->
                                                        case
                                                            divideFloat# [x1_sgNol 2.0#]
                                                        of
                                                        sat_sgNoD
                                                        { __DEFAULT ->
                                                              case
                                                                  sinFloat# [sat_sgNoD]
                                                              of
                                                              v_sgNoC [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        plusFloat# [v_sgNoC v_sgNoC]
                                                                    of
                                                                    sat_sgNoF
                                                                    { __DEFAULT ->
                                                                          case
                                                                              timesFloat# [sat_sgNoF
                                                                                           v_sgNoC]
                                                                          of
                                                                          sat_sgNoG
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateFloat# [sat_sgNoG]
                                                                                of
                                                                                w_sgNoE
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          sinFloat# [x1_sgNol]
                                                                                      of
                                                                                      sat_sgNoM
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                plusFloat# [ds4_sgNoB
                                                                                                            1.0#]
                                                                                            of
                                                                                            sat_sgNoL
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      timesFloat# [sat_sgNoL
                                                                                                                   sat_sgNoM]
                                                                                                  of
                                                                                                  sat_sgNoN
                                                                                                  { __DEFAULT ->
                                                                                                        let {
                                                                                                          sat_sgNoO [Occ=Once]
                                                                                                            :: GHC.Types.Float
                                                                                                          [LclId] =
                                                                                                              CCCS GHC.Types.F#! [sat_sgNoN];
                                                                                                        } in 
                                                                                                          case
                                                                                                              timesFloat# [ds4_sgNoB
                                                                                                                           w_sgNoE]
                                                                                                          of
                                                                                                          sat_sgNoH
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    plusFloat# [sat_sgNoH
                                                                                                                                ds4_sgNoB]
                                                                                                                of
                                                                                                                sat_sgNoI
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          plusFloat# [sat_sgNoI
                                                                                                                                      w_sgNoE]
                                                                                                                      of
                                                                                                                      sat_sgNoJ
                                                                                                                      { __DEFAULT ->
                                                                                                                            let {
                                                                                                                              sat_sgNoK [Occ=Once]
                                                                                                                                :: GHC.Types.Float
                                                                                                                              [LclId] =
                                                                                                                                  CCCS GHC.Types.F#! [sat_sgNoJ];
                                                                                                                            } in 
                                                                                                                              Data.Complex.:+ [sat_sgNoK
                                                                                                                                               sat_sgNoO];
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNoP]
        case eta_sgNoP of {
          Data.Complex.:+ a_sgNoR [Occ=Once!] b_sgNoS [Occ=Once!] ->
              case a_sgNoR of {
                GHC.Types.D# x_sgNoU ->
                    case b_sgNoS of {
                      GHC.Types.D# x1_sgNoW ->
                          case *## [x1_sgNoW x1_sgNoW] of sat_sgNoY {
                            __DEFAULT ->
                                case *## [x_sgNoU x_sgNoU] of sat_sgNoX {
                                  __DEFAULT ->
                                      case +## [sat_sgNoX sat_sgNoY] of sat_sgNoZ {
                                        __DEFAULT ->
                                            case <## [sat_sgNoZ 1.0##] of {
                                              __DEFAULT ->
                                                  case expDouble# [x_sgNoU] of expx_sgNp1 {
                                                    __DEFAULT ->
                                                        case sinDouble# [x1_sgNoW] of sat_sgNp6 {
                                                          __DEFAULT ->
                                                              case
                                                                  *## [expx_sgNp1 sat_sgNp6]
                                                              of
                                                              sat_sgNp7
                                                              { __DEFAULT ->
                                                                    let {
                                                                      sat_sgNp8 [Occ=Once]
                                                                        :: GHC.Types.Double
                                                                      [LclId] =
                                                                          CCCS GHC.Types.D#! [sat_sgNp7];
                                                                    } in 
                                                                      case
                                                                          cosDouble# [x1_sgNoW]
                                                                      of
                                                                      sat_sgNp2
                                                                      { __DEFAULT ->
                                                                            case
                                                                                *## [expx_sgNp1
                                                                                     sat_sgNp2]
                                                                            of
                                                                            sat_sgNp3
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      -## [sat_sgNp3
                                                                                           1.0##]
                                                                                  of
                                                                                  sat_sgNp4
                                                                                  { __DEFAULT ->
                                                                                        let {
                                                                                          sat_sgNp5 [Occ=Once]
                                                                                            :: GHC.Types.Double
                                                                                          [LclId] =
                                                                                              CCCS GHC.Types.D#! [sat_sgNp4];
                                                                                        } in 
                                                                                          Data.Complex.:+ [sat_sgNp5
                                                                                                           sat_sgNp8];
                                                                                  };
                                                                            };
                                                                      };
                                                              };
                                                        };
                                                  };
                                              1# ->
                                                  case
                                                      __pkg_ccall base-4.11.0.0 [x_sgNoU
                                                                                 GHC.Prim.realWorld#]
                                                  of
                                                  { (#,#) _ [Occ=Dead] ds4_sgNpc ->
                                                        case /## [x1_sgNoW 2.0##] of sat_sgNpe {
                                                          __DEFAULT ->
                                                              case
                                                                  sinDouble# [sat_sgNpe]
                                                              of
                                                              v_sgNpd [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        +## [v_sgNpd v_sgNpd]
                                                                    of
                                                                    sat_sgNpg
                                                                    { __DEFAULT ->
                                                                          case
                                                                              *## [sat_sgNpg
                                                                                   v_sgNpd]
                                                                          of
                                                                          sat_sgNph
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateDouble# [sat_sgNph]
                                                                                of
                                                                                w_sgNpf
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          sinDouble# [x1_sgNoW]
                                                                                      of
                                                                                      sat_sgNpn
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                +## [ds4_sgNpc
                                                                                                     1.0##]
                                                                                            of
                                                                                            sat_sgNpm
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      *## [sat_sgNpm
                                                                                                           sat_sgNpn]
                                                                                                  of
                                                                                                  sat_sgNpo
                                                                                                  { __DEFAULT ->
                                                                                                        let {
                                                                                                          sat_sgNpp [Occ=Once]
                                                                                                            :: GHC.Types.Double
                                                                                                          [LclId] =
                                                                                                              CCCS GHC.Types.D#! [sat_sgNpo];
                                                                                                        } in 
                                                                                                          case
                                                                                                              *## [ds4_sgNpc
                                                                                                                   w_sgNpf]
                                                                                                          of
                                                                                                          sat_sgNpi
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    +## [sat_sgNpi
                                                                                                                         ds4_sgNpc]
                                                                                                                of
                                                                                                                sat_sgNpj
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          +## [sat_sgNpj
                                                                                                                               w_sgNpf]
                                                                                                                      of
                                                                                                                      sat_sgNpk
                                                                                                                      { __DEFAULT ->
                                                                                                                            let {
                                                                                                                              sat_sgNpl [Occ=Once]
                                                                                                                                :: GHC.Types.Double
                                                                                                                              [LclId] =
                                                                                                                                  CCCS GHC.Types.D#! [sat_sgNpk];
                                                                                                                            } in 
                                                                                                                              Data.Complex.:+ [sat_sgNpl
                                                                                                                                               sat_sgNpp];
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(LLC(C(S))LLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgNpq eta_sgNpr]
        case eta_sgNpr of {
          Data.Complex.:+ a1_sgNpt b_sgNpu ->
              case
                  GHC.Float.$p1RealFloat $dRealFloat_sgNpq
              of
              $dRealFrac_sgNpv [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1RealFrac $dRealFrac_sgNpv
                    of
                    $dReal_sgNpw [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
                    { __DEFAULT ->
                          let {
                            $dNum_sgNpx [Dmd=<L,U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U))>]
                              :: GHC.Num.Num a_agsO1
                            [LclId] =
                                [$dReal_sgNpw] \u [] GHC.Real.$p1Real $dReal_sgNpw; } in
                          let {
                            sat_sgNpC [Occ=Once] :: a_agsO1
                            [LclId] =
                                [$dNum_sgNpx] \u []
                                    GHC.Num.fromInteger
                                        $dNum_sgNpx Data.Complex.$fFloatingComplex19; } in
                          let {
                            sat_sgNpB [Occ=Once] :: a_agsO1
                            [LclId] =
                                [a1_sgNpt b_sgNpu $dNum_sgNpx] \u []
                                    let {
                                      sat_sgNpA [Occ=Once] :: a_agsO1
                                      [LclId] =
                                          [b_sgNpu $dNum_sgNpx] \u []
                                              GHC.Num.* $dNum_sgNpx b_sgNpu b_sgNpu; } in
                                    let {
                                      sat_sgNpz [Occ=Once] :: a_agsO1
                                      [LclId] =
                                          [a1_sgNpt $dNum_sgNpx] \u []
                                              GHC.Num.* $dNum_sgNpx a1_sgNpt a1_sgNpt;
                                    } in  GHC.Num.+ $dNum_sgNpx sat_sgNpz sat_sgNpA;
                          } in 
                            case GHC.Real.$p2Real $dReal_sgNpw of sat_sgNpy {
                              __DEFAULT ->
                                  case GHC.Classes.< sat_sgNpy sat_sgNpB sat_sgNpC of {
                                    GHC.Types.False ->
                                        case
                                            Data.Complex.$w$cexp $dRealFloat_sgNpq a1_sgNpt b_sgNpu
                                        of
                                        { (#,#) ww1_sgNpF [Occ=Once] ww2_sgNpG [Occ=Once] ->
                                              case
                                                  Data.Complex.$w$cfromInteger
                                                      $dRealFloat_sgNpq
                                                      Data.Complex.$fFloatingComplex19
                                              of
                                              { (#,#) ww4_sgNpI [Occ=Once] ww5_sgNpJ [Occ=Once] ->
                                                    case
                                                        Data.Complex.$w$c-
                                                            $dRealFloat_sgNpq
                                                            ww1_sgNpF
                                                            ww2_sgNpG
                                                            ww4_sgNpI
                                                            ww5_sgNpJ
                                                    of
                                                    { (#,#) ww7_sgNpL [Occ=Once]
                                                            ww8_sgNpM [Occ=Once] ->
                                                          Data.Complex.:+ [ww7_sgNpL ww8_sgNpM];
                                                    };
                                              };
                                        };
                                    GHC.Types.True ->
                                        let {
                                          $dFloating_sgNpN [Dmd=<L,U(A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A)>]
                                            :: GHC.Float.Floating a_agsO1
                                          [LclId] =
                                              [$dRealFloat_sgNpq] \u []
                                                  GHC.Float.$p2RealFloat $dRealFloat_sgNpq; } in
                                        let {
                                          u_sgNpO :: a_agsO1
                                          [LclId] =
                                              [a1_sgNpt $dFloating_sgNpN] \u []
                                                  GHC.Float.expm1 $dFloating_sgNpN a1_sgNpt; } in
                                        let {
                                          w_sgNpP :: a_agsO1
                                          [LclId] =
                                              [b_sgNpu
                                               $dRealFrac_sgNpv
                                               $dNum_sgNpx
                                               $dFloating_sgNpN] \u []
                                                  let {
                                                    sat_sgNpW [Occ=Once] :: a_agsO1
                                                    [LclId] =
                                                        [b_sgNpu
                                                         $dRealFrac_sgNpv
                                                         $dNum_sgNpx
                                                         $dFloating_sgNpN] \u []
                                                            let {
                                                              v_sgNpQ :: a_agsO1
                                                              [LclId] =
                                                                  [b_sgNpu
                                                                   $dRealFrac_sgNpv
                                                                   $dNum_sgNpx
                                                                   $dFloating_sgNpN] \u []
                                                                      let {
                                                                        sat_sgNpT [Occ=Once]
                                                                          :: a_agsO1
                                                                        [LclId] =
                                                                            [b_sgNpu
                                                                             $dRealFrac_sgNpv
                                                                             $dNum_sgNpx] \u []
                                                                                let {
                                                                                  sat_sgNpS [Occ=Once]
                                                                                    :: a_agsO1
                                                                                  [LclId] =
                                                                                      [$dNum_sgNpx] \u []
                                                                                          GHC.Num.fromInteger
                                                                                              $dNum_sgNpx
                                                                                              Data.Complex.$fFloatingComplex21;
                                                                                } in 
                                                                                  case
                                                                                      GHC.Real.$p2RealFrac
                                                                                          $dRealFrac_sgNpv
                                                                                  of
                                                                                  sat_sgNpR
                                                                                  { __DEFAULT ->
                                                                                        GHC.Real./
                                                                                            sat_sgNpR
                                                                                            b_sgNpu
                                                                                            sat_sgNpS;
                                                                                  };
                                                                      } in 
                                                                        GHC.Float.sin
                                                                            $dFloating_sgNpN
                                                                            sat_sgNpT; } in
                                                            let {
                                                              sat_sgNpV [Occ=Once] :: a_agsO1
                                                              [LclId] =
                                                                  [$dNum_sgNpx v_sgNpQ] \u []
                                                                      let {
                                                                        sat_sgNpU [Occ=Once]
                                                                          :: a_agsO1
                                                                        [LclId] =
                                                                            [$dNum_sgNpx] \u []
                                                                                GHC.Num.fromInteger
                                                                                    $dNum_sgNpx
                                                                                    Data.Complex.$fFloatingComplex21;
                                                                      } in 
                                                                        GHC.Num.*
                                                                            $dNum_sgNpx
                                                                            sat_sgNpU
                                                                            v_sgNpQ;
                                                            } in 
                                                              GHC.Num.*
                                                                  $dNum_sgNpx sat_sgNpV v_sgNpQ;
                                                  } in  GHC.Num.negate $dNum_sgNpx sat_sgNpW; } in
                                        let {
                                          sat_sgNpY [Occ=Once] :: a_agsO1
                                          [LclId] =
                                              [$dNum_sgNpx u_sgNpO w_sgNpP] \u []
                                                  let {
                                                    sat_sgNpX [Occ=Once] :: a_agsO1
                                                    [LclId] =
                                                        [$dNum_sgNpx u_sgNpO w_sgNpP] \u []
                                                            GHC.Num.* $dNum_sgNpx u_sgNpO w_sgNpP;
                                                  } in  GHC.Num.+ $dNum_sgNpx sat_sgNpX u_sgNpO;
                                        } in 
                                          case GHC.Num.+ $dNum_sgNpx sat_sgNpY w_sgNpP of dt_sgNpZ {
                                            __DEFAULT ->
                                                let {
                                                  sat_sgNq2 [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [b_sgNpu $dFloating_sgNpN] \u []
                                                          GHC.Float.sin
                                                              $dFloating_sgNpN b_sgNpu; } in
                                                let {
                                                  sat_sgNq1 [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [$dNum_sgNpx u_sgNpO] \u []
                                                          let {
                                                            sat_sgNq0 [Occ=Once] :: a_agsO1
                                                            [LclId] =
                                                                [$dNum_sgNpx] \u []
                                                                    GHC.Num.fromInteger
                                                                        $dNum_sgNpx
                                                                        Data.Complex.$fFloatingComplex19;
                                                          } in 
                                                            GHC.Num.+ $dNum_sgNpx u_sgNpO sat_sgNq0;
                                                } in 
                                                  case
                                                      GHC.Num.* $dNum_sgNpx sat_sgNq1 sat_sgNq2
                                                  of
                                                  dt1_sgNq3
                                                  { __DEFAULT ->
                                                        Data.Complex.:+ [dt_sgNpZ dt1_sgNq3];
                                                  };
                                          };
                                  };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1p1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNq4]
        case eta_sgNq4 of {
          Data.Complex.:+ a_sgNq6 [Occ=Once!] b_sgNq7 [Occ=Once!] ->
              case a_sgNq6 of {
                GHC.Types.F# x_sgNq9 ->
                    case b_sgNq7 of {
                      GHC.Types.F# y_sgNqb ->
                          case fabsFloat# [x_sgNq9] of sat_sgNqj {
                            __DEFAULT ->
                                let-no-escape {
                                  $j_sgNqc [Occ=Once*T[0], Dmd=<L,1*U(U,U)>]
                                    :: Data.Complex.Complex GHC.Types.Float
                                  [LclId[JoinId(0)], Str=m, Unf=OtherCon []] =
                                      [x_sgNq9 y_sgNqb] \r []
                                          case plusFloat# [1.0# x_sgNq9] of ww_sgNqd [Dmd=<S,U>] {
                                            __DEFAULT ->
                                                case
                                                    Data.Complex.$w$smagnitude1 ww_sgNqd y_sgNqb
                                                of
                                                ww1_sgNqe
                                                { __DEFAULT ->
                                                      case logFloat# [ww1_sgNqe] of wild3_sgNqf {
                                                        __DEFAULT ->
                                                            case
                                                                Data.Complex.$w$sphase1
                                                                    ww_sgNqd y_sgNqb
                                                            of
                                                            ww2_sgNqg
                                                            { __DEFAULT ->
                                                                  let {
                                                                    sat_sgNqi [Occ=Once]
                                                                      :: GHC.Types.Float
                                                                    [LclId] =
                                                                        CCCS GHC.Types.F#! [ww2_sgNqg]; } in
                                                                  let {
                                                                    sat_sgNqh [Occ=Once]
                                                                      :: GHC.Types.Float
                                                                    [LclId] =
                                                                        CCCS GHC.Types.F#! [wild3_sgNqf];
                                                                  } in 
                                                                    Data.Complex.:+ [sat_sgNqh
                                                                                     sat_sgNqi];
                                                            };
                                                      };
                                                };
                                          };
                                } in 
                                  case ltFloat# [sat_sgNqj 0.5#] of {
                                    __DEFAULT -> $j_sgNqc;
                                    1# ->
                                        case fabsFloat# [y_sgNqb] of sat_sgNql {
                                          __DEFAULT ->
                                              case ltFloat# [sat_sgNql 0.5#] of {
                                                __DEFAULT -> $j_sgNqc;
                                                1# ->
                                                    case
                                                        timesFloat# [y_sgNqb y_sgNqb]
                                                    of
                                                    sat_sgNqr
                                                    { __DEFAULT ->
                                                          case
                                                              timesFloat# [x_sgNq9 x_sgNq9]
                                                          of
                                                          sat_sgNqp
                                                          { __DEFAULT ->
                                                                case
                                                                    plusFloat# [x_sgNq9 x_sgNq9]
                                                                of
                                                                sat_sgNqo
                                                                { __DEFAULT ->
                                                                      case
                                                                          plusFloat# [sat_sgNqo
                                                                                      sat_sgNqp]
                                                                      of
                                                                      sat_sgNqq
                                                                      { __DEFAULT ->
                                                                            case
                                                                                plusFloat# [sat_sgNqq
                                                                                            sat_sgNqr]
                                                                            of
                                                                            x1_sgNqn [Dmd=<S,U>]
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      plusFloat# [x1_sgNqn
                                                                                                  1.0#]
                                                                                  of
                                                                                  sat_sgNqs
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            sqrtFloat# [sat_sgNqs]
                                                                                        of
                                                                                        sat_sgNqt
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  plusFloat# [1.0#
                                                                                                              sat_sgNqt]
                                                                                              of
                                                                                              sat_sgNqu
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        divideFloat# [x1_sgNqn
                                                                                                                      sat_sgNqu]
                                                                                                    of
                                                                                                    wild3_sgNqv
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              __pkg_ccall base-4.11.0.0 [wild3_sgNqv
                                                                                                                                         GHC.Prim.realWorld#]
                                                                                                          of
                                                                                                          { (#,#) _ [Occ=Dead]
                                                                                                                  ds4_sgNqz [Occ=Once] ->
                                                                                                                case
                                                                                                                    plusFloat# [1.0#
                                                                                                                                x_sgNq9]
                                                                                                                of
                                                                                                                sat_sgNqA
                                                                                                                { __DEFAULT ->
                                                                                                                      let {
                                                                                                                        sat_sgNqB [Occ=Once]
                                                                                                                          :: GHC.Types.Float
                                                                                                                        [LclId] =
                                                                                                                            CCCS GHC.Types.F#! [sat_sgNqA];
                                                                                                                      } in 
                                                                                                                        case
                                                                                                                            GHC.Float.$w$catan1
                                                                                                                                sat_sgNqB
                                                                                                                                y_sgNqb
                                                                                                                        of
                                                                                                                        ww2_sgNqC
                                                                                                                        { __DEFAULT ->
                                                                                                                              let {
                                                                                                                                sat_sgNqE [Occ=Once]
                                                                                                                                  :: GHC.Types.Float
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.F#! [ww2_sgNqC]; } in
                                                                                                                              let {
                                                                                                                                sat_sgNqD [Occ=Once]
                                                                                                                                  :: GHC.Types.Float
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.F#! [ds4_sgNqz];
                                                                                                                              } in 
                                                                                                                                Data.Complex.:+ [sat_sgNqD
                                                                                                                                                 sat_sgNqE];
                                                                                                                        };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                        };
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1p [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNqF]
        case eta_sgNqF of {
          Data.Complex.:+ a_sgNqH [Occ=Once!] b_sgNqI [Occ=Once!] ->
              case a_sgNqH of {
                GHC.Types.D# x_sgNqK ->
                    case b_sgNqI of {
                      GHC.Types.D# y_sgNqM ->
                          case fabsDouble# [x_sgNqK] of sat_sgNqU {
                            __DEFAULT ->
                                let-no-escape {
                                  $j_sgNqN [Occ=Once*T[0], Dmd=<L,1*U(U,U)>]
                                    :: Data.Complex.Complex GHC.Types.Double
                                  [LclId[JoinId(0)], Str=m, Unf=OtherCon []] =
                                      [x_sgNqK y_sgNqM] \r []
                                          case +## [1.0## x_sgNqK] of ww_sgNqO [Dmd=<S,U>] {
                                            __DEFAULT ->
                                                case
                                                    Data.Complex.$w$smagnitude ww_sgNqO y_sgNqM
                                                of
                                                ww1_sgNqP
                                                { __DEFAULT ->
                                                      case logDouble# [ww1_sgNqP] of wild3_sgNqQ {
                                                        __DEFAULT ->
                                                            case
                                                                Data.Complex.$w$sphase
                                                                    ww_sgNqO y_sgNqM
                                                            of
                                                            ww2_sgNqR
                                                            { __DEFAULT ->
                                                                  let {
                                                                    sat_sgNqT [Occ=Once]
                                                                      :: GHC.Types.Double
                                                                    [LclId] =
                                                                        CCCS GHC.Types.D#! [ww2_sgNqR]; } in
                                                                  let {
                                                                    sat_sgNqS [Occ=Once]
                                                                      :: GHC.Types.Double
                                                                    [LclId] =
                                                                        CCCS GHC.Types.D#! [wild3_sgNqQ];
                                                                  } in 
                                                                    Data.Complex.:+ [sat_sgNqS
                                                                                     sat_sgNqT];
                                                            };
                                                      };
                                                };
                                          };
                                } in 
                                  case <## [sat_sgNqU 0.5##] of {
                                    __DEFAULT -> $j_sgNqN;
                                    1# ->
                                        case fabsDouble# [y_sgNqM] of sat_sgNqW {
                                          __DEFAULT ->
                                              case <## [sat_sgNqW 0.5##] of {
                                                __DEFAULT -> $j_sgNqN;
                                                1# ->
                                                    case *## [y_sgNqM y_sgNqM] of sat_sgNr2 {
                                                      __DEFAULT ->
                                                          case *## [x_sgNqK x_sgNqK] of sat_sgNr0 {
                                                            __DEFAULT ->
                                                                case
                                                                    +## [x_sgNqK x_sgNqK]
                                                                of
                                                                sat_sgNqZ
                                                                { __DEFAULT ->
                                                                      case
                                                                          +## [sat_sgNqZ sat_sgNr0]
                                                                      of
                                                                      sat_sgNr1
                                                                      { __DEFAULT ->
                                                                            case
                                                                                +## [sat_sgNr1
                                                                                     sat_sgNr2]
                                                                            of
                                                                            x1_sgNqY [Dmd=<S,U>]
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      +## [x1_sgNqY
                                                                                           1.0##]
                                                                                  of
                                                                                  sat_sgNr3
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            sqrtDouble# [sat_sgNr3]
                                                                                        of
                                                                                        sat_sgNr4
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  +## [1.0##
                                                                                                       sat_sgNr4]
                                                                                              of
                                                                                              sat_sgNr5
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        /## [x1_sgNqY
                                                                                                             sat_sgNr5]
                                                                                                    of
                                                                                                    wild3_sgNr6
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              __pkg_ccall base-4.11.0.0 [wild3_sgNr6
                                                                                                                                         GHC.Prim.realWorld#]
                                                                                                          of
                                                                                                          { (#,#) _ [Occ=Dead]
                                                                                                                  ds4_sgNra [Occ=Once] ->
                                                                                                                case
                                                                                                                    +## [1.0##
                                                                                                                         x_sgNqK]
                                                                                                                of
                                                                                                                sat_sgNrb
                                                                                                                { __DEFAULT ->
                                                                                                                      let {
                                                                                                                        sat_sgNrc [Occ=Once]
                                                                                                                          :: GHC.Types.Double
                                                                                                                        [LclId] =
                                                                                                                            CCCS GHC.Types.D#! [sat_sgNrb];
                                                                                                                      } in 
                                                                                                                        case
                                                                                                                            GHC.Float.$w$catan2
                                                                                                                                sat_sgNrc
                                                                                                                                y_sgNqM
                                                                                                                        of
                                                                                                                        ww2_sgNrd
                                                                                                                        { __DEFAULT ->
                                                                                                                              let {
                                                                                                                                sat_sgNrf [Occ=Once]
                                                                                                                                  :: GHC.Types.Double
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.D#! [ww2_sgNrd]; } in
                                                                                                                              let {
                                                                                                                                sat_sgNre [Occ=Once]
                                                                                                                                  :: GHC.Types.Double
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.D#! [ds4_sgNra];
                                                                                                                              } in 
                                                                                                                                Data.Complex.:+ [sat_sgNre
                                                                                                                                                 sat_sgNrf];
                                                                                                                        };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                        };
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clog1p [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgNrg eta_sgNrh]
        case eta_sgNrh of {
          Data.Complex.:+ a1_sgNrj b_sgNrk ->
              case
                  GHC.Float.$p1RealFloat $dRealFloat_sgNrg
              of
              $dRealFrac_sgNrl [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1RealFrac $dRealFrac_sgNrl
                    of
                    $dReal_sgNrm [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
                    { __DEFAULT ->
                          let {
                            $dNum_sgNrn [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
                              :: GHC.Num.Num a_agsO1
                            [LclId] =
                                [$dReal_sgNrm] \u [] GHC.Real.$p1Real $dReal_sgNrm;
                          } in 
                            case
                                GHC.Real.$p2Real $dReal_sgNrm
                            of
                            $dOrd_sgNro [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                            { __DEFAULT ->
                                  let {
                                    $dFractional_sgNrp [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
                                      :: GHC.Real.Fractional a_agsO1
                                    [LclId] =
                                        [$dRealFrac_sgNrl] \u []
                                            GHC.Real.$p2RealFrac $dRealFrac_sgNrl; } in
                                  let {
                                    sat_sgNrr [Occ=Once] :: a_agsO1
                                    [LclId] =
                                        [$dFractional_sgNrp] \u []
                                            GHC.Real.fromRational
                                                $dFractional_sgNrp
                                                Data.Complex.$fFloatingComplex20; } in
                                  let {
                                    sat_sgNrq [Occ=Once] :: a_agsO1
                                    [LclId] =
                                        [a1_sgNrj $dNum_sgNrn] \u []
                                            GHC.Num.abs $dNum_sgNrn a1_sgNrj;
                                  } in 
                                    case GHC.Classes.< $dOrd_sgNro sat_sgNrq sat_sgNrr of {
                                      GHC.Types.False ->
                                          case
                                              Data.Complex.$w$cfromInteger
                                                  $dRealFloat_sgNrg Data.Complex.$fFloatingComplex19
                                          of
                                          { (#,#) ww1_sgNru [Occ=Once] ww2_sgNrv [Occ=Once] ->
                                                case
                                                    Data.Complex.$w$c+
                                                        $dRealFloat_sgNrg
                                                        ww1_sgNru
                                                        ww2_sgNrv
                                                        a1_sgNrj
                                                        b_sgNrk
                                                of
                                                { (#,#) ww4_sgNrx [Occ=Once] ww5_sgNry [Occ=Once] ->
                                                      case
                                                          Data.Complex.$w$clog
                                                              $dRealFloat_sgNrg ww4_sgNrx ww5_sgNry
                                                      of
                                                      { (#,#) ww7_sgNrA [Occ=Once]
                                                              ww8_sgNrB [Occ=Once] ->
                                                            Data.Complex.:+ [ww7_sgNrA ww8_sgNrB];
                                                      };
                                                };
                                          };
                                      GHC.Types.True ->
                                          let {
                                            sat_sgNrD [Occ=Once] :: a_agsO1
                                            [LclId] =
                                                [$dFractional_sgNrp] \u []
                                                    GHC.Real.fromRational
                                                        $dFractional_sgNrp
                                                        Data.Complex.$fFloatingComplex20; } in
                                          let {
                                            sat_sgNrC [Occ=Once] :: a_agsO1
                                            [LclId] =
                                                [b_sgNrk $dNum_sgNrn] \u []
                                                    GHC.Num.abs $dNum_sgNrn b_sgNrk;
                                          } in 
                                            case GHC.Classes.< $dOrd_sgNro sat_sgNrC sat_sgNrD of {
                                              GHC.Types.False ->
                                                  case
                                                      Data.Complex.$w$cfromInteger
                                                          $dRealFloat_sgNrg
                                                          Data.Complex.$fFloatingComplex19
                                                  of
                                                  { (#,#) ww1_sgNrG [Occ=Once]
                                                          ww2_sgNrH [Occ=Once] ->
                                                        case
                                                            Data.Complex.$w$c+
                                                                $dRealFloat_sgNrg
                                                                ww1_sgNrG
                                                                ww2_sgNrH
                                                                a1_sgNrj
                                                                b_sgNrk
                                                        of
                                                        { (#,#) ww4_sgNrJ [Occ=Once]
                                                                ww5_sgNrK [Occ=Once] ->
                                                              case
                                                                  Data.Complex.$w$clog
                                                                      $dRealFloat_sgNrg
                                                                      ww4_sgNrJ
                                                                      ww5_sgNrK
                                                              of
                                                              { (#,#) ww7_sgNrM [Occ=Once]
                                                                      ww8_sgNrN [Occ=Once] ->
                                                                    Data.Complex.:+ [ww7_sgNrM
                                                                                     ww8_sgNrN];
                                                              };
                                                        };
                                                  };
                                              GHC.Types.True ->
                                                  case
                                                      GHC.Float.$p2RealFloat $dRealFloat_sgNrg
                                                  of
                                                  $dFloating_sgNrO [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_sgNs0 [Occ=Once] :: a_agsO1
                                                          [LclId] =
                                                              [a1_sgNrj
                                                               b_sgNrk
                                                               $dNum_sgNrn
                                                               $dFractional_sgNrp
                                                               $dFloating_sgNrO] \u []
                                                                  let {
                                                                    u_sgNrP :: a_agsO1
                                                                    [LclId] =
                                                                        [a1_sgNrj
                                                                         b_sgNrk
                                                                         $dNum_sgNrn] \u []
                                                                            let {
                                                                              sat_sgNrU [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [b_sgNrk
                                                                                   $dNum_sgNrn] \u []
                                                                                      GHC.Num.*
                                                                                          $dNum_sgNrn
                                                                                          b_sgNrk
                                                                                          b_sgNrk; } in
                                                                            let {
                                                                              sat_sgNrT [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [a1_sgNrj
                                                                                   $dNum_sgNrn] \u []
                                                                                      let {
                                                                                        sat_sgNrS [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [a1_sgNrj
                                                                                             $dNum_sgNrn] \u []
                                                                                                GHC.Num.*
                                                                                                    $dNum_sgNrn
                                                                                                    a1_sgNrj
                                                                                                    a1_sgNrj; } in
                                                                                      let {
                                                                                        sat_sgNrR [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [a1_sgNrj
                                                                                             $dNum_sgNrn] \u []
                                                                                                let {
                                                                                                  sat_sgNrQ [Occ=Once]
                                                                                                    :: a_agsO1
                                                                                                  [LclId] =
                                                                                                      [$dNum_sgNrn] \u []
                                                                                                          GHC.Num.fromInteger
                                                                                                              $dNum_sgNrn
                                                                                                              Data.Complex.$fFloatingComplex21;
                                                                                                } in 
                                                                                                  GHC.Num.*
                                                                                                      $dNum_sgNrn
                                                                                                      sat_sgNrQ
                                                                                                      a1_sgNrj;
                                                                                      } in 
                                                                                        GHC.Num.+
                                                                                            $dNum_sgNrn
                                                                                            sat_sgNrR
                                                                                            sat_sgNrS;
                                                                            } in 
                                                                              GHC.Num.+
                                                                                  $dNum_sgNrn
                                                                                  sat_sgNrT
                                                                                  sat_sgNrU; } in
                                                                  let {
                                                                    sat_sgNrZ [Occ=Once] :: a_agsO1
                                                                    [LclId] =
                                                                        [$dNum_sgNrn
                                                                         $dFloating_sgNrO
                                                                         u_sgNrP] \u []
                                                                            let {
                                                                              sat_sgNrY [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [$dNum_sgNrn
                                                                                   $dFloating_sgNrO
                                                                                   u_sgNrP] \u []
                                                                                      let {
                                                                                        sat_sgNrX [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [$dNum_sgNrn
                                                                                             u_sgNrP] \u []
                                                                                                let {
                                                                                                  sat_sgNrW [Occ=Once]
                                                                                                    :: a_agsO1
                                                                                                  [LclId] =
                                                                                                      [$dNum_sgNrn] \u []
                                                                                                          GHC.Num.fromInteger
                                                                                                              $dNum_sgNrn
                                                                                                              Data.Complex.$fFloatingComplex19;
                                                                                                } in 
                                                                                                  GHC.Num.+
                                                                                                      $dNum_sgNrn
                                                                                                      u_sgNrP
                                                                                                      sat_sgNrW;
                                                                                      } in 
                                                                                        GHC.Float.sqrt
                                                                                            $dFloating_sgNrO
                                                                                            sat_sgNrX; } in
                                                                            let {
                                                                              sat_sgNrV [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [$dNum_sgNrn] \u []
                                                                                      GHC.Num.fromInteger
                                                                                          $dNum_sgNrn
                                                                                          Data.Complex.$fFloatingComplex19;
                                                                            } in 
                                                                              GHC.Num.+
                                                                                  $dNum_sgNrn
                                                                                  sat_sgNrV
                                                                                  sat_sgNrY;
                                                                  } in 
                                                                    GHC.Real./
                                                                        $dFractional_sgNrp
                                                                        u_sgNrP
                                                                        sat_sgNrZ;
                                                        } in 
                                                          case
                                                              GHC.Float.log1p
                                                                  $dFloating_sgNrO sat_sgNs0
                                                          of
                                                          dt_sgNs1
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgNs3 [Occ=Once] :: a_agsO1
                                                                  [LclId] =
                                                                      [a1_sgNrj $dNum_sgNrn] \u []
                                                                          let {
                                                                            sat_sgNs2 [Occ=Once]
                                                                              :: a_agsO1
                                                                            [LclId] =
                                                                                [$dNum_sgNrn] \u []
                                                                                    GHC.Num.fromInteger
                                                                                        $dNum_sgNrn
                                                                                        Data.Complex.$fFloatingComplex19;
                                                                          } in 
                                                                            GHC.Num.+
                                                                                $dNum_sgNrn
                                                                                sat_sgNs2
                                                                                a1_sgNrj;
                                                                } in 
                                                                  case
                                                                      GHC.Float.atan2
                                                                          $dRealFloat_sgNrg
                                                                          sat_sgNs3
                                                                          b_sgNrk
                                                                  of
                                                                  dt1_sgNs4
                                                                  { __DEFAULT ->
                                                                        Data.Complex.:+ [dt_sgNs1
                                                                                         dt1_sgNs4];
                                                                  };
                                                          };
                                                  };
                                            };
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1mexp1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNs5]
        case eta_sgNs5 of {
          Data.Complex.:+ x_sgNs7 [Occ=Once!] y_sgNs8 [Occ=Once!] ->
              case x_sgNs7 of {
                GHC.Types.F# x1_sgNsa [Occ=Once] ->
                    case y_sgNs8 of {
                      GHC.Types.F# x2_sgNsc ->
                          case expFloat# [x1_sgNsa] of expx_sgNsd [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosFloat# [x2_sgNsc] of sat_sgNsf {
                                  __DEFAULT ->
                                      case timesFloat# [expx_sgNsd sat_sgNsf] of sat_sgNsg {
                                        __DEFAULT ->
                                            case negateFloat# [sat_sgNsg] of dt_sgNse [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case sinFloat# [x2_sgNsc] of sat_sgNsi {
                                                    __DEFAULT ->
                                                        case
                                                            timesFloat# [expx_sgNsd sat_sgNsi]
                                                        of
                                                        sat_sgNsj
                                                        { __DEFAULT ->
                                                              case
                                                                  negateFloat# [sat_sgNsj]
                                                              of
                                                              dt1_sgNsh [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        fabsFloat# [dt_sgNse]
                                                                    of
                                                                    sat_sgNsr
                                                                    { __DEFAULT ->
                                                                          let-no-escape {
                                                                            $j_sgNsk [Occ=Once*T[0],
                                                                                      Dmd=<L,1*U(U,U)>]
                                                                              :: Data.Complex.Complex
                                                                                   GHC.Types.Float
                                                                            [LclId[JoinId(0)],
                                                                             Str=m,
                                                                             Unf=OtherCon []] =
                                                                                [dt_sgNse
                                                                                 dt1_sgNsh] \r []
                                                                                    case
                                                                                        plusFloat# [1.0#
                                                                                                    dt_sgNse]
                                                                                    of
                                                                                    dt2_sgNsl [Dmd=<S,U>]
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$smagnitude1
                                                                                                  dt2_sgNsl
                                                                                                  dt1_sgNsh
                                                                                          of
                                                                                          ww_sgNsm
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    logFloat# [ww_sgNsm]
                                                                                                of
                                                                                                wild3_sgNsn
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          Data.Complex.$w$sphase1
                                                                                                              dt2_sgNsl
                                                                                                              dt1_sgNsh
                                                                                                      of
                                                                                                      ww1_sgNso
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgNsq [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [ww1_sgNso]; } in
                                                                                                            let {
                                                                                                              sat_sgNsp [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [wild3_sgNsn];
                                                                                                            } in 
                                                                                                              Data.Complex.:+ [sat_sgNsp
                                                                                                                               sat_sgNsq];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                          } in 
                                                                            case
                                                                                ltFloat# [sat_sgNsr
                                                                                          0.5#]
                                                                            of
                                                                            { __DEFAULT -> $j_sgNsk;
                                                                              1# ->
                                                                                  case
                                                                                      fabsFloat# [dt1_sgNsh]
                                                                                  of
                                                                                  sat_sgNst
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            ltFloat# [sat_sgNst
                                                                                                      0.5#]
                                                                                        of
                                                                                        { __DEFAULT ->
                                                                                              $j_sgNsk;
                                                                                          1# ->
                                                                                              case
                                                                                                  timesFloat# [dt1_sgNsh
                                                                                                               dt1_sgNsh]
                                                                                              of
                                                                                              sat_sgNsz
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        timesFloat# [dt_sgNse
                                                                                                                     dt_sgNse]
                                                                                                    of
                                                                                                    sat_sgNsx
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              plusFloat# [dt_sgNse
                                                                                                                          dt_sgNse]
                                                                                                          of
                                                                                                          sat_sgNsw
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    plusFloat# [sat_sgNsw
                                                                                                                                sat_sgNsx]
                                                                                                                of
                                                                                                                sat_sgNsy
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          plusFloat# [sat_sgNsy
                                                                                                                                      sat_sgNsz]
                                                                                                                      of
                                                                                                                      u_sgNsv [Dmd=<S,U>]
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                plusFloat# [u_sgNsv
                                                                                                                                            1.0#]
                                                                                                                            of
                                                                                                                            sat_sgNsA
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sqrtFloat# [sat_sgNsA]
                                                                                                                                  of
                                                                                                                                  sat_sgNsB
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            plusFloat# [1.0#
                                                                                                                                                        sat_sgNsB]
                                                                                                                                        of
                                                                                                                                        sat_sgNsC
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              case
                                                                                                                                                  divideFloat# [u_sgNsv
                                                                                                                                                                sat_sgNsC]
                                                                                                                                              of
                                                                                                                                              wild3_sgNsD
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    case
                                                                                                                                                        __pkg_ccall base-4.11.0.0 [wild3_sgNsD
                                                                                                                                                                                   GHC.Prim.realWorld#]
                                                                                                                                                    of
                                                                                                                                                    { (#,#) _ [Occ=Dead]
                                                                                                                                                            ds4_sgNsH [Occ=Once] ->
                                                                                                                                                          case
                                                                                                                                                              plusFloat# [1.0#
                                                                                                                                                                          dt_sgNse]
                                                                                                                                                          of
                                                                                                                                                          sat_sgNsI
                                                                                                                                                          { __DEFAULT ->
                                                                                                                                                                let {
                                                                                                                                                                  sat_sgNsJ [Occ=Once]
                                                                                                                                                                    :: GHC.Types.Float
                                                                                                                                                                  [LclId] =
                                                                                                                                                                      CCCS GHC.Types.F#! [sat_sgNsI];
                                                                                                                                                                } in 
                                                                                                                                                                  case
                                                                                                                                                                      GHC.Float.$w$catan1
                                                                                                                                                                          sat_sgNsJ
                                                                                                                                                                          dt1_sgNsh
                                                                                                                                                                  of
                                                                                                                                                                  ww2_sgNsK
                                                                                                                                                                  { __DEFAULT ->
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgNsM [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Float
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.F#! [ww2_sgNsK]; } in
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgNsL [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Float
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.F#! [ds4_sgNsH];
                                                                                                                                                                        } in 
                                                                                                                                                                          Data.Complex.:+ [sat_sgNsL
                                                                                                                                                                                           sat_sgNsM];
                                                                                                                                                                  };
                                                                                                                                                          };
                                                                                                                                                    };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNsN]
        case eta_sgNsN of {
          Data.Complex.:+ x_sgNsP [Occ=Once!] y_sgNsQ [Occ=Once!] ->
              case x_sgNsP of {
                GHC.Types.D# x1_sgNsS [Occ=Once] ->
                    case y_sgNsQ of {
                      GHC.Types.D# x2_sgNsU ->
                          case expDouble# [x1_sgNsS] of expx_sgNsV [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosDouble# [x2_sgNsU] of sat_sgNsX {
                                  __DEFAULT ->
                                      case *## [expx_sgNsV sat_sgNsX] of sat_sgNsY {
                                        __DEFAULT ->
                                            case negateDouble# [sat_sgNsY] of dt_sgNsW [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case sinDouble# [x2_sgNsU] of sat_sgNt0 {
                                                    __DEFAULT ->
                                                        case
                                                            *## [expx_sgNsV sat_sgNt0]
                                                        of
                                                        sat_sgNt1
                                                        { __DEFAULT ->
                                                              case
                                                                  negateDouble# [sat_sgNt1]
                                                              of
                                                              dt1_sgNsZ [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        fabsDouble# [dt_sgNsW]
                                                                    of
                                                                    sat_sgNt9
                                                                    { __DEFAULT ->
                                                                          let-no-escape {
                                                                            $j_sgNt2 [Occ=Once*T[0],
                                                                                      Dmd=<L,1*U(U,U)>]
                                                                              :: Data.Complex.Complex
                                                                                   GHC.Types.Double
                                                                            [LclId[JoinId(0)],
                                                                             Str=m,
                                                                             Unf=OtherCon []] =
                                                                                [dt_sgNsW
                                                                                 dt1_sgNsZ] \r []
                                                                                    case
                                                                                        +## [1.0##
                                                                                             dt_sgNsW]
                                                                                    of
                                                                                    dt2_sgNt3 [Dmd=<S,U>]
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$smagnitude
                                                                                                  dt2_sgNt3
                                                                                                  dt1_sgNsZ
                                                                                          of
                                                                                          ww_sgNt4
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    logDouble# [ww_sgNt4]
                                                                                                of
                                                                                                wild3_sgNt5
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          Data.Complex.$w$sphase
                                                                                                              dt2_sgNt3
                                                                                                              dt1_sgNsZ
                                                                                                      of
                                                                                                      ww1_sgNt6
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgNt8 [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [ww1_sgNt6]; } in
                                                                                                            let {
                                                                                                              sat_sgNt7 [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [wild3_sgNt5];
                                                                                                            } in 
                                                                                                              Data.Complex.:+ [sat_sgNt7
                                                                                                                               sat_sgNt8];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                          } in 
                                                                            case
                                                                                <## [sat_sgNt9
                                                                                     0.5##]
                                                                            of
                                                                            { __DEFAULT -> $j_sgNt2;
                                                                              1# ->
                                                                                  case
                                                                                      fabsDouble# [dt1_sgNsZ]
                                                                                  of
                                                                                  sat_sgNtb
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            <## [sat_sgNtb
                                                                                                 0.5##]
                                                                                        of
                                                                                        { __DEFAULT ->
                                                                                              $j_sgNt2;
                                                                                          1# ->
                                                                                              case
                                                                                                  *## [dt1_sgNsZ
                                                                                                       dt1_sgNsZ]
                                                                                              of
                                                                                              sat_sgNth
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        *## [dt_sgNsW
                                                                                                             dt_sgNsW]
                                                                                                    of
                                                                                                    sat_sgNtf
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              +## [dt_sgNsW
                                                                                                                   dt_sgNsW]
                                                                                                          of
                                                                                                          sat_sgNte
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    +## [sat_sgNte
                                                                                                                         sat_sgNtf]
                                                                                                                of
                                                                                                                sat_sgNtg
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          +## [sat_sgNtg
                                                                                                                               sat_sgNth]
                                                                                                                      of
                                                                                                                      u_sgNtd [Dmd=<S,U>]
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                +## [u_sgNtd
                                                                                                                                     1.0##]
                                                                                                                            of
                                                                                                                            sat_sgNti
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sqrtDouble# [sat_sgNti]
                                                                                                                                  of
                                                                                                                                  sat_sgNtj
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            +## [1.0##
                                                                                                                                                 sat_sgNtj]
                                                                                                                                        of
                                                                                                                                        sat_sgNtk
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              case
                                                                                                                                                  /## [u_sgNtd
                                                                                                                                                       sat_sgNtk]
                                                                                                                                              of
                                                                                                                                              wild3_sgNtl
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    case
                                                                                                                                                        __pkg_ccall base-4.11.0.0 [wild3_sgNtl
                                                                                                                                                                                   GHC.Prim.realWorld#]
                                                                                                                                                    of
                                                                                                                                                    { (#,#) _ [Occ=Dead]
                                                                                                                                                            ds4_sgNtp [Occ=Once] ->
                                                                                                                                                          case
                                                                                                                                                              +## [1.0##
                                                                                                                                                                   dt_sgNsW]
                                                                                                                                                          of
                                                                                                                                                          sat_sgNtq
                                                                                                                                                          { __DEFAULT ->
                                                                                                                                                                let {
                                                                                                                                                                  sat_sgNtr [Occ=Once]
                                                                                                                                                                    :: GHC.Types.Double
                                                                                                                                                                  [LclId] =
                                                                                                                                                                      CCCS GHC.Types.D#! [sat_sgNtq];
                                                                                                                                                                } in 
                                                                                                                                                                  case
                                                                                                                                                                      GHC.Float.$w$catan2
                                                                                                                                                                          sat_sgNtr
                                                                                                                                                                          dt1_sgNsZ
                                                                                                                                                                  of
                                                                                                                                                                  ww2_sgNts
                                                                                                                                                                  { __DEFAULT ->
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgNtu [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Double
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.D#! [ww2_sgNts]; } in
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgNtt [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Double
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.D#! [ds4_sgNtp];
                                                                                                                                                                        } in 
                                                                                                                                                                          Data.Complex.:+ [sat_sgNtt
                                                                                                                                                                                           sat_sgNtu];
                                                                                                                                                                  };
                                                                                                                                                          };
                                                                                                                                                    };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)S(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgNtv eta_sgNtw]
        case eta_sgNtw of {
          Data.Complex.:+ ww1_sgNty [Occ=Once] ww2_sgNtz [Occ=Once] ->
              case
                  Data.Complex.$w$cexp $dRealFloat_sgNtv ww1_sgNty ww2_sgNtz
              of
              { (#,#) ww4_sgNtB [Occ=Once] ww5_sgNtC [Occ=Once] ->
                    case
                        Data.Complex.$w$cnegate $dRealFloat_sgNtv ww4_sgNtB ww5_sgNtC
                    of
                    { (#,#) ww7_sgNtE ww8_sgNtF ->
                          case
                              GHC.Float.$p1RealFloat $dRealFloat_sgNtv
                          of
                          $dRealFrac_sgNtG [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
                          { __DEFAULT ->
                                case
                                    GHC.Real.$p1RealFrac $dRealFrac_sgNtG
                                of
                                $dReal_sgNtH [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
                                { __DEFAULT ->
                                      let {
                                        $dNum_sgNtI [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
                                          :: GHC.Num.Num a_agsO1
                                        [LclId] =
                                            [$dReal_sgNtH] \u [] GHC.Real.$p1Real $dReal_sgNtH;
                                      } in 
                                        case
                                            GHC.Real.$p2Real $dReal_sgNtH
                                        of
                                        $dOrd_sgNtJ [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                                        { __DEFAULT ->
                                              let {
                                                $dFractional_sgNtK [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
                                                  :: GHC.Real.Fractional a_agsO1
                                                [LclId] =
                                                    [$dRealFrac_sgNtG] \u []
                                                        GHC.Real.$p2RealFrac $dRealFrac_sgNtG; } in
                                              let {
                                                sat_sgNtM [Occ=Once] :: a_agsO1
                                                [LclId] =
                                                    [$dFractional_sgNtK] \u []
                                                        GHC.Real.fromRational
                                                            $dFractional_sgNtK
                                                            Data.Complex.$fFloatingComplex20; } in
                                              let {
                                                sat_sgNtL [Occ=Once] :: a_agsO1
                                                [LclId] =
                                                    [ww7_sgNtE $dNum_sgNtI] \u []
                                                        GHC.Num.abs $dNum_sgNtI ww7_sgNtE;
                                              } in 
                                                case
                                                    GHC.Classes.< $dOrd_sgNtJ sat_sgNtL sat_sgNtM
                                                of
                                                { GHC.Types.False ->
                                                      case
                                                          Data.Complex.$w$cfromInteger
                                                              $dRealFloat_sgNtv
                                                              Data.Complex.$fFloatingComplex19
                                                      of
                                                      { (#,#) ww10_sgNtP [Occ=Once]
                                                              ww11_sgNtQ [Occ=Once] ->
                                                            case
                                                                Data.Complex.$w$c+
                                                                    $dRealFloat_sgNtv
                                                                    ww10_sgNtP
                                                                    ww11_sgNtQ
                                                                    ww7_sgNtE
                                                                    ww8_sgNtF
                                                            of
                                                            { (#,#) ww13_sgNtS [Occ=Once]
                                                                    ww14_sgNtT [Occ=Once] ->
                                                                  case
                                                                      Data.Complex.$w$clog
                                                                          $dRealFloat_sgNtv
                                                                          ww13_sgNtS
                                                                          ww14_sgNtT
                                                                  of
                                                                  { (#,#) ww16_sgNtV [Occ=Once]
                                                                          ww17_sgNtW [Occ=Once] ->
                                                                        Data.Complex.:+ [ww16_sgNtV
                                                                                         ww17_sgNtW];
                                                                  };
                                                            };
                                                      };
                                                  GHC.Types.True ->
                                                      let {
                                                        sat_sgNtY [Occ=Once] :: a_agsO1
                                                        [LclId] =
                                                            [$dFractional_sgNtK] \u []
                                                                GHC.Real.fromRational
                                                                    $dFractional_sgNtK
                                                                    Data.Complex.$fFloatingComplex20; } in
                                                      let {
                                                        sat_sgNtX [Occ=Once] :: a_agsO1
                                                        [LclId] =
                                                            [ww8_sgNtF $dNum_sgNtI] \u []
                                                                GHC.Num.abs $dNum_sgNtI ww8_sgNtF;
                                                      } in 
                                                        case
                                                            GHC.Classes.<
                                                                $dOrd_sgNtJ sat_sgNtX sat_sgNtY
                                                        of
                                                        { GHC.Types.False ->
                                                              case
                                                                  Data.Complex.$w$cfromInteger
                                                                      $dRealFloat_sgNtv
                                                                      Data.Complex.$fFloatingComplex19
                                                              of
                                                              { (#,#) ww10_sgNu1 [Occ=Once]
                                                                      ww11_sgNu2 [Occ=Once] ->
                                                                    case
                                                                        Data.Complex.$w$c+
                                                                            $dRealFloat_sgNtv
                                                                            ww10_sgNu1
                                                                            ww11_sgNu2
                                                                            ww7_sgNtE
                                                                            ww8_sgNtF
                                                                    of
                                                                    { (#,#) ww13_sgNu4 [Occ=Once]
                                                                            ww14_sgNu5 [Occ=Once] ->
                                                                          case
                                                                              Data.Complex.$w$clog
                                                                                  $dRealFloat_sgNtv
                                                                                  ww13_sgNu4
                                                                                  ww14_sgNu5
                                                                          of
                                                                          { (#,#) ww16_sgNu7 [Occ=Once]
                                                                                  ww17_sgNu8 [Occ=Once] ->
                                                                                Data.Complex.:+ [ww16_sgNu7
                                                                                                 ww17_sgNu8];
                                                                          };
                                                                    };
                                                              };
                                                          GHC.Types.True ->
                                                              case
                                                                  GHC.Float.$p2RealFloat
                                                                      $dRealFloat_sgNtv
                                                              of
                                                              $dFloating_sgNu9 [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                                                              { __DEFAULT ->
                                                                    let {
                                                                      sat_sgNul [Occ=Once]
                                                                        :: a_agsO1
                                                                      [LclId] =
                                                                          [ww7_sgNtE
                                                                           ww8_sgNtF
                                                                           $dNum_sgNtI
                                                                           $dFractional_sgNtK
                                                                           $dFloating_sgNu9] \u []
                                                                              let {
                                                                                u_sgNua :: a_agsO1
                                                                                [LclId] =
                                                                                    [ww7_sgNtE
                                                                                     ww8_sgNtF
                                                                                     $dNum_sgNtI] \u []
                                                                                        let {
                                                                                          sat_sgNuf [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [ww8_sgNtF
                                                                                               $dNum_sgNtI] \u []
                                                                                                  GHC.Num.*
                                                                                                      $dNum_sgNtI
                                                                                                      ww8_sgNtF
                                                                                                      ww8_sgNtF; } in
                                                                                        let {
                                                                                          sat_sgNue [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [ww7_sgNtE
                                                                                               $dNum_sgNtI] \u []
                                                                                                  let {
                                                                                                    sat_sgNud [Occ=Once]
                                                                                                      :: a_agsO1
                                                                                                    [LclId] =
                                                                                                        [ww7_sgNtE
                                                                                                         $dNum_sgNtI] \u []
                                                                                                            GHC.Num.*
                                                                                                                $dNum_sgNtI
                                                                                                                ww7_sgNtE
                                                                                                                ww7_sgNtE; } in
                                                                                                  let {
                                                                                                    sat_sgNuc [Occ=Once]
                                                                                                      :: a_agsO1
                                                                                                    [LclId] =
                                                                                                        [ww7_sgNtE
                                                                                                         $dNum_sgNtI] \u []
                                                                                                            let {
                                                                                                              sat_sgNub [Occ=Once]
                                                                                                                :: a_agsO1
                                                                                                              [LclId] =
                                                                                                                  [$dNum_sgNtI] \u []
                                                                                                                      GHC.Num.fromInteger
                                                                                                                          $dNum_sgNtI
                                                                                                                          Data.Complex.$fFloatingComplex21;
                                                                                                            } in 
                                                                                                              GHC.Num.*
                                                                                                                  $dNum_sgNtI
                                                                                                                  sat_sgNub
                                                                                                                  ww7_sgNtE;
                                                                                                  } in 
                                                                                                    GHC.Num.+
                                                                                                        $dNum_sgNtI
                                                                                                        sat_sgNuc
                                                                                                        sat_sgNud;
                                                                                        } in 
                                                                                          GHC.Num.+
                                                                                              $dNum_sgNtI
                                                                                              sat_sgNue
                                                                                              sat_sgNuf; } in
                                                                              let {
                                                                                sat_sgNuk [Occ=Once]
                                                                                  :: a_agsO1
                                                                                [LclId] =
                                                                                    [$dNum_sgNtI
                                                                                     $dFloating_sgNu9
                                                                                     u_sgNua] \u []
                                                                                        let {
                                                                                          sat_sgNuj [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [$dNum_sgNtI
                                                                                               $dFloating_sgNu9
                                                                                               u_sgNua] \u []
                                                                                                  let {
                                                                                                    sat_sgNui [Occ=Once]
                                                                                                      :: a_agsO1
                                                                                                    [LclId] =
                                                                                                        [$dNum_sgNtI
                                                                                                         u_sgNua] \u []
                                                                                                            let {
                                                                                                              sat_sgNuh [Occ=Once]
                                                                                                                :: a_agsO1
                                                                                                              [LclId] =
                                                                                                                  [$dNum_sgNtI] \u []
                                                                                                                      GHC.Num.fromInteger
                                                                                                                          $dNum_sgNtI
                                                                                                                          Data.Complex.$fFloatingComplex19;
                                                                                                            } in 
                                                                                                              GHC.Num.+
                                                                                                                  $dNum_sgNtI
                                                                                                                  u_sgNua
                                                                                                                  sat_sgNuh;
                                                                                                  } in 
                                                                                                    GHC.Float.sqrt
                                                                                                        $dFloating_sgNu9
                                                                                                        sat_sgNui; } in
                                                                                        let {
                                                                                          sat_sgNug [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [$dNum_sgNtI] \u []
                                                                                                  GHC.Num.fromInteger
                                                                                                      $dNum_sgNtI
                                                                                                      Data.Complex.$fFloatingComplex19;
                                                                                        } in 
                                                                                          GHC.Num.+
                                                                                              $dNum_sgNtI
                                                                                              sat_sgNug
                                                                                              sat_sgNuj;
                                                                              } in 
                                                                                GHC.Real./
                                                                                    $dFractional_sgNtK
                                                                                    u_sgNua
                                                                                    sat_sgNuk;
                                                                    } in 
                                                                      case
                                                                          GHC.Float.log1p
                                                                              $dFloating_sgNu9
                                                                              sat_sgNul
                                                                      of
                                                                      dt_sgNum
                                                                      { __DEFAULT ->
                                                                            let {
                                                                              sat_sgNuo [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [ww7_sgNtE
                                                                                   $dNum_sgNtI] \u []
                                                                                      let {
                                                                                        sat_sgNun [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [$dNum_sgNtI] \u []
                                                                                                GHC.Num.fromInteger
                                                                                                    $dNum_sgNtI
                                                                                                    Data.Complex.$fFloatingComplex19;
                                                                                      } in 
                                                                                        GHC.Num.+
                                                                                            $dNum_sgNtI
                                                                                            sat_sgNun
                                                                                            ww7_sgNtE;
                                                                            } in 
                                                                              case
                                                                                  GHC.Float.atan2
                                                                                      $dRealFloat_sgNtv
                                                                                      sat_sgNuo
                                                                                      ww8_sgNtF
                                                                              of
                                                                              dt1_sgNup
                                                                              { __DEFAULT ->
                                                                                    Data.Complex.:+ [dt_sgNum
                                                                                                     dt1_sgNup];
                                                                              };
                                                                      };
                                                              };
                                                        };
                                                };
                                        };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1pexp1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNuq]
        case eta_sgNuq of {
          Data.Complex.:+ x_sgNus [Occ=Once!] y_sgNut [Occ=Once!] ->
              case x_sgNus of {
                GHC.Types.F# x1_sgNuv [Occ=Once] ->
                    case y_sgNut of {
                      GHC.Types.F# x2_sgNux ->
                          case expFloat# [x1_sgNuv] of expx_sgNuy [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosFloat# [x2_sgNux] of sat_sgNuA {
                                  __DEFAULT ->
                                      case
                                          timesFloat# [expx_sgNuy sat_sgNuA]
                                      of
                                      a_sgNuz [Dmd=<S,U>]
                                      { __DEFAULT ->
                                            case sinFloat# [x2_sgNux] of sat_sgNuC {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [expx_sgNuy sat_sgNuC]
                                                  of
                                                  b_sgNuB [Dmd=<S,U>]
                                                  { __DEFAULT ->
                                                        case fabsFloat# [a_sgNuz] of sat_sgNuK {
                                                          __DEFAULT ->
                                                              let-no-escape {
                                                                $j_sgNuD [Occ=Once*T[0],
                                                                          Dmd=<L,1*U(U,U)>]
                                                                  :: Data.Complex.Complex
                                                                       GHC.Types.Float
                                                                [LclId[JoinId(0)],
                                                                 Str=m,
                                                                 Unf=OtherCon []] =
                                                                    [a_sgNuz b_sgNuB] \r []
                                                                        case
                                                                            plusFloat# [1.0#
                                                                                        a_sgNuz]
                                                                        of
                                                                        dt_sgNuE [Dmd=<S,U>]
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  Data.Complex.$w$smagnitude1
                                                                                      dt_sgNuE
                                                                                      b_sgNuB
                                                                              of
                                                                              ww_sgNuF
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        logFloat# [ww_sgNuF]
                                                                                    of
                                                                                    wild3_sgNuG
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$sphase1
                                                                                                  dt_sgNuE
                                                                                                  b_sgNuB
                                                                                          of
                                                                                          ww1_sgNuH
                                                                                          { __DEFAULT ->
                                                                                                let {
                                                                                                  sat_sgNuJ [Occ=Once]
                                                                                                    :: GHC.Types.Float
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.F#! [ww1_sgNuH]; } in
                                                                                                let {
                                                                                                  sat_sgNuI [Occ=Once]
                                                                                                    :: GHC.Types.Float
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.F#! [wild3_sgNuG];
                                                                                                } in 
                                                                                                  Data.Complex.:+ [sat_sgNuI
                                                                                                                   sat_sgNuJ];
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                              } in 
                                                                case ltFloat# [sat_sgNuK 0.5#] of {
                                                                  __DEFAULT -> $j_sgNuD;
                                                                  1# ->
                                                                      case
                                                                          fabsFloat# [b_sgNuB]
                                                                      of
                                                                      sat_sgNuM
                                                                      { __DEFAULT ->
                                                                            case
                                                                                ltFloat# [sat_sgNuM
                                                                                          0.5#]
                                                                            of
                                                                            { __DEFAULT -> $j_sgNuD;
                                                                              1# ->
                                                                                  case
                                                                                      timesFloat# [b_sgNuB
                                                                                                   b_sgNuB]
                                                                                  of
                                                                                  sat_sgNuS
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            timesFloat# [a_sgNuz
                                                                                                         a_sgNuz]
                                                                                        of
                                                                                        sat_sgNuQ
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  plusFloat# [a_sgNuz
                                                                                                              a_sgNuz]
                                                                                              of
                                                                                              sat_sgNuP
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        plusFloat# [sat_sgNuP
                                                                                                                    sat_sgNuQ]
                                                                                                    of
                                                                                                    sat_sgNuR
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              plusFloat# [sat_sgNuR
                                                                                                                          sat_sgNuS]
                                                                                                          of
                                                                                                          u_sgNuO [Dmd=<S,U>]
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    plusFloat# [u_sgNuO
                                                                                                                                1.0#]
                                                                                                                of
                                                                                                                sat_sgNuT
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          sqrtFloat# [sat_sgNuT]
                                                                                                                      of
                                                                                                                      sat_sgNuU
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                plusFloat# [1.0#
                                                                                                                                            sat_sgNuU]
                                                                                                                            of
                                                                                                                            sat_sgNuV
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      divideFloat# [u_sgNuO
                                                                                                                                                    sat_sgNuV]
                                                                                                                                  of
                                                                                                                                  wild3_sgNuW
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            __pkg_ccall base-4.11.0.0 [wild3_sgNuW
                                                                                                                                                                       GHC.Prim.realWorld#]
                                                                                                                                        of
                                                                                                                                        { (#,#) _ [Occ=Dead]
                                                                                                                                                ds4_sgNv0 [Occ=Once] ->
                                                                                                                                              case
                                                                                                                                                  plusFloat# [1.0#
                                                                                                                                                              a_sgNuz]
                                                                                                                                              of
                                                                                                                                              sat_sgNv1
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    let {
                                                                                                                                                      sat_sgNv2 [Occ=Once]
                                                                                                                                                        :: GHC.Types.Float
                                                                                                                                                      [LclId] =
                                                                                                                                                          CCCS GHC.Types.F#! [sat_sgNv1];
                                                                                                                                                    } in 
                                                                                                                                                      case
                                                                                                                                                          GHC.Float.$w$catan1
                                                                                                                                                              sat_sgNv2
                                                                                                                                                              b_sgNuB
                                                                                                                                                      of
                                                                                                                                                      ww2_sgNv3
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgNv5 [Occ=Once]
                                                                                                                                                                :: GHC.Types.Float
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.F#! [ww2_sgNv3]; } in
                                                                                                                                                            let {
                                                                                                                                                              sat_sgNv4 [Occ=Once]
                                                                                                                                                                :: GHC.Types.Float
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.F#! [ds4_sgNv0];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgNv4
                                                                                                                                                                               sat_sgNv5];
                                                                                                                                                      };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNv6]
        case eta_sgNv6 of {
          Data.Complex.:+ x_sgNv8 [Occ=Once!] y_sgNv9 [Occ=Once!] ->
              case x_sgNv8 of {
                GHC.Types.D# x1_sgNvb [Occ=Once] ->
                    case y_sgNv9 of {
                      GHC.Types.D# x2_sgNvd ->
                          case expDouble# [x1_sgNvb] of expx_sgNve [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosDouble# [x2_sgNvd] of sat_sgNvg {
                                  __DEFAULT ->
                                      case *## [expx_sgNve sat_sgNvg] of a_sgNvf [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinDouble# [x2_sgNvd] of sat_sgNvi {
                                              __DEFAULT ->
                                                  case
                                                      *## [expx_sgNve sat_sgNvi]
                                                  of
                                                  b_sgNvh [Dmd=<S,U>]
                                                  { __DEFAULT ->
                                                        case fabsDouble# [a_sgNvf] of sat_sgNvq {
                                                          __DEFAULT ->
                                                              let-no-escape {
                                                                $j_sgNvj [Occ=Once*T[0],
                                                                          Dmd=<L,1*U(U,U)>]
                                                                  :: Data.Complex.Complex
                                                                       GHC.Types.Double
                                                                [LclId[JoinId(0)],
                                                                 Str=m,
                                                                 Unf=OtherCon []] =
                                                                    [a_sgNvf b_sgNvh] \r []
                                                                        case
                                                                            +## [1.0## a_sgNvf]
                                                                        of
                                                                        dt_sgNvk [Dmd=<S,U>]
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  Data.Complex.$w$smagnitude
                                                                                      dt_sgNvk
                                                                                      b_sgNvh
                                                                              of
                                                                              ww_sgNvl
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        logDouble# [ww_sgNvl]
                                                                                    of
                                                                                    wild3_sgNvm
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$sphase
                                                                                                  dt_sgNvk
                                                                                                  b_sgNvh
                                                                                          of
                                                                                          ww1_sgNvn
                                                                                          { __DEFAULT ->
                                                                                                let {
                                                                                                  sat_sgNvp [Occ=Once]
                                                                                                    :: GHC.Types.Double
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.D#! [ww1_sgNvn]; } in
                                                                                                let {
                                                                                                  sat_sgNvo [Occ=Once]
                                                                                                    :: GHC.Types.Double
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.D#! [wild3_sgNvm];
                                                                                                } in 
                                                                                                  Data.Complex.:+ [sat_sgNvo
                                                                                                                   sat_sgNvp];
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                              } in 
                                                                case <## [sat_sgNvq 0.5##] of {
                                                                  __DEFAULT -> $j_sgNvj;
                                                                  1# ->
                                                                      case
                                                                          fabsDouble# [b_sgNvh]
                                                                      of
                                                                      sat_sgNvs
                                                                      { __DEFAULT ->
                                                                            case
                                                                                <## [sat_sgNvs
                                                                                     0.5##]
                                                                            of
                                                                            { __DEFAULT -> $j_sgNvj;
                                                                              1# ->
                                                                                  case
                                                                                      *## [b_sgNvh
                                                                                           b_sgNvh]
                                                                                  of
                                                                                  sat_sgNvy
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            *## [a_sgNvf
                                                                                                 a_sgNvf]
                                                                                        of
                                                                                        sat_sgNvw
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  +## [a_sgNvf
                                                                                                       a_sgNvf]
                                                                                              of
                                                                                              sat_sgNvv
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        +## [sat_sgNvv
                                                                                                             sat_sgNvw]
                                                                                                    of
                                                                                                    sat_sgNvx
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              +## [sat_sgNvx
                                                                                                                   sat_sgNvy]
                                                                                                          of
                                                                                                          u_sgNvu [Dmd=<S,U>]
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    +## [u_sgNvu
                                                                                                                         1.0##]
                                                                                                                of
                                                                                                                sat_sgNvz
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          sqrtDouble# [sat_sgNvz]
                                                                                                                      of
                                                                                                                      sat_sgNvA
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                +## [1.0##
                                                                                                                                     sat_sgNvA]
                                                                                                                            of
                                                                                                                            sat_sgNvB
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      /## [u_sgNvu
                                                                                                                                           sat_sgNvB]
                                                                                                                                  of
                                                                                                                                  wild3_sgNvC
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            __pkg_ccall base-4.11.0.0 [wild3_sgNvC
                                                                                                                                                                       GHC.Prim.realWorld#]
                                                                                                                                        of
                                                                                                                                        { (#,#) _ [Occ=Dead]
                                                                                                                                                ds4_sgNvG [Occ=Once] ->
                                                                                                                                              case
                                                                                                                                                  +## [1.0##
                                                                                                                                                       a_sgNvf]
                                                                                                                                              of
                                                                                                                                              sat_sgNvH
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    let {
                                                                                                                                                      sat_sgNvI [Occ=Once]
                                                                                                                                                        :: GHC.Types.Double
                                                                                                                                                      [LclId] =
                                                                                                                                                          CCCS GHC.Types.D#! [sat_sgNvH];
                                                                                                                                                    } in 
                                                                                                                                                      case
                                                                                                                                                          GHC.Float.$w$catan2
                                                                                                                                                              sat_sgNvI
                                                                                                                                                              b_sgNvh
                                                                                                                                                      of
                                                                                                                                                      ww2_sgNvJ
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgNvL [Occ=Once]
                                                                                                                                                                :: GHC.Types.Double
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.D#! [ww2_sgNvJ]; } in
                                                                                                                                                            let {
                                                                                                                                                              sat_sgNvK [Occ=Once]
                                                                                                                                                                :: GHC.Types.Double
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.D#! [ds4_sgNvG];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgNvK
                                                                                                                                                                               sat_sgNvL];
                                                                                                                                                      };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLC(C(S))LLLL)S(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgNvM eta_sgNvN]
        case eta_sgNvN of {
          Data.Complex.:+ ww1_sgNvP [Occ=Once] ww2_sgNvQ [Occ=Once] ->
              case
                  Data.Complex.$w$cexp $dRealFloat_sgNvM ww1_sgNvP ww2_sgNvQ
              of
              { (#,#) ww4_sgNvS ww5_sgNvT ->
                    case
                        GHC.Float.$p1RealFloat $dRealFloat_sgNvM
                    of
                    $dRealFrac_sgNvU [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
                    { __DEFAULT ->
                          case
                              GHC.Real.$p1RealFrac $dRealFrac_sgNvU
                          of
                          $dReal_sgNvV [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
                          { __DEFAULT ->
                                let {
                                  $dNum_sgNvW [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
                                    :: GHC.Num.Num a_agsO1
                                  [LclId] =
                                      [$dReal_sgNvV] \u [] GHC.Real.$p1Real $dReal_sgNvV;
                                } in 
                                  case
                                      GHC.Real.$p2Real $dReal_sgNvV
                                  of
                                  $dOrd_sgNvX [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                                  { __DEFAULT ->
                                        let {
                                          $dFractional_sgNvY [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
                                            :: GHC.Real.Fractional a_agsO1
                                          [LclId] =
                                              [$dRealFrac_sgNvU] \u []
                                                  GHC.Real.$p2RealFrac $dRealFrac_sgNvU; } in
                                        let {
                                          sat_sgNw0 [Occ=Once] :: a_agsO1
                                          [LclId] =
                                              [$dFractional_sgNvY] \u []
                                                  GHC.Real.fromRational
                                                      $dFractional_sgNvY
                                                      Data.Complex.$fFloatingComplex20; } in
                                        let {
                                          sat_sgNvZ [Occ=Once] :: a_agsO1
                                          [LclId] =
                                              [ww4_sgNvS $dNum_sgNvW] \u []
                                                  GHC.Num.abs $dNum_sgNvW ww4_sgNvS;
                                        } in 
                                          case GHC.Classes.< $dOrd_sgNvX sat_sgNvZ sat_sgNw0 of {
                                            GHC.Types.False ->
                                                case
                                                    Data.Complex.$w$cfromInteger
                                                        $dRealFloat_sgNvM
                                                        Data.Complex.$fFloatingComplex19
                                                of
                                                { (#,#) ww7_sgNw3 [Occ=Once] ww8_sgNw4 [Occ=Once] ->
                                                      case
                                                          Data.Complex.$w$c+
                                                              $dRealFloat_sgNvM
                                                              ww7_sgNw3
                                                              ww8_sgNw4
                                                              ww4_sgNvS
                                                              ww5_sgNvT
                                                      of
                                                      { (#,#) ww10_sgNw6 [Occ=Once]
                                                              ww11_sgNw7 [Occ=Once] ->
                                                            case
                                                                Data.Complex.$w$clog
                                                                    $dRealFloat_sgNvM
                                                                    ww10_sgNw6
                                                                    ww11_sgNw7
                                                            of
                                                            { (#,#) ww13_sgNw9 [Occ=Once]
                                                                    ww14_sgNwa [Occ=Once] ->
                                                                  Data.Complex.:+ [ww13_sgNw9
                                                                                   ww14_sgNwa];
                                                            };
                                                      };
                                                };
                                            GHC.Types.True ->
                                                let {
                                                  sat_sgNwc [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [$dFractional_sgNvY] \u []
                                                          GHC.Real.fromRational
                                                              $dFractional_sgNvY
                                                              Data.Complex.$fFloatingComplex20; } in
                                                let {
                                                  sat_sgNwb [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [ww5_sgNvT $dNum_sgNvW] \u []
                                                          GHC.Num.abs $dNum_sgNvW ww5_sgNvT;
                                                } in 
                                                  case
                                                      GHC.Classes.< $dOrd_sgNvX sat_sgNwb sat_sgNwc
                                                  of
                                                  { GHC.Types.False ->
                                                        case
                                                            Data.Complex.$w$cfromInteger
                                                                $dRealFloat_sgNvM
                                                                Data.Complex.$fFloatingComplex19
                                                        of
                                                        { (#,#) ww7_sgNwf [Occ=Once]
                                                                ww8_sgNwg [Occ=Once] ->
                                                              case
                                                                  Data.Complex.$w$c+
                                                                      $dRealFloat_sgNvM
                                                                      ww7_sgNwf
                                                                      ww8_sgNwg
                                                                      ww4_sgNvS
                                                                      ww5_sgNvT
                                                              of
                                                              { (#,#) ww10_sgNwi [Occ=Once]
                                                                      ww11_sgNwj [Occ=Once] ->
                                                                    case
                                                                        Data.Complex.$w$clog
                                                                            $dRealFloat_sgNvM
                                                                            ww10_sgNwi
                                                                            ww11_sgNwj
                                                                    of
                                                                    { (#,#) ww13_sgNwl [Occ=Once]
                                                                            ww14_sgNwm [Occ=Once] ->
                                                                          Data.Complex.:+ [ww13_sgNwl
                                                                                           ww14_sgNwm];
                                                                    };
                                                              };
                                                        };
                                                    GHC.Types.True ->
                                                        case
                                                            GHC.Float.$p2RealFloat $dRealFloat_sgNvM
                                                        of
                                                        $dFloating_sgNwn [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_sgNwz [Occ=Once] :: a_agsO1
                                                                [LclId] =
                                                                    [ww4_sgNvS
                                                                     ww5_sgNvT
                                                                     $dNum_sgNvW
                                                                     $dFractional_sgNvY
                                                                     $dFloating_sgNwn] \u []
                                                                        let {
                                                                          u_sgNwo :: a_agsO1
                                                                          [LclId] =
                                                                              [ww4_sgNvS
                                                                               ww5_sgNvT
                                                                               $dNum_sgNvW] \u []
                                                                                  let {
                                                                                    sat_sgNwt [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [ww5_sgNvT
                                                                                         $dNum_sgNvW] \u []
                                                                                            GHC.Num.*
                                                                                                $dNum_sgNvW
                                                                                                ww5_sgNvT
                                                                                                ww5_sgNvT; } in
                                                                                  let {
                                                                                    sat_sgNws [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [ww4_sgNvS
                                                                                         $dNum_sgNvW] \u []
                                                                                            let {
                                                                                              sat_sgNwr [Occ=Once]
                                                                                                :: a_agsO1
                                                                                              [LclId] =
                                                                                                  [ww4_sgNvS
                                                                                                   $dNum_sgNvW] \u []
                                                                                                      GHC.Num.*
                                                                                                          $dNum_sgNvW
                                                                                                          ww4_sgNvS
                                                                                                          ww4_sgNvS; } in
                                                                                            let {
                                                                                              sat_sgNwq [Occ=Once]
                                                                                                :: a_agsO1
                                                                                              [LclId] =
                                                                                                  [ww4_sgNvS
                                                                                                   $dNum_sgNvW] \u []
                                                                                                      let {
                                                                                                        sat_sgNwp [Occ=Once]
                                                                                                          :: a_agsO1
                                                                                                        [LclId] =
                                                                                                            [$dNum_sgNvW] \u []
                                                                                                                GHC.Num.fromInteger
                                                                                                                    $dNum_sgNvW
                                                                                                                    Data.Complex.$fFloatingComplex21;
                                                                                                      } in 
                                                                                                        GHC.Num.*
                                                                                                            $dNum_sgNvW
                                                                                                            sat_sgNwp
                                                                                                            ww4_sgNvS;
                                                                                            } in 
                                                                                              GHC.Num.+
                                                                                                  $dNum_sgNvW
                                                                                                  sat_sgNwq
                                                                                                  sat_sgNwr;
                                                                                  } in 
                                                                                    GHC.Num.+
                                                                                        $dNum_sgNvW
                                                                                        sat_sgNws
                                                                                        sat_sgNwt; } in
                                                                        let {
                                                                          sat_sgNwy [Occ=Once]
                                                                            :: a_agsO1
                                                                          [LclId] =
                                                                              [$dNum_sgNvW
                                                                               $dFloating_sgNwn
                                                                               u_sgNwo] \u []
                                                                                  let {
                                                                                    sat_sgNwx [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [$dNum_sgNvW
                                                                                         $dFloating_sgNwn
                                                                                         u_sgNwo] \u []
                                                                                            let {
                                                                                              sat_sgNww [Occ=Once]
                                                                                                :: a_agsO1
                                                                                              [LclId] =
                                                                                                  [$dNum_sgNvW
                                                                                                   u_sgNwo] \u []
                                                                                                      let {
                                                                                                        sat_sgNwv [Occ=Once]
                                                                                                          :: a_agsO1
                                                                                                        [LclId] =
                                                                                                            [$dNum_sgNvW] \u []
                                                                                                                GHC.Num.fromInteger
                                                                                                                    $dNum_sgNvW
                                                                                                                    Data.Complex.$fFloatingComplex19;
                                                                                                      } in 
                                                                                                        GHC.Num.+
                                                                                                            $dNum_sgNvW
                                                                                                            u_sgNwo
                                                                                                            sat_sgNwv;
                                                                                            } in 
                                                                                              GHC.Float.sqrt
                                                                                                  $dFloating_sgNwn
                                                                                                  sat_sgNww; } in
                                                                                  let {
                                                                                    sat_sgNwu [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [$dNum_sgNvW] \u []
                                                                                            GHC.Num.fromInteger
                                                                                                $dNum_sgNvW
                                                                                                Data.Complex.$fFloatingComplex19;
                                                                                  } in 
                                                                                    GHC.Num.+
                                                                                        $dNum_sgNvW
                                                                                        sat_sgNwu
                                                                                        sat_sgNwx;
                                                                        } in 
                                                                          GHC.Real./
                                                                              $dFractional_sgNvY
                                                                              u_sgNwo
                                                                              sat_sgNwy;
                                                              } in 
                                                                case
                                                                    GHC.Float.log1p
                                                                        $dFloating_sgNwn sat_sgNwz
                                                                of
                                                                dt_sgNwA
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_sgNwC [Occ=Once]
                                                                          :: a_agsO1
                                                                        [LclId] =
                                                                            [ww4_sgNvS
                                                                             $dNum_sgNvW] \u []
                                                                                let {
                                                                                  sat_sgNwB [Occ=Once]
                                                                                    :: a_agsO1
                                                                                  [LclId] =
                                                                                      [$dNum_sgNvW] \u []
                                                                                          GHC.Num.fromInteger
                                                                                              $dNum_sgNvW
                                                                                              Data.Complex.$fFloatingComplex19;
                                                                                } in 
                                                                                  GHC.Num.+
                                                                                      $dNum_sgNvW
                                                                                      sat_sgNwB
                                                                                      ww4_sgNvS;
                                                                      } in 
                                                                        case
                                                                            GHC.Float.atan2
                                                                                $dRealFloat_sgNvM
                                                                                sat_sgNwC
                                                                                ww5_sgNvT
                                                                        of
                                                                        dt1_sgNwD
                                                                        { __DEFAULT ->
                                                                              Data.Complex.:+ [dt_sgNwA
                                                                                               dt1_sgNwD];
                                                                        };
                                                                };
                                                        };
                                                  };
                                          };
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clogBase1 [InlPrag=INLINE (sat-args=2)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNwE eta1_sgNwF]
        case eta1_sgNwF of {
          Data.Complex.:+ ww1_sgNwH [Occ=Once!] ww2_sgNwI [Occ=Once!] ->
              case ww1_sgNwH of {
                GHC.Types.F# ww4_sgNwK ->
                    case ww2_sgNwI of {
                      GHC.Types.F# ww6_sgNwM ->
                          case Data.Complex.$w$smagnitude1 ww4_sgNwK ww6_sgNwM of ww7_sgNwN {
                            __DEFAULT ->
                                case logFloat# [ww7_sgNwN] of wild1_sgNwO {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$sphase1 ww4_sgNwK ww6_sgNwM
                                      of
                                      ww8_sgNwP
                                      { __DEFAULT ->
                                            case eta_sgNwE of {
                                              Data.Complex.:+ ww10_sgNwR [Occ=Once!]
                                                              ww11_sgNwS [Occ=Once!] ->
                                                  case ww10_sgNwR of {
                                                    GHC.Types.F# ww13_sgNwU ->
                                                        case ww11_sgNwS of {
                                                          GHC.Types.F# ww15_sgNwW ->
                                                              case
                                                                  Data.Complex.$w$smagnitude1
                                                                      ww13_sgNwU ww15_sgNwW
                                                              of
                                                              ww16_sgNwX
                                                              { __DEFAULT ->
                                                                    case
                                                                        logFloat# [ww16_sgNwX]
                                                                    of
                                                                    wild2_sgNwY
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$sphase1
                                                                                  ww13_sgNwU
                                                                                  ww15_sgNwW
                                                                          of
                                                                          ww17_sgNwZ
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/1
                                                                                        wild1_sgNwO
                                                                                        ww8_sgNwP
                                                                                        wild2_sgNwY
                                                                                        ww17_sgNwZ
                                                                                of
                                                                                { (#,#) ww19_sgNx1 [Occ=Once]
                                                                                        ww20_sgNx2 [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww19_sgNx1
                                                                                                       ww20_sgNx2];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clogBase [InlPrag=INLINE (sat-args=2)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNx3 eta1_sgNx4]
        case eta1_sgNx4 of {
          Data.Complex.:+ ww1_sgNx6 [Occ=Once!] ww2_sgNx7 [Occ=Once!] ->
              case ww1_sgNx6 of {
                GHC.Types.D# ww4_sgNx9 ->
                    case ww2_sgNx7 of {
                      GHC.Types.D# ww6_sgNxb ->
                          case Data.Complex.$w$smagnitude ww4_sgNx9 ww6_sgNxb of ww7_sgNxc {
                            __DEFAULT ->
                                case logDouble# [ww7_sgNxc] of wild1_sgNxd {
                                  __DEFAULT ->
                                      case Data.Complex.$w$sphase ww4_sgNx9 ww6_sgNxb of ww8_sgNxe {
                                        __DEFAULT ->
                                            case eta_sgNx3 of {
                                              Data.Complex.:+ ww10_sgNxg [Occ=Once!]
                                                              ww11_sgNxh [Occ=Once!] ->
                                                  case ww10_sgNxg of {
                                                    GHC.Types.D# ww13_sgNxj ->
                                                        case ww11_sgNxh of {
                                                          GHC.Types.D# ww15_sgNxl ->
                                                              case
                                                                  Data.Complex.$w$smagnitude
                                                                      ww13_sgNxj ww15_sgNxl
                                                              of
                                                              ww16_sgNxm
                                                              { __DEFAULT ->
                                                                    case
                                                                        logDouble# [ww16_sgNxm]
                                                                    of
                                                                    wild2_sgNxn
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$sphase
                                                                                  ww13_sgNxj
                                                                                  ww15_sgNxl
                                                                          of
                                                                          ww17_sgNxo
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/
                                                                                        wild1_sgNxd
                                                                                        ww8_sgNxe
                                                                                        wild2_sgNxn
                                                                                        ww17_sgNxo
                                                                                of
                                                                                { (#,#) ww19_sgNxq [Occ=Once]
                                                                                        ww20_sgNxr [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww19_sgNxq
                                                                                                       ww20_sgNxr];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clogBase [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgNxs eta_sgNxt eta1_sgNxu]
        case eta1_sgNxu of {
          Data.Complex.:+ ww1_sgNxw [Occ=Once] ww2_sgNxx [Occ=Once] ->
              case
                  Data.Complex.$w$clog $dRealFloat_sgNxs ww1_sgNxw ww2_sgNxx
              of
              { (#,#) ww4_sgNxz [Occ=Once] ww5_sgNxA [Occ=Once] ->
                    case eta_sgNxt of {
                      Data.Complex.:+ ww7_sgNxC [Occ=Once] ww8_sgNxD [Occ=Once] ->
                          case
                              Data.Complex.$w$clog $dRealFloat_sgNxs ww7_sgNxC ww8_sgNxD
                          of
                          { (#,#) ww10_sgNxF [Occ=Once] ww11_sgNxG [Occ=Once] ->
                                case
                                    Data.Complex.$w$c/
                                        $dRealFloat_sgNxs ww4_sgNxz ww5_sgNxA ww10_sgNxF ww11_sgNxG
                                of
                                { (#,#) ww13_sgNxI [Occ=Once] ww14_sgNxJ [Occ=Once] ->
                                      Data.Complex.:+ [ww13_sgNxI ww14_sgNxJ];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$fFloatingComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Float.Floating (Data.Complex.Complex GHC.Types.Float)
[GblId] =
    CCS_DONT_CARE GHC.Float.C:Floating! [Data.Complex.$fFloatingComplex_$s$fFractionalComplex1
                                         Data.Complex.$fFloatingComplex_$s$cpi1
                                         Data.Complex.$fFloatingComplex_$s$cexp1
                                         Data.Complex.$fFloatingComplex_$s$clog1
                                         Data.Complex.$fFloatingComplex_$s$csqrt1
                                         Data.Complex.$fFloatingComplex_$s$c**1
                                         Data.Complex.$fFloatingComplex_$s$clogBase1
                                         Data.Complex.$fFloatingComplex_$s$csin1
                                         Data.Complex.$fFloatingComplex_$s$ccos1
                                         Data.Complex.$fFloatingComplex_$s$ctan1
                                         Data.Complex.$fFloatingComplex_$s$casin1
                                         Data.Complex.$fFloatingComplex_$s$cacos1
                                         Data.Complex.$fFloatingComplex_$s$catan1
                                         Data.Complex.$fFloatingComplex_$s$csinh1
                                         Data.Complex.$fFloatingComplex_$s$ccosh1
                                         Data.Complex.$fFloatingComplex_$s$ctanh1
                                         Data.Complex.$fFloatingComplex_$s$casinh1
                                         Data.Complex.$fFloatingComplex_$s$cacosh1
                                         Data.Complex.$fFloatingComplex_$s$catanh1
                                         Data.Complex.$fFloatingComplex_$s$clog1p1
                                         Data.Complex.$fFloatingComplex_$s$cexpm2
                                         Data.Complex.$fFloatingComplex_$s$clog1pexp1
                                         Data.Complex.$fFloatingComplex_$s$clog1mexp1];

Data.Complex.$fFloatingComplex_$s$fFloatingComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Float.Floating (Data.Complex.Complex GHC.Types.Double)
[GblId] =
    CCS_DONT_CARE GHC.Float.C:Floating! [Data.Complex.$fFloatingComplex_$s$fFractionalComplex
                                         Data.Complex.$fFloatingComplex_$s$cpi
                                         Data.Complex.$fFloatingComplex_$s$cexp
                                         Data.Complex.$fFloatingComplex_$s$clog
                                         Data.Complex.$fFloatingComplex_$s$csqrt
                                         Data.Complex.$fFloatingComplex_$s$c**
                                         Data.Complex.$fFloatingComplex_$s$clogBase
                                         Data.Complex.$fFloatingComplex_$s$csin
                                         Data.Complex.$fFloatingComplex_$s$ccos
                                         Data.Complex.$fFloatingComplex_$s$ctan
                                         Data.Complex.$fFloatingComplex_$s$casin
                                         Data.Complex.$fFloatingComplex_$s$cacos
                                         Data.Complex.$fFloatingComplex_$s$catan
                                         Data.Complex.$fFloatingComplex_$s$csinh
                                         Data.Complex.$fFloatingComplex_$s$ccosh
                                         Data.Complex.$fFloatingComplex_$s$ctanh
                                         Data.Complex.$fFloatingComplex_$s$casinh
                                         Data.Complex.$fFloatingComplex_$s$cacosh
                                         Data.Complex.$fFloatingComplex_$s$catanh
                                         Data.Complex.$fFloatingComplex_$s$clog1p
                                         Data.Complex.$fFloatingComplex_$s$cexpm1
                                         Data.Complex.$fFloatingComplex_$s$clog1pexp
                                         Data.Complex.$fFloatingComplex_$s$clog1mexp];

Data.Complex.$fFloatingComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Float.Floating (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,U,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))>] =
    [] \r [$dRealFloat_sgNxK]
        let {
          sat_sgNy7 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog1mexp
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy6 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog1pexp
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy5 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cexpm1
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy4 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog1p
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy3 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$catanh
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy2 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cacosh
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy1 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$casinh
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy0 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ctanh
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxZ [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ccosh
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxY [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$csinh
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxX [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$catan
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxW [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cacos
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxV [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$casin
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxU [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ctan $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxT [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ccos $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxS [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$csin $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxR [Occ=Once]
            :: Data.Complex.Complex a_agsO1
               -> Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$clogBase
                      $dRealFloat_sgNxK eta_B2 eta_B1; } in
        let {
          sat_sgNxQ [Occ=Once]
            :: Data.Complex.Complex a_agsO1
               -> Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c**
                      $dRealFloat_sgNxK eta_B2 eta_B1; } in
        let {
          sat_sgNxP [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$csqrt
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxO [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxN [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cexp $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxM [Occ=Once] :: Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \u []
                  Data.Complex.$fFloatingComplex_$cpi $dRealFloat_sgNxK; } in
        let {
          sat_sgNxL [Occ=Once]
            :: GHC.Real.Fractional (Data.Complex.Complex a_agsO1)
          [LclId] =
              [$dRealFloat_sgNxK] \u []
                  Data.Complex.$fFractionalComplex $dRealFloat_sgNxK;
        } in 
          GHC.Float.C:Floating [sat_sgNxL
                                sat_sgNxM
                                sat_sgNxN
                                sat_sgNxO
                                sat_sgNxP
                                sat_sgNxQ
                                sat_sgNxR
                                sat_sgNxS
                                sat_sgNxT
                                sat_sgNxU
                                sat_sgNxV
                                sat_sgNxW
                                sat_sgNxX
                                sat_sgNxY
                                sat_sgNxZ
                                sat_sgNy0
                                sat_sgNy1
                                sat_sgNy2
                                sat_sgNy3
                                sat_sgNy4
                                sat_sgNy5
                                sat_sgNy6
                                sat_sgNy7];

Data.Complex.:+ :: forall a. a -> a -> Data.Complex.Complex a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Complex.:+ [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:12:44.521547065 UTC

Data.Complex.$W:+ [InlPrag=INLINE[2]]
  :: forall a. a -> a -> Data.Complex.Complex a
[GblId[DataConWrapper],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>m,
 Unf=OtherCon []] =
    [] \r [dt_sgMF4 dt_sgMF5]
        case dt_sgMF4 of dt_sgMF6 {
          __DEFAULT ->
              case dt_sgMF5 of dt_sgMF7 {
                __DEFAULT -> Data.Complex.:+ [dt_sgMF6 dt_sgMF7];
              };
        };

Data.Complex.$fStorableComplex2 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Data.Complex.$fStorableComplex1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> Data.Complex.Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,U><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMF8 w1_sgMF9 w2_sgMFa void_0E]
        case w2_sgMFa of {
          Data.Complex.:+ ww1_sgMFd [Occ=Once] ww2_sgMFe [Occ=Once] ->
              case
                  Foreign.Storable.poke w_sgMF8 w1_sgMF9 ww1_sgMFd GHC.Prim.void#
              of
              { Unit# _ [Occ=Dead] ->
                    Foreign.Storable.pokeElemOff
                        w_sgMF8
                        w1_sgMF9
                        Data.Complex.$fStorableComplex2
                        ww2_sgMFe
                        GHC.Prim.void#;
              };
        };

Data.Complex.$fStorableComplex3
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Complex.Complex a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,1*C1(C1(C1(U(U,U)))),A,A,A,1*C1(C1(U(U,U))),A)><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgMFi p_sgMFj void_0E]
        case
            Foreign.Storable.peek $dStorable_sgMFi p_sgMFj GHC.Prim.void#
        of
        { Unit# ipv1_sgMFn [Occ=Once] ->
              case
                  Foreign.Storable.peekElemOff
                      $dStorable_sgMFi
                      p_sgMFj
                      Data.Complex.$fStorableComplex2
                      GHC.Prim.void#
              of
              { Unit# ipv3_sgMFq [Occ=Once] ->
                    let {
                      sat_sgMFr [Occ=Once] :: Data.Complex.Complex a_XgsQ1
                      [LclId] =
                          [ipv1_sgMFn ipv3_sgMFq] \u []
                              Data.Complex.$W:+ ipv1_sgMFn ipv3_sgMFq;
                    } in  Unit# [sat_sgMFr];
              };
        };

Data.Complex.$fApplicativeComplex_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> Data.Complex.Complex a
     -> Data.Complex.Complex b
     -> Data.Complex.Complex c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMFs w1_sgMFt w2_sgMFu]
        case w1_sgMFt of {
          Data.Complex.:+ ww1_sgMFw [Occ=Once] ww2_sgMFx [Occ=Once] ->
              case w2_sgMFu of {
                Data.Complex.:+ ww4_sgMFz [Occ=Once] ww5_sgMFA [Occ=Once] ->
                    case w_sgMFs ww1_sgMFw ww4_sgMFz of dt_sgMFB {
                      __DEFAULT ->
                          case w_sgMFs ww2_sgMFx ww5_sgMFA of dt1_sgMFC {
                            __DEFAULT -> Data.Complex.:+ [dt_sgMFB dt1_sgMFC];
                          };
                    };
              };
        };

Data.Complex.$fApplicativeComplex_$c<*>
  :: forall a b.
     Data.Complex.Complex (a -> b)
     -> Data.Complex.Complex a -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)C(S)),1*U(C1(U),C1(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMFD ds1_sgMFE]
        case ds_sgMFD of {
          Data.Complex.:+ f_sgMFG [Occ=Once!] g_sgMFH [Occ=Once!] ->
              case ds1_sgMFE of {
                Data.Complex.:+ a1_sgMFJ [Occ=Once] b1_sgMFK [Occ=Once] ->
                    case f_sgMFG a1_sgMFJ of dt_sgMFL {
                      __DEFAULT ->
                          case g_sgMFH b1_sgMFK of dt1_sgMFM {
                            __DEFAULT -> Data.Complex.:+ [dt_sgMFL dt1_sgMFM];
                          };
                    };
              };
        };

Data.Complex.$fApplicativeComplex_$cpure
  :: forall a. a -> Data.Complex.Complex a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>m, Unf=OtherCon []] =
    [] \r [a1_sgMFN] Data.Complex.$W:+ a1_sgMFN a1_sgMFN;

Data.Complex.$fTraversableComplex_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Complex.Complex a -> f (Data.Complex.Complex b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgMFO f1_sgMFP ds_sgMFQ]
        case ds_sgMFQ of {
          Data.Complex.:+ a1_sgMFS [Occ=Once] a2_sgMFT [Occ=Once] ->
              let {
                sat_sgMFV [Occ=Once] :: f_agsK7 b_agsK9
                [LclId] =
                    [f1_sgMFP a2_sgMFT] \u [] f1_sgMFP a2_sgMFT; } in
              let {
                sat_sgMFU [Occ=Once] :: f_agsK7 b_agsK9
                [LclId] =
                    [f1_sgMFP a1_sgMFS] \u [] f1_sgMFP a1_sgMFS;
              } in 
                GHC.Base.liftA2
                    $dApplicative_sgMFO Data.Complex.$W:+ sat_sgMFU sat_sgMFV;
        };

Data.Complex.$fFoldableComplex_$cnull
  :: forall a. Data.Complex.Complex a -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [ds_sgMFW]
        case ds_sgMFW of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Complex.$fFoldableComplex_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgMG0 z_sgMG1 ds_sgMG2]
        case ds_sgMG2 of {
          Data.Complex.:+ a1_sgMG4 [Occ=Once] a2_sgMG5 [Occ=Once] ->
              let {
                sat_sgMG6 [Occ=Once] :: b_agsHZ
                [LclId] =
                    [f_sgMG0 z_sgMG1 a2_sgMG5] \u [] f_sgMG0 a2_sgMG5 z_sgMG1;
              } in  f_sgMG0 a1_sgMG4 sat_sgMG6;
        };

Data.Complex.$fFoldableComplex_$cfoldMap
  :: forall m a.
     GHC.Base.Monoid m =>
     (a -> m) -> Data.Complex.Complex a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgMG7 f_sgMG8 ds_sgMG9]
        case ds_sgMG9 of {
          Data.Complex.:+ a1_sgMGb [Occ=Once] a2_sgMGc [Occ=Once] ->
              let {
                sat_sgMGe [Occ=Once] :: m_agsHO
                [LclId] =
                    [f_sgMG8 a2_sgMGc] \u [] f_sgMG8 a2_sgMGc; } in
              let {
                sat_sgMGd [Occ=Once] :: m_agsHO
                [LclId] =
                    [f_sgMG8 a1_sgMGb] \u [] f_sgMG8 a1_sgMGb;
              } in  GHC.Base.mappend $dMonoid_sgMG7 sat_sgMGd sat_sgMGe;
        };

Data.Complex.$fFoldableComplex_$cfold
  :: forall m. GHC.Base.Monoid m => Data.Complex.Complex m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgMGf ds_sgMGg]
        case ds_sgMGg of {
          Data.Complex.:+ a1_sgMGi [Occ=Once] a2_sgMGj [Occ=Once] ->
              GHC.Base.mappend $dMonoid_sgMGf a1_sgMGi a2_sgMGj;
        };

Data.Complex.$fFoldableComplex2
  :: forall a.
     GHC.Num.Num a =>
     Data.Complex.Complex a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgMGk ds_sgMGl]
        case ds_sgMGl of {
          Data.Complex.:+ a1_sgMGn [Occ=Once] a2_sgMGo [Occ=Once] ->
              GHC.Num.+ $dNum_sgMGk a1_sgMGn a2_sgMGo;
        };

Data.Complex.$fFoldableComplex_$cminimum
  :: forall a. GHC.Classes.Ord a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sgMGp x_sgMGq]
        case x_sgMGq of {
          Data.Complex.:+ a1_sgMGs a2_sgMGt ->
              case GHC.Classes.<= $dOrd_sgMGp a1_sgMGs a2_sgMGt of {
                GHC.Types.False -> a2_sgMGt;
                GHC.Types.True -> a1_sgMGs;
              };
        };

Data.Complex.$fFoldableComplex_$cmaximum
  :: forall a. GHC.Classes.Ord a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sgMGv x_sgMGw]
        case x_sgMGw of {
          Data.Complex.:+ a1_sgMGy a2_sgMGz ->
              case GHC.Classes.>= $dOrd_sgMGv a1_sgMGy a2_sgMGz of {
                GHC.Types.False -> a2_sgMGz;
                GHC.Types.True -> a1_sgMGy;
              };
        };

Data.Complex.$fFoldableComplex_$celem
  :: forall a.
     GHC.Classes.Eq a =>
     a -> Data.Complex.Complex a -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sgMGB eta_sgMGC]
        let {
          f_sgMGD [Dmd=<L,C(U)>] :: a_agsJ9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgMGB eta_sgMGC] \u []
                  GHC.Classes.== $dEq_sgMGB eta_sgMGC; } in
        let {
          sat_sgMGJ [Occ=Once]
            :: Data.Complex.Complex a_agsJ9 -> Data.Semigroup.Internal.Any
          [LclId] =
              [f_sgMGD] \r [ds_sgMGE]
                  case ds_sgMGE of {
                    Data.Complex.:+ a1_sgMGG [Occ=Once] a2_sgMGH [Occ=Once] ->
                        case f_sgMGD a1_sgMGG of {
                          GHC.Types.False -> f_sgMGD a2_sgMGH;
                          GHC.Types.True -> GHC.Types.True [];
                        };
                  };
        } in  sat_sgMGJ;

Data.Complex.$fFoldableComplex_$cfoldr1
  :: forall a. (a -> a -> a) -> Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgMGK xs_sgMGL]
        case xs_sgMGL of {
          Data.Complex.:+ a1_sgMGN [Occ=Once] a2_sgMGO [Occ=Once] ->
              f_sgMGK a1_sgMGN a2_sgMGO;
        };

Data.Complex.$fFoldableComplex_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgMGP z0_sgMGQ xs_sgMGR]
        case xs_sgMGR of {
          Data.Complex.:+ a1_sgMGT [Occ=Once] a2_sgMGU [Occ=Once] ->
              case f_sgMGP z0_sgMGQ a1_sgMGT of vx_sgMGV {
                __DEFAULT -> f_sgMGP vx_sgMGV a2_sgMGU;
              };
        };

lvl_rgA6e :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

Data.Complex.$fFoldableComplex_$clength
  :: forall a. Data.Complex.Complex a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [xs_sgMGW]
        case xs_sgMGW of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> lvl_rgA6e;
        };

Data.Complex.$fFoldableComplex_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgMH0 z_sgMH1 t1_sgMH2]
        case t1_sgMH2 of {
          Data.Complex.:+ a1_sgMH4 [Occ=Once] a2_sgMH5 [Occ=Once] ->
              let {
                sat_sgMH6 [Occ=Once] :: b_agsIe
                [LclId] =
                    [f_sgMH0 z_sgMH1 a1_sgMH4] \u [] f_sgMH0 z_sgMH1 a1_sgMH4;
              } in  f_sgMH0 sat_sgMH6 a2_sgMH5;
        };

Data.Complex.$fFoldableComplex_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Data.Complex.Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sgMH7 z0_sgMH8 xs_sgMH9]
        case xs_sgMH9 of {
          Data.Complex.:+ a1_sgMHb [Occ=Once] a2_sgMHc [Occ=Once] ->
              case f_sgMH7 a2_sgMHc z0_sgMH8 of vx_sgMHd {
                __DEFAULT -> f_sgMH7 a1_sgMHb vx_sgMHd;
              };
        };

Data.Complex.$fFoldableComplex1
  :: forall a.
     GHC.Num.Num a =>
     Data.Complex.Complex a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_sgMHe ds_sgMHf]
        case ds_sgMHf of {
          Data.Complex.:+ a1_sgMHh [Occ=Once] a2_sgMHi [Occ=Once] ->
              GHC.Num.* $dNum_sgMHe a1_sgMHh a2_sgMHi;
        };

Data.Complex.$fFoldableComplex_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Data.Complex.Complex a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_sgMHj]
        case eta_sgMHj of {
          Data.Complex.:+ a1_sgMHl [Occ=Once] a2_sgMHm [Occ=Once] ->
              let {
                sat_sgMHn [Occ=Once] :: [a_agsIO]
                [LclId] =
                    CCCS :! [a2_sgMHm GHC.Types.[]];
              } in  : [a1_sgMHl sat_sgMHn];
        };

Data.Complex.$fFoldableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Foldable.Foldable Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs] =
    CCS_DONT_CARE Data.Foldable.C:Foldable! [Data.Complex.$fFoldableComplex_$cfold
                                             Data.Complex.$fFoldableComplex_$cfoldMap
                                             Data.Complex.$fFoldableComplex_$cfoldr
                                             Data.Complex.$fFoldableComplex_$cfoldr'
                                             Data.Complex.$fFoldableComplex_$cfoldl
                                             Data.Complex.$fFoldableComplex_$cfoldl'
                                             Data.Complex.$fFoldableComplex_$cfoldr1
                                             Data.Complex.$fFoldableComplex_$cfoldr1
                                             Data.Complex.$fFoldableComplex_$ctoList
                                             Data.Complex.$fFoldableComplex_$cnull
                                             Data.Complex.$fFoldableComplex_$clength
                                             Data.Complex.$fFoldableComplex_$celem
                                             Data.Complex.$fFoldableComplex_$cmaximum
                                             Data.Complex.$fFoldableComplex_$cminimum
                                             Data.Complex.$fFoldableComplex2
                                             Data.Complex.$fFoldableComplex1];

Data.Complex.$fFunctorComplex_$c<$
  :: forall a b.
     a -> Data.Complex.Complex b -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [z_sgMHo ds_sgMHp]
        case ds_sgMHp of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] ->
              Data.Complex.$W:+ z_sgMHo z_sgMHo;
        };

Data.Complex.$fFunctorComplex_$cfmap
  :: forall a b.
     (a -> b) -> Data.Complex.Complex a -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sgMHt ds_sgMHu]
        case ds_sgMHu of {
          Data.Complex.:+ a1_sgMHw [Occ=Once] a2_sgMHx [Occ=Once] ->
              case f_sgMHt a1_sgMHw of dt_sgMHy {
                __DEFAULT ->
                    case f_sgMHt a2_sgMHx of dt1_sgMHz {
                      __DEFAULT -> Data.Complex.:+ [dt_sgMHy dt1_sgMHz];
                    };
              };
        };

Data.Complex.$fFunctorComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Complex.$fFunctorComplex_$cfmap
                                       Data.Complex.$fFunctorComplex_$c<$];

Data.Complex.$fTraversableComplex_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Complex.Complex (f a) -> f (Data.Complex.Complex a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgMHA ds_sgMHB]
        case ds_sgMHB of {
          Data.Complex.:+ a1_sgMHD [Occ=Once] a2_sgMHE [Occ=Once] ->
              GHC.Base.liftA2
                  $dApplicative_sgMHA Data.Complex.$W:+ a1_sgMHD a2_sgMHE;
        };

Data.Complex.$fTraversableComplex_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Complex.Complex a -> m (Data.Complex.Complex b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgMHF eta_sgMHG eta1_sgMHH]
        case eta1_sgMHH of {
          Data.Complex.:+ a1_sgMHJ [Occ=Once] a2_sgMHK [Occ=Once] ->
              let {
                sat_sgMHN [Occ=Once] :: m_agsKy b_agsKA
                [LclId] =
                    [eta_sgMHG a2_sgMHK] \u [] eta_sgMHG a2_sgMHK; } in
              let {
                sat_sgMHM [Occ=Once] :: m_agsKy b_agsKA
                [LclId] =
                    [eta_sgMHG a1_sgMHJ] \u [] eta_sgMHG a1_sgMHJ;
              } in 
                case GHC.Base.$p1Monad $dMonad_sgMHF of sat_sgMHL {
                  __DEFAULT ->
                      GHC.Base.liftA2 sat_sgMHL Data.Complex.$W:+ sat_sgMHM sat_sgMHN;
                };
        };

Data.Complex.$fTraversableComplex_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Complex.Complex (m a) -> m (Data.Complex.Complex a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgMHO eta_sgMHP]
        case eta_sgMHP of {
          Data.Complex.:+ a1_sgMHR [Occ=Once] a2_sgMHS [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sgMHO of sat_sgMHT {
                __DEFAULT ->
                    GHC.Base.liftA2 sat_sgMHT Data.Complex.$W:+ a1_sgMHR a2_sgMHS;
              };
        };

Data.Complex.$fTraversableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Complex.$fFunctorComplex
                                                   Data.Complex.$fFoldableComplex
                                                   Data.Complex.$fTraversableComplex_$ctraverse
                                                   Data.Complex.$fTraversableComplex_$csequenceA
                                                   Data.Complex.$fTraversableComplex_$cmapM
                                                   Data.Complex.$fTraversableComplex_$csequence];

Data.Complex.$fApplicativeComplex_$c*>
  :: forall a b.
     Data.Complex.Complex a
     -> Data.Complex.Complex b -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [a1_sgMHU a2_sgMHV]
        case a1_sgMHU of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> a2_sgMHV;
        };

Data.Complex.$fApplicativeComplex_$c<*
  :: forall a b.
     Data.Complex.Complex a
     -> Data.Complex.Complex b -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMHZ ds1_sgMI0]
        case ds_sgMHZ of wild_sgMI1 {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] ->
              case ds1_sgMI0 of {
                Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> wild_sgMI1;
              };
        };

Data.Complex.$fApplicativeComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Complex.$fFunctorComplex
                                           Data.Complex.$fApplicativeComplex_$cpure
                                           Data.Complex.$fApplicativeComplex_$c<*>
                                           Data.Complex.$fApplicativeComplex_$cliftA2
                                           Data.Complex.$fApplicativeComplex_$c*>
                                           Data.Complex.$fApplicativeComplex_$c<*];

Data.Complex.$fGeneric1Complex_$cto1
  :: forall a.
     GHC.Generics.Rep1 Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMI7]
        case ds_sgMI7 of {
          GHC.Generics.:*: ds1_sgMI9 [Occ=Once] ds2_sgMIa [Occ=Once] ->
              Data.Complex.$W:+ ds1_sgMI9 ds2_sgMIa;
        };

Data.Complex.$fGeneric1Complex1
  :: forall a.
     Data.Complex.Complex a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             ":+"
             ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
             'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.SourceStrict
                'GHC.Generics.DecidedStrict)
             GHC.Generics.Par1
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.SourceStrict
                                 'GHC.Generics.DecidedStrict)
                              GHC.Generics.Par1)
          a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_sgMIb]
        case x_sgMIb of {
          Data.Complex.:+ g1_sgMId [Occ=Once] g2_sgMIe [Occ=Once] ->
              GHC.Generics.:*: [g1_sgMId g2_sgMIe];
        };

Data.Complex.$fGeneric1Complex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Complex.Complex
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Complex.$fGeneric1Complex1
                                            Data.Complex.$fGeneric1Complex_$cto1];

Data.Complex.$fGenericComplex_$cto
  :: forall a x.
     GHC.Generics.Rep (Data.Complex.Complex a) x
     -> Data.Complex.Complex a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMIf]
        case ds_sgMIf of {
          GHC.Generics.:*: ds1_sgMIh [Occ=Once] ds2_sgMIi [Occ=Once] ->
              Data.Complex.$W:+ ds1_sgMIh ds2_sgMIi;
        };

Data.Complex.$fGenericComplex1
  :: forall a x.
     Data.Complex.Complex a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             ":+"
             ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
             'GHC.Types.False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'GHC.Base.Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.SourceStrict
                'GHC.Generics.DecidedStrict)
             (GHC.Generics.K1 GHC.Generics.R a)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'GHC.Base.Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.SourceStrict
                                 'GHC.Generics.DecidedStrict)
                              (GHC.Generics.K1 GHC.Generics.R a))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x1_sgMIj]
        case x1_sgMIj of {
          Data.Complex.:+ g1_sgMIl [Occ=Once] g2_sgMIm [Occ=Once] ->
              GHC.Generics.:*: [g1_sgMIl g2_sgMIm];
        };

Data.Complex.$fGenericComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Complex.Complex a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Complex.$fGenericComplex1
                                           Data.Complex.$fGenericComplex_$cto];

Data.Complex.$fDataComplex_$cgunfold
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dData_sgMIn k_sgMIo z_sgMIp ds_sgMIq]
        let {
          sat_sgMIs [Occ=Once]
            :: c_agsBB (a_agsBe -> Data.Complex.Complex a_agsBe)
          [LclId] =
              [$dData_sgMIn k_sgMIo z_sgMIp] \u []
                  let {
                    sat_sgMIr [Occ=Once]
                      :: c_agsBB (a_agsBe -> a_agsBe -> Data.Complex.Complex a_agsBe)
                    [LclId] =
                        [z_sgMIp] \u [] z_sgMIp Data.Complex.$W:+;
                  } in  k_sgMIo $dData_sgMIn sat_sgMIr;
        } in  k_sgMIo $dData_sgMIn sat_sgMIs;

Data.Complex.$fDataComplex_$cgfoldl
  :: forall a.
     Data.Data.Data a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Complex.Complex a
     -> c (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgMIt k_sgMIu z_sgMIv ds_sgMIw]
        case ds_sgMIw of {
          Data.Complex.:+ a1_sgMIy [Occ=Once] a2_sgMIz [Occ=Once] ->
              let {
                sat_sgMIB [Occ=Once]
                  :: c_agsBn (a_agsBe -> Data.Complex.Complex a_agsBe)
                [LclId] =
                    [$dData_sgMIt k_sgMIu z_sgMIv a1_sgMIy] \u []
                        let {
                          sat_sgMIA [Occ=Once]
                            :: c_agsBn (a_agsBe -> a_agsBe -> Data.Complex.Complex a_agsBe)
                          [LclId] =
                              [z_sgMIv] \u [] z_sgMIv Data.Complex.$W:+;
                        } in  k_sgMIu $dData_sgMIt sat_sgMIA a1_sgMIy;
              } in  k_sgMIu $dData_sgMIt sat_sgMIB a2_sgMIz;
        };

Data.Complex.$fReadComplex5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [7#];

Data.Complex.$fReadComplex4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":+"#;

Data.Complex.$fReadComplex3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Complex.$fReadComplex4;

Data.Complex.$fReadComplex2 :: Text.Read.Lex.Lexeme
[GblId, Str=m5, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Symbol! [Data.Complex.$fReadComplex3];

Data.Complex.$fReadComplex1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Complex.Complex a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sgMIC eta_sgMID eta1_sgMIE]
        let {
          ds1_sgMIF [Dmd=<L,C(U)>]
            :: Text.ParserCombinators.ReadP.ReadP a_agsAr
          [LclId] =
              [$dRead_sgMIC] \u []
                  GHC.Read.readPrec $dRead_sgMIC Data.Complex.$fReadComplex5; } in
        let {
          sat_sgMIU [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Complex.Complex a_agsAr)
          [LclId] =
              [ds1_sgMIF] \r [c_sgMIG eta2_sgMIH]
                  case c_sgMIG of {
                    GHC.Types.I# x_sgMIJ [Occ=Once] ->
                        case <=# [x_sgMIJ 6#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_sgMIT [Occ=Once]
                                  :: a_agsAr -> Text.ParserCombinators.ReadP.P b1_i815E
                                [LclId] =
                                    [ds1_sgMIF eta2_sgMIH] \r [a1_sgMIL]
                                        let {
                                          sat_sgMIQ [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i815E
                                          [LclId] =
                                              [ds1_sgMIF eta2_sgMIH a1_sgMIL] \r [a2_sgMIM]
                                                  let {
                                                    sat_sgMIP [Occ=Once]
                                                      :: a_agsAr
                                                         -> Text.ParserCombinators.ReadP.P b1_i815E
                                                    [LclId] =
                                                        [eta2_sgMIH a1_sgMIL] \r [a3_sgMIN]
                                                            let {
                                                              sat_sgMIO [Occ=Once]
                                                                :: Data.Complex.Complex a_agsAr
                                                              [LclId] =
                                                                  [a1_sgMIL a3_sgMIN] \u []
                                                                      Data.Complex.$W:+
                                                                          a1_sgMIL a3_sgMIN;
                                                            } in  eta2_sgMIH sat_sgMIO;
                                                  } in  ds1_sgMIF sat_sgMIP;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Complex.$fReadComplex2 sat_sgMIQ
                                          of
                                          { Unit# ww1_sgMIS [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_sgMIS];
                                          };
                              } in  ds1_sgMIF sat_sgMIT;
                        };
                  };
        } in  GHC.Read.list3 sat_sgMIU eta_sgMID eta1_sgMIE;

Data.Complex.$fReadComplex_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Complex.Complex a)
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C1(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_sgMIV n_sgMIW]
        let {
          sat_sgMIX [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Complex.Complex a_XgsEB)
          [LclId] =
              [$dRead_sgMIV n_sgMIW] \u []
                  Data.Complex.$fReadComplex1
                      $dRead_sgMIV
                      n_sgMIW
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgMIX;

Data.Complex.$fReadComplex_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Complex.Complex a]
[GblId, Arity=1, Str=<L,U(A,A,C(C(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sgMIY]
        let {
          sat_sgMIZ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Complex.Complex a_XgsEz)
          [LclId] =
              [$dRead_sgMIY] \r [eta_B2 eta_B1]
                  Data.Complex.$fReadComplex1 $dRead_sgMIY eta_B2 eta_B1;
        } in  GHC.Read.list sat_sgMIZ;

Data.Complex.$fReadComplex_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Complex.Complex a]
[GblId, Arity=1, Str=<L,U(A,A,C(C(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_sgMJ0]
        let {
          sat_sgMJ2 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Complex.Complex a_XgsEA]
          [LclId] =
              [$dRead_sgMJ0] \u []
                  let {
                    sat_sgMJ1 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Complex.Complex a_XgsEA)
                    [LclId] =
                        [$dRead_sgMJ0] \r [eta_B2 eta_B1]
                            Data.Complex.$fReadComplex1 $dRead_sgMJ0 eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_sgMJ1
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgMJ2;

Data.Complex.$fReadComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Complex.Complex a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C(U)),A)>m] =
    [] \r [$dRead_sgMJ3]
        let {
          sat_sgMJ7 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Complex.Complex a_XgsEy]
          [LclId] =
              [$dRead_sgMJ3] \u []
                  Data.Complex.$fReadComplex_$creadListPrec $dRead_sgMJ3; } in
        let {
          sat_sgMJ6 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Complex.Complex a_XgsEy)
          [LclId] =
              [$dRead_sgMJ3] \r [eta_B2 eta_B1]
                  Data.Complex.$fReadComplex1 $dRead_sgMJ3 eta_B2 eta_B1; } in
        let {
          sat_sgMJ5 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Complex.Complex a_XgsEy]
          [LclId] =
              [$dRead_sgMJ3] \u []
                  Data.Complex.$fReadComplex_$creadList $dRead_sgMJ3; } in
        let {
          sat_sgMJ4 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Complex.Complex a_XgsEy)
          [LclId] =
              [$dRead_sgMJ3] \r [eta_B1]
                  Data.Complex.$fReadComplex_$creadsPrec $dRead_sgMJ3 eta_B1;
        } in  GHC.Read.C:Read [sat_sgMJ4 sat_sgMJ5 sat_sgMJ6 sat_sgMJ7];

Data.Complex.$fShowComplex2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    " :+ "#;

Data.Complex.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> a -> a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMJ8 ww_sgMJ9 ww1_sgMJa ww2_sgMJb]
        let {
          f_sgMJc [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sgMJ8 ww1_sgMJa] \u []
                  GHC.Show.showsPrec
                      w_sgMJ8 Data.Complex.$fReadComplex5 ww1_sgMJa; } in
        let {
          g_sgMJd [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_sgMJ8 ww2_sgMJb] \u []
                  GHC.Show.showsPrec w_sgMJ8 Data.Complex.$fReadComplex5 ww2_sgMJb;
        } in 
          case >=# [ww_sgMJ9 7#] of {
            __DEFAULT ->
                let {
                  sat_sgMJi [Occ=OnceT[0]] :: GHC.Base.String -> GHC.Base.String
                  [LclId] =
                      [f_sgMJc g_sgMJd] \r [x_sgMJf]
                          let {
                            sat_sgMJh [Occ=Once] :: GHC.Base.String
                            [LclId] =
                                [g_sgMJd x_sgMJf] \u []
                                    let {
                                      sat_sgMJg [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [g_sgMJd x_sgMJf] \u [] g_sgMJd x_sgMJf;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Complex.$fShowComplex2 sat_sgMJg;
                          } in  f_sgMJc sat_sgMJh;
                } in  sat_sgMJi;
            1# ->
                let {
                  sat_sgMJo [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_sgMJc g_sgMJd] \r [x_sgMJj]
                          let {
                            sat_sgMJn [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_sgMJc g_sgMJd x_sgMJj] \u []
                                    let {
                                      sat_sgMJm [Occ=Once] :: GHC.Base.String
                                      [LclId] =
                                          [g_sgMJd x_sgMJj] \u []
                                              let {
                                                sat_sgMJl [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [g_sgMJd x_sgMJj] \u []
                                                        let {
                                                          sat_sgMJk [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              CCCS :! [GHC.Show.$fShow(,)2 x_sgMJj];
                                                        } in  g_sgMJd sat_sgMJk;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Complex.$fShowComplex2 sat_sgMJl;
                                    } in  f_sgMJc sat_sgMJm;
                          } in  : [GHC.Show.$fShow(,)4 sat_sgMJn];
                } in  sat_sgMJo;
          };

Data.Complex.$fShowComplex_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Complex.Complex a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMJp w1_sgMJq w2_sgMJr]
        case w1_sgMJq of {
          GHC.Types.I# ww1_sgMJt [Occ=Once] ->
              case w2_sgMJr of {
                Data.Complex.:+ ww3_sgMJv [Occ=Once] ww4_sgMJw [Occ=Once] ->
                    Data.Complex.$w$cshowsPrec w_sgMJp ww1_sgMJt ww3_sgMJv ww4_sgMJw;
              };
        };

Data.Complex.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Show.Show a => a -> a -> GHC.Base.String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMJx ww_sgMJy ww1_sgMJz]
        let {
          sat_sgMJB [Occ=Once] :: GHC.Base.String
          [LclId] =
              [w_sgMJx ww1_sgMJz] \u []
                  let {
                    sat_sgMJA [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [w_sgMJx ww1_sgMJz] \u []
                            GHC.Show.showsPrec
                                w_sgMJx Data.Complex.$fReadComplex5 ww1_sgMJz GHC.Types.[];
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Complex.$fShowComplex2 sat_sgMJA;
        } in 
          GHC.Show.showsPrec
              w_sgMJx Data.Complex.$fReadComplex5 ww_sgMJy sat_sgMJB;

Data.Complex.$fShowComplex_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     Data.Complex.Complex a -> GHC.Base.String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMJC w1_sgMJD]
        case w1_sgMJD of {
          Data.Complex.:+ ww1_sgMJF [Occ=Once] ww2_sgMJG [Occ=Once] ->
              Data.Complex.$w$cshow w_sgMJC ww1_sgMJF ww2_sgMJG;
        };

Data.Complex.$fShowComplex1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Complex.$fShowComplex_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Complex.Complex a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_sgMJH ls_sgMJI s_sgMJJ]
        let {
          sat_sgMJO [Occ=Once]
            :: Data.Complex.Complex a_agszX -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgMJH] \r [w_sgMJK]
                  case w_sgMJK of {
                    Data.Complex.:+ ww1_sgMJM [Occ=Once] ww2_sgMJN [Occ=Once] ->
                        Data.Complex.$w$cshowsPrec $dShow_sgMJH 0# ww1_sgMJM ww2_sgMJN;
                  };
        } in  GHC.Show.showList__ sat_sgMJO ls_sgMJI s_sgMJJ;

Data.Complex.$fShowComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_sgMJP]
        let {
          sat_sgMJS [Occ=Once]
            :: [Data.Complex.Complex a_agszX] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgMJP] \r [eta_B2 eta_B1]
                  Data.Complex.$fShowComplex_$cshowList
                      $dShow_sgMJP eta_B2 eta_B1; } in
        let {
          sat_sgMJR [Occ=Once]
            :: Data.Complex.Complex a_agszX -> GHC.Base.String
          [LclId] =
              [$dShow_sgMJP] \r [eta_B1]
                  Data.Complex.$fShowComplex_$cshow $dShow_sgMJP eta_B1; } in
        let {
          sat_sgMJQ [Occ=Once]
            :: GHC.Types.Int -> Data.Complex.Complex a_agszX -> GHC.Show.ShowS
          [LclId] =
              [$dShow_sgMJP] \r [eta_B2 eta_B1]
                  Data.Complex.$fShowComplex_$cshowsPrec $dShow_sgMJP eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgMJQ sat_sgMJR sat_sgMJS];

Data.Complex.$fEqComplex_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Complex.Complex a -> Data.Complex.Complex a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMJT w1_sgMJU w2_sgMJV]
        case w1_sgMJU of {
          Data.Complex.:+ ww1_sgMJX [Occ=Once] ww2_sgMJY [Occ=Once] ->
              case w2_sgMJV of {
                Data.Complex.:+ ww4_sgMK0 [Occ=Once] ww5_sgMK1 [Occ=Once] ->
                    case GHC.Classes.== w_sgMJT ww1_sgMJX ww4_sgMK0 of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True -> GHC.Classes.== w_sgMJT ww2_sgMJY ww5_sgMK1;
                    };
              };
        };

Data.Complex.$fEqComplex_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     Data.Complex.Complex a -> Data.Complex.Complex a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sgMK3 eta_sgMK4 eta1_sgMK5]
        case eta_sgMK4 of {
          Data.Complex.:+ ww1_sgMK7 [Occ=Once] ww2_sgMK8 [Occ=Once] ->
              case eta1_sgMK5 of {
                Data.Complex.:+ ww4_sgMKa [Occ=Once] ww5_sgMKb [Occ=Once] ->
                    case GHC.Classes.== $dEq_sgMK3 ww1_sgMK7 ww4_sgMKa of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True ->
                          case GHC.Classes.== $dEq_sgMK3 ww2_sgMK8 ww5_sgMKb of {
                            GHC.Types.False -> GHC.Types.True [];
                            GHC.Types.True -> GHC.Types.False [];
                          };
                    };
              };
        };

Data.Complex.$fEqComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Complex.Complex a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sgMKe]
        let {
          sat_sgMKg [Occ=Once]
            :: Data.Complex.Complex a_agszG
               -> Data.Complex.Complex a_agszG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgMKe] \r [eta_B2 eta_B1]
                  Data.Complex.$fEqComplex_$c/= $dEq_sgMKe eta_B2 eta_B1; } in
        let {
          sat_sgMKf [Occ=Once]
            :: Data.Complex.Complex a_agszG
               -> Data.Complex.Complex a_agszG -> GHC.Types.Bool
          [LclId] =
              [$dEq_sgMKe] \r [eta_B2 eta_B1]
                  Data.Complex.$fEqComplex_$c== $dEq_sgMKe eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sgMKf sat_sgMKg];

Data.Complex.realPart :: forall a. Data.Complex.Complex a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_sgMKh]
        case ds_sgMKh of {
          Data.Complex.:+ x_sgMKj [Occ=Once] _ [Occ=Dead] -> x_sgMKj;
        };

Data.Complex.$fStorableComplex_$csizeOf
  :: forall a.
     Foreign.Storable.Storable a =>
     Data.Complex.Complex a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S(S))LLLLLLL),1*U(1*C1(U(U)),A,A,A,A,A,A,A)><L,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgMKl a1_sgMKm]
        let {
          sat_sgMKq [Occ=Once] :: a_XgsQG
          [LclId] =
              [a1_sgMKm] \u []
                  case a1_sgMKm of {
                    Data.Complex.:+ x_sgMKo [Occ=Once] _ [Occ=Dead] -> x_sgMKo;
                  };
        } in 
          case Foreign.Storable.sizeOf $dStorable_sgMKl sat_sgMKq of {
            GHC.Types.I# y_sgMKs [Occ=Once] ->
                case *# [2# y_sgMKs] of sat_sgMKt {
                  __DEFAULT -> GHC.Types.I# [sat_sgMKt];
                };
          };

Data.Complex.$fStorableComplex_$calignment
  :: forall a.
     Foreign.Storable.Storable a =>
     Data.Complex.Complex a -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLLLL),1*U(A,1*C1(U(U)),A,A,A,A,A,A)><L,1*U(U,A)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgMKu a1_sgMKv]
        let {
          sat_sgMKz [Occ=Once] :: a_XgsQH
          [LclId] =
              [a1_sgMKv] \u []
                  case a1_sgMKv of {
                    Data.Complex.:+ x_sgMKx [Occ=Once] _ [Occ=Dead] -> x_sgMKx;
                  };
        } in  Foreign.Storable.alignment $dStorable_sgMKu sat_sgMKz;

Data.Complex.$fStorableComplex5
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Complex.Complex a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgMKA ptr_sgMKB off_sgMKC void_0E]
        let {
          sat_sgMKJ [Occ=Once] :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQL)
          [LclId] =
              [ptr_sgMKB off_sgMKC] \u []
                  case ptr_sgMKB of {
                    GHC.Ptr.Ptr addr_sgMKF [Occ=Once] ->
                        case off_sgMKC of {
                          GHC.Types.I# d_sgMKH [Occ=Once] ->
                              case plusAddr# [addr_sgMKF d_sgMKH] of sat_sgMKI {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_sgMKI];
                              };
                        };
                  };
        } in 
          Data.Complex.$fStorableComplex3
              $dStorable_sgMKA sat_sgMKJ GHC.Prim.void#;

lvl1_rgA6f :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "undefined"#;

lvl2_rgA6g :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl1_rgA6f;

Data.Complex.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl3_rgA6h :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Complex.$trModule4;

lvl4_rgA6i :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Foreign.Storable"#;

lvl5_rgA6j :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_rgA6i;

lvl6_rgA6k :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Foreign/Storable.hs"#;

lvl7_rgA6l :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl6_rgA6k;

lvl8_rgA6m :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [137#];

lvl9_rgA6n :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [31#];

lvl10_rgA6o :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [40#];

lvl11_rgA6p :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl3_rgA6h
                                           lvl5_rgA6j
                                           lvl7_rgA6l
                                           lvl8_rgA6m
                                           lvl9_rgA6n
                                           lvl8_rgA6m
                                           lvl10_rgA6o];

lvl12_rgA6q :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl2_rgA6g
                                                  lvl11_rgA6p
                                                  GHC.Stack.Types.EmptyCallStack];

Data.Complex.$fStorableComplex8 :: forall a. Data.Complex.Complex a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl12_rgA6q;

Data.Complex.$fStorableComplex7
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Data.Complex.Complex a #)
[GblId,
 Arity=4,
 Str=<S(LLLLLLC(C(S(SL)))L),U(1*C1(U(U)),A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgMKK ptr_sgMKL off_sgMKM void_0E]
        let {
          sat_sgMKY [Occ=Once] :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQM)
          [LclId] =
              [$dStorable_sgMKK ptr_sgMKL off_sgMKM] \u []
                  case ptr_sgMKL of {
                    GHC.Ptr.Ptr addr_sgMKP [Occ=Once] ->
                        case off_sgMKM of {
                          GHC.Types.I# x_sgMKR [Occ=Once] ->
                              case
                                  Foreign.Storable.sizeOf
                                      $dStorable_sgMKK Data.Complex.$fStorableComplex8
                              of
                              { GHC.Types.I# y_sgMKU [Occ=Once] ->
                                    case *# [2# y_sgMKU] of sat_sgMKV {
                                      __DEFAULT ->
                                          case *# [x_sgMKR sat_sgMKV] of sat_sgMKW {
                                            __DEFAULT ->
                                                case plusAddr# [addr_sgMKP sat_sgMKW] of sat_sgMKX {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_sgMKX];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          Data.Complex.$fStorableComplex3
              $dStorable_sgMKK sat_sgMKY GHC.Prim.void#;

Data.Complex.$fStorableComplex4
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> Data.Complex.Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_sgMKZ ptr_sgML0 off_sgML1 eta_sgML2 void_0E]
        case eta_sgML2 of {
          Data.Complex.:+ ww1_sgML5 [Occ=Once] ww2_sgML6 [Occ=Once] ->
              let {
                w_sgML7 :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQJ)
                [LclId] =
                    [ptr_sgML0 off_sgML1] \u []
                        case ptr_sgML0 of {
                          GHC.Ptr.Ptr addr_sgML9 [Occ=Once] ->
                              case off_sgML1 of {
                                GHC.Types.I# d_sgMLb [Occ=Once] ->
                                    case plusAddr# [addr_sgML9 d_sgMLb] of sat_sgMLc {
                                      __DEFAULT -> GHC.Ptr.Ptr [sat_sgMLc];
                                    };
                              };
                        };
              } in 
                case
                    Foreign.Storable.poke
                        $dStorable_sgMKZ w_sgML7 ww1_sgML5 GHC.Prim.void#
                of
                { Unit# _ [Occ=Dead] ->
                      Foreign.Storable.pokeElemOff
                          $dStorable_sgMKZ
                          w_sgML7
                          Data.Complex.$fStorableComplex2
                          ww2_sgML6
                          GHC.Prim.void#;
                };
        };

Data.Complex.$w$cpokeElemOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Types.Int
     -> a
     -> a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(1*C1(U(U)),A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMLg w1_sgMLh w2_sgMLi ww_sgMLj ww1_sgMLk void_0E]
        let {
          w4_sgMLm :: GHC.Ptr.Ptr (Data.Complex.Complex a_sgxtm)
          [LclId] =
              [w_sgMLg w1_sgMLh w2_sgMLi ww_sgMLj] \u []
                  case w1_sgMLh of {
                    GHC.Ptr.Ptr addr_sgMLo [Occ=Once] ->
                        case w2_sgMLi of {
                          GHC.Types.I# x_sgMLq [Occ=Once] ->
                              case Foreign.Storable.sizeOf w_sgMLg ww_sgMLj of {
                                GHC.Types.I# y_sgMLs [Occ=Once] ->
                                    case *# [2# y_sgMLs] of sat_sgMLt {
                                      __DEFAULT ->
                                          case *# [x_sgMLq sat_sgMLt] of sat_sgMLu {
                                            __DEFAULT ->
                                                case plusAddr# [addr_sgMLo sat_sgMLu] of sat_sgMLv {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_sgMLv];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case
              Foreign.Storable.poke w_sgMLg w4_sgMLm ww_sgMLj GHC.Prim.void#
          of
          { Unit# _ [Occ=Dead] ->
                Foreign.Storable.pokeElemOff
                    w_sgMLg
                    w4_sgMLm
                    Data.Complex.$fStorableComplex2
                    ww1_sgMLk
                    GHC.Prim.void#;
          };

Data.Complex.$fStorableComplex6 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (Data.Complex.Complex a)
     -> GHC.Types.Int
     -> Data.Complex.Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(C(U(U)),A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMLz w1_sgMLA w2_sgMLB w3_sgMLC void_0E]
        case w3_sgMLC of {
          Data.Complex.:+ ww1_sgMLF [Occ=Once] ww2_sgMLG [Occ=Once] ->
              Data.Complex.$w$cpokeElemOff
                  w_sgMLz w1_sgMLA w2_sgMLB ww1_sgMLF ww2_sgMLG GHC.Prim.void#;
        };

Data.Complex.$fStorableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Foreign.Storable.Storable a =>
     Foreign.Storable.Storable (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(U(U)),C(U(U)),C(C1(C1(U(U,U)))),C(C1(C1(C1(U(U,U))))),A,A,C(C1(U(U,U))),C(C1(C1(U(U,A)))))>m] =
    [] \r [$dStorable_sgMLH]
        let {
          sat_sgMLP [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> Data.Complex.Complex a_XgsQI -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B3 eta_B2 void_0E]
                  Data.Complex.$fStorableComplex1
                      $dStorable_sgMLH eta_B3 eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgMLO [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> GHC.Types.IO (Data.Complex.Complex a_XgsQI)
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B2 void_0E]
                  Data.Complex.$fStorableComplex3
                      $dStorable_sgMLH eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgMLN [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> Data.Complex.Complex a_XgsQI -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B4 eta_B3 eta_B2 void_0E]
                  Data.Complex.$fStorableComplex4
                      $dStorable_sgMLH eta_B4 eta_B3 eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgMLM [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> GHC.Types.IO (Data.Complex.Complex a_XgsQI)
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B3 eta_B2 void_0E]
                  Data.Complex.$fStorableComplex5
                      $dStorable_sgMLH eta_B3 eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgMLL [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> GHC.Types.Int -> Data.Complex.Complex a_XgsQI -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B4 eta_B3 eta_B2 void_0E]
                  Data.Complex.$fStorableComplex6
                      $dStorable_sgMLH eta_B4 eta_B3 eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgMLK [Occ=Once]
            :: GHC.Ptr.Ptr (Data.Complex.Complex a_XgsQI)
               -> GHC.Types.Int -> GHC.Types.IO (Data.Complex.Complex a_XgsQI)
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B3 eta_B2 void_0E]
                  Data.Complex.$fStorableComplex7
                      $dStorable_sgMLH eta_B3 eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgMLJ [Occ=Once]
            :: Data.Complex.Complex a_XgsQI -> GHC.Types.Int
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B1]
                  Data.Complex.$fStorableComplex_$calignment
                      $dStorable_sgMLH eta_B1; } in
        let {
          sat_sgMLI [Occ=Once]
            :: Data.Complex.Complex a_XgsQI -> GHC.Types.Int
          [LclId] =
              [$dStorable_sgMLH] \r [eta_B1]
                  Data.Complex.$fStorableComplex_$csizeOf $dStorable_sgMLH eta_B1;
        } in 
          Foreign.Storable.C:Storable [sat_sgMLI
                                       sat_sgMLJ
                                       sat_sgMLK
                                       sat_sgMLL
                                       sat_sgMLM
                                       sat_sgMLN
                                       sat_sgMLO
                                       sat_sgMLP];

Data.Complex.imagPart :: forall a. Data.Complex.Complex a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgMLQ]
        case ds_sgMLQ of {
          Data.Complex.:+ _ [Occ=Dead] y_sgMLT [Occ=Once] -> y_sgMLT;
        };

Data.Complex.$fMonadComplex_$c>>=
  :: forall a b.
     Data.Complex.Complex a
     -> (a -> Data.Complex.Complex b) -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><C(S(SS)),C(U(U,U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMLU f_sgMLV]
        case ds_sgMLU of {
          Data.Complex.:+ a1_sgMLX [Occ=Once] b1_sgMLY [Occ=Once] ->
              case f_sgMLV a1_sgMLX of {
                Data.Complex.:+ x_sgMM0 [Occ=Once] _ [Occ=Dead] ->
                    case f_sgMLV b1_sgMLY of {
                      Data.Complex.:+ _ [Occ=Dead] y_sgMM4 [Occ=Once] ->
                          Data.Complex.:+ [x_sgMM0 y_sgMM4];
                    };
              };
        };

Data.Complex.$fMonadComplex_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Complex.Complex a
     -> Data.Complex.Complex b -> Data.Complex.Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Complex.$fApplicativeComplex_$c*> eta_B2 eta_B1;

lvl13_rgA6r :: forall a. [GHC.Types.Char] -> Data.Complex.Complex a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_sgMM5] GHC.Err.errorWithoutStackTrace eta_sgMM5;

Data.Complex.$fMonadComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Complex.Complex
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Complex.$fApplicativeComplex
                                     Data.Complex.$fMonadComplex_$c>>=
                                     Data.Complex.$fMonadComplex_$c>>
                                     Data.Complex.$fApplicativeComplex_$cpure
                                     lvl13_rgA6r];

Data.Complex.$fDataComplex6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Complex"#;

Data.Complex.$fDataComplex9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Complex.$fDataComplex6;

go61_rgA6s
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgMM6 _ys_sgMM7]
        case ds2_sgMM6 of {
          [] -> GHC.List.badHead;
          : ipv_sgMM9 [Occ=Once!] ipv1_sgMMa [Occ=Once] ->
              case _ys_sgMM7 of {
                [] -> GHC.List.badHead;
                : ipv2_sgMMc [Occ=Once] ipv3_sgMMd [Occ=Once] ->
                    case ipv_sgMM9 of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgMMg [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sgMMg Data.Complex.$fReadComplex3 of {
                            GHC.Types.False -> go61_rgA6s ipv1_sgMMa ipv3_sgMMd;
                            GHC.Types.True -> ipv2_sgMMc;
                          };
                    };
              };
        };

$c:+1_rgA6t :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$c:+2_rgA6u];
Data.Complex.$fDataComplex8 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Complex.$c:+ GHC.Types.[]];
Data.Complex.$fDataComplex7 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Complex.$fDataComplex8];
Data.Complex.$tComplex :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Complex.$fDataComplex9
                                       Data.Complex.$fDataComplex7];
Data.Complex.$c:+ [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$c:+1_rgA6t
                                     Data.Complex.$fReadComplex3
                                     GHC.Types.[]
                                     Data.Data.Infix
                                     Data.Complex.$tComplex];
$c:+2_rgA6u :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rgA6s Data.Complex.$fDataComplex8 Data.Data.mkConstr1;

Data.Complex.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$trModule4];

Data.Complex.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Complex"#;

Data.Complex.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$trModule2];

Data.Complex.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Complex.$trModule3
                                     Data.Complex.$trModule1];

$krep_rgA6v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Complex.$fDataComplex5 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$fDataComplex6];

Data.Complex.$tcComplex :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1343342814679332338##
                                    7004386227939987578##
                                    Data.Complex.$trModule
                                    Data.Complex.$fDataComplex5
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep1_rgA6w :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_rgA6v GHC.Types.[]];

$krep2_rgA6x :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Complex.$tcComplex
                                              $krep1_rgA6w];

$krep3_rgA6y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgA6v $krep2_rgA6x];

Data.Complex.$tc':+1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgA6v $krep3_rgA6y];

Data.Complex.$tc':+3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "':+"#;

Data.Complex.$tc':+2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Complex.$tc':+3];

Data.Complex.$tc':+ :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6922641126191179007##
                                    8119904032930905711##
                                    Data.Complex.$trModule
                                    Data.Complex.$tc':+2
                                    1#
                                    Data.Complex.$tc':+1];

Data.Complex.$fDataComplex4
  :: Data.Typeable.Internal.TypeRep Data.Complex.Complex
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                1343342814679332338##
                7004386227939987578##
                Data.Complex.$trModule
                Data.Complex.$fDataComplex5
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sgMMm [Occ=Once]
                   ww9_sgMMn [Occ=Once]
                   ww10_sgMMo [Occ=Once]
                   ww11_sgMMp [Occ=Once]
                   ww12_sgMMq [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sgMMm
                                              ww9_sgMMn
                                              ww10_sgMMo
                                              ww11_sgMMp
                                              ww12_sgMMq];
        };

Data.Complex.$fDataComplex10
  :: forall a.
     Data.Data.Data a =>
     Data.Typeable.Internal.TypeRep (Data.Complex.Complex a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgMMr]
        case Data.Data.$p1Data $dData_sgMMr of sat_sgMMs {
          __DEFAULT ->
              Data.Typeable.Internal.mkTrApp
                  Data.Complex.$fDataComplex4 sat_sgMMs;
        };

Data.Complex.$fDataComplex_$cdataCast1
  :: forall a.
     Data.Data.Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Complex.Complex a))
[GblId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
    [] \r [$dData_sgMMt $dTypeable_sgMMu]
        let {
          lvl17_sgMMv [Occ=OnceL!] :: GHC.Types.Bool
          [LclId] =
              [$dTypeable_sgMMu] \u []
                  Data.Typeable.Internal.sameTypeRep
                      $dTypeable_sgMMu Data.Complex.$fDataComplex4; } in
        let {
          sat_sgMMz [Occ=OnceT[0]]
            :: (forall d. Data.Data.Data d => c_agsBY (t_agsBX d))
               -> GHC.Base.Maybe (c_agsBY (Data.Complex.Complex a_XgsGb))
          [LclId] =
              [$dData_sgMMt lvl17_sgMMv] \r [f_sgMMw]
                  case lvl17_sgMMv of {
                    GHC.Types.False -> GHC.Base.Nothing [];
                    GHC.Types.True ->
                        let {
                          sat_sgMMy [Occ=Once] :: c_agsBY (Data.Complex.Complex a_XgsGb)
                          [LclId] =
                              [$dData_sgMMt f_sgMMw] \u [] f_sgMMw $dData_sgMMt;
                        } in  GHC.Base.Just [sat_sgMMy];
                  };
        } in  sat_sgMMz;

Data.Complex.$fDataComplex1
  :: forall a. (a -> a -> Data.Complex.Complex a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Complex.$W:+ GHC.Types.False];

Data.Complex.$fDataComplex_$cgmapMp
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Complex.Complex a -> m (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgMMA $dMonadPlus_sgMMB ds_sgMMC eta_sgMMD]
        let {
          lvl17_sgMME [Occ=OnceL] :: m_agsE3 (Data.Complex.Complex a_XgsGk)
          [LclId] =
              [$dMonadPlus_sgMMB] \u [] GHC.Base.mzero $dMonadPlus_sgMMB;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sgMMB
          of
          $dMonad_sgMMF [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgMN9 [Occ=Once]
                    :: (Data.Complex.Complex a_XgsGk, GHC.Types.Bool)
                       -> m_agsE3 (Data.Complex.Complex a_XgsGk)
                  [LclId] =
                      [lvl17_sgMME $dMonad_sgMMF] \r [ds1_sgMN4]
                          case ds1_sgMN4 of {
                            (,) x'_sgMN6 [Occ=Once] b_sgMN7 [Occ=Once!] ->
                                case b_sgMN7 of {
                                  GHC.Types.False -> lvl17_sgMME;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgMMF x'_sgMN6;
                                };
                          }; } in
                let {
                  sat_sgMN3 [Occ=Once]
                    :: m_agsE3 (Data.Complex.Complex a_XgsGk, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sgMMA
                       $dMonadPlus_sgMMB
                       ds_sgMMC
                       eta_sgMMD
                       $dMonad_sgMMF] \u []
                          case eta_sgMMD of {
                            Data.Complex.:+ a1_sgMMH [Occ=Once] a2_sgMMI [Occ=Once] ->
                                let {
                                  k_sgMMJ [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_agsE3 (d -> b)
                                       -> d -> m_agsE3 (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sgMMB
                                                ds_sgMMC
                                                $dMonad_sgMMF] \r [$dData1_sgMMK ds1_sgMML y_sgMMM]
                                          let {
                                            lvl18_sgMMN [Occ=OnceL] :: m_agsE3 d_ae2Ws
                                            [LclId] =
                                                [ds_sgMMC $dData1_sgMMK y_sgMMM] \u []
                                                    ds_sgMMC $dData1_sgMMK y_sgMMM; } in
                                          let {
                                            sat_sgMN0 [Occ=Once]
                                              :: (d_ae2Ws -> b_ae2Wt, GHC.Types.Bool)
                                                 -> m_agsE3 (b_ae2Wt, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sgMMB
                                                 $dMonad_sgMMF
                                                 y_sgMMM
                                                 lvl18_sgMMN] \r [ds2_sgMMO]
                                                    case ds2_sgMMO of {
                                                      (,) h_sgMMQ b1_sgMMR [Occ=Once] ->
                                                          let {
                                                            sat_sgMMZ [Occ=Once]
                                                              :: m_agsE3 (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgMMF
                                                                 y_sgMMM
                                                                 h_sgMMQ
                                                                 b1_sgMMR] \u []
                                                                    let {
                                                                      sat_sgMMX [Occ=Once]
                                                                        :: b_ae2Wt
                                                                      [LclId] =
                                                                          [y_sgMMM h_sgMMQ] \u []
                                                                              h_sgMMQ y_sgMMM; } in
                                                                    let {
                                                                      sat_sgMMY [Occ=Once]
                                                                        :: (b_ae2Wt, GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sgMMX
                                                                                     b1_sgMMR];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sgMMF
                                                                          sat_sgMMY; } in
                                                          let {
                                                            sat_sgMMW [Occ=Once]
                                                              :: m_agsE3 (b_ae2Wt, GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgMMF
                                                                 lvl18_sgMMN
                                                                 h_sgMMQ] \u []
                                                                    let {
                                                                      sat_sgMMV [Occ=Once]
                                                                        :: d_ae2Ws
                                                                           -> m_agsE3 (b_ae2Wt,
                                                                                       GHC.Types.Bool)
                                                                      [LclId] =
                                                                          [$dMonad_sgMMF
                                                                           h_sgMMQ] \r [y'_sgMMS]
                                                                              let {
                                                                                sat_sgMMT [Occ=Once]
                                                                                  :: b_ae2Wt
                                                                                [LclId] =
                                                                                    [h_sgMMQ
                                                                                     y'_sgMMS] \u []
                                                                                        h_sgMMQ
                                                                                            y'_sgMMS; } in
                                                                              let {
                                                                                sat_sgMMU [Occ=Once]
                                                                                  :: (b_ae2Wt,
                                                                                      GHC.Types.Bool)
                                                                                [LclId] =
                                                                                    CCCS (,)! [sat_sgMMT
                                                                                               GHC.Types.True];
                                                                              } in 
                                                                                GHC.Base.return
                                                                                    $dMonad_sgMMF
                                                                                    sat_sgMMU;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          $dMonad_sgMMF
                                                                          lvl18_sgMMN
                                                                          sat_sgMMV;
                                                          } in 
                                                            GHC.Base.mplus
                                                                $dMonadPlus_sgMMB
                                                                sat_sgMMW
                                                                sat_sgMMZ;
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sgMMF ds1_sgMML sat_sgMN0; } in
                                let {
                                  sat_sgMN2 [Occ=Once]
                                    :: Data.Data.Mp
                                         m_agsE3 (a_XgsGk -> Data.Complex.Complex a_XgsGk)
                                  [LclId] =
                                      [$dData_sgMMA $dMonad_sgMMF a1_sgMMH k_sgMMJ] \u []
                                          let {
                                            sat_sgMN1 [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_agsE3
                                                   (a_XgsGk
                                                    -> a_XgsGk -> Data.Complex.Complex a_XgsGk)
                                            [LclId] =
                                                [$dMonad_sgMMF] \u []
                                                    GHC.Base.return
                                                        $dMonad_sgMMF Data.Complex.$fDataComplex1;
                                          } in  k_sgMMJ $dData_sgMMA sat_sgMN1 a1_sgMMH;
                                } in  k_sgMMJ $dData_sgMMA sat_sgMN2 a2_sgMMI;
                          };
                } in  GHC.Base.>>= $dMonad_sgMMF sat_sgMN3 sat_sgMN9;
          };

Data.Complex.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> a -> a -> m (Data.Complex.Complex a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMNa w1_sgMNb w2_sgMNc ww_sgMNd ww1_sgMNe]
        let {
          k_sgMNf [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
            :: forall d b.
               Data.Data.Data d =>
               m_sgxtX (d -> b) -> d -> m_sgxtX b
          [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
              sat-only [w1_sgMNb w2_sgMNc] \r [$dData1_sgMNg c_sgMNh x_sgMNi]
                  let {
                    lvl17_sgMNj [Occ=OnceL] :: m_sgxtX d_ae2Vh
                    [LclId] =
                        [w2_sgMNc $dData1_sgMNg x_sgMNi] \u []
                            w2_sgMNc $dData1_sgMNg x_sgMNi; } in
                  let {
                    sat_sgMNo [Occ=Once] :: (d_ae2Vh -> b_ae2Vi) -> m_sgxtX b_ae2Vi
                    [LclId] =
                        [w1_sgMNb lvl17_sgMNj] \r [c'_sgMNk]
                            let {
                              sat_sgMNn [Occ=Once] :: d_ae2Vh -> m_sgxtX b_ae2Vi
                              [LclId] =
                                  [w1_sgMNb c'_sgMNk] \r [x'_sgMNl]
                                      let {
                                        sat_sgMNm [Occ=Once] :: b_ae2Vi
                                        [LclId] =
                                            [c'_sgMNk x'_sgMNl] \u [] c'_sgMNk x'_sgMNl;
                                      } in  GHC.Base.return w1_sgMNb sat_sgMNm;
                            } in  GHC.Base.>>= w1_sgMNb lvl17_sgMNj sat_sgMNn;
                  } in  GHC.Base.>>= w1_sgMNb c_sgMNh sat_sgMNo; } in
        let {
          sat_sgMNq [Occ=Once]
            :: m_sgxtX (a_sgxtV -> Data.Complex.Complex a_sgxtV)
          [LclId] =
              [w_sgMNa w1_sgMNb ww_sgMNd k_sgMNf] \u []
                  let {
                    sat_sgMNp [Occ=Once]
                      :: m_sgxtX (a_sgxtV -> a_sgxtV -> Data.Complex.Complex a_sgxtV)
                    [LclId] =
                        [w1_sgMNb] \u [] GHC.Base.return w1_sgMNb Data.Complex.$W:+;
                  } in  k_sgMNf w_sgMNa sat_sgMNp ww_sgMNd;
        } in  k_sgMNf w_sgMNa sat_sgMNq ww1_sgMNe;

Data.Complex.$fDataComplex_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Complex.Complex a -> m (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMNr w1_sgMNs w2_sgMNt w3_sgMNu]
        case w3_sgMNu of {
          Data.Complex.:+ ww1_sgMNw [Occ=Once] ww2_sgMNx [Occ=Once] ->
              Data.Complex.$w$cgmapM
                  w_sgMNr w1_sgMNs w2_sgMNt ww1_sgMNw ww2_sgMNx;
        };

Data.Complex.$fDataComplex_$cgmapQi
  :: forall a.
     Data.Data.Data a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Complex.Complex a
     -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgMNy ds_sgMNz ds1_sgMNA x_sgMNB]
        case x_sgMNB of {
          Data.Complex.:+ a1_sgMND [Occ=Once] a2_sgMNE [Occ=Once] ->
              case ds_sgMNz of {
                GHC.Types.I# x1_sgMNG [Occ=Once!] ->
                    case x1_sgMNG of {
                      __DEFAULT -> Data.Maybe.fromJust1;
                      0# -> ds1_sgMNA $dData_sgMNy a1_sgMND;
                      1# -> ds1_sgMNA $dData_sgMNy a2_sgMNE;
                    };
              };
        };

Data.Complex.$fDataComplex_$cgmapQr [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Complex.Complex a
     -> r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMNI w1_sgMNJ w2_sgMNK w3_sgMNL w4_sgMNM]
        case w4_sgMNM of {
          Data.Complex.:+ ww1_sgMNO [Occ=Once] ww2_sgMNP [Occ=Once] ->
              let {
                sat_sgMNS [Occ=Once] :: r_sgxu9
                [LclId] =
                    [w_sgMNI w1_sgMNJ w2_sgMNK w3_sgMNL ww2_sgMNP] \u []
                        let {
                          sat_sgMNR [Occ=Once] :: r'_sgxua
                          [LclId] =
                              [w_sgMNI w3_sgMNL ww2_sgMNP] \u [] w3_sgMNL w_sgMNI ww2_sgMNP;
                        } in  w1_sgMNJ sat_sgMNR w2_sgMNK; } in
              let {
                sat_sgMNQ [Occ=Once] :: r'_sgxua
                [LclId] =
                    [w_sgMNI w3_sgMNL ww1_sgMNO] \u [] w3_sgMNL w_sgMNI ww1_sgMNO;
              } in  w1_sgMNJ sat_sgMNQ sat_sgMNS;
        };

Data.Complex.$fDataComplex_$cgmapQ
  :: forall a.
     Data.Data.Data a =>
     forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> Data.Complex.Complex a -> [u]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,C(C1(U))><S(SS),1*U(U,U)>m2,
 Unf=OtherCon []] =
    [] \r [$dData_sgMNT ds_sgMNU x0_sgMNV]
        case x0_sgMNV of {
          Data.Complex.:+ a1_sgMNX [Occ=Once] a2_sgMNY [Occ=Once] ->
              let {
                sat_sgMO0 [Occ=Once] :: u_agsDl
                [LclId] =
                    [$dData_sgMNT ds_sgMNU a2_sgMNY] \u []
                        ds_sgMNU $dData_sgMNT a2_sgMNY; } in
              let {
                sat_sgMO1 [Occ=Once] :: [u_agsDl]
                [LclId] =
                    CCCS :! [sat_sgMO0 GHC.Types.[]]; } in
              let {
                sat_sgMNZ [Occ=Once] :: u_agsDl
                [LclId] =
                    [$dData_sgMNT ds_sgMNU a1_sgMNX] \u []
                        ds_sgMNU $dData_sgMNT a1_sgMNX;
              } in  : [sat_sgMNZ sat_sgMO1];
        };

Data.Complex.$fDataComplex2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Data.Data a =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Complex.Complex a
     -> Data.Functor.Const.Const r (Data.Complex.Complex a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMO2 w1_sgMO3 w2_sgMO4 w3_sgMO5 w4_sgMO6]
        case w4_sgMO6 of {
          Data.Complex.:+ ww1_sgMO8 [Occ=Once] ww2_sgMO9 [Occ=Once] ->
              let {
                sat_sgMOc [Occ=Once] :: r'_XgxE2
                [LclId] =
                    [w_sgMO2 w3_sgMO5 ww2_sgMO9] \u [] w3_sgMO5 w_sgMO2 ww2_sgMO9; } in
              let {
                sat_sgMOb [Occ=Once] :: r_XgxE0
                [LclId] =
                    [w_sgMO2 w1_sgMO3 w2_sgMO4 w3_sgMO5 ww1_sgMO8] \u []
                        let {
                          sat_sgMOa [Occ=Once] :: r'_XgxE2
                          [LclId] =
                              [w_sgMO2 w3_sgMO5 ww1_sgMO8] \u [] w3_sgMO5 w_sgMO2 ww1_sgMO8;
                        } in  w1_sgMO3 w2_sgMO4 sat_sgMOa;
              } in  w1_sgMO3 sat_sgMOb sat_sgMOc;
        };

Data.Complex.$fDataComplex3
  :: forall a.
     Data.Data.Data a =>
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Complex.Complex a
     -> Data.Functor.Identity.Identity (Data.Complex.Complex a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dData_sgMOd ds_sgMOe x0_sgMOf]
        case x0_sgMOf of {
          Data.Complex.:+ a1_sgMOh [Occ=Once] a2_sgMOi [Occ=Once] ->
              case ds_sgMOe $dData_sgMOd a1_sgMOh of dt_sgMOj {
                __DEFAULT ->
                    case ds_sgMOe $dData_sgMOd a2_sgMOi of dt1_sgMOk {
                      __DEFAULT -> Data.Complex.:+ [dt_sgMOj dt1_sgMOk];
                    };
              };
        };

Data.Complex.$fDataComplex_$cgmapMo
  :: forall a.
     Data.Data.Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Complex.Complex a -> m (Data.Complex.Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dData_sgMOl $dMonadPlus_sgMOm ds_sgMOn eta_sgMOo]
        let {
          lvl17_sgMOp [Occ=OnceL] :: m_agsEj (Data.Complex.Complex a_XgsGd)
          [LclId] =
              [$dMonadPlus_sgMOm] \u [] GHC.Base.mzero $dMonadPlus_sgMOm;
        } in 
          case
              GHC.Base.$p2MonadPlus $dMonadPlus_sgMOm
          of
          $dMonad_sgMOq [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgMOX [Occ=Once]
                    :: (Data.Complex.Complex a_XgsGd, GHC.Types.Bool)
                       -> m_agsEj (Data.Complex.Complex a_XgsGd)
                  [LclId] =
                      [lvl17_sgMOp $dMonad_sgMOq] \r [ds1_sgMOS]
                          case ds1_sgMOS of {
                            (,) x'_sgMOU [Occ=Once] b_sgMOV [Occ=Once!] ->
                                case b_sgMOV of {
                                  GHC.Types.False -> lvl17_sgMOp;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgMOq x'_sgMOU;
                                };
                          }; } in
                let {
                  sat_sgMOR [Occ=Once]
                    :: m_agsEj (Data.Complex.Complex a_XgsGd, GHC.Types.Bool)
                  [LclId] =
                      [$dData_sgMOl
                       $dMonadPlus_sgMOm
                       ds_sgMOn
                       eta_sgMOo
                       $dMonad_sgMOq] \u []
                          case eta_sgMOo of {
                            Data.Complex.:+ a1_sgMOs [Occ=Once] a2_sgMOt [Occ=Once] ->
                                let {
                                  k_sgMOu [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
                                    :: forall d b.
                                       Data.Data.Data d =>
                                       Data.Data.Mp m_agsEj (d -> b)
                                       -> d -> m_agsEj (b, GHC.Types.Bool)
                                  [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dMonadPlus_sgMOm
                                                ds_sgMOn
                                                $dMonad_sgMOq] \r [$dData1_sgMOv ds1_sgMOw y_sgMOx]
                                          let {
                                            lvl18_sgMOy [Occ=OnceL] :: m_agsEj d_ae2Ya
                                            [LclId] =
                                                [ds_sgMOn $dData1_sgMOv y_sgMOx] \u []
                                                    ds_sgMOn $dData1_sgMOv y_sgMOx; } in
                                          let {
                                            sat_sgMOO [Occ=Once]
                                              :: (d_ae2Ya -> b_ae2Yb, GHC.Types.Bool)
                                                 -> m_agsEj (b_ae2Yb, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonadPlus_sgMOm
                                                 $dMonad_sgMOq
                                                 y_sgMOx
                                                 lvl18_sgMOy] \r [ds2_sgMOz]
                                                    case ds2_sgMOz of {
                                                      (,) h_sgMOB b1_sgMOC [Occ=Once!] ->
                                                          case b1_sgMOC of {
                                                            GHC.Types.False ->
                                                                let {
                                                                  sat_sgMOL [Occ=Once]
                                                                    :: m_agsEj (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sgMOq
                                                                       y_sgMOx
                                                                       h_sgMOB] \u []
                                                                          let {
                                                                            sat_sgMOJ [Occ=Once]
                                                                              :: b_ae2Yb
                                                                            [LclId] =
                                                                                [y_sgMOx
                                                                                 h_sgMOB] \u []
                                                                                    h_sgMOB
                                                                                        y_sgMOx; } in
                                                                          let {
                                                                            sat_sgMOK [Occ=Once]
                                                                              :: (b_ae2Yb,
                                                                                  GHC.Types.Bool)
                                                                            [LclId] =
                                                                                CCCS (,)! [sat_sgMOJ
                                                                                           GHC.Types.False];
                                                                          } in 
                                                                            GHC.Base.return
                                                                                $dMonad_sgMOq
                                                                                sat_sgMOK; } in
                                                                let {
                                                                  sat_sgMOI [Occ=Once]
                                                                    :: m_agsEj (b_ae2Yb,
                                                                                GHC.Types.Bool)
                                                                  [LclId] =
                                                                      [$dMonad_sgMOq
                                                                       lvl18_sgMOy
                                                                       h_sgMOB] \u []
                                                                          let {
                                                                            sat_sgMOH [Occ=Once]
                                                                              :: d_ae2Ya
                                                                                 -> m_agsEj (b_ae2Yb,
                                                                                             GHC.Types.Bool)
                                                                            [LclId] =
                                                                                [$dMonad_sgMOq
                                                                                 h_sgMOB] \r [y'_sgMOE]
                                                                                    let {
                                                                                      sat_sgMOF [Occ=Once]
                                                                                        :: b_ae2Yb
                                                                                      [LclId] =
                                                                                          [h_sgMOB
                                                                                           y'_sgMOE] \u []
                                                                                              h_sgMOB
                                                                                                  y'_sgMOE; } in
                                                                                    let {
                                                                                      sat_sgMOG [Occ=Once]
                                                                                        :: (b_ae2Yb,
                                                                                            GHC.Types.Bool)
                                                                                      [LclId] =
                                                                                          CCCS (,)! [sat_sgMOF
                                                                                                     GHC.Types.True];
                                                                                    } in 
                                                                                      GHC.Base.return
                                                                                          $dMonad_sgMOq
                                                                                          sat_sgMOG;
                                                                          } in 
                                                                            GHC.Base.>>=
                                                                                $dMonad_sgMOq
                                                                                lvl18_sgMOy
                                                                                sat_sgMOH;
                                                                } in 
                                                                  GHC.Base.mplus
                                                                      $dMonadPlus_sgMOm
                                                                      sat_sgMOI
                                                                      sat_sgMOL;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_sgMOM [Occ=Once] :: b_ae2Yb
                                                                  [LclId] =
                                                                      [y_sgMOx h_sgMOB] \u []
                                                                          h_sgMOB y_sgMOx; } in
                                                                let {
                                                                  sat_sgMON [Occ=Once]
                                                                    :: (b_ae2Yb, GHC.Types.Bool)
                                                                  [LclId] =
                                                                      CCCS (,)! [sat_sgMOM
                                                                                 GHC.Types.True];
                                                                } in 
                                                                  GHC.Base.return
                                                                      $dMonad_sgMOq sat_sgMON;
                                                          };
                                                    };
                                          } in  GHC.Base.>>= $dMonad_sgMOq ds1_sgMOw sat_sgMOO; } in
                                let {
                                  sat_sgMOQ [Occ=Once]
                                    :: Data.Data.Mp
                                         m_agsEj (a_XgsGd -> Data.Complex.Complex a_XgsGd)
                                  [LclId] =
                                      [$dData_sgMOl $dMonad_sgMOq a1_sgMOs k_sgMOu] \u []
                                          let {
                                            sat_sgMOP [Occ=Once]
                                              :: Data.Data.Mp
                                                   m_agsEj
                                                   (a_XgsGd
                                                    -> a_XgsGd -> Data.Complex.Complex a_XgsGd)
                                            [LclId] =
                                                [$dMonad_sgMOq] \u []
                                                    GHC.Base.return
                                                        $dMonad_sgMOq Data.Complex.$fDataComplex1;
                                          } in  k_sgMOu $dData_sgMOl sat_sgMOP a1_sgMOs;
                                } in  k_sgMOu $dData_sgMOl sat_sgMOQ a2_sgMOt;
                          };
                } in  GHC.Base.>>= $dMonad_sgMOq sat_sgMOR sat_sgMOX;
          };

lvl14_rgA6z :: forall a. Data.Complex.Complex a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_sgMOY]
        case ds_sgMOY of {
          Data.Complex.:+ _ [Occ=Dead] _ [Occ=Dead] -> Data.Complex.$c:+;
        };

lvl15_rgA6A
  :: forall a. Data.Complex.Complex a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgMP2] Data.Complex.$tComplex;

lvl16_rgA6B
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Complex.Complex a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgMP3 ds_sgMP4] GHC.Base.Nothing [];

Data.Complex.$fDataComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Data.Data a =>
     Data.Data.Data (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>] =
    [] \r [$dData_sgMP5]
        let {
          sat_sgMPh [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Complex.Complex a_XgsGc -> m (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgMP5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapMo
                      $dData_sgMP5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMPg [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.MonadPlus m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Complex.Complex a_XgsGc -> m (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgMP5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapMp
                      $dData_sgMP5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMPf [Occ=Once]
            :: forall (m :: * -> *).
               GHC.Base.Monad m =>
               (forall d. Data.Data.Data d => d -> m d)
               -> Data.Complex.Complex a_XgsGc -> m (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgMP5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapM
                      $dData_sgMP5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMPe [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Complex.Complex a_XgsGc
               -> u
          [LclId] =
              [$dData_sgMP5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapQi
                      $dData_sgMP5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMPd [Occ=Once]
            :: forall u.
               (forall d. Data.Data.Data d => d -> u)
               -> Data.Complex.Complex a_XgsGc -> [u]
          [LclId] =
              [$dData_sgMP5] \r [eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapQ $dData_sgMP5 eta_B2 eta_B1; } in
        let {
          sat_sgMPc [Occ=Once]
            :: forall r r'.
               (r' -> r -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Complex.Complex a_XgsGc
               -> r
          [LclId] =
              [$dData_sgMP5] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgmapQr
                      $dData_sgMP5 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMPb [Occ=Once]
            :: forall r r'.
               (r -> r' -> r)
               -> r
               -> (forall d. Data.Data.Data d => d -> r')
               -> Data.Complex.Complex a_XgsGc
               -> r
          [LclId] =
              [$dData_sgMP5] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex2
                      $dData_sgMP5 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMPa [Occ=Once]
            :: (forall b. Data.Data.Data b => b -> b)
               -> Data.Complex.Complex a_XgsGc -> Data.Complex.Complex a_XgsGc
          [LclId] =
              [$dData_sgMP5] \r [eta_B2 eta_B1]
                  Data.Complex.$fDataComplex3 $dData_sgMP5 eta_B2 eta_B1; } in
        let {
          sat_sgMP9 [Occ=Once]
            :: forall (t :: * -> *) (c :: * -> *).
               Data.Typeable.Internal.Typeable t =>
               (forall d. Data.Data.Data d => c (t d))
               -> GHC.Base.Maybe (c (Data.Complex.Complex a_XgsGc))
          [LclId] =
              [$dData_sgMP5] \r [eta_B1]
                  Data.Complex.$fDataComplex_$cdataCast1 $dData_sgMP5 eta_B1; } in
        let {
          sat_sgMP8 [Occ=Once]
            :: forall (c :: * -> *).
               (forall b r. Data.Data.Data b => c (b -> r) -> c r)
               -> (forall r. r -> c r)
               -> Data.Data.Constr
               -> c (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgMP5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgunfold
                      $dData_sgMP5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMP7 [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Complex.Complex a_XgsGc
               -> c (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgMP5] \r [eta_B3 eta_B2 eta_B1]
                  Data.Complex.$fDataComplex_$cgfoldl
                      $dData_sgMP5 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgMP6 [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Complex.Complex a_XgsGc)
          [LclId] =
              [$dData_sgMP5] \u [] Data.Complex.$fDataComplex10 $dData_sgMP5;
        } in 
          Data.Data.C:Data [sat_sgMP6
                            sat_sgMP7
                            sat_sgMP8
                            lvl14_rgA6z
                            lvl15_rgA6A
                            sat_sgMP9
                            lvl16_rgA6B
                            sat_sgMPa
                            sat_sgMPb
                            sat_sgMPc
                            sat_sgMPd
                            sat_sgMPe
                            sat_sgMPf
                            sat_sgMPg
                            sat_sgMPh];

Data.Complex.$fFloatingComplex9 :: GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.F#! [0.0#];

Data.Complex.$fFloatingComplex_$s$cpi1
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [GHC.Float.$fFloatingFloat_$cpi
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$fFloatingComplex_$s$cexp1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMPi]
        case ds_sgMPi of {
          Data.Complex.:+ x_sgMPk [Occ=Once!] y_sgMPl [Occ=Once!] ->
              case x_sgMPk of {
                GHC.Types.F# x1_sgMPn [Occ=Once] ->
                    case y_sgMPl of {
                      GHC.Types.F# x2_sgMPp ->
                          case expFloat# [x1_sgMPn] of expx_sgMPq {
                            __DEFAULT ->
                                case sinFloat# [x2_sgMPp] of sat_sgMPu {
                                  __DEFAULT ->
                                      case timesFloat# [expx_sgMPq sat_sgMPu] of sat_sgMPv {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMPw [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgMPv];
                                            } in 
                                              case cosFloat# [x2_sgMPp] of sat_sgMPr {
                                                __DEFAULT ->
                                                    case
                                                        timesFloat# [expx_sgMPq sat_sgMPr]
                                                    of
                                                    sat_sgMPs
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_sgMPt [Occ=Once] :: GHC.Types.Float
                                                            [LclId] =
                                                                CCCS GHC.Types.F#! [sat_sgMPs];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgMPt sat_sgMPw];
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$csin1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMPx]
        case ds_sgMPx of {
          Data.Complex.:+ x_sgMPz [Occ=Once!] y_sgMPA [Occ=Once!] ->
              case y_sgMPA of {
                GHC.Types.F# x1_sgMPC ->
                    case x_sgMPz of {
                      GHC.Types.F# x2_sgMPE ->
                          case sinhFloat# [x1_sgMPC] of sat_sgMPK {
                            __DEFAULT ->
                                case cosFloat# [x2_sgMPE] of sat_sgMPJ {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgMPJ sat_sgMPK] of sat_sgMPL {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMPM [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgMPL];
                                            } in 
                                              case coshFloat# [x1_sgMPC] of sat_sgMPG {
                                                __DEFAULT ->
                                                    case sinFloat# [x2_sgMPE] of sat_sgMPF {
                                                      __DEFAULT ->
                                                          case
                                                              timesFloat# [sat_sgMPF sat_sgMPG]
                                                          of
                                                          sat_sgMPH
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgMPI [Occ=Once]
                                                                    :: GHC.Types.Float
                                                                  [LclId] =
                                                                      CCCS GHC.Types.F#! [sat_sgMPH];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgMPI
                                                                                   sat_sgMPM];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ccos1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMPN]
        case ds_sgMPN of {
          Data.Complex.:+ x_sgMPP [Occ=Once!] y_sgMPQ [Occ=Once!] ->
              case y_sgMPQ of {
                GHC.Types.F# x1_sgMPS ->
                    case x_sgMPP of {
                      GHC.Types.F# x2_sgMPU ->
                          case sinhFloat# [x1_sgMPS] of sat_sgMQ0 {
                            __DEFAULT ->
                                case sinFloat# [x2_sgMPU] of sat_sgMPZ {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgMPZ sat_sgMQ0] of sat_sgMQ1 {
                                        __DEFAULT ->
                                            case negateFloat# [sat_sgMQ1] of sat_sgMQ2 {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgMQ3 [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [sat_sgMQ2];
                                                  } in 
                                                    case coshFloat# [x1_sgMPS] of sat_sgMPW {
                                                      __DEFAULT ->
                                                          case cosFloat# [x2_sgMPU] of sat_sgMPV {
                                                            __DEFAULT ->
                                                                case
                                                                    timesFloat# [sat_sgMPV
                                                                                 sat_sgMPW]
                                                                of
                                                                sat_sgMPX
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_sgMPY [Occ=Once]
                                                                          :: GHC.Types.Float
                                                                        [LclId] =
                                                                            CCCS GHC.Types.F#! [sat_sgMPX];
                                                                      } in 
                                                                        Data.Complex.:+ [sat_sgMPY
                                                                                         sat_sgMQ3];
                                                                };
                                                          };
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$csinh1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMQ4]
        case ds_sgMQ4 of {
          Data.Complex.:+ x_sgMQ6 [Occ=Once!] y_sgMQ7 [Occ=Once!] ->
              case x_sgMQ6 of {
                GHC.Types.F# x1_sgMQ9 ->
                    case y_sgMQ7 of {
                      GHC.Types.F# x2_sgMQb ->
                          case coshFloat# [x1_sgMQ9] of sat_sgMQh {
                            __DEFAULT ->
                                case sinFloat# [x2_sgMQb] of sat_sgMQg {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgMQg sat_sgMQh] of sat_sgMQi {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMQj [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgMQi];
                                            } in 
                                              case sinhFloat# [x1_sgMQ9] of sat_sgMQd {
                                                __DEFAULT ->
                                                    case cosFloat# [x2_sgMQb] of sat_sgMQc {
                                                      __DEFAULT ->
                                                          case
                                                              timesFloat# [sat_sgMQc sat_sgMQd]
                                                          of
                                                          sat_sgMQe
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgMQf [Occ=Once]
                                                                    :: GHC.Types.Float
                                                                  [LclId] =
                                                                      CCCS GHC.Types.F#! [sat_sgMQe];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgMQf
                                                                                   sat_sgMQj];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ccosh1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMQk]
        case ds_sgMQk of {
          Data.Complex.:+ x_sgMQm [Occ=Once!] y_sgMQn [Occ=Once!] ->
              case x_sgMQm of {
                GHC.Types.F# x1_sgMQp ->
                    case y_sgMQn of {
                      GHC.Types.F# x2_sgMQr ->
                          case sinhFloat# [x1_sgMQp] of sat_sgMQx {
                            __DEFAULT ->
                                case sinFloat# [x2_sgMQr] of sat_sgMQw {
                                  __DEFAULT ->
                                      case timesFloat# [sat_sgMQw sat_sgMQx] of sat_sgMQy {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMQz [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [sat_sgMQy];
                                            } in 
                                              case coshFloat# [x1_sgMQp] of sat_sgMQt {
                                                __DEFAULT ->
                                                    case cosFloat# [x2_sgMQr] of sat_sgMQs {
                                                      __DEFAULT ->
                                                          case
                                                              timesFloat# [sat_sgMQs sat_sgMQt]
                                                          of
                                                          sat_sgMQu
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgMQv [Occ=Once]
                                                                    :: GHC.Types.Float
                                                                  [LclId] =
                                                                      CCCS GHC.Types.F#! [sat_sgMQu];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgMQv
                                                                                   sat_sgMQz];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$s$c/1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgMQA ww1_sgMQB ww2_sgMQC ww3_sgMQD]
        case GHC.Float.$w$cexponent1 ww2_sgMQC of ww4_sgMQE {
          __DEFAULT ->
              case GHC.Float.$w$cexponent1 ww3_sgMQD of ww5_sgMQF {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgMQG [Occ=Once*!T[1], Dmd=<C(S),1*C1(U(U,U))>]
                        :: GHC.Prim.Int# -> (# GHC.Types.Float, GHC.Types.Float #)
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgMQA ww1_sgMQB ww2_sgMQC ww3_sgMQD] \r [ww6_sgMQH]
                              case GHC.Float.$w$cscaleFloat1 ww6_sgMQH ww2_sgMQC of ww7_sgMQI {
                                __DEFAULT ->
                                    case
                                        GHC.Float.$w$cscaleFloat1 ww6_sgMQH ww3_sgMQD
                                    of
                                    ww8_sgMQJ
                                    { __DEFAULT ->
                                          case timesFloat# [ww3_sgMQD ww8_sgMQJ] of sat_sgMQM {
                                            __DEFAULT ->
                                                case
                                                    timesFloat# [ww2_sgMQC ww7_sgMQI]
                                                of
                                                sat_sgMQL
                                                { __DEFAULT ->
                                                      case
                                                          plusFloat# [sat_sgMQL sat_sgMQM]
                                                      of
                                                      y_sgMQK [Dmd=<S,U>]
                                                      { __DEFAULT ->
                                                            case
                                                                timesFloat# [ww1_sgMQB ww8_sgMQJ]
                                                            of
                                                            sat_sgMQO
                                                            { __DEFAULT ->
                                                                  case
                                                                      timesFloat# [ww_sgMQA
                                                                                   ww7_sgMQI]
                                                                  of
                                                                  sat_sgMQN
                                                                  { __DEFAULT ->
                                                                        case
                                                                            plusFloat# [sat_sgMQN
                                                                                        sat_sgMQO]
                                                                        of
                                                                        sat_sgMQP
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  divideFloat# [sat_sgMQP
                                                                                                y_sgMQK]
                                                                              of
                                                                              wild2_sgMQQ
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        timesFloat# [ww_sgMQA
                                                                                                     ww8_sgMQJ]
                                                                                    of
                                                                                    sat_sgMQS
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              timesFloat# [ww1_sgMQB
                                                                                                           ww7_sgMQI]
                                                                                          of
                                                                                          sat_sgMQR
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    minusFloat# [sat_sgMQR
                                                                                                                 sat_sgMQS]
                                                                                                of
                                                                                                sat_sgMQT
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          divideFloat# [sat_sgMQT
                                                                                                                        y_sgMQK]
                                                                                                      of
                                                                                                      wild1_sgMQU
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgMQW [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [wild1_sgMQU]; } in
                                                                                                            let {
                                                                                                              sat_sgMQV [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [wild2_sgMQQ];
                                                                                                            } in 
                                                                                                              (#,#) [sat_sgMQV
                                                                                                                     sat_sgMQW];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww4_sgMQE ww5_sgMQF] of {
                        __DEFAULT ->
                            case negateInt# [ww4_sgMQE] of sat_sgMQY {
                              __DEFAULT -> $j_sgMQG sat_sgMQY;
                            };
                        1# ->
                            case negateInt# [ww5_sgMQF] of sat_sgMQZ {
                              __DEFAULT -> $j_sgMQG sat_sgMQZ;
                            };
                      };
              };
        };

Data.Complex.$fFloatingComplex_$s$c/1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMR0 w1_sgMR1]
        case w_sgMR0 of {
          Data.Complex.:+ ww1_sgMR3 [Occ=Once!] ww2_sgMR4 [Occ=Once!] ->
              case ww1_sgMR3 of {
                GHC.Types.F# ww4_sgMR6 [Occ=Once] ->
                    case ww2_sgMR4 of {
                      GHC.Types.F# ww6_sgMR8 [Occ=Once] ->
                          case w1_sgMR1 of {
                            Data.Complex.:+ ww8_sgMRa [Occ=Once!] ww9_sgMRb [Occ=Once!] ->
                                case ww8_sgMRa of {
                                  GHC.Types.F# ww11_sgMRd [Occ=Once] ->
                                      case ww9_sgMRb of {
                                        GHC.Types.F# ww13_sgMRf [Occ=Once] ->
                                            case
                                                Data.Complex.$w$s$c/1
                                                    ww4_sgMR6 ww6_sgMR8 ww11_sgMRd ww13_sgMRf
                                            of
                                            { (#,#) ww15_sgMRh [Occ=Once] ww16_sgMRi [Occ=Once] ->
                                                  Data.Complex.:+ [ww15_sgMRh ww16_sgMRi];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromRational1
  :: GHC.Real.Rational -> Data.Complex.Complex GHC.Types.Float
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [a_sgMRj]
        case a_sgMRj of {
          GHC.Real.:% n_sgMRl [Occ=Once] d_sgMRm [Occ=Once] ->
              case GHC.Float.rationalToFloat n_sgMRl d_sgMRm of dt_sgMRn {
                GHC.Types.F# _ [Occ=Dead] ->
                    Data.Complex.:+ [dt_sgMRn Data.Complex.$fFloatingComplex9];
              };
        };

Data.Complex.$fFloatingComplex_$s$c+1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMRp w1_sgMRq]
        case w_sgMRp of {
          Data.Complex.:+ ww1_sgMRs [Occ=Once!] ww2_sgMRt [Occ=Once!] ->
              case ww1_sgMRs of {
                GHC.Types.F# ww4_sgMRv [Occ=Once] ->
                    case ww2_sgMRt of {
                      GHC.Types.F# ww6_sgMRx [Occ=Once] ->
                          case w1_sgMRq of {
                            Data.Complex.:+ ww8_sgMRz [Occ=Once!] ww9_sgMRA [Occ=Once!] ->
                                case ww8_sgMRz of {
                                  GHC.Types.F# ww11_sgMRC [Occ=Once] ->
                                      case ww9_sgMRA of {
                                        GHC.Types.F# ww13_sgMRE [Occ=Once] ->
                                            case plusFloat# [ww6_sgMRx ww13_sgMRE] of sat_sgMRH {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgMRI [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [sat_sgMRH];
                                                  } in 
                                                    case
                                                        plusFloat# [ww4_sgMRv ww11_sgMRC]
                                                    of
                                                    sat_sgMRF
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_sgMRG [Occ=Once] :: GHC.Types.Float
                                                            [LclId] =
                                                                CCCS GHC.Types.F#! [sat_sgMRF];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgMRG sat_sgMRI];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c-1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMRJ w1_sgMRK]
        case w_sgMRJ of {
          Data.Complex.:+ ww1_sgMRM [Occ=Once!] ww2_sgMRN [Occ=Once!] ->
              case ww1_sgMRM of {
                GHC.Types.F# ww4_sgMRP [Occ=Once] ->
                    case ww2_sgMRN of {
                      GHC.Types.F# ww6_sgMRR [Occ=Once] ->
                          case w1_sgMRK of {
                            Data.Complex.:+ ww8_sgMRT [Occ=Once!] ww9_sgMRU [Occ=Once!] ->
                                case ww8_sgMRT of {
                                  GHC.Types.F# ww11_sgMRW [Occ=Once] ->
                                      case ww9_sgMRU of {
                                        GHC.Types.F# ww13_sgMRY [Occ=Once] ->
                                            case minusFloat# [ww6_sgMRR ww13_sgMRY] of sat_sgMS1 {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgMS2 [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [sat_sgMS1];
                                                  } in 
                                                    case
                                                        minusFloat# [ww4_sgMRP ww11_sgMRW]
                                                    of
                                                    sat_sgMRZ
                                                    { __DEFAULT ->
                                                          let {
                                                            sat_sgMS0 [Occ=Once] :: GHC.Types.Float
                                                            [LclId] =
                                                                CCCS GHC.Types.F#! [sat_sgMRZ];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgMS0 sat_sgMS2];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c*1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMS3 w1_sgMS4]
        case w_sgMS3 of {
          Data.Complex.:+ ww1_sgMS6 [Occ=Once!] ww2_sgMS7 [Occ=Once!] ->
              case ww1_sgMS6 of {
                GHC.Types.F# ww4_sgMS9 ->
                    case ww2_sgMS7 of {
                      GHC.Types.F# ww6_sgMSb ->
                          case w1_sgMS4 of {
                            Data.Complex.:+ ww8_sgMSd [Occ=Once!] ww9_sgMSe [Occ=Once!] ->
                                case ww8_sgMSd of {
                                  GHC.Types.F# ww11_sgMSg ->
                                      case ww9_sgMSe of {
                                        GHC.Types.F# ww13_sgMSi ->
                                            case timesFloat# [ww6_sgMSb ww11_sgMSg] of sat_sgMSo {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [ww4_sgMS9 ww13_sgMSi]
                                                  of
                                                  sat_sgMSn
                                                  { __DEFAULT ->
                                                        case
                                                            plusFloat# [sat_sgMSn sat_sgMSo]
                                                        of
                                                        sat_sgMSp
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_sgMSq [Occ=Once]
                                                                  :: GHC.Types.Float
                                                                [LclId] =
                                                                    CCCS GHC.Types.F#! [sat_sgMSp];
                                                              } in 
                                                                case
                                                                    timesFloat# [ww6_sgMSb
                                                                                 ww13_sgMSi]
                                                                of
                                                                sat_sgMSk
                                                                { __DEFAULT ->
                                                                      case
                                                                          timesFloat# [ww4_sgMS9
                                                                                       ww11_sgMSg]
                                                                      of
                                                                      sat_sgMSj
                                                                      { __DEFAULT ->
                                                                            case
                                                                                minusFloat# [sat_sgMSj
                                                                                             sat_sgMSk]
                                                                            of
                                                                            sat_sgMSl
                                                                            { __DEFAULT ->
                                                                                  let {
                                                                                    sat_sgMSm [Occ=Once]
                                                                                      :: GHC.Types.Float
                                                                                    [LclId] =
                                                                                        CCCS GHC.Types.F#! [sat_sgMSl];
                                                                                  } in 
                                                                                    Data.Complex.:+ [sat_sgMSm
                                                                                                     sat_sgMSq];
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cnegate1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMSr]
        case ds_sgMSr of {
          Data.Complex.:+ x_sgMSt [Occ=Once!] y_sgMSu [Occ=Once!] ->
              case x_sgMSt of {
                GHC.Types.F# x1_sgMSw [Occ=Once] ->
                    case y_sgMSu of {
                      GHC.Types.F# x2_sgMSy [Occ=Once] ->
                          case negateFloat# [x2_sgMSy] of sat_sgMSB {
                            __DEFAULT ->
                                let {
                                  sat_sgMSC [Occ=Once] :: GHC.Types.Float
                                  [LclId] =
                                      CCCS GHC.Types.F#! [sat_sgMSB];
                                } in 
                                  case negateFloat# [x1_sgMSw] of sat_sgMSz {
                                    __DEFAULT ->
                                        let {
                                          sat_sgMSA [Occ=Once] :: GHC.Types.Float
                                          [LclId] =
                                              CCCS GHC.Types.F#! [sat_sgMSz];
                                        } in  Data.Complex.:+ [sat_sgMSA sat_sgMSC];
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromInteger1
  :: GHC.Integer.Type.Integer -> Data.Complex.Complex GHC.Types.Float
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [n_sgMSD]
        case GHC.Integer.Type.floatFromInteger n_sgMSD of wild_sgMSE {
          __DEFAULT ->
              let {
                sat_sgMSF [Occ=Once] :: GHC.Types.Float
                [LclId] =
                    CCCS GHC.Types.F#! [wild_sgMSE];
              } in  Data.Complex.:+ [sat_sgMSF Data.Complex.$fFloatingComplex9];
        };

Data.Complex.conjugate_$sconjugate
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMSG]
        case ds_sgMSG of {
          Data.Complex.:+ x_sgMSI [Occ=Once] y_sgMSJ [Occ=Once!] ->
              case y_sgMSJ of {
                GHC.Types.D# x1_sgMSL [Occ=Once] ->
                    case negateDouble# [x1_sgMSL] of sat_sgMSM {
                      __DEFAULT ->
                          let {
                            sat_sgMSN [Occ=Once] :: GHC.Types.Double
                            [LclId] =
                                CCCS GHC.Types.D#! [sat_sgMSM];
                          } in  Data.Complex.:+ [x_sgMSI sat_sgMSN];
                    };
              };
        };

Data.Complex.conjugate
  :: forall a.
     GHC.Num.Num a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LLL),1*U(A,A,A,1*C1(U),A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dNum_sgMSO ds_sgMSP]
        case ds_sgMSP of {
          Data.Complex.:+ x_sgMSR [Occ=Once] y_sgMSS [Occ=Once] ->
              case GHC.Num.negate $dNum_sgMSO y_sgMSS of dt_sgMST {
                __DEFAULT -> Data.Complex.:+ [x_sgMSR dt_sgMST];
              };
        };

Data.Complex.cis_$scis
  :: GHC.Types.Double -> Data.Complex.Complex GHC.Types.Double
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [theta_sgMSU]
        case theta_sgMSU of {
          GHC.Types.D# x_sgMSW ->
              case sinDouble# [x_sgMSW] of sat_sgMSZ {
                __DEFAULT ->
                    let {
                      sat_sgMT0 [Occ=Once] :: GHC.Types.Double
                      [LclId] =
                          CCCS GHC.Types.D#! [sat_sgMSZ];
                    } in 
                      case cosDouble# [x_sgMSW] of sat_sgMSX {
                        __DEFAULT ->
                            let {
                              sat_sgMSY [Occ=Once] :: GHC.Types.Double
                              [LclId] =
                                  CCCS GHC.Types.D#! [sat_sgMSX];
                            } in  Data.Complex.:+ [sat_sgMSY sat_sgMT0];
                      };
              };
        };

Data.Complex.cis
  :: forall a. GHC.Float.Floating a => a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)C(S)LLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFloating_sgMT1 theta_sgMT2]
        case GHC.Float.cos $dFloating_sgMT1 theta_sgMT2 of dt_sgMT3 {
          __DEFAULT ->
              case GHC.Float.sin $dFloating_sgMT1 theta_sgMT2 of dt1_sgMT4 {
                __DEFAULT -> Data.Complex.:+ [dt_sgMT3 dt1_sgMT4];
              };
        };

Data.Complex.mkPolar_$smkPolar
  :: GHC.Types.Double
     -> GHC.Types.Double -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [r_sgMT5 theta_sgMT6]
        case r_sgMT5 of {
          GHC.Types.D# x_sgMT8 ->
              case theta_sgMT6 of {
                GHC.Types.D# x1_sgMTa ->
                    case sinDouble# [x1_sgMTa] of sat_sgMTe {
                      __DEFAULT ->
                          case *## [x_sgMT8 sat_sgMTe] of sat_sgMTf {
                            __DEFAULT ->
                                let {
                                  sat_sgMTg [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [sat_sgMTf];
                                } in 
                                  case cosDouble# [x1_sgMTa] of sat_sgMTb {
                                    __DEFAULT ->
                                        case *## [x_sgMT8 sat_sgMTb] of sat_sgMTc {
                                          __DEFAULT ->
                                              let {
                                                sat_sgMTd [Occ=Once] :: GHC.Types.Double
                                                [LclId] =
                                                    CCCS GHC.Types.D#! [sat_sgMTc];
                                              } in  Data.Complex.:+ [sat_sgMTd sat_sgMTg];
                                        };
                                  };
                          };
                    };
              };
        };

Data.Complex.$wmkPolar [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.Floating a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LLC(C(S))LLLL)LLL)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A,A),A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMTh w1_sgMTi w2_sgMTj]
        case
            GHC.Float.$p1Floating w_sgMTh
        of
        $dFractional_sgMTk [Dmd=<S(S(LLC(C(S))LLLL)LLL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1Fractional $dFractional_sgMTk
              of
              $dNum_sgMTl [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
              { __DEFAULT ->
                    let {
                      sat_sgMTm [Occ=Once] :: a_sgxwP
                      [LclId] =
                          [w_sgMTh w2_sgMTj] \u [] GHC.Float.cos w_sgMTh w2_sgMTj;
                    } in 
                      case GHC.Num.* $dNum_sgMTl w1_sgMTi sat_sgMTm of dt_sgMTn {
                        __DEFAULT ->
                            let {
                              sat_sgMTo [Occ=Once] :: a_sgxwP
                              [LclId] =
                                  [w_sgMTh w2_sgMTj] \u [] GHC.Float.sin w_sgMTh w2_sgMTj;
                            } in 
                              case GHC.Num.* $dNum_sgMTl w1_sgMTi sat_sgMTo of dt1_sgMTp {
                                __DEFAULT -> (#,#) [dt_sgMTn dt1_sgMTp];
                              };
                      };
              };
        };

Data.Complex.mkPolar [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.Floating a =>
     a -> a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LLC(C(S))LLLL)LLL)LLLLLLLLLLLLLLLLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),A,A,A),A,A,A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgMTq w1_sgMTr w2_sgMTs]
        case Data.Complex.$wmkPolar w_sgMTq w1_sgMTr w2_sgMTs of {
          (#,#) ww1_sgMTu [Occ=Once] ww2_sgMTv [Occ=Once] ->
              Data.Complex.:+ [ww1_sgMTu ww2_sgMTv];
        };

Data.Complex.$w$sphase [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> GHC.Prim.Double#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_sgMTw ww1_sgMTx]
        case ==## [ww_sgMTw 0.0##] of {
          __DEFAULT ->
              let {
                sat_sgMTz [Occ=Once] :: GHC.Types.Double
                [LclId] =
                    CCCS GHC.Types.D#! [ww1_sgMTx];
              } in  GHC.Float.$w$catan2 sat_sgMTz ww_sgMTw;
          1# ->
              case ==## [ww1_sgMTx 0.0##] of {
                __DEFAULT ->
                    let {
                      sat_sgMTB [Occ=Once] :: GHC.Types.Double
                      [LclId] =
                          CCCS GHC.Types.D#! [ww1_sgMTx];
                    } in  GHC.Float.$w$catan2 sat_sgMTB ww_sgMTw;
                1# -> 0.0##;
              };
        };

Data.Complex.$fFloatingComplex_$sphase [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double -> GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMTC]
        case w_sgMTC of {
          Data.Complex.:+ ww1_sgMTE [Occ=Once!] ww2_sgMTF [Occ=Once!] ->
              case ww1_sgMTE of {
                GHC.Types.D# ww4_sgMTH [Occ=Once] ->
                    case ww2_sgMTF of {
                      GHC.Types.D# ww6_sgMTJ [Occ=Once] ->
                          case Data.Complex.$w$sphase ww4_sgMTH ww6_sgMTJ of ww7_sgMTK {
                            __DEFAULT -> GHC.Types.D# [ww7_sgMTK];
                          };
                    };
              };
        };

Data.Complex.$w$sphase1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> GHC.Prim.Float#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><L,U>, Unf=OtherCon []] =
    [] \r [ww_sgMTL ww1_sgMTM]
        case eqFloat# [ww_sgMTL 0.0#] of {
          __DEFAULT ->
              let {
                sat_sgMTO [Occ=Once] :: GHC.Types.Float
                [LclId] =
                    CCCS GHC.Types.F#! [ww1_sgMTM];
              } in  GHC.Float.$w$catan1 sat_sgMTO ww_sgMTL;
          1# ->
              case eqFloat# [ww1_sgMTM 0.0#] of {
                __DEFAULT ->
                    let {
                      sat_sgMTQ [Occ=Once] :: GHC.Types.Float
                      [LclId] =
                          CCCS GHC.Types.F#! [ww1_sgMTM];
                    } in  GHC.Float.$w$catan1 sat_sgMTQ ww_sgMTL;
                1# -> 0.0#;
              };
        };

Data.Complex.$fFloatingComplex_$sphase1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float -> GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMTR]
        case w_sgMTR of {
          Data.Complex.:+ ww1_sgMTT [Occ=Once!] ww2_sgMTU [Occ=Once!] ->
              case ww1_sgMTT of {
                GHC.Types.F# ww4_sgMTW [Occ=Once] ->
                    case ww2_sgMTU of {
                      GHC.Types.F# ww6_sgMTY [Occ=Once] ->
                          case Data.Complex.$w$sphase1 ww4_sgMTW ww6_sgMTY of ww7_sgMTZ {
                            __DEFAULT -> GHC.Types.F# [ww7_sgMTZ];
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex17 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Complex.$wphase [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMU0 ww_sgMU1 ww1_sgMU2]
        case
            GHC.Float.$p1RealFloat w_sgMU0
        of
        $dRealFrac_sgMU3 [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgMU3
              of
              $dReal_sgMU4 [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      $dNum_sgMU5 [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_sgxxx
                      [LclId] =
                          [$dReal_sgMU4] \u [] GHC.Real.$p1Real $dReal_sgMU4;
                    } in 
                      case
                          GHC.Real.$p2Real $dReal_sgMU4
                      of
                      $dOrd_sgMU6 [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                      { __DEFAULT ->
                            case
                                GHC.Classes.$p1Ord $dOrd_sgMU6
                            of
                            $dEq_sgMU7 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                            { __DEFAULT ->
                                  let {
                                    sat_sgMU8 [Occ=Once] :: a_sgxxx
                                    [LclId] =
                                        [$dNum_sgMU5] \u []
                                            GHC.Num.fromInteger
                                                $dNum_sgMU5 Data.Complex.$fFloatingComplex17;
                                  } in 
                                    case GHC.Classes.== $dEq_sgMU7 ww_sgMU1 sat_sgMU8 of {
                                      GHC.Types.False -> GHC.Float.atan2 w_sgMU0 ww1_sgMU2 ww_sgMU1;
                                      GHC.Types.True ->
                                          let {
                                            sat_sgMUa [Occ=Once] :: a_sgxxx
                                            [LclId] =
                                                [$dNum_sgMU5] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_sgMU5
                                                        Data.Complex.$fFloatingComplex17;
                                          } in 
                                            case GHC.Classes.== $dEq_sgMU7 ww1_sgMU2 sat_sgMUa of {
                                              GHC.Types.False ->
                                                  GHC.Float.atan2 w_sgMU0 ww1_sgMU2 ww_sgMU1;
                                              GHC.Types.True ->
                                                  GHC.Num.fromInteger
                                                      $dNum_sgMU5 Data.Complex.$fFloatingComplex17;
                                            };
                                    };
                            };
                      };
              };
        };

Data.Complex.phase [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMUc w1_sgMUd]
        case w1_sgMUd of {
          Data.Complex.:+ ww1_sgMUf [Occ=Once] ww2_sgMUg [Occ=Once] ->
              Data.Complex.$wphase w_sgMUc ww1_sgMUf ww2_sgMUg;
        };

Data.Complex.$w$smagnitude [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> GHC.Prim.Double#
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgMUh ww1_sgMUi]
        case GHC.Float.$w$cexponent ww_sgMUh of ww2_sgMUj {
          __DEFAULT ->
              case GHC.Float.$w$cexponent ww1_sgMUi of ww3_sgMUk {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgMUl [Occ=Once*!T[1], Dmd=<C(S),1*C1(U)>]
                        :: GHC.Prim.Int# -> GHC.Prim.Double#
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgMUh ww1_sgMUi] \r [x_sgMUm]
                              case negateInt# [x_sgMUm] of ww4_sgMUn [Dmd=<S,U>] {
                                __DEFAULT ->
                                    case GHC.Float.$w$cscaleFloat ww4_sgMUn ww_sgMUh of ww5_sgMUo {
                                      __DEFAULT ->
                                          case
                                              GHC.Float.$w$cscaleFloat ww4_sgMUn ww1_sgMUi
                                          of
                                          ww6_sgMUp
                                          { __DEFAULT ->
                                                case *## [ww6_sgMUp ww6_sgMUp] of sat_sgMUr {
                                                  __DEFAULT ->
                                                      case *## [ww5_sgMUo ww5_sgMUo] of sat_sgMUq {
                                                        __DEFAULT ->
                                                            case
                                                                +## [sat_sgMUq sat_sgMUr]
                                                            of
                                                            sat_sgMUs
                                                            { __DEFAULT ->
                                                                  case
                                                                      sqrtDouble# [sat_sgMUs]
                                                                  of
                                                                  sat_sgMUt
                                                                  { __DEFAULT ->
                                                                        GHC.Float.$w$cscaleFloat
                                                                            x_sgMUm sat_sgMUt;
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww2_sgMUj ww3_sgMUk] of {
                        __DEFAULT -> $j_sgMUl ww2_sgMUj;
                        1# -> $j_sgMUl ww3_sgMUk;
                      };
              };
        };

Data.Complex.$fFloatingComplex_$smagnitude [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double -> GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMUv]
        case w_sgMUv of {
          Data.Complex.:+ ww1_sgMUx [Occ=Once!] ww2_sgMUy [Occ=Once!] ->
              case ww1_sgMUx of {
                GHC.Types.D# ww4_sgMUA [Occ=Once] ->
                    case ww2_sgMUy of {
                      GHC.Types.D# ww6_sgMUC [Occ=Once] ->
                          case Data.Complex.$w$smagnitude ww4_sgMUA ww6_sgMUC of ww7_sgMUD {
                            __DEFAULT -> GHC.Types.D# [ww7_sgMUD];
                          };
                    };
              };
        };

Data.Complex.$w$smagnitude1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> GHC.Prim.Float#
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgMUE ww1_sgMUF]
        case GHC.Float.$w$cexponent1 ww_sgMUE of ww2_sgMUG {
          __DEFAULT ->
              case GHC.Float.$w$cexponent1 ww1_sgMUF of ww3_sgMUH {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgMUI [Occ=Once*!T[1], Dmd=<C(S),1*C1(U)>]
                        :: GHC.Prim.Int# -> GHC.Prim.Float#
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgMUE ww1_sgMUF] \r [x_sgMUJ]
                              case negateInt# [x_sgMUJ] of ww4_sgMUK [Dmd=<S,U>] {
                                __DEFAULT ->
                                    case GHC.Float.$w$cscaleFloat1 ww4_sgMUK ww_sgMUE of ww5_sgMUL {
                                      __DEFAULT ->
                                          case
                                              GHC.Float.$w$cscaleFloat1 ww4_sgMUK ww1_sgMUF
                                          of
                                          ww6_sgMUM
                                          { __DEFAULT ->
                                                case
                                                    timesFloat# [ww6_sgMUM ww6_sgMUM]
                                                of
                                                sat_sgMUO
                                                { __DEFAULT ->
                                                      case
                                                          timesFloat# [ww5_sgMUL ww5_sgMUL]
                                                      of
                                                      sat_sgMUN
                                                      { __DEFAULT ->
                                                            case
                                                                plusFloat# [sat_sgMUN sat_sgMUO]
                                                            of
                                                            sat_sgMUP
                                                            { __DEFAULT ->
                                                                  case
                                                                      sqrtFloat# [sat_sgMUP]
                                                                  of
                                                                  sat_sgMUQ
                                                                  { __DEFAULT ->
                                                                        GHC.Float.$w$cscaleFloat1
                                                                            x_sgMUJ sat_sgMUQ;
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww2_sgMUG ww3_sgMUH] of {
                        __DEFAULT -> $j_sgMUI ww2_sgMUG;
                        1# -> $j_sgMUI ww3_sgMUH;
                      };
              };
        };

Data.Complex.$fFloatingComplex_$smagnitude1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float -> GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMUS]
        case w_sgMUS of {
          Data.Complex.:+ ww1_sgMUU [Occ=Once!] ww2_sgMUV [Occ=Once!] ->
              case ww1_sgMUU of {
                GHC.Types.F# ww4_sgMUX [Occ=Once] ->
                    case ww2_sgMUV of {
                      GHC.Types.F# ww6_sgMUZ [Occ=Once] ->
                          case Data.Complex.$w$smagnitude1 ww4_sgMUX ww6_sgMUZ of ww7_sgMV0 {
                            __DEFAULT -> GHC.Types.F# [ww7_sgMV0];
                          };
                    };
              };
        };

Data.Complex.$wmagnitude [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(C(S))LLLLLL),U(1*U(1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMV1 ww_sgMV2 ww1_sgMV3]
        let {
          k_sgMV4 [Dmd=<L,U(U)>] :: GHC.Types.Int
          [LclId] =
              [w_sgMV1 ww_sgMV2 ww1_sgMV3] \u []
                  case GHC.Float.exponent w_sgMV1 ww_sgMV2 of wild_sgMV5 {
                    GHC.Types.I# x1_sgMV6 [Occ=Once] ->
                        case GHC.Float.exponent w_sgMV1 ww1_sgMV3 of wild1_sgMV7 {
                          GHC.Types.I# y1_sgMV8 [Occ=Once] ->
                              case <=# [x1_sgMV6 y1_sgMV8] of {
                                __DEFAULT -> wild_sgMV5;
                                1# -> wild1_sgMV7;
                              };
                        };
                  }; } in
        let {
          sat_sgMVn [Occ=Once] :: a_sgxyi
          [LclId] =
              [w_sgMV1 ww_sgMV2 ww1_sgMV3 k_sgMV4] \u []
                  let {
                    sat_sgMVm [Occ=Once] :: a_sgxyi
                    [LclId] =
                        [w_sgMV1 ww_sgMV2 ww1_sgMV3 k_sgMV4] \u []
                            case
                                GHC.Float.$p1RealFloat w_sgMV1
                            of
                            $dRealFrac_sgMVb [Dmd=<S(S(S(C(C(S))LLLLLL)LL)LLLLLL),1*U(1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
                            { __DEFAULT ->
                                  case
                                      GHC.Real.$p1RealFrac $dRealFrac_sgMVb
                                  of
                                  $dReal_sgMVc [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A)>]
                                  { __DEFAULT ->
                                        case
                                            GHC.Real.$p1Real $dReal_sgMVc
                                        of
                                        $dNum_sgMVd [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A)>]
                                        { __DEFAULT ->
                                              let {
                                                mk_sgMVe :: GHC.Types.Int
                                                [LclId] =
                                                    [k_sgMV4] \u []
                                                        case k_sgMV4 of {
                                                          GHC.Types.I# x_sgMVg [Occ=Once] ->
                                                              case
                                                                  negateInt# [x_sgMVg]
                                                              of
                                                              sat_sgMVh
                                                              { __DEFAULT ->
                                                                    GHC.Types.I# [sat_sgMVh];
                                                              };
                                                        }; } in
                                              let {
                                                sat_sgMVl [Occ=Once] :: a_sgxyi
                                                [LclId] =
                                                    [w_sgMV1 ww1_sgMV3 $dNum_sgMVd mk_sgMVe] \u []
                                                        let {
                                                          z_sgMVk :: a_sgxyi
                                                          [LclId] =
                                                              [w_sgMV1 ww1_sgMV3 mk_sgMVe] \u []
                                                                  GHC.Float.scaleFloat
                                                                      w_sgMV1 mk_sgMVe ww1_sgMV3;
                                                        } in 
                                                          GHC.Num.*
                                                              $dNum_sgMVd z_sgMVk z_sgMVk; } in
                                              let {
                                                sat_sgMVj [Occ=Once] :: a_sgxyi
                                                [LclId] =
                                                    [w_sgMV1 ww_sgMV2 $dNum_sgMVd mk_sgMVe] \u []
                                                        let {
                                                          z_sgMVi :: a_sgxyi
                                                          [LclId] =
                                                              [w_sgMV1 ww_sgMV2 mk_sgMVe] \u []
                                                                  GHC.Float.scaleFloat
                                                                      w_sgMV1 mk_sgMVe ww_sgMV2;
                                                        } in  GHC.Num.* $dNum_sgMVd z_sgMVi z_sgMVi;
                                              } in  GHC.Num.+ $dNum_sgMVd sat_sgMVj sat_sgMVl;
                                        };
                                  };
                            };
                  } in 
                    case GHC.Float.$p2RealFloat w_sgMV1 of sat_sgMVa {
                      __DEFAULT -> GHC.Float.sqrt sat_sgMVa sat_sgMVm;
                    };
        } in  GHC.Float.scaleFloat w_sgMV1 k_sgMV4 sat_sgMVn;

Data.Complex.magnitude [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => Data.Complex.Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgMVo w1_sgMVp]
        case w1_sgMVp of {
          Data.Complex.:+ ww1_sgMVr [Occ=Once] ww2_sgMVs [Occ=Once] ->
              Data.Complex.$wmagnitude w_sgMVo ww1_sgMVr ww2_sgMVs;
        };

Data.Complex.$fFloatingComplex_$s$clog1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMVt]
        case w_sgMVt of {
          Data.Complex.:+ ww1_sgMVv [Occ=Once!] ww2_sgMVw [Occ=Once!] ->
              case ww1_sgMVv of {
                GHC.Types.F# ww4_sgMVy ->
                    case ww2_sgMVw of {
                      GHC.Types.F# ww6_sgMVA ->
                          case Data.Complex.$w$smagnitude1 ww4_sgMVy ww6_sgMVA of ww7_sgMVB {
                            __DEFAULT ->
                                case logFloat# [ww7_sgMVB] of wild1_sgMVC {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$sphase1 ww4_sgMVy ww6_sgMVA
                                      of
                                      ww8_sgMVD
                                      { __DEFAULT ->
                                            let {
                                              sat_sgMVF [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [ww8_sgMVD]; } in
                                            let {
                                              sat_sgMVE [Occ=Once] :: GHC.Types.Float
                                              [LclId] =
                                                  CCCS GHC.Types.F#! [wild1_sgMVC];
                                            } in  Data.Complex.:+ [sat_sgMVE sat_sgMVF];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cabs1
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [z_sgMVG]
        case z_sgMVG of {
          Data.Complex.:+ ww1_sgMVI [Occ=Once!] ww2_sgMVJ [Occ=Once!] ->
              case ww1_sgMVI of {
                GHC.Types.F# ww4_sgMVL [Occ=Once] ->
                    case ww2_sgMVJ of {
                      GHC.Types.F# ww6_sgMVN [Occ=Once] ->
                          case Data.Complex.$w$smagnitude1 ww4_sgMVL ww6_sgMVN of ww7_sgMVO {
                            __DEFAULT ->
                                let {
                                  sat_sgMVP [Occ=Once] :: GHC.Types.Float
                                  [LclId] =
                                      CCCS GHC.Types.F#! [ww7_sgMVO];
                                } in  Data.Complex.:+ [sat_sgMVP Data.Complex.$fFloatingComplex9];
                          };
                    };
              };
        };

Data.Complex.polar_$spolar
  :: Data.Complex.Complex GHC.Types.Double
     -> (GHC.Types.Double, GHC.Types.Double)
[GblId, Arity=1, Str=<L,U(U(U),U(U))>m, Unf=OtherCon []] =
    [] \r [z_sgMVQ]
        let {
          sat_sgMVS [Occ=Once] :: GHC.Types.Double
          [LclId] =
              [z_sgMVQ] \u []
                  Data.Complex.$fFloatingComplex_$sphase z_sgMVQ; } in
        let {
          sat_sgMVR [Occ=Once] :: GHC.Types.Double
          [LclId] =
              [z_sgMVQ] \u [] Data.Complex.$fFloatingComplex_$smagnitude z_sgMVQ;
        } in  (,) [sat_sgMVR sat_sgMVS];

Data.Complex.polar
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> (a, a)
[GblId,
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgMVT z_sgMVU]
        let {
          sat_sgMVW [Occ=Once] :: a_agsyd
          [LclId] =
              [$dRealFloat_sgMVT z_sgMVU] \u []
                  Data.Complex.phase $dRealFloat_sgMVT z_sgMVU; } in
        let {
          sat_sgMVV [Occ=Once] :: a_agsyd
          [LclId] =
              [$dRealFloat_sgMVT z_sgMVU] \u []
                  Data.Complex.magnitude $dRealFloat_sgMVT z_sgMVU;
        } in  (,) [sat_sgMVV sat_sgMVW];

Data.Complex.$fFloatingComplex1 :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.D#! [0.0##];

Data.Complex.$fFloatingComplex_$s$cpi
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [GHC.Float.$fFloatingDouble_$cpi
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$w$cpi [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => (# a, a #)
[GblId,
 Arity=1,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)S(LSLLLLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A),1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [w_sgMVX]
        case GHC.Float.$p2RealFloat w_sgMVX of sat_sgMVY {
          __DEFAULT ->
              case GHC.Float.pi sat_sgMVY of dt_sgMVZ {
                __DEFAULT ->
                    case GHC.Float.$p1RealFloat w_sgMVX of sat_sgMW0 {
                      __DEFAULT ->
                          case GHC.Real.$p1RealFrac sat_sgMW0 of sat_sgMW1 {
                            __DEFAULT ->
                                case GHC.Real.$p1Real sat_sgMW1 of sat_sgMW2 {
                                  __DEFAULT ->
                                      case
                                          GHC.Num.fromInteger
                                              sat_sgMW2 Data.Complex.$fFloatingComplex17
                                      of
                                      dt1_sgMW3
                                      { __DEFAULT -> (#,#) [dt_sgMVZ dt1_sgMW3];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cpi [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => Data.Complex.Complex a
[GblId,
 Arity=1,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)S(LSLLLLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMW4]
        case Data.Complex.$w$cpi w_sgMW4 of {
          (#,#) ww1_sgMW6 [Occ=Once] ww2_sgMW7 [Occ=Once] ->
              Data.Complex.:+ [ww1_sgMW6 ww2_sgMW7];
        };

Data.Complex.$fFloatingComplex_$s$cexp
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMW8]
        case ds_sgMW8 of {
          Data.Complex.:+ x_sgMWa [Occ=Once!] y_sgMWb [Occ=Once!] ->
              case x_sgMWa of {
                GHC.Types.D# x1_sgMWd [Occ=Once] ->
                    case y_sgMWb of {
                      GHC.Types.D# x2_sgMWf ->
                          case expDouble# [x1_sgMWd] of expx_sgMWg {
                            __DEFAULT ->
                                case sinDouble# [x2_sgMWf] of sat_sgMWk {
                                  __DEFAULT ->
                                      case *## [expx_sgMWg sat_sgMWk] of sat_sgMWl {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMWm [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgMWl];
                                            } in 
                                              case cosDouble# [x2_sgMWf] of sat_sgMWh {
                                                __DEFAULT ->
                                                    case *## [expx_sgMWg sat_sgMWh] of sat_sgMWi {
                                                      __DEFAULT ->
                                                          let {
                                                            sat_sgMWj [Occ=Once] :: GHC.Types.Double
                                                            [LclId] =
                                                                CCCS GHC.Types.D#! [sat_sgMWi];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgMWj sat_sgMWm];
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$cexp [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMWn ww_sgMWo ww1_sgMWp]
        case
            GHC.Float.$p1RealFloat w_sgMWn
        of
        $dRealFrac_sgMWq [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgMWq
              of
              $dReal_sgMWr [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgMWr
                    of
                    $dNum_sgMWs [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dFloating_sgMWt [Dmd=<L,U(A,A,1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
                              :: GHC.Float.Floating a_sgxyP
                            [LclId] =
                                [w_sgMWn] \u [] GHC.Float.$p2RealFloat w_sgMWn; } in
                          let {
                            expx_sgMWu :: a_sgxyP
                            [LclId] =
                                [ww_sgMWo $dFloating_sgMWt] \u []
                                    GHC.Float.exp $dFloating_sgMWt ww_sgMWo; } in
                          let {
                            sat_sgMWv [Occ=Once] :: a_sgxyP
                            [LclId] =
                                [ww1_sgMWp $dFloating_sgMWt] \u []
                                    GHC.Float.cos $dFloating_sgMWt ww1_sgMWp;
                          } in 
                            case GHC.Num.* $dNum_sgMWs expx_sgMWu sat_sgMWv of dt_sgMWw {
                              __DEFAULT ->
                                  let {
                                    sat_sgMWx [Occ=Once] :: a_sgxyP
                                    [LclId] =
                                        [ww1_sgMWp $dFloating_sgMWt] \u []
                                            GHC.Float.sin $dFloating_sgMWt ww1_sgMWp;
                                  } in 
                                    case GHC.Num.* $dNum_sgMWs expx_sgMWu sat_sgMWx of dt1_sgMWy {
                                      __DEFAULT -> (#,#) [dt_sgMWw dt1_sgMWy];
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cexp [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMWz w1_sgMWA]
        case w1_sgMWA of {
          Data.Complex.:+ ww1_sgMWC [Occ=Once] ww2_sgMWD [Occ=Once] ->
              case Data.Complex.$w$cexp w_sgMWz ww1_sgMWC ww2_sgMWD of {
                (#,#) ww4_sgMWF [Occ=Once] ww5_sgMWG [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgMWF ww5_sgMWG];
              };
        };

Data.Complex.$fFloatingComplex_$s$clog [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMWH]
        case w_sgMWH of {
          Data.Complex.:+ ww1_sgMWJ [Occ=Once!] ww2_sgMWK [Occ=Once!] ->
              case ww1_sgMWJ of {
                GHC.Types.D# ww4_sgMWM ->
                    case ww2_sgMWK of {
                      GHC.Types.D# ww6_sgMWO ->
                          case Data.Complex.$w$smagnitude ww4_sgMWM ww6_sgMWO of ww7_sgMWP {
                            __DEFAULT ->
                                case logDouble# [ww7_sgMWP] of wild1_sgMWQ {
                                  __DEFAULT ->
                                      case Data.Complex.$w$sphase ww4_sgMWM ww6_sgMWO of ww8_sgMWR {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMWT [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [ww8_sgMWR]; } in
                                            let {
                                              sat_sgMWS [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [wild1_sgMWQ];
                                            } in  Data.Complex.:+ [sat_sgMWS sat_sgMWT];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$clog [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMWU ww_sgMWV ww1_sgMWW]
        let {
          sat_sgMWY [Occ=Once] :: a_sgxzj
          [LclId] =
              [w_sgMWU ww_sgMWV ww1_sgMWW] \u []
                  Data.Complex.$wmagnitude w_sgMWU ww_sgMWV ww1_sgMWW;
        } in 
          case GHC.Float.$p2RealFloat w_sgMWU of sat_sgMWX {
            __DEFAULT ->
                case GHC.Float.log sat_sgMWX sat_sgMWY of dt_sgMWZ {
                  __DEFAULT ->
                      case Data.Complex.$wphase w_sgMWU ww_sgMWV ww1_sgMWW of dt1_sgMX0 {
                        __DEFAULT -> (#,#) [dt_sgMWZ dt1_sgMX0];
                      };
                };
          };

Data.Complex.$fFloatingComplex_$clog [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMX1 w1_sgMX2]
        case w1_sgMX2 of {
          Data.Complex.:+ ww1_sgMX4 [Occ=Once] ww2_sgMX5 [Occ=Once] ->
              case Data.Complex.$w$clog w_sgMX1 ww1_sgMX4 ww2_sgMX5 of {
                (#,#) ww4_sgMX7 [Occ=Once] ww5_sgMX8 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgMX7 ww5_sgMX8];
              };
        };

Data.Complex.$fFloatingComplex_$s$csin
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMX9]
        case ds_sgMX9 of {
          Data.Complex.:+ x_sgMXb [Occ=Once!] y_sgMXc [Occ=Once!] ->
              case y_sgMXc of {
                GHC.Types.D# x1_sgMXe ->
                    case x_sgMXb of {
                      GHC.Types.D# x2_sgMXg ->
                          case sinhDouble# [x1_sgMXe] of sat_sgMXm {
                            __DEFAULT ->
                                case cosDouble# [x2_sgMXg] of sat_sgMXl {
                                  __DEFAULT ->
                                      case *## [sat_sgMXl sat_sgMXm] of sat_sgMXn {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMXo [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgMXn];
                                            } in 
                                              case coshDouble# [x1_sgMXe] of sat_sgMXi {
                                                __DEFAULT ->
                                                    case sinDouble# [x2_sgMXg] of sat_sgMXh {
                                                      __DEFAULT ->
                                                          case
                                                              *## [sat_sgMXh sat_sgMXi]
                                                          of
                                                          sat_sgMXj
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgMXk [Occ=Once]
                                                                    :: GHC.Types.Double
                                                                  [LclId] =
                                                                      CCCS GHC.Types.D#! [sat_sgMXj];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgMXk
                                                                                   sat_sgMXo];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$csin [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMXp ww_sgMXq ww1_sgMXr]
        let {
          $dFloating_sgMXs [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxzv
          [LclId] =
              [w_sgMXp] \u [] GHC.Float.$p2RealFloat w_sgMXp;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgMXp
          of
          $dRealFrac_sgMXt [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgMXt
                of
                $dReal_sgMXu [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgMXu
                      of
                      $dNum_sgMXv [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgMXx [Occ=Once] :: a_sgxzv
                              [LclId] =
                                  [ww1_sgMXr $dFloating_sgMXs] \u []
                                      GHC.Float.cosh $dFloating_sgMXs ww1_sgMXr; } in
                            let {
                              sat_sgMXw [Occ=Once] :: a_sgxzv
                              [LclId] =
                                  [ww_sgMXq $dFloating_sgMXs] \u []
                                      GHC.Float.sin $dFloating_sgMXs ww_sgMXq;
                            } in 
                              case GHC.Num.* $dNum_sgMXv sat_sgMXw sat_sgMXx of dt_sgMXy {
                                __DEFAULT ->
                                    let {
                                      sat_sgMXA [Occ=Once] :: a_sgxzv
                                      [LclId] =
                                          [ww1_sgMXr $dFloating_sgMXs] \u []
                                              GHC.Float.sinh $dFloating_sgMXs ww1_sgMXr; } in
                                    let {
                                      sat_sgMXz [Occ=Once] :: a_sgxzv
                                      [LclId] =
                                          [ww_sgMXq $dFloating_sgMXs] \u []
                                              GHC.Float.cos $dFloating_sgMXs ww_sgMXq;
                                    } in 
                                      case GHC.Num.* $dNum_sgMXv sat_sgMXz sat_sgMXA of dt1_sgMXB {
                                        __DEFAULT -> (#,#) [dt_sgMXy dt1_sgMXB];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$csin [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMXC w1_sgMXD]
        case w1_sgMXD of {
          Data.Complex.:+ ww1_sgMXF [Occ=Once] ww2_sgMXG [Occ=Once] ->
              case Data.Complex.$w$csin w_sgMXC ww1_sgMXF ww2_sgMXG of {
                (#,#) ww4_sgMXI [Occ=Once] ww5_sgMXJ [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgMXI ww5_sgMXJ];
              };
        };

Data.Complex.$fFloatingComplex_$s$ccos
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMXK]
        case ds_sgMXK of {
          Data.Complex.:+ x_sgMXM [Occ=Once!] y_sgMXN [Occ=Once!] ->
              case y_sgMXN of {
                GHC.Types.D# x1_sgMXP ->
                    case x_sgMXM of {
                      GHC.Types.D# x2_sgMXR ->
                          case sinhDouble# [x1_sgMXP] of sat_sgMXX {
                            __DEFAULT ->
                                case sinDouble# [x2_sgMXR] of sat_sgMXW {
                                  __DEFAULT ->
                                      case *## [sat_sgMXW sat_sgMXX] of sat_sgMXY {
                                        __DEFAULT ->
                                            case negateDouble# [sat_sgMXY] of sat_sgMXZ {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgMY0 [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [sat_sgMXZ];
                                                  } in 
                                                    case coshDouble# [x1_sgMXP] of sat_sgMXT {
                                                      __DEFAULT ->
                                                          case cosDouble# [x2_sgMXR] of sat_sgMXS {
                                                            __DEFAULT ->
                                                                case
                                                                    *## [sat_sgMXS sat_sgMXT]
                                                                of
                                                                sat_sgMXU
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_sgMXV [Occ=Once]
                                                                          :: GHC.Types.Double
                                                                        [LclId] =
                                                                            CCCS GHC.Types.D#! [sat_sgMXU];
                                                                      } in 
                                                                        Data.Complex.:+ [sat_sgMXV
                                                                                         sat_sgMY0];
                                                                };
                                                          };
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ccos [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMY1 ww_sgMY2 ww1_sgMY3]
        let {
          $dFloating_sgMY4 [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxzH
          [LclId] =
              [w_sgMY1] \u [] GHC.Float.$p2RealFloat w_sgMY1;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgMY1
          of
          $dRealFrac_sgMY5 [Dmd=<S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgMY5
                of
                $dReal_sgMY6 [Dmd=<S(S(LLC(C(S))C(S)LLL)LL),1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgMY6
                      of
                      $dNum_sgMY7 [Dmd=<S(LLC(C(S))C(S)LLL),U(A,A,C(C1(U)),1*C1(U),A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgMY9 [Occ=Once] :: a_sgxzH
                              [LclId] =
                                  [ww1_sgMY3 $dFloating_sgMY4] \u []
                                      GHC.Float.cosh $dFloating_sgMY4 ww1_sgMY3; } in
                            let {
                              sat_sgMY8 [Occ=Once] :: a_sgxzH
                              [LclId] =
                                  [ww_sgMY2 $dFloating_sgMY4] \u []
                                      GHC.Float.cos $dFloating_sgMY4 ww_sgMY2;
                            } in 
                              case GHC.Num.* $dNum_sgMY7 sat_sgMY8 sat_sgMY9 of dt_sgMYa {
                                __DEFAULT ->
                                    let {
                                      sat_sgMYd [Occ=Once] :: a_sgxzH
                                      [LclId] =
                                          [ww_sgMY2 ww1_sgMY3 $dFloating_sgMY4 $dNum_sgMY7] \u []
                                              let {
                                                sat_sgMYc [Occ=Once] :: a_sgxzH
                                                [LclId] =
                                                    [ww1_sgMY3 $dFloating_sgMY4] \u []
                                                        GHC.Float.sinh
                                                            $dFloating_sgMY4 ww1_sgMY3; } in
                                              let {
                                                sat_sgMYb [Occ=Once] :: a_sgxzH
                                                [LclId] =
                                                    [ww_sgMY2 $dFloating_sgMY4] \u []
                                                        GHC.Float.sin $dFloating_sgMY4 ww_sgMY2;
                                              } in  GHC.Num.* $dNum_sgMY7 sat_sgMYb sat_sgMYc;
                                    } in 
                                      case GHC.Num.negate $dNum_sgMY7 sat_sgMYd of dt1_sgMYe {
                                        __DEFAULT -> (#,#) [dt_sgMYa dt1_sgMYe];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$ccos [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),C(U),A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMYf w1_sgMYg]
        case w1_sgMYg of {
          Data.Complex.:+ ww1_sgMYi [Occ=Once] ww2_sgMYj [Occ=Once] ->
              case Data.Complex.$w$ccos w_sgMYf ww1_sgMYi ww2_sgMYj of {
                (#,#) ww4_sgMYl [Occ=Once] ww5_sgMYm [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgMYl ww5_sgMYm];
              };
        };

Data.Complex.$fFloatingComplex_$s$csinh
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMYn]
        case ds_sgMYn of {
          Data.Complex.:+ x_sgMYp [Occ=Once!] y_sgMYq [Occ=Once!] ->
              case x_sgMYp of {
                GHC.Types.D# x1_sgMYs ->
                    case y_sgMYq of {
                      GHC.Types.D# x2_sgMYu ->
                          case coshDouble# [x1_sgMYs] of sat_sgMYA {
                            __DEFAULT ->
                                case sinDouble# [x2_sgMYu] of sat_sgMYz {
                                  __DEFAULT ->
                                      case *## [sat_sgMYz sat_sgMYA] of sat_sgMYB {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMYC [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgMYB];
                                            } in 
                                              case sinhDouble# [x1_sgMYs] of sat_sgMYw {
                                                __DEFAULT ->
                                                    case cosDouble# [x2_sgMYu] of sat_sgMYv {
                                                      __DEFAULT ->
                                                          case
                                                              *## [sat_sgMYv sat_sgMYw]
                                                          of
                                                          sat_sgMYx
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgMYy [Occ=Once]
                                                                    :: GHC.Types.Double
                                                                  [LclId] =
                                                                      CCCS GHC.Types.D#! [sat_sgMYx];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgMYy
                                                                                   sat_sgMYC];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$csinh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMYD ww_sgMYE ww1_sgMYF]
        let {
          $dFloating_sgMYG [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxzT
          [LclId] =
              [w_sgMYD] \u [] GHC.Float.$p2RealFloat w_sgMYD;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgMYD
          of
          $dRealFrac_sgMYH [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgMYH
                of
                $dReal_sgMYI [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgMYI
                      of
                      $dNum_sgMYJ [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgMYL [Occ=Once] :: a_sgxzT
                              [LclId] =
                                  [ww_sgMYE $dFloating_sgMYG] \u []
                                      GHC.Float.sinh $dFloating_sgMYG ww_sgMYE; } in
                            let {
                              sat_sgMYK [Occ=Once] :: a_sgxzT
                              [LclId] =
                                  [ww1_sgMYF $dFloating_sgMYG] \u []
                                      GHC.Float.cos $dFloating_sgMYG ww1_sgMYF;
                            } in 
                              case GHC.Num.* $dNum_sgMYJ sat_sgMYK sat_sgMYL of dt_sgMYM {
                                __DEFAULT ->
                                    let {
                                      sat_sgMYO [Occ=Once] :: a_sgxzT
                                      [LclId] =
                                          [ww_sgMYE $dFloating_sgMYG] \u []
                                              GHC.Float.cosh $dFloating_sgMYG ww_sgMYE; } in
                                    let {
                                      sat_sgMYN [Occ=Once] :: a_sgxzT
                                      [LclId] =
                                          [ww1_sgMYF $dFloating_sgMYG] \u []
                                              GHC.Float.sin $dFloating_sgMYG ww1_sgMYF;
                                    } in 
                                      case GHC.Num.* $dNum_sgMYJ sat_sgMYN sat_sgMYO of dt1_sgMYP {
                                        __DEFAULT -> (#,#) [dt_sgMYM dt1_sgMYP];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$csinh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMYQ w1_sgMYR]
        case w1_sgMYR of {
          Data.Complex.:+ ww1_sgMYT [Occ=Once] ww2_sgMYU [Occ=Once] ->
              case Data.Complex.$w$csinh w_sgMYQ ww1_sgMYT ww2_sgMYU of {
                (#,#) ww4_sgMYW [Occ=Once] ww5_sgMYX [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgMYW ww5_sgMYX];
              };
        };

Data.Complex.$fFloatingComplex_$s$ccosh
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgMYY]
        case ds_sgMYY of {
          Data.Complex.:+ x_sgMZ0 [Occ=Once!] y_sgMZ1 [Occ=Once!] ->
              case x_sgMZ0 of {
                GHC.Types.D# x1_sgMZ3 ->
                    case y_sgMZ1 of {
                      GHC.Types.D# x2_sgMZ5 ->
                          case sinhDouble# [x1_sgMZ3] of sat_sgMZb {
                            __DEFAULT ->
                                case sinDouble# [x2_sgMZ5] of sat_sgMZa {
                                  __DEFAULT ->
                                      case *## [sat_sgMZa sat_sgMZb] of sat_sgMZc {
                                        __DEFAULT ->
                                            let {
                                              sat_sgMZd [Occ=Once] :: GHC.Types.Double
                                              [LclId] =
                                                  CCCS GHC.Types.D#! [sat_sgMZc];
                                            } in 
                                              case coshDouble# [x1_sgMZ3] of sat_sgMZ7 {
                                                __DEFAULT ->
                                                    case cosDouble# [x2_sgMZ5] of sat_sgMZ6 {
                                                      __DEFAULT ->
                                                          case
                                                              *## [sat_sgMZ6 sat_sgMZ7]
                                                          of
                                                          sat_sgMZ8
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgMZ9 [Occ=Once]
                                                                    :: GHC.Types.Double
                                                                  [LclId] =
                                                                      CCCS GHC.Types.D#! [sat_sgMZ8];
                                                                } in 
                                                                  Data.Complex.:+ [sat_sgMZ9
                                                                                   sat_sgMZd];
                                                          };
                                                    };
                                              };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ccosh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgMZe ww_sgMZf ww1_sgMZg]
        let {
          $dFloating_sgMZh [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
            :: GHC.Float.Floating a_sgxA5
          [LclId] =
              [w_sgMZe] \u [] GHC.Float.$p2RealFloat w_sgMZe;
        } in 
          case
              GHC.Float.$p1RealFloat w_sgMZe
          of
          $dRealFrac_sgMZi [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          { __DEFAULT ->
                case
                    GHC.Real.$p1RealFrac $dRealFrac_sgMZi
                of
                $dReal_sgMZj [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
                { __DEFAULT ->
                      case
                          GHC.Real.$p1Real $dReal_sgMZj
                      of
                      $dNum_sgMZk [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                      { __DEFAULT ->
                            let {
                              sat_sgMZm [Occ=Once] :: a_sgxA5
                              [LclId] =
                                  [ww_sgMZf $dFloating_sgMZh] \u []
                                      GHC.Float.cosh $dFloating_sgMZh ww_sgMZf; } in
                            let {
                              sat_sgMZl [Occ=Once] :: a_sgxA5
                              [LclId] =
                                  [ww1_sgMZg $dFloating_sgMZh] \u []
                                      GHC.Float.cos $dFloating_sgMZh ww1_sgMZg;
                            } in 
                              case GHC.Num.* $dNum_sgMZk sat_sgMZl sat_sgMZm of dt_sgMZn {
                                __DEFAULT ->
                                    let {
                                      sat_sgMZp [Occ=Once] :: a_sgxA5
                                      [LclId] =
                                          [ww_sgMZf $dFloating_sgMZh] \u []
                                              GHC.Float.sinh $dFloating_sgMZh ww_sgMZf; } in
                                    let {
                                      sat_sgMZo [Occ=Once] :: a_sgxA5
                                      [LclId] =
                                          [ww1_sgMZg $dFloating_sgMZh] \u []
                                              GHC.Float.sin $dFloating_sgMZh ww1_sgMZg;
                                    } in 
                                      case GHC.Num.* $dNum_sgMZk sat_sgMZo sat_sgMZp of dt1_sgMZq {
                                        __DEFAULT -> (#,#) [dt_sgMZn dt1_sgMZq];
                                      };
                              };
                      };
                };
          };

Data.Complex.$fFloatingComplex_$ccosh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgMZr w1_sgMZs]
        case w1_sgMZs of {
          Data.Complex.:+ ww1_sgMZu [Occ=Once] ww2_sgMZv [Occ=Once] ->
              case Data.Complex.$w$ccosh w_sgMZr ww1_sgMZu ww2_sgMZv of {
                (#,#) ww4_sgMZx [Occ=Once] ww5_sgMZy [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgMZx ww5_sgMZy];
              };
        };

Data.Complex.$w$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=4, Str=<S,U><S,U><S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgMZz ww1_sgMZA ww2_sgMZB ww3_sgMZC]
        case GHC.Float.$w$cexponent ww2_sgMZB of ww4_sgMZD {
          __DEFAULT ->
              case GHC.Float.$w$cexponent ww3_sgMZC of ww5_sgMZE {
                __DEFAULT ->
                    let-no-escape {
                      $j_sgMZF [Occ=Once*!T[1], Dmd=<C(S),1*C1(U(U,U))>]
                        :: GHC.Prim.Int# -> (# GHC.Types.Double, GHC.Types.Double #)
                      [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ww_sgMZz ww1_sgMZA ww2_sgMZB ww3_sgMZC] \r [ww6_sgMZG]
                              case GHC.Float.$w$cscaleFloat ww6_sgMZG ww2_sgMZB of ww7_sgMZH {
                                __DEFAULT ->
                                    case GHC.Float.$w$cscaleFloat ww6_sgMZG ww3_sgMZC of ww8_sgMZI {
                                      __DEFAULT ->
                                          case *## [ww3_sgMZC ww8_sgMZI] of sat_sgMZL {
                                            __DEFAULT ->
                                                case *## [ww2_sgMZB ww7_sgMZH] of sat_sgMZK {
                                                  __DEFAULT ->
                                                      case
                                                          +## [sat_sgMZK sat_sgMZL]
                                                      of
                                                      y_sgMZJ [Dmd=<S,U>]
                                                      { __DEFAULT ->
                                                            case
                                                                *## [ww1_sgMZA ww8_sgMZI]
                                                            of
                                                            sat_sgMZN
                                                            { __DEFAULT ->
                                                                  case
                                                                      *## [ww_sgMZz ww7_sgMZH]
                                                                  of
                                                                  sat_sgMZM
                                                                  { __DEFAULT ->
                                                                        case
                                                                            +## [sat_sgMZM
                                                                                 sat_sgMZN]
                                                                        of
                                                                        sat_sgMZO
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  /## [sat_sgMZO
                                                                                       y_sgMZJ]
                                                                              of
                                                                              wild2_sgMZP
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        *## [ww_sgMZz
                                                                                             ww8_sgMZI]
                                                                                    of
                                                                                    sat_sgMZR
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              *## [ww1_sgMZA
                                                                                                   ww7_sgMZH]
                                                                                          of
                                                                                          sat_sgMZQ
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    -## [sat_sgMZQ
                                                                                                         sat_sgMZR]
                                                                                                of
                                                                                                sat_sgMZS
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          /## [sat_sgMZS
                                                                                                               y_sgMZJ]
                                                                                                      of
                                                                                                      wild1_sgMZT
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgMZV [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [wild1_sgMZT]; } in
                                                                                                            let {
                                                                                                              sat_sgMZU [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [wild2_sgMZP];
                                                                                                            } in 
                                                                                                              (#,#) [sat_sgMZU
                                                                                                                     sat_sgMZV];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                    } in 
                      case <=# [ww4_sgMZD ww5_sgMZE] of {
                        __DEFAULT ->
                            case negateInt# [ww4_sgMZD] of sat_sgMZX {
                              __DEFAULT -> $j_sgMZF sat_sgMZX;
                            };
                        1# ->
                            case negateInt# [ww5_sgMZE] of sat_sgMZY {
                              __DEFAULT -> $j_sgMZF sat_sgMZY;
                            };
                      };
              };
        };

Data.Complex.$fFloatingComplex_$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgMZZ w1_sgN00]
        case w_sgMZZ of {
          Data.Complex.:+ ww1_sgN02 [Occ=Once!] ww2_sgN03 [Occ=Once!] ->
              case ww1_sgN02 of {
                GHC.Types.D# ww4_sgN05 [Occ=Once] ->
                    case ww2_sgN03 of {
                      GHC.Types.D# ww6_sgN07 [Occ=Once] ->
                          case w1_sgN00 of {
                            Data.Complex.:+ ww8_sgN09 [Occ=Once!] ww9_sgN0a [Occ=Once!] ->
                                case ww8_sgN09 of {
                                  GHC.Types.D# ww11_sgN0c [Occ=Once] ->
                                      case ww9_sgN0a of {
                                        GHC.Types.D# ww13_sgN0e [Occ=Once] ->
                                            case
                                                Data.Complex.$w$s$c/
                                                    ww4_sgN05 ww6_sgN07 ww11_sgN0c ww13_sgN0e
                                            of
                                            { (#,#) ww15_sgN0g [Occ=Once] ww16_sgN0h [Occ=Once] ->
                                                  Data.Complex.:+ [ww15_sgN0g ww16_sgN0h];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN0i ww_sgN0j ww1_sgN0k ww2_sgN0l ww3_sgN0m]
        case
            GHC.Float.$p1RealFloat w_sgN0i
        of
        $dRealFrac_sgN0n [Dmd=<S(LS(LC(C(S))LL)LLLLL),U(1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p2RealFrac $dRealFrac_sgN0n
              of
              $dFractional_sgN0o [Dmd=<S(LC(C(S))LL),U(A,C(C1(U)),A,A)>]
              { __DEFAULT ->
                    let {
                      $dReal_sgN0p [Occ=OnceL,
                                    Dmd=<L,1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
                        :: GHC.Real.Real a_sgxAO
                      [LclId] =
                          [$dRealFrac_sgN0n] \s []
                              GHC.Real.$p1RealFrac $dRealFrac_sgN0n; } in
                    let {
                      $dNum_sgN0q [Dmd=<L,U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
                        :: GHC.Num.Num a_sgxAO
                      [LclId] =
                          [$dReal_sgN0p] \u [] GHC.Real.$p1Real $dReal_sgN0p; } in
                    let {
                      k_sgN0r :: GHC.Types.Int
                      [LclId] =
                          [w_sgN0i ww2_sgN0l ww3_sgN0m] \u []
                              case GHC.Float.exponent w_sgN0i ww2_sgN0l of {
                                GHC.Types.I# x1_sgN0t ->
                                    case GHC.Float.exponent w_sgN0i ww3_sgN0m of {
                                      GHC.Types.I# y1_sgN0v ->
                                          case <=# [x1_sgN0t y1_sgN0v] of {
                                            __DEFAULT ->
                                                case negateInt# [x1_sgN0t] of sat_sgN0x {
                                                  __DEFAULT -> GHC.Types.I# [sat_sgN0x];
                                                };
                                            1# ->
                                                case negateInt# [y1_sgN0v] of sat_sgN0y {
                                                  __DEFAULT -> GHC.Types.I# [sat_sgN0y];
                                                };
                                          };
                                    };
                              }; } in
                    let {
                      y''_sgN0z :: a_sgxAO
                      [LclId] =
                          [w_sgN0i ww3_sgN0m k_sgN0r] \u []
                              GHC.Float.scaleFloat w_sgN0i k_sgN0r ww3_sgN0m; } in
                    let {
                      x''_sgN0A :: a_sgxAO
                      [LclId] =
                          [w_sgN0i ww2_sgN0l k_sgN0r] \u []
                              GHC.Float.scaleFloat w_sgN0i k_sgN0r ww2_sgN0l; } in
                    let {
                      d_sgN0B :: a_sgxAO
                      [LclId] =
                          [ww2_sgN0l ww3_sgN0m $dNum_sgN0q y''_sgN0z x''_sgN0A] \u []
                              let {
                                sat_sgN0D [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww3_sgN0m $dNum_sgN0q y''_sgN0z] \u []
                                        GHC.Num.* $dNum_sgN0q ww3_sgN0m y''_sgN0z; } in
                              let {
                                sat_sgN0C [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww2_sgN0l $dNum_sgN0q x''_sgN0A] \u []
                                        GHC.Num.* $dNum_sgN0q ww2_sgN0l x''_sgN0A;
                              } in  GHC.Num.+ $dNum_sgN0q sat_sgN0C sat_sgN0D; } in
                    let {
                      sat_sgN0G [Occ=Once] :: a_sgxAO
                      [LclId] =
                          [ww_sgN0j ww1_sgN0k $dNum_sgN0q y''_sgN0z x''_sgN0A] \u []
                              let {
                                sat_sgN0F [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww1_sgN0k $dNum_sgN0q y''_sgN0z] \u []
                                        GHC.Num.* $dNum_sgN0q ww1_sgN0k y''_sgN0z; } in
                              let {
                                sat_sgN0E [Occ=Once] :: a_sgxAO
                                [LclId] =
                                    [ww_sgN0j $dNum_sgN0q x''_sgN0A] \u []
                                        GHC.Num.* $dNum_sgN0q ww_sgN0j x''_sgN0A;
                              } in  GHC.Num.+ $dNum_sgN0q sat_sgN0E sat_sgN0F;
                    } in 
                      case GHC.Real./ $dFractional_sgN0o sat_sgN0G d_sgN0B of dt_sgN0H {
                        __DEFAULT ->
                            let {
                              sat_sgN0K [Occ=Once] :: a_sgxAO
                              [LclId] =
                                  [ww_sgN0j ww1_sgN0k $dNum_sgN0q y''_sgN0z x''_sgN0A] \u []
                                      let {
                                        sat_sgN0J [Occ=Once] :: a_sgxAO
                                        [LclId] =
                                            [ww_sgN0j $dNum_sgN0q y''_sgN0z] \u []
                                                GHC.Num.* $dNum_sgN0q ww_sgN0j y''_sgN0z; } in
                                      let {
                                        sat_sgN0I [Occ=Once] :: a_sgxAO
                                        [LclId] =
                                            [ww1_sgN0k $dNum_sgN0q x''_sgN0A] \u []
                                                GHC.Num.* $dNum_sgN0q ww1_sgN0k x''_sgN0A;
                                      } in  GHC.Num.- $dNum_sgN0q sat_sgN0I sat_sgN0J;
                            } in 
                              case GHC.Real./ $dFractional_sgN0o sat_sgN0K d_sgN0B of dt1_sgN0L {
                                __DEFAULT -> (#,#) [dt_sgN0H dt1_sgN0L];
                              };
                      };
              };
        };

Data.Complex.$fFloatingComplex_$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN0M w1_sgN0N w2_sgN0O]
        case w1_sgN0N of {
          Data.Complex.:+ ww1_sgN0Q [Occ=Once] ww2_sgN0R [Occ=Once] ->
              case w2_sgN0O of {
                Data.Complex.:+ ww4_sgN0T [Occ=Once] ww5_sgN0U [Occ=Once] ->
                    case
                        Data.Complex.$w$c/ w_sgN0M ww1_sgN0Q ww2_sgN0R ww4_sgN0T ww5_sgN0U
                    of
                    { (#,#) ww7_sgN0W [Occ=Once] ww8_sgN0X [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgN0W ww8_sgN0X];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromRational
  :: GHC.Real.Rational -> Data.Complex.Complex GHC.Types.Double
[GblId, Arity=1, Str=<S(SS),1*U(U,U)>m, Unf=OtherCon []] =
    [] \r [a_sgN0Y]
        case a_sgN0Y of {
          GHC.Real.:% n_sgN10 [Occ=Once] d_sgN11 [Occ=Once] ->
              case GHC.Float.rationalToDouble n_sgN10 d_sgN11 of dt_sgN12 {
                GHC.Types.D# _ [Occ=Dead] ->
                    Data.Complex.:+ [dt_sgN12 Data.Complex.$fFloatingComplex1];
              };
        };

Data.Complex.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.Rational -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN14 w1_sgN15]
        case
            GHC.Float.$p1RealFloat w_sgN14
        of
        $dRealFrac_sgN16 [Dmd=<S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A)>]
        { __DEFAULT ->
              case GHC.Real.$p2RealFrac $dRealFrac_sgN16 of sat_sgN17 {
                __DEFAULT ->
                    case GHC.Real.fromRational sat_sgN17 w1_sgN15 of dt_sgN18 {
                      __DEFAULT ->
                          case GHC.Real.$p1RealFrac $dRealFrac_sgN16 of sat_sgN19 {
                            __DEFAULT ->
                                case GHC.Real.$p1Real sat_sgN19 of sat_sgN1a {
                                  __DEFAULT ->
                                      case
                                          GHC.Num.fromInteger
                                              sat_sgN1a Data.Complex.$fFloatingComplex17
                                      of
                                      dt1_sgN1b
                                      { __DEFAULT -> (#,#) [dt_sgN18 dt1_sgN1b];
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFractionalComplex_$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.Rational -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgN1c w1_sgN1d]
        case Data.Complex.$w$cfromRational w_sgN1c w1_sgN1d of {
          (#,#) ww1_sgN1f [Occ=Once] ww2_sgN1g [Occ=Once] ->
              Data.Complex.:+ [ww1_sgN1f ww2_sgN1g];
        };

Data.Complex.$fFloatingComplex_$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN1h w1_sgN1i]
        case w_sgN1h of {
          Data.Complex.:+ ww1_sgN1k [Occ=Once!] ww2_sgN1l [Occ=Once!] ->
              case ww1_sgN1k of {
                GHC.Types.D# ww4_sgN1n [Occ=Once] ->
                    case ww2_sgN1l of {
                      GHC.Types.D# ww6_sgN1p [Occ=Once] ->
                          case w1_sgN1i of {
                            Data.Complex.:+ ww8_sgN1r [Occ=Once!] ww9_sgN1s [Occ=Once!] ->
                                case ww8_sgN1r of {
                                  GHC.Types.D# ww11_sgN1u [Occ=Once] ->
                                      case ww9_sgN1s of {
                                        GHC.Types.D# ww13_sgN1w [Occ=Once] ->
                                            case +## [ww6_sgN1p ww13_sgN1w] of sat_sgN1z {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgN1A [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [sat_sgN1z];
                                                  } in 
                                                    case +## [ww4_sgN1n ww11_sgN1u] of sat_sgN1x {
                                                      __DEFAULT ->
                                                          let {
                                                            sat_sgN1y [Occ=Once] :: GHC.Types.Double
                                                            [LclId] =
                                                                CCCS GHC.Types.D#! [sat_sgN1x];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgN1y sat_sgN1A];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))LLLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN1B ww_sgN1C ww1_sgN1D ww2_sgN1E ww3_sgN1F]
        case
            GHC.Float.$p1RealFloat w_sgN1B
        of
        $dRealFrac_sgN1G [Dmd=<S(S(S(C(C(S))LLLLLL)LL)LLLLLL),1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN1G
              of
              $dReal_sgN1H [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgN1H
                    of
                    $dNum_sgN1I [Dmd=<S(C(C(S))LLLLLL),U(C(C1(U)),A,A,A,A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.+ $dNum_sgN1I ww_sgN1C ww2_sgN1E of dt_sgN1J {
                            __DEFAULT ->
                                case GHC.Num.+ $dNum_sgN1I ww1_sgN1D ww3_sgN1F of dt1_sgN1K {
                                  __DEFAULT -> (#,#) [dt_sgN1J dt1_sgN1K];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))LLLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN1L w1_sgN1M w2_sgN1N]
        case w1_sgN1M of {
          Data.Complex.:+ ww1_sgN1P [Occ=Once] ww2_sgN1Q [Occ=Once] ->
              case w2_sgN1N of {
                Data.Complex.:+ ww4_sgN1S [Occ=Once] ww5_sgN1T [Occ=Once] ->
                    case
                        Data.Complex.$w$c+ w_sgN1L ww1_sgN1P ww2_sgN1Q ww4_sgN1S ww5_sgN1T
                    of
                    { (#,#) ww7_sgN1V [Occ=Once] ww8_sgN1W [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgN1V ww8_sgN1W];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c- [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN1X w1_sgN1Y]
        case w_sgN1X of {
          Data.Complex.:+ ww1_sgN20 [Occ=Once!] ww2_sgN21 [Occ=Once!] ->
              case ww1_sgN20 of {
                GHC.Types.D# ww4_sgN23 [Occ=Once] ->
                    case ww2_sgN21 of {
                      GHC.Types.D# ww6_sgN25 [Occ=Once] ->
                          case w1_sgN1Y of {
                            Data.Complex.:+ ww8_sgN27 [Occ=Once!] ww9_sgN28 [Occ=Once!] ->
                                case ww8_sgN27 of {
                                  GHC.Types.D# ww11_sgN2a [Occ=Once] ->
                                      case ww9_sgN28 of {
                                        GHC.Types.D# ww13_sgN2c [Occ=Once] ->
                                            case -## [ww6_sgN25 ww13_sgN2c] of sat_sgN2f {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgN2g [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [sat_sgN2f];
                                                  } in 
                                                    case -## [ww4_sgN23 ww11_sgN2a] of sat_sgN2d {
                                                      __DEFAULT ->
                                                          let {
                                                            sat_sgN2e [Occ=Once] :: GHC.Types.Double
                                                            [LclId] =
                                                                CCCS GHC.Types.D#! [sat_sgN2d];
                                                          } in 
                                                            Data.Complex.:+ [sat_sgN2e sat_sgN2g];
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN2h ww_sgN2i ww1_sgN2j ww2_sgN2k ww3_sgN2l]
        case
            GHC.Float.$p1RealFloat w_sgN2h
        of
        $dRealFrac_sgN2m [Dmd=<S(S(S(LC(C(S))LLLLL)LL)LLLLLL),1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN2m
              of
              $dReal_sgN2n [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgN2n
                    of
                    $dNum_sgN2o [Dmd=<S(LC(C(S))LLLLL),U(A,C(C1(U)),A,A,A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.- $dNum_sgN2o ww_sgN2i ww2_sgN2k of dt_sgN2p {
                            __DEFAULT ->
                                case GHC.Num.- $dNum_sgN2o ww1_sgN2j ww3_sgN2l of dt1_sgN2q {
                                  __DEFAULT -> (#,#) [dt_sgN2p dt1_sgN2q];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN2r w1_sgN2s w2_sgN2t]
        case w1_sgN2s of {
          Data.Complex.:+ ww1_sgN2v [Occ=Once] ww2_sgN2w [Occ=Once] ->
              case w2_sgN2t of {
                Data.Complex.:+ ww4_sgN2y [Occ=Once] ww5_sgN2z [Occ=Once] ->
                    case
                        Data.Complex.$w$c- w_sgN2r ww1_sgN2v ww2_sgN2w ww4_sgN2y ww5_sgN2z
                    of
                    { (#,#) ww7_sgN2B [Occ=Once] ww8_sgN2C [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgN2B ww8_sgN2C];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$c* [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN2D w1_sgN2E]
        case w_sgN2D of {
          Data.Complex.:+ ww1_sgN2G [Occ=Once!] ww2_sgN2H [Occ=Once!] ->
              case ww1_sgN2G of {
                GHC.Types.D# ww4_sgN2J ->
                    case ww2_sgN2H of {
                      GHC.Types.D# ww6_sgN2L ->
                          case w1_sgN2E of {
                            Data.Complex.:+ ww8_sgN2N [Occ=Once!] ww9_sgN2O [Occ=Once!] ->
                                case ww8_sgN2N of {
                                  GHC.Types.D# ww11_sgN2Q ->
                                      case ww9_sgN2O of {
                                        GHC.Types.D# ww13_sgN2S ->
                                            case *## [ww6_sgN2L ww11_sgN2Q] of sat_sgN2Y {
                                              __DEFAULT ->
                                                  case *## [ww4_sgN2J ww13_sgN2S] of sat_sgN2X {
                                                    __DEFAULT ->
                                                        case
                                                            +## [sat_sgN2X sat_sgN2Y]
                                                        of
                                                        sat_sgN2Z
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_sgN30 [Occ=Once]
                                                                  :: GHC.Types.Double
                                                                [LclId] =
                                                                    CCCS GHC.Types.D#! [sat_sgN2Z];
                                                              } in 
                                                                case
                                                                    *## [ww6_sgN2L ww13_sgN2S]
                                                                of
                                                                sat_sgN2U
                                                                { __DEFAULT ->
                                                                      case
                                                                          *## [ww4_sgN2J ww11_sgN2Q]
                                                                      of
                                                                      sat_sgN2T
                                                                      { __DEFAULT ->
                                                                            case
                                                                                -## [sat_sgN2T
                                                                                     sat_sgN2U]
                                                                            of
                                                                            sat_sgN2V
                                                                            { __DEFAULT ->
                                                                                  let {
                                                                                    sat_sgN2W [Occ=Once]
                                                                                      :: GHC.Types.Double
                                                                                    [LclId] =
                                                                                        CCCS GHC.Types.D#! [sat_sgN2V];
                                                                                  } in 
                                                                                    Data.Complex.:+ [sat_sgN2W
                                                                                                     sat_sgN30];
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN31 ww_sgN32 ww1_sgN33 ww2_sgN34 ww3_sgN35]
        case
            GHC.Float.$p1RealFloat w_sgN31
        of
        $dRealFrac_sgN36 [Dmd=<S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL),1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN36
              of
              $dReal_sgN37 [Dmd=<S(S(C(C(S))C(C(S))LLLLL)LL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgN37
                    of
                    $dNum_sgN38 [Dmd=<S(C(C(S))C(C(S))LLLLL),U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            sat_sgN3a [Occ=Once] :: a_sgxDl
                            [LclId] =
                                [ww1_sgN33 ww3_sgN35 $dNum_sgN38] \u []
                                    GHC.Num.* $dNum_sgN38 ww1_sgN33 ww3_sgN35; } in
                          let {
                            sat_sgN39 [Occ=Once] :: a_sgxDl
                            [LclId] =
                                [ww_sgN32 ww2_sgN34 $dNum_sgN38] \u []
                                    GHC.Num.* $dNum_sgN38 ww_sgN32 ww2_sgN34;
                          } in 
                            case GHC.Num.- $dNum_sgN38 sat_sgN39 sat_sgN3a of dt_sgN3b {
                              __DEFAULT ->
                                  let {
                                    sat_sgN3d [Occ=Once] :: a_sgxDl
                                    [LclId] =
                                        [ww1_sgN33 ww2_sgN34 $dNum_sgN38] \u []
                                            GHC.Num.* $dNum_sgN38 ww1_sgN33 ww2_sgN34; } in
                                  let {
                                    sat_sgN3c [Occ=Once] :: a_sgxDl
                                    [LclId] =
                                        [ww_sgN32 ww3_sgN35 $dNum_sgN38] \u []
                                            GHC.Num.* $dNum_sgN38 ww_sgN32 ww3_sgN35;
                                  } in 
                                    case GHC.Num.+ $dNum_sgN38 sat_sgN3c sat_sgN3d of dt1_sgN3e {
                                      __DEFAULT -> (#,#) [dt_sgN3b dt1_sgN3e];
                                    };
                            };
                    };
              };
        };

Data.Complex.$fNumComplex_$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN3f w1_sgN3g w2_sgN3h]
        case w1_sgN3g of {
          Data.Complex.:+ ww1_sgN3j [Occ=Once] ww2_sgN3k [Occ=Once] ->
              case w2_sgN3h of {
                Data.Complex.:+ ww4_sgN3m [Occ=Once] ww5_sgN3n [Occ=Once] ->
                    case
                        Data.Complex.$w$c* w_sgN3f ww1_sgN3j ww2_sgN3k ww4_sgN3m ww5_sgN3n
                    of
                    { (#,#) ww7_sgN3p [Occ=Once] ww8_sgN3q [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgN3p ww8_sgN3q];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cnegate
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [ds_sgN3r]
        case ds_sgN3r of {
          Data.Complex.:+ x_sgN3t [Occ=Once!] y_sgN3u [Occ=Once!] ->
              case x_sgN3t of {
                GHC.Types.D# x1_sgN3w [Occ=Once] ->
                    case y_sgN3u of {
                      GHC.Types.D# x2_sgN3y [Occ=Once] ->
                          case negateDouble# [x2_sgN3y] of sat_sgN3B {
                            __DEFAULT ->
                                let {
                                  sat_sgN3C [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [sat_sgN3B];
                                } in 
                                  case negateDouble# [x1_sgN3w] of sat_sgN3z {
                                    __DEFAULT ->
                                        let {
                                          sat_sgN3A [Occ=Once] :: GHC.Types.Double
                                          [LclId] =
                                              CCCS GHC.Types.D#! [sat_sgN3z];
                                        } in  Data.Complex.:+ [sat_sgN3A sat_sgN3C];
                                  };
                          };
                    };
              };
        };

Data.Complex.$w$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLLC(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN3D ww_sgN3E ww1_sgN3F]
        case
            GHC.Float.$p1RealFloat w_sgN3D
        of
        $dRealFrac_sgN3G [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN3G
              of
              $dReal_sgN3H [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgN3H
                    of
                    $dNum_sgN3I [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.negate $dNum_sgN3I ww_sgN3E of dt_sgN3J {
                            __DEFAULT ->
                                case GHC.Num.negate $dNum_sgN3I ww1_sgN3F of dt1_sgN3K {
                                  __DEFAULT -> (#,#) [dt_sgN3J dt1_sgN3K];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLLC(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN3L w1_sgN3M]
        case w1_sgN3M of {
          Data.Complex.:+ ww1_sgN3O [Occ=Once] ww2_sgN3P [Occ=Once] ->
              case Data.Complex.$w$cnegate w_sgN3L ww1_sgN3O ww2_sgN3P of {
                (#,#) ww4_sgN3R [Occ=Once] ww5_sgN3S [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgN3R ww5_sgN3S];
              };
        };

Data.Complex.$fFloatingComplex_$s$cabs
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [z_sgN3T]
        case z_sgN3T of {
          Data.Complex.:+ ww1_sgN3V [Occ=Once!] ww2_sgN3W [Occ=Once!] ->
              case ww1_sgN3V of {
                GHC.Types.D# ww4_sgN3Y [Occ=Once] ->
                    case ww2_sgN3W of {
                      GHC.Types.D# ww6_sgN40 [Occ=Once] ->
                          case Data.Complex.$w$smagnitude ww4_sgN3Y ww6_sgN40 of ww7_sgN41 {
                            __DEFAULT ->
                                let {
                                  sat_sgN42 [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [ww7_sgN41];
                                } in  Data.Complex.:+ [sat_sgN42 Data.Complex.$fFloatingComplex1];
                          };
                    };
              };
        };

Data.Complex.$w$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,1*C1(U)),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN43 ww_sgN44 ww1_sgN45]
        case
            Data.Complex.$wmagnitude w_sgN43 ww_sgN44 ww1_sgN45
        of
        dt_sgN46
        { __DEFAULT ->
              case GHC.Float.$p1RealFloat w_sgN43 of sat_sgN47 {
                __DEFAULT ->
                    case GHC.Real.$p1RealFrac sat_sgN47 of sat_sgN48 {
                      __DEFAULT ->
                          case GHC.Real.$p1Real sat_sgN48 of sat_sgN49 {
                            __DEFAULT ->
                                case
                                    GHC.Num.fromInteger sat_sgN49 Data.Complex.$fFloatingComplex17
                                of
                                dt1_sgN4a
                                { __DEFAULT -> (#,#) [dt_sgN46 dt1_sgN4a];
                                };
                          };
                    };
              };
        };

Data.Complex.$fNumComplex_$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN4b w1_sgN4c]
        case w1_sgN4c of {
          Data.Complex.:+ ww1_sgN4e [Occ=Once] ww2_sgN4f [Occ=Once] ->
              case Data.Complex.$w$cabs w_sgN4b ww1_sgN4e ww2_sgN4f of {
                (#,#) ww4_sgN4h [Occ=Once] ww5_sgN4i [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgN4h ww5_sgN4i];
              };
        };

Data.Complex.$fFloatingComplex_$s$cfromInteger
  :: GHC.Integer.Type.Integer
     -> Data.Complex.Complex GHC.Types.Double
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [n_sgN4j]
        case GHC.Integer.Type.doubleFromInteger n_sgN4j of wild_sgN4k {
          __DEFAULT ->
              let {
                sat_sgN4l [Occ=Once] :: GHC.Types.Double
                [LclId] =
                    CCCS GHC.Types.D#! [wild_sgN4k];
              } in  Data.Complex.:+ [sat_sgN4l Data.Complex.$fFloatingComplex1];
        };

Data.Complex.$w$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Integer.Type.Integer -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN4m w1_sgN4n]
        case
            GHC.Float.$p1RealFloat w_sgN4m
        of
        $dRealFrac_sgN4o [Dmd=<S(S(S(LLLLLLC(S))LL)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN4o
              of
              $dReal_sgN4p [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgN4p
                    of
                    $dNum_sgN4q [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
                    { __DEFAULT ->
                          case GHC.Num.fromInteger $dNum_sgN4q w1_sgN4n of dt_sgN4r {
                            __DEFAULT ->
                                case
                                    GHC.Num.fromInteger $dNum_sgN4q Data.Complex.$fFloatingComplex17
                                of
                                dt1_sgN4s
                                { __DEFAULT -> (#,#) [dt_sgN4r dt1_sgN4s];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Integer.Type.Integer -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgN4t w1_sgN4u]
        case Data.Complex.$w$cfromInteger w_sgN4t w1_sgN4u of {
          (#,#) ww1_sgN4w [Occ=Once] ww2_sgN4x [Occ=Once] ->
              Data.Complex.:+ [ww1_sgN4w ww2_sgN4x];
        };

Data.Complex.$fFloatingComplex4
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex1
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$fFloatingComplex_$s$csignum [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN4y]
        case w_sgN4y of {
          Data.Complex.:+ ww1_sgN4A [Occ=Once!] ww2_sgN4B [Occ=Once!] ->
              case ww1_sgN4A of {
                GHC.Types.D# ww4_sgN4D ->
                    case ww2_sgN4B of {
                      GHC.Types.D# ww6_sgN4F ->
                          case ==## [ww4_sgN4D 0.0##] of {
                            __DEFAULT ->
                                case Data.Complex.$w$smagnitude ww4_sgN4D ww6_sgN4F of ww7_sgN4H {
                                  __DEFAULT ->
                                      case /## [ww4_sgN4D ww7_sgN4H] of wild2_sgN4I {
                                        __DEFAULT ->
                                            case /## [ww6_sgN4F ww7_sgN4H] of wild1_sgN4J {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgN4L [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [wild1_sgN4J]; } in
                                                  let {
                                                    sat_sgN4K [Occ=Once] :: GHC.Types.Double
                                                    [LclId] =
                                                        CCCS GHC.Types.D#! [wild2_sgN4I];
                                                  } in  Data.Complex.:+ [sat_sgN4K sat_sgN4L];
                                            };
                                      };
                                };
                            1# ->
                                case ==## [ww6_sgN4F 0.0##] of {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$smagnitude ww4_sgN4D ww6_sgN4F
                                      of
                                      ww7_sgN4N
                                      { __DEFAULT ->
                                            case /## [ww4_sgN4D ww7_sgN4N] of wild2_sgN4O {
                                              __DEFAULT ->
                                                  case /## [ww6_sgN4F ww7_sgN4N] of wild1_sgN4P {
                                                    __DEFAULT ->
                                                        let {
                                                          sat_sgN4R [Occ=Once] :: GHC.Types.Double
                                                          [LclId] =
                                                              CCCS GHC.Types.D#! [wild1_sgN4P]; } in
                                                        let {
                                                          sat_sgN4Q [Occ=Once] :: GHC.Types.Double
                                                          [LclId] =
                                                              CCCS GHC.Types.D#! [wild2_sgN4O];
                                                        } in  Data.Complex.:+ [sat_sgN4Q sat_sgN4R];
                                                  };
                                            };
                                      };
                                  1# -> Data.Complex.$fFloatingComplex4;
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex12
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex9
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$fFloatingComplex_$s$csignum1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN4S]
        case w_sgN4S of {
          Data.Complex.:+ ww1_sgN4U [Occ=Once!] ww2_sgN4V [Occ=Once!] ->
              case ww1_sgN4U of {
                GHC.Types.F# ww4_sgN4X ->
                    case ww2_sgN4V of {
                      GHC.Types.F# ww6_sgN4Z ->
                          case eqFloat# [ww4_sgN4X 0.0#] of {
                            __DEFAULT ->
                                case Data.Complex.$w$smagnitude1 ww4_sgN4X ww6_sgN4Z of ww7_sgN51 {
                                  __DEFAULT ->
                                      case divideFloat# [ww4_sgN4X ww7_sgN51] of wild2_sgN52 {
                                        __DEFAULT ->
                                            case divideFloat# [ww6_sgN4Z ww7_sgN51] of wild1_sgN53 {
                                              __DEFAULT ->
                                                  let {
                                                    sat_sgN55 [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [wild1_sgN53]; } in
                                                  let {
                                                    sat_sgN54 [Occ=Once] :: GHC.Types.Float
                                                    [LclId] =
                                                        CCCS GHC.Types.F#! [wild2_sgN52];
                                                  } in  Data.Complex.:+ [sat_sgN54 sat_sgN55];
                                            };
                                      };
                                };
                            1# ->
                                case eqFloat# [ww6_sgN4Z 0.0#] of {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$smagnitude1 ww4_sgN4X ww6_sgN4Z
                                      of
                                      ww7_sgN57
                                      { __DEFAULT ->
                                            case divideFloat# [ww4_sgN4X ww7_sgN57] of wild2_sgN58 {
                                              __DEFAULT ->
                                                  case
                                                      divideFloat# [ww6_sgN4Z ww7_sgN57]
                                                  of
                                                  wild1_sgN59
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_sgN5b [Occ=Once] :: GHC.Types.Float
                                                          [LclId] =
                                                              CCCS GHC.Types.F#! [wild1_sgN59]; } in
                                                        let {
                                                          sat_sgN5a [Occ=Once] :: GHC.Types.Float
                                                          [LclId] =
                                                              CCCS GHC.Types.F#! [wild2_sgN58];
                                                        } in  Data.Complex.:+ [sat_sgN5a sat_sgN5b];
                                                  };
                                            };
                                      };
                                  1# -> Data.Complex.$fFloatingComplex12;
                                };
                          };
                    };
              };
        };

Data.Complex.$w$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN5c ww_sgN5d ww1_sgN5e]
        case
            GHC.Float.$p1RealFloat w_sgN5c
        of
        $dRealFrac_sgN5f [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN5f
              of
              $dReal_sgN5g [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      $dNum_sgN5h [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_sgxEJ
                      [LclId] =
                          [$dReal_sgN5g] \u [] GHC.Real.$p1Real $dReal_sgN5g;
                    } in 
                      case
                          GHC.Real.$p2Real $dReal_sgN5g
                      of
                      $dOrd_sgN5i [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                      { __DEFAULT ->
                            case
                                GHC.Classes.$p1Ord $dOrd_sgN5i
                            of
                            $dEq_sgN5j [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                            { __DEFAULT ->
                                  let {
                                    sat_sgN5q [Occ=Once] :: a_sgxEJ
                                    [LclId] =
                                        [$dNum_sgN5h] \u []
                                            GHC.Num.fromInteger
                                                $dNum_sgN5h Data.Complex.$fFloatingComplex17;
                                  } in 
                                    let-no-escape {
                                      fail_sgN5k [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> (# a_sgxEJ, a_sgxEJ #)
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [w_sgN5c
                                                    ww_sgN5d
                                                    ww1_sgN5e
                                                    $dRealFrac_sgN5f] \r [void_0E]
                                              case
                                                  GHC.Real.$p2RealFrac $dRealFrac_sgN5f
                                              of
                                              $dFractional_sgN5m [Dmd=<S(LC(C(S))LL),U(A,C(C1(U)),A,A)>]
                                              { __DEFAULT ->
                                                    let {
                                                      r_sgN5n :: a_sgxEJ
                                                      [LclId] =
                                                          [w_sgN5c ww_sgN5d ww1_sgN5e] \u []
                                                              Data.Complex.$wmagnitude
                                                                  w_sgN5c ww_sgN5d ww1_sgN5e;
                                                    } in 
                                                      case
                                                          GHC.Real./
                                                              $dFractional_sgN5m ww_sgN5d r_sgN5n
                                                      of
                                                      dt_sgN5o
                                                      { __DEFAULT ->
                                                            case
                                                                GHC.Real./
                                                                    $dFractional_sgN5m
                                                                    ww1_sgN5e
                                                                    r_sgN5n
                                                            of
                                                            dt1_sgN5p
                                                            { __DEFAULT ->
                                                                  (#,#) [dt_sgN5o dt1_sgN5p];
                                                            };
                                                      };
                                              };
                                    } in 
                                      case GHC.Classes.== $dEq_sgN5j ww_sgN5d sat_sgN5q of {
                                        GHC.Types.False -> fail_sgN5k GHC.Prim.void#;
                                        GHC.Types.True ->
                                            let {
                                              sat_sgN5s [Occ=Once] :: a_sgxEJ
                                              [LclId] =
                                                  [$dNum_sgN5h] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_sgN5h
                                                          Data.Complex.$fFloatingComplex17;
                                            } in 
                                              case
                                                  GHC.Classes.== $dEq_sgN5j ww1_sgN5e sat_sgN5s
                                              of
                                              { GHC.Types.False -> fail_sgN5k GHC.Prim.void#;
                                                GHC.Types.True ->
                                                    Data.Complex.$w$cfromInteger
                                                        w_sgN5c Data.Complex.$fFloatingComplex17;
                                              };
                                      };
                            };
                      };
              };
        };

Data.Complex.$fNumComplex_$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN5u w1_sgN5v]
        case w1_sgN5v of {
          Data.Complex.:+ ww1_sgN5x [Occ=Once] ww2_sgN5y [Occ=Once] ->
              case Data.Complex.$w$csignum w_sgN5u ww1_sgN5x ww2_sgN5y of {
                (#,#) ww4_sgN5A [Occ=Once] ww5_sgN5B [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgN5A ww5_sgN5B];
              };
        };

Data.Complex.$fFloatingComplex_$s$fNumComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Num.Num (Data.Complex.Complex GHC.Types.Double)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Num.C:Num! [Data.Complex.$fFloatingComplex_$s$c+
                                  Data.Complex.$fFloatingComplex_$s$c-
                                  Data.Complex.$fFloatingComplex_$s$c*
                                  Data.Complex.$fFloatingComplex_$s$cnegate
                                  Data.Complex.$fFloatingComplex_$s$cabs
                                  Data.Complex.$fFloatingComplex_$s$csignum
                                  Data.Complex.$fFloatingComplex_$s$cfromInteger];

Data.Complex.$fFloatingComplex_$s$fNumComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Num.Num (Data.Complex.Complex GHC.Types.Float)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Num.C:Num! [Data.Complex.$fFloatingComplex_$s$c+1
                                  Data.Complex.$fFloatingComplex_$s$c-1
                                  Data.Complex.$fFloatingComplex_$s$c*1
                                  Data.Complex.$fFloatingComplex_$s$cnegate1
                                  Data.Complex.$fFloatingComplex_$s$cabs1
                                  Data.Complex.$fFloatingComplex_$s$csignum1
                                  Data.Complex.$fFloatingComplex_$s$cfromInteger1];

Data.Complex.$fNumComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Num.Num (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dRealFloat_sgN5C]
        let {
          sat_sgN5J [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cfromInteger
                      $dRealFloat_sgN5C eta_B1; } in
        let {
          sat_sgN5I [Occ=Once]
            :: Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B1]
                  Data.Complex.$fNumComplex_$csignum $dRealFloat_sgN5C eta_B1; } in
        let {
          sat_sgN5H [Occ=Once]
            :: Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B1]
                  Data.Complex.$fNumComplex_$cabs $dRealFloat_sgN5C eta_B1; } in
        let {
          sat_sgN5G [Occ=Once]
            :: Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cnegate
                      $dRealFloat_sgN5C eta_B1; } in
        let {
          sat_sgN5F [Occ=Once]
            :: Data.Complex.Complex a_agt1x
               -> Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B2 eta_B1]
                  Data.Complex.$fNumComplex_$c* $dRealFloat_sgN5C eta_B2 eta_B1; } in
        let {
          sat_sgN5E [Occ=Once]
            :: Data.Complex.Complex a_agt1x
               -> Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c-
                      $dRealFloat_sgN5C eta_B2 eta_B1; } in
        let {
          sat_sgN5D [Occ=Once]
            :: Data.Complex.Complex a_agt1x
               -> Data.Complex.Complex a_agt1x -> Data.Complex.Complex a_agt1x
          [LclId] =
              [$dRealFloat_sgN5C] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c+ $dRealFloat_sgN5C eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [sat_sgN5D
                         sat_sgN5E
                         sat_sgN5F
                         sat_sgN5G
                         sat_sgN5H
                         sat_sgN5I
                         sat_sgN5J];

Data.Complex.$w$s$csqrt1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgN5K ww1_sgN5L]
        let-no-escape {
          fail_sgN5M [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> (# GHC.Types.Float, GHC.Types.Float #)
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [ww_sgN5K ww1_sgN5L] \r [void_0E]
                  case ltFloat# [ww_sgN5K 0.0#] of {
                    __DEFAULT ->
                        case Data.Complex.$w$smagnitude1 ww_sgN5K ww1_sgN5L of ww2_sgN5P {
                          __DEFAULT ->
                              case fabsFloat# [ww_sgN5K] of sat_sgN5R {
                                __DEFAULT ->
                                    case plusFloat# [ww2_sgN5P sat_sgN5R] of sat_sgN5S {
                                      __DEFAULT ->
                                          case divideFloat# [sat_sgN5S 2.0#] of sat_sgN5T {
                                            __DEFAULT ->
                                                case
                                                    sqrtFloat# [sat_sgN5T]
                                                of
                                                ipv_sgN5Q [Dmd=<S,U>]
                                                { __DEFAULT ->
                                                      case ltFloat# [ww1_sgN5L 0.0#] of {
                                                        __DEFAULT ->
                                                            case
                                                                plusFloat# [ipv_sgN5Q ipv_sgN5Q]
                                                            of
                                                            sat_sgN5W
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsFloat# [ww1_sgN5L]
                                                                  of
                                                                  sat_sgN5V
                                                                  { __DEFAULT ->
                                                                        case
                                                                            divideFloat# [sat_sgN5V
                                                                                          sat_sgN5W]
                                                                        of
                                                                        wild2_sgN5X
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgN5Z [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [wild2_sgN5X]; } in
                                                                              let {
                                                                                sat_sgN5Y [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [ipv_sgN5Q];
                                                                              } in 
                                                                                (#,#) [sat_sgN5Y
                                                                                       sat_sgN5Z];
                                                                        };
                                                                  };
                                                            };
                                                        1# ->
                                                            case
                                                                plusFloat# [ipv_sgN5Q ipv_sgN5Q]
                                                            of
                                                            sat_sgN61
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsFloat# [ww1_sgN5L]
                                                                  of
                                                                  sat_sgN60
                                                                  { __DEFAULT ->
                                                                        case
                                                                            divideFloat# [sat_sgN60
                                                                                          sat_sgN61]
                                                                        of
                                                                        wild2_sgN62
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  negateFloat# [wild2_sgN62]
                                                                              of
                                                                              sat_sgN64
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgN65 [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [sat_sgN64]; } in
                                                                                    let {
                                                                                      sat_sgN63 [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [ipv_sgN5Q];
                                                                                    } in 
                                                                                      (#,#) [sat_sgN63
                                                                                             sat_sgN65];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                    1# ->
                        case Data.Complex.$w$smagnitude1 ww_sgN5K ww1_sgN5L of ww2_sgN66 {
                          __DEFAULT ->
                              case fabsFloat# [ww_sgN5K] of sat_sgN68 {
                                __DEFAULT ->
                                    case plusFloat# [ww2_sgN66 sat_sgN68] of sat_sgN69 {
                                      __DEFAULT ->
                                          case divideFloat# [sat_sgN69 2.0#] of sat_sgN6a {
                                            __DEFAULT ->
                                                case sqrtFloat# [sat_sgN6a] of x_sgN67 [Dmd=<S,U>] {
                                                  __DEFAULT ->
                                                      case
                                                          plusFloat# [x_sgN67 x_sgN67]
                                                      of
                                                      sat_sgN6c
                                                      { __DEFAULT ->
                                                            case
                                                                fabsFloat# [ww1_sgN5L]
                                                            of
                                                            sat_sgN6b
                                                            { __DEFAULT ->
                                                                  case
                                                                      divideFloat# [sat_sgN6b
                                                                                    sat_sgN6c]
                                                                  of
                                                                  wild2_sgN6d
                                                                  { __DEFAULT ->
                                                                        case
                                                                            ltFloat# [ww1_sgN5L
                                                                                      0.0#]
                                                                        of
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgN6g [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [x_sgN67]; } in
                                                                              let {
                                                                                sat_sgN6f [Occ=Once]
                                                                                  :: GHC.Types.Float
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.F#! [wild2_sgN6d];
                                                                              } in 
                                                                                (#,#) [sat_sgN6f
                                                                                       sat_sgN6g];
                                                                          1# ->
                                                                              case
                                                                                  negateFloat# [x_sgN67]
                                                                              of
                                                                              sat_sgN6i
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgN6j [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [sat_sgN6i]; } in
                                                                                    let {
                                                                                      sat_sgN6h [Occ=Once]
                                                                                        :: GHC.Types.Float
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.F#! [wild2_sgN6d];
                                                                                    } in 
                                                                                      (#,#) [sat_sgN6h
                                                                                             sat_sgN6j];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case eqFloat# [ww_sgN5K 0.0#] of {
            __DEFAULT -> fail_sgN5M GHC.Prim.void#;
            1# ->
                case eqFloat# [ww1_sgN5L 0.0#] of {
                  __DEFAULT -> fail_sgN5M GHC.Prim.void#;
                  1# ->
                      (#,#) [Data.Complex.$fFloatingComplex9
                             Data.Complex.$fFloatingComplex9];
                };
          };

Data.Complex.$fFloatingComplex_$s$csqrt1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN6m]
        case w_sgN6m of {
          Data.Complex.:+ ww1_sgN6o [Occ=Once!] ww2_sgN6p [Occ=Once!] ->
              case ww1_sgN6o of {
                GHC.Types.F# ww4_sgN6r [Occ=Once] ->
                    case ww2_sgN6p of {
                      GHC.Types.F# ww6_sgN6t [Occ=Once] ->
                          case Data.Complex.$w$s$csqrt1 ww4_sgN6r ww6_sgN6t of {
                            (#,#) ww8_sgN6v [Occ=Once] ww9_sgN6w [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgN6v ww9_sgN6w];
                          };
                    };
              };
        };

Data.Complex.$w$s$csqrt [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgN6x ww1_sgN6y]
        let-no-escape {
          fail_sgN6z [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> (# GHC.Types.Double, GHC.Types.Double #)
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [ww_sgN6x ww1_sgN6y] \r [void_0E]
                  case <## [ww_sgN6x 0.0##] of {
                    __DEFAULT ->
                        case Data.Complex.$w$smagnitude ww_sgN6x ww1_sgN6y of ww2_sgN6C {
                          __DEFAULT ->
                              case fabsDouble# [ww_sgN6x] of sat_sgN6E {
                                __DEFAULT ->
                                    case +## [ww2_sgN6C sat_sgN6E] of sat_sgN6F {
                                      __DEFAULT ->
                                          case /## [sat_sgN6F 2.0##] of sat_sgN6G {
                                            __DEFAULT ->
                                                case
                                                    sqrtDouble# [sat_sgN6G]
                                                of
                                                ipv_sgN6D [Dmd=<S,U>]
                                                { __DEFAULT ->
                                                      case <## [ww1_sgN6y 0.0##] of {
                                                        __DEFAULT ->
                                                            case
                                                                +## [ipv_sgN6D ipv_sgN6D]
                                                            of
                                                            sat_sgN6J
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsDouble# [ww1_sgN6y]
                                                                  of
                                                                  sat_sgN6I
                                                                  { __DEFAULT ->
                                                                        case
                                                                            /## [sat_sgN6I
                                                                                 sat_sgN6J]
                                                                        of
                                                                        wild2_sgN6K
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgN6M [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [wild2_sgN6K]; } in
                                                                              let {
                                                                                sat_sgN6L [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [ipv_sgN6D];
                                                                              } in 
                                                                                (#,#) [sat_sgN6L
                                                                                       sat_sgN6M];
                                                                        };
                                                                  };
                                                            };
                                                        1# ->
                                                            case
                                                                +## [ipv_sgN6D ipv_sgN6D]
                                                            of
                                                            sat_sgN6O
                                                            { __DEFAULT ->
                                                                  case
                                                                      fabsDouble# [ww1_sgN6y]
                                                                  of
                                                                  sat_sgN6N
                                                                  { __DEFAULT ->
                                                                        case
                                                                            /## [sat_sgN6N
                                                                                 sat_sgN6O]
                                                                        of
                                                                        wild2_sgN6P
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  negateDouble# [wild2_sgN6P]
                                                                              of
                                                                              sat_sgN6R
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgN6S [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [sat_sgN6R]; } in
                                                                                    let {
                                                                                      sat_sgN6Q [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [ipv_sgN6D];
                                                                                    } in 
                                                                                      (#,#) [sat_sgN6Q
                                                                                             sat_sgN6S];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                    1# ->
                        case Data.Complex.$w$smagnitude ww_sgN6x ww1_sgN6y of ww2_sgN6T {
                          __DEFAULT ->
                              case fabsDouble# [ww_sgN6x] of sat_sgN6V {
                                __DEFAULT ->
                                    case +## [ww2_sgN6T sat_sgN6V] of sat_sgN6W {
                                      __DEFAULT ->
                                          case /## [sat_sgN6W 2.0##] of sat_sgN6X {
                                            __DEFAULT ->
                                                case
                                                    sqrtDouble# [sat_sgN6X]
                                                of
                                                x_sgN6U [Dmd=<S,U>]
                                                { __DEFAULT ->
                                                      case +## [x_sgN6U x_sgN6U] of sat_sgN6Z {
                                                        __DEFAULT ->
                                                            case
                                                                fabsDouble# [ww1_sgN6y]
                                                            of
                                                            sat_sgN6Y
                                                            { __DEFAULT ->
                                                                  case
                                                                      /## [sat_sgN6Y sat_sgN6Z]
                                                                  of
                                                                  wild2_sgN70
                                                                  { __DEFAULT ->
                                                                        case
                                                                            <## [ww1_sgN6y 0.0##]
                                                                        of
                                                                        { __DEFAULT ->
                                                                              let {
                                                                                sat_sgN73 [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [x_sgN6U]; } in
                                                                              let {
                                                                                sat_sgN72 [Occ=Once]
                                                                                  :: GHC.Types.Double
                                                                                [LclId] =
                                                                                    CCCS GHC.Types.D#! [wild2_sgN70];
                                                                              } in 
                                                                                (#,#) [sat_sgN72
                                                                                       sat_sgN73];
                                                                          1# ->
                                                                              case
                                                                                  negateDouble# [x_sgN6U]
                                                                              of
                                                                              sat_sgN75
                                                                              { __DEFAULT ->
                                                                                    let {
                                                                                      sat_sgN76 [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [sat_sgN75]; } in
                                                                                    let {
                                                                                      sat_sgN74 [Occ=Once]
                                                                                        :: GHC.Types.Double
                                                                                      [LclId] =
                                                                                          CCCS GHC.Types.D#! [wild2_sgN70];
                                                                                    } in 
                                                                                      (#,#) [sat_sgN74
                                                                                             sat_sgN76];
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case ==## [ww_sgN6x 0.0##] of {
            __DEFAULT -> fail_sgN6z GHC.Prim.void#;
            1# ->
                case ==## [ww1_sgN6y 0.0##] of {
                  __DEFAULT -> fail_sgN6z GHC.Prim.void#;
                  1# ->
                      (#,#) [Data.Complex.$fFloatingComplex1
                             Data.Complex.$fFloatingComplex1];
                };
          };

Data.Complex.$fFloatingComplex_$s$csqrt [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN79]
        case w_sgN79 of {
          Data.Complex.:+ ww1_sgN7b [Occ=Once!] ww2_sgN7c [Occ=Once!] ->
              case ww1_sgN7b of {
                GHC.Types.D# ww4_sgN7e [Occ=Once] ->
                    case ww2_sgN7c of {
                      GHC.Types.D# ww6_sgN7g [Occ=Once] ->
                          case Data.Complex.$w$s$csqrt ww4_sgN7e ww6_sgN7g of {
                            (#,#) ww8_sgN7i [Occ=Once] ww9_sgN7j [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgN7i ww9_sgN7j];
                          };
                    };
              };
        };

sat_sgN7k :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_sgN7l :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgN7k GHC.Types.[]];

Data.Complex.$fFloatingComplex21 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgN7l;

Data.Complex.$w$csqrt [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN7m ww_sgN7n ww1_sgN7o]
        case
            GHC.Float.$p1RealFloat w_sgN7m
        of
        $dRealFrac_sgN7p [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN7p
              of
              $dReal_sgN7q [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p2Real $dReal_sgN7q
                    of
                    $dOrd_sgN7r [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dNum_sgN7s [Dmd=<L,U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U))>]
                              :: GHC.Num.Num a_sgxFA
                            [LclId] =
                                [$dReal_sgN7q] \u [] GHC.Real.$p1Real $dReal_sgN7q;
                          } in 
                            case
                                GHC.Classes.$p1Ord $dOrd_sgN7r
                            of
                            $dEq_sgN7t [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                            { __DEFAULT ->
                                  let {
                                    sat_sgN7S [Occ=Once] :: a_sgxFA
                                    [LclId] =
                                        [$dNum_sgN7s] \u []
                                            GHC.Num.fromInteger
                                                $dNum_sgN7s Data.Complex.$fFloatingComplex17;
                                  } in 
                                    let-no-escape {
                                      fail_sgN7u [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> (# a_sgxFA, a_sgxFA #)
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [w_sgN7m
                                                    ww_sgN7n
                                                    ww1_sgN7o
                                                    $dRealFrac_sgN7p
                                                    $dOrd_sgN7r
                                                    $dNum_sgN7s] \r [void_0E]
                                              let {
                                                $dFractional_sgN7w [Dmd=<L,U(A,C(C1(U)),A,A)>]
                                                  :: GHC.Real.Fractional a_sgxFA
                                                [LclId] =
                                                    [$dRealFrac_sgN7p] \u []
                                                        GHC.Real.$p2RealFrac $dRealFrac_sgN7p; } in
                                              let {
                                                u'_sgN7x :: a_sgxFA
                                                [LclId] =
                                                    [w_sgN7m
                                                     ww_sgN7n
                                                     ww1_sgN7o
                                                     $dNum_sgN7s
                                                     $dFractional_sgN7w] \u []
                                                        let {
                                                          sat_sgN7D [Occ=Once] :: a_sgxFA
                                                          [LclId] =
                                                              [w_sgN7m
                                                               ww_sgN7n
                                                               ww1_sgN7o
                                                               $dNum_sgN7s
                                                               $dFractional_sgN7w] \u []
                                                                  let {
                                                                    sat_sgN7C [Occ=Once] :: a_sgxFA
                                                                    [LclId] =
                                                                        [$dNum_sgN7s] \u []
                                                                            GHC.Num.fromInteger
                                                                                $dNum_sgN7s
                                                                                Data.Complex.$fFloatingComplex21; } in
                                                                  let {
                                                                    sat_sgN7B [Occ=Once] :: a_sgxFA
                                                                    [LclId] =
                                                                        [w_sgN7m
                                                                         ww_sgN7n
                                                                         ww1_sgN7o
                                                                         $dNum_sgN7s] \u []
                                                                            let {
                                                                              sat_sgN7A [Occ=Once]
                                                                                :: a_sgxFA
                                                                              [LclId] =
                                                                                  [ww_sgN7n
                                                                                   $dNum_sgN7s] \u []
                                                                                      GHC.Num.abs
                                                                                          $dNum_sgN7s
                                                                                          ww_sgN7n; } in
                                                                            let {
                                                                              sat_sgN7z [Occ=Once]
                                                                                :: a_sgxFA
                                                                              [LclId] =
                                                                                  [w_sgN7m
                                                                                   ww_sgN7n
                                                                                   ww1_sgN7o] \u []
                                                                                      Data.Complex.$wmagnitude
                                                                                          w_sgN7m
                                                                                          ww_sgN7n
                                                                                          ww1_sgN7o;
                                                                            } in 
                                                                              GHC.Num.+
                                                                                  $dNum_sgN7s
                                                                                  sat_sgN7z
                                                                                  sat_sgN7A;
                                                                  } in 
                                                                    GHC.Real./
                                                                        $dFractional_sgN7w
                                                                        sat_sgN7B
                                                                        sat_sgN7C;
                                                        } in 
                                                          case
                                                              GHC.Float.$p2RealFloat w_sgN7m
                                                          of
                                                          sat_sgN7y
                                                          { __DEFAULT ->
                                                                GHC.Float.sqrt sat_sgN7y sat_sgN7D;
                                                          }; } in
                                              let {
                                                v'_sgN7E [Occ=Once*] :: a_sgxFA
                                                [LclId] =
                                                    [ww1_sgN7o
                                                     $dNum_sgN7s
                                                     $dFractional_sgN7w
                                                     u'_sgN7x] \u []
                                                        let {
                                                          sat_sgN7H [Occ=Once] :: a_sgxFA
                                                          [LclId] =
                                                              [$dNum_sgN7s u'_sgN7x] \u []
                                                                  let {
                                                                    sat_sgN7G [Occ=Once] :: a_sgxFA
                                                                    [LclId] =
                                                                        [$dNum_sgN7s] \u []
                                                                            GHC.Num.fromInteger
                                                                                $dNum_sgN7s
                                                                                Data.Complex.$fFloatingComplex21;
                                                                  } in 
                                                                    GHC.Num.*
                                                                        $dNum_sgN7s
                                                                        u'_sgN7x
                                                                        sat_sgN7G; } in
                                                        let {
                                                          sat_sgN7F [Occ=Once] :: a_sgxFA
                                                          [LclId] =
                                                              [ww1_sgN7o $dNum_sgN7s] \u []
                                                                  GHC.Num.abs $dNum_sgN7s ww1_sgN7o;
                                                        } in 
                                                          GHC.Real./
                                                              $dFractional_sgN7w
                                                              sat_sgN7F
                                                              sat_sgN7H; } in
                                              let {
                                                sat_sgN7Q [Occ=Once] :: a_sgxFA
                                                [LclId] =
                                                    [$dNum_sgN7s] \u []
                                                        GHC.Num.fromInteger
                                                            $dNum_sgN7s
                                                            Data.Complex.$fFloatingComplex17;
                                              } in 
                                                let-no-escape {
                                                  $j_sgN7I [Occ=Once*!T[2],
                                                            Dmd=<C(C(S)),1*C1(C1(U(U,U)))>]
                                                    :: a_sgxFA -> a_sgxFA -> (# a_sgxFA, a_sgxFA #)
                                                  [LclId[JoinId(2)],
                                                   Arity=2,
                                                   Str=<S,1*U><L,U>,
                                                   Unf=OtherCon []] =
                                                      sat-only [ww1_sgN7o
                                                                $dOrd_sgN7r
                                                                $dNum_sgN7s] \r [u_sgN7J v_sgN7K]
                                                          case u_sgN7J of dt_sgN7L {
                                                            __DEFAULT ->
                                                                let {
                                                                  sat_sgN7M [Occ=Once] :: a_sgxFA
                                                                  [LclId] =
                                                                      [$dNum_sgN7s] \u []
                                                                          GHC.Num.fromInteger
                                                                              $dNum_sgN7s
                                                                              Data.Complex.$fFloatingComplex17;
                                                                } in 
                                                                  case
                                                                      GHC.Classes.<
                                                                          $dOrd_sgN7r
                                                                          ww1_sgN7o
                                                                          sat_sgN7M
                                                                  of
                                                                  { GHC.Types.False ->
                                                                        case v_sgN7K of dt1_sgN7O {
                                                                          __DEFAULT ->
                                                                              (#,#) [dt_sgN7L
                                                                                     dt1_sgN7O];
                                                                        };
                                                                    GHC.Types.True ->
                                                                        case
                                                                            GHC.Num.negate
                                                                                $dNum_sgN7s v_sgN7K
                                                                        of
                                                                        dt1_sgN7P
                                                                        { __DEFAULT ->
                                                                              (#,#) [dt_sgN7L
                                                                                     dt1_sgN7P];
                                                                        };
                                                                  };
                                                          };
                                                } in 
                                                  case
                                                      GHC.Classes.< $dOrd_sgN7r ww_sgN7n sat_sgN7Q
                                                  of
                                                  { GHC.Types.False -> $j_sgN7I u'_sgN7x v'_sgN7E;
                                                    GHC.Types.True -> $j_sgN7I v'_sgN7E u'_sgN7x;
                                                  };
                                    } in 
                                      case GHC.Classes.== $dEq_sgN7t ww_sgN7n sat_sgN7S of {
                                        GHC.Types.False -> fail_sgN7u GHC.Prim.void#;
                                        GHC.Types.True ->
                                            let {
                                              sat_sgN7U [Occ=Once] :: a_sgxFA
                                              [LclId] =
                                                  [$dNum_sgN7s] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_sgN7s
                                                          Data.Complex.$fFloatingComplex17;
                                            } in 
                                              case
                                                  GHC.Classes.== $dEq_sgN7t ww1_sgN7o sat_sgN7U
                                              of
                                              { GHC.Types.False -> fail_sgN7u GHC.Prim.void#;
                                                GHC.Types.True ->
                                                    Data.Complex.$w$cfromInteger
                                                        w_sgN7m Data.Complex.$fFloatingComplex17;
                                              };
                                      };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$csqrt [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN7W w1_sgN7X]
        case w1_sgN7X of {
          Data.Complex.:+ ww1_sgN7Z [Occ=Once] ww2_sgN80 [Occ=Once] ->
              case Data.Complex.$w$csqrt w_sgN7W ww1_sgN7Z ww2_sgN80 of {
                (#,#) ww4_sgN82 [Occ=Once] ww5_sgN83 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgN82 ww5_sgN83];
              };
        };

Data.Complex.$fFloatingComplex_$s$crecip [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgN84]
        case eta_sgN84 of {
          Data.Complex.:+ ww1_sgN86 [Occ=Once!] ww2_sgN87 [Occ=Once!] ->
              case ww1_sgN86 of {
                GHC.Types.D# ww4_sgN89 [Occ=Once] ->
                    case ww2_sgN87 of {
                      GHC.Types.D# ww6_sgN8b [Occ=Once] ->
                          case Data.Complex.$w$s$c/ 1.0## 0.0## ww4_sgN89 ww6_sgN8b of {
                            (#,#) ww8_sgN8d [Occ=Once] ww9_sgN8e [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgN8d ww9_sgN8e];
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$crecip1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgN8f]
        case eta_sgN8f of {
          Data.Complex.:+ ww1_sgN8h [Occ=Once!] ww2_sgN8i [Occ=Once!] ->
              case ww1_sgN8h of {
                GHC.Types.F# ww4_sgN8k [Occ=Once] ->
                    case ww2_sgN8i of {
                      GHC.Types.F# ww6_sgN8m [Occ=Once] ->
                          case Data.Complex.$w$s$c/1 1.0# 0.0# ww4_sgN8k ww6_sgN8m of {
                            (#,#) ww8_sgN8o [Occ=Once] ww9_sgN8p [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgN8o ww9_sgN8p];
                          };
                    };
              };
        };

sat_sgN8q :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sgN8r :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgN8q GHC.Types.[]];

Data.Complex.$fFloatingComplex19 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgN8r;

Data.Complex.$fFractionalComplex_$crecip [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgN8s eta_sgN8t]
        case
            Data.Complex.$w$cfromInteger
                $dRealFloat_sgN8s Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww1_sgN8v [Occ=Once] ww2_sgN8w [Occ=Once] ->
              case eta_sgN8t of {
                Data.Complex.:+ ww4_sgN8y [Occ=Once] ww5_sgN8z [Occ=Once] ->
                    case
                        Data.Complex.$w$c/
                            $dRealFloat_sgN8s ww1_sgN8v ww2_sgN8w ww4_sgN8y ww5_sgN8z
                    of
                    { (#,#) ww7_sgN8B [Occ=Once] ww8_sgN8C [Occ=Once] ->
                          Data.Complex.:+ [ww7_sgN8B ww8_sgN8C];
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$fFractionalComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Fractional (Data.Complex.Complex GHC.Types.Double)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Fractional! [Data.Complex.$fFloatingComplex_$s$fNumComplex
                                          Data.Complex.$fFloatingComplex_$s$c/
                                          Data.Complex.$fFloatingComplex_$s$crecip
                                          Data.Complex.$fFloatingComplex_$s$cfromRational];

Data.Complex.$fFloatingComplex_$s$fFractionalComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Real.Fractional (Data.Complex.Complex GHC.Types.Float)
[GblId, Str=m] =
    CCS_DONT_CARE GHC.Real.C:Fractional! [Data.Complex.$fFloatingComplex_$s$fNumComplex1
                                          Data.Complex.$fFloatingComplex_$s$c/1
                                          Data.Complex.$fFloatingComplex_$s$crecip1
                                          Data.Complex.$fFloatingComplex_$s$cfromRational1];

Data.Complex.$fFractionalComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Real.Fractional (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dRealFloat_sgN8D]
        let {
          sat_sgN8H [Occ=Once]
            :: GHC.Real.Rational -> Data.Complex.Complex a_agsZS
          [LclId] =
              [$dRealFloat_sgN8D] \r [eta_B1]
                  Data.Complex.$fFractionalComplex_$cfromRational
                      $dRealFloat_sgN8D eta_B1; } in
        let {
          sat_sgN8G [Occ=Once]
            :: Data.Complex.Complex a_agsZS -> Data.Complex.Complex a_agsZS
          [LclId] =
              [$dRealFloat_sgN8D] \r [eta_B1]
                  Data.Complex.$fFractionalComplex_$crecip
                      $dRealFloat_sgN8D eta_B1; } in
        let {
          sat_sgN8F [Occ=Once]
            :: Data.Complex.Complex a_agsZS
               -> Data.Complex.Complex a_agsZS -> Data.Complex.Complex a_agsZS
          [LclId] =
              [$dRealFloat_sgN8D] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c/
                      $dRealFloat_sgN8D eta_B2 eta_B1; } in
        let {
          sat_sgN8E [Occ=Once] :: GHC.Num.Num (Data.Complex.Complex a_agsZS)
          [LclId] =
              [$dRealFloat_sgN8D] \u []
                  Data.Complex.$fNumComplex $dRealFloat_sgN8D;
        } in 
          GHC.Real.C:Fractional [sat_sgN8E sat_sgN8F sat_sgN8G sat_sgN8H];

Data.Complex.$fFloatingComplex_$s$ctan1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN8I]
        case w_sgN8I of {
          Data.Complex.:+ ww1_sgN8K [Occ=Once!] ww2_sgN8L [Occ=Once!] ->
              case ww1_sgN8K of {
                GHC.Types.F# ww4_sgN8N ->
                    case ww2_sgN8L of {
                      GHC.Types.F# ww6_sgN8P ->
                          case coshFloat# [ww6_sgN8P] of coshy_sgN8Q [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhFloat# [ww6_sgN8P] of sinhy_sgN8R [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosFloat# [ww4_sgN8N] of cosx_sgN8S [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinFloat# [ww4_sgN8N] of sinx_sgN8T [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [sinx_sgN8T sinhy_sgN8R]
                                                  of
                                                  sat_sgN8X
                                                  { __DEFAULT ->
                                                        case negateFloat# [sat_sgN8X] of sat_sgN8Y {
                                                          __DEFAULT ->
                                                              case
                                                                  timesFloat# [cosx_sgN8S
                                                                               coshy_sgN8Q]
                                                              of
                                                              sat_sgN8W
                                                              { __DEFAULT ->
                                                                    case
                                                                        timesFloat# [cosx_sgN8S
                                                                                     sinhy_sgN8R]
                                                                    of
                                                                    sat_sgN8V
                                                                    { __DEFAULT ->
                                                                          case
                                                                              timesFloat# [sinx_sgN8T
                                                                                           coshy_sgN8Q]
                                                                          of
                                                                          sat_sgN8U
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/1
                                                                                        sat_sgN8U
                                                                                        sat_sgN8V
                                                                                        sat_sgN8W
                                                                                        sat_sgN8Y
                                                                                of
                                                                                { (#,#) ww8_sgN90 [Occ=Once]
                                                                                        ww9_sgN91 [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww8_sgN90
                                                                                                       ww9_sgN91];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ctan [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN92]
        case w_sgN92 of {
          Data.Complex.:+ ww1_sgN94 [Occ=Once!] ww2_sgN95 [Occ=Once!] ->
              case ww1_sgN94 of {
                GHC.Types.D# ww4_sgN97 ->
                    case ww2_sgN95 of {
                      GHC.Types.D# ww6_sgN99 ->
                          case coshDouble# [ww6_sgN99] of coshy_sgN9a [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhDouble# [ww6_sgN99] of sinhy_sgN9b [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosDouble# [ww4_sgN97] of cosx_sgN9c [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinDouble# [ww4_sgN97] of sinx_sgN9d [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case *## [sinx_sgN9d sinhy_sgN9b] of sat_sgN9h {
                                                    __DEFAULT ->
                                                        case
                                                            negateDouble# [sat_sgN9h]
                                                        of
                                                        sat_sgN9i
                                                        { __DEFAULT ->
                                                              case
                                                                  *## [cosx_sgN9c coshy_sgN9a]
                                                              of
                                                              sat_sgN9g
                                                              { __DEFAULT ->
                                                                    case
                                                                        *## [cosx_sgN9c sinhy_sgN9b]
                                                                    of
                                                                    sat_sgN9f
                                                                    { __DEFAULT ->
                                                                          case
                                                                              *## [sinx_sgN9d
                                                                                   coshy_sgN9a]
                                                                          of
                                                                          sat_sgN9e
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/
                                                                                        sat_sgN9e
                                                                                        sat_sgN9f
                                                                                        sat_sgN9g
                                                                                        sat_sgN9i
                                                                                of
                                                                                { (#,#) ww8_sgN9k [Occ=Once]
                                                                                        ww9_sgN9l [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww8_sgN9k
                                                                                                       ww9_sgN9l];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ctan [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),1*C1(U),A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgN9m ww_sgN9n ww1_sgN9o]
        case
            GHC.Float.$p1RealFloat w_sgN9m
        of
        $dRealFrac_sgN9p [Dmd=<S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgN9p
              of
              $dReal_sgN9q [Dmd=<S(S(LLC(C(S))C(S)LLL)LL),1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgN9q
                    of
                    $dNum_sgN9r [Dmd=<S(LLC(C(S))C(S)LLL),U(A,A,C(C1(U)),1*C1(U),A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dFloating_sgN9s [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
                              :: GHC.Float.Floating a_sgxGm
                            [LclId] =
                                [w_sgN9m] \u [] GHC.Float.$p2RealFloat w_sgN9m; } in
                          let {
                            coshy_sgN9t :: a_sgxGm
                            [LclId] =
                                [ww1_sgN9o $dFloating_sgN9s] \u []
                                    GHC.Float.cosh $dFloating_sgN9s ww1_sgN9o; } in
                          let {
                            sinx_sgN9u :: a_sgxGm
                            [LclId] =
                                [ww_sgN9n $dFloating_sgN9s] \u []
                                    GHC.Float.sin $dFloating_sgN9s ww_sgN9n;
                          } in 
                            case GHC.Num.* $dNum_sgN9r sinx_sgN9u coshy_sgN9t of dt_sgN9v {
                              __DEFAULT ->
                                  let {
                                    sinhy_sgN9w :: a_sgxGm
                                    [LclId] =
                                        [ww1_sgN9o $dFloating_sgN9s] \u []
                                            GHC.Float.sinh $dFloating_sgN9s ww1_sgN9o; } in
                                  let {
                                    cosx_sgN9x :: a_sgxGm
                                    [LclId] =
                                        [ww_sgN9n $dFloating_sgN9s] \u []
                                            GHC.Float.cos $dFloating_sgN9s ww_sgN9n;
                                  } in 
                                    case GHC.Num.* $dNum_sgN9r cosx_sgN9x sinhy_sgN9w of dt1_sgN9y {
                                      __DEFAULT ->
                                          case
                                              GHC.Num.* $dNum_sgN9r cosx_sgN9x coshy_sgN9t
                                          of
                                          dt2_sgN9z
                                          { __DEFAULT ->
                                                let {
                                                  sat_sgN9A [Occ=Once] :: a_sgxGm
                                                  [LclId] =
                                                      [$dNum_sgN9r sinx_sgN9u sinhy_sgN9w] \u []
                                                          GHC.Num.*
                                                              $dNum_sgN9r sinx_sgN9u sinhy_sgN9w;
                                                } in 
                                                  case
                                                      GHC.Num.negate $dNum_sgN9r sat_sgN9A
                                                  of
                                                  dt3_sgN9B
                                                  { __DEFAULT ->
                                                        Data.Complex.$w$c/
                                                            w_sgN9m
                                                            dt_sgN9v
                                                            dt1_sgN9y
                                                            dt2_sgN9z
                                                            dt3_sgN9B;
                                                  };
                                          };
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$ctan [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgN9C w1_sgN9D]
        case w1_sgN9D of {
          Data.Complex.:+ ww1_sgN9F [Occ=Once] ww2_sgN9G [Occ=Once] ->
              case Data.Complex.$w$ctan w_sgN9C ww1_sgN9F ww2_sgN9G of {
                (#,#) ww4_sgN9I [Occ=Once] ww5_sgN9J [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgN9I ww5_sgN9J];
              };
        };

Data.Complex.$fFloatingComplex_$s$ctanh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgN9K]
        case w_sgN9K of {
          Data.Complex.:+ ww1_sgN9M [Occ=Once!] ww2_sgN9N [Occ=Once!] ->
              case ww1_sgN9M of {
                GHC.Types.F# ww4_sgN9P ->
                    case ww2_sgN9N of {
                      GHC.Types.F# ww6_sgN9R ->
                          case coshFloat# [ww4_sgN9P] of coshx_sgN9S [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhFloat# [ww4_sgN9P] of sinhx_sgN9T [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosFloat# [ww6_sgN9R] of cosy_sgN9U [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinFloat# [ww6_sgN9R] of siny_sgN9V [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [siny_sgN9V sinhx_sgN9T]
                                                  of
                                                  sat_sgN9Z
                                                  { __DEFAULT ->
                                                        case
                                                            timesFloat# [cosy_sgN9U coshx_sgN9S]
                                                        of
                                                        sat_sgN9Y
                                                        { __DEFAULT ->
                                                              case
                                                                  timesFloat# [siny_sgN9V
                                                                               coshx_sgN9S]
                                                              of
                                                              sat_sgN9X
                                                              { __DEFAULT ->
                                                                    case
                                                                        timesFloat# [cosy_sgN9U
                                                                                     sinhx_sgN9T]
                                                                    of
                                                                    sat_sgN9W
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/1
                                                                                  sat_sgN9W
                                                                                  sat_sgN9X
                                                                                  sat_sgN9Y
                                                                                  sat_sgN9Z
                                                                          of
                                                                          { (#,#) ww8_sgNa1 [Occ=Once]
                                                                                  ww9_sgNa2 [Occ=Once] ->
                                                                                Data.Complex.:+ [ww8_sgNa1
                                                                                                 ww9_sgNa2];
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$ctanh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNa3]
        case w_sgNa3 of {
          Data.Complex.:+ ww1_sgNa5 [Occ=Once!] ww2_sgNa6 [Occ=Once!] ->
              case ww1_sgNa5 of {
                GHC.Types.D# ww4_sgNa8 ->
                    case ww2_sgNa6 of {
                      GHC.Types.D# ww6_sgNaa ->
                          case coshDouble# [ww4_sgNa8] of coshx_sgNab [Dmd=<S,U>] {
                            __DEFAULT ->
                                case sinhDouble# [ww4_sgNa8] of sinhx_sgNac [Dmd=<S,U>] {
                                  __DEFAULT ->
                                      case cosDouble# [ww6_sgNaa] of cosy_sgNad [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinDouble# [ww6_sgNaa] of siny_sgNae [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case *## [siny_sgNae sinhx_sgNac] of sat_sgNai {
                                                    __DEFAULT ->
                                                        case
                                                            *## [cosy_sgNad coshx_sgNab]
                                                        of
                                                        sat_sgNah
                                                        { __DEFAULT ->
                                                              case
                                                                  *## [siny_sgNae coshx_sgNab]
                                                              of
                                                              sat_sgNag
                                                              { __DEFAULT ->
                                                                    case
                                                                        *## [cosy_sgNad sinhx_sgNac]
                                                                    of
                                                                    sat_sgNaf
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/
                                                                                  sat_sgNaf
                                                                                  sat_sgNag
                                                                                  sat_sgNah
                                                                                  sat_sgNai
                                                                          of
                                                                          { (#,#) ww8_sgNak [Occ=Once]
                                                                                  ww9_sgNal [Occ=Once] ->
                                                                                Data.Complex.:+ [ww8_sgNak
                                                                                                 ww9_sgNal];
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$w$ctanh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNam ww_sgNan ww1_sgNao]
        case
            GHC.Float.$p1RealFloat w_sgNam
        of
        $dRealFrac_sgNap [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgNap
              of
              $dReal_sgNaq [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgNaq
                    of
                    $dNum_sgNar [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
                    { __DEFAULT ->
                          let {
                            $dFloating_sgNas [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
                              :: GHC.Float.Floating a_sgxH8
                            [LclId] =
                                [w_sgNam] \u [] GHC.Float.$p2RealFloat w_sgNam; } in
                          let {
                            sinhx_sgNat :: a_sgxH8
                            [LclId] =
                                [ww_sgNan $dFloating_sgNas] \u []
                                    GHC.Float.sinh $dFloating_sgNas ww_sgNan; } in
                          let {
                            cosy_sgNau :: a_sgxH8
                            [LclId] =
                                [ww1_sgNao $dFloating_sgNas] \u []
                                    GHC.Float.cos $dFloating_sgNas ww1_sgNao;
                          } in 
                            case GHC.Num.* $dNum_sgNar cosy_sgNau sinhx_sgNat of dt_sgNav {
                              __DEFAULT ->
                                  let {
                                    coshx_sgNaw :: a_sgxH8
                                    [LclId] =
                                        [ww_sgNan $dFloating_sgNas] \u []
                                            GHC.Float.cosh $dFloating_sgNas ww_sgNan; } in
                                  let {
                                    siny_sgNax :: a_sgxH8
                                    [LclId] =
                                        [ww1_sgNao $dFloating_sgNas] \u []
                                            GHC.Float.sin $dFloating_sgNas ww1_sgNao;
                                  } in 
                                    case GHC.Num.* $dNum_sgNar siny_sgNax coshx_sgNaw of dt1_sgNay {
                                      __DEFAULT ->
                                          case
                                              GHC.Num.* $dNum_sgNar cosy_sgNau coshx_sgNaw
                                          of
                                          dt2_sgNaz
                                          { __DEFAULT ->
                                                case
                                                    GHC.Num.* $dNum_sgNar siny_sgNax sinhx_sgNat
                                                of
                                                dt3_sgNaA
                                                { __DEFAULT ->
                                                      Data.Complex.$w$c/
                                                          w_sgNam
                                                          dt_sgNav
                                                          dt1_sgNay
                                                          dt2_sgNaz
                                                          dt3_sgNaA;
                                                };
                                          };
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$ctanh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNaB w1_sgNaC]
        case w1_sgNaC of {
          Data.Complex.:+ ww1_sgNaE [Occ=Once] ww2_sgNaF [Occ=Once] ->
              case Data.Complex.$w$ctanh w_sgNaB ww1_sgNaE ww2_sgNaF of {
                (#,#) ww4_sgNaH [Occ=Once] ww5_sgNaI [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNaH ww5_sgNaI];
              };
        };

Data.Complex.$w$s$cacosh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNaJ ww1_sgNaK]
        case plusFloat# [ww_sgNaJ 1.0#] of sat_sgNaL {
          __DEFAULT ->
              case Data.Complex.$w$s$csqrt1 sat_sgNaL ww1_sgNaK of {
                (#,#) ww3_sgNaN [Occ=Once!] ww4_sgNaO [Occ=Once!] ->
                    case ww4_sgNaO of {
                      GHC.Types.F# x_sgNaQ ->
                          case ww3_sgNaN of {
                            GHC.Types.F# x1_sgNaS ->
                                case minusFloat# [ww_sgNaJ 1.0#] of sat_sgNaT {
                                  __DEFAULT ->
                                      case Data.Complex.$w$s$csqrt1 sat_sgNaT ww1_sgNaK of {
                                        (#,#) ww6_sgNaV [Occ=Once!] ww7_sgNaW [Occ=Once!] ->
                                            case ww7_sgNaW of {
                                              GHC.Types.F# y_sgNaY ->
                                                  case ww6_sgNaV of {
                                                    GHC.Types.F# y1_sgNb0 ->
                                                        case
                                                            timesFloat# [x_sgNaQ y1_sgNb0]
                                                        of
                                                        sat_sgNb3
                                                        { __DEFAULT ->
                                                              case
                                                                  timesFloat# [x1_sgNaS y_sgNaY]
                                                              of
                                                              sat_sgNb2
                                                              { __DEFAULT ->
                                                                    case
                                                                        plusFloat# [sat_sgNb2
                                                                                    sat_sgNb3]
                                                                    of
                                                                    sat_sgNb4
                                                                    { __DEFAULT ->
                                                                          case
                                                                              plusFloat# [ww1_sgNaK
                                                                                          sat_sgNb4]
                                                                          of
                                                                          ww8_sgNb1 [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    timesFloat# [x_sgNaQ
                                                                                                 y_sgNaY]
                                                                                of
                                                                                sat_sgNb7
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          timesFloat# [x1_sgNaS
                                                                                                       y1_sgNb0]
                                                                                      of
                                                                                      sat_sgNb6
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                minusFloat# [sat_sgNb6
                                                                                                             sat_sgNb7]
                                                                                            of
                                                                                            sat_sgNb8
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      plusFloat# [ww_sgNaJ
                                                                                                                  sat_sgNb8]
                                                                                                  of
                                                                                                  ww9_sgNb5 [Dmd=<S,U>]
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$smagnitude1
                                                                                                                ww9_sgNb5
                                                                                                                ww8_sgNb1
                                                                                                        of
                                                                                                        ww10_sgNb9
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  logFloat# [ww10_sgNb9]
                                                                                                              of
                                                                                                              wild4_sgNba
                                                                                                              { __DEFAULT ->
                                                                                                                    case
                                                                                                                        Data.Complex.$w$sphase1
                                                                                                                            ww9_sgNb5
                                                                                                                            ww8_sgNb1
                                                                                                                    of
                                                                                                                    ww11_sgNbb
                                                                                                                    { __DEFAULT ->
                                                                                                                          let {
                                                                                                                            sat_sgNbd [Occ=Once]
                                                                                                                              :: GHC.Types.Float
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.F#! [ww11_sgNbb]; } in
                                                                                                                          let {
                                                                                                                            sat_sgNbc [Occ=Once]
                                                                                                                              :: GHC.Types.Float
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.F#! [wild4_sgNba];
                                                                                                                          } in 
                                                                                                                            (#,#) [sat_sgNbc
                                                                                                                                   sat_sgNbd];
                                                                                                                    };
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacosh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNbe]
        case w_sgNbe of {
          Data.Complex.:+ ww1_sgNbg [Occ=Once!] ww2_sgNbh [Occ=Once!] ->
              case ww1_sgNbg of {
                GHC.Types.F# ww4_sgNbj [Occ=Once] ->
                    case ww2_sgNbh of {
                      GHC.Types.F# ww6_sgNbl [Occ=Once] ->
                          case Data.Complex.$w$s$cacosh1 ww4_sgNbj ww6_sgNbl of {
                            (#,#) ww8_sgNbn [Occ=Once] ww9_sgNbo [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNbn ww9_sgNbo];
                          };
                    };
              };
        };

Data.Complex.$w$s$cacosh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNbp ww1_sgNbq]
        case +## [ww_sgNbp 1.0##] of sat_sgNbr {
          __DEFAULT ->
              case Data.Complex.$w$s$csqrt sat_sgNbr ww1_sgNbq of {
                (#,#) ww3_sgNbt [Occ=Once!] ww4_sgNbu [Occ=Once!] ->
                    case ww4_sgNbu of {
                      GHC.Types.D# x_sgNbw ->
                          case ww3_sgNbt of {
                            GHC.Types.D# x1_sgNby ->
                                case -## [ww_sgNbp 1.0##] of sat_sgNbz {
                                  __DEFAULT ->
                                      case Data.Complex.$w$s$csqrt sat_sgNbz ww1_sgNbq of {
                                        (#,#) ww6_sgNbB [Occ=Once!] ww7_sgNbC [Occ=Once!] ->
                                            case ww7_sgNbC of {
                                              GHC.Types.D# y_sgNbE ->
                                                  case ww6_sgNbB of {
                                                    GHC.Types.D# y1_sgNbG ->
                                                        case *## [x_sgNbw y1_sgNbG] of sat_sgNbJ {
                                                          __DEFAULT ->
                                                              case
                                                                  *## [x1_sgNby y_sgNbE]
                                                              of
                                                              sat_sgNbI
                                                              { __DEFAULT ->
                                                                    case
                                                                        +## [sat_sgNbI sat_sgNbJ]
                                                                    of
                                                                    sat_sgNbK
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +## [ww1_sgNbq
                                                                                   sat_sgNbK]
                                                                          of
                                                                          ww8_sgNbH [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    *## [x_sgNbw
                                                                                         y_sgNbE]
                                                                                of
                                                                                sat_sgNbN
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          *## [x1_sgNby
                                                                                               y1_sgNbG]
                                                                                      of
                                                                                      sat_sgNbM
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                -## [sat_sgNbM
                                                                                                     sat_sgNbN]
                                                                                            of
                                                                                            sat_sgNbO
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      +## [ww_sgNbp
                                                                                                           sat_sgNbO]
                                                                                                  of
                                                                                                  ww9_sgNbL [Dmd=<S,U>]
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$smagnitude
                                                                                                                ww9_sgNbL
                                                                                                                ww8_sgNbH
                                                                                                        of
                                                                                                        ww10_sgNbP
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  logDouble# [ww10_sgNbP]
                                                                                                              of
                                                                                                              wild4_sgNbQ
                                                                                                              { __DEFAULT ->
                                                                                                                    case
                                                                                                                        Data.Complex.$w$sphase
                                                                                                                            ww9_sgNbL
                                                                                                                            ww8_sgNbH
                                                                                                                    of
                                                                                                                    ww11_sgNbR
                                                                                                                    { __DEFAULT ->
                                                                                                                          let {
                                                                                                                            sat_sgNbT [Occ=Once]
                                                                                                                              :: GHC.Types.Double
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.D#! [ww11_sgNbR]; } in
                                                                                                                          let {
                                                                                                                            sat_sgNbS [Occ=Once]
                                                                                                                              :: GHC.Types.Double
                                                                                                                            [LclId] =
                                                                                                                                CCCS GHC.Types.D#! [wild4_sgNbQ];
                                                                                                                          } in 
                                                                                                                            (#,#) [sat_sgNbS
                                                                                                                                   sat_sgNbT];
                                                                                                                    };
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacosh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNbU]
        case w_sgNbU of {
          Data.Complex.:+ ww1_sgNbW [Occ=Once!] ww2_sgNbX [Occ=Once!] ->
              case ww1_sgNbW of {
                GHC.Types.D# ww4_sgNbZ [Occ=Once] ->
                    case ww2_sgNbX of {
                      GHC.Types.D# ww6_sgNc1 [Occ=Once] ->
                          case Data.Complex.$w$s$cacosh ww4_sgNbZ ww6_sgNc1 of {
                            (#,#) ww8_sgNc3 [Occ=Once] ww9_sgNc4 [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNc3 ww9_sgNc4];
                          };
                    };
              };
        };

Data.Complex.$w$cacosh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNc5 ww_sgNc6 ww1_sgNc7]
        case
            Data.Complex.$w$cfromInteger
                w_sgNc5 Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww3_sgNc9 ww4_sgNca ->
              case
                  Data.Complex.$w$c+ w_sgNc5 ww_sgNc6 ww1_sgNc7 ww3_sgNc9 ww4_sgNca
              of
              { (#,#) ww6_sgNcc [Occ=Once] ww7_sgNcd [Occ=Once] ->
                    case Data.Complex.$w$csqrt w_sgNc5 ww6_sgNcc ww7_sgNcd of {
                      (#,#) ww9_sgNcf [Occ=Once] ww10_sgNcg [Occ=Once] ->
                          case
                              Data.Complex.$w$c- w_sgNc5 ww_sgNc6 ww1_sgNc7 ww3_sgNc9 ww4_sgNca
                          of
                          { (#,#) ww12_sgNci [Occ=Once] ww13_sgNcj [Occ=Once] ->
                                case Data.Complex.$w$csqrt w_sgNc5 ww12_sgNci ww13_sgNcj of {
                                  (#,#) ww15_sgNcl [Occ=Once] ww16_sgNcm [Occ=Once] ->
                                      case
                                          Data.Complex.$w$c*
                                              w_sgNc5 ww9_sgNcf ww10_sgNcg ww15_sgNcl ww16_sgNcm
                                      of
                                      { (#,#) ww18_sgNco [Occ=Once] ww19_sgNcp [Occ=Once] ->
                                            case
                                                Data.Complex.$w$c+
                                                    w_sgNc5 ww_sgNc6 ww1_sgNc7 ww18_sgNco ww19_sgNcp
                                            of
                                            { (#,#) ww21_sgNcr [Occ=Once] ww22_sgNcs [Occ=Once] ->
                                                  Data.Complex.$w$clog
                                                      w_sgNc5 ww21_sgNcr ww22_sgNcs;
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cacosh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNct w1_sgNcu]
        case w1_sgNcu of {
          Data.Complex.:+ ww1_sgNcw [Occ=Once] ww2_sgNcx [Occ=Once] ->
              case Data.Complex.$w$cacosh w_sgNct ww1_sgNcw ww2_sgNcx of {
                (#,#) ww4_sgNcz [Occ=Once] ww5_sgNcA [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNcz ww5_sgNcA];
              };
        };

Data.Complex.$w$s$casinh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNcB ww1_sgNcC]
        case timesFloat# [ww1_sgNcC ww_sgNcB] of sat_sgNcI {
          __DEFAULT ->
              case timesFloat# [ww_sgNcB ww1_sgNcC] of sat_sgNcH {
                __DEFAULT ->
                    case plusFloat# [sat_sgNcH sat_sgNcI] of sat_sgNcJ {
                      __DEFAULT ->
                          case timesFloat# [ww1_sgNcC ww1_sgNcC] of sat_sgNcE {
                            __DEFAULT ->
                                case timesFloat# [ww_sgNcB ww_sgNcB] of sat_sgNcD {
                                  __DEFAULT ->
                                      case minusFloat# [sat_sgNcD sat_sgNcE] of sat_sgNcF {
                                        __DEFAULT ->
                                            case plusFloat# [1.0# sat_sgNcF] of sat_sgNcG {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt1 sat_sgNcG sat_sgNcJ
                                                  of
                                                  { (#,#) ww3_sgNcL [Occ=Once!]
                                                          ww4_sgNcM [Occ=Once!] ->
                                                        case ww3_sgNcL of {
                                                          GHC.Types.F# y_sgNcO [Occ=Once] ->
                                                              case ww4_sgNcM of {
                                                                GHC.Types.F# y1_sgNcQ [Occ=Once] ->
                                                                    case
                                                                        plusFloat# [ww1_sgNcC
                                                                                    y1_sgNcQ]
                                                                    of
                                                                    ww5_sgNcR [Dmd=<S,U>]
                                                                    { __DEFAULT ->
                                                                          case
                                                                              plusFloat# [ww_sgNcB
                                                                                          y_sgNcO]
                                                                          of
                                                                          ww6_sgNcS [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$smagnitude1
                                                                                        ww6_sgNcS
                                                                                        ww5_sgNcR
                                                                                of
                                                                                ww7_sgNcT
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          logFloat# [ww7_sgNcT]
                                                                                      of
                                                                                      wild3_sgNcU
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$sphase1
                                                                                                    ww6_sgNcS
                                                                                                    ww5_sgNcR
                                                                                            of
                                                                                            ww8_sgNcV
                                                                                            { __DEFAULT ->
                                                                                                  let {
                                                                                                    sat_sgNcX [Occ=Once]
                                                                                                      :: GHC.Types.Float
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.F#! [ww8_sgNcV]; } in
                                                                                                  let {
                                                                                                    sat_sgNcW [Occ=Once]
                                                                                                      :: GHC.Types.Float
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.F#! [wild3_sgNcU];
                                                                                                  } in 
                                                                                                    (#,#) [sat_sgNcW
                                                                                                           sat_sgNcX];
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casinh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNcY]
        case w_sgNcY of {
          Data.Complex.:+ ww1_sgNd0 [Occ=Once!] ww2_sgNd1 [Occ=Once!] ->
              case ww1_sgNd0 of {
                GHC.Types.F# ww4_sgNd3 [Occ=Once] ->
                    case ww2_sgNd1 of {
                      GHC.Types.F# ww6_sgNd5 [Occ=Once] ->
                          case Data.Complex.$w$s$casinh1 ww4_sgNd3 ww6_sgNd5 of {
                            (#,#) ww8_sgNd7 [Occ=Once] ww9_sgNd8 [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNd7 ww9_sgNd8];
                          };
                    };
              };
        };

Data.Complex.$w$s$casinh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNd9 ww1_sgNda]
        case *## [ww1_sgNda ww_sgNd9] of sat_sgNdg {
          __DEFAULT ->
              case *## [ww_sgNd9 ww1_sgNda] of sat_sgNdf {
                __DEFAULT ->
                    case +## [sat_sgNdf sat_sgNdg] of sat_sgNdh {
                      __DEFAULT ->
                          case *## [ww1_sgNda ww1_sgNda] of sat_sgNdc {
                            __DEFAULT ->
                                case *## [ww_sgNd9 ww_sgNd9] of sat_sgNdb {
                                  __DEFAULT ->
                                      case -## [sat_sgNdb sat_sgNdc] of sat_sgNdd {
                                        __DEFAULT ->
                                            case +## [1.0## sat_sgNdd] of sat_sgNde {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt sat_sgNde sat_sgNdh
                                                  of
                                                  { (#,#) ww3_sgNdj [Occ=Once!]
                                                          ww4_sgNdk [Occ=Once!] ->
                                                        case ww3_sgNdj of {
                                                          GHC.Types.D# y_sgNdm [Occ=Once] ->
                                                              case ww4_sgNdk of {
                                                                GHC.Types.D# y1_sgNdo [Occ=Once] ->
                                                                    case
                                                                        +## [ww1_sgNda y1_sgNdo]
                                                                    of
                                                                    ww5_sgNdp [Dmd=<S,U>]
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +## [ww_sgNd9 y_sgNdm]
                                                                          of
                                                                          ww6_sgNdq [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$smagnitude
                                                                                        ww6_sgNdq
                                                                                        ww5_sgNdp
                                                                                of
                                                                                ww7_sgNdr
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          logDouble# [ww7_sgNdr]
                                                                                      of
                                                                                      wild3_sgNds
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$sphase
                                                                                                    ww6_sgNdq
                                                                                                    ww5_sgNdp
                                                                                            of
                                                                                            ww8_sgNdt
                                                                                            { __DEFAULT ->
                                                                                                  let {
                                                                                                    sat_sgNdv [Occ=Once]
                                                                                                      :: GHC.Types.Double
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.D#! [ww8_sgNdt]; } in
                                                                                                  let {
                                                                                                    sat_sgNdu [Occ=Once]
                                                                                                      :: GHC.Types.Double
                                                                                                    [LclId] =
                                                                                                        CCCS GHC.Types.D#! [wild3_sgNds];
                                                                                                  } in 
                                                                                                    (#,#) [sat_sgNdu
                                                                                                           sat_sgNdv];
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casinh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNdw]
        case w_sgNdw of {
          Data.Complex.:+ ww1_sgNdy [Occ=Once!] ww2_sgNdz [Occ=Once!] ->
              case ww1_sgNdy of {
                GHC.Types.D# ww4_sgNdB [Occ=Once] ->
                    case ww2_sgNdz of {
                      GHC.Types.D# ww6_sgNdD [Occ=Once] ->
                          case Data.Complex.$w$s$casinh ww4_sgNdB ww6_sgNdD of {
                            (#,#) ww8_sgNdF [Occ=Once] ww9_sgNdG [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNdF ww9_sgNdG];
                          };
                    };
              };
        };

Data.Complex.$w$casinh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),1*C1(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNdH ww_sgNdI ww1_sgNdJ]
        case
            Data.Complex.$w$cfromInteger
                w_sgNdH Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww3_sgNdL [Occ=Once] ww4_sgNdM [Occ=Once] ->
              case
                  Data.Complex.$w$c* w_sgNdH ww_sgNdI ww1_sgNdJ ww_sgNdI ww1_sgNdJ
              of
              { (#,#) ww6_sgNdO [Occ=Once] ww7_sgNdP [Occ=Once] ->
                    case
                        Data.Complex.$w$c+ w_sgNdH ww3_sgNdL ww4_sgNdM ww6_sgNdO ww7_sgNdP
                    of
                    { (#,#) ww9_sgNdR [Occ=Once] ww10_sgNdS [Occ=Once] ->
                          case Data.Complex.$w$csqrt w_sgNdH ww9_sgNdR ww10_sgNdS of {
                            (#,#) ww12_sgNdU [Occ=Once] ww13_sgNdV [Occ=Once] ->
                                case
                                    Data.Complex.$w$c+
                                        w_sgNdH ww_sgNdI ww1_sgNdJ ww12_sgNdU ww13_sgNdV
                                of
                                { (#,#) ww15_sgNdX [Occ=Once] ww16_sgNdY [Occ=Once] ->
                                      Data.Complex.$w$clog w_sgNdH ww15_sgNdX ww16_sgNdY;
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$casinh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNdZ w1_sgNe0]
        case w1_sgNe0 of {
          Data.Complex.:+ ww1_sgNe2 [Occ=Once] ww2_sgNe3 [Occ=Once] ->
              case Data.Complex.$w$casinh w_sgNdZ ww1_sgNe2 ww2_sgNe3 of {
                (#,#) ww4_sgNe5 [Occ=Once] ww5_sgNe6 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNe5 ww5_sgNe6];
              };
        };

Data.Complex.$w$s$catan1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNe7 ww1_sgNe8]
        case timesFloat# [ww1_sgNe8 ww_sgNe7] of sat_sgNee {
          __DEFAULT ->
              case timesFloat# [ww_sgNe7 ww1_sgNe8] of sat_sgNed {
                __DEFAULT ->
                    case plusFloat# [sat_sgNed sat_sgNee] of sat_sgNef {
                      __DEFAULT ->
                          case timesFloat# [ww1_sgNe8 ww1_sgNe8] of sat_sgNea {
                            __DEFAULT ->
                                case timesFloat# [ww_sgNe7 ww_sgNe7] of sat_sgNe9 {
                                  __DEFAULT ->
                                      case minusFloat# [sat_sgNe9 sat_sgNea] of sat_sgNeb {
                                        __DEFAULT ->
                                            case plusFloat# [1.0# sat_sgNeb] of sat_sgNec {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt1 sat_sgNec sat_sgNef
                                                  of
                                                  { (#,#) ww3_sgNeh [Occ=Once!]
                                                          ww4_sgNei [Occ=Once!] ->
                                                        case ww3_sgNeh of {
                                                          GHC.Types.F# ww6_sgNek [Occ=Once] ->
                                                              case ww4_sgNei of {
                                                                GHC.Types.F# ww8_sgNem [Occ=Once] ->
                                                                    case
                                                                        minusFloat# [1.0# ww1_sgNe8]
                                                                    of
                                                                    sat_sgNen
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/1
                                                                                  sat_sgNen
                                                                                  ww_sgNe7
                                                                                  ww6_sgNek
                                                                                  ww8_sgNem
                                                                          of
                                                                          { (#,#) ww10_sgNep [Occ=Once!]
                                                                                  ww11_sgNeq [Occ=Once!] ->
                                                                                case ww10_sgNep of {
                                                                                  GHC.Types.F# ww13_sgNes ->
                                                                                      case
                                                                                          ww11_sgNeq
                                                                                      of
                                                                                      { GHC.Types.F# ww15_sgNeu ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude1
                                                                                                    ww13_sgNes
                                                                                                    ww15_sgNeu
                                                                                            of
                                                                                            ww16_sgNev
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logFloat# [ww16_sgNev]
                                                                                                  of
                                                                                                  wild1_sgNew
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase1
                                                                                                                ww13_sgNes
                                                                                                                ww15_sgNeu
                                                                                                        of
                                                                                                        ww17_sgNex
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateFloat# [wild1_sgNew]
                                                                                                              of
                                                                                                              sat_sgNez
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgNeA [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [sat_sgNez]; } in
                                                                                                                    let {
                                                                                                                      sat_sgNey [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [ww17_sgNex];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgNey
                                                                                                                             sat_sgNeA];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catan1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNeB]
        case w_sgNeB of {
          Data.Complex.:+ ww1_sgNeD [Occ=Once!] ww2_sgNeE [Occ=Once!] ->
              case ww1_sgNeD of {
                GHC.Types.F# ww4_sgNeG [Occ=Once] ->
                    case ww2_sgNeE of {
                      GHC.Types.F# ww6_sgNeI [Occ=Once] ->
                          case Data.Complex.$w$s$catan1 ww4_sgNeG ww6_sgNeI of {
                            (#,#) ww8_sgNeK [Occ=Once] ww9_sgNeL [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNeK ww9_sgNeL];
                          };
                    };
              };
        };

Data.Complex.$w$s$catan [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNeM ww1_sgNeN]
        case *## [ww1_sgNeN ww_sgNeM] of sat_sgNeT {
          __DEFAULT ->
              case *## [ww_sgNeM ww1_sgNeN] of sat_sgNeS {
                __DEFAULT ->
                    case +## [sat_sgNeS sat_sgNeT] of sat_sgNeU {
                      __DEFAULT ->
                          case *## [ww1_sgNeN ww1_sgNeN] of sat_sgNeP {
                            __DEFAULT ->
                                case *## [ww_sgNeM ww_sgNeM] of sat_sgNeO {
                                  __DEFAULT ->
                                      case -## [sat_sgNeO sat_sgNeP] of sat_sgNeQ {
                                        __DEFAULT ->
                                            case +## [1.0## sat_sgNeQ] of sat_sgNeR {
                                              __DEFAULT ->
                                                  case
                                                      Data.Complex.$w$s$csqrt sat_sgNeR sat_sgNeU
                                                  of
                                                  { (#,#) ww3_sgNeW [Occ=Once!]
                                                          ww4_sgNeX [Occ=Once!] ->
                                                        case ww3_sgNeW of {
                                                          GHC.Types.D# ww6_sgNeZ [Occ=Once] ->
                                                              case ww4_sgNeX of {
                                                                GHC.Types.D# ww8_sgNf1 [Occ=Once] ->
                                                                    case
                                                                        -## [1.0## ww1_sgNeN]
                                                                    of
                                                                    sat_sgNf2
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$s$c/
                                                                                  sat_sgNf2
                                                                                  ww_sgNeM
                                                                                  ww6_sgNeZ
                                                                                  ww8_sgNf1
                                                                          of
                                                                          { (#,#) ww10_sgNf4 [Occ=Once!]
                                                                                  ww11_sgNf5 [Occ=Once!] ->
                                                                                case ww10_sgNf4 of {
                                                                                  GHC.Types.D# ww13_sgNf7 ->
                                                                                      case
                                                                                          ww11_sgNf5
                                                                                      of
                                                                                      { GHC.Types.D# ww15_sgNf9 ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude
                                                                                                    ww13_sgNf7
                                                                                                    ww15_sgNf9
                                                                                            of
                                                                                            ww16_sgNfa
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logDouble# [ww16_sgNfa]
                                                                                                  of
                                                                                                  wild1_sgNfb
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase
                                                                                                                ww13_sgNf7
                                                                                                                ww15_sgNf9
                                                                                                        of
                                                                                                        ww17_sgNfc
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateDouble# [wild1_sgNfb]
                                                                                                              of
                                                                                                              sat_sgNfe
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgNff [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [sat_sgNfe]; } in
                                                                                                                    let {
                                                                                                                      sat_sgNfd [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [ww17_sgNfc];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgNfd
                                                                                                                             sat_sgNff];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catan [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNfg]
        case w_sgNfg of {
          Data.Complex.:+ ww1_sgNfi [Occ=Once!] ww2_sgNfj [Occ=Once!] ->
              case ww1_sgNfi of {
                GHC.Types.D# ww4_sgNfl [Occ=Once] ->
                    case ww2_sgNfj of {
                      GHC.Types.D# ww6_sgNfn [Occ=Once] ->
                          case Data.Complex.$w$s$catan ww4_sgNfl ww6_sgNfn of {
                            (#,#) ww8_sgNfp [Occ=Once] ww9_sgNfq [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNfp ww9_sgNfq];
                          };
                    };
              };
        };

Data.Complex.$w$catan [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNfr ww_sgNfs ww1_sgNft]
        case
            GHC.Float.$p1RealFloat w_sgNfr
        of
        $dRealFrac_sgNfu [Dmd=<S(S(S(LC(C(S))LC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U)),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgNfu
              of
              $dReal_sgNfv [Dmd=<S(S(LC(C(S))LC(S)LLL)LL),1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U)),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgNfv
                    of
                    $dNum_sgNfw [Dmd=<S(LC(C(S))LC(S)LLL),U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U))>]
                    { __DEFAULT ->
                          let {
                            sat_sgNfx [Occ=Once] :: a_sgxKN
                            [LclId] =
                                [$dNum_sgNfw] \u []
                                    GHC.Num.fromInteger
                                        $dNum_sgNfw Data.Complex.$fFloatingComplex19;
                          } in 
                            case GHC.Num.- $dNum_sgNfw sat_sgNfx ww1_sgNft of dt_sgNfy {
                              __DEFAULT ->
                                  case
                                      Data.Complex.$w$cfromInteger
                                          w_sgNfr Data.Complex.$fFloatingComplex19
                                  of
                                  { (#,#) ww3_sgNfA [Occ=Once] ww4_sgNfB [Occ=Once] ->
                                        case
                                            Data.Complex.$w$c*
                                                w_sgNfr ww_sgNfs ww1_sgNft ww_sgNfs ww1_sgNft
                                        of
                                        { (#,#) ww6_sgNfD [Occ=Once] ww7_sgNfE [Occ=Once] ->
                                              case
                                                  Data.Complex.$w$c+
                                                      w_sgNfr
                                                      ww3_sgNfA
                                                      ww4_sgNfB
                                                      ww6_sgNfD
                                                      ww7_sgNfE
                                              of
                                              { (#,#) ww9_sgNfG [Occ=Once] ww10_sgNfH [Occ=Once] ->
                                                    case
                                                        Data.Complex.$w$csqrt
                                                            w_sgNfr ww9_sgNfG ww10_sgNfH
                                                    of
                                                    { (#,#) ww12_sgNfJ [Occ=Once]
                                                            ww13_sgNfK [Occ=Once] ->
                                                          case
                                                              Data.Complex.$w$c/
                                                                  w_sgNfr
                                                                  dt_sgNfy
                                                                  ww_sgNfs
                                                                  ww12_sgNfJ
                                                                  ww13_sgNfK
                                                          of
                                                          { (#,#) ww15_sgNfM ww16_sgNfN ->
                                                                let {
                                                                  sat_sgNfP [Occ=Once] :: a_sgxKN
                                                                  [LclId] =
                                                                      [w_sgNfr
                                                                       ww15_sgNfM
                                                                       ww16_sgNfN] \u []
                                                                          Data.Complex.$wmagnitude
                                                                              w_sgNfr
                                                                              ww15_sgNfM
                                                                              ww16_sgNfN;
                                                                } in 
                                                                  case
                                                                      GHC.Float.$p2RealFloat w_sgNfr
                                                                  of
                                                                  sat_sgNfO
                                                                  { __DEFAULT ->
                                                                        case
                                                                            GHC.Float.log
                                                                                sat_sgNfO sat_sgNfP
                                                                        of
                                                                        dt1_sgNfQ
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  Data.Complex.$wphase
                                                                                      w_sgNfr
                                                                                      ww15_sgNfM
                                                                                      ww16_sgNfN
                                                                              of
                                                                              dt2_sgNfR
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        GHC.Num.negate
                                                                                            $dNum_sgNfw
                                                                                            dt1_sgNfQ
                                                                                    of
                                                                                    dt3_sgNfS
                                                                                    { __DEFAULT ->
                                                                                          (#,#) [dt2_sgNfR
                                                                                                 dt3_sgNfS];
                                                                                    };
                                                                              };
                                                                        };
                                                                  };
                                                          };
                                                    };
                                              };
                                        };
                                  };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$catan [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNfT w1_sgNfU]
        case w1_sgNfU of {
          Data.Complex.:+ ww1_sgNfW [Occ=Once] ww2_sgNfX [Occ=Once] ->
              case Data.Complex.$w$catan w_sgNfT ww1_sgNfW ww2_sgNfX of {
                (#,#) ww4_sgNfZ [Occ=Once] ww5_sgNg0 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNfZ ww5_sgNg0];
              };
        };

Data.Complex.$w$s$cacos1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNg1 ww1_sgNg2]
        case timesFloat# [ww1_sgNg2 ww_sgNg1] of sat_sgNg8 {
          __DEFAULT ->
              case timesFloat# [ww_sgNg1 ww1_sgNg2] of sat_sgNg7 {
                __DEFAULT ->
                    case plusFloat# [sat_sgNg7 sat_sgNg8] of sat_sgNg9 {
                      __DEFAULT ->
                          case minusFloat# [0.0# sat_sgNg9] of sat_sgNga {
                            __DEFAULT ->
                                case timesFloat# [ww1_sgNg2 ww1_sgNg2] of sat_sgNg4 {
                                  __DEFAULT ->
                                      case timesFloat# [ww_sgNg1 ww_sgNg1] of sat_sgNg3 {
                                        __DEFAULT ->
                                            case minusFloat# [sat_sgNg3 sat_sgNg4] of sat_sgNg5 {
                                              __DEFAULT ->
                                                  case minusFloat# [1.0# sat_sgNg5] of sat_sgNg6 {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt1
                                                                sat_sgNg6 sat_sgNga
                                                        of
                                                        { (#,#) ww3_sgNgc [Occ=Once!]
                                                                ww4_sgNgd [Occ=Once!] ->
                                                              case ww4_sgNgd of {
                                                                GHC.Types.F# x_sgNgf [Occ=Once] ->
                                                                    case ww3_sgNgc of {
                                                                      GHC.Types.F# y_sgNgh [Occ=Once] ->
                                                                          case
                                                                              plusFloat# [ww1_sgNg2
                                                                                          y_sgNgh]
                                                                          of
                                                                          ww5_sgNgi [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateFloat# [x_sgNgf]
                                                                                of
                                                                                sat_sgNgk
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          plusFloat# [ww_sgNg1
                                                                                                      sat_sgNgk]
                                                                                      of
                                                                                      ww6_sgNgj [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude1
                                                                                                    ww6_sgNgj
                                                                                                    ww5_sgNgi
                                                                                            of
                                                                                            ww7_sgNgl
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logFloat# [ww7_sgNgl]
                                                                                                  of
                                                                                                  wild2_sgNgm
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase1
                                                                                                                ww6_sgNgj
                                                                                                                ww5_sgNgi
                                                                                                        of
                                                                                                        ww8_sgNgn
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateFloat# [wild2_sgNgm]
                                                                                                              of
                                                                                                              sat_sgNgp
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgNgq [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [sat_sgNgp]; } in
                                                                                                                    let {
                                                                                                                      sat_sgNgo [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [ww8_sgNgn];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgNgo
                                                                                                                             sat_sgNgq];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacos1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNgr]
        case w_sgNgr of {
          Data.Complex.:+ ww1_sgNgt [Occ=Once!] ww2_sgNgu [Occ=Once!] ->
              case ww1_sgNgt of {
                GHC.Types.F# ww4_sgNgw [Occ=Once] ->
                    case ww2_sgNgu of {
                      GHC.Types.F# ww6_sgNgy [Occ=Once] ->
                          case Data.Complex.$w$s$cacos1 ww4_sgNgw ww6_sgNgy of {
                            (#,#) ww8_sgNgA [Occ=Once] ww9_sgNgB [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNgA ww9_sgNgB];
                          };
                    };
              };
        };

Data.Complex.$w$s$cacos [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNgC ww1_sgNgD]
        case *## [ww1_sgNgD ww_sgNgC] of sat_sgNgJ {
          __DEFAULT ->
              case *## [ww_sgNgC ww1_sgNgD] of sat_sgNgI {
                __DEFAULT ->
                    case +## [sat_sgNgI sat_sgNgJ] of sat_sgNgK {
                      __DEFAULT ->
                          case -## [0.0## sat_sgNgK] of sat_sgNgL {
                            __DEFAULT ->
                                case *## [ww1_sgNgD ww1_sgNgD] of sat_sgNgF {
                                  __DEFAULT ->
                                      case *## [ww_sgNgC ww_sgNgC] of sat_sgNgE {
                                        __DEFAULT ->
                                            case -## [sat_sgNgE sat_sgNgF] of sat_sgNgG {
                                              __DEFAULT ->
                                                  case -## [1.0## sat_sgNgG] of sat_sgNgH {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt
                                                                sat_sgNgH sat_sgNgL
                                                        of
                                                        { (#,#) ww3_sgNgN [Occ=Once!]
                                                                ww4_sgNgO [Occ=Once!] ->
                                                              case ww4_sgNgO of {
                                                                GHC.Types.D# x_sgNgQ [Occ=Once] ->
                                                                    case ww3_sgNgN of {
                                                                      GHC.Types.D# y_sgNgS [Occ=Once] ->
                                                                          case
                                                                              +## [ww1_sgNgD
                                                                                   y_sgNgS]
                                                                          of
                                                                          ww5_sgNgT [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateDouble# [x_sgNgQ]
                                                                                of
                                                                                sat_sgNgV
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          +## [ww_sgNgC
                                                                                               sat_sgNgV]
                                                                                      of
                                                                                      ww6_sgNgU [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude
                                                                                                    ww6_sgNgU
                                                                                                    ww5_sgNgT
                                                                                            of
                                                                                            ww7_sgNgW
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logDouble# [ww7_sgNgW]
                                                                                                  of
                                                                                                  wild2_sgNgX
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase
                                                                                                                ww6_sgNgU
                                                                                                                ww5_sgNgT
                                                                                                        of
                                                                                                        ww8_sgNgY
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateDouble# [wild2_sgNgX]
                                                                                                              of
                                                                                                              sat_sgNh0
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgNh1 [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [sat_sgNh0]; } in
                                                                                                                    let {
                                                                                                                      sat_sgNgZ [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [ww8_sgNgY];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgNgZ
                                                                                                                             sat_sgNh1];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cacos [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNh2]
        case w_sgNh2 of {
          Data.Complex.:+ ww1_sgNh4 [Occ=Once!] ww2_sgNh5 [Occ=Once!] ->
              case ww1_sgNh4 of {
                GHC.Types.D# ww4_sgNh7 [Occ=Once] ->
                    case ww2_sgNh5 of {
                      GHC.Types.D# ww6_sgNh9 [Occ=Once] ->
                          case Data.Complex.$w$s$cacos ww4_sgNh7 ww6_sgNh9 of {
                            (#,#) ww8_sgNhb [Occ=Once] ww9_sgNhc [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNhb ww9_sgNhc];
                          };
                    };
              };
        };

Data.Complex.$w$cacos [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNhd ww_sgNhe ww1_sgNhf]
        case
            Data.Complex.$w$cfromInteger
                w_sgNhd Data.Complex.$fFloatingComplex19
        of
        { (#,#) ww3_sgNhh [Occ=Once] ww4_sgNhi [Occ=Once] ->
              case
                  Data.Complex.$w$c* w_sgNhd ww_sgNhe ww1_sgNhf ww_sgNhe ww1_sgNhf
              of
              { (#,#) ww6_sgNhk [Occ=Once] ww7_sgNhl [Occ=Once] ->
                    case
                        Data.Complex.$w$c- w_sgNhd ww3_sgNhh ww4_sgNhi ww6_sgNhk ww7_sgNhl
                    of
                    { (#,#) ww9_sgNhn [Occ=Once] ww10_sgNho [Occ=Once] ->
                          case Data.Complex.$w$csqrt w_sgNhd ww9_sgNhn ww10_sgNho of {
                            (#,#) ww12_sgNhq [Occ=Once] ww13_sgNhr [Occ=Once] ->
                                case
                                    GHC.Float.$p1RealFloat w_sgNhd
                                of
                                $dRealFrac_sgNhs [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
                                { __DEFAULT ->
                                      case
                                          GHC.Real.$p1RealFrac $dRealFrac_sgNhs
                                      of
                                      $dReal_sgNht [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
                                      { __DEFAULT ->
                                            case
                                                GHC.Real.$p1Real $dReal_sgNht
                                            of
                                            $dNum_sgNhu [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
                                            { __DEFAULT ->
                                                  case
                                                      GHC.Num.negate $dNum_sgNhu ww13_sgNhr
                                                  of
                                                  dt_sgNhv
                                                  { __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$c+
                                                                w_sgNhd
                                                                ww_sgNhe
                                                                ww1_sgNhf
                                                                dt_sgNhv
                                                                ww12_sgNhq
                                                        of
                                                        { (#,#) ww15_sgNhx ww16_sgNhy ->
                                                              let {
                                                                sat_sgNhA [Occ=Once] :: a_sgxM9
                                                                [LclId] =
                                                                    [w_sgNhd
                                                                     ww15_sgNhx
                                                                     ww16_sgNhy] \u []
                                                                        Data.Complex.$wmagnitude
                                                                            w_sgNhd
                                                                            ww15_sgNhx
                                                                            ww16_sgNhy;
                                                              } in 
                                                                case
                                                                    GHC.Float.$p2RealFloat w_sgNhd
                                                                of
                                                                sat_sgNhz
                                                                { __DEFAULT ->
                                                                      case
                                                                          GHC.Float.log
                                                                              sat_sgNhz sat_sgNhA
                                                                      of
                                                                      dt1_sgNhB
                                                                      { __DEFAULT ->
                                                                            case
                                                                                Data.Complex.$wphase
                                                                                    w_sgNhd
                                                                                    ww15_sgNhx
                                                                                    ww16_sgNhy
                                                                            of
                                                                            dt2_sgNhC
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      GHC.Num.negate
                                                                                          $dNum_sgNhu
                                                                                          dt1_sgNhB
                                                                                  of
                                                                                  dt3_sgNhD
                                                                                  { __DEFAULT ->
                                                                                        (#,#) [dt2_sgNhC
                                                                                               dt3_sgNhD];
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cacos [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNhE w1_sgNhF]
        case w1_sgNhF of {
          Data.Complex.:+ ww1_sgNhH [Occ=Once] ww2_sgNhI [Occ=Once] ->
              case Data.Complex.$w$cacos w_sgNhE ww1_sgNhH ww2_sgNhI of {
                (#,#) ww4_sgNhK [Occ=Once] ww5_sgNhL [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNhK ww5_sgNhL];
              };
        };

Data.Complex.$w$s$casin1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNhM ww1_sgNhN]
        case timesFloat# [ww1_sgNhN ww_sgNhM] of sat_sgNhT {
          __DEFAULT ->
              case timesFloat# [ww_sgNhM ww1_sgNhN] of sat_sgNhS {
                __DEFAULT ->
                    case plusFloat# [sat_sgNhS sat_sgNhT] of sat_sgNhU {
                      __DEFAULT ->
                          case minusFloat# [0.0# sat_sgNhU] of sat_sgNhV {
                            __DEFAULT ->
                                case timesFloat# [ww1_sgNhN ww1_sgNhN] of sat_sgNhP {
                                  __DEFAULT ->
                                      case timesFloat# [ww_sgNhM ww_sgNhM] of sat_sgNhO {
                                        __DEFAULT ->
                                            case minusFloat# [sat_sgNhO sat_sgNhP] of sat_sgNhQ {
                                              __DEFAULT ->
                                                  case minusFloat# [1.0# sat_sgNhQ] of sat_sgNhR {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt1
                                                                sat_sgNhR sat_sgNhV
                                                        of
                                                        { (#,#) ww3_sgNhX [Occ=Once!]
                                                                ww4_sgNhY [Occ=Once!] ->
                                                              case ww3_sgNhX of {
                                                                GHC.Types.F# y_sgNi0 [Occ=Once] ->
                                                                    case ww4_sgNhY of {
                                                                      GHC.Types.F# y1_sgNi2 [Occ=Once] ->
                                                                          case
                                                                              plusFloat# [ww_sgNhM
                                                                                          y1_sgNi2]
                                                                          of
                                                                          ww5_sgNi3 [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateFloat# [ww1_sgNhN]
                                                                                of
                                                                                sat_sgNi5
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          plusFloat# [sat_sgNi5
                                                                                                      y_sgNi0]
                                                                                      of
                                                                                      ww6_sgNi4 [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude1
                                                                                                    ww6_sgNi4
                                                                                                    ww5_sgNi3
                                                                                            of
                                                                                            ww7_sgNi6
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logFloat# [ww7_sgNi6]
                                                                                                  of
                                                                                                  wild3_sgNi7
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase1
                                                                                                                ww6_sgNi4
                                                                                                                ww5_sgNi3
                                                                                                        of
                                                                                                        ww8_sgNi8
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateFloat# [wild3_sgNi7]
                                                                                                              of
                                                                                                              sat_sgNia
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgNib [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [sat_sgNia]; } in
                                                                                                                    let {
                                                                                                                      sat_sgNi9 [Occ=Once]
                                                                                                                        :: GHC.Types.Float
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.F#! [ww8_sgNi8];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgNi9
                                                                                                                             sat_sgNib];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casin1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNic]
        case w_sgNic of {
          Data.Complex.:+ ww1_sgNie [Occ=Once!] ww2_sgNif [Occ=Once!] ->
              case ww1_sgNie of {
                GHC.Types.F# ww4_sgNih [Occ=Once] ->
                    case ww2_sgNif of {
                      GHC.Types.F# ww6_sgNij [Occ=Once] ->
                          case Data.Complex.$w$s$casin1 ww4_sgNih ww6_sgNij of {
                            (#,#) ww8_sgNil [Occ=Once] ww9_sgNim [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNil ww9_sgNim];
                          };
                    };
              };
        };

Data.Complex.$w$s$casin [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNin ww1_sgNio]
        case *## [ww1_sgNio ww_sgNin] of sat_sgNiu {
          __DEFAULT ->
              case *## [ww_sgNin ww1_sgNio] of sat_sgNit {
                __DEFAULT ->
                    case +## [sat_sgNit sat_sgNiu] of sat_sgNiv {
                      __DEFAULT ->
                          case -## [0.0## sat_sgNiv] of sat_sgNiw {
                            __DEFAULT ->
                                case *## [ww1_sgNio ww1_sgNio] of sat_sgNiq {
                                  __DEFAULT ->
                                      case *## [ww_sgNin ww_sgNin] of sat_sgNip {
                                        __DEFAULT ->
                                            case -## [sat_sgNip sat_sgNiq] of sat_sgNir {
                                              __DEFAULT ->
                                                  case -## [1.0## sat_sgNir] of sat_sgNis {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$s$csqrt
                                                                sat_sgNis sat_sgNiw
                                                        of
                                                        { (#,#) ww3_sgNiy [Occ=Once!]
                                                                ww4_sgNiz [Occ=Once!] ->
                                                              case ww3_sgNiy of {
                                                                GHC.Types.D# y_sgNiB [Occ=Once] ->
                                                                    case ww4_sgNiz of {
                                                                      GHC.Types.D# y1_sgNiD [Occ=Once] ->
                                                                          case
                                                                              +## [ww_sgNin
                                                                                   y1_sgNiD]
                                                                          of
                                                                          ww5_sgNiE [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateDouble# [ww1_sgNio]
                                                                                of
                                                                                sat_sgNiG
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          +## [sat_sgNiG
                                                                                               y_sgNiB]
                                                                                      of
                                                                                      ww6_sgNiF [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                Data.Complex.$w$smagnitude
                                                                                                    ww6_sgNiF
                                                                                                    ww5_sgNiE
                                                                                            of
                                                                                            ww7_sgNiH
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      logDouble# [ww7_sgNiH]
                                                                                                  of
                                                                                                  wild3_sgNiI
                                                                                                  { __DEFAULT ->
                                                                                                        case
                                                                                                            Data.Complex.$w$sphase
                                                                                                                ww6_sgNiF
                                                                                                                ww5_sgNiE
                                                                                                        of
                                                                                                        ww8_sgNiJ
                                                                                                        { __DEFAULT ->
                                                                                                              case
                                                                                                                  negateDouble# [wild3_sgNiI]
                                                                                                              of
                                                                                                              sat_sgNiL
                                                                                                              { __DEFAULT ->
                                                                                                                    let {
                                                                                                                      sat_sgNiM [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [sat_sgNiL]; } in
                                                                                                                    let {
                                                                                                                      sat_sgNiK [Occ=Once]
                                                                                                                        :: GHC.Types.Double
                                                                                                                      [LclId] =
                                                                                                                          CCCS GHC.Types.D#! [ww8_sgNiJ];
                                                                                                                    } in 
                                                                                                                      (#,#) [sat_sgNiK
                                                                                                                             sat_sgNiM];
                                                                                                              };
                                                                                                        };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$casin [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNiN]
        case w_sgNiN of {
          Data.Complex.:+ ww1_sgNiP [Occ=Once!] ww2_sgNiQ [Occ=Once!] ->
              case ww1_sgNiP of {
                GHC.Types.D# ww4_sgNiS [Occ=Once] ->
                    case ww2_sgNiQ of {
                      GHC.Types.D# ww6_sgNiU [Occ=Once] ->
                          case Data.Complex.$w$s$casin ww4_sgNiS ww6_sgNiU of {
                            (#,#) ww8_sgNiW [Occ=Once] ww9_sgNiX [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNiW ww9_sgNiX];
                          };
                    };
              };
        };

Data.Complex.$w$casin [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNiY ww_sgNiZ ww1_sgNj0]
        case
            GHC.Float.$p1RealFloat w_sgNiY
        of
        $dRealFrac_sgNj1 [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgNj1
              of
              $dReal_sgNj2 [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1Real $dReal_sgNj2
                    of
                    $dNum_sgNj3 [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
                    { __DEFAULT ->
                          case GHC.Num.negate $dNum_sgNj3 ww1_sgNj0 of dt_sgNj4 {
                            __DEFAULT ->
                                case
                                    Data.Complex.$w$cfromInteger
                                        w_sgNiY Data.Complex.$fFloatingComplex19
                                of
                                { (#,#) ww3_sgNj6 [Occ=Once] ww4_sgNj7 [Occ=Once] ->
                                      case
                                          Data.Complex.$w$c*
                                              w_sgNiY ww_sgNiZ ww1_sgNj0 ww_sgNiZ ww1_sgNj0
                                      of
                                      { (#,#) ww6_sgNj9 [Occ=Once] ww7_sgNja [Occ=Once] ->
                                            case
                                                Data.Complex.$w$c-
                                                    w_sgNiY ww3_sgNj6 ww4_sgNj7 ww6_sgNj9 ww7_sgNja
                                            of
                                            { (#,#) ww9_sgNjc [Occ=Once] ww10_sgNjd [Occ=Once] ->
                                                  case
                                                      Data.Complex.$w$csqrt
                                                          w_sgNiY ww9_sgNjc ww10_sgNjd
                                                  of
                                                  { (#,#) ww12_sgNjf [Occ=Once]
                                                          ww13_sgNjg [Occ=Once] ->
                                                        case
                                                            Data.Complex.$w$c+
                                                                w_sgNiY
                                                                dt_sgNj4
                                                                ww_sgNiZ
                                                                ww12_sgNjf
                                                                ww13_sgNjg
                                                        of
                                                        { (#,#) ww15_sgNji ww16_sgNjj ->
                                                              let {
                                                                sat_sgNjl [Occ=Once] :: a_sgxNq
                                                                [LclId] =
                                                                    [w_sgNiY
                                                                     ww15_sgNji
                                                                     ww16_sgNjj] \u []
                                                                        Data.Complex.$wmagnitude
                                                                            w_sgNiY
                                                                            ww15_sgNji
                                                                            ww16_sgNjj;
                                                              } in 
                                                                case
                                                                    GHC.Float.$p2RealFloat w_sgNiY
                                                                of
                                                                sat_sgNjk
                                                                { __DEFAULT ->
                                                                      case
                                                                          GHC.Float.log
                                                                              sat_sgNjk sat_sgNjl
                                                                      of
                                                                      dt1_sgNjm
                                                                      { __DEFAULT ->
                                                                            case
                                                                                Data.Complex.$wphase
                                                                                    w_sgNiY
                                                                                    ww15_sgNji
                                                                                    ww16_sgNjj
                                                                            of
                                                                            dt2_sgNjn
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      GHC.Num.negate
                                                                                          $dNum_sgNj3
                                                                                          dt1_sgNjm
                                                                                  of
                                                                                  dt3_sgNjo
                                                                                  { __DEFAULT ->
                                                                                        (#,#) [dt2_sgNjn
                                                                                               dt3_sgNjo];
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$casin [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNjp w1_sgNjq]
        case w1_sgNjq of {
          Data.Complex.:+ ww1_sgNjs [Occ=Once] ww2_sgNjt [Occ=Once] ->
              case Data.Complex.$w$casin w_sgNjp ww1_sgNjs ww2_sgNjt of {
                (#,#) ww4_sgNjv [Occ=Once] ww5_sgNjw [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNjv ww5_sgNjw];
              };
        };

Data.Complex.$w$s$catanh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float# -> (# GHC.Types.Float, GHC.Types.Float #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNjx ww1_sgNjy]
        case minusFloat# [0.0# ww1_sgNjy] of sat_sgNjB {
          __DEFAULT ->
              case minusFloat# [1.0# ww_sgNjx] of sat_sgNjA {
                __DEFAULT ->
                    case plusFloat# [1.0# ww_sgNjx] of sat_sgNjz {
                      __DEFAULT ->
                          case
                              Data.Complex.$w$s$c/1 sat_sgNjz ww1_sgNjy sat_sgNjA sat_sgNjB
                          of
                          { (#,#) ww3_sgNjD [Occ=Once!] ww4_sgNjE [Occ=Once!] ->
                                case ww3_sgNjD of {
                                  GHC.Types.F# ww6_sgNjG ->
                                      case ww4_sgNjE of {
                                        GHC.Types.F# ww8_sgNjI ->
                                            case
                                                Data.Complex.$w$smagnitude1 ww6_sgNjG ww8_sgNjI
                                            of
                                            ww9_sgNjJ
                                            { __DEFAULT ->
                                                  case logFloat# [ww9_sgNjJ] of wild1_sgNjK {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$sphase1
                                                                ww6_sgNjG ww8_sgNjI
                                                        of
                                                        ww10_sgNjL
                                                        { __DEFAULT ->
                                                              case
                                                                  timesFloat# [0.0# wild1_sgNjK]
                                                              of
                                                              sat_sgNjR
                                                              { __DEFAULT ->
                                                                    case
                                                                        timesFloat# [0.5#
                                                                                     ww10_sgNjL]
                                                                    of
                                                                    sat_sgNjQ
                                                                    { __DEFAULT ->
                                                                          case
                                                                              plusFloat# [sat_sgNjQ
                                                                                          sat_sgNjR]
                                                                          of
                                                                          sat_sgNjS
                                                                          { __DEFAULT ->
                                                                                let {
                                                                                  sat_sgNjT [Occ=Once]
                                                                                    :: GHC.Types.Float
                                                                                  [LclId] =
                                                                                      CCCS GHC.Types.F#! [sat_sgNjS];
                                                                                } in 
                                                                                  case
                                                                                      timesFloat# [0.0#
                                                                                                   ww10_sgNjL]
                                                                                  of
                                                                                  sat_sgNjN
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            timesFloat# [0.5#
                                                                                                         wild1_sgNjK]
                                                                                        of
                                                                                        sat_sgNjM
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  minusFloat# [sat_sgNjM
                                                                                                               sat_sgNjN]
                                                                                              of
                                                                                              sat_sgNjO
                                                                                              { __DEFAULT ->
                                                                                                    let {
                                                                                                      sat_sgNjP [Occ=Once]
                                                                                                        :: GHC.Types.Float
                                                                                                      [LclId] =
                                                                                                          CCCS GHC.Types.F#! [sat_sgNjO];
                                                                                                    } in 
                                                                                                      (#,#) [sat_sgNjP
                                                                                                             sat_sgNjT];
                                                                                              };
                                                                                        };
                                                                                  };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catanh1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNjU]
        case w_sgNjU of {
          Data.Complex.:+ ww1_sgNjW [Occ=Once!] ww2_sgNjX [Occ=Once!] ->
              case ww1_sgNjW of {
                GHC.Types.F# ww4_sgNjZ [Occ=Once] ->
                    case ww2_sgNjX of {
                      GHC.Types.F# ww6_sgNk1 [Occ=Once] ->
                          case Data.Complex.$w$s$catanh1 ww4_sgNjZ ww6_sgNk1 of {
                            (#,#) ww8_sgNk3 [Occ=Once] ww9_sgNk4 [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNk3 ww9_sgNk4];
                          };
                    };
              };
        };

Data.Complex.$w$s$catanh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double# -> (# GHC.Types.Double, GHC.Types.Double #)
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ww_sgNk5 ww1_sgNk6]
        case -## [0.0## ww1_sgNk6] of sat_sgNk9 {
          __DEFAULT ->
              case -## [1.0## ww_sgNk5] of sat_sgNk8 {
                __DEFAULT ->
                    case +## [1.0## ww_sgNk5] of sat_sgNk7 {
                      __DEFAULT ->
                          case
                              Data.Complex.$w$s$c/ sat_sgNk7 ww1_sgNk6 sat_sgNk8 sat_sgNk9
                          of
                          { (#,#) ww3_sgNkb [Occ=Once!] ww4_sgNkc [Occ=Once!] ->
                                case ww3_sgNkb of {
                                  GHC.Types.D# ww6_sgNke ->
                                      case ww4_sgNkc of {
                                        GHC.Types.D# ww8_sgNkg ->
                                            case
                                                Data.Complex.$w$smagnitude ww6_sgNke ww8_sgNkg
                                            of
                                            ww9_sgNkh
                                            { __DEFAULT ->
                                                  case logDouble# [ww9_sgNkh] of wild1_sgNki {
                                                    __DEFAULT ->
                                                        case
                                                            Data.Complex.$w$sphase
                                                                ww6_sgNke ww8_sgNkg
                                                        of
                                                        ww10_sgNkj
                                                        { __DEFAULT ->
                                                              case
                                                                  *## [0.0## wild1_sgNki]
                                                              of
                                                              sat_sgNkp
                                                              { __DEFAULT ->
                                                                    case
                                                                        *## [0.5## ww10_sgNkj]
                                                                    of
                                                                    sat_sgNko
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +## [sat_sgNko
                                                                                   sat_sgNkp]
                                                                          of
                                                                          sat_sgNkq
                                                                          { __DEFAULT ->
                                                                                let {
                                                                                  sat_sgNkr [Occ=Once]
                                                                                    :: GHC.Types.Double
                                                                                  [LclId] =
                                                                                      CCCS GHC.Types.D#! [sat_sgNkq];
                                                                                } in 
                                                                                  case
                                                                                      *## [0.0##
                                                                                           ww10_sgNkj]
                                                                                  of
                                                                                  sat_sgNkl
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            *## [0.5##
                                                                                                 wild1_sgNki]
                                                                                        of
                                                                                        sat_sgNkk
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  -## [sat_sgNkk
                                                                                                       sat_sgNkl]
                                                                                              of
                                                                                              sat_sgNkm
                                                                                              { __DEFAULT ->
                                                                                                    let {
                                                                                                      sat_sgNkn [Occ=Once]
                                                                                                        :: GHC.Types.Double
                                                                                                      [LclId] =
                                                                                                          CCCS GHC.Types.D#! [sat_sgNkm];
                                                                                                    } in 
                                                                                                      (#,#) [sat_sgNkn
                                                                                                             sat_sgNkr];
                                                                                              };
                                                                                        };
                                                                                  };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$catanh [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [w_sgNks]
        case w_sgNks of {
          Data.Complex.:+ ww1_sgNku [Occ=Once!] ww2_sgNkv [Occ=Once!] ->
              case ww1_sgNku of {
                GHC.Types.D# ww4_sgNkx [Occ=Once] ->
                    case ww2_sgNkv of {
                      GHC.Types.D# ww6_sgNkz [Occ=Once] ->
                          case Data.Complex.$w$s$catanh ww4_sgNkx ww6_sgNkz of {
                            (#,#) ww8_sgNkB [Occ=Once] ww9_sgNkC [Occ=Once] ->
                                Data.Complex.:+ [ww8_sgNkB ww9_sgNkC];
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex20
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [Data.Complex.$fFloatingComplex19
                                Data.Complex.$fFloatingComplex21];

Data.Complex.$fFloatingComplex18
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Real.:%! [Data.Complex.$fFloatingComplex19
                                Data.Complex.$fFloatingComplex19];

Data.Complex.$w$catanh [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Float.RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LC(S))LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNkD ww_sgNkE ww1_sgNkF]
        case
            Data.Complex.$w$cfromRational
                w_sgNkD Data.Complex.$fFloatingComplex20
        of
        { (#,#) ww3_sgNkH [Occ=Once] ww4_sgNkI [Occ=Once] ->
              case
                  Data.Complex.$w$cfromRational
                      w_sgNkD Data.Complex.$fFloatingComplex18
              of
              { (#,#) ww6_sgNkK ww7_sgNkL ->
                    case
                        Data.Complex.$w$c+ w_sgNkD ww6_sgNkK ww7_sgNkL ww_sgNkE ww1_sgNkF
                    of
                    { (#,#) ww9_sgNkN [Occ=Once] ww10_sgNkO [Occ=Once] ->
                          case
                              Data.Complex.$w$c- w_sgNkD ww6_sgNkK ww7_sgNkL ww_sgNkE ww1_sgNkF
                          of
                          { (#,#) ww12_sgNkQ [Occ=Once] ww13_sgNkR [Occ=Once] ->
                                case
                                    Data.Complex.$w$c/
                                        w_sgNkD ww9_sgNkN ww10_sgNkO ww12_sgNkQ ww13_sgNkR
                                of
                                { (#,#) ww15_sgNkT ww16_sgNkU ->
                                      let {
                                        sat_sgNkW [Occ=Once] :: a_sgxOH
                                        [LclId] =
                                            [w_sgNkD ww15_sgNkT ww16_sgNkU] \u []
                                                Data.Complex.$wmagnitude
                                                    w_sgNkD ww15_sgNkT ww16_sgNkU;
                                      } in 
                                        case GHC.Float.$p2RealFloat w_sgNkD of sat_sgNkV {
                                          __DEFAULT ->
                                              case GHC.Float.log sat_sgNkV sat_sgNkW of dt_sgNkX {
                                                __DEFAULT ->
                                                    case
                                                        Data.Complex.$wphase
                                                            w_sgNkD ww15_sgNkT ww16_sgNkU
                                                    of
                                                    dt1_sgNkY
                                                    { __DEFAULT ->
                                                          Data.Complex.$w$c*
                                                              w_sgNkD
                                                              ww3_sgNkH
                                                              ww4_sgNkI
                                                              dt_sgNkX
                                                              dt1_sgNkY;
                                                    };
                                              };
                                        };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$catanh [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LC(S))LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNkZ w1_sgNl0]
        case w1_sgNl0 of {
          Data.Complex.:+ ww1_sgNl2 [Occ=Once] ww2_sgNl3 [Occ=Once] ->
              case Data.Complex.$w$catanh w_sgNkZ ww1_sgNl2 ww2_sgNl3 of {
                (#,#) ww4_sgNl5 [Occ=Once] ww5_sgNl6 [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNl5 ww5_sgNl6];
              };
        };

Data.Complex.$fFloatingComplex_nan :: GHC.Types.Double
[GblId] =
    [] \u []
        case /## [0.0## 0.0##] of wild2_sgNl7 {
          __DEFAULT -> GHC.Types.D# [wild2_sgNl7];
        };

Data.Complex.$fFloatingComplex_inf :: GHC.Types.Double
[GblId] =
    [] \u []
        case /## [1.0## 0.0##] of wild2_sgNl8 {
          __DEFAULT -> GHC.Types.D# [wild2_sgNl8];
        };

Data.Complex.$fFloatingComplex6
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_nan
                                    Data.Complex.$fFloatingComplex_nan];

Data.Complex.$fFloatingComplex5
  :: Data.Complex.Complex GHC.Types.Double
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_nan of {
          GHC.Types.D# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex6;
        };

Data.Complex.$fFloatingComplex8
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_inf
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$fFloatingComplex7
  :: Data.Complex.Complex GHC.Types.Double
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_inf of {
          GHC.Types.D# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex8;
        };

Data.Complex.$fFloatingComplex3 :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.D#! [1.0##];

Data.Complex.$fFloatingComplex2
  :: Data.Complex.Complex GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex3
                                    Data.Complex.$fFloatingComplex1];

Data.Complex.$w$s$c** [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=3,
 Str=<L,1*U(U(U),U(U))><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNld ww_sgNle ww1_sgNlf]
        let-no-escape {
          fail_sgNlg [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Double
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [w_sgNld ww_sgNle ww1_sgNlf] \r [void_0E]
                  case w_sgNld of {
                    Data.Complex.:+ ds1_sgNlj [Occ=Once!] ds2_sgNlk [Occ=Once!] ->
                        case ds2_sgNlk of {
                          GHC.Types.D# ds4_sgNlm ->
                              case ds1_sgNlj of {
                                GHC.Types.D# ds6_sgNlo ->
                                    let-no-escape {
                                      fail1_sgNlp [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Double
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [ww_sgNle
                                                    ww1_sgNlf
                                                    ds4_sgNlm
                                                    ds6_sgNlo] \r [void_0E]
                                              case
                                                  __pkg_ccall base-4.11.0.0 [ds6_sgNlo
                                                                             GHC.Prim.realWorld#]
                                              of
                                              { Unit# ds9_sgNlu [Occ=Once!] ->
                                                    case ds9_sgNlu of {
                                                      __DEFAULT ->
                                                          case <## [ww_sgNle 0.0##] of {
                                                            __DEFAULT ->
                                                                case ==## [ww_sgNle 0.0##] of {
                                                                  __DEFAULT ->
                                                                      Data.Complex.$fFloatingComplex7;
                                                                  1# ->
                                                                      Data.Complex.$fFloatingComplex5;
                                                                };
                                                            1# -> Data.Complex.$fFloatingComplex4;
                                                          };
                                                      0# ->
                                                          case
                                                              __pkg_ccall base-4.11.0.0 [ds4_sgNlm
                                                                                         GHC.Prim.realWorld#]
                                                          of
                                                          { Unit# ds11_sgNlB [Occ=Once!] ->
                                                                case ds11_sgNlB of {
                                                                  __DEFAULT ->
                                                                      case <## [ww_sgNle 0.0##] of {
                                                                        __DEFAULT ->
                                                                            case
                                                                                ==## [ww_sgNle
                                                                                      0.0##]
                                                                            of
                                                                            { __DEFAULT ->
                                                                                  Data.Complex.$fFloatingComplex7;
                                                                              1# ->
                                                                                  Data.Complex.$fFloatingComplex5;
                                                                            };
                                                                        1# ->
                                                                            Data.Complex.$fFloatingComplex4;
                                                                      };
                                                                  0# ->
                                                                      case
                                                                          Data.Complex.$w$smagnitude
                                                                              ds6_sgNlo ds4_sgNlm
                                                                      of
                                                                      ww2_sgNlF
                                                                      { __DEFAULT ->
                                                                            case
                                                                                logDouble# [ww2_sgNlF]
                                                                            of
                                                                            wild5_sgNlG
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      Data.Complex.$w$sphase
                                                                                          ds6_sgNlo
                                                                                          ds4_sgNlm
                                                                                  of
                                                                                  ww3_sgNlH
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            *## [ww3_sgNlH
                                                                                                 ww_sgNle]
                                                                                        of
                                                                                        sat_sgNlK
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  *## [wild5_sgNlG
                                                                                                       ww1_sgNlf]
                                                                                              of
                                                                                              sat_sgNlJ
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        +## [sat_sgNlJ
                                                                                                             sat_sgNlK]
                                                                                                    of
                                                                                                    y_sgNlI
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              *## [ww3_sgNlH
                                                                                                                   ww1_sgNlf]
                                                                                                          of
                                                                                                          sat_sgNlN
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    *## [wild5_sgNlG
                                                                                                                         ww_sgNle]
                                                                                                                of
                                                                                                                sat_sgNlM
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          -## [sat_sgNlM
                                                                                                                               sat_sgNlN]
                                                                                                                      of
                                                                                                                      sat_sgNlO
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                expDouble# [sat_sgNlO]
                                                                                                                            of
                                                                                                                            expx_sgNlL
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sinDouble# [y_sgNlI]
                                                                                                                                  of
                                                                                                                                  sat_sgNlS
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            *## [expx_sgNlL
                                                                                                                                                 sat_sgNlS]
                                                                                                                                        of
                                                                                                                                        sat_sgNlT
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              let {
                                                                                                                                                sat_sgNlU [Occ=Once]
                                                                                                                                                  :: GHC.Types.Double
                                                                                                                                                [LclId] =
                                                                                                                                                    CCCS GHC.Types.D#! [sat_sgNlT];
                                                                                                                                              } in 
                                                                                                                                                case
                                                                                                                                                    cosDouble# [y_sgNlI]
                                                                                                                                                of
                                                                                                                                                sat_sgNlP
                                                                                                                                                { __DEFAULT ->
                                                                                                                                                      case
                                                                                                                                                          *## [expx_sgNlL
                                                                                                                                                               sat_sgNlP]
                                                                                                                                                      of
                                                                                                                                                      sat_sgNlQ
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgNlR [Occ=Once]
                                                                                                                                                                :: GHC.Types.Double
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.D#! [sat_sgNlQ];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgNlR
                                                                                                                                                                               sat_sgNlU];
                                                                                                                                                      };
                                                                                                                                                };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                    } in 
                                      case ==## [ds6_sgNlo 0.0##] of {
                                        __DEFAULT -> fail1_sgNlp GHC.Prim.void#;
                                        1# ->
                                            case ==## [ds4_sgNlm 0.0##] of {
                                              __DEFAULT -> fail1_sgNlp GHC.Prim.void#;
                                              1# ->
                                                  case <## [ww_sgNle 0.0##] of {
                                                    __DEFAULT ->
                                                        case ==## [ww_sgNle 0.0##] of {
                                                          __DEFAULT ->
                                                              Data.Complex.$fFloatingComplex4;
                                                          1# -> Data.Complex.$fFloatingComplex5;
                                                        };
                                                    1# -> Data.Complex.$fFloatingComplex7;
                                                  };
                                            };
                                      };
                              };
                        };
                  };
        } in 
          case ==## [ww_sgNle 0.0##] of {
            __DEFAULT -> fail_sgNlg GHC.Prim.void#;
            1# ->
                case ==## [ww1_sgNlf 0.0##] of {
                  __DEFAULT -> fail_sgNlg GHC.Prim.void#;
                  1# -> Data.Complex.$fFloatingComplex2;
                };
          };

Data.Complex.$fFloatingComplex_$s$c** [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Str=<L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>,
 Unf=OtherCon []] =
    [] \r [w_sgNm1 w1_sgNm2]
        case w1_sgNm2 of {
          Data.Complex.:+ ww1_sgNm4 [Occ=Once!] ww2_sgNm5 [Occ=Once!] ->
              case ww1_sgNm4 of {
                GHC.Types.D# ww4_sgNm7 [Occ=Once] ->
                    case ww2_sgNm5 of {
                      GHC.Types.D# ww6_sgNm9 [Occ=Once] ->
                          Data.Complex.$w$s$c** w_sgNm1 ww4_sgNm7 ww6_sgNm9;
                    };
              };
        };

Data.Complex.$fFloatingComplex_nan1 :: GHC.Types.Float
[GblId] =
    [] \u []
        case divideFloat# [0.0# 0.0#] of wild2_sgNma {
          __DEFAULT -> GHC.Types.F# [wild2_sgNma];
        };

Data.Complex.$fFloatingComplex_inf1 :: GHC.Types.Float
[GblId] =
    [] \u []
        case divideFloat# [1.0# 0.0#] of wild2_sgNmb {
          __DEFAULT -> GHC.Types.F# [wild2_sgNmb];
        };

Data.Complex.$fFloatingComplex14
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_nan1
                                    Data.Complex.$fFloatingComplex_nan1];

Data.Complex.$fFloatingComplex13
  :: Data.Complex.Complex GHC.Types.Float
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_nan1 of {
          GHC.Types.F# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex14;
        };

Data.Complex.$fFloatingComplex16
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex_inf1
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$fFloatingComplex15
  :: Data.Complex.Complex GHC.Types.Float
[GblId] =
    [] \u []
        case Data.Complex.$fFloatingComplex_inf1 of {
          GHC.Types.F# _ [Occ=Dead] -> Data.Complex.$fFloatingComplex16;
        };

Data.Complex.$fFloatingComplex11 :: GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.F#! [1.0#];

Data.Complex.$fFloatingComplex10
  :: Data.Complex.Complex GHC.Types.Float
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Complex.:+! [Data.Complex.$fFloatingComplex11
                                    Data.Complex.$fFloatingComplex9];

Data.Complex.$w$s$c**1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=3,
 Str=<L,1*U(U(U),U(U))><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNmg ww_sgNmh ww1_sgNmi]
        let-no-escape {
          fail_sgNmj [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
            :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Float
          [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
              sat-only [w_sgNmg ww_sgNmh ww1_sgNmi] \r [void_0E]
                  case w_sgNmg of {
                    Data.Complex.:+ ds1_sgNmm [Occ=Once!] ds2_sgNmn [Occ=Once!] ->
                        case ds2_sgNmn of {
                          GHC.Types.F# ds4_sgNmp ->
                              case ds1_sgNmm of {
                                GHC.Types.F# ds6_sgNmr ->
                                    let-no-escape {
                                      fail1_sgNms [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                        :: GHC.Prim.Void# -> Data.Complex.Complex GHC.Types.Float
                                      [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                          sat-only [ww_sgNmh
                                                    ww1_sgNmi
                                                    ds4_sgNmp
                                                    ds6_sgNmr] \r [void_0E]
                                              case
                                                  __pkg_ccall base-4.11.0.0 [ds6_sgNmr
                                                                             GHC.Prim.realWorld#]
                                              of
                                              { Unit# ds9_sgNmx [Occ=Once!] ->
                                                    case ds9_sgNmx of {
                                                      __DEFAULT ->
                                                          case ltFloat# [ww_sgNmh 0.0#] of {
                                                            __DEFAULT ->
                                                                case eqFloat# [ww_sgNmh 0.0#] of {
                                                                  __DEFAULT ->
                                                                      Data.Complex.$fFloatingComplex15;
                                                                  1# ->
                                                                      Data.Complex.$fFloatingComplex13;
                                                                };
                                                            1# -> Data.Complex.$fFloatingComplex12;
                                                          };
                                                      0# ->
                                                          case
                                                              __pkg_ccall base-4.11.0.0 [ds4_sgNmp
                                                                                         GHC.Prim.realWorld#]
                                                          of
                                                          { Unit# ds11_sgNmE [Occ=Once!] ->
                                                                case ds11_sgNmE of {
                                                                  __DEFAULT ->
                                                                      case
                                                                          ltFloat# [ww_sgNmh 0.0#]
                                                                      of
                                                                      { __DEFAULT ->
                                                                            case
                                                                                eqFloat# [ww_sgNmh
                                                                                          0.0#]
                                                                            of
                                                                            { __DEFAULT ->
                                                                                  Data.Complex.$fFloatingComplex15;
                                                                              1# ->
                                                                                  Data.Complex.$fFloatingComplex13;
                                                                            };
                                                                        1# ->
                                                                            Data.Complex.$fFloatingComplex12;
                                                                      };
                                                                  0# ->
                                                                      case
                                                                          Data.Complex.$w$smagnitude1
                                                                              ds6_sgNmr ds4_sgNmp
                                                                      of
                                                                      ww2_sgNmI
                                                                      { __DEFAULT ->
                                                                            case
                                                                                logFloat# [ww2_sgNmI]
                                                                            of
                                                                            wild5_sgNmJ
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      Data.Complex.$w$sphase1
                                                                                          ds6_sgNmr
                                                                                          ds4_sgNmp
                                                                                  of
                                                                                  ww3_sgNmK
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            timesFloat# [ww3_sgNmK
                                                                                                         ww_sgNmh]
                                                                                        of
                                                                                        sat_sgNmN
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  timesFloat# [wild5_sgNmJ
                                                                                                               ww1_sgNmi]
                                                                                              of
                                                                                              sat_sgNmM
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        plusFloat# [sat_sgNmM
                                                                                                                    sat_sgNmN]
                                                                                                    of
                                                                                                    y_sgNmL
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              timesFloat# [ww3_sgNmK
                                                                                                                           ww1_sgNmi]
                                                                                                          of
                                                                                                          sat_sgNmQ
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    timesFloat# [wild5_sgNmJ
                                                                                                                                 ww_sgNmh]
                                                                                                                of
                                                                                                                sat_sgNmP
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          minusFloat# [sat_sgNmP
                                                                                                                                       sat_sgNmQ]
                                                                                                                      of
                                                                                                                      sat_sgNmR
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                expFloat# [sat_sgNmR]
                                                                                                                            of
                                                                                                                            expx_sgNmO
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sinFloat# [y_sgNmL]
                                                                                                                                  of
                                                                                                                                  sat_sgNmV
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            timesFloat# [expx_sgNmO
                                                                                                                                                         sat_sgNmV]
                                                                                                                                        of
                                                                                                                                        sat_sgNmW
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              let {
                                                                                                                                                sat_sgNmX [Occ=Once]
                                                                                                                                                  :: GHC.Types.Float
                                                                                                                                                [LclId] =
                                                                                                                                                    CCCS GHC.Types.F#! [sat_sgNmW];
                                                                                                                                              } in 
                                                                                                                                                case
                                                                                                                                                    cosFloat# [y_sgNmL]
                                                                                                                                                of
                                                                                                                                                sat_sgNmS
                                                                                                                                                { __DEFAULT ->
                                                                                                                                                      case
                                                                                                                                                          timesFloat# [expx_sgNmO
                                                                                                                                                                       sat_sgNmS]
                                                                                                                                                      of
                                                                                                                                                      sat_sgNmT
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgNmU [Occ=Once]
                                                                                                                                                                :: GHC.Types.Float
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.F#! [sat_sgNmT];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgNmU
                                                                                                                                                                               sat_sgNmX];
                                                                                                                                                      };
                                                                                                                                                };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                    } in 
                                      case eqFloat# [ds6_sgNmr 0.0#] of {
                                        __DEFAULT -> fail1_sgNms GHC.Prim.void#;
                                        1# ->
                                            case eqFloat# [ds4_sgNmp 0.0#] of {
                                              __DEFAULT -> fail1_sgNms GHC.Prim.void#;
                                              1# ->
                                                  case ltFloat# [ww_sgNmh 0.0#] of {
                                                    __DEFAULT ->
                                                        case eqFloat# [ww_sgNmh 0.0#] of {
                                                          __DEFAULT ->
                                                              Data.Complex.$fFloatingComplex12;
                                                          1# -> Data.Complex.$fFloatingComplex13;
                                                        };
                                                    1# -> Data.Complex.$fFloatingComplex15;
                                                  };
                                            };
                                      };
                              };
                        };
                  };
        } in 
          case eqFloat# [ww_sgNmh 0.0#] of {
            __DEFAULT -> fail_sgNmj GHC.Prim.void#;
            1# ->
                case eqFloat# [ww1_sgNmi 0.0#] of {
                  __DEFAULT -> fail_sgNmj GHC.Prim.void#;
                  1# -> Data.Complex.$fFloatingComplex10;
                };
          };

Data.Complex.$fFloatingComplex_$s$c**1 [InlPrag=NOUSERINLINE[0]]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Str=<L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>,
 Unf=OtherCon []] =
    [] \r [w_sgNn4 w1_sgNn5]
        case w1_sgNn5 of {
          Data.Complex.:+ ww1_sgNn7 [Occ=Once!] ww2_sgNn8 [Occ=Once!] ->
              case ww1_sgNn7 of {
                GHC.Types.F# ww4_sgNna [Occ=Once] ->
                    case ww2_sgNn8 of {
                      GHC.Types.F# ww6_sgNnc [Occ=Once] ->
                          Data.Complex.$w$s$c**1 w_sgNn4 ww4_sgNna ww6_sgNnc;
                    };
              };
        };

Data.Complex.$w$c** [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> a -> a -> (# a, a #)
[GblId,
 Arity=4,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))><L,1*U(U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgNnd w1_sgNne ww_sgNnf ww1_sgNng]
        case
            GHC.Float.$p1RealFloat w_sgNnd
        of
        $dRealFrac_sgNnh [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_sgNnh
              of
              $dReal_sgNni [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p2Real $dReal_sgNni
                    of
                    $dOrd_sgNnj [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A)>]
                    { __DEFAULT ->
                          case
                              GHC.Classes.$p1Ord $dOrd_sgNnj
                          of
                          $dEq_sgNnk [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                          { __DEFAULT ->
                                let {
                                  $dNum_sgNnl [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_sgxPv
                                  [LclId] =
                                      [$dReal_sgNni] \u [] GHC.Real.$p1Real $dReal_sgNni; } in
                                let {
                                  sat_sgNnZ [Occ=Once] :: a_sgxPv
                                  [LclId] =
                                      [$dNum_sgNnl] \u []
                                          GHC.Num.fromInteger
                                              $dNum_sgNnl Data.Complex.$fFloatingComplex17;
                                } in 
                                  let-no-escape {
                                    fail_sgNnm [Occ=Once*!T[1], Dmd=<L,1*C1(U(U,U))>]
                                      :: GHC.Prim.Void# -> (# a_sgxPv, a_sgxPv #)
                                    [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
                                        sat-only [w_sgNnd
                                                  w1_sgNne
                                                  ww_sgNnf
                                                  ww1_sgNng
                                                  $dRealFrac_sgNnh
                                                  $dOrd_sgNnj
                                                  $dEq_sgNnk
                                                  $dNum_sgNnl] \r [void_0E]
                                            case w1_sgNne of {
                                              Data.Complex.:+ ds1_sgNnp ds2_sgNnq ->
                                                  let {
                                                    $dFractional_sgNnr [Dmd=<L,U(A,C(C1(U)),A,A)>]
                                                      :: GHC.Real.Fractional a_sgxPv
                                                    [LclId] =
                                                        [$dRealFrac_sgNnh] \u []
                                                            GHC.Real.$p2RealFrac
                                                                $dRealFrac_sgNnh; } in
                                                  let {
                                                    nan_sgNns [Dmd=<L,1*U>] :: a_sgxPv
                                                    [LclId] =
                                                        [$dNum_sgNnl $dFractional_sgNnr] \s []
                                                            let {
                                                              sat_sgNnu [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgNnl] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgNnl
                                                                          Data.Complex.$fFloatingComplex17; } in
                                                            let {
                                                              sat_sgNnt [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgNnl] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgNnl
                                                                          Data.Complex.$fFloatingComplex17;
                                                            } in 
                                                              GHC.Real./
                                                                  $dFractional_sgNnr
                                                                  sat_sgNnt
                                                                  sat_sgNnu; } in
                                                  let {
                                                    inf_sgNnv [Dmd=<L,1*U>] :: a_sgxPv
                                                    [LclId] =
                                                        [$dNum_sgNnl $dFractional_sgNnr] \s []
                                                            let {
                                                              sat_sgNnx [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgNnl] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgNnl
                                                                          Data.Complex.$fFloatingComplex17; } in
                                                            let {
                                                              sat_sgNnw [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgNnl] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgNnl
                                                                          Data.Complex.$fFloatingComplex19;
                                                            } in 
                                                              GHC.Real./
                                                                  $dFractional_sgNnr
                                                                  sat_sgNnw
                                                                  sat_sgNnx; } in
                                                  let {
                                                    sat_sgNnP [Occ=Once] :: a_sgxPv
                                                    [LclId] =
                                                        [$dNum_sgNnl] \u []
                                                            GHC.Num.fromInteger
                                                                $dNum_sgNnl
                                                                Data.Complex.$fFloatingComplex17;
                                                  } in 
                                                    let-no-escape {
                                                      fail1_sgNny [Occ=Once*!T[1],
                                                                   Dmd=<L,1*C1(U(U,U))>]
                                                        :: GHC.Prim.Void# -> (# a_sgxPv, a_sgxPv #)
                                                      [LclId[JoinId(1)],
                                                       Arity=1,
                                                       Str=<L,A>,
                                                       Unf=OtherCon []] =
                                                          sat-only [w_sgNnd
                                                                    ww_sgNnf
                                                                    ww1_sgNng
                                                                    $dOrd_sgNnj
                                                                    $dNum_sgNnl
                                                                    ds1_sgNnp
                                                                    ds2_sgNnq
                                                                    nan_sgNns
                                                                    inf_sgNnv] \r [void_0E]
                                                              let-no-escape {
                                                                $j_sgNnA [Occ=Once*T[0],
                                                                          Dmd=<L,1*U(U,U)>]
                                                                  :: (# a_sgxPv, a_sgxPv #)
                                                                [LclId[JoinId(0)],
                                                                 Unf=OtherCon []] =
                                                                    [ww_sgNnf
                                                                     $dOrd_sgNnj
                                                                     $dNum_sgNnl
                                                                     nan_sgNns
                                                                     inf_sgNnv] \r []
                                                                        let {
                                                                          sat_sgNnB [Occ=Once]
                                                                            :: a_sgxPv
                                                                          [LclId] =
                                                                              [$dNum_sgNnl] \u []
                                                                                  GHC.Num.fromInteger
                                                                                      $dNum_sgNnl
                                                                                      Data.Complex.$fFloatingComplex17;
                                                                        } in 
                                                                          case
                                                                              GHC.Classes.compare
                                                                                  $dOrd_sgNnj
                                                                                  ww_sgNnf
                                                                                  sat_sgNnB
                                                                          of
                                                                          { GHC.Types.LT ->
                                                                                case
                                                                                    GHC.Num.fromInteger
                                                                                        $dNum_sgNnl
                                                                                        Data.Complex.$fFloatingComplex17
                                                                                of
                                                                                dt_sgNnD
                                                                                { __DEFAULT ->
                                                                                      (#,#) [dt_sgNnD
                                                                                             dt_sgNnD];
                                                                                };
                                                                            GHC.Types.EQ ->
                                                                                case
                                                                                    nan_sgNns
                                                                                of
                                                                                dt_sgNnE
                                                                                { __DEFAULT ->
                                                                                      (#,#) [dt_sgNnE
                                                                                             dt_sgNnE];
                                                                                };
                                                                            GHC.Types.GT ->
                                                                                case
                                                                                    inf_sgNnv
                                                                                of
                                                                                dt_sgNnF
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          GHC.Num.fromInteger
                                                                                              $dNum_sgNnl
                                                                                              Data.Complex.$fFloatingComplex17
                                                                                      of
                                                                                      dt1_sgNnG
                                                                                      { __DEFAULT ->
                                                                                            (#,#) [dt_sgNnF
                                                                                                   dt1_sgNnG];
                                                                                      };
                                                                                };
                                                                          };
                                                              } in 
                                                                case
                                                                    GHC.Float.isInfinite
                                                                        w_sgNnd ds1_sgNnp
                                                                of
                                                                { GHC.Types.False ->
                                                                      case
                                                                          GHC.Float.isInfinite
                                                                              w_sgNnd ds2_sgNnq
                                                                      of
                                                                      { GHC.Types.False ->
                                                                            case
                                                                                Data.Complex.$w$clog
                                                                                    w_sgNnd
                                                                                    ds1_sgNnp
                                                                                    ds2_sgNnq
                                                                            of
                                                                            { (#,#) ww3_sgNnK [Occ=Once]
                                                                                    ww4_sgNnL [Occ=Once] ->
                                                                                  case
                                                                                      Data.Complex.$w$c*
                                                                                          w_sgNnd
                                                                                          ww3_sgNnK
                                                                                          ww4_sgNnL
                                                                                          ww_sgNnf
                                                                                          ww1_sgNng
                                                                                  of
                                                                                  { (#,#) ww6_sgNnN [Occ=Once]
                                                                                          ww7_sgNnO [Occ=Once] ->
                                                                                        Data.Complex.$w$cexp
                                                                                            w_sgNnd
                                                                                            ww6_sgNnN
                                                                                            ww7_sgNnO;
                                                                                  };
                                                                            };
                                                                        GHC.Types.True -> $j_sgNnA;
                                                                      };
                                                                  GHC.Types.True -> $j_sgNnA;
                                                                };
                                                    } in 
                                                      case
                                                          GHC.Classes.==
                                                              $dEq_sgNnk ds1_sgNnp sat_sgNnP
                                                      of
                                                      { GHC.Types.False ->
                                                            fail1_sgNny GHC.Prim.void#;
                                                        GHC.Types.True ->
                                                            let {
                                                              sat_sgNnR [Occ=Once] :: a_sgxPv
                                                              [LclId] =
                                                                  [$dNum_sgNnl] \u []
                                                                      GHC.Num.fromInteger
                                                                          $dNum_sgNnl
                                                                          Data.Complex.$fFloatingComplex17;
                                                            } in 
                                                              case
                                                                  GHC.Classes.==
                                                                      $dEq_sgNnk ds2_sgNnq sat_sgNnR
                                                              of
                                                              { GHC.Types.False ->
                                                                    fail1_sgNny GHC.Prim.void#;
                                                                GHC.Types.True ->
                                                                    let {
                                                                      sat_sgNnT [Occ=Once]
                                                                        :: a_sgxPv
                                                                      [LclId] =
                                                                          [$dNum_sgNnl] \u []
                                                                              GHC.Num.fromInteger
                                                                                  $dNum_sgNnl
                                                                                  Data.Complex.$fFloatingComplex17;
                                                                    } in 
                                                                      case
                                                                          GHC.Classes.compare
                                                                              $dOrd_sgNnj
                                                                              ww_sgNnf
                                                                              sat_sgNnT
                                                                      of
                                                                      { GHC.Types.LT ->
                                                                            case
                                                                                inf_sgNnv
                                                                            of
                                                                            dt_sgNnV
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      GHC.Num.fromInteger
                                                                                          $dNum_sgNnl
                                                                                          Data.Complex.$fFloatingComplex17
                                                                                  of
                                                                                  dt1_sgNnW
                                                                                  { __DEFAULT ->
                                                                                        (#,#) [dt_sgNnV
                                                                                               dt1_sgNnW];
                                                                                  };
                                                                            };
                                                                        GHC.Types.EQ ->
                                                                            case
                                                                                nan_sgNns
                                                                            of
                                                                            dt_sgNnX
                                                                            { __DEFAULT ->
                                                                                  (#,#) [dt_sgNnX
                                                                                         dt_sgNnX];
                                                                            };
                                                                        GHC.Types.GT ->
                                                                            case
                                                                                GHC.Num.fromInteger
                                                                                    $dNum_sgNnl
                                                                                    Data.Complex.$fFloatingComplex17
                                                                            of
                                                                            dt_sgNnY
                                                                            { __DEFAULT ->
                                                                                  (#,#) [dt_sgNnY
                                                                                         dt_sgNnY];
                                                                            };
                                                                      };
                                                              };
                                                      };
                                            };
                                  } in 
                                    case GHC.Classes.== $dEq_sgNnk ww_sgNnf sat_sgNnZ of {
                                      GHC.Types.False -> fail_sgNnm GHC.Prim.void#;
                                      GHC.Types.True ->
                                          let {
                                            sat_sgNo1 [Occ=Once] :: a_sgxPv
                                            [LclId] =
                                                [$dNum_sgNnl] \u []
                                                    GHC.Num.fromInteger
                                                        $dNum_sgNnl
                                                        Data.Complex.$fFloatingComplex17;
                                          } in 
                                            case GHC.Classes.== $dEq_sgNnk ww1_sgNng sat_sgNo1 of {
                                              GHC.Types.False -> fail_sgNnm GHC.Prim.void#;
                                              GHC.Types.True ->
                                                  case
                                                      GHC.Num.fromInteger
                                                          $dNum_sgNnl
                                                          Data.Complex.$fFloatingComplex19
                                                  of
                                                  dt_sgNo3
                                                  { __DEFAULT ->
                                                        case
                                                            GHC.Num.fromInteger
                                                                $dNum_sgNnl
                                                                Data.Complex.$fFloatingComplex17
                                                        of
                                                        dt1_sgNo4
                                                        { __DEFAULT -> (#,#) [dt_sgNo3 dt1_sgNo4];
                                                        };
                                                  };
                                            };
                                    };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$c** [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))><L,1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgNo5 w1_sgNo6 w2_sgNo7]
        case w2_sgNo7 of {
          Data.Complex.:+ ww1_sgNo9 [Occ=Once] ww2_sgNoa [Occ=Once] ->
              case Data.Complex.$w$c** w_sgNo5 w1_sgNo6 ww1_sgNo9 ww2_sgNoa of {
                (#,#) ww4_sgNoc [Occ=Once] ww5_sgNod [Occ=Once] ->
                    Data.Complex.:+ [ww4_sgNoc ww5_sgNod];
              };
        };

Data.Complex.$fFloatingComplex_$s$cexpm2 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNoe]
        case eta_sgNoe of {
          Data.Complex.:+ a_sgNog [Occ=Once!] b_sgNoh [Occ=Once!] ->
              case a_sgNog of {
                GHC.Types.F# x_sgNoj ->
                    case b_sgNoh of {
                      GHC.Types.F# x1_sgNol ->
                          case timesFloat# [x1_sgNol x1_sgNol] of sat_sgNon {
                            __DEFAULT ->
                                case timesFloat# [x_sgNoj x_sgNoj] of sat_sgNom {
                                  __DEFAULT ->
                                      case plusFloat# [sat_sgNom sat_sgNon] of sat_sgNoo {
                                        __DEFAULT ->
                                            case ltFloat# [sat_sgNoo 1.0#] of {
                                              __DEFAULT ->
                                                  case expFloat# [x_sgNoj] of expx_sgNoq {
                                                    __DEFAULT ->
                                                        case sinFloat# [x1_sgNol] of sat_sgNov {
                                                          __DEFAULT ->
                                                              case
                                                                  timesFloat# [expx_sgNoq sat_sgNov]
                                                              of
                                                              sat_sgNow
                                                              { __DEFAULT ->
                                                                    let {
                                                                      sat_sgNox [Occ=Once]
                                                                        :: GHC.Types.Float
                                                                      [LclId] =
                                                                          CCCS GHC.Types.F#! [sat_sgNow];
                                                                    } in 
                                                                      case
                                                                          cosFloat# [x1_sgNol]
                                                                      of
                                                                      sat_sgNor
                                                                      { __DEFAULT ->
                                                                            case
                                                                                timesFloat# [expx_sgNoq
                                                                                             sat_sgNor]
                                                                            of
                                                                            sat_sgNos
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      minusFloat# [sat_sgNos
                                                                                                   1.0#]
                                                                                  of
                                                                                  sat_sgNot
                                                                                  { __DEFAULT ->
                                                                                        let {
                                                                                          sat_sgNou [Occ=Once]
                                                                                            :: GHC.Types.Float
                                                                                          [LclId] =
                                                                                              CCCS GHC.Types.F#! [sat_sgNot];
                                                                                        } in 
                                                                                          Data.Complex.:+ [sat_sgNou
                                                                                                           sat_sgNox];
                                                                                  };
                                                                            };
                                                                      };
                                                              };
                                                        };
                                                  };
                                              1# ->
                                                  case
                                                      __pkg_ccall base-4.11.0.0 [x_sgNoj
                                                                                 GHC.Prim.realWorld#]
                                                  of
                                                  { Unit# ds4_sgNoB ->
                                                        case
                                                            divideFloat# [x1_sgNol 2.0#]
                                                        of
                                                        sat_sgNoD
                                                        { __DEFAULT ->
                                                              case
                                                                  sinFloat# [sat_sgNoD]
                                                              of
                                                              v_sgNoC [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        plusFloat# [v_sgNoC v_sgNoC]
                                                                    of
                                                                    sat_sgNoF
                                                                    { __DEFAULT ->
                                                                          case
                                                                              timesFloat# [sat_sgNoF
                                                                                           v_sgNoC]
                                                                          of
                                                                          sat_sgNoG
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateFloat# [sat_sgNoG]
                                                                                of
                                                                                w_sgNoE
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          sinFloat# [x1_sgNol]
                                                                                      of
                                                                                      sat_sgNoM
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                plusFloat# [ds4_sgNoB
                                                                                                            1.0#]
                                                                                            of
                                                                                            sat_sgNoL
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      timesFloat# [sat_sgNoL
                                                                                                                   sat_sgNoM]
                                                                                                  of
                                                                                                  sat_sgNoN
                                                                                                  { __DEFAULT ->
                                                                                                        let {
                                                                                                          sat_sgNoO [Occ=Once]
                                                                                                            :: GHC.Types.Float
                                                                                                          [LclId] =
                                                                                                              CCCS GHC.Types.F#! [sat_sgNoN];
                                                                                                        } in 
                                                                                                          case
                                                                                                              timesFloat# [ds4_sgNoB
                                                                                                                           w_sgNoE]
                                                                                                          of
                                                                                                          sat_sgNoH
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    plusFloat# [sat_sgNoH
                                                                                                                                ds4_sgNoB]
                                                                                                                of
                                                                                                                sat_sgNoI
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          plusFloat# [sat_sgNoI
                                                                                                                                      w_sgNoE]
                                                                                                                      of
                                                                                                                      sat_sgNoJ
                                                                                                                      { __DEFAULT ->
                                                                                                                            let {
                                                                                                                              sat_sgNoK [Occ=Once]
                                                                                                                                :: GHC.Types.Float
                                                                                                                              [LclId] =
                                                                                                                                  CCCS GHC.Types.F#! [sat_sgNoJ];
                                                                                                                            } in 
                                                                                                                              Data.Complex.:+ [sat_sgNoK
                                                                                                                                               sat_sgNoO];
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNoP]
        case eta_sgNoP of {
          Data.Complex.:+ a_sgNoR [Occ=Once!] b_sgNoS [Occ=Once!] ->
              case a_sgNoR of {
                GHC.Types.D# x_sgNoU ->
                    case b_sgNoS of {
                      GHC.Types.D# x1_sgNoW ->
                          case *## [x1_sgNoW x1_sgNoW] of sat_sgNoY {
                            __DEFAULT ->
                                case *## [x_sgNoU x_sgNoU] of sat_sgNoX {
                                  __DEFAULT ->
                                      case +## [sat_sgNoX sat_sgNoY] of sat_sgNoZ {
                                        __DEFAULT ->
                                            case <## [sat_sgNoZ 1.0##] of {
                                              __DEFAULT ->
                                                  case expDouble# [x_sgNoU] of expx_sgNp1 {
                                                    __DEFAULT ->
                                                        case sinDouble# [x1_sgNoW] of sat_sgNp6 {
                                                          __DEFAULT ->
                                                              case
                                                                  *## [expx_sgNp1 sat_sgNp6]
                                                              of
                                                              sat_sgNp7
                                                              { __DEFAULT ->
                                                                    let {
                                                                      sat_sgNp8 [Occ=Once]
                                                                        :: GHC.Types.Double
                                                                      [LclId] =
                                                                          CCCS GHC.Types.D#! [sat_sgNp7];
                                                                    } in 
                                                                      case
                                                                          cosDouble# [x1_sgNoW]
                                                                      of
                                                                      sat_sgNp2
                                                                      { __DEFAULT ->
                                                                            case
                                                                                *## [expx_sgNp1
                                                                                     sat_sgNp2]
                                                                            of
                                                                            sat_sgNp3
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      -## [sat_sgNp3
                                                                                           1.0##]
                                                                                  of
                                                                                  sat_sgNp4
                                                                                  { __DEFAULT ->
                                                                                        let {
                                                                                          sat_sgNp5 [Occ=Once]
                                                                                            :: GHC.Types.Double
                                                                                          [LclId] =
                                                                                              CCCS GHC.Types.D#! [sat_sgNp4];
                                                                                        } in 
                                                                                          Data.Complex.:+ [sat_sgNp5
                                                                                                           sat_sgNp8];
                                                                                  };
                                                                            };
                                                                      };
                                                              };
                                                        };
                                                  };
                                              1# ->
                                                  case
                                                      __pkg_ccall base-4.11.0.0 [x_sgNoU
                                                                                 GHC.Prim.realWorld#]
                                                  of
                                                  { Unit# ds4_sgNpc ->
                                                        case /## [x1_sgNoW 2.0##] of sat_sgNpe {
                                                          __DEFAULT ->
                                                              case
                                                                  sinDouble# [sat_sgNpe]
                                                              of
                                                              v_sgNpd [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        +## [v_sgNpd v_sgNpd]
                                                                    of
                                                                    sat_sgNpg
                                                                    { __DEFAULT ->
                                                                          case
                                                                              *## [sat_sgNpg
                                                                                   v_sgNpd]
                                                                          of
                                                                          sat_sgNph
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    negateDouble# [sat_sgNph]
                                                                                of
                                                                                w_sgNpf
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          sinDouble# [x1_sgNoW]
                                                                                      of
                                                                                      sat_sgNpn
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                +## [ds4_sgNpc
                                                                                                     1.0##]
                                                                                            of
                                                                                            sat_sgNpm
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      *## [sat_sgNpm
                                                                                                           sat_sgNpn]
                                                                                                  of
                                                                                                  sat_sgNpo
                                                                                                  { __DEFAULT ->
                                                                                                        let {
                                                                                                          sat_sgNpp [Occ=Once]
                                                                                                            :: GHC.Types.Double
                                                                                                          [LclId] =
                                                                                                              CCCS GHC.Types.D#! [sat_sgNpo];
                                                                                                        } in 
                                                                                                          case
                                                                                                              *## [ds4_sgNpc
                                                                                                                   w_sgNpf]
                                                                                                          of
                                                                                                          sat_sgNpi
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    +## [sat_sgNpi
                                                                                                                         ds4_sgNpc]
                                                                                                                of
                                                                                                                sat_sgNpj
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          +## [sat_sgNpj
                                                                                                                               w_sgNpf]
                                                                                                                      of
                                                                                                                      sat_sgNpk
                                                                                                                      { __DEFAULT ->
                                                                                                                            let {
                                                                                                                              sat_sgNpl [Occ=Once]
                                                                                                                                :: GHC.Types.Double
                                                                                                                              [LclId] =
                                                                                                                                  CCCS GHC.Types.D#! [sat_sgNpk];
                                                                                                                            } in 
                                                                                                                              Data.Complex.:+ [sat_sgNpl
                                                                                                                                               sat_sgNpp];
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                  };
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(LLC(C(S))LLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgNpq eta_sgNpr]
        case eta_sgNpr of {
          Data.Complex.:+ a1_sgNpt b_sgNpu ->
              case
                  GHC.Float.$p1RealFloat $dRealFloat_sgNpq
              of
              $dRealFrac_sgNpv [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1RealFrac $dRealFrac_sgNpv
                    of
                    $dReal_sgNpw [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
                    { __DEFAULT ->
                          let {
                            $dNum_sgNpx [Dmd=<L,U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U))>]
                              :: GHC.Num.Num a_agsO1
                            [LclId] =
                                [$dReal_sgNpw] \u [] GHC.Real.$p1Real $dReal_sgNpw; } in
                          let {
                            sat_sgNpC [Occ=Once] :: a_agsO1
                            [LclId] =
                                [$dNum_sgNpx] \u []
                                    GHC.Num.fromInteger
                                        $dNum_sgNpx Data.Complex.$fFloatingComplex19; } in
                          let {
                            sat_sgNpB [Occ=Once] :: a_agsO1
                            [LclId] =
                                [a1_sgNpt b_sgNpu $dNum_sgNpx] \u []
                                    let {
                                      sat_sgNpA [Occ=Once] :: a_agsO1
                                      [LclId] =
                                          [b_sgNpu $dNum_sgNpx] \u []
                                              GHC.Num.* $dNum_sgNpx b_sgNpu b_sgNpu; } in
                                    let {
                                      sat_sgNpz [Occ=Once] :: a_agsO1
                                      [LclId] =
                                          [a1_sgNpt $dNum_sgNpx] \u []
                                              GHC.Num.* $dNum_sgNpx a1_sgNpt a1_sgNpt;
                                    } in  GHC.Num.+ $dNum_sgNpx sat_sgNpz sat_sgNpA;
                          } in 
                            case GHC.Real.$p2Real $dReal_sgNpw of sat_sgNpy {
                              __DEFAULT ->
                                  case GHC.Classes.< sat_sgNpy sat_sgNpB sat_sgNpC of {
                                    GHC.Types.False ->
                                        case
                                            Data.Complex.$w$cexp $dRealFloat_sgNpq a1_sgNpt b_sgNpu
                                        of
                                        { (#,#) ww1_sgNpF [Occ=Once] ww2_sgNpG [Occ=Once] ->
                                              case
                                                  Data.Complex.$w$cfromInteger
                                                      $dRealFloat_sgNpq
                                                      Data.Complex.$fFloatingComplex19
                                              of
                                              { (#,#) ww4_sgNpI [Occ=Once] ww5_sgNpJ [Occ=Once] ->
                                                    case
                                                        Data.Complex.$w$c-
                                                            $dRealFloat_sgNpq
                                                            ww1_sgNpF
                                                            ww2_sgNpG
                                                            ww4_sgNpI
                                                            ww5_sgNpJ
                                                    of
                                                    { (#,#) ww7_sgNpL [Occ=Once]
                                                            ww8_sgNpM [Occ=Once] ->
                                                          Data.Complex.:+ [ww7_sgNpL ww8_sgNpM];
                                                    };
                                              };
                                        };
                                    GHC.Types.True ->
                                        let {
                                          $dFloating_sgNpN [Dmd=<L,U(A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A)>]
                                            :: GHC.Float.Floating a_agsO1
                                          [LclId] =
                                              [$dRealFloat_sgNpq] \u []
                                                  GHC.Float.$p2RealFloat $dRealFloat_sgNpq; } in
                                        let {
                                          u_sgNpO :: a_agsO1
                                          [LclId] =
                                              [a1_sgNpt $dFloating_sgNpN] \u []
                                                  GHC.Float.expm1 $dFloating_sgNpN a1_sgNpt; } in
                                        let {
                                          w_sgNpP :: a_agsO1
                                          [LclId] =
                                              [b_sgNpu
                                               $dRealFrac_sgNpv
                                               $dNum_sgNpx
                                               $dFloating_sgNpN] \u []
                                                  let {
                                                    sat_sgNpW [Occ=Once] :: a_agsO1
                                                    [LclId] =
                                                        [b_sgNpu
                                                         $dRealFrac_sgNpv
                                                         $dNum_sgNpx
                                                         $dFloating_sgNpN] \u []
                                                            let {
                                                              v_sgNpQ :: a_agsO1
                                                              [LclId] =
                                                                  [b_sgNpu
                                                                   $dRealFrac_sgNpv
                                                                   $dNum_sgNpx
                                                                   $dFloating_sgNpN] \u []
                                                                      let {
                                                                        sat_sgNpT [Occ=Once]
                                                                          :: a_agsO1
                                                                        [LclId] =
                                                                            [b_sgNpu
                                                                             $dRealFrac_sgNpv
                                                                             $dNum_sgNpx] \u []
                                                                                let {
                                                                                  sat_sgNpS [Occ=Once]
                                                                                    :: a_agsO1
                                                                                  [LclId] =
                                                                                      [$dNum_sgNpx] \u []
                                                                                          GHC.Num.fromInteger
                                                                                              $dNum_sgNpx
                                                                                              Data.Complex.$fFloatingComplex21;
                                                                                } in 
                                                                                  case
                                                                                      GHC.Real.$p2RealFrac
                                                                                          $dRealFrac_sgNpv
                                                                                  of
                                                                                  sat_sgNpR
                                                                                  { __DEFAULT ->
                                                                                        GHC.Real./
                                                                                            sat_sgNpR
                                                                                            b_sgNpu
                                                                                            sat_sgNpS;
                                                                                  };
                                                                      } in 
                                                                        GHC.Float.sin
                                                                            $dFloating_sgNpN
                                                                            sat_sgNpT; } in
                                                            let {
                                                              sat_sgNpV [Occ=Once] :: a_agsO1
                                                              [LclId] =
                                                                  [$dNum_sgNpx v_sgNpQ] \u []
                                                                      let {
                                                                        sat_sgNpU [Occ=Once]
                                                                          :: a_agsO1
                                                                        [LclId] =
                                                                            [$dNum_sgNpx] \u []
                                                                                GHC.Num.fromInteger
                                                                                    $dNum_sgNpx
                                                                                    Data.Complex.$fFloatingComplex21;
                                                                      } in 
                                                                        GHC.Num.*
                                                                            $dNum_sgNpx
                                                                            sat_sgNpU
                                                                            v_sgNpQ;
                                                            } in 
                                                              GHC.Num.*
                                                                  $dNum_sgNpx sat_sgNpV v_sgNpQ;
                                                  } in  GHC.Num.negate $dNum_sgNpx sat_sgNpW; } in
                                        let {
                                          sat_sgNpY [Occ=Once] :: a_agsO1
                                          [LclId] =
                                              [$dNum_sgNpx u_sgNpO w_sgNpP] \u []
                                                  let {
                                                    sat_sgNpX [Occ=Once] :: a_agsO1
                                                    [LclId] =
                                                        [$dNum_sgNpx u_sgNpO w_sgNpP] \u []
                                                            GHC.Num.* $dNum_sgNpx u_sgNpO w_sgNpP;
                                                  } in  GHC.Num.+ $dNum_sgNpx sat_sgNpX u_sgNpO;
                                        } in 
                                          case GHC.Num.+ $dNum_sgNpx sat_sgNpY w_sgNpP of dt_sgNpZ {
                                            __DEFAULT ->
                                                let {
                                                  sat_sgNq2 [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [b_sgNpu $dFloating_sgNpN] \u []
                                                          GHC.Float.sin
                                                              $dFloating_sgNpN b_sgNpu; } in
                                                let {
                                                  sat_sgNq1 [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [$dNum_sgNpx u_sgNpO] \u []
                                                          let {
                                                            sat_sgNq0 [Occ=Once] :: a_agsO1
                                                            [LclId] =
                                                                [$dNum_sgNpx] \u []
                                                                    GHC.Num.fromInteger
                                                                        $dNum_sgNpx
                                                                        Data.Complex.$fFloatingComplex19;
                                                          } in 
                                                            GHC.Num.+ $dNum_sgNpx u_sgNpO sat_sgNq0;
                                                } in 
                                                  case
                                                      GHC.Num.* $dNum_sgNpx sat_sgNq1 sat_sgNq2
                                                  of
                                                  dt1_sgNq3
                                                  { __DEFAULT ->
                                                        Data.Complex.:+ [dt_sgNpZ dt1_sgNq3];
                                                  };
                                          };
                                  };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1p1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNq4]
        case eta_sgNq4 of {
          Data.Complex.:+ a_sgNq6 [Occ=Once!] b_sgNq7 [Occ=Once!] ->
              case a_sgNq6 of {
                GHC.Types.F# x_sgNq9 ->
                    case b_sgNq7 of {
                      GHC.Types.F# y_sgNqb ->
                          case fabsFloat# [x_sgNq9] of sat_sgNqj {
                            __DEFAULT ->
                                let-no-escape {
                                  $j_sgNqc [Occ=Once*T[0], Dmd=<L,1*U(U,U)>]
                                    :: Data.Complex.Complex GHC.Types.Float
                                  [LclId[JoinId(0)], Str=m, Unf=OtherCon []] =
                                      [x_sgNq9 y_sgNqb] \r []
                                          case plusFloat# [1.0# x_sgNq9] of ww_sgNqd [Dmd=<S,U>] {
                                            __DEFAULT ->
                                                case
                                                    Data.Complex.$w$smagnitude1 ww_sgNqd y_sgNqb
                                                of
                                                ww1_sgNqe
                                                { __DEFAULT ->
                                                      case logFloat# [ww1_sgNqe] of wild3_sgNqf {
                                                        __DEFAULT ->
                                                            case
                                                                Data.Complex.$w$sphase1
                                                                    ww_sgNqd y_sgNqb
                                                            of
                                                            ww2_sgNqg
                                                            { __DEFAULT ->
                                                                  let {
                                                                    sat_sgNqi [Occ=Once]
                                                                      :: GHC.Types.Float
                                                                    [LclId] =
                                                                        CCCS GHC.Types.F#! [ww2_sgNqg]; } in
                                                                  let {
                                                                    sat_sgNqh [Occ=Once]
                                                                      :: GHC.Types.Float
                                                                    [LclId] =
                                                                        CCCS GHC.Types.F#! [wild3_sgNqf];
                                                                  } in 
                                                                    Data.Complex.:+ [sat_sgNqh
                                                                                     sat_sgNqi];
                                                            };
                                                      };
                                                };
                                          };
                                } in 
                                  case ltFloat# [sat_sgNqj 0.5#] of {
                                    __DEFAULT -> $j_sgNqc;
                                    1# ->
                                        case fabsFloat# [y_sgNqb] of sat_sgNql {
                                          __DEFAULT ->
                                              case ltFloat# [sat_sgNql 0.5#] of {
                                                __DEFAULT -> $j_sgNqc;
                                                1# ->
                                                    case
                                                        timesFloat# [y_sgNqb y_sgNqb]
                                                    of
                                                    sat_sgNqr
                                                    { __DEFAULT ->
                                                          case
                                                              timesFloat# [x_sgNq9 x_sgNq9]
                                                          of
                                                          sat_sgNqp
                                                          { __DEFAULT ->
                                                                case
                                                                    plusFloat# [x_sgNq9 x_sgNq9]
                                                                of
                                                                sat_sgNqo
                                                                { __DEFAULT ->
                                                                      case
                                                                          plusFloat# [sat_sgNqo
                                                                                      sat_sgNqp]
                                                                      of
                                                                      sat_sgNqq
                                                                      { __DEFAULT ->
                                                                            case
                                                                                plusFloat# [sat_sgNqq
                                                                                            sat_sgNqr]
                                                                            of
                                                                            x1_sgNqn [Dmd=<S,U>]
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      plusFloat# [x1_sgNqn
                                                                                                  1.0#]
                                                                                  of
                                                                                  sat_sgNqs
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            sqrtFloat# [sat_sgNqs]
                                                                                        of
                                                                                        sat_sgNqt
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  plusFloat# [1.0#
                                                                                                              sat_sgNqt]
                                                                                              of
                                                                                              sat_sgNqu
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        divideFloat# [x1_sgNqn
                                                                                                                      sat_sgNqu]
                                                                                                    of
                                                                                                    wild3_sgNqv
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              __pkg_ccall base-4.11.0.0 [wild3_sgNqv
                                                                                                                                         GHC.Prim.realWorld#]
                                                                                                          of
                                                                                                          { Unit# ds4_sgNqz [Occ=Once] ->
                                                                                                                case
                                                                                                                    plusFloat# [1.0#
                                                                                                                                x_sgNq9]
                                                                                                                of
                                                                                                                sat_sgNqA
                                                                                                                { __DEFAULT ->
                                                                                                                      let {
                                                                                                                        sat_sgNqB [Occ=Once]
                                                                                                                          :: GHC.Types.Float
                                                                                                                        [LclId] =
                                                                                                                            CCCS GHC.Types.F#! [sat_sgNqA];
                                                                                                                      } in 
                                                                                                                        case
                                                                                                                            GHC.Float.$w$catan1
                                                                                                                                sat_sgNqB
                                                                                                                                y_sgNqb
                                                                                                                        of
                                                                                                                        ww2_sgNqC
                                                                                                                        { __DEFAULT ->
                                                                                                                              let {
                                                                                                                                sat_sgNqE [Occ=Once]
                                                                                                                                  :: GHC.Types.Float
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.F#! [ww2_sgNqC]; } in
                                                                                                                              let {
                                                                                                                                sat_sgNqD [Occ=Once]
                                                                                                                                  :: GHC.Types.Float
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.F#! [ds4_sgNqz];
                                                                                                                              } in 
                                                                                                                                Data.Complex.:+ [sat_sgNqD
                                                                                                                                                 sat_sgNqE];
                                                                                                                        };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                        };
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1p [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNqF]
        case eta_sgNqF of {
          Data.Complex.:+ a_sgNqH [Occ=Once!] b_sgNqI [Occ=Once!] ->
              case a_sgNqH of {
                GHC.Types.D# x_sgNqK ->
                    case b_sgNqI of {
                      GHC.Types.D# y_sgNqM ->
                          case fabsDouble# [x_sgNqK] of sat_sgNqU {
                            __DEFAULT ->
                                let-no-escape {
                                  $j_sgNqN [Occ=Once*T[0], Dmd=<L,1*U(U,U)>]
                                    :: Data.Complex.Complex GHC.Types.Double
                                  [LclId[JoinId(0)], Str=m, Unf=OtherCon []] =
                                      [x_sgNqK y_sgNqM] \r []
                                          case +## [1.0## x_sgNqK] of ww_sgNqO [Dmd=<S,U>] {
                                            __DEFAULT ->
                                                case
                                                    Data.Complex.$w$smagnitude ww_sgNqO y_sgNqM
                                                of
                                                ww1_sgNqP
                                                { __DEFAULT ->
                                                      case logDouble# [ww1_sgNqP] of wild3_sgNqQ {
                                                        __DEFAULT ->
                                                            case
                                                                Data.Complex.$w$sphase
                                                                    ww_sgNqO y_sgNqM
                                                            of
                                                            ww2_sgNqR
                                                            { __DEFAULT ->
                                                                  let {
                                                                    sat_sgNqT [Occ=Once]
                                                                      :: GHC.Types.Double
                                                                    [LclId] =
                                                                        CCCS GHC.Types.D#! [ww2_sgNqR]; } in
                                                                  let {
                                                                    sat_sgNqS [Occ=Once]
                                                                      :: GHC.Types.Double
                                                                    [LclId] =
                                                                        CCCS GHC.Types.D#! [wild3_sgNqQ];
                                                                  } in 
                                                                    Data.Complex.:+ [sat_sgNqS
                                                                                     sat_sgNqT];
                                                            };
                                                      };
                                                };
                                          };
                                } in 
                                  case <## [sat_sgNqU 0.5##] of {
                                    __DEFAULT -> $j_sgNqN;
                                    1# ->
                                        case fabsDouble# [y_sgNqM] of sat_sgNqW {
                                          __DEFAULT ->
                                              case <## [sat_sgNqW 0.5##] of {
                                                __DEFAULT -> $j_sgNqN;
                                                1# ->
                                                    case *## [y_sgNqM y_sgNqM] of sat_sgNr2 {
                                                      __DEFAULT ->
                                                          case *## [x_sgNqK x_sgNqK] of sat_sgNr0 {
                                                            __DEFAULT ->
                                                                case
                                                                    +## [x_sgNqK x_sgNqK]
                                                                of
                                                                sat_sgNqZ
                                                                { __DEFAULT ->
                                                                      case
                                                                          +## [sat_sgNqZ sat_sgNr0]
                                                                      of
                                                                      sat_sgNr1
                                                                      { __DEFAULT ->
                                                                            case
                                                                                +## [sat_sgNr1
                                                                                     sat_sgNr2]
                                                                            of
                                                                            x1_sgNqY [Dmd=<S,U>]
                                                                            { __DEFAULT ->
                                                                                  case
                                                                                      +## [x1_sgNqY
                                                                                           1.0##]
                                                                                  of
                                                                                  sat_sgNr3
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            sqrtDouble# [sat_sgNr3]
                                                                                        of
                                                                                        sat_sgNr4
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  +## [1.0##
                                                                                                       sat_sgNr4]
                                                                                              of
                                                                                              sat_sgNr5
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        /## [x1_sgNqY
                                                                                                             sat_sgNr5]
                                                                                                    of
                                                                                                    wild3_sgNr6
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              __pkg_ccall base-4.11.0.0 [wild3_sgNr6
                                                                                                                                         GHC.Prim.realWorld#]
                                                                                                          of
                                                                                                          { Unit# ds4_sgNra [Occ=Once] ->
                                                                                                                case
                                                                                                                    +## [1.0##
                                                                                                                         x_sgNqK]
                                                                                                                of
                                                                                                                sat_sgNrb
                                                                                                                { __DEFAULT ->
                                                                                                                      let {
                                                                                                                        sat_sgNrc [Occ=Once]
                                                                                                                          :: GHC.Types.Double
                                                                                                                        [LclId] =
                                                                                                                            CCCS GHC.Types.D#! [sat_sgNrb];
                                                                                                                      } in 
                                                                                                                        case
                                                                                                                            GHC.Float.$w$catan2
                                                                                                                                sat_sgNrc
                                                                                                                                y_sgNqM
                                                                                                                        of
                                                                                                                        ww2_sgNrd
                                                                                                                        { __DEFAULT ->
                                                                                                                              let {
                                                                                                                                sat_sgNrf [Occ=Once]
                                                                                                                                  :: GHC.Types.Double
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.D#! [ww2_sgNrd]; } in
                                                                                                                              let {
                                                                                                                                sat_sgNre [Occ=Once]
                                                                                                                                  :: GHC.Types.Double
                                                                                                                                [LclId] =
                                                                                                                                    CCCS GHC.Types.D#! [ds4_sgNra];
                                                                                                                              } in 
                                                                                                                                Data.Complex.:+ [sat_sgNre
                                                                                                                                                 sat_sgNrf];
                                                                                                                        };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                          };
                                                    };
                                              };
                                        };
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clog1p [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgNrg eta_sgNrh]
        case eta_sgNrh of {
          Data.Complex.:+ a1_sgNrj b_sgNrk ->
              case
                  GHC.Float.$p1RealFloat $dRealFloat_sgNrg
              of
              $dRealFrac_sgNrl [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
              { __DEFAULT ->
                    case
                        GHC.Real.$p1RealFrac $dRealFrac_sgNrl
                    of
                    $dReal_sgNrm [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
                    { __DEFAULT ->
                          let {
                            $dNum_sgNrn [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
                              :: GHC.Num.Num a_agsO1
                            [LclId] =
                                [$dReal_sgNrm] \u [] GHC.Real.$p1Real $dReal_sgNrm;
                          } in 
                            case
                                GHC.Real.$p2Real $dReal_sgNrm
                            of
                            $dOrd_sgNro [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                            { __DEFAULT ->
                                  let {
                                    $dFractional_sgNrp [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
                                      :: GHC.Real.Fractional a_agsO1
                                    [LclId] =
                                        [$dRealFrac_sgNrl] \u []
                                            GHC.Real.$p2RealFrac $dRealFrac_sgNrl; } in
                                  let {
                                    sat_sgNrr [Occ=Once] :: a_agsO1
                                    [LclId] =
                                        [$dFractional_sgNrp] \u []
                                            GHC.Real.fromRational
                                                $dFractional_sgNrp
                                                Data.Complex.$fFloatingComplex20; } in
                                  let {
                                    sat_sgNrq [Occ=Once] :: a_agsO1
                                    [LclId] =
                                        [a1_sgNrj $dNum_sgNrn] \u []
                                            GHC.Num.abs $dNum_sgNrn a1_sgNrj;
                                  } in 
                                    case GHC.Classes.< $dOrd_sgNro sat_sgNrq sat_sgNrr of {
                                      GHC.Types.False ->
                                          case
                                              Data.Complex.$w$cfromInteger
                                                  $dRealFloat_sgNrg Data.Complex.$fFloatingComplex19
                                          of
                                          { (#,#) ww1_sgNru [Occ=Once] ww2_sgNrv [Occ=Once] ->
                                                case
                                                    Data.Complex.$w$c+
                                                        $dRealFloat_sgNrg
                                                        ww1_sgNru
                                                        ww2_sgNrv
                                                        a1_sgNrj
                                                        b_sgNrk
                                                of
                                                { (#,#) ww4_sgNrx [Occ=Once] ww5_sgNry [Occ=Once] ->
                                                      case
                                                          Data.Complex.$w$clog
                                                              $dRealFloat_sgNrg ww4_sgNrx ww5_sgNry
                                                      of
                                                      { (#,#) ww7_sgNrA [Occ=Once]
                                                              ww8_sgNrB [Occ=Once] ->
                                                            Data.Complex.:+ [ww7_sgNrA ww8_sgNrB];
                                                      };
                                                };
                                          };
                                      GHC.Types.True ->
                                          let {
                                            sat_sgNrD [Occ=Once] :: a_agsO1
                                            [LclId] =
                                                [$dFractional_sgNrp] \u []
                                                    GHC.Real.fromRational
                                                        $dFractional_sgNrp
                                                        Data.Complex.$fFloatingComplex20; } in
                                          let {
                                            sat_sgNrC [Occ=Once] :: a_agsO1
                                            [LclId] =
                                                [b_sgNrk $dNum_sgNrn] \u []
                                                    GHC.Num.abs $dNum_sgNrn b_sgNrk;
                                          } in 
                                            case GHC.Classes.< $dOrd_sgNro sat_sgNrC sat_sgNrD of {
                                              GHC.Types.False ->
                                                  case
                                                      Data.Complex.$w$cfromInteger
                                                          $dRealFloat_sgNrg
                                                          Data.Complex.$fFloatingComplex19
                                                  of
                                                  { (#,#) ww1_sgNrG [Occ=Once]
                                                          ww2_sgNrH [Occ=Once] ->
                                                        case
                                                            Data.Complex.$w$c+
                                                                $dRealFloat_sgNrg
                                                                ww1_sgNrG
                                                                ww2_sgNrH
                                                                a1_sgNrj
                                                                b_sgNrk
                                                        of
                                                        { (#,#) ww4_sgNrJ [Occ=Once]
                                                                ww5_sgNrK [Occ=Once] ->
                                                              case
                                                                  Data.Complex.$w$clog
                                                                      $dRealFloat_sgNrg
                                                                      ww4_sgNrJ
                                                                      ww5_sgNrK
                                                              of
                                                              { (#,#) ww7_sgNrM [Occ=Once]
                                                                      ww8_sgNrN [Occ=Once] ->
                                                                    Data.Complex.:+ [ww7_sgNrM
                                                                                     ww8_sgNrN];
                                                              };
                                                        };
                                                  };
                                              GHC.Types.True ->
                                                  case
                                                      GHC.Float.$p2RealFloat $dRealFloat_sgNrg
                                                  of
                                                  $dFloating_sgNrO [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                                                  { __DEFAULT ->
                                                        let {
                                                          sat_sgNs0 [Occ=Once] :: a_agsO1
                                                          [LclId] =
                                                              [a1_sgNrj
                                                               b_sgNrk
                                                               $dNum_sgNrn
                                                               $dFractional_sgNrp
                                                               $dFloating_sgNrO] \u []
                                                                  let {
                                                                    u_sgNrP :: a_agsO1
                                                                    [LclId] =
                                                                        [a1_sgNrj
                                                                         b_sgNrk
                                                                         $dNum_sgNrn] \u []
                                                                            let {
                                                                              sat_sgNrU [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [b_sgNrk
                                                                                   $dNum_sgNrn] \u []
                                                                                      GHC.Num.*
                                                                                          $dNum_sgNrn
                                                                                          b_sgNrk
                                                                                          b_sgNrk; } in
                                                                            let {
                                                                              sat_sgNrT [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [a1_sgNrj
                                                                                   $dNum_sgNrn] \u []
                                                                                      let {
                                                                                        sat_sgNrS [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [a1_sgNrj
                                                                                             $dNum_sgNrn] \u []
                                                                                                GHC.Num.*
                                                                                                    $dNum_sgNrn
                                                                                                    a1_sgNrj
                                                                                                    a1_sgNrj; } in
                                                                                      let {
                                                                                        sat_sgNrR [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [a1_sgNrj
                                                                                             $dNum_sgNrn] \u []
                                                                                                let {
                                                                                                  sat_sgNrQ [Occ=Once]
                                                                                                    :: a_agsO1
                                                                                                  [LclId] =
                                                                                                      [$dNum_sgNrn] \u []
                                                                                                          GHC.Num.fromInteger
                                                                                                              $dNum_sgNrn
                                                                                                              Data.Complex.$fFloatingComplex21;
                                                                                                } in 
                                                                                                  GHC.Num.*
                                                                                                      $dNum_sgNrn
                                                                                                      sat_sgNrQ
                                                                                                      a1_sgNrj;
                                                                                      } in 
                                                                                        GHC.Num.+
                                                                                            $dNum_sgNrn
                                                                                            sat_sgNrR
                                                                                            sat_sgNrS;
                                                                            } in 
                                                                              GHC.Num.+
                                                                                  $dNum_sgNrn
                                                                                  sat_sgNrT
                                                                                  sat_sgNrU; } in
                                                                  let {
                                                                    sat_sgNrZ [Occ=Once] :: a_agsO1
                                                                    [LclId] =
                                                                        [$dNum_sgNrn
                                                                         $dFloating_sgNrO
                                                                         u_sgNrP] \u []
                                                                            let {
                                                                              sat_sgNrY [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [$dNum_sgNrn
                                                                                   $dFloating_sgNrO
                                                                                   u_sgNrP] \u []
                                                                                      let {
                                                                                        sat_sgNrX [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [$dNum_sgNrn
                                                                                             u_sgNrP] \u []
                                                                                                let {
                                                                                                  sat_sgNrW [Occ=Once]
                                                                                                    :: a_agsO1
                                                                                                  [LclId] =
                                                                                                      [$dNum_sgNrn] \u []
                                                                                                          GHC.Num.fromInteger
                                                                                                              $dNum_sgNrn
                                                                                                              Data.Complex.$fFloatingComplex19;
                                                                                                } in 
                                                                                                  GHC.Num.+
                                                                                                      $dNum_sgNrn
                                                                                                      u_sgNrP
                                                                                                      sat_sgNrW;
                                                                                      } in 
                                                                                        GHC.Float.sqrt
                                                                                            $dFloating_sgNrO
                                                                                            sat_sgNrX; } in
                                                                            let {
                                                                              sat_sgNrV [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [$dNum_sgNrn] \u []
                                                                                      GHC.Num.fromInteger
                                                                                          $dNum_sgNrn
                                                                                          Data.Complex.$fFloatingComplex19;
                                                                            } in 
                                                                              GHC.Num.+
                                                                                  $dNum_sgNrn
                                                                                  sat_sgNrV
                                                                                  sat_sgNrY;
                                                                  } in 
                                                                    GHC.Real./
                                                                        $dFractional_sgNrp
                                                                        u_sgNrP
                                                                        sat_sgNrZ;
                                                        } in 
                                                          case
                                                              GHC.Float.log1p
                                                                  $dFloating_sgNrO sat_sgNs0
                                                          of
                                                          dt_sgNs1
                                                          { __DEFAULT ->
                                                                let {
                                                                  sat_sgNs3 [Occ=Once] :: a_agsO1
                                                                  [LclId] =
                                                                      [a1_sgNrj $dNum_sgNrn] \u []
                                                                          let {
                                                                            sat_sgNs2 [Occ=Once]
                                                                              :: a_agsO1
                                                                            [LclId] =
                                                                                [$dNum_sgNrn] \u []
                                                                                    GHC.Num.fromInteger
                                                                                        $dNum_sgNrn
                                                                                        Data.Complex.$fFloatingComplex19;
                                                                          } in 
                                                                            GHC.Num.+
                                                                                $dNum_sgNrn
                                                                                sat_sgNs2
                                                                                a1_sgNrj;
                                                                } in 
                                                                  case
                                                                      GHC.Float.atan2
                                                                          $dRealFloat_sgNrg
                                                                          sat_sgNs3
                                                                          b_sgNrk
                                                                  of
                                                                  dt1_sgNs4
                                                                  { __DEFAULT ->
                                                                        Data.Complex.:+ [dt_sgNs1
                                                                                         dt1_sgNs4];
                                                                  };
                                                          };
                                                  };
                                            };
                                    };
                            };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1mexp1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNs5]
        case eta_sgNs5 of {
          Data.Complex.:+ x_sgNs7 [Occ=Once!] y_sgNs8 [Occ=Once!] ->
              case x_sgNs7 of {
                GHC.Types.F# x1_sgNsa [Occ=Once] ->
                    case y_sgNs8 of {
                      GHC.Types.F# x2_sgNsc ->
                          case expFloat# [x1_sgNsa] of expx_sgNsd [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosFloat# [x2_sgNsc] of sat_sgNsf {
                                  __DEFAULT ->
                                      case timesFloat# [expx_sgNsd sat_sgNsf] of sat_sgNsg {
                                        __DEFAULT ->
                                            case negateFloat# [sat_sgNsg] of dt_sgNse [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case sinFloat# [x2_sgNsc] of sat_sgNsi {
                                                    __DEFAULT ->
                                                        case
                                                            timesFloat# [expx_sgNsd sat_sgNsi]
                                                        of
                                                        sat_sgNsj
                                                        { __DEFAULT ->
                                                              case
                                                                  negateFloat# [sat_sgNsj]
                                                              of
                                                              dt1_sgNsh [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        fabsFloat# [dt_sgNse]
                                                                    of
                                                                    sat_sgNsr
                                                                    { __DEFAULT ->
                                                                          let-no-escape {
                                                                            $j_sgNsk [Occ=Once*T[0],
                                                                                      Dmd=<L,1*U(U,U)>]
                                                                              :: Data.Complex.Complex
                                                                                   GHC.Types.Float
                                                                            [LclId[JoinId(0)],
                                                                             Str=m,
                                                                             Unf=OtherCon []] =
                                                                                [dt_sgNse
                                                                                 dt1_sgNsh] \r []
                                                                                    case
                                                                                        plusFloat# [1.0#
                                                                                                    dt_sgNse]
                                                                                    of
                                                                                    dt2_sgNsl [Dmd=<S,U>]
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$smagnitude1
                                                                                                  dt2_sgNsl
                                                                                                  dt1_sgNsh
                                                                                          of
                                                                                          ww_sgNsm
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    logFloat# [ww_sgNsm]
                                                                                                of
                                                                                                wild3_sgNsn
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          Data.Complex.$w$sphase1
                                                                                                              dt2_sgNsl
                                                                                                              dt1_sgNsh
                                                                                                      of
                                                                                                      ww1_sgNso
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgNsq [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [ww1_sgNso]; } in
                                                                                                            let {
                                                                                                              sat_sgNsp [Occ=Once]
                                                                                                                :: GHC.Types.Float
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.F#! [wild3_sgNsn];
                                                                                                            } in 
                                                                                                              Data.Complex.:+ [sat_sgNsp
                                                                                                                               sat_sgNsq];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                          } in 
                                                                            case
                                                                                ltFloat# [sat_sgNsr
                                                                                          0.5#]
                                                                            of
                                                                            { __DEFAULT -> $j_sgNsk;
                                                                              1# ->
                                                                                  case
                                                                                      fabsFloat# [dt1_sgNsh]
                                                                                  of
                                                                                  sat_sgNst
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            ltFloat# [sat_sgNst
                                                                                                      0.5#]
                                                                                        of
                                                                                        { __DEFAULT ->
                                                                                              $j_sgNsk;
                                                                                          1# ->
                                                                                              case
                                                                                                  timesFloat# [dt1_sgNsh
                                                                                                               dt1_sgNsh]
                                                                                              of
                                                                                              sat_sgNsz
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        timesFloat# [dt_sgNse
                                                                                                                     dt_sgNse]
                                                                                                    of
                                                                                                    sat_sgNsx
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              plusFloat# [dt_sgNse
                                                                                                                          dt_sgNse]
                                                                                                          of
                                                                                                          sat_sgNsw
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    plusFloat# [sat_sgNsw
                                                                                                                                sat_sgNsx]
                                                                                                                of
                                                                                                                sat_sgNsy
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          plusFloat# [sat_sgNsy
                                                                                                                                      sat_sgNsz]
                                                                                                                      of
                                                                                                                      u_sgNsv [Dmd=<S,U>]
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                plusFloat# [u_sgNsv
                                                                                                                                            1.0#]
                                                                                                                            of
                                                                                                                            sat_sgNsA
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sqrtFloat# [sat_sgNsA]
                                                                                                                                  of
                                                                                                                                  sat_sgNsB
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            plusFloat# [1.0#
                                                                                                                                                        sat_sgNsB]
                                                                                                                                        of
                                                                                                                                        sat_sgNsC
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              case
                                                                                                                                                  divideFloat# [u_sgNsv
                                                                                                                                                                sat_sgNsC]
                                                                                                                                              of
                                                                                                                                              wild3_sgNsD
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    case
                                                                                                                                                        __pkg_ccall base-4.11.0.0 [wild3_sgNsD
                                                                                                                                                                                   GHC.Prim.realWorld#]
                                                                                                                                                    of
                                                                                                                                                    { Unit# ds4_sgNsH [Occ=Once] ->
                                                                                                                                                          case
                                                                                                                                                              plusFloat# [1.0#
                                                                                                                                                                          dt_sgNse]
                                                                                                                                                          of
                                                                                                                                                          sat_sgNsI
                                                                                                                                                          { __DEFAULT ->
                                                                                                                                                                let {
                                                                                                                                                                  sat_sgNsJ [Occ=Once]
                                                                                                                                                                    :: GHC.Types.Float
                                                                                                                                                                  [LclId] =
                                                                                                                                                                      CCCS GHC.Types.F#! [sat_sgNsI];
                                                                                                                                                                } in 
                                                                                                                                                                  case
                                                                                                                                                                      GHC.Float.$w$catan1
                                                                                                                                                                          sat_sgNsJ
                                                                                                                                                                          dt1_sgNsh
                                                                                                                                                                  of
                                                                                                                                                                  ww2_sgNsK
                                                                                                                                                                  { __DEFAULT ->
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgNsM [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Float
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.F#! [ww2_sgNsK]; } in
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgNsL [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Float
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.F#! [ds4_sgNsH];
                                                                                                                                                                        } in 
                                                                                                                                                                          Data.Complex.:+ [sat_sgNsL
                                                                                                                                                                                           sat_sgNsM];
                                                                                                                                                                  };
                                                                                                                                                          };
                                                                                                                                                    };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNsN]
        case eta_sgNsN of {
          Data.Complex.:+ x_sgNsP [Occ=Once!] y_sgNsQ [Occ=Once!] ->
              case x_sgNsP of {
                GHC.Types.D# x1_sgNsS [Occ=Once] ->
                    case y_sgNsQ of {
                      GHC.Types.D# x2_sgNsU ->
                          case expDouble# [x1_sgNsS] of expx_sgNsV [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosDouble# [x2_sgNsU] of sat_sgNsX {
                                  __DEFAULT ->
                                      case *## [expx_sgNsV sat_sgNsX] of sat_sgNsY {
                                        __DEFAULT ->
                                            case negateDouble# [sat_sgNsY] of dt_sgNsW [Dmd=<S,U>] {
                                              __DEFAULT ->
                                                  case sinDouble# [x2_sgNsU] of sat_sgNt0 {
                                                    __DEFAULT ->
                                                        case
                                                            *## [expx_sgNsV sat_sgNt0]
                                                        of
                                                        sat_sgNt1
                                                        { __DEFAULT ->
                                                              case
                                                                  negateDouble# [sat_sgNt1]
                                                              of
                                                              dt1_sgNsZ [Dmd=<S,U>]
                                                              { __DEFAULT ->
                                                                    case
                                                                        fabsDouble# [dt_sgNsW]
                                                                    of
                                                                    sat_sgNt9
                                                                    { __DEFAULT ->
                                                                          let-no-escape {
                                                                            $j_sgNt2 [Occ=Once*T[0],
                                                                                      Dmd=<L,1*U(U,U)>]
                                                                              :: Data.Complex.Complex
                                                                                   GHC.Types.Double
                                                                            [LclId[JoinId(0)],
                                                                             Str=m,
                                                                             Unf=OtherCon []] =
                                                                                [dt_sgNsW
                                                                                 dt1_sgNsZ] \r []
                                                                                    case
                                                                                        +## [1.0##
                                                                                             dt_sgNsW]
                                                                                    of
                                                                                    dt2_sgNt3 [Dmd=<S,U>]
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$smagnitude
                                                                                                  dt2_sgNt3
                                                                                                  dt1_sgNsZ
                                                                                          of
                                                                                          ww_sgNt4
                                                                                          { __DEFAULT ->
                                                                                                case
                                                                                                    logDouble# [ww_sgNt4]
                                                                                                of
                                                                                                wild3_sgNt5
                                                                                                { __DEFAULT ->
                                                                                                      case
                                                                                                          Data.Complex.$w$sphase
                                                                                                              dt2_sgNt3
                                                                                                              dt1_sgNsZ
                                                                                                      of
                                                                                                      ww1_sgNt6
                                                                                                      { __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sgNt8 [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [ww1_sgNt6]; } in
                                                                                                            let {
                                                                                                              sat_sgNt7 [Occ=Once]
                                                                                                                :: GHC.Types.Double
                                                                                                              [LclId] =
                                                                                                                  CCCS GHC.Types.D#! [wild3_sgNt5];
                                                                                                            } in 
                                                                                                              Data.Complex.:+ [sat_sgNt7
                                                                                                                               sat_sgNt8];
                                                                                                      };
                                                                                                };
                                                                                          };
                                                                                    };
                                                                          } in 
                                                                            case
                                                                                <## [sat_sgNt9
                                                                                     0.5##]
                                                                            of
                                                                            { __DEFAULT -> $j_sgNt2;
                                                                              1# ->
                                                                                  case
                                                                                      fabsDouble# [dt1_sgNsZ]
                                                                                  of
                                                                                  sat_sgNtb
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            <## [sat_sgNtb
                                                                                                 0.5##]
                                                                                        of
                                                                                        { __DEFAULT ->
                                                                                              $j_sgNt2;
                                                                                          1# ->
                                                                                              case
                                                                                                  *## [dt1_sgNsZ
                                                                                                       dt1_sgNsZ]
                                                                                              of
                                                                                              sat_sgNth
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        *## [dt_sgNsW
                                                                                                             dt_sgNsW]
                                                                                                    of
                                                                                                    sat_sgNtf
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              +## [dt_sgNsW
                                                                                                                   dt_sgNsW]
                                                                                                          of
                                                                                                          sat_sgNte
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    +## [sat_sgNte
                                                                                                                         sat_sgNtf]
                                                                                                                of
                                                                                                                sat_sgNtg
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          +## [sat_sgNtg
                                                                                                                               sat_sgNth]
                                                                                                                      of
                                                                                                                      u_sgNtd [Dmd=<S,U>]
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                +## [u_sgNtd
                                                                                                                                     1.0##]
                                                                                                                            of
                                                                                                                            sat_sgNti
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      sqrtDouble# [sat_sgNti]
                                                                                                                                  of
                                                                                                                                  sat_sgNtj
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            +## [1.0##
                                                                                                                                                 sat_sgNtj]
                                                                                                                                        of
                                                                                                                                        sat_sgNtk
                                                                                                                                        { __DEFAULT ->
                                                                                                                                              case
                                                                                                                                                  /## [u_sgNtd
                                                                                                                                                       sat_sgNtk]
                                                                                                                                              of
                                                                                                                                              wild3_sgNtl
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    case
                                                                                                                                                        __pkg_ccall base-4.11.0.0 [wild3_sgNtl
                                                                                                                                                                                   GHC.Prim.realWorld#]
                                                                                                                                                    of
                                                                                                                                                    { Unit# ds4_sgNtp [Occ=Once] ->
                                                                                                                                                          case
                                                                                                                                                              +## [1.0##
                                                                                                                                                                   dt_sgNsW]
                                                                                                                                                          of
                                                                                                                                                          sat_sgNtq
                                                                                                                                                          { __DEFAULT ->
                                                                                                                                                                let {
                                                                                                                                                                  sat_sgNtr [Occ=Once]
                                                                                                                                                                    :: GHC.Types.Double
                                                                                                                                                                  [LclId] =
                                                                                                                                                                      CCCS GHC.Types.D#! [sat_sgNtq];
                                                                                                                                                                } in 
                                                                                                                                                                  case
                                                                                                                                                                      GHC.Float.$w$catan2
                                                                                                                                                                          sat_sgNtr
                                                                                                                                                                          dt1_sgNsZ
                                                                                                                                                                  of
                                                                                                                                                                  ww2_sgNts
                                                                                                                                                                  { __DEFAULT ->
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgNtu [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Double
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.D#! [ww2_sgNts]; } in
                                                                                                                                                                        let {
                                                                                                                                                                          sat_sgNtt [Occ=Once]
                                                                                                                                                                            :: GHC.Types.Double
                                                                                                                                                                          [LclId] =
                                                                                                                                                                              CCCS GHC.Types.D#! [ds4_sgNtp];
                                                                                                                                                                        } in 
                                                                                                                                                                          Data.Complex.:+ [sat_sgNtt
                                                                                                                                                                                           sat_sgNtu];
                                                                                                                                                                  };
                                                                                                                                                          };
                                                                                                                                                    };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)S(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgNtv eta_sgNtw]
        case eta_sgNtw of {
          Data.Complex.:+ ww1_sgNty [Occ=Once] ww2_sgNtz [Occ=Once] ->
              case
                  Data.Complex.$w$cexp $dRealFloat_sgNtv ww1_sgNty ww2_sgNtz
              of
              { (#,#) ww4_sgNtB [Occ=Once] ww5_sgNtC [Occ=Once] ->
                    case
                        Data.Complex.$w$cnegate $dRealFloat_sgNtv ww4_sgNtB ww5_sgNtC
                    of
                    { (#,#) ww7_sgNtE ww8_sgNtF ->
                          case
                              GHC.Float.$p1RealFloat $dRealFloat_sgNtv
                          of
                          $dRealFrac_sgNtG [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
                          { __DEFAULT ->
                                case
                                    GHC.Real.$p1RealFrac $dRealFrac_sgNtG
                                of
                                $dReal_sgNtH [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
                                { __DEFAULT ->
                                      let {
                                        $dNum_sgNtI [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
                                          :: GHC.Num.Num a_agsO1
                                        [LclId] =
                                            [$dReal_sgNtH] \u [] GHC.Real.$p1Real $dReal_sgNtH;
                                      } in 
                                        case
                                            GHC.Real.$p2Real $dReal_sgNtH
                                        of
                                        $dOrd_sgNtJ [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                                        { __DEFAULT ->
                                              let {
                                                $dFractional_sgNtK [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
                                                  :: GHC.Real.Fractional a_agsO1
                                                [LclId] =
                                                    [$dRealFrac_sgNtG] \u []
                                                        GHC.Real.$p2RealFrac $dRealFrac_sgNtG; } in
                                              let {
                                                sat_sgNtM [Occ=Once] :: a_agsO1
                                                [LclId] =
                                                    [$dFractional_sgNtK] \u []
                                                        GHC.Real.fromRational
                                                            $dFractional_sgNtK
                                                            Data.Complex.$fFloatingComplex20; } in
                                              let {
                                                sat_sgNtL [Occ=Once] :: a_agsO1
                                                [LclId] =
                                                    [ww7_sgNtE $dNum_sgNtI] \u []
                                                        GHC.Num.abs $dNum_sgNtI ww7_sgNtE;
                                              } in 
                                                case
                                                    GHC.Classes.< $dOrd_sgNtJ sat_sgNtL sat_sgNtM
                                                of
                                                { GHC.Types.False ->
                                                      case
                                                          Data.Complex.$w$cfromInteger
                                                              $dRealFloat_sgNtv
                                                              Data.Complex.$fFloatingComplex19
                                                      of
                                                      { (#,#) ww10_sgNtP [Occ=Once]
                                                              ww11_sgNtQ [Occ=Once] ->
                                                            case
                                                                Data.Complex.$w$c+
                                                                    $dRealFloat_sgNtv
                                                                    ww10_sgNtP
                                                                    ww11_sgNtQ
                                                                    ww7_sgNtE
                                                                    ww8_sgNtF
                                                            of
                                                            { (#,#) ww13_sgNtS [Occ=Once]
                                                                    ww14_sgNtT [Occ=Once] ->
                                                                  case
                                                                      Data.Complex.$w$clog
                                                                          $dRealFloat_sgNtv
                                                                          ww13_sgNtS
                                                                          ww14_sgNtT
                                                                  of
                                                                  { (#,#) ww16_sgNtV [Occ=Once]
                                                                          ww17_sgNtW [Occ=Once] ->
                                                                        Data.Complex.:+ [ww16_sgNtV
                                                                                         ww17_sgNtW];
                                                                  };
                                                            };
                                                      };
                                                  GHC.Types.True ->
                                                      let {
                                                        sat_sgNtY [Occ=Once] :: a_agsO1
                                                        [LclId] =
                                                            [$dFractional_sgNtK] \u []
                                                                GHC.Real.fromRational
                                                                    $dFractional_sgNtK
                                                                    Data.Complex.$fFloatingComplex20; } in
                                                      let {
                                                        sat_sgNtX [Occ=Once] :: a_agsO1
                                                        [LclId] =
                                                            [ww8_sgNtF $dNum_sgNtI] \u []
                                                                GHC.Num.abs $dNum_sgNtI ww8_sgNtF;
                                                      } in 
                                                        case
                                                            GHC.Classes.<
                                                                $dOrd_sgNtJ sat_sgNtX sat_sgNtY
                                                        of
                                                        { GHC.Types.False ->
                                                              case
                                                                  Data.Complex.$w$cfromInteger
                                                                      $dRealFloat_sgNtv
                                                                      Data.Complex.$fFloatingComplex19
                                                              of
                                                              { (#,#) ww10_sgNu1 [Occ=Once]
                                                                      ww11_sgNu2 [Occ=Once] ->
                                                                    case
                                                                        Data.Complex.$w$c+
                                                                            $dRealFloat_sgNtv
                                                                            ww10_sgNu1
                                                                            ww11_sgNu2
                                                                            ww7_sgNtE
                                                                            ww8_sgNtF
                                                                    of
                                                                    { (#,#) ww13_sgNu4 [Occ=Once]
                                                                            ww14_sgNu5 [Occ=Once] ->
                                                                          case
                                                                              Data.Complex.$w$clog
                                                                                  $dRealFloat_sgNtv
                                                                                  ww13_sgNu4
                                                                                  ww14_sgNu5
                                                                          of
                                                                          { (#,#) ww16_sgNu7 [Occ=Once]
                                                                                  ww17_sgNu8 [Occ=Once] ->
                                                                                Data.Complex.:+ [ww16_sgNu7
                                                                                                 ww17_sgNu8];
                                                                          };
                                                                    };
                                                              };
                                                          GHC.Types.True ->
                                                              case
                                                                  GHC.Float.$p2RealFloat
                                                                      $dRealFloat_sgNtv
                                                              of
                                                              $dFloating_sgNu9 [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                                                              { __DEFAULT ->
                                                                    let {
                                                                      sat_sgNul [Occ=Once]
                                                                        :: a_agsO1
                                                                      [LclId] =
                                                                          [ww7_sgNtE
                                                                           ww8_sgNtF
                                                                           $dNum_sgNtI
                                                                           $dFractional_sgNtK
                                                                           $dFloating_sgNu9] \u []
                                                                              let {
                                                                                u_sgNua :: a_agsO1
                                                                                [LclId] =
                                                                                    [ww7_sgNtE
                                                                                     ww8_sgNtF
                                                                                     $dNum_sgNtI] \u []
                                                                                        let {
                                                                                          sat_sgNuf [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [ww8_sgNtF
                                                                                               $dNum_sgNtI] \u []
                                                                                                  GHC.Num.*
                                                                                                      $dNum_sgNtI
                                                                                                      ww8_sgNtF
                                                                                                      ww8_sgNtF; } in
                                                                                        let {
                                                                                          sat_sgNue [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [ww7_sgNtE
                                                                                               $dNum_sgNtI] \u []
                                                                                                  let {
                                                                                                    sat_sgNud [Occ=Once]
                                                                                                      :: a_agsO1
                                                                                                    [LclId] =
                                                                                                        [ww7_sgNtE
                                                                                                         $dNum_sgNtI] \u []
                                                                                                            GHC.Num.*
                                                                                                                $dNum_sgNtI
                                                                                                                ww7_sgNtE
                                                                                                                ww7_sgNtE; } in
                                                                                                  let {
                                                                                                    sat_sgNuc [Occ=Once]
                                                                                                      :: a_agsO1
                                                                                                    [LclId] =
                                                                                                        [ww7_sgNtE
                                                                                                         $dNum_sgNtI] \u []
                                                                                                            let {
                                                                                                              sat_sgNub [Occ=Once]
                                                                                                                :: a_agsO1
                                                                                                              [LclId] =
                                                                                                                  [$dNum_sgNtI] \u []
                                                                                                                      GHC.Num.fromInteger
                                                                                                                          $dNum_sgNtI
                                                                                                                          Data.Complex.$fFloatingComplex21;
                                                                                                            } in 
                                                                                                              GHC.Num.*
                                                                                                                  $dNum_sgNtI
                                                                                                                  sat_sgNub
                                                                                                                  ww7_sgNtE;
                                                                                                  } in 
                                                                                                    GHC.Num.+
                                                                                                        $dNum_sgNtI
                                                                                                        sat_sgNuc
                                                                                                        sat_sgNud;
                                                                                        } in 
                                                                                          GHC.Num.+
                                                                                              $dNum_sgNtI
                                                                                              sat_sgNue
                                                                                              sat_sgNuf; } in
                                                                              let {
                                                                                sat_sgNuk [Occ=Once]
                                                                                  :: a_agsO1
                                                                                [LclId] =
                                                                                    [$dNum_sgNtI
                                                                                     $dFloating_sgNu9
                                                                                     u_sgNua] \u []
                                                                                        let {
                                                                                          sat_sgNuj [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [$dNum_sgNtI
                                                                                               $dFloating_sgNu9
                                                                                               u_sgNua] \u []
                                                                                                  let {
                                                                                                    sat_sgNui [Occ=Once]
                                                                                                      :: a_agsO1
                                                                                                    [LclId] =
                                                                                                        [$dNum_sgNtI
                                                                                                         u_sgNua] \u []
                                                                                                            let {
                                                                                                              sat_sgNuh [Occ=Once]
                                                                                                                :: a_agsO1
                                                                                                              [LclId] =
                                                                                                                  [$dNum_sgNtI] \u []
                                                                                                                      GHC.Num.fromInteger
                                                                                                                          $dNum_sgNtI
                                                                                                                          Data.Complex.$fFloatingComplex19;
                                                                                                            } in 
                                                                                                              GHC.Num.+
                                                                                                                  $dNum_sgNtI
                                                                                                                  u_sgNua
                                                                                                                  sat_sgNuh;
                                                                                                  } in 
                                                                                                    GHC.Float.sqrt
                                                                                                        $dFloating_sgNu9
                                                                                                        sat_sgNui; } in
                                                                                        let {
                                                                                          sat_sgNug [Occ=Once]
                                                                                            :: a_agsO1
                                                                                          [LclId] =
                                                                                              [$dNum_sgNtI] \u []
                                                                                                  GHC.Num.fromInteger
                                                                                                      $dNum_sgNtI
                                                                                                      Data.Complex.$fFloatingComplex19;
                                                                                        } in 
                                                                                          GHC.Num.+
                                                                                              $dNum_sgNtI
                                                                                              sat_sgNug
                                                                                              sat_sgNuj;
                                                                              } in 
                                                                                GHC.Real./
                                                                                    $dFractional_sgNtK
                                                                                    u_sgNua
                                                                                    sat_sgNuk;
                                                                    } in 
                                                                      case
                                                                          GHC.Float.log1p
                                                                              $dFloating_sgNu9
                                                                              sat_sgNul
                                                                      of
                                                                      dt_sgNum
                                                                      { __DEFAULT ->
                                                                            let {
                                                                              sat_sgNuo [Occ=Once]
                                                                                :: a_agsO1
                                                                              [LclId] =
                                                                                  [ww7_sgNtE
                                                                                   $dNum_sgNtI] \u []
                                                                                      let {
                                                                                        sat_sgNun [Occ=Once]
                                                                                          :: a_agsO1
                                                                                        [LclId] =
                                                                                            [$dNum_sgNtI] \u []
                                                                                                GHC.Num.fromInteger
                                                                                                    $dNum_sgNtI
                                                                                                    Data.Complex.$fFloatingComplex19;
                                                                                      } in 
                                                                                        GHC.Num.+
                                                                                            $dNum_sgNtI
                                                                                            sat_sgNun
                                                                                            ww7_sgNtE;
                                                                            } in 
                                                                              case
                                                                                  GHC.Float.atan2
                                                                                      $dRealFloat_sgNtv
                                                                                      sat_sgNuo
                                                                                      ww8_sgNtF
                                                                              of
                                                                              dt1_sgNup
                                                                              { __DEFAULT ->
                                                                                    Data.Complex.:+ [dt_sgNum
                                                                                                     dt1_sgNup];
                                                                              };
                                                                      };
                                                              };
                                                        };
                                                };
                                        };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1pexp1 [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNuq]
        case eta_sgNuq of {
          Data.Complex.:+ x_sgNus [Occ=Once!] y_sgNut [Occ=Once!] ->
              case x_sgNus of {
                GHC.Types.F# x1_sgNuv [Occ=Once] ->
                    case y_sgNut of {
                      GHC.Types.F# x2_sgNux ->
                          case expFloat# [x1_sgNuv] of expx_sgNuy [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosFloat# [x2_sgNux] of sat_sgNuA {
                                  __DEFAULT ->
                                      case
                                          timesFloat# [expx_sgNuy sat_sgNuA]
                                      of
                                      a_sgNuz [Dmd=<S,U>]
                                      { __DEFAULT ->
                                            case sinFloat# [x2_sgNux] of sat_sgNuC {
                                              __DEFAULT ->
                                                  case
                                                      timesFloat# [expx_sgNuy sat_sgNuC]
                                                  of
                                                  b_sgNuB [Dmd=<S,U>]
                                                  { __DEFAULT ->
                                                        case fabsFloat# [a_sgNuz] of sat_sgNuK {
                                                          __DEFAULT ->
                                                              let-no-escape {
                                                                $j_sgNuD [Occ=Once*T[0],
                                                                          Dmd=<L,1*U(U,U)>]
                                                                  :: Data.Complex.Complex
                                                                       GHC.Types.Float
                                                                [LclId[JoinId(0)],
                                                                 Str=m,
                                                                 Unf=OtherCon []] =
                                                                    [a_sgNuz b_sgNuB] \r []
                                                                        case
                                                                            plusFloat# [1.0#
                                                                                        a_sgNuz]
                                                                        of
                                                                        dt_sgNuE [Dmd=<S,U>]
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  Data.Complex.$w$smagnitude1
                                                                                      dt_sgNuE
                                                                                      b_sgNuB
                                                                              of
                                                                              ww_sgNuF
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        logFloat# [ww_sgNuF]
                                                                                    of
                                                                                    wild3_sgNuG
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$sphase1
                                                                                                  dt_sgNuE
                                                                                                  b_sgNuB
                                                                                          of
                                                                                          ww1_sgNuH
                                                                                          { __DEFAULT ->
                                                                                                let {
                                                                                                  sat_sgNuJ [Occ=Once]
                                                                                                    :: GHC.Types.Float
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.F#! [ww1_sgNuH]; } in
                                                                                                let {
                                                                                                  sat_sgNuI [Occ=Once]
                                                                                                    :: GHC.Types.Float
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.F#! [wild3_sgNuG];
                                                                                                } in 
                                                                                                  Data.Complex.:+ [sat_sgNuI
                                                                                                                   sat_sgNuJ];
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                              } in 
                                                                case ltFloat# [sat_sgNuK 0.5#] of {
                                                                  __DEFAULT -> $j_sgNuD;
                                                                  1# ->
                                                                      case
                                                                          fabsFloat# [b_sgNuB]
                                                                      of
                                                                      sat_sgNuM
                                                                      { __DEFAULT ->
                                                                            case
                                                                                ltFloat# [sat_sgNuM
                                                                                          0.5#]
                                                                            of
                                                                            { __DEFAULT -> $j_sgNuD;
                                                                              1# ->
                                                                                  case
                                                                                      timesFloat# [b_sgNuB
                                                                                                   b_sgNuB]
                                                                                  of
                                                                                  sat_sgNuS
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            timesFloat# [a_sgNuz
                                                                                                         a_sgNuz]
                                                                                        of
                                                                                        sat_sgNuQ
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  plusFloat# [a_sgNuz
                                                                                                              a_sgNuz]
                                                                                              of
                                                                                              sat_sgNuP
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        plusFloat# [sat_sgNuP
                                                                                                                    sat_sgNuQ]
                                                                                                    of
                                                                                                    sat_sgNuR
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              plusFloat# [sat_sgNuR
                                                                                                                          sat_sgNuS]
                                                                                                          of
                                                                                                          u_sgNuO [Dmd=<S,U>]
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    plusFloat# [u_sgNuO
                                                                                                                                1.0#]
                                                                                                                of
                                                                                                                sat_sgNuT
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          sqrtFloat# [sat_sgNuT]
                                                                                                                      of
                                                                                                                      sat_sgNuU
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                plusFloat# [1.0#
                                                                                                                                            sat_sgNuU]
                                                                                                                            of
                                                                                                                            sat_sgNuV
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      divideFloat# [u_sgNuO
                                                                                                                                                    sat_sgNuV]
                                                                                                                                  of
                                                                                                                                  wild3_sgNuW
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            __pkg_ccall base-4.11.0.0 [wild3_sgNuW
                                                                                                                                                                       GHC.Prim.realWorld#]
                                                                                                                                        of
                                                                                                                                        { Unit# ds4_sgNv0 [Occ=Once] ->
                                                                                                                                              case
                                                                                                                                                  plusFloat# [1.0#
                                                                                                                                                              a_sgNuz]
                                                                                                                                              of
                                                                                                                                              sat_sgNv1
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    let {
                                                                                                                                                      sat_sgNv2 [Occ=Once]
                                                                                                                                                        :: GHC.Types.Float
                                                                                                                                                      [LclId] =
                                                                                                                                                          CCCS GHC.Types.F#! [sat_sgNv1];
                                                                                                                                                    } in 
                                                                                                                                                      case
                                                                                                                                                          GHC.Float.$w$catan1
                                                                                                                                                              sat_sgNv2
                                                                                                                                                              b_sgNuB
                                                                                                                                                      of
                                                                                                                                                      ww2_sgNv3
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgNv5 [Occ=Once]
                                                                                                                                                                :: GHC.Types.Float
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.F#! [ww2_sgNv3]; } in
                                                                                                                                                            let {
                                                                                                                                                              sat_sgNv4 [Occ=Once]
                                                                                                                                                                :: GHC.Types.Float
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.F#! [ds4_sgNv0];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgNv4
                                                                                                                                                                               sat_sgNv5];
                                                                                                                                                      };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNv6]
        case eta_sgNv6 of {
          Data.Complex.:+ x_sgNv8 [Occ=Once!] y_sgNv9 [Occ=Once!] ->
              case x_sgNv8 of {
                GHC.Types.D# x1_sgNvb [Occ=Once] ->
                    case y_sgNv9 of {
                      GHC.Types.D# x2_sgNvd ->
                          case expDouble# [x1_sgNvb] of expx_sgNve [Dmd=<S,U>] {
                            __DEFAULT ->
                                case cosDouble# [x2_sgNvd] of sat_sgNvg {
                                  __DEFAULT ->
                                      case *## [expx_sgNve sat_sgNvg] of a_sgNvf [Dmd=<S,U>] {
                                        __DEFAULT ->
                                            case sinDouble# [x2_sgNvd] of sat_sgNvi {
                                              __DEFAULT ->
                                                  case
                                                      *## [expx_sgNve sat_sgNvi]
                                                  of
                                                  b_sgNvh [Dmd=<S,U>]
                                                  { __DEFAULT ->
                                                        case fabsDouble# [a_sgNvf] of sat_sgNvq {
                                                          __DEFAULT ->
                                                              let-no-escape {
                                                                $j_sgNvj [Occ=Once*T[0],
                                                                          Dmd=<L,1*U(U,U)>]
                                                                  :: Data.Complex.Complex
                                                                       GHC.Types.Double
                                                                [LclId[JoinId(0)],
                                                                 Str=m,
                                                                 Unf=OtherCon []] =
                                                                    [a_sgNvf b_sgNvh] \r []
                                                                        case
                                                                            +## [1.0## a_sgNvf]
                                                                        of
                                                                        dt_sgNvk [Dmd=<S,U>]
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  Data.Complex.$w$smagnitude
                                                                                      dt_sgNvk
                                                                                      b_sgNvh
                                                                              of
                                                                              ww_sgNvl
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        logDouble# [ww_sgNvl]
                                                                                    of
                                                                                    wild3_sgNvm
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              Data.Complex.$w$sphase
                                                                                                  dt_sgNvk
                                                                                                  b_sgNvh
                                                                                          of
                                                                                          ww1_sgNvn
                                                                                          { __DEFAULT ->
                                                                                                let {
                                                                                                  sat_sgNvp [Occ=Once]
                                                                                                    :: GHC.Types.Double
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.D#! [ww1_sgNvn]; } in
                                                                                                let {
                                                                                                  sat_sgNvo [Occ=Once]
                                                                                                    :: GHC.Types.Double
                                                                                                  [LclId] =
                                                                                                      CCCS GHC.Types.D#! [wild3_sgNvm];
                                                                                                } in 
                                                                                                  Data.Complex.:+ [sat_sgNvo
                                                                                                                   sat_sgNvp];
                                                                                          };
                                                                                    };
                                                                              };
                                                                        };
                                                              } in 
                                                                case <## [sat_sgNvq 0.5##] of {
                                                                  __DEFAULT -> $j_sgNvj;
                                                                  1# ->
                                                                      case
                                                                          fabsDouble# [b_sgNvh]
                                                                      of
                                                                      sat_sgNvs
                                                                      { __DEFAULT ->
                                                                            case
                                                                                <## [sat_sgNvs
                                                                                     0.5##]
                                                                            of
                                                                            { __DEFAULT -> $j_sgNvj;
                                                                              1# ->
                                                                                  case
                                                                                      *## [b_sgNvh
                                                                                           b_sgNvh]
                                                                                  of
                                                                                  sat_sgNvy
                                                                                  { __DEFAULT ->
                                                                                        case
                                                                                            *## [a_sgNvf
                                                                                                 a_sgNvf]
                                                                                        of
                                                                                        sat_sgNvw
                                                                                        { __DEFAULT ->
                                                                                              case
                                                                                                  +## [a_sgNvf
                                                                                                       a_sgNvf]
                                                                                              of
                                                                                              sat_sgNvv
                                                                                              { __DEFAULT ->
                                                                                                    case
                                                                                                        +## [sat_sgNvv
                                                                                                             sat_sgNvw]
                                                                                                    of
                                                                                                    sat_sgNvx
                                                                                                    { __DEFAULT ->
                                                                                                          case
                                                                                                              +## [sat_sgNvx
                                                                                                                   sat_sgNvy]
                                                                                                          of
                                                                                                          u_sgNvu [Dmd=<S,U>]
                                                                                                          { __DEFAULT ->
                                                                                                                case
                                                                                                                    +## [u_sgNvu
                                                                                                                         1.0##]
                                                                                                                of
                                                                                                                sat_sgNvz
                                                                                                                { __DEFAULT ->
                                                                                                                      case
                                                                                                                          sqrtDouble# [sat_sgNvz]
                                                                                                                      of
                                                                                                                      sat_sgNvA
                                                                                                                      { __DEFAULT ->
                                                                                                                            case
                                                                                                                                +## [1.0##
                                                                                                                                     sat_sgNvA]
                                                                                                                            of
                                                                                                                            sat_sgNvB
                                                                                                                            { __DEFAULT ->
                                                                                                                                  case
                                                                                                                                      /## [u_sgNvu
                                                                                                                                           sat_sgNvB]
                                                                                                                                  of
                                                                                                                                  wild3_sgNvC
                                                                                                                                  { __DEFAULT ->
                                                                                                                                        case
                                                                                                                                            __pkg_ccall base-4.11.0.0 [wild3_sgNvC
                                                                                                                                                                       GHC.Prim.realWorld#]
                                                                                                                                        of
                                                                                                                                        { Unit# ds4_sgNvG [Occ=Once] ->
                                                                                                                                              case
                                                                                                                                                  +## [1.0##
                                                                                                                                                       a_sgNvf]
                                                                                                                                              of
                                                                                                                                              sat_sgNvH
                                                                                                                                              { __DEFAULT ->
                                                                                                                                                    let {
                                                                                                                                                      sat_sgNvI [Occ=Once]
                                                                                                                                                        :: GHC.Types.Double
                                                                                                                                                      [LclId] =
                                                                                                                                                          CCCS GHC.Types.D#! [sat_sgNvH];
                                                                                                                                                    } in 
                                                                                                                                                      case
                                                                                                                                                          GHC.Float.$w$catan2
                                                                                                                                                              sat_sgNvI
                                                                                                                                                              b_sgNvh
                                                                                                                                                      of
                                                                                                                                                      ww2_sgNvJ
                                                                                                                                                      { __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sgNvL [Occ=Once]
                                                                                                                                                                :: GHC.Types.Double
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.D#! [ww2_sgNvJ]; } in
                                                                                                                                                            let {
                                                                                                                                                              sat_sgNvK [Occ=Once]
                                                                                                                                                                :: GHC.Types.Double
                                                                                                                                                              [LclId] =
                                                                                                                                                                  CCCS GHC.Types.D#! [ds4_sgNvG];
                                                                                                                                                            } in 
                                                                                                                                                              Data.Complex.:+ [sat_sgNvK
                                                                                                                                                                               sat_sgNvL];
                                                                                                                                                      };
                                                                                                                                              };
                                                                                                                                        };
                                                                                                                                  };
                                                                                                                            };
                                                                                                                      };
                                                                                                                };
                                                                                                          };
                                                                                                    };
                                                                                              };
                                                                                        };
                                                                                  };
                                                                            };
                                                                      };
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLC(C(S))LLLL)S(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgNvM eta_sgNvN]
        case eta_sgNvN of {
          Data.Complex.:+ ww1_sgNvP [Occ=Once] ww2_sgNvQ [Occ=Once] ->
              case
                  Data.Complex.$w$cexp $dRealFloat_sgNvM ww1_sgNvP ww2_sgNvQ
              of
              { (#,#) ww4_sgNvS ww5_sgNvT ->
                    case
                        GHC.Float.$p1RealFloat $dRealFloat_sgNvM
                    of
                    $dRealFrac_sgNvU [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
                    { __DEFAULT ->
                          case
                              GHC.Real.$p1RealFrac $dRealFrac_sgNvU
                          of
                          $dReal_sgNvV [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
                          { __DEFAULT ->
                                let {
                                  $dNum_sgNvW [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
                                    :: GHC.Num.Num a_agsO1
                                  [LclId] =
                                      [$dReal_sgNvV] \u [] GHC.Real.$p1Real $dReal_sgNvV;
                                } in 
                                  case
                                      GHC.Real.$p2Real $dReal_sgNvV
                                  of
                                  $dOrd_sgNvX [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                                  { __DEFAULT ->
                                        let {
                                          $dFractional_sgNvY [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
                                            :: GHC.Real.Fractional a_agsO1
                                          [LclId] =
                                              [$dRealFrac_sgNvU] \u []
                                                  GHC.Real.$p2RealFrac $dRealFrac_sgNvU; } in
                                        let {
                                          sat_sgNw0 [Occ=Once] :: a_agsO1
                                          [LclId] =
                                              [$dFractional_sgNvY] \u []
                                                  GHC.Real.fromRational
                                                      $dFractional_sgNvY
                                                      Data.Complex.$fFloatingComplex20; } in
                                        let {
                                          sat_sgNvZ [Occ=Once] :: a_agsO1
                                          [LclId] =
                                              [ww4_sgNvS $dNum_sgNvW] \u []
                                                  GHC.Num.abs $dNum_sgNvW ww4_sgNvS;
                                        } in 
                                          case GHC.Classes.< $dOrd_sgNvX sat_sgNvZ sat_sgNw0 of {
                                            GHC.Types.False ->
                                                case
                                                    Data.Complex.$w$cfromInteger
                                                        $dRealFloat_sgNvM
                                                        Data.Complex.$fFloatingComplex19
                                                of
                                                { (#,#) ww7_sgNw3 [Occ=Once] ww8_sgNw4 [Occ=Once] ->
                                                      case
                                                          Data.Complex.$w$c+
                                                              $dRealFloat_sgNvM
                                                              ww7_sgNw3
                                                              ww8_sgNw4
                                                              ww4_sgNvS
                                                              ww5_sgNvT
                                                      of
                                                      { (#,#) ww10_sgNw6 [Occ=Once]
                                                              ww11_sgNw7 [Occ=Once] ->
                                                            case
                                                                Data.Complex.$w$clog
                                                                    $dRealFloat_sgNvM
                                                                    ww10_sgNw6
                                                                    ww11_sgNw7
                                                            of
                                                            { (#,#) ww13_sgNw9 [Occ=Once]
                                                                    ww14_sgNwa [Occ=Once] ->
                                                                  Data.Complex.:+ [ww13_sgNw9
                                                                                   ww14_sgNwa];
                                                            };
                                                      };
                                                };
                                            GHC.Types.True ->
                                                let {
                                                  sat_sgNwc [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [$dFractional_sgNvY] \u []
                                                          GHC.Real.fromRational
                                                              $dFractional_sgNvY
                                                              Data.Complex.$fFloatingComplex20; } in
                                                let {
                                                  sat_sgNwb [Occ=Once] :: a_agsO1
                                                  [LclId] =
                                                      [ww5_sgNvT $dNum_sgNvW] \u []
                                                          GHC.Num.abs $dNum_sgNvW ww5_sgNvT;
                                                } in 
                                                  case
                                                      GHC.Classes.< $dOrd_sgNvX sat_sgNwb sat_sgNwc
                                                  of
                                                  { GHC.Types.False ->
                                                        case
                                                            Data.Complex.$w$cfromInteger
                                                                $dRealFloat_sgNvM
                                                                Data.Complex.$fFloatingComplex19
                                                        of
                                                        { (#,#) ww7_sgNwf [Occ=Once]
                                                                ww8_sgNwg [Occ=Once] ->
                                                              case
                                                                  Data.Complex.$w$c+
                                                                      $dRealFloat_sgNvM
                                                                      ww7_sgNwf
                                                                      ww8_sgNwg
                                                                      ww4_sgNvS
                                                                      ww5_sgNvT
                                                              of
                                                              { (#,#) ww10_sgNwi [Occ=Once]
                                                                      ww11_sgNwj [Occ=Once] ->
                                                                    case
                                                                        Data.Complex.$w$clog
                                                                            $dRealFloat_sgNvM
                                                                            ww10_sgNwi
                                                                            ww11_sgNwj
                                                                    of
                                                                    { (#,#) ww13_sgNwl [Occ=Once]
                                                                            ww14_sgNwm [Occ=Once] ->
                                                                          Data.Complex.:+ [ww13_sgNwl
                                                                                           ww14_sgNwm];
                                                                    };
                                                              };
                                                        };
                                                    GHC.Types.True ->
                                                        case
                                                            GHC.Float.$p2RealFloat $dRealFloat_sgNvM
                                                        of
                                                        $dFloating_sgNwn [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                                                        { __DEFAULT ->
                                                              let {
                                                                sat_sgNwz [Occ=Once] :: a_agsO1
                                                                [LclId] =
                                                                    [ww4_sgNvS
                                                                     ww5_sgNvT
                                                                     $dNum_sgNvW
                                                                     $dFractional_sgNvY
                                                                     $dFloating_sgNwn] \u []
                                                                        let {
                                                                          u_sgNwo :: a_agsO1
                                                                          [LclId] =
                                                                              [ww4_sgNvS
                                                                               ww5_sgNvT
                                                                               $dNum_sgNvW] \u []
                                                                                  let {
                                                                                    sat_sgNwt [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [ww5_sgNvT
                                                                                         $dNum_sgNvW] \u []
                                                                                            GHC.Num.*
                                                                                                $dNum_sgNvW
                                                                                                ww5_sgNvT
                                                                                                ww5_sgNvT; } in
                                                                                  let {
                                                                                    sat_sgNws [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [ww4_sgNvS
                                                                                         $dNum_sgNvW] \u []
                                                                                            let {
                                                                                              sat_sgNwr [Occ=Once]
                                                                                                :: a_agsO1
                                                                                              [LclId] =
                                                                                                  [ww4_sgNvS
                                                                                                   $dNum_sgNvW] \u []
                                                                                                      GHC.Num.*
                                                                                                          $dNum_sgNvW
                                                                                                          ww4_sgNvS
                                                                                                          ww4_sgNvS; } in
                                                                                            let {
                                                                                              sat_sgNwq [Occ=Once]
                                                                                                :: a_agsO1
                                                                                              [LclId] =
                                                                                                  [ww4_sgNvS
                                                                                                   $dNum_sgNvW] \u []
                                                                                                      let {
                                                                                                        sat_sgNwp [Occ=Once]
                                                                                                          :: a_agsO1
                                                                                                        [LclId] =
                                                                                                            [$dNum_sgNvW] \u []
                                                                                                                GHC.Num.fromInteger
                                                                                                                    $dNum_sgNvW
                                                                                                                    Data.Complex.$fFloatingComplex21;
                                                                                                      } in 
                                                                                                        GHC.Num.*
                                                                                                            $dNum_sgNvW
                                                                                                            sat_sgNwp
                                                                                                            ww4_sgNvS;
                                                                                            } in 
                                                                                              GHC.Num.+
                                                                                                  $dNum_sgNvW
                                                                                                  sat_sgNwq
                                                                                                  sat_sgNwr;
                                                                                  } in 
                                                                                    GHC.Num.+
                                                                                        $dNum_sgNvW
                                                                                        sat_sgNws
                                                                                        sat_sgNwt; } in
                                                                        let {
                                                                          sat_sgNwy [Occ=Once]
                                                                            :: a_agsO1
                                                                          [LclId] =
                                                                              [$dNum_sgNvW
                                                                               $dFloating_sgNwn
                                                                               u_sgNwo] \u []
                                                                                  let {
                                                                                    sat_sgNwx [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [$dNum_sgNvW
                                                                                         $dFloating_sgNwn
                                                                                         u_sgNwo] \u []
                                                                                            let {
                                                                                              sat_sgNww [Occ=Once]
                                                                                                :: a_agsO1
                                                                                              [LclId] =
                                                                                                  [$dNum_sgNvW
                                                                                                   u_sgNwo] \u []
                                                                                                      let {
                                                                                                        sat_sgNwv [Occ=Once]
                                                                                                          :: a_agsO1
                                                                                                        [LclId] =
                                                                                                            [$dNum_sgNvW] \u []
                                                                                                                GHC.Num.fromInteger
                                                                                                                    $dNum_sgNvW
                                                                                                                    Data.Complex.$fFloatingComplex19;
                                                                                                      } in 
                                                                                                        GHC.Num.+
                                                                                                            $dNum_sgNvW
                                                                                                            u_sgNwo
                                                                                                            sat_sgNwv;
                                                                                            } in 
                                                                                              GHC.Float.sqrt
                                                                                                  $dFloating_sgNwn
                                                                                                  sat_sgNww; } in
                                                                                  let {
                                                                                    sat_sgNwu [Occ=Once]
                                                                                      :: a_agsO1
                                                                                    [LclId] =
                                                                                        [$dNum_sgNvW] \u []
                                                                                            GHC.Num.fromInteger
                                                                                                $dNum_sgNvW
                                                                                                Data.Complex.$fFloatingComplex19;
                                                                                  } in 
                                                                                    GHC.Num.+
                                                                                        $dNum_sgNvW
                                                                                        sat_sgNwu
                                                                                        sat_sgNwx;
                                                                        } in 
                                                                          GHC.Real./
                                                                              $dFractional_sgNvY
                                                                              u_sgNwo
                                                                              sat_sgNwy;
                                                              } in 
                                                                case
                                                                    GHC.Float.log1p
                                                                        $dFloating_sgNwn sat_sgNwz
                                                                of
                                                                dt_sgNwA
                                                                { __DEFAULT ->
                                                                      let {
                                                                        sat_sgNwC [Occ=Once]
                                                                          :: a_agsO1
                                                                        [LclId] =
                                                                            [ww4_sgNvS
                                                                             $dNum_sgNvW] \u []
                                                                                let {
                                                                                  sat_sgNwB [Occ=Once]
                                                                                    :: a_agsO1
                                                                                  [LclId] =
                                                                                      [$dNum_sgNvW] \u []
                                                                                          GHC.Num.fromInteger
                                                                                              $dNum_sgNvW
                                                                                              Data.Complex.$fFloatingComplex19;
                                                                                } in 
                                                                                  GHC.Num.+
                                                                                      $dNum_sgNvW
                                                                                      sat_sgNwB
                                                                                      ww4_sgNvS;
                                                                      } in 
                                                                        case
                                                                            GHC.Float.atan2
                                                                                $dRealFloat_sgNvM
                                                                                sat_sgNwC
                                                                                ww5_sgNvT
                                                                        of
                                                                        dt1_sgNwD
                                                                        { __DEFAULT ->
                                                                              Data.Complex.:+ [dt_sgNwA
                                                                                               dt1_sgNwD];
                                                                        };
                                                                };
                                                        };
                                                  };
                                          };
                                  };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clogBase1 [InlPrag=INLINE (sat-args=2)]
  :: Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
     -> Data.Complex.Complex GHC.Types.Float
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNwE eta1_sgNwF]
        case eta1_sgNwF of {
          Data.Complex.:+ ww1_sgNwH [Occ=Once!] ww2_sgNwI [Occ=Once!] ->
              case ww1_sgNwH of {
                GHC.Types.F# ww4_sgNwK ->
                    case ww2_sgNwI of {
                      GHC.Types.F# ww6_sgNwM ->
                          case Data.Complex.$w$smagnitude1 ww4_sgNwK ww6_sgNwM of ww7_sgNwN {
                            __DEFAULT ->
                                case logFloat# [ww7_sgNwN] of wild1_sgNwO {
                                  __DEFAULT ->
                                      case
                                          Data.Complex.$w$sphase1 ww4_sgNwK ww6_sgNwM
                                      of
                                      ww8_sgNwP
                                      { __DEFAULT ->
                                            case eta_sgNwE of {
                                              Data.Complex.:+ ww10_sgNwR [Occ=Once!]
                                                              ww11_sgNwS [Occ=Once!] ->
                                                  case ww10_sgNwR of {
                                                    GHC.Types.F# ww13_sgNwU ->
                                                        case ww11_sgNwS of {
                                                          GHC.Types.F# ww15_sgNwW ->
                                                              case
                                                                  Data.Complex.$w$smagnitude1
                                                                      ww13_sgNwU ww15_sgNwW
                                                              of
                                                              ww16_sgNwX
                                                              { __DEFAULT ->
                                                                    case
                                                                        logFloat# [ww16_sgNwX]
                                                                    of
                                                                    wild2_sgNwY
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$sphase1
                                                                                  ww13_sgNwU
                                                                                  ww15_sgNwW
                                                                          of
                                                                          ww17_sgNwZ
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/1
                                                                                        wild1_sgNwO
                                                                                        ww8_sgNwP
                                                                                        wild2_sgNwY
                                                                                        ww17_sgNwZ
                                                                                of
                                                                                { (#,#) ww19_sgNx1 [Occ=Once]
                                                                                        ww20_sgNx2 [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww19_sgNx1
                                                                                                       ww20_sgNx2];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$clogBase [InlPrag=INLINE (sat-args=2)]
  :: Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
     -> Data.Complex.Complex GHC.Types.Double
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=OtherCon []] =
    [] \r [eta_sgNx3 eta1_sgNx4]
        case eta1_sgNx4 of {
          Data.Complex.:+ ww1_sgNx6 [Occ=Once!] ww2_sgNx7 [Occ=Once!] ->
              case ww1_sgNx6 of {
                GHC.Types.D# ww4_sgNx9 ->
                    case ww2_sgNx7 of {
                      GHC.Types.D# ww6_sgNxb ->
                          case Data.Complex.$w$smagnitude ww4_sgNx9 ww6_sgNxb of ww7_sgNxc {
                            __DEFAULT ->
                                case logDouble# [ww7_sgNxc] of wild1_sgNxd {
                                  __DEFAULT ->
                                      case Data.Complex.$w$sphase ww4_sgNx9 ww6_sgNxb of ww8_sgNxe {
                                        __DEFAULT ->
                                            case eta_sgNx3 of {
                                              Data.Complex.:+ ww10_sgNxg [Occ=Once!]
                                                              ww11_sgNxh [Occ=Once!] ->
                                                  case ww10_sgNxg of {
                                                    GHC.Types.D# ww13_sgNxj ->
                                                        case ww11_sgNxh of {
                                                          GHC.Types.D# ww15_sgNxl ->
                                                              case
                                                                  Data.Complex.$w$smagnitude
                                                                      ww13_sgNxj ww15_sgNxl
                                                              of
                                                              ww16_sgNxm
                                                              { __DEFAULT ->
                                                                    case
                                                                        logDouble# [ww16_sgNxm]
                                                                    of
                                                                    wild2_sgNxn
                                                                    { __DEFAULT ->
                                                                          case
                                                                              Data.Complex.$w$sphase
                                                                                  ww13_sgNxj
                                                                                  ww15_sgNxl
                                                                          of
                                                                          ww17_sgNxo
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    Data.Complex.$w$s$c/
                                                                                        wild1_sgNxd
                                                                                        ww8_sgNxe
                                                                                        wild2_sgNxn
                                                                                        ww17_sgNxo
                                                                                of
                                                                                { (#,#) ww19_sgNxq [Occ=Once]
                                                                                        ww20_sgNxr [Occ=Once] ->
                                                                                      Data.Complex.:+ [ww19_sgNxq
                                                                                                       ww20_sgNxr];
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$clogBase [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Float.RealFloat a =>
     Data.Complex.Complex a
     -> Data.Complex.Complex a -> Data.Complex.Complex a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_sgNxs eta_sgNxt eta1_sgNxu]
        case eta1_sgNxu of {
          Data.Complex.:+ ww1_sgNxw [Occ=Once] ww2_sgNxx [Occ=Once] ->
              case
                  Data.Complex.$w$clog $dRealFloat_sgNxs ww1_sgNxw ww2_sgNxx
              of
              { (#,#) ww4_sgNxz [Occ=Once] ww5_sgNxA [Occ=Once] ->
                    case eta_sgNxt of {
                      Data.Complex.:+ ww7_sgNxC [Occ=Once] ww8_sgNxD [Occ=Once] ->
                          case
                              Data.Complex.$w$clog $dRealFloat_sgNxs ww7_sgNxC ww8_sgNxD
                          of
                          { (#,#) ww10_sgNxF [Occ=Once] ww11_sgNxG [Occ=Once] ->
                                case
                                    Data.Complex.$w$c/
                                        $dRealFloat_sgNxs ww4_sgNxz ww5_sgNxA ww10_sgNxF ww11_sgNxG
                                of
                                { (#,#) ww13_sgNxI [Occ=Once] ww14_sgNxJ [Occ=Once] ->
                                      Data.Complex.:+ [ww13_sgNxI ww14_sgNxJ];
                                };
                          };
                    };
              };
        };

Data.Complex.$fFloatingComplex_$s$fFloatingComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Float.Floating (Data.Complex.Complex GHC.Types.Float)
[GblId] =
    CCS_DONT_CARE GHC.Float.C:Floating! [Data.Complex.$fFloatingComplex_$s$fFractionalComplex1
                                         Data.Complex.$fFloatingComplex_$s$cpi1
                                         Data.Complex.$fFloatingComplex_$s$cexp1
                                         Data.Complex.$fFloatingComplex_$s$clog1
                                         Data.Complex.$fFloatingComplex_$s$csqrt1
                                         Data.Complex.$fFloatingComplex_$s$c**1
                                         Data.Complex.$fFloatingComplex_$s$clogBase1
                                         Data.Complex.$fFloatingComplex_$s$csin1
                                         Data.Complex.$fFloatingComplex_$s$ccos1
                                         Data.Complex.$fFloatingComplex_$s$ctan1
                                         Data.Complex.$fFloatingComplex_$s$casin1
                                         Data.Complex.$fFloatingComplex_$s$cacos1
                                         Data.Complex.$fFloatingComplex_$s$catan1
                                         Data.Complex.$fFloatingComplex_$s$csinh1
                                         Data.Complex.$fFloatingComplex_$s$ccosh1
                                         Data.Complex.$fFloatingComplex_$s$ctanh1
                                         Data.Complex.$fFloatingComplex_$s$casinh1
                                         Data.Complex.$fFloatingComplex_$s$cacosh1
                                         Data.Complex.$fFloatingComplex_$s$catanh1
                                         Data.Complex.$fFloatingComplex_$s$clog1p1
                                         Data.Complex.$fFloatingComplex_$s$cexpm2
                                         Data.Complex.$fFloatingComplex_$s$clog1pexp1
                                         Data.Complex.$fFloatingComplex_$s$clog1mexp1];

Data.Complex.$fFloatingComplex_$s$fFloatingComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Float.Floating (Data.Complex.Complex GHC.Types.Double)
[GblId] =
    CCS_DONT_CARE GHC.Float.C:Floating! [Data.Complex.$fFloatingComplex_$s$fFractionalComplex
                                         Data.Complex.$fFloatingComplex_$s$cpi
                                         Data.Complex.$fFloatingComplex_$s$cexp
                                         Data.Complex.$fFloatingComplex_$s$clog
                                         Data.Complex.$fFloatingComplex_$s$csqrt
                                         Data.Complex.$fFloatingComplex_$s$c**
                                         Data.Complex.$fFloatingComplex_$s$clogBase
                                         Data.Complex.$fFloatingComplex_$s$csin
                                         Data.Complex.$fFloatingComplex_$s$ccos
                                         Data.Complex.$fFloatingComplex_$s$ctan
                                         Data.Complex.$fFloatingComplex_$s$casin
                                         Data.Complex.$fFloatingComplex_$s$cacos
                                         Data.Complex.$fFloatingComplex_$s$catan
                                         Data.Complex.$fFloatingComplex_$s$csinh
                                         Data.Complex.$fFloatingComplex_$s$ccosh
                                         Data.Complex.$fFloatingComplex_$s$ctanh
                                         Data.Complex.$fFloatingComplex_$s$casinh
                                         Data.Complex.$fFloatingComplex_$s$cacosh
                                         Data.Complex.$fFloatingComplex_$s$catanh
                                         Data.Complex.$fFloatingComplex_$s$clog1p
                                         Data.Complex.$fFloatingComplex_$s$cexpm1
                                         Data.Complex.$fFloatingComplex_$s$clog1pexp
                                         Data.Complex.$fFloatingComplex_$s$clog1mexp];

Data.Complex.$fFloatingComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Float.Floating (Data.Complex.Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,U,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))>] =
    [] \r [$dRealFloat_sgNxK]
        let {
          sat_sgNy7 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog1mexp
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy6 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog1pexp
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy5 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cexpm1
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy4 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog1p
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy3 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$catanh
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy2 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cacosh
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy1 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$casinh
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNy0 [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ctanh
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxZ [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ccosh
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxY [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$csinh
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxX [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$catan
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxW [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cacos
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxV [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$casin
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxU [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ctan $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxT [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$ccos $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxS [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$csin $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxR [Occ=Once]
            :: Data.Complex.Complex a_agsO1
               -> Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$clogBase
                      $dRealFloat_sgNxK eta_B2 eta_B1; } in
        let {
          sat_sgNxQ [Occ=Once]
            :: Data.Complex.Complex a_agsO1
               -> Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B2 eta_B1]
                  Data.Complex.$fFloatingComplex_$c**
                      $dRealFloat_sgNxK eta_B2 eta_B1; } in
        let {
          sat_sgNxP [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$csqrt
                      $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxO [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$clog $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxN [Occ=Once]
            :: Data.Complex.Complex a_agsO1 -> Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \r [eta_B1]
                  Data.Complex.$fFloatingComplex_$cexp $dRealFloat_sgNxK eta_B1; } in
        let {
          sat_sgNxM [Occ=Once] :: Data.Complex.Complex a_agsO1
          [LclId] =
              [$dRealFloat_sgNxK] \u []
                  Data.Complex.$fFloatingComplex_$cpi $dRealFloat_sgNxK; } in
        let {
          sat_sgNxL [Occ=Once]
            :: GHC.Real.Fractional (Data.Complex.Complex a_agsO1)
          [LclId] =
              [$dRealFloat_sgNxK] \u []
                  Data.Complex.$fFractionalComplex $dRealFloat_sgNxK;
        } in 
          GHC.Float.C:Floating [sat_sgNxL
                                sat_sgNxM
                                sat_sgNxN
                                sat_sgNxO
                                sat_sgNxP
                                sat_sgNxQ
                                sat_sgNxR
                                sat_sgNxS
                                sat_sgNxT
                                sat_sgNxU
                                sat_sgNxV
                                sat_sgNxW
                                sat_sgNxX
                                sat_sgNxY
                                sat_sgNxZ
                                sat_sgNy0
                                sat_sgNy1
                                sat_sgNy2
                                sat_sgNy3
                                sat_sgNy4
                                sat_sgNy5
                                sat_sgNy6
                                sat_sgNy7];

Data.Complex.:+ :: forall a. a -> a -> Data.Complex.Complex a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Complex.:+ [eta_B2 eta_B1];

