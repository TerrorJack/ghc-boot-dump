
==================== Tidy Core ====================
2018-03-16 16:12:26.090949515 UTC

Result size of Tidy Core
  = {terms: 8,476, types: 8,311, coercions: 899, joins: 22/250}

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
Data.Complex.$W:+ [InlPrag=INLINE[2]]
  :: forall a. a -> a -> Complex a
[GblId[DataConWrapper],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsns)
                 (dt_agsqe [Occ=Once] :: a_agsns[sk:1])
                 (dt_agsqf [Occ=Once] :: a_agsns[sk:1]) ->
                 case dt_agsqe of dt_Xgsqi { __DEFAULT ->
                 case dt_agsqf of dt_Xgsqk { __DEFAULT ->
                 Data.Complex.:+ @ a_agsns dt_Xgsqi dt_Xgsqk
                 }
                 }}]
Data.Complex.$W:+
  = \ (@ a_agsns)
      (dt_agsqe [Occ=Once] :: a_agsns[sk:1])
      (dt_agsqf [Occ=Once] :: a_agsns[sk:1]) ->
      case dt_agsqe of dt_Xgsqi { __DEFAULT ->
      case dt_agsqf of dt_Xgsqk { __DEFAULT ->
      Data.Complex.:+ @ a_agsns dt_Xgsqi dt_Xgsqk
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fStorableComplex2 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Complex.$fStorableComplex2 = GHC.Types.I# 1#

-- RHS size: {terms: 21, types: 28, coercions: 20, joins: 0/0}
Data.Complex.$fStorableComplex1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Storable a =>
     GHC.Ptr.Ptr (Complex a)
     -> Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,U><S(SS),1*U(U,U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxs3)
                 (w_sgxs4 :: Storable a_sgxs3)
                 (w1_sgxs5 :: GHC.Ptr.Ptr (Complex a_sgxs3))
                 (w2_sgxs6 [Occ=Once!] :: Complex a_sgxs3)
                 (w3_sgxs7 [Occ=Once] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w2_sgxs6 of { :+ ww1_sgxsa [Occ=Once] ww2_sgxsb [Occ=Once] ->
                 case ((poke
                          @ a_sgxs3
                          w_sgxs4
                          (w1_sgxs5
                           `cast` ((GHC.Ptr.Ptr
                                      Univ(phantom phantom <*>_N :: Complex a_sgxs3, a_sgxs3))_R
                                   :: (GHC.Ptr.Ptr (Complex a_sgxs3) :: *)
                                      ~R# (GHC.Ptr.Ptr a_sgxs3 :: *)))
                          ww1_sgxsa)
                       `cast` (GHC.Types.N:IO[0] <()>_R
                               :: (IO () :: *)
                                  ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                                       -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)))
                        w3_sgxs7
                 of
                 { (# ipv_i7JiK [Occ=Once], _ [Occ=Dead] #) ->
                 ((pokeElemOff
                     @ a_sgxs3
                     w_sgxs4
                     (w1_sgxs5
                      `cast` ((GHC.Ptr.Ptr
                                 Univ(phantom phantom <*>_N :: Complex a_sgxs3, a_sgxs3))_R
                              :: (GHC.Ptr.Ptr (Complex a_sgxs3) :: *)
                                 ~R# (GHC.Ptr.Ptr a_sgxs3 :: *)))
                     Data.Complex.$fStorableComplex2
                     ww2_sgxsb)
                  `cast` (GHC.Types.N:IO[0] <()>_R
                          :: (IO () :: *)
                             ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)))
                   ipv_i7JiK
                 }
                 }}]
Data.Complex.$fStorableComplex1
  = \ (@ a_sgxs3)
      (w_sgxs4 :: Storable a_sgxs3)
      (w1_sgxs5 :: GHC.Ptr.Ptr (Complex a_sgxs3))
      (w2_sgxs6 :: Complex a_sgxs3)
      (w3_sgxs7 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      case w2_sgxs6 of { :+ ww1_sgxsa ww2_sgxsb ->
      case ((poke
               @ a_sgxs3
               w_sgxs4
               (w1_sgxs5
                `cast` ((GHC.Ptr.Ptr
                           Univ(phantom phantom <*>_N :: Complex a_sgxs3, a_sgxs3))_R
                        :: (GHC.Ptr.Ptr (Complex a_sgxs3) :: *)
                           ~R# (GHC.Ptr.Ptr a_sgxs3 :: *)))
               ww1_sgxsa)
            `cast` (GHC.Types.N:IO[0] <()>_R
                    :: (IO () :: *)
                       ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)))
             w3_sgxs7
      of
      { (# ipv_i7JiK, ipv1_i7JiL #) ->
      ((pokeElemOff
          @ a_sgxs3
          w_sgxs4
          (w1_sgxs5
           `cast` ((GHC.Ptr.Ptr
                      Univ(phantom phantom <*>_N :: Complex a_sgxs3, a_sgxs3))_R
                   :: (GHC.Ptr.Ptr (Complex a_sgxs3) :: *)
                      ~R# (GHC.Ptr.Ptr a_sgxs3 :: *)))
          Data.Complex.$fStorableComplex2
          ww2_sgxsb)
       `cast` (GHC.Types.N:IO[0] <()>_R
               :: (IO () :: *)
                  ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                       -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)))
        ipv_i7JiK
      }
      }

-- RHS size: {terms: 22, types: 42, coercions: 20, joins: 0/0}
Data.Complex.$fStorableComplex3
  :: forall a.
     Storable a =>
     GHC.Ptr.Ptr (Complex a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Complex a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,1*C1(C1(C1(U(U,U)))),A,A,A,1*C1(C1(U(U,U))),A)><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 140 30}]
Data.Complex.$fStorableComplex3
  = \ (@ a_XgsQ1)
      ($dStorable_XgsQ3 :: Storable a_XgsQ1)
      (p_agsnJ :: GHC.Ptr.Ptr (Complex a_XgsQ1))
      (s_i7IAv :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      case ((peek
               @ a_XgsQ1
               $dStorable_XgsQ3
               (p_agsnJ
                `cast` ((GHC.Ptr.Ptr
                           Univ(phantom phantom <*>_N :: Complex a_XgsQ1, a_XgsQ1))_R
                        :: (GHC.Ptr.Ptr (Complex a_XgsQ1) :: *)
                           ~R# (GHC.Ptr.Ptr a_XgsQ1 :: *))))
            `cast` (GHC.Types.N:IO[0] <a_XgsQ1>_R
                    :: (IO a_XgsQ1 :: *)
                       ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, a_XgsQ1 #) :: *)))
             s_i7IAv
      of
      { (# ipv_X7IDS, ipv1_X7IDU #) ->
      case ((peekElemOff
               @ a_XgsQ1
               $dStorable_XgsQ3
               (p_agsnJ
                `cast` ((GHC.Ptr.Ptr
                           Univ(phantom phantom <*>_N :: Complex a_XgsQ1, a_XgsQ1))_R
                        :: (GHC.Ptr.Ptr (Complex a_XgsQ1) :: *)
                           ~R# (GHC.Ptr.Ptr a_XgsQ1 :: *)))
               Data.Complex.$fStorableComplex2)
            `cast` (GHC.Types.N:IO[0] <a_XgsQ1>_R
                    :: (IO a_XgsQ1 :: *)
                       ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, a_XgsQ1 #) :: *)))
             ipv_X7IDS
      of
      { (# ipv2_X7IDY, ipv3_X7IE0 #) ->
      (# ipv2_X7IDY, Data.Complex.$W:+ @ a_XgsQ1 ipv1_X7IDU ipv3_X7IE0 #)
      }
      }

-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
Data.Complex.$fApplicativeComplex_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c) -> Complex a -> Complex b -> Complex c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxsi)
                 (@ b_sgxsj)
                 (@ c_sgxsk)
                 (w_sgxsl :: a_sgxsi -> b_sgxsj -> c_sgxsk)
                 (w1_sgxsm [Occ=Once!] :: Complex a_sgxsi)
                 (w2_sgxsn [Occ=Once!] :: Complex b_sgxsj) ->
                 case w1_sgxsm of { :+ ww1_sgxsq [Occ=Once] ww2_sgxsr [Occ=Once] ->
                 case w2_sgxsn of { :+ ww4_sgxsv [Occ=Once] ww5_sgxsw [Occ=Once] ->
                 case w_sgxsl ww1_sgxsq ww4_sgxsv of dt_Xgsqi { __DEFAULT ->
                 case w_sgxsl ww2_sgxsr ww5_sgxsw of dt1_Xgsxk { __DEFAULT ->
                 Data.Complex.:+ @ c_sgxsk dt_Xgsqi dt1_Xgsxk
                 }
                 }
                 }
                 }}]
Data.Complex.$fApplicativeComplex_$cliftA2
  = \ (@ a_sgxsi)
      (@ b_sgxsj)
      (@ c_sgxsk)
      (w_sgxsl :: a_sgxsi -> b_sgxsj -> c_sgxsk)
      (w1_sgxsm :: Complex a_sgxsi)
      (w2_sgxsn :: Complex b_sgxsj) ->
      case w1_sgxsm of { :+ ww1_sgxsq ww2_sgxsr ->
      case w2_sgxsn of { :+ ww4_sgxsv ww5_sgxsw ->
      case w_sgxsl ww1_sgxsq ww4_sgxsv of dt_Xgsqi { __DEFAULT ->
      case w_sgxsl ww2_sgxsr ww5_sgxsw of dt1_Xgsxk { __DEFAULT ->
      Data.Complex.:+ @ c_sgxsk dt_Xgsqi dt1_Xgsxk
      }
      }
      }
      }

-- RHS size: {terms: 21, types: 23, coercions: 0, joins: 0/0}
Data.Complex.$fApplicativeComplex_$c<*>
  :: forall a b. Complex (a -> b) -> Complex a -> Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)C(S)),1*U(C1(U),C1(U))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsLP)
                 (@ b_agsLQ)
                 (ds_dgta2 [Occ=Once!] :: Complex (a_agsLP -> b_agsLQ))
                 (ds1_dgta3 [Occ=Once!] :: Complex a_agsLP) ->
                 case ds_dgta2 of { :+ f_agsnx [Occ=Once!] g_agsny [Occ=Once!] ->
                 case ds1_dgta3 of { :+ a1_agsnz [Occ=Once] b1_agsnA [Occ=Once] ->
                 case f_agsnx a1_agsnz of dt_Xgsqi { __DEFAULT ->
                 case g_agsny b1_agsnA of dt1_Xgsxj { __DEFAULT ->
                 Data.Complex.:+ @ b_agsLQ dt_Xgsqi dt1_Xgsxj
                 }
                 }
                 }
                 }}]
Data.Complex.$fApplicativeComplex_$c<*>
  = \ (@ a_agsLP)
      (@ b_agsLQ)
      (ds_dgta2 :: Complex (a_agsLP -> b_agsLQ))
      (ds1_dgta3 :: Complex a_agsLP) ->
      case ds_dgta2 of { :+ f_agsnx g_agsny ->
      case ds1_dgta3 of { :+ a1_agsnz b1_agsnA ->
      case f_agsnx a1_agsnz of dt_Xgsqi { __DEFAULT ->
      case g_agsny b1_agsnA of dt1_Xgsxj { __DEFAULT ->
      Data.Complex.:+ @ b_agsLQ dt_Xgsqi dt1_Xgsxj
      }
      }
      }
      }

-- RHS size: {terms: 5, types: 4, coercions: 0, joins: 0/0}
Data.Complex.$fApplicativeComplex_$cpure
  :: forall a. a -> Complex a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsLJ) (a1_agsnw :: a_agsLJ) ->
                 Data.Complex.$W:+ @ a_agsLJ a1_agsnw a1_agsnw}]
Data.Complex.$fApplicativeComplex_$cpure
  = \ (@ a_agsLJ) (a1_agsnw :: a_agsLJ) ->
      Data.Complex.$W:+ @ a_agsLJ a1_agsnw a1_agsnw

-- RHS size: {terms: 16, types: 25, coercions: 0, joins: 0/0}
Data.Complex.$fTraversableComplex_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Complex a -> f (Complex b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_agsK7 :: * -> *))
                 (@ a_agsK8)
                 (@ b_agsK9)
                 ($dApplicative_agsKb [Occ=Once] :: Applicative f_agsK7)
                 (f1_agsuc :: a_agsK8 -> f_agsK7 b_agsK9)
                 (ds_dgt9T [Occ=Once!] :: Complex a_agsK8) ->
                 case ds_dgt9T of { :+ a1_agsud [Occ=Once] a2_agsue [Occ=Once] ->
                 liftA2
                   @ f_agsK7
                   $dApplicative_agsKb
                   @ b_agsK9
                   @ b_agsK9
                   @ (Complex b_agsK9)
                   (Data.Complex.$W:+ @ b_agsK9)
                   (f1_agsuc a1_agsud)
                   (f1_agsuc a2_agsue)
                 }}]
Data.Complex.$fTraversableComplex_$ctraverse
  = \ (@ (f_agsK7 :: * -> *))
      (@ a_agsK8)
      (@ b_agsK9)
      ($dApplicative_agsKb :: Applicative f_agsK7)
      (f1_agsuc :: a_agsK8 -> f_agsK7 b_agsK9)
      (ds_dgt9T :: Complex a_agsK8) ->
      case ds_dgt9T of { :+ a1_agsud a2_agsue ->
      liftA2
        @ f_agsK7
        $dApplicative_agsKb
        @ b_agsK9
        @ b_agsK9
        @ (Complex b_agsK9)
        (Data.Complex.$W:+ @ b_agsK9)
        (f1_agsuc a1_agsud)
        (f1_agsuc a2_agsue)
      }

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
Data.Complex.$fFoldableComplex_$cnull
  :: forall a. Complex a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsIW) (ds_dgt9P [Occ=Once!] :: Complex a_agsIW) ->
                 case ds_dgt9P of { :+ _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.False
                 }}]
Data.Complex.$fFoldableComplex_$cnull
  = \ (@ a_agsIW) (ds_dgt9P :: Complex a_agsIW) ->
      case ds_dgt9P of { :+ ds1_dgt9Q ds2_dgt9R -> GHC.Types.False }

-- RHS size: {terms: 13, types: 14, coercions: 0, joins: 0/0}
Data.Complex.$fFoldableComplex_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsHY)
                 (@ b_agsHZ)
                 (f_agsu5 :: a_agsHY -> b_agsHZ -> b_agsHZ)
                 (z_agsu6 [Occ=Once] :: b_agsHZ)
                 (ds_dgt9N [Occ=Once!] :: Complex a_agsHY) ->
                 case ds_dgt9N of { :+ a1_agsu7 [Occ=Once] a2_agsu8 [Occ=Once] ->
                 f_agsu5 a1_agsu7 (f_agsu5 a2_agsu8 z_agsu6)
                 }}]
Data.Complex.$fFoldableComplex_$cfoldr
  = \ (@ a_agsHY)
      (@ b_agsHZ)
      (f_agsu5 :: a_agsHY -> b_agsHZ -> b_agsHZ)
      (z_agsu6 :: b_agsHZ)
      (ds_dgt9N :: Complex a_agsHY) ->
      case ds_dgt9N of { :+ a1_agsu7 a2_agsu8 ->
      f_agsu5 a1_agsu7 (f_agsu5 a2_agsu8 z_agsu6)
      }

-- RHS size: {terms: 14, types: 15, coercions: 0, joins: 0/0}
Data.Complex.$fFoldableComplex_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> Complex a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_agsHO)
                 (@ a_agsHP)
                 ($dMonoid_agsHR [Occ=Once] :: Monoid m_agsHO)
                 (f_agsu9 :: a_agsHP -> m_agsHO)
                 (ds_dgt9L [Occ=Once!] :: Complex a_agsHP) ->
                 case ds_dgt9L of { :+ a1_agsua [Occ=Once] a2_agsub [Occ=Once] ->
                 mappend
                   @ m_agsHO $dMonoid_agsHR (f_agsu9 a1_agsua) (f_agsu9 a2_agsub)
                 }}]
Data.Complex.$fFoldableComplex_$cfoldMap
  = \ (@ m_agsHO)
      (@ a_agsHP)
      ($dMonoid_agsHR :: Monoid m_agsHO)
      (f_agsu9 :: a_agsHP -> m_agsHO)
      (ds_dgt9L :: Complex a_agsHP) ->
      case ds_dgt9L of { :+ a1_agsua a2_agsub ->
      mappend
        @ m_agsHO $dMonoid_agsHR (f_agsu9 a1_agsua) (f_agsu9 a2_agsub)
      }

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFoldableComplex_$cfold
  :: forall m. Monoid m => Complex m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_agsHE)
                 ($dMonoid_agsHG [Occ=Once] :: Monoid m_agsHE)
                 (ds_dgt9L [Occ=Once!] :: Complex m_agsHE) ->
                 case ds_dgt9L of { :+ a1_agsua [Occ=Once] a2_agsub [Occ=Once] ->
                 mappend @ m_agsHE $dMonoid_agsHG a1_agsua a2_agsub
                 }}]
Data.Complex.$fFoldableComplex_$cfold
  = \ (@ m_agsHE)
      ($dMonoid_agsHG :: Monoid m_agsHE)
      (ds_dgt9L :: Complex m_agsHE) ->
      case ds_dgt9L of { :+ a1_agsua a2_agsub ->
      mappend @ m_agsHE $dMonoid_agsHG a1_agsua a2_agsub
      }

-- RHS size: {terms: 10, types: 11, coercions: 3, joins: 0/0}
Data.Complex.$fFoldableComplex2
  :: forall a. Num a => Complex a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsJD)
                 ($dNum_agsJF [Occ=Once] :: Num a_agsJD)
                 (ds_dgt9L [Occ=Once!] :: Complex a_agsJD) ->
                 case ds_dgt9L of { :+ a1_agsua [Occ=Once] a2_agsub [Occ=Once] ->
                 (+ @ a_agsJD $dNum_agsJF a1_agsua a2_agsub)
                 `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_agsJD>_R)
                         :: (a_agsJD :: *) ~R# (Data.Semigroup.Internal.Sum a_agsJD :: *))
                 }}]
Data.Complex.$fFoldableComplex2
  = \ (@ a_agsJD)
      ($dNum_agsJF :: Num a_agsJD)
      (ds_dgt9L :: Complex a_agsJD) ->
      case ds_dgt9L of { :+ a1_agsua a2_agsub ->
      (+ @ a_agsJD $dNum_agsJF a1_agsua a2_agsub)
      `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_agsJD>_R)
              :: (a_agsJD :: *) ~R# (Data.Semigroup.Internal.Sum a_agsJD :: *))
      }

-- RHS size: {terms: 15, types: 12, coercions: 0, joins: 0/0}
Data.Complex.$fFoldableComplex_$cminimum
  :: forall a. Ord a => Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsJt)
                 ($dOrd_agsJv [Occ=Once] :: Ord a_agsJt)
                 (x_ifzGk [Occ=Once!] :: Complex a_agsJt) ->
                 case x_ifzGk of { :+ a1_agsua a2_agsub ->
                 case <= @ a_agsJt $dOrd_agsJv a1_agsua a2_agsub of {
                   False -> a2_agsub;
                   True -> a1_agsua
                 }
                 }}]
Data.Complex.$fFoldableComplex_$cminimum
  = \ (@ a_agsJt)
      ($dOrd_agsJv :: Ord a_agsJt)
      (x_ifzGk :: Complex a_agsJt) ->
      case x_ifzGk of { :+ a1_agsua a2_agsub ->
      case <= @ a_agsJt $dOrd_agsJv a1_agsua a2_agsub of {
        False -> a2_agsub;
        True -> a1_agsua
      }
      }

-- RHS size: {terms: 15, types: 12, coercions: 0, joins: 0/0}
Data.Complex.$fFoldableComplex_$cmaximum
  :: forall a. Ord a => Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsJj)
                 ($dOrd_agsJl [Occ=Once] :: Ord a_agsJj)
                 (x_ifzG6 [Occ=Once!] :: Complex a_agsJj) ->
                 case x_ifzG6 of { :+ a1_agsua a2_agsub ->
                 case >= @ a_agsJj $dOrd_agsJl a1_agsua a2_agsub of {
                   False -> a2_agsub;
                   True -> a1_agsua
                 }
                 }}]
Data.Complex.$fFoldableComplex_$cmaximum
  = \ (@ a_agsJj)
      ($dOrd_agsJl :: Ord a_agsJj)
      (x_ifzG6 :: Complex a_agsJj) ->
      case x_ifzG6 of { :+ a1_agsua a2_agsub ->
      case >= @ a_agsJj $dOrd_agsJl a1_agsua a2_agsub of {
        False -> a2_agsub;
        True -> a1_agsua
      }
      }

-- RHS size: {terms: 19, types: 15, coercions: 8, joins: 0/1}
Data.Complex.$fFoldableComplex_$celem
  :: forall a. Eq a => a -> Complex a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 120 60}]
Data.Complex.$fFoldableComplex_$celem
  = \ (@ a_agsJ9) ($dEq_agsJb :: Eq a_agsJ9) (eta_B1 :: a_agsJ9) ->
      let {
        f_sgunQ [Dmd=<L,C(U)>] :: a_agsJ9 -> Bool
        [LclId]
        f_sgunQ = == @ a_agsJ9 $dEq_agsJb eta_B1 } in
      (\ (ds_dgt9L :: Complex a_agsJ9) ->
         case ds_dgt9L of { :+ a1_agsua a2_agsub ->
         case f_sgunQ a1_agsua of {
           False ->
             (f_sgunQ a2_agsub)
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Data.Semigroup.Internal.Any :: *));
           True ->
             GHC.Types.True
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Data.Semigroup.Internal.Any :: *))
         }
         })
      `cast` (<Complex a_agsJ9>_R ->_R Data.Semigroup.Internal.N:Any[0]
              :: (Complex a_agsJ9 -> Data.Semigroup.Internal.Any :: *)
                 ~R# (Complex a_agsJ9 -> Bool :: *))

-- RHS size: {terms: 9, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFoldableComplex_$cfoldr1
  :: forall a. (a -> a -> a) -> Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsIy)
                 (f_ifzEZ [Occ=Once!] :: a_agsIy -> a_agsIy -> a_agsIy)
                 (xs_ifzF0 [Occ=Once!] :: Complex a_agsIy) ->
                 case xs_ifzF0 of { :+ a1_agsu7 [Occ=Once] a2_agsu8 [Occ=Once] ->
                 f_ifzEZ a1_agsu7 a2_agsu8
                 }}]
Data.Complex.$fFoldableComplex_$cfoldr1
  = \ (@ a_agsIy)
      (f_ifzEZ :: a_agsIy -> a_agsIy -> a_agsIy)
      (xs_ifzF0 :: Complex a_agsIy) ->
      case xs_ifzF0 of { :+ a1_agsu7 a2_agsu8 ->
      f_ifzEZ a1_agsu7 a2_agsu8
      }

-- RHS size: {terms: 16, types: 15, coercions: 0, joins: 0/0}
Data.Complex.$fFoldableComplex_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_agsIo)
                 (@ a_agsIp)
                 (f_ifzEP :: b_agsIo -> a_agsIp -> b_agsIo)
                 (z0_ifzEQ [Occ=Once] :: b_agsIo)
                 (xs_ifzER [Occ=Once!] :: Complex a_agsIp) ->
                 case xs_ifzER of { :+ a1_agsu7 [Occ=Once] a2_agsu8 [Occ=Once] ->
                 case f_ifzEP z0_ifzEQ a1_agsu7 of vx_ifzEV { __DEFAULT ->
                 f_ifzEP vx_ifzEV a2_agsu8
                 }
                 }}]
Data.Complex.$fFoldableComplex_$cfoldl'
  = \ (@ b_agsIo)
      (@ a_agsIp)
      (f_ifzEP :: b_agsIo -> a_agsIp -> b_agsIo)
      (z0_ifzEQ :: b_agsIo)
      (xs_ifzER :: Complex a_agsIp) ->
      case xs_ifzER of { :+ a1_agsu7 a2_agsu8 ->
      case f_ifzEP z0_ifzEQ a1_agsu7 of vx_ifzEV { __DEFAULT ->
      f_ifzEP vx_ifzEV a2_agsu8
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl_rgA6e :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl_rgA6e = GHC.Types.I# 2#

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
Data.Complex.$fFoldableComplex_$clength
  :: forall a. Complex a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsJ1) (xs_ifzER [Occ=Once!] :: Complex a_agsJ1) ->
                 case xs_ifzER of { :+ _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.I# 2#
                 }}]
Data.Complex.$fFoldableComplex_$clength
  = \ (@ a_agsJ1) (xs_ifzER :: Complex a_agsJ1) ->
      case xs_ifzER of { :+ a1_agsu7 a2_agsu8 -> lvl_rgA6e }

-- RHS size: {terms: 13, types: 14, coercions: 0, joins: 0/0}
Data.Complex.$fFoldableComplex_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_agsIe)
                 (@ a_agsIf)
                 (f_XfzIf :: b_agsIe -> a_agsIf -> b_agsIe)
                 (z_XfzIh [Occ=Once] :: b_agsIe)
                 (t1_XfzIj [Occ=Once!] :: Complex a_agsIf) ->
                 case t1_XfzIj of { :+ a1_agsua [Occ=Once] a2_agsub [Occ=Once] ->
                 f_XfzIf (f_XfzIf z_XfzIh a1_agsua) a2_agsub
                 }}]
Data.Complex.$fFoldableComplex_$cfoldl
  = \ (@ b_agsIe)
      (@ a_agsIf)
      (f_XfzIf :: b_agsIe -> a_agsIf -> b_agsIe)
      (z_XfzIh :: b_agsIe)
      (t1_XfzIj :: Complex a_agsIf) ->
      case t1_XfzIj of { :+ a1_agsua a2_agsub ->
      f_XfzIf (f_XfzIf z_XfzIh a1_agsua) a2_agsub
      }

-- RHS size: {terms: 16, types: 15, coercions: 0, joins: 0/0}
Data.Complex.$fFoldableComplex_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Complex a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsI4)
                 (@ b_agsI5)
                 (f_ifzEu :: a_agsI4 -> b_agsI5 -> b_agsI5)
                 (z0_ifzEv [Occ=Once] :: b_agsI5)
                 (xs_ifzEw [Occ=Once!] :: Complex a_agsI4) ->
                 case xs_ifzEw of { :+ a1_agsua [Occ=Once] a2_agsub [Occ=Once] ->
                 case f_ifzEu a2_agsub z0_ifzEv of vx_ifzEA { __DEFAULT ->
                 f_ifzEu a1_agsua vx_ifzEA
                 }
                 }}]
Data.Complex.$fFoldableComplex_$cfoldr'
  = \ (@ a_agsI4)
      (@ b_agsI5)
      (f_ifzEu :: a_agsI4 -> b_agsI5 -> b_agsI5)
      (z0_ifzEv :: b_agsI5)
      (xs_ifzEw :: Complex a_agsI4) ->
      case xs_ifzEw of { :+ a1_agsua a2_agsub ->
      case f_ifzEu a2_agsub z0_ifzEv of vx_ifzEA { __DEFAULT ->
      f_ifzEu a1_agsua vx_ifzEA
      }
      }

-- RHS size: {terms: 10, types: 11, coercions: 3, joins: 0/0}
Data.Complex.$fFoldableComplex1
  :: forall a.
     Num a =>
     Complex a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsJN)
                 ($dNum_agsJP [Occ=Once] :: Num a_agsJN)
                 (ds_dgt9L [Occ=Once!] :: Complex a_agsJN) ->
                 case ds_dgt9L of { :+ a1_agsua [Occ=Once] a2_agsub [Occ=Once] ->
                 (* @ a_agsJN $dNum_agsJP a1_agsua a2_agsub)
                 `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_agsJN>_R)
                         :: (a_agsJN :: *)
                            ~R# (Data.Semigroup.Internal.Product a_agsJN :: *))
                 }}]
Data.Complex.$fFoldableComplex1
  = \ (@ a_agsJN)
      ($dNum_agsJP :: Num a_agsJN)
      (ds_dgt9L :: Complex a_agsJN) ->
      case ds_dgt9L of { :+ a1_agsua a2_agsub ->
      (* @ a_agsJN $dNum_agsJP a1_agsua a2_agsub)
      `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_agsJN>_R)
              :: (a_agsJN :: *)
                 ~R# (Data.Semigroup.Internal.Product a_agsJN :: *))
      }

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFoldableComplex_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Complex a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_agsIO) (t1_ifzFB [Occ=Once] :: Complex a_agsIO) ->
                 GHC.Base.build
                   @ a_agsIO
                   (\ (@ b_ifzFC)
                      (c_ifzFD [Occ=Once, OS=OneShot] :: a_agsIO -> b_ifzFC -> b_ifzFC)
                      (n_ifzFE [Occ=Once, OS=OneShot] :: b_ifzFC) ->
                      Data.Complex.$fFoldableComplex_$cfoldr
                        @ a_agsIO @ b_ifzFC c_ifzFD n_ifzFE t1_ifzFB)}]
Data.Complex.$fFoldableComplex_$ctoList
  = \ (@ a_agsIO) (eta_B1 :: Complex a_agsIO) ->
      case eta_B1 of { :+ a1_agsu7 a2_agsu8 ->
      GHC.Types.:
        @ a_agsIO
        a1_agsu7
        (GHC.Types.: @ a_agsIO a2_agsu8 (GHC.Types.[] @ a_agsIO))
      }

-- RHS size: {terms: 17, types: 1, coercions: 22, joins: 0/0}
Data.Complex.$fFoldableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable Complex
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Complex
                                Data.Complex.$fFoldableComplex_$cfold
                                Data.Complex.$fFoldableComplex_$cfoldMap
                                Data.Complex.$fFoldableComplex_$cfoldr
                                Data.Complex.$fFoldableComplex_$cfoldr'
                                Data.Complex.$fFoldableComplex_$cfoldl
                                Data.Complex.$fFoldableComplex_$cfoldl'
                                Data.Complex.$fFoldableComplex_$cfoldr1
                                Data.Complex.$fFoldableComplex_$cfoldr1
                                Data.Complex.$fFoldableComplex_$ctoList
                                Data.Complex.$fFoldableComplex_$cnull
                                Data.Complex.$fFoldableComplex_$clength
                                Data.Complex.$fFoldableComplex_$celem
                                Data.Complex.$fFoldableComplex_$cmaximum
                                Data.Complex.$fFoldableComplex_$cminimum
                                Data.Complex.$fFoldableComplex2
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Complex a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a.
                                            Num a =>
                                            Complex a -> Data.Semigroup.Internal.Sum a :: *)
                                           ~R# (forall a. Num a => Complex a -> a :: *))
                                Data.Complex.$fFoldableComplex1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Complex a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a.
                                            Num a =>
                                            Complex a -> Data.Semigroup.Internal.Product a :: *)
                                           ~R# (forall a. Num a => Complex a -> a :: *))]
Data.Complex.$fFoldableComplex
  = Data.Foldable.C:Foldable
      @ Complex
      Data.Complex.$fFoldableComplex_$cfold
      Data.Complex.$fFoldableComplex_$cfoldMap
      Data.Complex.$fFoldableComplex_$cfoldr
      Data.Complex.$fFoldableComplex_$cfoldr'
      Data.Complex.$fFoldableComplex_$cfoldl
      Data.Complex.$fFoldableComplex_$cfoldl'
      Data.Complex.$fFoldableComplex_$cfoldr1
      Data.Complex.$fFoldableComplex_$cfoldr1
      Data.Complex.$fFoldableComplex_$ctoList
      Data.Complex.$fFoldableComplex_$cnull
      Data.Complex.$fFoldableComplex_$clength
      Data.Complex.$fFoldableComplex_$celem
      Data.Complex.$fFoldableComplex_$cmaximum
      Data.Complex.$fFoldableComplex_$cminimum
      (Data.Complex.$fFoldableComplex2
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Complex a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a.
                   Num a =>
                   Complex a -> Data.Semigroup.Internal.Sum a :: *)
                  ~R# (forall a. Num a => Complex a -> a :: *)))
      (Data.Complex.$fFoldableComplex1
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Complex a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a.
                   Num a =>
                   Complex a -> Data.Semigroup.Internal.Product a :: *)
                  ~R# (forall a. Num a => Complex a -> a :: *)))

-- RHS size: {terms: 10, types: 12, coercions: 0, joins: 0/0}
Data.Complex.$fFunctorComplex_$c<$
  :: forall a b. a -> Complex b -> Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsHh)
                 (@ b_agsHi)
                 (z_agsu0 :: a_agsHh)
                 (ds_dgt9J [Occ=Once!] :: Complex b_agsHi) ->
                 case ds_dgt9J of { :+ _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Complex.$W:+ @ a_agsHh z_agsu0 z_agsu0
                 }}]
Data.Complex.$fFunctorComplex_$c<$
  = \ (@ a_agsHh)
      (@ b_agsHi)
      (z_agsu0 :: a_agsHh)
      (ds_dgt9J :: Complex b_agsHi) ->
      case ds_dgt9J of { :+ a1_agsu1 a2_agsu2 ->
      Data.Complex.$W:+ @ a_agsHh z_agsu0 z_agsu0
      }

-- RHS size: {terms: 18, types: 15, coercions: 0, joins: 0/0}
Data.Complex.$fFunctorComplex_$cfmap
  :: forall a b. (a -> b) -> Complex a -> Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsHa)
                 (@ b_agsHb)
                 (f_agstX :: a_agsHa -> b_agsHb)
                 (ds_dgt9H [Occ=Once!] :: Complex a_agsHa) ->
                 case ds_dgt9H of { :+ a1_agstY [Occ=Once] a2_agstZ [Occ=Once] ->
                 case f_agstX a1_agstY of dt_Xgsqi { __DEFAULT ->
                 case f_agstX a2_agstZ of dt1_Xgsxy { __DEFAULT ->
                 Data.Complex.:+ @ b_agsHb dt_Xgsqi dt1_Xgsxy
                 }
                 }
                 }}]
Data.Complex.$fFunctorComplex_$cfmap
  = \ (@ a_agsHa)
      (@ b_agsHb)
      (f_agstX :: a_agsHa -> b_agsHb)
      (ds_dgt9H :: Complex a_agsHa) ->
      case ds_dgt9H of { :+ a1_agstY a2_agstZ ->
      case f_agstX a1_agstY of dt_Xgsqi { __DEFAULT ->
      case f_agstX a2_agstZ of dt1_Xgsxy { __DEFAULT ->
      Data.Complex.:+ @ b_agsHb dt_Xgsqi dt1_Xgsxy
      }
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFunctorComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor Complex
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: Complex
                          Data.Complex.$fFunctorComplex_$cfmap
                          Data.Complex.$fFunctorComplex_$c<$]
Data.Complex.$fFunctorComplex
  = GHC.Base.C:Functor
      @ Complex
      Data.Complex.$fFunctorComplex_$cfmap
      Data.Complex.$fFunctorComplex_$c<$

-- RHS size: {terms: 12, types: 24, coercions: 0, joins: 0/0}
Data.Complex.$fTraversableComplex_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Complex (f a) -> f (Complex a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),1*U(A,A,A,1*C1(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_agsKm :: * -> *))
                 (@ a_agsKn)
                 ($dApplicative_agsKp [Occ=Once] :: Applicative f_agsKm)
                 (ds_dgt9T [Occ=Once!] :: Complex (f_agsKm a_agsKn)) ->
                 case ds_dgt9T of { :+ a1_agsud [Occ=Once] a2_agsue [Occ=Once] ->
                 liftA2
                   @ f_agsKm
                   $dApplicative_agsKp
                   @ a_agsKn
                   @ a_agsKn
                   @ (Complex a_agsKn)
                   (Data.Complex.$W:+ @ a_agsKn)
                   a1_agsud
                   a2_agsue
                 }}]
Data.Complex.$fTraversableComplex_$csequenceA
  = \ (@ (f_agsKm :: * -> *))
      (@ a_agsKn)
      ($dApplicative_agsKp :: Applicative f_agsKm)
      (ds_dgt9T :: Complex (f_agsKm a_agsKn)) ->
      case ds_dgt9T of { :+ a1_agsud a2_agsue ->
      liftA2
        @ f_agsKm
        $dApplicative_agsKp
        @ a_agsKn
        @ a_agsKn
        @ (Complex a_agsKn)
        (Data.Complex.$W:+ @ a_agsKn)
        a1_agsud
        a2_agsue
      }

-- RHS size: {terms: 17, types: 26, coercions: 0, joins: 0/0}
Data.Complex.$fTraversableComplex_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Complex a -> m (Complex b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_agsKy :: * -> *))
                 (@ a_agsKz)
                 (@ b_agsKA)
                 ($dMonad_agsKC [Occ=OnceL] :: Monad m_agsKy) ->
                 let {
                   $dApplicative_agsKb [Occ=OnceL] :: Applicative m_agsKy
                   [LclId]
                   $dApplicative_agsKb
                     = GHC.Base.$p1Monad @ m_agsKy $dMonad_agsKC } in
                 \ (f_agsuc :: a_agsKz -> m_agsKy b_agsKA)
                   (ds_dgt9T [Occ=Once!] :: Complex a_agsKz) ->
                   case ds_dgt9T of { :+ a1_agsud [Occ=Once] a2_agsue [Occ=Once] ->
                   liftA2
                     @ m_agsKy
                     $dApplicative_agsKb
                     @ b_agsKA
                     @ b_agsKA
                     @ (Complex b_agsKA)
                     (Data.Complex.$W:+ @ b_agsKA)
                     (f_agsuc a1_agsud)
                     (f_agsuc a2_agsue)
                   }}]
Data.Complex.$fTraversableComplex_$cmapM
  = \ (@ (m_agsKy :: * -> *))
      (@ a_agsKz)
      (@ b_agsKA)
      ($dMonad_agsKC :: Monad m_agsKy)
      (eta_B2 :: a_agsKz -> m_agsKy b_agsKA)
      (eta1_B1 :: Complex a_agsKz) ->
      case eta1_B1 of { :+ a1_agsud a2_agsue ->
      liftA2
        @ m_agsKy
        (GHC.Base.$p1Monad @ m_agsKy $dMonad_agsKC)
        @ b_agsKA
        @ b_agsKA
        @ (Complex b_agsKA)
        (Data.Complex.$W:+ @ b_agsKA)
        (eta_B2 a1_agsud)
        (eta_B2 a2_agsue)
      }

-- RHS size: {terms: 13, types: 25, coercions: 0, joins: 0/0}
Data.Complex.$fTraversableComplex_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     Monad m =>
     Complex (m a) -> m (Complex a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_agsKM :: * -> *))
                 (@ a_agsKN)
                 ($dMonad_agsKP [Occ=OnceL] :: Monad m_agsKM) ->
                 let {
                   $dApplicative_agsKp [Occ=OnceL] :: Applicative m_agsKM
                   [LclId]
                   $dApplicative_agsKp
                     = GHC.Base.$p1Monad @ m_agsKM $dMonad_agsKP } in
                 \ (ds_dgt9T [Occ=Once!] :: Complex (m_agsKM a_agsKN)) ->
                   case ds_dgt9T of { :+ a1_agsud [Occ=Once] a2_agsue [Occ=Once] ->
                   liftA2
                     @ m_agsKM
                     $dApplicative_agsKp
                     @ a_agsKN
                     @ a_agsKN
                     @ (Complex a_agsKN)
                     (Data.Complex.$W:+ @ a_agsKN)
                     a1_agsud
                     a2_agsue
                   }}]
Data.Complex.$fTraversableComplex_$csequence
  = \ (@ (m_agsKM :: * -> *))
      (@ a_agsKN)
      ($dMonad_agsKP :: Monad m_agsKM)
      (eta_B1 :: Complex (m_agsKM a_agsKN)) ->
      case eta_B1 of { :+ a1_agsud a2_agsue ->
      liftA2
        @ m_agsKM
        (GHC.Base.$p1Monad @ m_agsKM $dMonad_agsKP)
        @ a_agsKN
        @ a_agsKN
        @ (Complex a_agsKN)
        (Data.Complex.$W:+ @ a_agsKN)
        a1_agsud
        a2_agsue
      }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fTraversableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable Complex
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Complex
                                      Data.Complex.$fFunctorComplex
                                      Data.Complex.$fFoldableComplex
                                      Data.Complex.$fTraversableComplex_$ctraverse
                                      Data.Complex.$fTraversableComplex_$csequenceA
                                      Data.Complex.$fTraversableComplex_$cmapM
                                      Data.Complex.$fTraversableComplex_$csequence]
Data.Complex.$fTraversableComplex
  = Data.Traversable.C:Traversable
      @ Complex
      Data.Complex.$fFunctorComplex
      Data.Complex.$fFoldableComplex
      Data.Complex.$fTraversableComplex_$ctraverse
      Data.Complex.$fTraversableComplex_$csequenceA
      Data.Complex.$fTraversableComplex_$cmapM
      Data.Complex.$fTraversableComplex_$csequence

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Complex.$fApplicativeComplex_$c*>
  :: forall a b. Complex a -> Complex b -> Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsM4)
                 (@ b_agsM5)
                 (a1_ibJeW [Occ=Once!] :: Complex a_agsM4)
                 (a2_ibJeX [Occ=Once] :: Complex b_agsM5) ->
                 case a1_ibJeW of { :+ _ [Occ=Dead] _ [Occ=Dead] -> a2_ibJeX }}]
Data.Complex.$fApplicativeComplex_$c*>
  = \ (@ a_agsM4)
      (@ b_agsM5)
      (a1_ibJeW :: Complex a_agsM4)
      (a2_ibJeX :: Complex b_agsM5) ->
      case a1_ibJeW of { :+ a4_agsu1 a5_agsu2 -> a2_ibJeX }

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
Data.Complex.$fApplicativeComplex_$c<*
  :: forall a b. Complex a -> Complex b -> Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsMe)
                 (@ b_agsMf)
                 (ds_dgtad [Occ=Once!] :: Complex a_agsMe)
                 (ds1_dgtae [Occ=Once!] :: Complex b_agsMf) ->
                 case ds_dgtad of { :+ x_agsnC [Occ=Once] y_agsnD [Occ=Once] ->
                 case ds1_dgtae of { :+ _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Complex.:+ @ a_agsMe x_agsnC y_agsnD
                 }
                 }}]
Data.Complex.$fApplicativeComplex_$c<*
  = \ (@ a_agsMe)
      (@ b_agsMf)
      (ds_dgtad :: Complex a_agsMe)
      (ds1_dgtae :: Complex b_agsMf) ->
      case ds_dgtad of wild_X3m { :+ x_agsnC y_agsnD ->
      case ds1_dgtae of { :+ a1_agsnE b1_agsnF -> wild_X3m }
      }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fApplicativeComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative Complex
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: Complex
                              Data.Complex.$fFunctorComplex
                              Data.Complex.$fApplicativeComplex_$cpure
                              Data.Complex.$fApplicativeComplex_$c<*>
                              Data.Complex.$fApplicativeComplex_$cliftA2
                              Data.Complex.$fApplicativeComplex_$c*>
                              Data.Complex.$fApplicativeComplex_$c<*]
Data.Complex.$fApplicativeComplex
  = GHC.Base.C:Applicative
      @ Complex
      Data.Complex.$fFunctorComplex
      Data.Complex.$fApplicativeComplex_$cpure
      Data.Complex.$fApplicativeComplex_$c<*>
      Data.Complex.$fApplicativeComplex_$cliftA2
      Data.Complex.$fApplicativeComplex_$c*>
      Data.Complex.$fApplicativeComplex_$c<*

-- RHS size: {terms: 8, types: 58, coercions: 114, joins: 0/0}
Data.Complex.$fGeneric1Complex_$cto1
  :: forall a. GHC.Generics.Rep1 Complex a -> Complex a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsGy)
                 (ds_dgt9B [Occ=Once] :: GHC.Generics.Rep1 Complex a_agsGy) ->
                 case ds_dgt9B
                      `cast` ((Sub (Data.Complex.Rep1_Complex[0]) ; (GHC.Generics.N:M1[0]
                                                                         <*>_N
                                                                         <GHC.Generics.D>_P
                                                                         <'GHC.Generics.MetaData
                                                                            "Complex"
                                                                            "Data.Complex"
                                                                            "base"
                                                                            'False>_P
                                                                         <GHC.Generics.M1
                                                                            GHC.Generics.C
                                                                            ('GHC.Generics.MetaCons
                                                                               ":+"
                                                                               ('GHC.Generics.InfixI
                                                                                  'GHC.Generics.NotAssociative
                                                                                  6)
                                                                               'False)
                                                                            (GHC.Generics.M1
                                                                               GHC.Generics.S
                                                                               ('GHC.Generics.MetaSel
                                                                                  'Nothing
                                                                                  'GHC.Generics.NoSourceUnpackedness
                                                                                  'GHC.Generics.SourceStrict
                                                                                  'GHC.Generics.DecidedStrict)
                                                                               GHC.Generics.Par1
                                                                             GHC.Generics.:*: GHC.Generics.M1
                                                                                                GHC.Generics.S
                                                                                                ('GHC.Generics.MetaSel
                                                                                                   'Nothing
                                                                                                   'GHC.Generics.NoSourceUnpackedness
                                                                                                   'GHC.Generics.SourceStrict
                                                                                                   'GHC.Generics.DecidedStrict)
                                                                                                GHC.Generics.Par1)>_R ; GHC.Generics.N:M1[0]
                                                                                                                            <*>_N
                                                                                                                            <GHC.Generics.C>_P
                                                                                                                            <'GHC.Generics.MetaCons
                                                                                                                               ":+"
                                                                                                                               ('GHC.Generics.InfixI
                                                                                                                                  'GHC.Generics.NotAssociative
                                                                                                                                  6)
                                                                                                                               'False>_P
                                                                                                                            <GHC.Generics.M1
                                                                                                                               GHC.Generics.S
                                                                                                                               ('GHC.Generics.MetaSel
                                                                                                                                  'Nothing
                                                                                                                                  'GHC.Generics.NoSourceUnpackedness
                                                                                                                                  'GHC.Generics.SourceStrict
                                                                                                                                  'GHC.Generics.DecidedStrict)
                                                                                                                               GHC.Generics.Par1
                                                                                                                             GHC.Generics.:*: GHC.Generics.M1
                                                                                                                                                GHC.Generics.S
                                                                                                                                                ('GHC.Generics.MetaSel
                                                                                                                                                   'Nothing
                                                                                                                                                   'GHC.Generics.NoSourceUnpackedness
                                                                                                                                                   'GHC.Generics.SourceStrict
                                                                                                                                                   'GHC.Generics.DecidedStrict)
                                                                                                                                                GHC.Generics.Par1>_R)) <a_agsGy>_N
                              :: (GHC.Generics.Rep1 Complex a_agsGy :: *)
                                 ~R# ((GHC.Generics.:*:)
                                        (GHC.Generics.M1
                                           GHC.Generics.S
                                           ('GHC.Generics.MetaSel
                                              'Nothing
                                              'GHC.Generics.NoSourceUnpackedness
                                              'GHC.Generics.SourceStrict
                                              'GHC.Generics.DecidedStrict)
                                           GHC.Generics.Par1)
                                        (GHC.Generics.M1
                                           GHC.Generics.S
                                           ('GHC.Generics.MetaSel
                                              'Nothing
                                              'GHC.Generics.NoSourceUnpackedness
                                              'GHC.Generics.SourceStrict
                                              'GHC.Generics.DecidedStrict)
                                           GHC.Generics.Par1)
                                        a_agsGy :: *))
                 of
                 { GHC.Generics.:*: ds1_dgt9E [Occ=Once] ds2_dgt9F [Occ=Once] ->
                 Data.Complex.$W:+
                   @ a_agsGy
                   (ds1_dgt9E
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N
                                <GHC.Generics.S>_P
                                <'GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.SourceStrict
                                   'GHC.Generics.DecidedStrict>_P
                                <GHC.Generics.Par1>_R <a_agsGy>_N ; GHC.Generics.N:Par1[0]
                                                                        <a_agsGy>_R
                            :: (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.SourceStrict
                                     'GHC.Generics.DecidedStrict)
                                  GHC.Generics.Par1
                                  a_agsGy :: *)
                               ~R# (a_agsGy :: *)))
                   (ds2_dgt9F
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N
                                <GHC.Generics.S>_P
                                <'GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.SourceStrict
                                   'GHC.Generics.DecidedStrict>_P
                                <GHC.Generics.Par1>_R <a_agsGy>_N ; GHC.Generics.N:Par1[0]
                                                                        <a_agsGy>_R
                            :: (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.SourceStrict
                                     'GHC.Generics.DecidedStrict)
                                  GHC.Generics.Par1
                                  a_agsGy :: *)
                               ~R# (a_agsGy :: *)))
                 }}]
Data.Complex.$fGeneric1Complex_$cto1
  = \ (@ a_agsGy) (ds_dgt9B :: GHC.Generics.Rep1 Complex a_agsGy) ->
      case ds_dgt9B
           `cast` ((Sub (Data.Complex.Rep1_Complex[0]) ; (GHC.Generics.N:M1[0]
                                                              <*>_N
                                                              <GHC.Generics.D>_P
                                                              <'GHC.Generics.MetaData
                                                                 "Complex"
                                                                 "Data.Complex"
                                                                 "base"
                                                                 'False>_P
                                                              <GHC.Generics.M1
                                                                 GHC.Generics.C
                                                                 ('GHC.Generics.MetaCons
                                                                    ":+"
                                                                    ('GHC.Generics.InfixI
                                                                       'GHC.Generics.NotAssociative
                                                                       6)
                                                                    'False)
                                                                 (GHC.Generics.M1
                                                                    GHC.Generics.S
                                                                    ('GHC.Generics.MetaSel
                                                                       'Nothing
                                                                       'GHC.Generics.NoSourceUnpackedness
                                                                       'GHC.Generics.SourceStrict
                                                                       'GHC.Generics.DecidedStrict)
                                                                    GHC.Generics.Par1
                                                                  GHC.Generics.:*: GHC.Generics.M1
                                                                                     GHC.Generics.S
                                                                                     ('GHC.Generics.MetaSel
                                                                                        'Nothing
                                                                                        'GHC.Generics.NoSourceUnpackedness
                                                                                        'GHC.Generics.SourceStrict
                                                                                        'GHC.Generics.DecidedStrict)
                                                                                     GHC.Generics.Par1)>_R ; GHC.Generics.N:M1[0]
                                                                                                                 <*>_N
                                                                                                                 <GHC.Generics.C>_P
                                                                                                                 <'GHC.Generics.MetaCons
                                                                                                                    ":+"
                                                                                                                    ('GHC.Generics.InfixI
                                                                                                                       'GHC.Generics.NotAssociative
                                                                                                                       6)
                                                                                                                    'False>_P
                                                                                                                 <GHC.Generics.M1
                                                                                                                    GHC.Generics.S
                                                                                                                    ('GHC.Generics.MetaSel
                                                                                                                       'Nothing
                                                                                                                       'GHC.Generics.NoSourceUnpackedness
                                                                                                                       'GHC.Generics.SourceStrict
                                                                                                                       'GHC.Generics.DecidedStrict)
                                                                                                                    GHC.Generics.Par1
                                                                                                                  GHC.Generics.:*: GHC.Generics.M1
                                                                                                                                     GHC.Generics.S
                                                                                                                                     ('GHC.Generics.MetaSel
                                                                                                                                        'Nothing
                                                                                                                                        'GHC.Generics.NoSourceUnpackedness
                                                                                                                                        'GHC.Generics.SourceStrict
                                                                                                                                        'GHC.Generics.DecidedStrict)
                                                                                                                                     GHC.Generics.Par1>_R)) <a_agsGy>_N
                   :: (GHC.Generics.Rep1 Complex a_agsGy :: *)
                      ~R# ((GHC.Generics.:*:)
                             (GHC.Generics.M1
                                GHC.Generics.S
                                ('GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.SourceStrict
                                   'GHC.Generics.DecidedStrict)
                                GHC.Generics.Par1)
                             (GHC.Generics.M1
                                GHC.Generics.S
                                ('GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.SourceStrict
                                   'GHC.Generics.DecidedStrict)
                                GHC.Generics.Par1)
                             a_agsGy :: *))
      of
      { GHC.Generics.:*: ds1_dgt9E ds2_dgt9F ->
      Data.Complex.$W:+
        @ a_agsGy
        (ds1_dgt9E
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N
                     <GHC.Generics.S>_P
                     <'GHC.Generics.MetaSel
                        'Nothing
                        'GHC.Generics.NoSourceUnpackedness
                        'GHC.Generics.SourceStrict
                        'GHC.Generics.DecidedStrict>_P
                     <GHC.Generics.Par1>_R <a_agsGy>_N ; GHC.Generics.N:Par1[0]
                                                             <a_agsGy>_R
                 :: (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.SourceStrict
                          'GHC.Generics.DecidedStrict)
                       GHC.Generics.Par1
                       a_agsGy :: *)
                    ~R# (a_agsGy :: *)))
        (ds2_dgt9F
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N
                     <GHC.Generics.S>_P
                     <'GHC.Generics.MetaSel
                        'Nothing
                        'GHC.Generics.NoSourceUnpackedness
                        'GHC.Generics.SourceStrict
                        'GHC.Generics.DecidedStrict>_P
                     <GHC.Generics.Par1>_R <a_agsGy>_N ; GHC.Generics.N:Par1[0]
                                                             <a_agsGy>_R
                 :: (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.SourceStrict
                          'GHC.Generics.DecidedStrict)
                       GHC.Generics.Par1
                       a_agsGy :: *)
                    ~R# (a_agsGy :: *)))
      }

-- RHS size: {terms: 8, types: 33, coercions: 71, joins: 0/0}
Data.Complex.$fGeneric1Complex1
  :: forall a.
     Complex a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             ":+" ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6) 'False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.SourceStrict
                'GHC.Generics.DecidedStrict)
             GHC.Generics.Par1
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.SourceStrict
                                 'GHC.Generics.DecidedStrict)
                              GHC.Generics.Par1)
          a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsFZ) (x_agstR [Occ=Once!] :: Complex a_agsFZ) ->
                 case x_agstR of { :+ g1_agstS [Occ=Once] g2_agstT [Occ=Once] ->
                 (GHC.Generics.:*:
                    @ *
                    @ (GHC.Generics.M1
                         GHC.Generics.S
                         ('GHC.Generics.MetaSel
                            'Nothing
                            'GHC.Generics.NoSourceUnpackedness
                            'GHC.Generics.SourceStrict
                            'GHC.Generics.DecidedStrict)
                         GHC.Generics.Par1)
                    @ (GHC.Generics.M1
                         GHC.Generics.S
                         ('GHC.Generics.MetaSel
                            'Nothing
                            'GHC.Generics.NoSourceUnpackedness
                            'GHC.Generics.SourceStrict
                            'GHC.Generics.DecidedStrict)
                         GHC.Generics.Par1)
                    @ a_agsFZ
                    (g1_agstS
                     `cast` (Sym (GHC.Generics.N:Par1[0]
                                      <a_agsFZ>_R) ; Sym (GHC.Generics.N:M1[0]
                                                              <*>_N
                                                              <GHC.Generics.S>_P
                                                              <'GHC.Generics.MetaSel
                                                                 'Nothing
                                                                 'GHC.Generics.NoSourceUnpackedness
                                                                 'GHC.Generics.SourceStrict
                                                                 'GHC.Generics.DecidedStrict>_P
                                                              <GHC.Generics.Par1>_R) <a_agsFZ>_N
                             :: (a_agsFZ :: *)
                                ~R# (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.SourceStrict
                                          'GHC.Generics.DecidedStrict)
                                       GHC.Generics.Par1
                                       a_agsFZ :: *)))
                    (g2_agstT
                     `cast` (Sym (GHC.Generics.N:Par1[0]
                                      <a_agsFZ>_R) ; Sym (GHC.Generics.N:M1[0]
                                                              <*>_N
                                                              <GHC.Generics.S>_P
                                                              <'GHC.Generics.MetaSel
                                                                 'Nothing
                                                                 'GHC.Generics.NoSourceUnpackedness
                                                                 'GHC.Generics.SourceStrict
                                                                 'GHC.Generics.DecidedStrict>_P
                                                              <GHC.Generics.Par1>_R) <a_agsFZ>_N
                             :: (a_agsFZ :: *)
                                ~R# (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.SourceStrict
                                          'GHC.Generics.DecidedStrict)
                                       GHC.Generics.Par1
                                       a_agsFZ :: *))))
                 `cast` (Sym (GHC.Generics.N:M1[0]
                                  <*>_N
                                  <GHC.Generics.C>_P
                                  <'GHC.Generics.MetaCons
                                     ":+"
                                     ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
                                     'False>_P
                                  <GHC.Generics.M1
                                     GHC.Generics.S
                                     ('GHC.Generics.MetaSel
                                        'Nothing
                                        'GHC.Generics.NoSourceUnpackedness
                                        'GHC.Generics.SourceStrict
                                        'GHC.Generics.DecidedStrict)
                                     GHC.Generics.Par1
                                   GHC.Generics.:*: GHC.Generics.M1
                                                      GHC.Generics.S
                                                      ('GHC.Generics.MetaSel
                                                         'Nothing
                                                         'GHC.Generics.NoSourceUnpackedness
                                                         'GHC.Generics.SourceStrict
                                                         'GHC.Generics.DecidedStrict)
                                                      GHC.Generics.Par1>_R) <a_agsFZ>_N
                         :: ((GHC.Generics.:*:)
                               (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.SourceStrict
                                     'GHC.Generics.DecidedStrict)
                                  GHC.Generics.Par1)
                               (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.SourceStrict
                                     'GHC.Generics.DecidedStrict)
                                  GHC.Generics.Par1)
                               a_agsFZ :: *)
                            ~R# (GHC.Generics.M1
                                   GHC.Generics.C
                                   ('GHC.Generics.MetaCons
                                      ":+"
                                      ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
                                      'False)
                                   (GHC.Generics.M1
                                      GHC.Generics.S
                                      ('GHC.Generics.MetaSel
                                         'Nothing
                                         'GHC.Generics.NoSourceUnpackedness
                                         'GHC.Generics.SourceStrict
                                         'GHC.Generics.DecidedStrict)
                                      GHC.Generics.Par1
                                    GHC.Generics.:*: GHC.Generics.M1
                                                       GHC.Generics.S
                                                       ('GHC.Generics.MetaSel
                                                          'Nothing
                                                          'GHC.Generics.NoSourceUnpackedness
                                                          'GHC.Generics.SourceStrict
                                                          'GHC.Generics.DecidedStrict)
                                                       GHC.Generics.Par1)
                                   a_agsFZ :: *))
                 }}]
Data.Complex.$fGeneric1Complex1
  = \ (@ a_agsFZ) (x_agstR :: Complex a_agsFZ) ->
      case x_agstR of { :+ g1_agstS g2_agstT ->
      (GHC.Generics.:*:
         @ *
         @ (GHC.Generics.M1
              GHC.Generics.S
              ('GHC.Generics.MetaSel
                 'Nothing
                 'GHC.Generics.NoSourceUnpackedness
                 'GHC.Generics.SourceStrict
                 'GHC.Generics.DecidedStrict)
              GHC.Generics.Par1)
         @ (GHC.Generics.M1
              GHC.Generics.S
              ('GHC.Generics.MetaSel
                 'Nothing
                 'GHC.Generics.NoSourceUnpackedness
                 'GHC.Generics.SourceStrict
                 'GHC.Generics.DecidedStrict)
              GHC.Generics.Par1)
         @ a_agsFZ
         (g1_agstS
          `cast` (Sym (GHC.Generics.N:Par1[0]
                           <a_agsFZ>_R) ; Sym (GHC.Generics.N:M1[0]
                                                   <*>_N
                                                   <GHC.Generics.S>_P
                                                   <'GHC.Generics.MetaSel
                                                      'Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.SourceStrict
                                                      'GHC.Generics.DecidedStrict>_P
                                                   <GHC.Generics.Par1>_R) <a_agsFZ>_N
                  :: (a_agsFZ :: *)
                     ~R# (GHC.Generics.M1
                            GHC.Generics.S
                            ('GHC.Generics.MetaSel
                               'Nothing
                               'GHC.Generics.NoSourceUnpackedness
                               'GHC.Generics.SourceStrict
                               'GHC.Generics.DecidedStrict)
                            GHC.Generics.Par1
                            a_agsFZ :: *)))
         (g2_agstT
          `cast` (Sym (GHC.Generics.N:Par1[0]
                           <a_agsFZ>_R) ; Sym (GHC.Generics.N:M1[0]
                                                   <*>_N
                                                   <GHC.Generics.S>_P
                                                   <'GHC.Generics.MetaSel
                                                      'Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.SourceStrict
                                                      'GHC.Generics.DecidedStrict>_P
                                                   <GHC.Generics.Par1>_R) <a_agsFZ>_N
                  :: (a_agsFZ :: *)
                     ~R# (GHC.Generics.M1
                            GHC.Generics.S
                            ('GHC.Generics.MetaSel
                               'Nothing
                               'GHC.Generics.NoSourceUnpackedness
                               'GHC.Generics.SourceStrict
                               'GHC.Generics.DecidedStrict)
                            GHC.Generics.Par1
                            a_agsFZ :: *))))
      `cast` (Sym (GHC.Generics.N:M1[0]
                       <*>_N
                       <GHC.Generics.C>_P
                       <'GHC.Generics.MetaCons
                          ":+"
                          ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
                          'False>_P
                       <GHC.Generics.M1
                          GHC.Generics.S
                          ('GHC.Generics.MetaSel
                             'Nothing
                             'GHC.Generics.NoSourceUnpackedness
                             'GHC.Generics.SourceStrict
                             'GHC.Generics.DecidedStrict)
                          GHC.Generics.Par1
                        GHC.Generics.:*: GHC.Generics.M1
                                           GHC.Generics.S
                                           ('GHC.Generics.MetaSel
                                              'Nothing
                                              'GHC.Generics.NoSourceUnpackedness
                                              'GHC.Generics.SourceStrict
                                              'GHC.Generics.DecidedStrict)
                                           GHC.Generics.Par1>_R) <a_agsFZ>_N
              :: ((GHC.Generics.:*:)
                    (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.SourceStrict
                          'GHC.Generics.DecidedStrict)
                       GHC.Generics.Par1)
                    (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.SourceStrict
                          'GHC.Generics.DecidedStrict)
                       GHC.Generics.Par1)
                    a_agsFZ :: *)
                 ~R# (GHC.Generics.M1
                        GHC.Generics.C
                        ('GHC.Generics.MetaCons
                           ":+" ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6) 'False)
                        (GHC.Generics.M1
                           GHC.Generics.S
                           ('GHC.Generics.MetaSel
                              'Nothing
                              'GHC.Generics.NoSourceUnpackedness
                              'GHC.Generics.SourceStrict
                              'GHC.Generics.DecidedStrict)
                           GHC.Generics.Par1
                         GHC.Generics.:*: GHC.Generics.M1
                                            GHC.Generics.S
                                            ('GHC.Generics.MetaSel
                                               'Nothing
                                               'GHC.Generics.NoSourceUnpackedness
                                               'GHC.Generics.SourceStrict
                                               'GHC.Generics.DecidedStrict)
                                            GHC.Generics.Par1)
                        a_agsFZ :: *))
      }

-- RHS size: {terms: 3, types: 3, coercions: 56, joins: 0/0}
Data.Complex.$fGeneric1Complex [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic1 Complex
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: Complex
                               Data.Complex.$fGeneric1Complex1
                               `cast` (forall (a :: <*>_N).
                                       <Complex a>_R
                                       ->_R (Sym (GHC.Generics.N:M1[0]
                                                      <*>_N
                                                      <GHC.Generics.D>_P
                                                      <'GHC.Generics.MetaData
                                                         "Complex" "Data.Complex" "base" 'False>_P
                                                      <GHC.Generics.M1
                                                         GHC.Generics.C
                                                         ('GHC.Generics.MetaCons
                                                            ":+"
                                                            ('GHC.Generics.InfixI
                                                               'GHC.Generics.NotAssociative 6)
                                                            'False)
                                                         (GHC.Generics.M1
                                                            GHC.Generics.S
                                                            ('GHC.Generics.MetaSel
                                                               'Nothing
                                                               'GHC.Generics.NoSourceUnpackedness
                                                               'GHC.Generics.SourceStrict
                                                               'GHC.Generics.DecidedStrict)
                                                            GHC.Generics.Par1
                                                          GHC.Generics.:*: GHC.Generics.M1
                                                                             GHC.Generics.S
                                                                             ('GHC.Generics.MetaSel
                                                                                'Nothing
                                                                                'GHC.Generics.NoSourceUnpackedness
                                                                                'GHC.Generics.SourceStrict
                                                                                'GHC.Generics.DecidedStrict)
                                                                             GHC.Generics.Par1)>_R) ; Sub (Sym (Data.Complex.Rep1_Complex[0]))) <a>_N
                                       :: (forall a.
                                           Complex a
                                           -> GHC.Generics.M1
                                                GHC.Generics.C
                                                ('GHC.Generics.MetaCons
                                                   ":+"
                                                   ('GHC.Generics.InfixI
                                                      'GHC.Generics.NotAssociative 6)
                                                   'False)
                                                (GHC.Generics.M1
                                                   GHC.Generics.S
                                                   ('GHC.Generics.MetaSel
                                                      'Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.SourceStrict
                                                      'GHC.Generics.DecidedStrict)
                                                   GHC.Generics.Par1
                                                 GHC.Generics.:*: GHC.Generics.M1
                                                                    GHC.Generics.S
                                                                    ('GHC.Generics.MetaSel
                                                                       'Nothing
                                                                       'GHC.Generics.NoSourceUnpackedness
                                                                       'GHC.Generics.SourceStrict
                                                                       'GHC.Generics.DecidedStrict)
                                                                    GHC.Generics.Par1)
                                                a :: *)
                                          ~R# (forall a.
                                               Complex a -> GHC.Generics.Rep1 Complex a :: *))
                               Data.Complex.$fGeneric1Complex_$cto1]
Data.Complex.$fGeneric1Complex
  = GHC.Generics.C:Generic1
      @ *
      @ Complex
      (Data.Complex.$fGeneric1Complex1
       `cast` (forall (a :: <*>_N).
               <Complex a>_R
               ->_R (Sym (GHC.Generics.N:M1[0]
                              <*>_N
                              <GHC.Generics.D>_P
                              <'GHC.Generics.MetaData "Complex" "Data.Complex" "base" 'False>_P
                              <GHC.Generics.M1
                                 GHC.Generics.C
                                 ('GHC.Generics.MetaCons
                                    ":+"
                                    ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
                                    'False)
                                 (GHC.Generics.M1
                                    GHC.Generics.S
                                    ('GHC.Generics.MetaSel
                                       'Nothing
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.SourceStrict
                                       'GHC.Generics.DecidedStrict)
                                    GHC.Generics.Par1
                                  GHC.Generics.:*: GHC.Generics.M1
                                                     GHC.Generics.S
                                                     ('GHC.Generics.MetaSel
                                                        'Nothing
                                                        'GHC.Generics.NoSourceUnpackedness
                                                        'GHC.Generics.SourceStrict
                                                        'GHC.Generics.DecidedStrict)
                                                     GHC.Generics.Par1)>_R) ; Sub (Sym (Data.Complex.Rep1_Complex[0]))) <a>_N
               :: (forall a.
                   Complex a
                   -> GHC.Generics.M1
                        GHC.Generics.C
                        ('GHC.Generics.MetaCons
                           ":+" ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6) 'False)
                        (GHC.Generics.M1
                           GHC.Generics.S
                           ('GHC.Generics.MetaSel
                              'Nothing
                              'GHC.Generics.NoSourceUnpackedness
                              'GHC.Generics.SourceStrict
                              'GHC.Generics.DecidedStrict)
                           GHC.Generics.Par1
                         GHC.Generics.:*: GHC.Generics.M1
                                            GHC.Generics.S
                                            ('GHC.Generics.MetaSel
                                               'Nothing
                                               'GHC.Generics.NoSourceUnpackedness
                                               'GHC.Generics.SourceStrict
                                               'GHC.Generics.DecidedStrict)
                                            GHC.Generics.Par1)
                        a :: *)
                  ~R# (forall a. Complex a -> GHC.Generics.Rep1 Complex a :: *)))
      Data.Complex.$fGeneric1Complex_$cto1

-- RHS size: {terms: 9, types: 74, coercions: 147, joins: 0/0}
Data.Complex.$fGenericComplex_$cto
  :: forall a x. GHC.Generics.Rep (Complex a) x -> Complex a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsEy)
                 (@ x_agsFh)
                 (ds_dgt9r [Occ=Once]
                    :: GHC.Generics.Rep (Complex a_agsEy) x_agsFh) ->
                 case ds_dgt9r
                      `cast` ((Sub (Data.Complex.Rep_Complex[0]
                                        <a_agsEy>_N) ; (GHC.Generics.N:M1[0]
                                                            <*>_N
                                                            <GHC.Generics.D>_P
                                                            <'GHC.Generics.MetaData
                                                               "Complex"
                                                               "Data.Complex"
                                                               "base"
                                                               'False>_P
                                                            <GHC.Generics.M1
                                                               GHC.Generics.C
                                                               ('GHC.Generics.MetaCons
                                                                  ":+"
                                                                  ('GHC.Generics.InfixI
                                                                     'GHC.Generics.NotAssociative 6)
                                                                  'False)
                                                               (GHC.Generics.M1
                                                                  GHC.Generics.S
                                                                  ('GHC.Generics.MetaSel
                                                                     'Nothing
                                                                     'GHC.Generics.NoSourceUnpackedness
                                                                     'GHC.Generics.SourceStrict
                                                                     'GHC.Generics.DecidedStrict)
                                                                  (GHC.Generics.K1
                                                                     GHC.Generics.R a_agsEy)
                                                                GHC.Generics.:*: GHC.Generics.M1
                                                                                   GHC.Generics.S
                                                                                   ('GHC.Generics.MetaSel
                                                                                      'Nothing
                                                                                      'GHC.Generics.NoSourceUnpackedness
                                                                                      'GHC.Generics.SourceStrict
                                                                                      'GHC.Generics.DecidedStrict)
                                                                                   (GHC.Generics.K1
                                                                                      GHC.Generics.R
                                                                                      a_agsEy))>_R ; GHC.Generics.N:M1[0]
                                                                                                         <*>_N
                                                                                                         <GHC.Generics.C>_P
                                                                                                         <'GHC.Generics.MetaCons
                                                                                                            ":+"
                                                                                                            ('GHC.Generics.InfixI
                                                                                                               'GHC.Generics.NotAssociative
                                                                                                               6)
                                                                                                            'False>_P
                                                                                                         <GHC.Generics.M1
                                                                                                            GHC.Generics.S
                                                                                                            ('GHC.Generics.MetaSel
                                                                                                               'Nothing
                                                                                                               'GHC.Generics.NoSourceUnpackedness
                                                                                                               'GHC.Generics.SourceStrict
                                                                                                               'GHC.Generics.DecidedStrict)
                                                                                                            (GHC.Generics.K1
                                                                                                               GHC.Generics.R
                                                                                                               a_agsEy)
                                                                                                          GHC.Generics.:*: GHC.Generics.M1
                                                                                                                             GHC.Generics.S
                                                                                                                             ('GHC.Generics.MetaSel
                                                                                                                                'Nothing
                                                                                                                                'GHC.Generics.NoSourceUnpackedness
                                                                                                                                'GHC.Generics.SourceStrict
                                                                                                                                'GHC.Generics.DecidedStrict)
                                                                                                                             (GHC.Generics.K1
                                                                                                                                GHC.Generics.R
                                                                                                                                a_agsEy)>_R)) <x_agsFh>_N
                              :: (GHC.Generics.Rep (Complex a_agsEy) x_agsFh :: *)
                                 ~R# ((GHC.Generics.:*:)
                                        (GHC.Generics.M1
                                           GHC.Generics.S
                                           ('GHC.Generics.MetaSel
                                              'Nothing
                                              'GHC.Generics.NoSourceUnpackedness
                                              'GHC.Generics.SourceStrict
                                              'GHC.Generics.DecidedStrict)
                                           (GHC.Generics.K1 GHC.Generics.R a_agsEy))
                                        (GHC.Generics.M1
                                           GHC.Generics.S
                                           ('GHC.Generics.MetaSel
                                              'Nothing
                                              'GHC.Generics.NoSourceUnpackedness
                                              'GHC.Generics.SourceStrict
                                              'GHC.Generics.DecidedStrict)
                                           (GHC.Generics.K1 GHC.Generics.R a_agsEy))
                                        x_agsFh :: *))
                 of
                 { GHC.Generics.:*: ds1_dgt9u [Occ=Once] ds2_dgt9v [Occ=Once] ->
                 Data.Complex.$W:+
                   @ a_agsEy
                   (ds1_dgt9u
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N
                                <GHC.Generics.S>_P
                                <'GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.SourceStrict
                                   'GHC.Generics.DecidedStrict>_P
                                <GHC.Generics.K1
                                   GHC.Generics.R a_agsEy>_R <x_agsFh>_N ; GHC.Generics.N:K1[0]
                                                                               <*>_N
                                                                               <GHC.Generics.R>_P
                                                                               <a_agsEy>_R
                                                                               <x_agsFh>_P
                            :: (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.SourceStrict
                                     'GHC.Generics.DecidedStrict)
                                  (GHC.Generics.K1 GHC.Generics.R a_agsEy)
                                  x_agsFh :: *)
                               ~R# (a_agsEy :: *)))
                   (ds2_dgt9v
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N
                                <GHC.Generics.S>_P
                                <'GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.SourceStrict
                                   'GHC.Generics.DecidedStrict>_P
                                <GHC.Generics.K1
                                   GHC.Generics.R a_agsEy>_R <x_agsFh>_N ; GHC.Generics.N:K1[0]
                                                                               <*>_N
                                                                               <GHC.Generics.R>_P
                                                                               <a_agsEy>_R
                                                                               <x_agsFh>_P
                            :: (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.SourceStrict
                                     'GHC.Generics.DecidedStrict)
                                  (GHC.Generics.K1 GHC.Generics.R a_agsEy)
                                  x_agsFh :: *)
                               ~R# (a_agsEy :: *)))
                 }}]
Data.Complex.$fGenericComplex_$cto
  = \ (@ a_agsEy)
      (@ x_agsFh)
      (ds_dgt9r :: GHC.Generics.Rep (Complex a_agsEy) x_agsFh) ->
      case ds_dgt9r
           `cast` ((Sub (Data.Complex.Rep_Complex[0]
                             <a_agsEy>_N) ; (GHC.Generics.N:M1[0]
                                                 <*>_N
                                                 <GHC.Generics.D>_P
                                                 <'GHC.Generics.MetaData
                                                    "Complex" "Data.Complex" "base" 'False>_P
                                                 <GHC.Generics.M1
                                                    GHC.Generics.C
                                                    ('GHC.Generics.MetaCons
                                                       ":+"
                                                       ('GHC.Generics.InfixI
                                                          'GHC.Generics.NotAssociative 6)
                                                       'False)
                                                    (GHC.Generics.M1
                                                       GHC.Generics.S
                                                       ('GHC.Generics.MetaSel
                                                          'Nothing
                                                          'GHC.Generics.NoSourceUnpackedness
                                                          'GHC.Generics.SourceStrict
                                                          'GHC.Generics.DecidedStrict)
                                                       (GHC.Generics.K1 GHC.Generics.R a_agsEy)
                                                     GHC.Generics.:*: GHC.Generics.M1
                                                                        GHC.Generics.S
                                                                        ('GHC.Generics.MetaSel
                                                                           'Nothing
                                                                           'GHC.Generics.NoSourceUnpackedness
                                                                           'GHC.Generics.SourceStrict
                                                                           'GHC.Generics.DecidedStrict)
                                                                        (GHC.Generics.K1
                                                                           GHC.Generics.R
                                                                           a_agsEy))>_R ; GHC.Generics.N:M1[0]
                                                                                              <*>_N
                                                                                              <GHC.Generics.C>_P
                                                                                              <'GHC.Generics.MetaCons
                                                                                                 ":+"
                                                                                                 ('GHC.Generics.InfixI
                                                                                                    'GHC.Generics.NotAssociative
                                                                                                    6)
                                                                                                 'False>_P
                                                                                              <GHC.Generics.M1
                                                                                                 GHC.Generics.S
                                                                                                 ('GHC.Generics.MetaSel
                                                                                                    'Nothing
                                                                                                    'GHC.Generics.NoSourceUnpackedness
                                                                                                    'GHC.Generics.SourceStrict
                                                                                                    'GHC.Generics.DecidedStrict)
                                                                                                 (GHC.Generics.K1
                                                                                                    GHC.Generics.R
                                                                                                    a_agsEy)
                                                                                               GHC.Generics.:*: GHC.Generics.M1
                                                                                                                  GHC.Generics.S
                                                                                                                  ('GHC.Generics.MetaSel
                                                                                                                     'Nothing
                                                                                                                     'GHC.Generics.NoSourceUnpackedness
                                                                                                                     'GHC.Generics.SourceStrict
                                                                                                                     'GHC.Generics.DecidedStrict)
                                                                                                                  (GHC.Generics.K1
                                                                                                                     GHC.Generics.R
                                                                                                                     a_agsEy)>_R)) <x_agsFh>_N
                   :: (GHC.Generics.Rep (Complex a_agsEy) x_agsFh :: *)
                      ~R# ((GHC.Generics.:*:)
                             (GHC.Generics.M1
                                GHC.Generics.S
                                ('GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.SourceStrict
                                   'GHC.Generics.DecidedStrict)
                                (GHC.Generics.K1 GHC.Generics.R a_agsEy))
                             (GHC.Generics.M1
                                GHC.Generics.S
                                ('GHC.Generics.MetaSel
                                   'Nothing
                                   'GHC.Generics.NoSourceUnpackedness
                                   'GHC.Generics.SourceStrict
                                   'GHC.Generics.DecidedStrict)
                                (GHC.Generics.K1 GHC.Generics.R a_agsEy))
                             x_agsFh :: *))
      of
      { GHC.Generics.:*: ds1_dgt9u ds2_dgt9v ->
      Data.Complex.$W:+
        @ a_agsEy
        (ds1_dgt9u
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N
                     <GHC.Generics.S>_P
                     <'GHC.Generics.MetaSel
                        'Nothing
                        'GHC.Generics.NoSourceUnpackedness
                        'GHC.Generics.SourceStrict
                        'GHC.Generics.DecidedStrict>_P
                     <GHC.Generics.K1
                        GHC.Generics.R a_agsEy>_R <x_agsFh>_N ; GHC.Generics.N:K1[0]
                                                                    <*>_N
                                                                    <GHC.Generics.R>_P
                                                                    <a_agsEy>_R
                                                                    <x_agsFh>_P
                 :: (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.SourceStrict
                          'GHC.Generics.DecidedStrict)
                       (GHC.Generics.K1 GHC.Generics.R a_agsEy)
                       x_agsFh :: *)
                    ~R# (a_agsEy :: *)))
        (ds2_dgt9v
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N
                     <GHC.Generics.S>_P
                     <'GHC.Generics.MetaSel
                        'Nothing
                        'GHC.Generics.NoSourceUnpackedness
                        'GHC.Generics.SourceStrict
                        'GHC.Generics.DecidedStrict>_P
                     <GHC.Generics.K1
                        GHC.Generics.R a_agsEy>_R <x_agsFh>_N ; GHC.Generics.N:K1[0]
                                                                    <*>_N
                                                                    <GHC.Generics.R>_P
                                                                    <a_agsEy>_R
                                                                    <x_agsFh>_P
                 :: (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.SourceStrict
                          'GHC.Generics.DecidedStrict)
                       (GHC.Generics.K1 GHC.Generics.R a_agsEy)
                       x_agsFh :: *)
                    ~R# (a_agsEy :: *)))
      }

-- RHS size: {terms: 9, types: 42, coercions: 95, joins: 0/0}
Data.Complex.$fGenericComplex1
  :: forall a x.
     Complex a
     -> GHC.Generics.M1
          GHC.Generics.C
          ('GHC.Generics.MetaCons
             ":+" ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6) 'False)
          (GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                'Nothing
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.SourceStrict
                'GHC.Generics.DecidedStrict)
             (GHC.Generics.K1 GHC.Generics.R a)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 'Nothing
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.SourceStrict
                                 'GHC.Generics.DecidedStrict)
                              (GHC.Generics.K1 GHC.Generics.R a))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsEy)
                 (@ x_agsEC)
                 (x1_agstL [Occ=Once!] :: Complex a_agsEy) ->
                 case x1_agstL of { :+ g1_agstM [Occ=Once] g2_agstN [Occ=Once] ->
                 (GHC.Generics.:*:
                    @ *
                    @ (GHC.Generics.M1
                         GHC.Generics.S
                         ('GHC.Generics.MetaSel
                            'Nothing
                            'GHC.Generics.NoSourceUnpackedness
                            'GHC.Generics.SourceStrict
                            'GHC.Generics.DecidedStrict)
                         (GHC.Generics.K1 GHC.Generics.R a_agsEy))
                    @ (GHC.Generics.M1
                         GHC.Generics.S
                         ('GHC.Generics.MetaSel
                            'Nothing
                            'GHC.Generics.NoSourceUnpackedness
                            'GHC.Generics.SourceStrict
                            'GHC.Generics.DecidedStrict)
                         (GHC.Generics.K1 GHC.Generics.R a_agsEy))
                    @ x_agsEC
                    (g1_agstM
                     `cast` (Sym (GHC.Generics.N:K1[0]
                                      <*>_N
                                      <GHC.Generics.R>_P
                                      <a_agsEy>_R
                                      <x_agsEC>_P) ; Sym (GHC.Generics.N:M1[0]
                                                              <*>_N
                                                              <GHC.Generics.S>_P
                                                              <'GHC.Generics.MetaSel
                                                                 'Nothing
                                                                 'GHC.Generics.NoSourceUnpackedness
                                                                 'GHC.Generics.SourceStrict
                                                                 'GHC.Generics.DecidedStrict>_P
                                                              <GHC.Generics.K1
                                                                 GHC.Generics.R
                                                                 a_agsEy>_R) <x_agsEC>_N
                             :: (a_agsEy :: *)
                                ~R# (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.SourceStrict
                                          'GHC.Generics.DecidedStrict)
                                       (GHC.Generics.K1 GHC.Generics.R a_agsEy)
                                       x_agsEC :: *)))
                    (g2_agstN
                     `cast` (Sym (GHC.Generics.N:K1[0]
                                      <*>_N
                                      <GHC.Generics.R>_P
                                      <a_agsEy>_R
                                      <x_agsEC>_P) ; Sym (GHC.Generics.N:M1[0]
                                                              <*>_N
                                                              <GHC.Generics.S>_P
                                                              <'GHC.Generics.MetaSel
                                                                 'Nothing
                                                                 'GHC.Generics.NoSourceUnpackedness
                                                                 'GHC.Generics.SourceStrict
                                                                 'GHC.Generics.DecidedStrict>_P
                                                              <GHC.Generics.K1
                                                                 GHC.Generics.R
                                                                 a_agsEy>_R) <x_agsEC>_N
                             :: (a_agsEy :: *)
                                ~R# (GHC.Generics.M1
                                       GHC.Generics.S
                                       ('GHC.Generics.MetaSel
                                          'Nothing
                                          'GHC.Generics.NoSourceUnpackedness
                                          'GHC.Generics.SourceStrict
                                          'GHC.Generics.DecidedStrict)
                                       (GHC.Generics.K1 GHC.Generics.R a_agsEy)
                                       x_agsEC :: *))))
                 `cast` (Sym (GHC.Generics.N:M1[0]
                                  <*>_N
                                  <GHC.Generics.C>_P
                                  <'GHC.Generics.MetaCons
                                     ":+"
                                     ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
                                     'False>_P
                                  <GHC.Generics.M1
                                     GHC.Generics.S
                                     ('GHC.Generics.MetaSel
                                        'Nothing
                                        'GHC.Generics.NoSourceUnpackedness
                                        'GHC.Generics.SourceStrict
                                        'GHC.Generics.DecidedStrict)
                                     (GHC.Generics.K1 GHC.Generics.R a_agsEy)
                                   GHC.Generics.:*: GHC.Generics.M1
                                                      GHC.Generics.S
                                                      ('GHC.Generics.MetaSel
                                                         'Nothing
                                                         'GHC.Generics.NoSourceUnpackedness
                                                         'GHC.Generics.SourceStrict
                                                         'GHC.Generics.DecidedStrict)
                                                      (GHC.Generics.K1
                                                         GHC.Generics.R a_agsEy)>_R) <x_agsEC>_N
                         :: ((GHC.Generics.:*:)
                               (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.SourceStrict
                                     'GHC.Generics.DecidedStrict)
                                  (GHC.Generics.K1 GHC.Generics.R a_agsEy))
                               (GHC.Generics.M1
                                  GHC.Generics.S
                                  ('GHC.Generics.MetaSel
                                     'Nothing
                                     'GHC.Generics.NoSourceUnpackedness
                                     'GHC.Generics.SourceStrict
                                     'GHC.Generics.DecidedStrict)
                                  (GHC.Generics.K1 GHC.Generics.R a_agsEy))
                               x_agsEC :: *)
                            ~R# (GHC.Generics.M1
                                   GHC.Generics.C
                                   ('GHC.Generics.MetaCons
                                      ":+"
                                      ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
                                      'False)
                                   (GHC.Generics.M1
                                      GHC.Generics.S
                                      ('GHC.Generics.MetaSel
                                         'Nothing
                                         'GHC.Generics.NoSourceUnpackedness
                                         'GHC.Generics.SourceStrict
                                         'GHC.Generics.DecidedStrict)
                                      (GHC.Generics.K1 GHC.Generics.R a_agsEy)
                                    GHC.Generics.:*: GHC.Generics.M1
                                                       GHC.Generics.S
                                                       ('GHC.Generics.MetaSel
                                                          'Nothing
                                                          'GHC.Generics.NoSourceUnpackedness
                                                          'GHC.Generics.SourceStrict
                                                          'GHC.Generics.DecidedStrict)
                                                       (GHC.Generics.K1 GHC.Generics.R a_agsEy))
                                   x_agsEC :: *))
                 }}]
Data.Complex.$fGenericComplex1
  = \ (@ a_agsEy) (@ x_agsEC) (x1_agstL :: Complex a_agsEy) ->
      case x1_agstL of { :+ g1_agstM g2_agstN ->
      (GHC.Generics.:*:
         @ *
         @ (GHC.Generics.M1
              GHC.Generics.S
              ('GHC.Generics.MetaSel
                 'Nothing
                 'GHC.Generics.NoSourceUnpackedness
                 'GHC.Generics.SourceStrict
                 'GHC.Generics.DecidedStrict)
              (GHC.Generics.K1 GHC.Generics.R a_agsEy))
         @ (GHC.Generics.M1
              GHC.Generics.S
              ('GHC.Generics.MetaSel
                 'Nothing
                 'GHC.Generics.NoSourceUnpackedness
                 'GHC.Generics.SourceStrict
                 'GHC.Generics.DecidedStrict)
              (GHC.Generics.K1 GHC.Generics.R a_agsEy))
         @ x_agsEC
         (g1_agstM
          `cast` (Sym (GHC.Generics.N:K1[0]
                           <*>_N
                           <GHC.Generics.R>_P
                           <a_agsEy>_R
                           <x_agsEC>_P) ; Sym (GHC.Generics.N:M1[0]
                                                   <*>_N
                                                   <GHC.Generics.S>_P
                                                   <'GHC.Generics.MetaSel
                                                      'Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.SourceStrict
                                                      'GHC.Generics.DecidedStrict>_P
                                                   <GHC.Generics.K1
                                                      GHC.Generics.R a_agsEy>_R) <x_agsEC>_N
                  :: (a_agsEy :: *)
                     ~R# (GHC.Generics.M1
                            GHC.Generics.S
                            ('GHC.Generics.MetaSel
                               'Nothing
                               'GHC.Generics.NoSourceUnpackedness
                               'GHC.Generics.SourceStrict
                               'GHC.Generics.DecidedStrict)
                            (GHC.Generics.K1 GHC.Generics.R a_agsEy)
                            x_agsEC :: *)))
         (g2_agstN
          `cast` (Sym (GHC.Generics.N:K1[0]
                           <*>_N
                           <GHC.Generics.R>_P
                           <a_agsEy>_R
                           <x_agsEC>_P) ; Sym (GHC.Generics.N:M1[0]
                                                   <*>_N
                                                   <GHC.Generics.S>_P
                                                   <'GHC.Generics.MetaSel
                                                      'Nothing
                                                      'GHC.Generics.NoSourceUnpackedness
                                                      'GHC.Generics.SourceStrict
                                                      'GHC.Generics.DecidedStrict>_P
                                                   <GHC.Generics.K1
                                                      GHC.Generics.R a_agsEy>_R) <x_agsEC>_N
                  :: (a_agsEy :: *)
                     ~R# (GHC.Generics.M1
                            GHC.Generics.S
                            ('GHC.Generics.MetaSel
                               'Nothing
                               'GHC.Generics.NoSourceUnpackedness
                               'GHC.Generics.SourceStrict
                               'GHC.Generics.DecidedStrict)
                            (GHC.Generics.K1 GHC.Generics.R a_agsEy)
                            x_agsEC :: *))))
      `cast` (Sym (GHC.Generics.N:M1[0]
                       <*>_N
                       <GHC.Generics.C>_P
                       <'GHC.Generics.MetaCons
                          ":+"
                          ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
                          'False>_P
                       <GHC.Generics.M1
                          GHC.Generics.S
                          ('GHC.Generics.MetaSel
                             'Nothing
                             'GHC.Generics.NoSourceUnpackedness
                             'GHC.Generics.SourceStrict
                             'GHC.Generics.DecidedStrict)
                          (GHC.Generics.K1 GHC.Generics.R a_agsEy)
                        GHC.Generics.:*: GHC.Generics.M1
                                           GHC.Generics.S
                                           ('GHC.Generics.MetaSel
                                              'Nothing
                                              'GHC.Generics.NoSourceUnpackedness
                                              'GHC.Generics.SourceStrict
                                              'GHC.Generics.DecidedStrict)
                                           (GHC.Generics.K1 GHC.Generics.R a_agsEy)>_R) <x_agsEC>_N
              :: ((GHC.Generics.:*:)
                    (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.SourceStrict
                          'GHC.Generics.DecidedStrict)
                       (GHC.Generics.K1 GHC.Generics.R a_agsEy))
                    (GHC.Generics.M1
                       GHC.Generics.S
                       ('GHC.Generics.MetaSel
                          'Nothing
                          'GHC.Generics.NoSourceUnpackedness
                          'GHC.Generics.SourceStrict
                          'GHC.Generics.DecidedStrict)
                       (GHC.Generics.K1 GHC.Generics.R a_agsEy))
                    x_agsEC :: *)
                 ~R# (GHC.Generics.M1
                        GHC.Generics.C
                        ('GHC.Generics.MetaCons
                           ":+" ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6) 'False)
                        (GHC.Generics.M1
                           GHC.Generics.S
                           ('GHC.Generics.MetaSel
                              'Nothing
                              'GHC.Generics.NoSourceUnpackedness
                              'GHC.Generics.SourceStrict
                              'GHC.Generics.DecidedStrict)
                           (GHC.Generics.K1 GHC.Generics.R a_agsEy)
                         GHC.Generics.:*: GHC.Generics.M1
                                            GHC.Generics.S
                                            ('GHC.Generics.MetaSel
                                               'Nothing
                                               'GHC.Generics.NoSourceUnpackedness
                                               'GHC.Generics.SourceStrict
                                               'GHC.Generics.DecidedStrict)
                                            (GHC.Generics.K1 GHC.Generics.R a_agsEy))
                        x_agsEC :: *))
      }

-- RHS size: {terms: 4, types: 6, coercions: 64, joins: 0/0}
Data.Complex.$fGenericComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Generic (Complex a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_agsns) ->
       GHC.Generics.C:Generic TYPE: Complex a_agsns
                              (Data.Complex.$fGenericComplex1 @ a_agsns)
                              `cast` (forall (x :: <*>_N).
                                      <Complex a_agsns>_R
                                      ->_R (Sym (GHC.Generics.N:M1[0]
                                                     <*>_N
                                                     <GHC.Generics.D>_P
                                                     <'GHC.Generics.MetaData
                                                        "Complex" "Data.Complex" "base" 'False>_P
                                                     <GHC.Generics.M1
                                                        GHC.Generics.C
                                                        ('GHC.Generics.MetaCons
                                                           ":+"
                                                           ('GHC.Generics.InfixI
                                                              'GHC.Generics.NotAssociative 6)
                                                           'False)
                                                        (GHC.Generics.M1
                                                           GHC.Generics.S
                                                           ('GHC.Generics.MetaSel
                                                              'Nothing
                                                              'GHC.Generics.NoSourceUnpackedness
                                                              'GHC.Generics.SourceStrict
                                                              'GHC.Generics.DecidedStrict)
                                                           (GHC.Generics.K1 GHC.Generics.R a_agsns)
                                                         GHC.Generics.:*: GHC.Generics.M1
                                                                            GHC.Generics.S
                                                                            ('GHC.Generics.MetaSel
                                                                               'Nothing
                                                                               'GHC.Generics.NoSourceUnpackedness
                                                                               'GHC.Generics.SourceStrict
                                                                               'GHC.Generics.DecidedStrict)
                                                                            (GHC.Generics.K1
                                                                               GHC.Generics.R
                                                                               a_agsns))>_R) ; Sub (Sym (Data.Complex.Rep_Complex[0]
                                                                                                             <a_agsns>_N))) <x>_N
                                      :: (forall x.
                                          Complex a_agsns
                                          -> GHC.Generics.M1
                                               GHC.Generics.C
                                               ('GHC.Generics.MetaCons
                                                  ":+"
                                                  ('GHC.Generics.InfixI
                                                     'GHC.Generics.NotAssociative 6)
                                                  'False)
                                               (GHC.Generics.M1
                                                  GHC.Generics.S
                                                  ('GHC.Generics.MetaSel
                                                     'Nothing
                                                     'GHC.Generics.NoSourceUnpackedness
                                                     'GHC.Generics.SourceStrict
                                                     'GHC.Generics.DecidedStrict)
                                                  (GHC.Generics.K1 GHC.Generics.R a_agsns)
                                                GHC.Generics.:*: GHC.Generics.M1
                                                                   GHC.Generics.S
                                                                   ('GHC.Generics.MetaSel
                                                                      'Nothing
                                                                      'GHC.Generics.NoSourceUnpackedness
                                                                      'GHC.Generics.SourceStrict
                                                                      'GHC.Generics.DecidedStrict)
                                                                   (GHC.Generics.K1
                                                                      GHC.Generics.R a_agsns))
                                               x :: *)
                                         ~R# (forall x.
                                              Complex a_agsns
                                              -> GHC.Generics.Rep (Complex a_agsns) x :: *))
                              Data.Complex.$fGenericComplex_$cto @ a_agsns]
Data.Complex.$fGenericComplex
  = \ (@ a_XgsIy) ->
      GHC.Generics.C:Generic
        @ (Complex a_XgsIy)
        ((Data.Complex.$fGenericComplex1 @ a_XgsIy)
         `cast` (forall (x :: <*>_N).
                 <Complex a_XgsIy>_R
                 ->_R (Sym (GHC.Generics.N:M1[0]
                                <*>_N
                                <GHC.Generics.D>_P
                                <'GHC.Generics.MetaData "Complex" "Data.Complex" "base" 'False>_P
                                <GHC.Generics.M1
                                   GHC.Generics.C
                                   ('GHC.Generics.MetaCons
                                      ":+"
                                      ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6)
                                      'False)
                                   (GHC.Generics.M1
                                      GHC.Generics.S
                                      ('GHC.Generics.MetaSel
                                         'Nothing
                                         'GHC.Generics.NoSourceUnpackedness
                                         'GHC.Generics.SourceStrict
                                         'GHC.Generics.DecidedStrict)
                                      (GHC.Generics.K1 GHC.Generics.R a_XgsIy)
                                    GHC.Generics.:*: GHC.Generics.M1
                                                       GHC.Generics.S
                                                       ('GHC.Generics.MetaSel
                                                          'Nothing
                                                          'GHC.Generics.NoSourceUnpackedness
                                                          'GHC.Generics.SourceStrict
                                                          'GHC.Generics.DecidedStrict)
                                                       (GHC.Generics.K1
                                                          GHC.Generics.R
                                                          a_XgsIy))>_R) ; Sub (Sym (Data.Complex.Rep_Complex[0]
                                                                                        <a_XgsIy>_N))) <x>_N
                 :: (forall x.
                     Complex a_XgsIy
                     -> GHC.Generics.M1
                          GHC.Generics.C
                          ('GHC.Generics.MetaCons
                             ":+" ('GHC.Generics.InfixI 'GHC.Generics.NotAssociative 6) 'False)
                          (GHC.Generics.M1
                             GHC.Generics.S
                             ('GHC.Generics.MetaSel
                                'Nothing
                                'GHC.Generics.NoSourceUnpackedness
                                'GHC.Generics.SourceStrict
                                'GHC.Generics.DecidedStrict)
                             (GHC.Generics.K1 GHC.Generics.R a_XgsIy)
                           GHC.Generics.:*: GHC.Generics.M1
                                              GHC.Generics.S
                                              ('GHC.Generics.MetaSel
                                                 'Nothing
                                                 'GHC.Generics.NoSourceUnpackedness
                                                 'GHC.Generics.SourceStrict
                                                 'GHC.Generics.DecidedStrict)
                                              (GHC.Generics.K1 GHC.Generics.R a_XgsIy))
                          x :: *)
                    ~R# (forall x.
                         Complex a_XgsIy -> GHC.Generics.Rep (Complex a_XgsIy) x :: *)))
        (Data.Complex.$fGenericComplex_$cto @ a_XgsIy)

-- RHS size: {terms: 12, types: 37, coercions: 0, joins: 0/0}
Data.Complex.$fDataComplex_$cgunfold
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Data.Data.Constr -> c (Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsBe)
                 ($dData_agsBf :: Data a_agsBe)
                 (@ (c_agsBB :: * -> *))
                 (k_agstI :: forall b r. Data b => c_agsBB (b -> r) -> c_agsBB r)
                 (z_agstJ [Occ=Once!] :: forall r. r -> c_agsBB r)
                 _ [Occ=Dead] ->
                 k_agstI
                   @ a_agsBe
                   @ (Complex a_agsBe)
                   $dData_agsBf
                   (k_agstI
                      @ a_agsBe
                      @ (a_agsBe -> Complex a_agsBe)
                      $dData_agsBf
                      (z_agstJ
                         @ (a_agsBe -> a_agsBe -> Complex a_agsBe)
                         (Data.Complex.$W:+ @ a_agsBe)))}]
Data.Complex.$fDataComplex_$cgunfold
  = \ (@ a_agsBe)
      ($dData_agsBf :: Data a_agsBe)
      (@ (c_agsBB :: * -> *))
      (k_agstI :: forall b r. Data b => c_agsBB (b -> r) -> c_agsBB r)
      (z_agstJ :: forall r. r -> c_agsBB r)
      _ [Occ=Dead] ->
      k_agstI
        @ a_agsBe
        @ (Complex a_agsBe)
        $dData_agsBf
        (k_agstI
           @ a_agsBe
           @ (a_agsBe -> Complex a_agsBe)
           $dData_agsBf
           (z_agstJ
              @ (a_agsBe -> a_agsBe -> Complex a_agsBe)
              (Data.Complex.$W:+ @ a_agsBe)))

-- RHS size: {terms: 17, types: 43, coercions: 0, joins: 0/0}
Data.Complex.$fDataComplex_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Complex a -> c (Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsBe)
                 ($dData_agsBf :: Data a_agsBe)
                 (@ (c_agsBn :: * -> *))
                 (k_agstE
                    :: forall d b. Data d => c_agsBn (d -> b) -> d -> c_agsBn b)
                 (z_agstF [Occ=Once!] :: forall g. g -> c_agsBn g)
                 (ds_dgt93 [Occ=Once!] :: Complex a_agsBe) ->
                 case ds_dgt93 of { :+ a1_agstG [Occ=Once] a2_agstH [Occ=Once] ->
                 k_agstE
                   @ a_agsBe
                   @ (Complex a_agsBe)
                   $dData_agsBf
                   (k_agstE
                      @ a_agsBe
                      @ (a_agsBe -> Complex a_agsBe)
                      $dData_agsBf
                      (z_agstF
                         @ (a_agsBe -> a_agsBe -> Complex a_agsBe)
                         (Data.Complex.$W:+ @ a_agsBe))
                      a1_agstG)
                   a2_agstH
                 }}]
Data.Complex.$fDataComplex_$cgfoldl
  = \ (@ a_agsBe)
      ($dData_agsBf :: Data a_agsBe)
      (@ (c_agsBn :: * -> *))
      (k_agstE
         :: forall d b. Data d => c_agsBn (d -> b) -> d -> c_agsBn b)
      (z_agstF :: forall g. g -> c_agsBn g)
      (ds_dgt93 :: Complex a_agsBe) ->
      case ds_dgt93 of { :+ a1_agstG a2_agstH ->
      k_agstE
        @ a_agsBe
        @ (Complex a_agsBe)
        $dData_agsBf
        (k_agstE
           @ a_agsBe
           @ (a_agsBe -> Complex a_agsBe)
           $dData_agsBf
           (z_agstF
              @ (a_agsBe -> a_agsBe -> Complex a_agsBe)
              (Data.Complex.$W:+ @ a_agsBe))
           a1_agstG)
        a2_agstH
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fReadComplex5 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Complex.$fReadComplex5 = GHC.Types.I# 7#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fReadComplex4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Complex.$fReadComplex4 = ":+"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fReadComplex3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Complex.$fReadComplex3
  = GHC.CString.unpackCString# Data.Complex.$fReadComplex4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fReadComplex2 :: Text.Read.Lex.Lexeme
[GblId,
 Str=m5,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Complex.$fReadComplex2
  = Text.Read.Lex.Symbol Data.Complex.$fReadComplex3

-- RHS size: {terms: 40, types: 44, coercions: 17, joins: 0/1}
Data.Complex.$fReadComplex1
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Complex a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,1*U(A,A,1*C1(C(U)),A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 301 0}]
Data.Complex.$fReadComplex1
  = \ (@ a_agsAr)
      ($dRead_agsAs :: Read a_agsAr)
      (eta_B2 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_i815e)
      (eta1_B1
         :: Complex a_agsAr -> Text.ParserCombinators.ReadP.P b_i815e) ->
      GHC.Read.list3
        @ (Complex a_agsAr)
        (let {
           ds1_sgunN [Dmd=<L,C(U)>]
             :: Text.ParserCombinators.ReadP.ReadP a_agsAr
           [LclId]
           ds1_sgunN
             = ((GHC.Read.readPrec @ a_agsAr $dRead_agsAs)
                `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_agsAr>_R
                        :: (Text.ParserCombinators.ReadPrec.ReadPrec a_agsAr :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.Prec
                                -> Text.ParserCombinators.ReadP.ReadP a_agsAr :: *)))
                 Data.Complex.$fReadComplex5 } in
         (\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b1_i815E)
            (eta2_X7A
               :: Complex a_agsAr -> Text.ParserCombinators.ReadP.P b1_i815E) ->
            case c_i88VW of { GHC.Types.I# x_i88VZ ->
            case GHC.Prim.<=# x_i88VZ 6# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1_i815E;
              1# ->
                (ds1_sgunN
                 `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_agsAr>_R
                         :: (Text.ParserCombinators.ReadP.ReadP a_agsAr :: *)
                            ~R# (forall b.
                                 (a_agsAr -> Text.ParserCombinators.ReadP.P b)
                                 -> Text.ParserCombinators.ReadP.P b :: *)))
                  @ b1_i815E
                  (\ (a1_i88WJ :: a_agsAr) ->
                     case Text.Read.Lex.$wexpect
                            Data.Complex.$fReadComplex2
                            @ b1_i815E
                            (\ _ [Occ=Dead, OS=OneShot] ->
                               (ds1_sgunN
                                `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_agsAr>_R
                                        :: (Text.ParserCombinators.ReadP.ReadP a_agsAr :: *)
                                           ~R# (forall b.
                                                (a_agsAr -> Text.ParserCombinators.ReadP.P b)
                                                -> Text.ParserCombinators.ReadP.P b :: *)))
                                 @ b1_i815E
                                 (\ (a3_X891l :: a_agsAr) ->
                                    eta2_X7A (Data.Complex.$W:+ @ a_agsAr a1_i88WJ a3_X891l)))
                     of
                     { (# ww1_i88Ww #) ->
                     Text.ParserCombinators.ReadP.Look @ b1_i815E ww1_i88Ww
                     })
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Complex
                                   a_agsAr>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Complex a_agsAr>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Complex a_agsAr -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Complex a_agsAr) :: *)))
        eta_B2
        @ b_i815e
        eta1_B1

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Complex.$fReadComplex_$creadsPrec
  :: forall a. Read a => Int -> ReadS (Complex a)
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgsEB)
                 ($dRead_XgsED [Occ=Once] :: Read a_XgsEB)
                 (n_i8156 [Occ=Once] :: Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Complex a_XgsEB)
                   (Data.Complex.$fReadComplex1
                      @ a_XgsEB
                      $dRead_XgsED
                      n_i8156
                      @ (Complex a_XgsEB)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Complex a_XgsEB)))}]
Data.Complex.$fReadComplex_$creadsPrec
  = \ (@ a_XgsEB) ($dRead_XgsED :: Read a_XgsEB) (n_i8156 :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (Complex a_XgsEB)
        (Data.Complex.$fReadComplex1
           @ a_XgsEB
           $dRead_XgsED
           n_i8156
           @ (Complex a_XgsEB)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (Complex a_XgsEB)))

-- RHS size: {terms: 5, types: 7, coercions: 11, joins: 0/0}
Data.Complex.$fReadComplex_$creadListPrec
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Complex a]
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgsEz) ($dRead_XgsEB [Occ=Once] :: Read a_XgsEz) ->
                 GHC.Read.list
                   @ (Complex a_XgsEz)
                   ((Data.Complex.$fReadComplex1 @ a_XgsEz $dRead_XgsEB)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Complex
                                              a_XgsEz>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Complex a_XgsEz>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (Complex a_XgsEz -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                      (Complex a_XgsEz) :: *)))}]
Data.Complex.$fReadComplex_$creadListPrec
  = \ (@ a_XgsEz) ($dRead_XgsEB :: Read a_XgsEz) ->
      GHC.Read.list
        @ (Complex a_XgsEz)
        ((Data.Complex.$fReadComplex1 @ a_XgsEz $dRead_XgsEB)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Complex
                                   a_XgsEz>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Complex a_XgsEz>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Complex a_XgsEz -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Complex a_XgsEz) :: *)))

-- RHS size: {terms: 8, types: 16, coercions: 19, joins: 0/0}
Data.Complex.$fReadComplex_$creadList
  :: forall a. Read a => ReadS [Complex a]
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgsEA) ($dRead_XgsEC [Occ=Once] :: Read a_XgsEA) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Complex a_XgsEA]
                   (((((GHC.Read.list
                          @ (Complex a_XgsEA)
                          ((Data.Complex.$fReadComplex1 @ a_XgsEA $dRead_XgsEC)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <Complex
                                                     a_XgsEA>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <Complex a_XgsEA>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (Complex a_XgsEA -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (Complex a_XgsEA) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[Complex a_XgsEA]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                     [Complex a_XgsEA] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP
                                            [Complex a_XgsEA] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                 <[Complex a_XgsEA]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [Complex a_XgsEA] :: *)
                                ~R# (forall b.
                                     ([Complex a_XgsEA] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [Complex a_XgsEA]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Complex a_XgsEA]))}]
Data.Complex.$fReadComplex_$creadList
  = \ (@ a_XgsEA) ($dRead_XgsEC :: Read a_XgsEA) ->
      Text.ParserCombinators.ReadP.run
        @ [Complex a_XgsEA]
        (((((GHC.Read.list
               @ (Complex a_XgsEA)
               ((Data.Complex.$fReadComplex1 @ a_XgsEA $dRead_XgsEC)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Complex
                                          a_XgsEA>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Complex a_XgsEA>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (Complex a_XgsEA -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                  (Complex a_XgsEA) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[Complex a_XgsEA]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec
                          [Complex a_XgsEA] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [Complex a_XgsEA] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[Complex a_XgsEA]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [Complex a_XgsEA] :: *)
                     ~R# (forall b.
                          ([Complex a_XgsEA] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [Complex a_XgsEA]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [Complex a_XgsEA]))

-- RHS size: {terms: 11, types: 10, coercions: 11, joins: 0/0}
Data.Complex.$fReadComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Read a => Read (Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,C(C(U)),A)>m,
 Unf=DFun: \ (@ a_agsns) (v_B1 :: Read a_agsns) ->
       GHC.Read.C:Read TYPE: Complex a_agsns
                       Data.Complex.$fReadComplex_$creadsPrec @ a_agsns v_B1
                       Data.Complex.$fReadComplex_$creadList @ a_agsns v_B1
                       (Data.Complex.$fReadComplex1 @ a_agsns v_B1)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Complex
                                                 a_agsns>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <Complex a_agsns>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Complex a_agsns -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                         (Complex a_agsns) :: *))
                       Data.Complex.$fReadComplex_$creadListPrec @ a_agsns v_B1]
Data.Complex.$fReadComplex
  = \ (@ a_XgsEy) ($dRead_XgsEA :: Read a_XgsEy) ->
      GHC.Read.C:Read
        @ (Complex a_XgsEy)
        (Data.Complex.$fReadComplex_$creadsPrec @ a_XgsEy $dRead_XgsEA)
        (Data.Complex.$fReadComplex_$creadList @ a_XgsEy $dRead_XgsEA)
        ((Data.Complex.$fReadComplex1 @ a_XgsEy $dRead_XgsEA)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Complex
                                   a_XgsEy>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Complex a_XgsEy>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Complex a_XgsEy -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Complex a_XgsEy) :: *)))
        (Data.Complex.$fReadComplex_$creadListPrec @ a_XgsEy $dRead_XgsEA)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fShowComplex2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Complex.$fShowComplex2 = " :+ "#

-- RHS size: {terms: 37, types: 18, coercions: 0, joins: 0/2}
Data.Complex.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => GHC.Prim.Int# -> a -> a -> ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0 0] 301 120}]
Data.Complex.$w$cshowsPrec
  = \ (@ a_sgxsK)
      (w_sgxsL :: Show a_sgxsK)
      (ww_sgxsQ :: GHC.Prim.Int#)
      (ww1_sgxsU
         :: a_sgxsK
         Unf=OtherCon [])
      (ww2_sgxsV
         :: a_sgxsK
         Unf=OtherCon []) ->
      let {
        f_sgunK [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_sgunK
          = showsPrec
              @ a_sgxsK w_sgxsL Data.Complex.$fReadComplex5 ww1_sgxsU } in
      let {
        g_sgunI [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        g_sgunI
          = showsPrec
              @ a_sgxsK w_sgxsL Data.Complex.$fReadComplex5 ww2_sgxsV } in
      case GHC.Prim.>=# ww_sgxsQ 7# of {
        __DEFAULT ->
          \ (x_X7RBN :: String) ->
            f_sgunK
              (GHC.CString.unpackAppendCString#
                 Data.Complex.$fShowComplex2 (g_sgunI x_X7RBN));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (f_sgunK
                 (GHC.CString.unpackAppendCString#
                    Data.Complex.$fShowComplex2
                    (g_sgunI (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR))))
      }

-- RHS size: {terms: 15, types: 14, coercions: 0, joins: 0/0}
Data.Complex.$fShowComplex_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int -> Complex a -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxsK)
                 (w_sgxsL [Occ=Once] :: Show a_sgxsK)
                 (w1_sgxsM [Occ=Once!] :: Int)
                 (w2_sgxsN [Occ=Once!] :: Complex a_sgxsK) ->
                 case w1_sgxsM of { GHC.Types.I# ww1_sgxsQ [Occ=Once] ->
                 case w2_sgxsN of { :+ ww3_sgxsU [Occ=Once] ww4_sgxsV [Occ=Once] ->
                 Data.Complex.$w$cshowsPrec
                   @ a_sgxsK w_sgxsL ww1_sgxsQ ww3_sgxsU ww4_sgxsV
                 }
                 }}]
Data.Complex.$fShowComplex_$cshowsPrec
  = \ (@ a_sgxsK)
      (w_sgxsL :: Show a_sgxsK)
      (w1_sgxsM :: Int)
      (w2_sgxsN :: Complex a_sgxsK) ->
      case w1_sgxsM of { GHC.Types.I# ww1_sgxsQ ->
      case w2_sgxsN of { :+ ww3_sgxsU ww4_sgxsV ->
      Data.Complex.$w$cshowsPrec
        @ a_sgxsK w_sgxsL ww1_sgxsQ ww3_sgxsU ww4_sgxsV
      }
      }

-- RHS size: {terms: 15, types: 9, coercions: 0, joins: 0/0}
Data.Complex.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => a -> a -> String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 130 0}]
Data.Complex.$w$cshow
  = \ (@ a_sgxsY)
      (w_sgxsZ :: Show a_sgxsY)
      (ww_sgxt3
         :: a_sgxsY
         Unf=OtherCon [])
      (ww1_sgxt4
         :: a_sgxsY
         Unf=OtherCon []) ->
      showsPrec
        @ a_sgxsY
        w_sgxsZ
        Data.Complex.$fReadComplex5
        ww_sgxt3
        (GHC.CString.unpackAppendCString#
           Data.Complex.$fShowComplex2
           (showsPrec
              @ a_sgxsY
              w_sgxsZ
              Data.Complex.$fReadComplex5
              ww1_sgxt4
              (GHC.Types.[] @ Char)))

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fShowComplex_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Complex a -> String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxsY)
                 (w_sgxsZ [Occ=Once] :: Show a_sgxsY)
                 (w1_sgxt0 [Occ=Once!] :: Complex a_sgxsY) ->
                 case w1_sgxt0 of { :+ ww1_sgxt3 [Occ=Once] ww2_sgxt4 [Occ=Once] ->
                 Data.Complex.$w$cshow @ a_sgxsY w_sgxsZ ww1_sgxt3 ww2_sgxt4
                 }}]
Data.Complex.$fShowComplex_$cshow
  = \ (@ a_sgxsY)
      (w_sgxsZ :: Show a_sgxsY)
      (w1_sgxt0 :: Complex a_sgxsY) ->
      case w1_sgxt0 of { :+ ww1_sgxt3 ww2_sgxt4 ->
      Data.Complex.$w$cshow @ a_sgxsY w_sgxsZ ww1_sgxt3 ww2_sgxt4
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fShowComplex1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Complex.$fShowComplex1 = GHC.Types.I# 0#

-- RHS size: {terms: 16, types: 17, coercions: 0, joins: 0/0}
Data.Complex.$fShowComplex_$cshowList
  :: forall a. Show a => [Complex a] -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agszX)
                 ($dShow_agszY [Occ=Once] :: Show a_agszX)
                 (ls_i7JaB [Occ=Once] :: [Complex a_agszX])
                 (s_i7JaC [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (Complex a_agszX)
                   (Data.Complex.$fShowComplex_$cshowsPrec
                      @ a_agszX $dShow_agszY Data.Complex.$fShowComplex1)
                   ls_i7JaB
                   s_i7JaC}]
Data.Complex.$fShowComplex_$cshowList
  = \ (@ a_agszX)
      ($dShow_agszY :: Show a_agszX)
      (ls_i7JaB :: [Complex a_agszX])
      (s_i7JaC :: String) ->
      GHC.Show.showList__
        @ (Complex a_agszX)
        (\ (w_sgxsN :: Complex a_agszX) ->
           case w_sgxsN of { :+ ww1_sgxsU ww2_sgxsV ->
           Data.Complex.$w$cshowsPrec
             @ a_agszX $dShow_agszY 0# ww1_sgxsU ww2_sgxsV
           })
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Complex.$fShowComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show (Complex a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_agsns) (v_B1 :: Show a_agsns) ->
       GHC.Show.C:Show TYPE: Complex a_agsns
                       Data.Complex.$fShowComplex_$cshowsPrec @ a_agsns v_B1
                       Data.Complex.$fShowComplex_$cshow @ a_agsns v_B1
                       Data.Complex.$fShowComplex_$cshowList @ a_agsns v_B1]
Data.Complex.$fShowComplex
  = \ (@ a_agszX) ($dShow_agszY :: Show a_agszX) ->
      GHC.Show.C:Show
        @ (Complex a_agszX)
        (Data.Complex.$fShowComplex_$cshowsPrec @ a_agszX $dShow_agszY)
        (Data.Complex.$fShowComplex_$cshow @ a_agszX $dShow_agszY)
        (Data.Complex.$fShowComplex_$cshowList @ a_agszX $dShow_agszY)

-- RHS size: {terms: 22, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fEqComplex_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a. Eq a => Complex a -> Complex a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxt7)
                 (w_sgxt8 :: Eq a_sgxt7)
                 (w1_sgxt9 [Occ=Once!] :: Complex a_sgxt7)
                 (w2_sgxta [Occ=Once!] :: Complex a_sgxt7) ->
                 case w1_sgxt9 of { :+ ww1_sgxtd [Occ=Once] ww2_sgxte [Occ=Once] ->
                 case w2_sgxta of { :+ ww4_sgxti [Occ=Once] ww5_sgxtj [Occ=Once] ->
                 case == @ a_sgxt7 w_sgxt8 ww1_sgxtd ww4_sgxti of {
                   False -> GHC.Types.False;
                   True -> == @ a_sgxt7 w_sgxt8 ww2_sgxte ww5_sgxtj
                 }
                 }
                 }}]
Data.Complex.$fEqComplex_$c==
  = \ (@ a_sgxt7)
      (w_sgxt8 :: Eq a_sgxt7)
      (w1_sgxt9 :: Complex a_sgxt7)
      (w2_sgxta :: Complex a_sgxt7) ->
      case w1_sgxt9 of { :+ ww1_sgxtd ww2_sgxte ->
      case w2_sgxta of { :+ ww4_sgxti ww5_sgxtj ->
      case == @ a_sgxt7 w_sgxt8 ww1_sgxtd ww4_sgxti of {
        False -> GHC.Types.False;
        True -> == @ a_sgxt7 w_sgxt8 ww2_sgxte ww5_sgxtj
      }
      }
      }

-- RHS size: {terms: 27, types: 20, coercions: 0, joins: 0/0}
Data.Complex.$fEqComplex_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a. Eq a => Complex a -> Complex a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_agszG)
                 ($dEq_agszH [Occ=Once] :: Eq a_agszG)
                 (x_a22b [Occ=Once] :: Complex a_agszG)
                 (y_a22c [Occ=Once] :: Complex a_agszG) ->
                 case Data.Complex.$fEqComplex_$c==
                        @ a_agszG $dEq_agszH x_a22b y_a22c
                 of {
                   False -> GHC.Types.True;
                   True -> GHC.Types.False
                 }}]
Data.Complex.$fEqComplex_$c/=
  = \ (@ a_agszG)
      ($dEq_agszH :: Eq a_agszG)
      (eta_B2 :: Complex a_agszG)
      (eta1_B1 :: Complex a_agszG) ->
      case eta_B2 of { :+ ww1_sgxtd ww2_sgxte ->
      case eta1_B1 of { :+ ww4_sgxti ww5_sgxtj ->
      case == @ a_agszG $dEq_agszH ww1_sgxtd ww4_sgxti of {
        False -> GHC.Types.True;
        True ->
          case == @ a_agszG $dEq_agszH ww2_sgxte ww5_sgxtj of {
            False -> GHC.Types.True;
            True -> GHC.Types.False
          }
      }
      }
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
Data.Complex.$fEqComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq a => Eq (Complex a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_agsns) (v_B1 :: Eq a_agsns) ->
       GHC.Classes.C:Eq TYPE: Complex a_agsns
                        Data.Complex.$fEqComplex_$c== @ a_agsns v_B1
                        Data.Complex.$fEqComplex_$c/= @ a_agsns v_B1]
Data.Complex.$fEqComplex
  = \ (@ a_agszG) ($dEq_agszH :: Eq a_agszG) ->
      GHC.Classes.C:Eq
        @ (Complex a_agszG)
        (Data.Complex.$fEqComplex_$c== @ a_agszG $dEq_agszH)
        (Data.Complex.$fEqComplex_$c/= @ a_agszG $dEq_agszH)

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
realPart :: forall a. Complex a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agszs) (ds_dgt8N [Occ=Once!] :: Complex a_agszs) ->
                 case ds_dgt8N of { :+ x_agspA [Occ=Once] _ [Occ=Dead] ->
                 x_agspA
                 }}]
realPart
  = \ (@ a_agszs) (ds_dgt8N :: Complex a_agszs) ->
      case ds_dgt8N of { :+ x_agspA ds1_dgt8T -> x_agspA }

-- RHS size: {terms: 15, types: 13, coercions: 0, joins: 0/0}
Data.Complex.$fStorableComplex_$csizeOf
  :: forall a. Storable a => Complex a -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S(S))LLLLLLL),1*U(1*C1(U(U)),A,A,A,A,A,A,A)><L,1*U(U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgsQG)
                 ($dStorable_XgsQI [Occ=Once] :: Storable a_XgsQG)
                 (a1_agsnH [Occ=Once!] :: Complex a_XgsQG) ->
                 case sizeOf
                        @ a_XgsQG
                        $dStorable_XgsQI
                        (case a1_agsnH of { :+ x_agspA [Occ=Once] _ [Occ=Dead] ->
                         x_agspA
                         })
                 of
                 { GHC.Types.I# y_i7MWP [Occ=Once] ->
                 GHC.Types.I# (GHC.Prim.*# 2# y_i7MWP)
                 }}]
Data.Complex.$fStorableComplex_$csizeOf
  = \ (@ a_XgsQG)
      ($dStorable_XgsQI :: Storable a_XgsQG)
      (a1_agsnH :: Complex a_XgsQG) ->
      case sizeOf
             @ a_XgsQG
             $dStorable_XgsQI
             (case a1_agsnH of { :+ x_agspA ds_dgt8T -> x_agspA })
      of
      { GHC.Types.I# y_i7MWP ->
      GHC.Types.I# (GHC.Prim.*# 2# y_i7MWP)
      }

-- RHS size: {terms: 9, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fStorableComplex_$calignment
  :: forall a. Storable a => Complex a -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLLLL),1*U(A,1*C1(U(U)),A,A,A,A,A,A)><L,1*U(U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgsQH)
                 ($dStorable_XgsQJ [Occ=Once] :: Storable a_XgsQH)
                 (a1_agsnI [Occ=Once!] :: Complex a_XgsQH) ->
                 alignment
                   @ a_XgsQH
                   $dStorable_XgsQJ
                   (case a1_agsnI of { :+ x_agspA [Occ=Once] _ [Occ=Dead] ->
                    x_agspA
                    })}]
Data.Complex.$fStorableComplex_$calignment
  = \ (@ a_XgsQH)
      ($dStorable_XgsQJ :: Storable a_XgsQH)
      (a1_agsnI :: Complex a_XgsQH) ->
      alignment
        @ a_XgsQH
        $dStorable_XgsQJ
        (case a1_agsnI of { :+ x_agspA ds_dgt8T -> x_agspA })

-- RHS size: {terms: 19, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fStorableComplex5
  :: forall a.
     Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Complex a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgsQL)
                 ($dStorable_XgsQN [Occ=Once] :: Storable a_XgsQL)
                 (@ b_agsMU)
                 (ptr_i9wJP [Occ=Once!] :: GHC.Ptr.Ptr b_agsMU)
                 (off_i9wJQ [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 Data.Complex.$fStorableComplex3
                   @ a_XgsQL
                   $dStorable_XgsQN
                   (case ptr_i9wJP of { GHC.Ptr.Ptr addr_i9wJT [Occ=Once] ->
                    case off_i9wJQ of { GHC.Types.I# d_i9wJX [Occ=Once] ->
                    GHC.Ptr.Ptr
                      @ (Complex a_XgsQL) (GHC.Prim.plusAddr# addr_i9wJT d_i9wJX)
                    }
                    })
                   eta_B1}]
Data.Complex.$fStorableComplex5
  = \ (@ a_XgsQL)
      ($dStorable_XgsQN :: Storable a_XgsQL)
      (@ b_agsMU)
      (ptr_i9wJP :: GHC.Ptr.Ptr b_agsMU)
      (off_i9wJQ :: Int)
      (eta_B1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      Data.Complex.$fStorableComplex3
        @ a_XgsQL
        $dStorable_XgsQN
        (case ptr_i9wJP of { GHC.Ptr.Ptr addr_i9wJT ->
         case off_i9wJQ of { GHC.Types.I# d_i9wJX ->
         GHC.Ptr.Ptr
           @ (Complex a_XgsQL) (GHC.Prim.plusAddr# addr_i9wJT d_i9wJX)
         }
         })
        eta_B1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1_rgA6f :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl1_rgA6f = "undefined"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl2_rgA6g :: [Char]
[GblId]
lvl2_rgA6g = GHC.CString.unpackCString# lvl1_rgA6f

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Complex.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl3_rgA6h :: [Char]
[GblId]
lvl3_rgA6h = GHC.CString.unpackCString# Data.Complex.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl4_rgA6i :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl4_rgA6i = "Foreign.Storable"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl5_rgA6j :: [Char]
[GblId]
lvl5_rgA6j = GHC.CString.unpackCString# lvl4_rgA6i

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl6_rgA6k :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl6_rgA6k = "./Foreign/Storable.hs"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl7_rgA6l :: [Char]
[GblId]
lvl7_rgA6l = GHC.CString.unpackCString# lvl6_rgA6k

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl8_rgA6m :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl8_rgA6m = GHC.Types.I# 137#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl9_rgA6n :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl9_rgA6n = GHC.Types.I# 31#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl10_rgA6o :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl10_rgA6o = GHC.Types.I# 40#

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
lvl11_rgA6p :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []]
lvl11_rgA6p
  = GHC.Stack.Types.SrcLoc
      lvl3_rgA6h
      lvl5_rgA6j
      lvl7_rgA6l
      lvl8_rgA6m
      lvl9_rgA6n
      lvl8_rgA6m
      lvl10_rgA6o

-- RHS size: {terms: 4, types: 0, coercions: 0, joins: 0/0}
lvl12_rgA6q :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []]
lvl12_rgA6q
  = GHC.Stack.Types.PushCallStack
      lvl2_rgA6g lvl11_rgA6p GHC.Stack.Types.EmptyCallStack

-- RHS size: {terms: 3, types: 5, coercions: 4, joins: 0/0}
Data.Complex.$fStorableComplex8 :: forall a. Complex a
[GblId, Str=x]
Data.Complex.$fStorableComplex8
  = \ (@ a_XgsQM) ->
      undefined
        @ 'GHC.Types.LiftedRep
        @ (Complex a_XgsQM)
        (lvl12_rgA6q
         `cast` (Sym (GHC.Classes.N:IP[0]
                          <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                 :: (GHC.Stack.Types.CallStack :: *)
                    ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))

-- RHS size: {terms: 28, types: 26, coercions: 0, joins: 0/0}
Data.Complex.$fStorableComplex7
  :: forall a.
     Storable a =>
     GHC.Ptr.Ptr (Complex a)
     -> Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Complex a #)
[GblId,
 Arity=4,
 Str=<S(LLLLLLC(C(S(SL)))L),U(1*C1(U(U)),A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgsQM)
                 ($dStorable_XgsQO :: Storable a_XgsQM)
                 (ptr_i9wJl [Occ=Once!] :: GHC.Ptr.Ptr (Complex a_XgsQM))
                 (off_i9wJm [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 Data.Complex.$fStorableComplex3
                   @ a_XgsQM
                   $dStorable_XgsQO
                   (case ptr_i9wJl of { GHC.Ptr.Ptr addr_i9wJT [Occ=Once] ->
                    case off_i9wJm of { GHC.Types.I# x_i9wJp [Occ=Once] ->
                    case sizeOf
                           @ a_XgsQM
                           $dStorable_XgsQO
                           (case Data.Complex.$fStorableComplex8 of { })
                    of
                    { GHC.Types.I# y_i7MWP [Occ=Once] ->
                    GHC.Ptr.Ptr
                      @ (Complex a_XgsQM)
                      (GHC.Prim.plusAddr#
                         addr_i9wJT (GHC.Prim.*# x_i9wJp (GHC.Prim.*# 2# y_i7MWP)))
                    }
                    }
                    })
                   eta_B1}]
Data.Complex.$fStorableComplex7
  = \ (@ a_XgsQM)
      ($dStorable_XgsQO :: Storable a_XgsQM)
      (ptr_i9wJl :: GHC.Ptr.Ptr (Complex a_XgsQM))
      (off_i9wJm :: Int)
      (eta_B1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      Data.Complex.$fStorableComplex3
        @ a_XgsQM
        $dStorable_XgsQO
        (case ptr_i9wJl of { GHC.Ptr.Ptr addr_i9wJT ->
         case off_i9wJm of { GHC.Types.I# x_i9wJp ->
         case sizeOf
                @ a_XgsQM
                $dStorable_XgsQO
                (case Data.Complex.$fStorableComplex8 of wild2_00 { })
         of
         { GHC.Types.I# y_i7MWP ->
         GHC.Ptr.Ptr
           @ (Complex a_XgsQM)
           (GHC.Prim.plusAddr#
              addr_i9wJT (GHC.Prim.*# x_i9wJp (GHC.Prim.*# 2# y_i7MWP)))
         }
         }
         })
        eta_B1

-- RHS size: {terms: 34, types: 40, coercions: 20, joins: 0/1}
Data.Complex.$fStorableComplex4
  :: forall a.
     Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> Int
     -> Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgsQJ)
                 ($dStorable_XgsVC [Occ=Once] :: Storable a_XgsQJ)
                 (@ b_agsN2)
                 (ptr_i9wK2 [Occ=Once!] :: GHC.Ptr.Ptr b_agsN2)
                 (off_i9wK3 [Occ=Once!] :: Int)
                 (eta_B2 [Occ=Once] :: Complex a_XgsQJ)
                 (eta1_B1 [Occ=Once] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 Data.Complex.$fStorableComplex1
                   @ a_XgsQJ
                   $dStorable_XgsVC
                   (case ptr_i9wK2 of { GHC.Ptr.Ptr addr_i9wK6 [Occ=Once] ->
                    case off_i9wK3 of { GHC.Types.I# d_i9wKa [Occ=Once] ->
                    GHC.Ptr.Ptr
                      @ (Complex a_XgsQJ) (GHC.Prim.plusAddr# addr_i9wK6 d_i9wKa)
                    }
                    })
                   eta_B2
                   eta1_B1}]
Data.Complex.$fStorableComplex4
  = \ (@ a_XgsQJ)
      ($dStorable_XgsVC :: Storable a_XgsQJ)
      (@ b_agsN2)
      (ptr_i9wK2 :: GHC.Ptr.Ptr b_agsN2)
      (off_i9wK3 :: Int)
      (eta_B2 :: Complex a_XgsQJ)
      (eta1_B1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      case eta_B2 of { :+ ww1_sgxsa ww2_sgxsb ->
      let {
        w_sgxs5 :: GHC.Ptr.Ptr (Complex a_XgsQJ)
        [LclId]
        w_sgxs5
          = case ptr_i9wK2 of { GHC.Ptr.Ptr addr_i9wK6 ->
            case off_i9wK3 of { GHC.Types.I# d_i9wKa ->
            GHC.Ptr.Ptr
              @ (Complex a_XgsQJ) (GHC.Prim.plusAddr# addr_i9wK6 d_i9wKa)
            }
            } } in
      case ((poke
               @ a_XgsQJ
               $dStorable_XgsVC
               (w_sgxs5
                `cast` ((GHC.Ptr.Ptr
                           Univ(phantom phantom <*>_N :: Complex a_XgsQJ, a_XgsQJ))_R
                        :: (GHC.Ptr.Ptr (Complex a_XgsQJ) :: *)
                           ~R# (GHC.Ptr.Ptr a_XgsQJ :: *)))
               ww1_sgxsa)
            `cast` (GHC.Types.N:IO[0] <()>_R
                    :: (IO () :: *)
                       ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)))
             eta1_B1
      of
      { (# ipv_i7JiK, ipv1_i7JiL #) ->
      ((pokeElemOff
          @ a_XgsQJ
          $dStorable_XgsVC
          (w_sgxs5
           `cast` ((GHC.Ptr.Ptr
                      Univ(phantom phantom <*>_N :: Complex a_XgsQJ, a_XgsQJ))_R
                   :: (GHC.Ptr.Ptr (Complex a_XgsQJ) :: *)
                      ~R# (GHC.Ptr.Ptr a_XgsQJ :: *)))
          Data.Complex.$fStorableComplex2
          ww2_sgxsb)
       `cast` (GHC.Types.N:IO[0] <()>_R
               :: (IO () :: *)
                  ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                       -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)))
        ipv_i7JiK
      }
      }

-- RHS size: {terms: 40, types: 39, coercions: 20, joins: 0/1}
Data.Complex.$w$cpokeElemOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Storable a =>
     GHC.Ptr.Ptr (Complex a)
     -> Int
     -> a
     -> a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(1*C1(U(U)),A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [90 20 20 0 0 0] 203 0}]
Data.Complex.$w$cpokeElemOff
  = \ (@ a_sgxtm)
      (w_sgxtn :: Storable a_sgxtm)
      (w1_sgxto :: GHC.Ptr.Ptr (Complex a_sgxtm))
      (w2_sgxtp :: Int)
      (ww_sgxtu
         :: a_sgxtm
         Unf=OtherCon [])
      (ww1_sgxtv
         :: a_sgxtm
         Unf=OtherCon [])
      (w3_sgxtr :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      let {
        w4_sgxs5 :: GHC.Ptr.Ptr (Complex a_sgxtm)
        [LclId]
        w4_sgxs5
          = case w1_sgxto of { GHC.Ptr.Ptr addr_i9wK6 ->
            case w2_sgxtp of { GHC.Types.I# x_i9wJG ->
            case sizeOf @ a_sgxtm w_sgxtn ww_sgxtu of { GHC.Types.I# y_i7MWP ->
            GHC.Ptr.Ptr
              @ (Complex a_sgxtm)
              (GHC.Prim.plusAddr#
                 addr_i9wK6 (GHC.Prim.*# x_i9wJG (GHC.Prim.*# 2# y_i7MWP)))
            }
            }
            } } in
      case ((poke
               @ a_sgxtm
               w_sgxtn
               (w4_sgxs5
                `cast` ((GHC.Ptr.Ptr
                           Univ(phantom phantom <*>_N :: Complex a_sgxtm, a_sgxtm))_R
                        :: (GHC.Ptr.Ptr (Complex a_sgxtm) :: *)
                           ~R# (GHC.Ptr.Ptr a_sgxtm :: *)))
               ww_sgxtu)
            `cast` (GHC.Types.N:IO[0] <()>_R
                    :: (IO () :: *)
                       ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)))
             w3_sgxtr
      of
      { (# ipv_i7JiK, ipv1_i7JiL #) ->
      ((pokeElemOff
          @ a_sgxtm
          w_sgxtn
          (w4_sgxs5
           `cast` ((GHC.Ptr.Ptr
                      Univ(phantom phantom <*>_N :: Complex a_sgxtm, a_sgxtm))_R
                   :: (GHC.Ptr.Ptr (Complex a_sgxtm) :: *)
                      ~R# (GHC.Ptr.Ptr a_sgxtm :: *)))
          Data.Complex.$fStorableComplex2
          ww1_sgxtv)
       `cast` (GHC.Types.N:IO[0] <()>_R
               :: (IO () :: *)
                  ~R# (GHC.Prim.State# GHC.Prim.RealWorld
                       -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)))
        ipv_i7JiK
      }

-- RHS size: {terms: 16, types: 17, coercions: 0, joins: 0/0}
Data.Complex.$fStorableComplex6 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Storable a =>
     GHC.Ptr.Ptr (Complex a)
     -> Int
     -> Complex a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(C(U(U)),A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxtm)
                 (w_sgxtn [Occ=Once] :: Storable a_sgxtm)
                 (w1_sgxto [Occ=Once] :: GHC.Ptr.Ptr (Complex a_sgxtm))
                 (w2_sgxtp [Occ=Once] :: Int)
                 (w3_sgxtq [Occ=Once!] :: Complex a_sgxtm)
                 (w4_sgxtr [Occ=Once] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w3_sgxtq of { :+ ww1_sgxtu [Occ=Once] ww2_sgxtv [Occ=Once] ->
                 Data.Complex.$w$cpokeElemOff
                   @ a_sgxtm w_sgxtn w1_sgxto w2_sgxtp ww1_sgxtu ww2_sgxtv w4_sgxtr
                 }}]
Data.Complex.$fStorableComplex6
  = \ (@ a_sgxtm)
      (w_sgxtn :: Storable a_sgxtm)
      (w1_sgxto :: GHC.Ptr.Ptr (Complex a_sgxtm))
      (w2_sgxtp :: Int)
      (w3_sgxtq :: Complex a_sgxtm)
      (w4_sgxtr :: GHC.Prim.State# GHC.Prim.RealWorld) ->
      case w3_sgxtq of { :+ ww1_sgxtu ww2_sgxtv ->
      Data.Complex.$w$cpokeElemOff
        @ a_sgxtm w_sgxtn w1_sgxto w2_sgxtp ww1_sgxtu ww2_sgxtv w4_sgxtr
      }

-- RHS size: {terms: 19, types: 14, coercions: 66, joins: 0/0}
Data.Complex.$fStorableComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Storable a => Storable (Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(U(U)),C(U(U)),C(C1(C1(U(U,U)))),C(C1(C1(C1(U(U,U))))),A,A,C(C1(U(U,U))),C(C1(C1(U(U,A)))))>m,
 Unf=DFun: \ (@ a_agsnG) (v_B1 :: Storable a_agsnG) ->
       Foreign.Storable.C:Storable TYPE: Complex a_agsnG
                                   Data.Complex.$fStorableComplex_$csizeOf @ a_agsnG v_B1
                                   Data.Complex.$fStorableComplex_$calignment @ a_agsnG v_B1
                                   (Data.Complex.$fStorableComplex7 @ a_agsnG v_B1)
                                   `cast` (<GHC.Ptr.Ptr (Complex a_agsnG)>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Complex a_agsnG>_R)
                                           :: (GHC.Ptr.Ptr (Complex a_agsnG)
                                               -> Int
                                               -> GHC.Prim.State# GHC.Prim.RealWorld
                                               -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                     Complex a_agsnG #) :: *)
                                              ~R# (GHC.Ptr.Ptr (Complex a_agsnG)
                                                   -> Int -> IO (Complex a_agsnG) :: *))
                                   (Data.Complex.$fStorableComplex6 @ a_agsnG v_B1)
                                   `cast` (<GHC.Ptr.Ptr (Complex a_agsnG)>_R
                                           ->_R <Int>_R
                                           ->_R <Complex a_agsnG>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr (Complex a_agsnG)
                                               -> Int
                                               -> Complex a_agsnG
                                               -> GHC.Prim.State# GHC.Prim.RealWorld
                                               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr (Complex a_agsnG)
                                                   -> Int -> Complex a_agsnG -> IO () :: *))
                                   (Data.Complex.$fStorableComplex5 @ a_agsnG v_B1)
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Complex a_agsnG>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> GHC.Prim.State# GHC.Prim.RealWorld
                                               -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                     Complex a_agsnG #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b
                                                   -> Int -> IO (Complex a_agsnG) :: *))
                                   (Data.Complex.$fStorableComplex4 @ a_agsnG v_B1)
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Complex a_agsnG>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Complex a_agsnG
                                               -> GHC.Prim.State# GHC.Prim.RealWorld
                                               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b
                                                   -> Int -> Complex a_agsnG -> IO () :: *))
                                   (Data.Complex.$fStorableComplex3 @ a_agsnG v_B1)
                                   `cast` (<GHC.Ptr.Ptr (Complex a_agsnG)>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Complex a_agsnG>_R)
                                           :: (GHC.Ptr.Ptr (Complex a_agsnG)
                                               -> GHC.Prim.State# GHC.Prim.RealWorld
                                               -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                     Complex a_agsnG #) :: *)
                                              ~R# (GHC.Ptr.Ptr (Complex a_agsnG)
                                                   -> IO (Complex a_agsnG) :: *))
                                   (Data.Complex.$fStorableComplex1 @ a_agsnG v_B1)
                                   `cast` (<GHC.Ptr.Ptr (Complex a_agsnG)>_R
                                           ->_R <Complex a_agsnG>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr (Complex a_agsnG)
                                               -> Complex a_agsnG
                                               -> GHC.Prim.State# GHC.Prim.RealWorld
                                               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr (Complex a_agsnG)
                                                   -> Complex a_agsnG -> IO () :: *))]
Data.Complex.$fStorableComplex
  = \ (@ a_XgsQI) ($dStorable_XgsVQ :: Storable a_XgsQI) ->
      Foreign.Storable.C:Storable
        @ (Complex a_XgsQI)
        (Data.Complex.$fStorableComplex_$csizeOf
           @ a_XgsQI $dStorable_XgsVQ)
        (Data.Complex.$fStorableComplex_$calignment
           @ a_XgsQI $dStorable_XgsVQ)
        ((Data.Complex.$fStorableComplex7 @ a_XgsQI $dStorable_XgsVQ)
         `cast` (<GHC.Ptr.Ptr (Complex a_XgsQI)>_R
                 ->_R <Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Complex a_XgsQI>_R)
                 :: (GHC.Ptr.Ptr (Complex a_XgsQI)
                     -> Int
                     -> GHC.Prim.State# GHC.Prim.RealWorld
                     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Complex a_XgsQI #) :: *)
                    ~R# (GHC.Ptr.Ptr (Complex a_XgsQI)
                         -> Int -> IO (Complex a_XgsQI) :: *)))
        ((Data.Complex.$fStorableComplex6 @ a_XgsQI $dStorable_XgsVQ)
         `cast` (<GHC.Ptr.Ptr (Complex a_XgsQI)>_R
                 ->_R <Int>_R
                 ->_R <Complex a_XgsQI>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (GHC.Ptr.Ptr (Complex a_XgsQI)
                     -> Int
                     -> Complex a_XgsQI
                     -> GHC.Prim.State# GHC.Prim.RealWorld
                     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)
                    ~R# (GHC.Ptr.Ptr (Complex a_XgsQI)
                         -> Int -> Complex a_XgsQI -> IO () :: *)))
        ((Data.Complex.$fStorableComplex5 @ a_XgsQI $dStorable_XgsVQ)
         `cast` (forall (b :: <*>_N).
                 <GHC.Ptr.Ptr b>_R
                 ->_R <Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Complex a_XgsQI>_R)
                 :: (forall b.
                     GHC.Ptr.Ptr b
                     -> Int
                     -> GHC.Prim.State# GHC.Prim.RealWorld
                     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Complex a_XgsQI #) :: *)
                    ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO (Complex a_XgsQI) :: *)))
        ((Data.Complex.$fStorableComplex4 @ a_XgsQI $dStorable_XgsVQ)
         `cast` (forall (b :: <*>_N).
                 <GHC.Ptr.Ptr b>_R
                 ->_R <Int>_R
                 ->_R <Complex a_XgsQI>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (forall b.
                     GHC.Ptr.Ptr b
                     -> Int
                     -> Complex a_XgsQI
                     -> GHC.Prim.State# GHC.Prim.RealWorld
                     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)
                    ~R# (forall b.
                         GHC.Ptr.Ptr b -> Int -> Complex a_XgsQI -> IO () :: *)))
        ((Data.Complex.$fStorableComplex3 @ a_XgsQI $dStorable_XgsVQ)
         `cast` (<GHC.Ptr.Ptr (Complex a_XgsQI)>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Complex a_XgsQI>_R)
                 :: (GHC.Ptr.Ptr (Complex a_XgsQI)
                     -> GHC.Prim.State# GHC.Prim.RealWorld
                     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Complex a_XgsQI #) :: *)
                    ~R# (GHC.Ptr.Ptr (Complex a_XgsQI) -> IO (Complex a_XgsQI) :: *)))
        ((Data.Complex.$fStorableComplex1 @ a_XgsQI $dStorable_XgsVQ)
         `cast` (<GHC.Ptr.Ptr (Complex a_XgsQI)>_R
                 ->_R <Complex a_XgsQI>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (GHC.Ptr.Ptr (Complex a_XgsQI)
                     -> Complex a_XgsQI
                     -> GHC.Prim.State# GHC.Prim.RealWorld
                     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #) :: *)
                    ~R# (GHC.Ptr.Ptr (Complex a_XgsQI)
                         -> Complex a_XgsQI -> IO () :: *)))

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
imagPart :: forall a. Complex a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agszq) (ds_dgt8F [Occ=Once!] :: Complex a_agszq) ->
                 case ds_dgt8F of { :+ _ [Occ=Dead] y_agspB [Occ=Once] ->
                 y_agspB
                 }}]
imagPart
  = \ (@ a_agszq) (ds_dgt8F :: Complex a_agszq) ->
      case ds_dgt8F of { :+ ds1_dgt8L y_agspB -> y_agspB }

-- RHS size: {terms: 18, types: 22, coercions: 0, joins: 0/0}
Data.Complex.$fMonadComplex_$c>>=
  :: forall a b. Complex a -> (a -> Complex b) -> Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><C(S(SS)),C(U(U,U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsL4)
                 (@ b_agsL5)
                 (ds_dgt9V [Occ=Once!] :: Complex a_agsL4)
                 (f_agsnv :: a_agsL4 -> Complex b_agsL5) ->
                 case ds_dgt9V of { :+ a1_agsnt [Occ=Once] b1_agsnu [Occ=Once] ->
                 case f_agsnv a1_agsnt of { :+ x_agspA [Occ=Once] _ [Occ=Dead] ->
                 case f_agsnv b1_agsnu of { :+ _ [Occ=Dead] y_agspB [Occ=Once] ->
                 Data.Complex.:+ @ b_agsL5 x_agspA y_agspB
                 }
                 }
                 }}]
Data.Complex.$fMonadComplex_$c>>=
  = \ (@ a_agsL4)
      (@ b_agsL5)
      (ds_dgt9V :: Complex a_agsL4)
      (f_agsnv :: a_agsL4 -> Complex b_agsL5) ->
      case ds_dgt9V of { :+ a1_agsnt b1_agsnu ->
      case f_agsnv a1_agsnt of { :+ x_agspA ds1_dgt8T ->
      case f_agsnv b1_agsnu of { :+ ds2_dgt8L y_agspB ->
      Data.Complex.:+ @ b_agsL5 x_agspA y_agspB
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fMonadComplex_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. Complex a -> Complex b -> Complex b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_agsLd)
                 (@ b_agsLe)
                 (m1_ibJeL [Occ=Once!] :: Complex a_agsLd)
                 (k_ibJeM [Occ=Once!] :: Complex b_agsLe) ->
                 case m1_ibJeL of { :+ _ [Occ=Dead] _ [Occ=Dead] ->
                 case k_ibJeM of { :+ x_agspA [Occ=Once] ds_dgt8T [Occ=Once] ->
                 Data.Complex.$W:+ @ b_agsLe x_agspA ds_dgt8T
                 }
                 }}]
Data.Complex.$fMonadComplex_$c>>
  = Data.Complex.$fApplicativeComplex_$c*>

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
lvl13_rgA6r :: forall a. [Char] -> Complex a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
lvl13_rgA6r
  = \ (@ a_agsLv) (eta_B1 :: [Char]) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep @ (Complex a_agsLv) eta_B1

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fMonadComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Monad Complex
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: Complex
                        Data.Complex.$fApplicativeComplex
                        Data.Complex.$fMonadComplex_$c>>=
                        Data.Complex.$fMonadComplex_$c>>
                        Data.Complex.$fApplicativeComplex_$cpure
                        \ (@ a_agsLv) ->
                          errorWithoutStackTrace @ 'GHC.Types.LiftedRep @ (Complex a_agsLv)]
Data.Complex.$fMonadComplex
  = GHC.Base.C:Monad
      @ Complex
      Data.Complex.$fApplicativeComplex
      Data.Complex.$fMonadComplex_$c>>=
      Data.Complex.$fMonadComplex_$c>>
      Data.Complex.$fApplicativeComplex_$cpure
      lvl13_rgA6r

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fDataComplex6 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Complex.$fDataComplex6 = "Complex"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fDataComplex9 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Complex.$fDataComplex9
  = GHC.CString.unpackCString# Data.Complex.$fDataComplex6

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go61_rgA6s :: [Data.Data.Constr] -> [Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go61_rgA6s
  = \ (ds2_iaIB3 :: [Data.Data.Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds2_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Data.Data.Constr ds3_de7m3 ds4_de7m4 ds5_de7m5 ds6_de7m6
                                 ds7_de7m7 ->
              case GHC.Base.eqString ds4_de7m4 Data.Complex.$fReadComplex3 of {
                False -> go61_rgA6s ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$c:+1_rgA6t :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$c:+1_rgA6t = Data.Data.AlgConstr $c:+2_rgA6u

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Complex.$fDataComplex8 :: [Data.Data.Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fDataComplex8
  = GHC.Types.:
      @ Data.Data.Constr
      Data.Complex.$c:+
      (GHC.Types.[] @ Data.Data.Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fDataComplex7 :: Data.Data.DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Complex.$fDataComplex7
  = Data.Data.AlgRep Data.Complex.$fDataComplex8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$tComplex :: Data.Data.DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$tComplex
  = Data.Data.DataType
      Data.Complex.$fDataComplex9 Data.Complex.$fDataComplex7

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$c:+ [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Complex.$c:+
  = Data.Data.Constr
      $c:+1_rgA6t
      Data.Complex.$fReadComplex3
      (GHC.Types.[] @ String)
      Data.Data.Infix
      Data.Complex.$tComplex

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$c:+2_rgA6u :: Data.Data.ConIndex
[GblId]
$c:+2_rgA6u
  = go61_rgA6s Data.Complex.$fDataComplex8 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Complex.$trModule3 = GHC.Types.TrNameS Data.Complex.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Complex.$trModule2 = "Data.Complex"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Complex.$trModule1 = GHC.Types.TrNameS Data.Complex.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$trModule
  = GHC.Types.Module Data.Complex.$trModule3 Data.Complex.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep_rgA6v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep_rgA6v = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fDataComplex5 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Complex.$fDataComplex5
  = GHC.Types.TrNameS Data.Complex.$fDataComplex6

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$tcComplex :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Complex.$tcComplex
  = GHC.Types.TyCon
      1343342814679332338##
      7004386227939987578##
      Data.Complex.$trModule
      Data.Complex.$fDataComplex5
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep1_rgA6w :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep1_rgA6w
  = GHC.Types.:
      @ GHC.Types.KindRep $krep_rgA6v (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2_rgA6x :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep2_rgA6x
  = GHC.Types.KindRepTyConApp Data.Complex.$tcComplex $krep1_rgA6w

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3_rgA6y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep3_rgA6y = GHC.Types.KindRepFun $krep_rgA6v $krep2_rgA6x

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$tc':+1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Complex.$tc':+1
  = GHC.Types.KindRepFun $krep_rgA6v $krep3_rgA6y

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$tc':+3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Complex.$tc':+3 = "':+"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$tc':+2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Complex.$tc':+2 = GHC.Types.TrNameS Data.Complex.$tc':+3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$tc':+ :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Complex.$tc':+
  = GHC.Types.TyCon
      6922641126191179007##
      8119904032930905711##
      Data.Complex.$trModule
      Data.Complex.$tc':+2
      1#
      Data.Complex.$tc':+1

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Complex.$fDataComplex4
  :: Data.Typeable.Internal.TypeRep Complex
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Complex.$fDataComplex4
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Complex
           1343342814679332338##
           7004386227939987578##
           Data.Complex.$trModule
           Data.Complex.$fDataComplex5
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Complex
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Complex.$fDataComplex10
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (Complex a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsBe) ($dData_agsBf [Occ=Once] :: Data a_agsBe) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Complex
                   @ a_agsBe
                   Data.Complex.$fDataComplex4
                   ((Data.Data.$p1Data @ a_agsBe $dData_agsBf)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_agsBe>_N
                            :: (Data.Typeable.Internal.Typeable a_agsBe :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_agsBe :: *)))}]
Data.Complex.$fDataComplex10
  = \ (@ a_agsBe) ($dData_agsBf :: Data a_agsBe) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Complex
        @ a_agsBe
        Data.Complex.$fDataComplex4
        ((Data.Data.$p1Data @ a_agsBe $dData_agsBf)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_agsBe>_N
                 :: (Data.Typeable.Internal.Typeable a_agsBe :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_agsBe :: *)))

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Complex.$fDataComplex_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Complex a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Complex.$fDataComplex_$cdataCast1
  = \ (@ a_XgsGb)
      ($dData_XgsGd :: Data a_XgsGb)
      (@ (t_agsBX :: * -> *))
      (@ (c_agsBY :: * -> *))
      ($dTypeable_agsC0 :: Data.Typeable.Internal.Typeable t_agsBX) ->
      let {
        lvl17_sgup0 :: Bool
        [LclId]
        lvl17_sgup0
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_agsBX
              @ Complex
              ($dTypeable_agsC0
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_agsBX>_N
                       :: (Data.Typeable.Internal.Typeable t_agsBX :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_agsBX :: *)))
              Data.Complex.$fDataComplex4 } in
      \ (f_agstK :: forall d. Data d => c_agsBY (t_agsBX d)) ->
        case lvl17_sgup0 of {
          False -> GHC.Base.Nothing @ (c_agsBY (Complex a_XgsGb));
          True ->
            GHC.Base.Just
              @ (c_agsBY (Complex a_XgsGb))
              ((f_agstK @ a_XgsGb $dData_XgsGd)
               `cast` (<c_agsBY>_R (UnsafeCo nominal t_agsBX Complex <a_XgsGb>_N)
                       :: (c_agsBY (t_agsBX a_XgsGb) :: *)
                          ~R# (c_agsBY (Complex a_XgsGb) :: *)))
        }

-- RHS size: {terms: 4, types: 8, coercions: 0, joins: 0/0}
Data.Complex.$fDataComplex1
  :: forall a. (a -> a -> Complex a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fDataComplex1
  = \ (@ a_XgsGk) -> (Data.Complex.$W:+ @ a_XgsGk, GHC.Types.False)

-- RHS size: {terms: 73, types: 139, coercions: 17, joins: 0/4}
Data.Complex.$fDataComplex_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data d => d -> m d) -> Complex a -> m (Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 20] 640 0}]
Data.Complex.$fDataComplex_$cgmapMp
  = \ (@ a_XgsGk)
      ($dData_XgsGm :: Data a_XgsGk)
      (@ (m_agsE3 :: * -> *))
      ($dMonadPlus_agsE5 :: GHC.Base.MonadPlus m_agsE3)
      (ds_dgt9n :: forall d. Data d => d -> m_agsE3 d)
      (eta_B1 :: Complex a_XgsGk) ->
      let {
        lvl17_sgup3 :: m_agsE3 (Complex a_XgsGk)
        [LclId]
        lvl17_sgup3
          = GHC.Base.mzero
              @ m_agsE3 $dMonadPlus_agsE5 @ (Complex a_XgsGk) } in
      let {
        $dMonad_sgunA [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_agsE3
        [LclId]
        $dMonad_sgunA
          = GHC.Base.$p2MonadPlus @ m_agsE3 $dMonadPlus_agsE5 } in
      >>=
        @ m_agsE3
        $dMonad_sgunA
        @ (Complex a_XgsGk, Bool)
        @ (Complex a_XgsGk)
        (case eta_B1 of { :+ a1_agstG a2_agstH ->
         let {
           k_sgunz [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b.
                Data d =>
                Data.Data.Mp m_agsE3 (d -> b) -> d -> m_agsE3 (b, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_sgunz
             = \ (@ d_ae2Ws)
                 (@ b_ae2Wt)
                 ($dData1_ae2Wv :: Data d_ae2Ws)
                 (ds1_de7oC [OS=OneShot]
                    :: Data.Data.Mp m_agsE3 (d_ae2Ws -> b_ae2Wt))
                 (y_ae1Tz [OS=OneShot] :: d_ae2Ws) ->
                 let {
                   lvl18_sgup1 :: m_agsE3 d_ae2Ws
                   [LclId]
                   lvl18_sgup1 = ds_dgt9n @ d_ae2Ws $dData1_ae2Wv y_ae1Tz } in
                 >>=
                   @ m_agsE3
                   $dMonad_sgunA
                   @ (d_ae2Ws -> b_ae2Wt, Bool)
                   @ (b_ae2Wt, Bool)
                   (ds1_de7oC
                    `cast` (Data.Data.N:Mp[0] <m_agsE3>_R <d_ae2Ws -> b_ae2Wt>_N
                            :: (Data.Data.Mp m_agsE3 (d_ae2Ws -> b_ae2Wt) :: *)
                               ~R# (m_agsE3 (d_ae2Ws -> b_ae2Wt, Bool) :: *)))
                   (\ (ds2_de7oD :: (d_ae2Ws -> b_ae2Wt, Bool)) ->
                      case ds2_de7oD of { (h_ae1TA, b1_ae1TB) ->
                      GHC.Base.mplus
                        @ m_agsE3
                        $dMonadPlus_agsE5
                        @ (b_ae2Wt, Bool)
                        (>>=
                           @ m_agsE3
                           $dMonad_sgunA
                           @ d_ae2Ws
                           @ (b_ae2Wt, Bool)
                           lvl18_sgup1
                           (\ (y'_ae1TC :: d_ae2Ws) ->
                              return
                                @ m_agsE3
                                $dMonad_sgunA
                                @ (b_ae2Wt, Bool)
                                (h_ae1TA y'_ae1TC, GHC.Types.True)))
                        (return
                           @ m_agsE3
                           $dMonad_sgunA
                           @ (b_ae2Wt, Bool)
                           (h_ae1TA y_ae1Tz, b1_ae1TB))
                      }) } in
         k_sgunz
           @ a_XgsGk
           @ (Complex a_XgsGk)
           $dData_XgsGm
           ((k_sgunz
               @ a_XgsGk
               @ (a_XgsGk -> Complex a_XgsGk)
               $dData_XgsGm
               ((return
                   @ m_agsE3
                   $dMonad_sgunA
                   @ (a_XgsGk -> a_XgsGk -> Complex a_XgsGk, Bool)
                   (Data.Complex.$fDataComplex1 @ a_XgsGk))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_agsE3>_R <a_XgsGk -> a_XgsGk -> Complex a_XgsGk>_N)
                        :: (m_agsE3 (a_XgsGk -> a_XgsGk -> Complex a_XgsGk, Bool) :: *)
                           ~R# (Data.Data.Mp
                                  m_agsE3 (a_XgsGk -> a_XgsGk -> Complex a_XgsGk) :: *)))
               a1_agstG)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_agsE3>_R <a_XgsGk -> Complex a_XgsGk>_N)
                    :: (m_agsE3 (a_XgsGk -> Complex a_XgsGk, Bool) :: *)
                       ~R# (Data.Data.Mp m_agsE3 (a_XgsGk -> Complex a_XgsGk) :: *)))
           a2_agstH
         })
        (\ (ds1_de7oa :: (Complex a_XgsGk, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl17_sgup3;
             True -> return @ m_agsE3 $dMonad_sgunA @ (Complex a_XgsGk) x'_ae1TD
           }
           })

-- RHS size: {terms: 38, types: 69, coercions: 0, joins: 0/2}
Data.Complex.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> a -> a -> m (Complex a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0 0] 340 0}]
Data.Complex.$w$cgmapM
  = \ (@ a_sgxtV)
      (w_sgxtW :: Data a_sgxtV)
      (@ (m_sgxtX :: * -> *))
      (w1_sgxtY :: Monad m_sgxtX)
      (w2_sgxtZ :: forall d. Data d => d -> m_sgxtX d)
      (ww_sgxu3
         :: a_sgxtV
         Unf=OtherCon [])
      (ww1_sgxu4
         :: a_sgxtV
         Unf=OtherCon []) ->
      let {
        k_sgunw [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
          :: forall d b. Data d => m_sgxtX (d -> b) -> d -> m_sgxtX b
        [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
        k_sgunw
          = \ (@ d_ae2Vh)
              (@ b_ae2Vi)
              ($dData1_ae2Vk :: Data d_ae2Vh)
              (c_ae1Tm [OS=OneShot] :: m_sgxtX (d_ae2Vh -> b_ae2Vi))
              (x_ae1Tn [OS=OneShot] :: d_ae2Vh) ->
              let {
                lvl17_sgup4 :: m_sgxtX d_ae2Vh
                [LclId]
                lvl17_sgup4 = w2_sgxtZ @ d_ae2Vh $dData1_ae2Vk x_ae1Tn } in
              >>=
                @ m_sgxtX
                w1_sgxtY
                @ (d_ae2Vh -> b_ae2Vi)
                @ b_ae2Vi
                c_ae1Tm
                (\ (c'_ae1To :: d_ae2Vh -> b_ae2Vi) ->
                   >>=
                     @ m_sgxtX
                     w1_sgxtY
                     @ d_ae2Vh
                     @ b_ae2Vi
                     lvl17_sgup4
                     (\ (x'_ae1Tp :: d_ae2Vh) ->
                        return @ m_sgxtX w1_sgxtY @ b_ae2Vi (c'_ae1To x'_ae1Tp))) } in
      k_sgunw
        @ a_sgxtV
        @ (Complex a_sgxtV)
        w_sgxtW
        (k_sgunw
           @ a_sgxtV
           @ (a_sgxtV -> Complex a_sgxtV)
           w_sgxtW
           (return
              @ m_sgxtX
              w1_sgxtY
              @ (a_sgxtV -> a_sgxtV -> Complex a_sgxtV)
              (Data.Complex.$W:+ @ a_sgxtV))
           ww_sgxu3)
        ww1_sgxu4

-- RHS size: {terms: 15, types: 25, coercions: 0, joins: 0/0}
Data.Complex.$fDataComplex_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Complex a -> m (Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxtV)
                 (w_sgxtW [Occ=Once] :: Data a_sgxtV)
                 (@ (m_sgxtX :: * -> *))
                 (w1_sgxtY [Occ=Once] :: Monad m_sgxtX)
                 (w2_sgxtZ [Occ=Once] :: forall d. Data d => d -> m_sgxtX d)
                 (w3_sgxu0 [Occ=Once!] :: Complex a_sgxtV) ->
                 case w3_sgxu0 of { :+ ww1_sgxu3 [Occ=Once] ww2_sgxu4 [Occ=Once] ->
                 Data.Complex.$w$cgmapM
                   @ a_sgxtV w_sgxtW @ m_sgxtX w1_sgxtY w2_sgxtZ ww1_sgxu3 ww2_sgxu4
                 }}]
Data.Complex.$fDataComplex_$cgmapM
  = \ (@ a_sgxtV)
      (w_sgxtW :: Data a_sgxtV)
      (@ (m_sgxtX :: * -> *))
      (w1_sgxtY :: Monad m_sgxtX)
      (w2_sgxtZ :: forall d. Data d => d -> m_sgxtX d)
      (w3_sgxu0 :: Complex a_sgxtV) ->
      case w3_sgxu0 of { :+ ww1_sgxu3 ww2_sgxu4 ->
      Data.Complex.$w$cgmapM
        @ a_sgxtV w_sgxtW @ m_sgxtX w1_sgxtY w2_sgxtZ ww1_sgxu3 ww2_sgxu4
      }

-- RHS size: {terms: 24, types: 25, coercions: 0, joins: 0/0}
Data.Complex.$fDataComplex_$cgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> Complex a -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgsOE)
                 ($dData_XgsGk [Occ=Once*] :: Data a_XgsOE)
                 (@ u_agsDz)
                 (ds_dgt9k [Occ=Once!] :: Int)
                 (ds1_dgt9l [Occ=Once*!] :: forall d. Data d => d -> u_agsDz)
                 (x_ae1T7 [Occ=Once!] :: Complex a_XgsOE) ->
                 case x_ae1T7 of { :+ a1_agstG [Occ=Once] a2_agstH [Occ=Once] ->
                 case ds_dgt9k of { GHC.Types.I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_agsDz;
                   0# -> ds1_dgt9l @ a_XgsOE $dData_XgsGk a1_agstG;
                   1# -> ds1_dgt9l @ a_XgsOE $dData_XgsGk a2_agstH
                 }
                 }
                 }}]
Data.Complex.$fDataComplex_$cgmapQi
  = \ (@ a_XgsOE)
      ($dData_XgsGk :: Data a_XgsOE)
      (@ u_agsDz)
      (ds_dgt9k :: Int)
      (ds1_dgt9l :: forall d. Data d => d -> u_agsDz)
      (x_ae1T7 :: Complex a_XgsOE) ->
      case x_ae1T7 of { :+ a1_agstG a2_agstH ->
      case ds_dgt9k of { GHC.Types.I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_agsDz;
        0# -> ds1_dgt9l @ a_XgsOE $dData_XgsGk a1_agstG;
        1# -> ds1_dgt9l @ a_XgsOE $dData_XgsGk a2_agstH
      }
      }
      }

-- RHS size: {terms: 20, types: 26, coercions: 0, joins: 0/0}
Data.Complex.$fDataComplex_$cgmapQr [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Complex a -> r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxu7)
                 (w_sgxu8 :: Data a_sgxu7)
                 (@ r_sgxu9)
                 (@ r'_sgxua)
                 (w1_sgxub :: r'_sgxua -> r_sgxu9 -> r_sgxu9)
                 (w2_sgxuc [Occ=Once] :: r_sgxu9)
                 (w3_sgxud :: forall d. Data d => d -> r'_sgxua)
                 (w4_sgxue [Occ=Once!] :: Complex a_sgxu7) ->
                 case w4_sgxue of { :+ ww1_sgxuh [Occ=Once] ww2_sgxui [Occ=Once] ->
                 w1_sgxub
                   (w3_sgxud @ a_sgxu7 w_sgxu8 ww1_sgxuh)
                   (w1_sgxub (w3_sgxud @ a_sgxu7 w_sgxu8 ww2_sgxui) w2_sgxuc)
                 }}]
Data.Complex.$fDataComplex_$cgmapQr
  = \ (@ a_sgxu7)
      (w_sgxu8 :: Data a_sgxu7)
      (@ r_sgxu9)
      (@ r'_sgxua)
      (w1_sgxub :: r'_sgxua -> r_sgxu9 -> r_sgxu9)
      (w2_sgxuc :: r_sgxu9)
      (w3_sgxud :: forall d. Data d => d -> r'_sgxua)
      (w4_sgxue :: Complex a_sgxu7) ->
      case w4_sgxue of { :+ ww1_sgxuh ww2_sgxui ->
      w1_sgxub
        (w3_sgxud @ a_sgxu7 w_sgxu8 ww1_sgxuh)
        (w1_sgxub (w3_sgxud @ a_sgxu7 w_sgxu8 ww2_sgxui) w2_sgxuc)
      }

-- RHS size: {terms: 17, types: 23, coercions: 0, joins: 0/0}
Data.Complex.$fDataComplex_$cgmapQ
  :: forall a.
     Data a =>
     forall u. (forall d. Data d => d -> u) -> Complex a -> [u]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,C(C1(U))><S(SS),1*U(U,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgsGh)
                 ($dData_XgsGj :: Data a_XgsGh)
                 (@ u_agsDl)
                 (ds_dgt9j :: forall d. Data d => d -> u_agsDl)
                 (x0_ae1SX [Occ=Once!] :: Complex a_XgsGh) ->
                 case x0_ae1SX of { :+ a1_agstG [Occ=Once] a2_agstH [Occ=Once] ->
                 GHC.Types.:
                   @ u_agsDl
                   (ds_dgt9j @ a_XgsGh $dData_XgsGj a1_agstG)
                   (GHC.Types.:
                      @ u_agsDl
                      (ds_dgt9j @ a_XgsGh $dData_XgsGj a2_agstH)
                      (GHC.Types.[] @ u_agsDl))
                 }}]
Data.Complex.$fDataComplex_$cgmapQ
  = \ (@ a_XgsGh)
      ($dData_XgsGj :: Data a_XgsGh)
      (@ u_agsDl)
      (ds_dgt9j :: forall d. Data d => d -> u_agsDl)
      (x0_ae1SX :: Complex a_XgsGh) ->
      case x0_ae1SX of { :+ a1_agstG a2_agstH ->
      GHC.Types.:
        @ u_agsDl
        (ds_dgt9j @ a_XgsGh $dData_XgsGj a1_agstG)
        (GHC.Types.:
           @ u_agsDl
           (ds_dgt9j @ a_XgsGh $dData_XgsGj a2_agstH)
           (GHC.Types.[] @ u_agsDl))
      }

-- RHS size: {terms: 20, types: 26, coercions: 7, joins: 0/0}
Data.Complex.$fDataComplex2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> Complex a
     -> Data.Functor.Const.Const r (Complex a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgxDW)
                 (w_XgxDY :: Data a_XgxDW)
                 (@ r_XgxE0)
                 (@ r'_XgxE2)
                 (w1_XgxE4 :: r_XgxE0 -> r'_XgxE2 -> r_XgxE0)
                 (w2_XgxE6 [Occ=Once] :: r_XgxE0)
                 (w3_XgxE8 :: forall d. Data d => d -> r'_XgxE2)
                 (w4_sgxus [Occ=Once!] :: Complex a_XgxDW) ->
                 case w4_sgxus of { :+ ww1_XgxEg [Occ=Once] ww2_XgxEi [Occ=Once] ->
                 (w1_XgxE4
                    (w1_XgxE4 w2_XgxE6 (w3_XgxE8 @ a_XgxDW w_XgxDY ww1_XgxEg))
                    (w3_XgxE8 @ a_XgxDW w_XgxDY ww2_XgxEi))
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_XgxE0>_R <Complex a_XgxDW>_P)
                         :: (r_XgxE0 :: *)
                            ~R# (Data.Functor.Const.Const r_XgxE0 (Complex a_XgxDW) :: *))
                 }}]
Data.Complex.$fDataComplex2
  = \ (@ a_XgxDW)
      (w_XgxDY :: Data a_XgxDW)
      (@ r_XgxE0)
      (@ r'_XgxE2)
      (w1_XgxE4 :: r_XgxE0 -> r'_XgxE2 -> r_XgxE0)
      (w2_XgxE6 :: r_XgxE0)
      (w3_XgxE8 :: forall d. Data d => d -> r'_XgxE2)
      (w4_sgxus :: Complex a_XgxDW) ->
      case w4_sgxus of { :+ ww1_XgxEg ww2_XgxEi ->
      (w1_XgxE4
         (w1_XgxE4 w2_XgxE6 (w3_XgxE8 @ a_XgxDW w_XgxDY ww1_XgxEg))
         (w3_XgxE8 @ a_XgxDW w_XgxDY ww2_XgxEi))
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_XgxE0>_R <Complex a_XgxDW>_P)
              :: (r_XgxE0 :: *)
                 ~R# (Data.Functor.Const.Const r_XgxE0 (Complex a_XgxDW) :: *))
      }

-- RHS size: {terms: 20, types: 21, coercions: 4, joins: 0/0}
Data.Complex.$fDataComplex3
  :: forall a.
     Data a =>
     (forall b. Data b => b -> b)
     -> Complex a -> Data.Functor.Identity.Identity (Complex a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(C(S)),C(C1(U))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XgsOE)
                 ($dData_XgsGg :: Data a_XgsOE)
                 (ds_dgt9c :: forall b. Data b => b -> b)
                 (x0_Xe2jm [Occ=Once!] :: Complex a_XgsOE) ->
                 case x0_Xe2jm of { :+ a1_agstG [Occ=Once] a2_agstH [Occ=Once] ->
                 case ds_dgt9c @ a_XgsOE $dData_XgsGg a1_agstG of dt_Xgsqi
                 { __DEFAULT ->
                 case ds_dgt9c @ a_XgsOE $dData_XgsGg a2_agstH of dt1_XgsyX
                 { __DEFAULT ->
                 (Data.Complex.:+ @ a_XgsOE dt_Xgsqi dt1_XgsyX)
                 `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Complex a_XgsOE>_R)
                         :: (Complex a_XgsOE :: *)
                            ~R# (Data.Functor.Identity.Identity (Complex a_XgsOE) :: *))
                 }
                 }
                 }}]
Data.Complex.$fDataComplex3
  = \ (@ a_XgsOE)
      ($dData_XgsGg :: Data a_XgsOE)
      (ds_dgt9c :: forall b. Data b => b -> b)
      (x0_Xe2jm :: Complex a_XgsOE) ->
      case x0_Xe2jm of { :+ a1_agstG a2_agstH ->
      case ds_dgt9c @ a_XgsOE $dData_XgsGg a1_agstG of dt_Xgsqi
      { __DEFAULT ->
      case ds_dgt9c @ a_XgsOE $dData_XgsGg a2_agstH of dt1_XgsyX
      { __DEFAULT ->
      (Data.Complex.:+ @ a_XgsOE dt_Xgsqi dt1_XgsyX)
      `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                       <Complex a_XgsOE>_R)
              :: (Complex a_XgsOE :: *)
                 ~R# (Data.Functor.Identity.Identity (Complex a_XgsOE) :: *))
      }
      }
      }

-- RHS size: {terms: 83, types: 146, coercions: 17, joins: 0/4}
Data.Complex.$fDataComplex_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data d => d -> m d) -> Complex a -> m (Complex a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 20] 720 0}]
Data.Complex.$fDataComplex_$cgmapMo
  = \ (@ a_XgsGd)
      ($dData_XgsM9 :: Data a_XgsGd)
      (@ (m_agsEj :: * -> *))
      ($dMonadPlus_agsEl :: GHC.Base.MonadPlus m_agsEj)
      (ds_dgt9o :: forall d. Data d => d -> m_agsEj d)
      (eta_X5Z :: Complex a_XgsGd) ->
      let {
        lvl17_sgupa :: m_agsEj (Complex a_XgsGd)
        [LclId]
        lvl17_sgupa
          = GHC.Base.mzero
              @ m_agsEj $dMonadPlus_agsEl @ (Complex a_XgsGd) } in
      let {
        $dMonad_sgunu [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_agsEj
        [LclId]
        $dMonad_sgunu
          = GHC.Base.$p2MonadPlus @ m_agsEj $dMonadPlus_agsEl } in
      >>=
        @ m_agsEj
        $dMonad_sgunu
        @ (Complex a_XgsGd, Bool)
        @ (Complex a_XgsGd)
        (case eta_X5Z of { :+ a1_agstG a2_agstH ->
         let {
           k_sgunt [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b.
                Data d =>
                Data.Data.Mp m_agsEj (d -> b) -> d -> m_agsEj (b, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_sgunt
             = \ (@ d_ae2Ya)
                 (@ b_ae2Yb)
                 ($dData1_ae2Yd :: Data d_ae2Ya)
                 (ds1_de7pC [OS=OneShot]
                    :: Data.Data.Mp m_agsEj (d_ae2Ya -> b_ae2Yb))
                 (y_ae1TO [OS=OneShot] :: d_ae2Ya) ->
                 let {
                   lvl18_sgup8 :: m_agsEj d_ae2Ya
                   [LclId]
                   lvl18_sgup8 = ds_dgt9o @ d_ae2Ya $dData1_ae2Yd y_ae1TO } in
                 >>=
                   @ m_agsEj
                   $dMonad_sgunu
                   @ (d_ae2Ya -> b_ae2Yb, Bool)
                   @ (b_ae2Yb, Bool)
                   (ds1_de7pC
                    `cast` (Data.Data.N:Mp[0] <m_agsEj>_R <d_ae2Ya -> b_ae2Yb>_N
                            :: (Data.Data.Mp m_agsEj (d_ae2Ya -> b_ae2Yb) :: *)
                               ~R# (m_agsEj (d_ae2Ya -> b_ae2Yb, Bool) :: *)))
                   (\ (ds2_de7pD :: (d_ae2Ya -> b_ae2Yb, Bool)) ->
                      case ds2_de7pD of { (h_ae1TP, b1_ae1TQ) ->
                      case b1_ae1TQ of {
                        False ->
                          GHC.Base.mplus
                            @ m_agsEj
                            $dMonadPlus_agsEl
                            @ (b_ae2Yb, Bool)
                            (>>=
                               @ m_agsEj
                               $dMonad_sgunu
                               @ d_ae2Ya
                               @ (b_ae2Yb, Bool)
                               lvl18_sgup8
                               (\ (y'_ae1TR :: d_ae2Ya) ->
                                  return
                                    @ m_agsEj
                                    $dMonad_sgunu
                                    @ (b_ae2Yb, Bool)
                                    (h_ae1TP y'_ae1TR, GHC.Types.True)))
                            (return
                               @ m_agsEj
                               $dMonad_sgunu
                               @ (b_ae2Yb, Bool)
                               (h_ae1TP y_ae1TO, GHC.Types.False));
                        True ->
                          return
                            @ m_agsEj
                            $dMonad_sgunu
                            @ (b_ae2Yb, Bool)
                            (h_ae1TP y_ae1TO, GHC.Types.True)
                      }
                      }) } in
         k_sgunt
           @ a_XgsGd
           @ (Complex a_XgsGd)
           $dData_XgsM9
           ((k_sgunt
               @ a_XgsGd
               @ (a_XgsGd -> Complex a_XgsGd)
               $dData_XgsM9
               ((return
                   @ m_agsEj
                   $dMonad_sgunu
                   @ (a_XgsGd -> a_XgsGd -> Complex a_XgsGd, Bool)
                   (Data.Complex.$fDataComplex1 @ a_XgsGd))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_agsEj>_R <a_XgsGd -> a_XgsGd -> Complex a_XgsGd>_N)
                        :: (m_agsEj (a_XgsGd -> a_XgsGd -> Complex a_XgsGd, Bool) :: *)
                           ~R# (Data.Data.Mp
                                  m_agsEj (a_XgsGd -> a_XgsGd -> Complex a_XgsGd) :: *)))
               a1_agstG)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_agsEj>_R <a_XgsGd -> Complex a_XgsGd>_N)
                    :: (m_agsEj (a_XgsGd -> Complex a_XgsGd, Bool) :: *)
                       ~R# (Data.Data.Mp m_agsEj (a_XgsGd -> Complex a_XgsGd) :: *)))
           a2_agstH
         })
        (\ (ds1_de7pa :: (Complex a_XgsGd, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl17_sgupa;
             True -> return @ m_agsEj $dMonad_sgunu @ (Complex a_XgsGd) x'_ae1TS
           }
           })

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
lvl14_rgA6z :: forall a. Complex a -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl14_rgA6z
  = \ (@ a_XgsGc) (ds_dgt96 :: Complex a_XgsGc) ->
      case ds_dgt96 of { :+ ds1_dgt97 ds2_dgt98 -> Data.Complex.$c:+ }

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl15_rgA6A :: forall a. Complex a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl15_rgA6A = \ (@ a_XgsGc) _ [Occ=Dead] -> Data.Complex.$tComplex

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl16_rgA6B
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c (Complex a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl16_rgA6B
  = \ (@ a_XgsGc)
      (@ (t_agsCf :: * -> * -> *))
      (@ (c_agsCg :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_agsCg (Complex a_XgsGc))

-- RHS size: {terms: 30, types: 21, coercions: 47, joins: 0/0}
Data.Complex.$fDataComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_agsns) (v_X5W :: Data a_agsns) ->
       Data.Data.C:Data TYPE: Complex a_agsns
                        (Data.Complex.$fDataComplex10 @ a_agsns v_X5W)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Complex
                                                                                    a_agsns>_N
                                :: (Data.Typeable.Internal.TypeRep (Complex a_agsns) :: *)
                                   ~R# (Data.Typeable.Internal.Typeable
                                          (Complex a_agsns) :: Constraint))
                        Data.Complex.$fDataComplex_$cgfoldl @ a_agsns v_X5W
                        Data.Complex.$fDataComplex_$cgunfold @ a_agsns v_X5W
                        \ (ds_dgt96 [Occ=Once!] :: Complex a_agsns) ->
                          case ds_dgt96 of { :+ _ [Occ=Dead] _ [Occ=Dead] ->
                          Data.Complex.$c:+
                          }
                        \ _ [Occ=Dead] -> Data.Complex.$tComplex
                        Data.Complex.$fDataComplex_$cdataCast1 @ a_agsns v_X5W
                        \ (@ (t_agsCf :: * -> * -> *))
                          (@ (c_agsCg :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_agsCg (Complex a_agsns))
                        (Data.Complex.$fDataComplex3 @ a_agsns v_X5W)
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Complex a_agsns>_R
                                ->_R Data.Functor.Identity.N:Identity[0] <Complex a_agsns>_R
                                :: ((forall b. Data b => b -> b)
                                    -> Complex a_agsns
                                    -> Data.Functor.Identity.Identity (Complex a_agsns) :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Complex a_agsns -> Complex a_agsns :: *))
                        (Data.Complex.$fDataComplex2 @ a_agsns v_X5W)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Complex a_agsns>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Complex a_agsns>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Complex a_agsns
                                    -> Data.Functor.Const.Const r (Complex a_agsns) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> Complex a_agsns
                                        -> r :: *))
                        Data.Complex.$fDataComplex_$cgmapQr @ a_agsns v_X5W
                        Data.Complex.$fDataComplex_$cgmapQ @ a_agsns v_X5W
                        Data.Complex.$fDataComplex_$cgmapQi @ a_agsns v_X5W
                        Data.Complex.$fDataComplex_$cgmapM @ a_agsns v_X5W
                        Data.Complex.$fDataComplex_$cgmapMp @ a_agsns v_X5W
                        Data.Complex.$fDataComplex_$cgmapMo @ a_agsns v_X5W]
Data.Complex.$fDataComplex
  = \ (@ a_XgsGc) ($dData_XgsM9 :: Data a_XgsGc) ->
      Data.Data.C:Data
        @ (Complex a_XgsGc)
        ((Data.Complex.$fDataComplex10 @ a_XgsGc $dData_XgsM9)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Complex
                                                                     a_XgsGc>_N
                 :: (Data.Typeable.Internal.TypeRep (Complex a_XgsGc) :: *)
                    ~R# (Data.Typeable.Internal.Typeable
                           (Complex a_XgsGc) :: Constraint)))
        (Data.Complex.$fDataComplex_$cgfoldl @ a_XgsGc $dData_XgsM9)
        (Data.Complex.$fDataComplex_$cgunfold @ a_XgsGc $dData_XgsM9)
        (lvl14_rgA6z @ a_XgsGc)
        (lvl15_rgA6A @ a_XgsGc)
        (Data.Complex.$fDataComplex_$cdataCast1 @ a_XgsGc $dData_XgsM9)
        (lvl16_rgA6B @ a_XgsGc)
        ((Data.Complex.$fDataComplex3 @ a_XgsGc $dData_XgsM9)
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Complex a_XgsGc>_R
                 ->_R Data.Functor.Identity.N:Identity[0] <Complex a_XgsGc>_R
                 :: ((forall b. Data b => b -> b)
                     -> Complex a_XgsGc
                     -> Data.Functor.Identity.Identity (Complex a_XgsGc) :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Complex a_XgsGc -> Complex a_XgsGc :: *)))
        ((Data.Complex.$fDataComplex2 @ a_XgsGc $dData_XgsM9)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <Complex a_XgsGc>_R
                 ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Complex a_XgsGc>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> Complex a_XgsGc
                     -> Data.Functor.Const.Const r (Complex a_XgsGc) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r
                         -> (forall d. Data d => d -> r')
                         -> Complex a_XgsGc
                         -> r :: *)))
        (Data.Complex.$fDataComplex_$cgmapQr @ a_XgsGc $dData_XgsM9)
        (Data.Complex.$fDataComplex_$cgmapQ @ a_XgsGc $dData_XgsM9)
        (Data.Complex.$fDataComplex_$cgmapQi @ a_XgsGc $dData_XgsM9)
        (Data.Complex.$fDataComplex_$cgmapM @ a_XgsGc $dData_XgsM9)
        (Data.Complex.$fDataComplex_$cgmapMp @ a_XgsGc $dData_XgsM9)
        (Data.Complex.$fDataComplex_$cgmapMo @ a_XgsGc $dData_XgsM9)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex9 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Complex.$fFloatingComplex9 = GHC.Types.F# 0.0#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cpi1 :: Complex Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fFloatingComplex_$s$cpi1
  = Data.Complex.:+
      @ Float
      GHC.Float.$fFloatingFloat_$cpi
      Data.Complex.$fFloatingComplex9

-- RHS size: {terms: 24, types: 12, coercions: 0, joins: 0/1}
Data.Complex.$fFloatingComplex_$s$cexp1
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dgtaQ [Occ=Once!] :: Complex Float) ->
                 case ds_dgtaQ of { :+ x_agsnS [Occ=Once!] y_agsnT [Occ=Once!] ->
                 case x_agsnS of { GHC.Types.F# x1_sguph [Occ=Once] ->
                 case y_agsnT of { GHC.Types.F# x2_sgupk ->
                 let {
                   expx_sguGv :: GHC.Prim.Float#
                   [LclId]
                   expx_sguGv = GHC.Prim.expFloat# x1_sguph } in
                 Data.Complex.:+
                   @ Float
                   (GHC.Types.F#
                      (GHC.Prim.timesFloat# expx_sguGv (GHC.Prim.cosFloat# x2_sgupk)))
                   (GHC.Types.F#
                      (GHC.Prim.timesFloat# expx_sguGv (GHC.Prim.sinFloat# x2_sgupk)))
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$cexp1
  = \ (ds_dgtaQ :: Complex Float) ->
      case ds_dgtaQ of { :+ x_agsnS y_agsnT ->
      case x_agsnS of { GHC.Types.F# x1_sgzes ->
      case y_agsnT of { GHC.Types.F# x2_sgzev ->
      let {
        expx_sguGv :: GHC.Prim.Float#
        [LclId]
        expx_sguGv = GHC.Prim.expFloat# x1_sgzes } in
      Data.Complex.:+
        @ Float
        (GHC.Types.F#
           (GHC.Prim.timesFloat# expx_sguGv (GHC.Prim.cosFloat# x2_sgzev)))
        (GHC.Types.F#
           (GHC.Prim.timesFloat# expx_sguGv (GHC.Prim.sinFloat# x2_sgzev)))
      }
      }
      }

-- RHS size: {terms: 23, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$csin1
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dgteO [Occ=Once!] :: Complex Float) ->
                 case ds_dgteO of { :+ x_agsob [Occ=Once!] y_agsoc [Occ=Once!] ->
                 case y_agsoc of { GHC.Types.F# x1_sgupt ->
                 case x_agsob of { GHC.Types.F# x2_sgupq ->
                 Data.Complex.:+
                   @ Float
                   (GHC.Types.F#
                      (GHC.Prim.timesFloat#
                         (GHC.Prim.sinFloat# x2_sgupq) (GHC.Prim.coshFloat# x1_sgupt)))
                   (GHC.Types.F#
                      (GHC.Prim.timesFloat#
                         (GHC.Prim.cosFloat# x2_sgupq) (GHC.Prim.sinhFloat# x1_sgupt)))
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$csin1
  = \ (ds_dgteO :: Complex Float) ->
      case ds_dgteO of { :+ x_agsob y_agsoc ->
      case y_agsoc of { GHC.Types.F# x1_sgzey ->
      case x_agsob of { GHC.Types.F# x2_sgzeB ->
      Data.Complex.:+
        @ Float
        (GHC.Types.F#
           (GHC.Prim.timesFloat#
              (GHC.Prim.sinFloat# x2_sgzeB) (GHC.Prim.coshFloat# x1_sgzey)))
        (GHC.Types.F#
           (GHC.Prim.timesFloat#
              (GHC.Prim.cosFloat# x2_sgzeB) (GHC.Prim.sinhFloat# x1_sgzey)))
      }
      }
      }

-- RHS size: {terms: 24, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$ccos1
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dgtf6 [Occ=Once!] :: Complex Float) ->
                 case ds_dgtf6 of { :+ x_agsod [Occ=Once!] y_agsoe [Occ=Once!] ->
                 case y_agsoe of { GHC.Types.F# x1_sgupF ->
                 case x_agsod of { GHC.Types.F# x2_sgupC ->
                 Data.Complex.:+
                   @ Float
                   (GHC.Types.F#
                      (GHC.Prim.timesFloat#
                         (GHC.Prim.cosFloat# x2_sgupC) (GHC.Prim.coshFloat# x1_sgupF)))
                   (GHC.Types.F#
                      (GHC.Prim.negateFloat#
                         (GHC.Prim.timesFloat#
                            (GHC.Prim.sinFloat# x2_sgupC) (GHC.Prim.sinhFloat# x1_sgupF))))
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$ccos1
  = \ (ds_dgtf6 :: Complex Float) ->
      case ds_dgtf6 of { :+ x_agsod y_agsoe ->
      case y_agsoe of { GHC.Types.F# x1_sgzeE ->
      case x_agsod of { GHC.Types.F# x2_sgzeH ->
      Data.Complex.:+
        @ Float
        (GHC.Types.F#
           (GHC.Prim.timesFloat#
              (GHC.Prim.cosFloat# x2_sgzeH) (GHC.Prim.coshFloat# x1_sgzeE)))
        (GHC.Types.F#
           (GHC.Prim.negateFloat#
              (GHC.Prim.timesFloat#
                 (GHC.Prim.sinFloat# x2_sgzeH) (GHC.Prim.sinhFloat# x1_sgzeE))))
      }
      }
      }

-- RHS size: {terms: 23, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$csinh1
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dgtjT [Occ=Once!] :: Complex Float) ->
                 case ds_dgtjT of { :+ x_agsol [Occ=Once!] y_agsom [Occ=Once!] ->
                 case x_agsol of { GHC.Types.F# x1_sgupR ->
                 case y_agsom of { GHC.Types.F# x2_sgupO ->
                 Data.Complex.:+
                   @ Float
                   (GHC.Types.F#
                      (GHC.Prim.timesFloat#
                         (GHC.Prim.cosFloat# x2_sgupO) (GHC.Prim.sinhFloat# x1_sgupR)))
                   (GHC.Types.F#
                      (GHC.Prim.timesFloat#
                         (GHC.Prim.sinFloat# x2_sgupO) (GHC.Prim.coshFloat# x1_sgupR)))
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$csinh1
  = \ (ds_dgtjT :: Complex Float) ->
      case ds_dgtjT of { :+ x_agsol y_agsom ->
      case x_agsol of { GHC.Types.F# x1_sgzeK ->
      case y_agsom of { GHC.Types.F# x2_sgzeN ->
      Data.Complex.:+
        @ Float
        (GHC.Types.F#
           (GHC.Prim.timesFloat#
              (GHC.Prim.cosFloat# x2_sgzeN) (GHC.Prim.sinhFloat# x1_sgzeK)))
        (GHC.Types.F#
           (GHC.Prim.timesFloat#
              (GHC.Prim.sinFloat# x2_sgzeN) (GHC.Prim.coshFloat# x1_sgzeK)))
      }
      }
      }

-- RHS size: {terms: 23, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$ccosh1
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dgtkb [Occ=Once!] :: Complex Float) ->
                 case ds_dgtkb of { :+ x_agson [Occ=Once!] y_agsoo [Occ=Once!] ->
                 case x_agson of { GHC.Types.F# x1_sguq3 ->
                 case y_agsoo of { GHC.Types.F# x2_sguq0 ->
                 Data.Complex.:+
                   @ Float
                   (GHC.Types.F#
                      (GHC.Prim.timesFloat#
                         (GHC.Prim.cosFloat# x2_sguq0) (GHC.Prim.coshFloat# x1_sguq3)))
                   (GHC.Types.F#
                      (GHC.Prim.timesFloat#
                         (GHC.Prim.sinFloat# x2_sguq0) (GHC.Prim.sinhFloat# x1_sguq3)))
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$ccosh1
  = \ (ds_dgtkb :: Complex Float) ->
      case ds_dgtkb of { :+ x_agson y_agsoo ->
      case x_agson of { GHC.Types.F# x1_sgzeQ ->
      case y_agsoo of { GHC.Types.F# x2_sgzeT ->
      Data.Complex.:+
        @ Float
        (GHC.Types.F#
           (GHC.Prim.timesFloat#
              (GHC.Prim.cosFloat# x2_sgzeT) (GHC.Prim.coshFloat# x1_sgzeQ)))
        (GHC.Types.F#
           (GHC.Prim.timesFloat#
              (GHC.Prim.sinFloat# x2_sgzeT) (GHC.Prim.sinhFloat# x1_sgzeQ)))
      }
      }
      }

-- RHS size: {terms: 71, types: 23, coercions: 0, joins: 1/2}
Data.Complex.$w$s$c/1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> GHC.Prim.Float#
     -> (# Float, Float #)
[GblId,
 Arity=4,
 Str=<S,U><S,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0 0] 202 0}]
Data.Complex.$w$s$c/1
  = \ (ww_sgxuS :: GHC.Prim.Float#)
      (ww1_sgxuX :: GHC.Prim.Float#)
      (ww2_sgxv5 :: GHC.Prim.Float#)
      (ww3_sgxva :: GHC.Prim.Float#) ->
      case GHC.Float.$w$cexponent1 ww2_sgxv5 of ww4_igtvO { __DEFAULT ->
      case GHC.Float.$w$cexponent1 ww3_sgxva of ww5_XgtEM { __DEFAULT ->
      join {
        $j_sgwwQ [Dmd=<C(S),1*C1(U(U,U))>]
          :: GHC.Prim.Int# -> (# Float, Float #)
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_sgwwQ (ww6_igtvX [OS=OneShot] :: GHC.Prim.Int#)
          = case GHC.Float.$w$cscaleFloat1 ww6_igtvX ww2_sgxv5 of ww7_igtw4
            { __DEFAULT ->
            case GHC.Float.$w$cscaleFloat1 ww6_igtvX ww3_sgxva of ww8_XgtF9
            { __DEFAULT ->
            let {
              y_igtwt [Dmd=<S,U>] :: GHC.Prim.Float#
              [LclId]
              y_igtwt
                = GHC.Prim.plusFloat#
                    (GHC.Prim.timesFloat# ww2_sgxv5 ww7_igtw4)
                    (GHC.Prim.timesFloat# ww3_sgxva ww8_XgtF9) } in
            case GHC.Prim.divideFloat#
                   (GHC.Prim.plusFloat#
                      (GHC.Prim.timesFloat# ww_sgxuS ww7_igtw4)
                      (GHC.Prim.timesFloat# ww1_sgxuX ww8_XgtF9))
                   y_igtwt
            of wild2_igtwv
            { __DEFAULT ->
            case GHC.Prim.divideFloat#
                   (GHC.Prim.minusFloat#
                      (GHC.Prim.timesFloat# ww1_sgxuX ww7_igtw4)
                      (GHC.Prim.timesFloat# ww_sgxuS ww8_XgtF9))
                   y_igtwt
            of wild1_XgtLq
            { __DEFAULT ->
            (# GHC.Types.F# wild2_igtwv, GHC.Types.F# wild1_XgtLq #)
            }
            }
            }
            } } in
      case GHC.Prim.<=# ww4_igtvO ww5_XgtEM of {
        __DEFAULT -> jump $j_sgwwQ (GHC.Prim.negateInt# ww4_igtvO);
        1# -> jump $j_sgwwQ (GHC.Prim.negateInt# ww5_XgtEM)
      }
      }
      }

-- RHS size: {terms: 30, types: 28, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$c/1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float -> Complex Float
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxuL [Occ=Once!] :: Complex Float)
                 (w1_sgxuM [Occ=Once!] :: Complex Float) ->
                 case w_sgxuL of { :+ ww1_sgxuP [Occ=Once!] ww2_sgxuU [Occ=Once!] ->
                 case ww1_sgxuP of { GHC.Types.F# ww4_sgxuS [Occ=Once] ->
                 case ww2_sgxuU of { GHC.Types.F# ww6_sgxuX [Occ=Once] ->
                 case w1_sgxuM of
                 { :+ ww8_sgxv2 [Occ=Once!] ww9_sgxv7 [Occ=Once!] ->
                 case ww8_sgxv2 of { GHC.Types.F# ww11_sgxv5 [Occ=Once] ->
                 case ww9_sgxv7 of { GHC.Types.F# ww13_sgxva [Occ=Once] ->
                 case Data.Complex.$w$s$c/1
                        ww4_sgxuS ww6_sgxuX ww11_sgxv5 ww13_sgxva
                 of
                 { (# ww15_sgxQb [Occ=Once], ww16_sgxQc [Occ=Once] #) ->
                 Data.Complex.:+ @ Float ww15_sgxQb ww16_sgxQc
                 }
                 }
                 }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$c/1
  = \ (w_sgxuL :: Complex Float) (w1_sgxuM :: Complex Float) ->
      case w_sgxuL of { :+ ww1_sgxuP ww2_sgxuU ->
      case ww1_sgxuP of { GHC.Types.F# ww4_sgzeW ->
      case ww2_sgxuU of { GHC.Types.F# ww6_sgzeZ ->
      case w1_sgxuM of { :+ ww8_sgxv2 ww9_sgxv7 ->
      case ww8_sgxv2 of { GHC.Types.F# ww11_sgzf2 ->
      case ww9_sgxv7 of { GHC.Types.F# ww13_sgzf5 ->
      case Data.Complex.$w$s$c/1
             ww4_sgzeW ww6_sgzeZ ww11_sgzf2 ww13_sgzf5
      of
      { (# ww15_sgxQb, ww16_sgxQc #) ->
      Data.Complex.:+ @ Float ww15_sgxQb ww16_sgxQc
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 12, types: 8, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cfromRational1
  :: Rational -> Complex Float
[GblId,
 Arity=1,
 Str=<S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_agsp6 [Occ=Once!] :: Rational) ->
                 case a_agsp6 of
                 { GHC.Real.:% n_iebqa [Occ=Once] d_iebqb [Occ=Once] ->
                 case GHC.Float.rationalToFloat n_iebqa d_iebqb of dt_XgsE9
                 { GHC.Types.F# _ [Occ=Dead] ->
                 Data.Complex.:+ @ Float dt_XgsE9 Data.Complex.$fFloatingComplex9
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$cfromRational1
  = \ (a_agsp6 :: Rational) ->
      case a_agsp6 of { GHC.Real.:% n_iebqa d_iebqb ->
      case GHC.Float.rationalToFloat n_iebqa d_iebqb of dt_XgsE9
      { GHC.Types.F# ipv_sguHa ->
      Data.Complex.:+ @ Float dt_XgsE9 Data.Complex.$fFloatingComplex9
      }
      }

-- RHS size: {terms: 29, types: 21, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$c+1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float -> Complex Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxvh [Occ=Once!] :: Complex Float)
                 (w1_sgxvi [Occ=Once!] :: Complex Float) ->
                 case w_sgxvh of { :+ ww1_sgxvl [Occ=Once!] ww2_sgxvq [Occ=Once!] ->
                 case ww1_sgxvl of { GHC.Types.F# ww4_sgxvo [Occ=Once] ->
                 case ww2_sgxvq of { GHC.Types.F# ww6_sgxvt [Occ=Once] ->
                 case w1_sgxvi of
                 { :+ ww8_sgxvy [Occ=Once!] ww9_sgxvD [Occ=Once!] ->
                 case ww8_sgxvy of { GHC.Types.F# ww11_sgxvB [Occ=Once] ->
                 case ww9_sgxvD of { GHC.Types.F# ww13_sgxvG [Occ=Once] ->
                 Data.Complex.:+
                   @ Float
                   (GHC.Types.F# (GHC.Prim.plusFloat# ww4_sgxvo ww11_sgxvB))
                   (GHC.Types.F# (GHC.Prim.plusFloat# ww6_sgxvt ww13_sgxvG))
                 }
                 }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$c+1
  = \ (w_sgxvh :: Complex Float) (w1_sgxvi :: Complex Float) ->
      case w_sgxvh of { :+ ww1_sgxvl ww2_sgxvq ->
      case ww1_sgxvl of { GHC.Types.F# ww4_sgzf8 ->
      case ww2_sgxvq of { GHC.Types.F# ww6_sgzfb ->
      case w1_sgxvi of { :+ ww8_sgxvy ww9_sgxvD ->
      case ww8_sgxvy of { GHC.Types.F# ww11_sgzfe ->
      case ww9_sgxvD of { GHC.Types.F# ww13_sgzfh ->
      Data.Complex.:+
        @ Float
        (GHC.Types.F# (GHC.Prim.plusFloat# ww4_sgzf8 ww11_sgzfe))
        (GHC.Types.F# (GHC.Prim.plusFloat# ww6_sgzfb ww13_sgzfh))
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 29, types: 21, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$c-1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float -> Complex Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxvN [Occ=Once!] :: Complex Float)
                 (w1_sgxvO [Occ=Once!] :: Complex Float) ->
                 case w_sgxvN of { :+ ww1_sgxvR [Occ=Once!] ww2_sgxvW [Occ=Once!] ->
                 case ww1_sgxvR of { GHC.Types.F# ww4_sgxvU [Occ=Once] ->
                 case ww2_sgxvW of { GHC.Types.F# ww6_sgxvZ [Occ=Once] ->
                 case w1_sgxvO of
                 { :+ ww8_sgxw4 [Occ=Once!] ww9_sgxw9 [Occ=Once!] ->
                 case ww8_sgxw4 of { GHC.Types.F# ww11_sgxw7 [Occ=Once] ->
                 case ww9_sgxw9 of { GHC.Types.F# ww13_sgxwc [Occ=Once] ->
                 Data.Complex.:+
                   @ Float
                   (GHC.Types.F# (GHC.Prim.minusFloat# ww4_sgxvU ww11_sgxw7))
                   (GHC.Types.F# (GHC.Prim.minusFloat# ww6_sgxvZ ww13_sgxwc))
                 }
                 }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$c-1
  = \ (w_sgxvN :: Complex Float) (w1_sgxvO :: Complex Float) ->
      case w_sgxvN of { :+ ww1_sgxvR ww2_sgxvW ->
      case ww1_sgxvR of { GHC.Types.F# ww4_sgzfk ->
      case ww2_sgxvW of { GHC.Types.F# ww6_sgzfn ->
      case w1_sgxvO of { :+ ww8_sgxw4 ww9_sgxw9 ->
      case ww8_sgxw4 of { GHC.Types.F# ww11_sgzfq ->
      case ww9_sgxw9 of { GHC.Types.F# ww13_sgzft ->
      Data.Complex.:+
        @ Float
        (GHC.Types.F# (GHC.Prim.minusFloat# ww4_sgzfk ww11_sgzfq))
        (GHC.Types.F# (GHC.Prim.minusFloat# ww6_sgzfn ww13_sgzft))
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 37, types: 21, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$c*1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float -> Complex Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxwj [Occ=Once!] :: Complex Float)
                 (w1_sgxwk [Occ=Once!] :: Complex Float) ->
                 case w_sgxwj of { :+ ww1_sgxwn [Occ=Once!] ww2_sgxws [Occ=Once!] ->
                 case ww1_sgxwn of { GHC.Types.F# ww4_sgxwq ->
                 case ww2_sgxws of { GHC.Types.F# ww6_sgxwv ->
                 case w1_sgxwk of
                 { :+ ww8_sgxwA [Occ=Once!] ww9_sgxwF [Occ=Once!] ->
                 case ww8_sgxwA of { GHC.Types.F# ww11_sgxwD ->
                 case ww9_sgxwF of { GHC.Types.F# ww13_sgxwI ->
                 Data.Complex.:+
                   @ Float
                   (GHC.Types.F#
                      (GHC.Prim.minusFloat#
                         (GHC.Prim.timesFloat# ww4_sgxwq ww11_sgxwD)
                         (GHC.Prim.timesFloat# ww6_sgxwv ww13_sgxwI)))
                   (GHC.Types.F#
                      (GHC.Prim.plusFloat#
                         (GHC.Prim.timesFloat# ww4_sgxwq ww13_sgxwI)
                         (GHC.Prim.timesFloat# ww6_sgxwv ww11_sgxwD)))
                 }
                 }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$c*1
  = \ (w_sgxwj :: Complex Float) (w1_sgxwk :: Complex Float) ->
      case w_sgxwj of { :+ ww1_sgxwn ww2_sgxws ->
      case ww1_sgxwn of { GHC.Types.F# ww4_sgzfw ->
      case ww2_sgxws of { GHC.Types.F# ww6_sgzfz ->
      case w1_sgxwk of { :+ ww8_sgxwA ww9_sgxwF ->
      case ww8_sgxwA of { GHC.Types.F# ww11_sgzfC ->
      case ww9_sgxwF of { GHC.Types.F# ww13_sgzfF ->
      Data.Complex.:+
        @ Float
        (GHC.Types.F#
           (GHC.Prim.minusFloat#
              (GHC.Prim.timesFloat# ww4_sgzfw ww11_sgzfC)
              (GHC.Prim.timesFloat# ww6_sgzfz ww13_sgzfF)))
        (GHC.Types.F#
           (GHC.Prim.plusFloat#
              (GHC.Prim.timesFloat# ww4_sgzfw ww13_sgzfF)
              (GHC.Prim.timesFloat# ww6_sgzfz ww11_sgzfC)))
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 17, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cnegate1
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dgtpZ [Occ=Once!] :: Complex Float) ->
                 case ds_dgtpZ of { :+ x_agspk [Occ=Once!] y_agspl [Occ=Once!] ->
                 case x_agspk of { GHC.Types.F# x1_sgurh [Occ=Once] ->
                 case y_agspl of { GHC.Types.F# x2_sgurk [Occ=Once] ->
                 Data.Complex.:+
                   @ Float
                   (GHC.Types.F# (GHC.Prim.negateFloat# x1_sgurh))
                   (GHC.Types.F# (GHC.Prim.negateFloat# x2_sgurk))
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$cnegate1
  = \ (ds_dgtpZ :: Complex Float) ->
      case ds_dgtpZ of { :+ x_agspk y_agspl ->
      case x_agspk of { GHC.Types.F# x1_sgzfI ->
      case y_agspl of { GHC.Types.F# x2_sgzfL ->
      Data.Complex.:+
        @ Float
        (GHC.Types.F# (GHC.Prim.negateFloat# x1_sgzfI))
        (GHC.Types.F# (GHC.Prim.negateFloat# x2_sgzfL))
      }
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cfromInteger1
  :: Integer -> Complex Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_agspr [Occ=Once] :: Integer) ->
                 case integer-simple-0.1.1.1:GHC.Integer.Type.floatFromInteger
                        n_agspr
                 of wild_igtui
                 { __DEFAULT ->
                 Data.Complex.:+
                   @ Float (GHC.Types.F# wild_igtui) Data.Complex.$fFloatingComplex9
                 }}]
Data.Complex.$fFloatingComplex_$s$cfromInteger1
  = \ (n_agspr :: Integer) ->
      case integer-simple-0.1.1.1:GHC.Integer.Type.floatFromInteger
             n_agspr
      of wild_igtui
      { __DEFAULT ->
      Data.Complex.:+
        @ Float (GHC.Types.F# wild_igtui) Data.Complex.$fFloatingComplex9
      }

-- RHS size: {terms: 12, types: 9, coercions: 0, joins: 0/0}
Data.Complex.conjugate_$sconjugate
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dgt8y [Occ=Once!] :: Complex Double) ->
                 case ds_dgt8y of { :+ x_agspC [Occ=Once] y_agspD [Occ=Once!] ->
                 case y_agspD of { GHC.Types.D# x1_sguro [Occ=Once] ->
                 Data.Complex.:+
                   @ Double x_agspC (GHC.Types.D# (GHC.Prim.negateDouble# x1_sguro))
                 }
                 }}]
Data.Complex.conjugate_$sconjugate
  = \ (ds_dgt8y :: Complex Double) ->
      case ds_dgt8y of { :+ x_agspC y_agspD ->
      case y_agspD of { GHC.Types.D# x1_sgzfO ->
      Data.Complex.:+
        @ Double x_agspC (GHC.Types.D# (GHC.Prim.negateDouble# x1_sgzfO))
      }
      }

-- RHS size: {terms: 14, types: 13, coercions: 0, joins: 0/0}
conjugate :: forall a. Num a => Complex a -> Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LLL),1*U(A,A,A,1*C1(U),A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsza)
                 ($dNum_agszc [Occ=Once] :: Num a_agsza)
                 (ds_dgt8y [Occ=Once!] :: Complex a_agsza) ->
                 case ds_dgt8y of { :+ x_agspC [Occ=Once] y_agspD [Occ=Once] ->
                 case negate @ a_agsza $dNum_agszc y_agspD of dt_XgsEn
                 { __DEFAULT ->
                 Data.Complex.:+ @ a_agsza x_agspC dt_XgsEn
                 }
                 }}]
conjugate
  = \ (@ a_agsza)
      ($dNum_agszc :: Num a_agsza)
      (ds_dgt8y :: Complex a_agsza) ->
      case ds_dgt8y of { :+ x_agspC y_agspD ->
      case negate @ a_agsza $dNum_agszc y_agspD of dt_XgsEn
      { __DEFAULT ->
      Data.Complex.:+ @ a_agsza x_agspC dt_XgsEn
      }
      }

-- RHS size: {terms: 11, types: 4, coercions: 0, joins: 0/0}
Data.Complex.cis_$scis :: Double -> Complex Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (theta_agspG [Occ=Once!] :: Double) ->
                 case theta_agspG of { GHC.Types.D# x_igtxC ->
                 Data.Complex.:+
                   @ Double
                   (GHC.Types.D# (GHC.Prim.cosDouble# x_igtxC))
                   (GHC.Types.D# (GHC.Prim.sinDouble# x_igtxC))
                 }}]
Data.Complex.cis_$scis
  = \ (theta_agspG :: Double) ->
      case theta_agspG of { GHC.Types.D# x_igtxC ->
      Data.Complex.:+
        @ Double
        (GHC.Types.D# (GHC.Prim.cosDouble# x_igtxC))
        (GHC.Types.D# (GHC.Prim.sinDouble# x_igtxC))
      }

-- RHS size: {terms: 16, types: 10, coercions: 0, joins: 0/0}
cis :: forall a. Floating a => a -> Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)C(S)LLLLLLLLLLLLLL),U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsyu)
                 ($dFloating_agsyw :: Floating a_agsyu)
                 (theta_agspG :: a_agsyu) ->
                 case cos @ a_agsyu $dFloating_agsyw theta_agspG of dt_XgsEh
                 { __DEFAULT ->
                 case sin @ a_agsyu $dFloating_agsyw theta_agspG of dt1_XgsEm
                 { __DEFAULT ->
                 Data.Complex.:+ @ a_agsyu dt_XgsEh dt1_XgsEm
                 }
                 }}]
cis
  = \ (@ a_agsyu)
      ($dFloating_agsyw :: Floating a_agsyu)
      (theta_agspG :: a_agsyu) ->
      case cos @ a_agsyu $dFloating_agsyw theta_agspG of dt_XgsEh
      { __DEFAULT ->
      case sin @ a_agsyu $dFloating_agsyw theta_agspG of dt1_XgsEm
      { __DEFAULT ->
      Data.Complex.:+ @ a_agsyu dt_XgsEh dt1_XgsEm
      }
      }

-- RHS size: {terms: 19, types: 7, coercions: 0, joins: 0/0}
Data.Complex.mkPolar_$smkPolar
  :: Double -> Double -> Complex Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (r_agspE [Occ=Once!] :: Double)
                 (theta_agspF [Occ=Once!] :: Double) ->
                 case r_agspE of { GHC.Types.D# x_igtxN ->
                 case theta_agspF of { GHC.Types.D# x1_igtxC ->
                 Data.Complex.:+
                   @ Double
                   (GHC.Types.D#
                      (GHC.Prim.*## x_igtxN (GHC.Prim.cosDouble# x1_igtxC)))
                   (GHC.Types.D#
                      (GHC.Prim.*## x_igtxN (GHC.Prim.sinDouble# x1_igtxC)))
                 }
                 }}]
Data.Complex.mkPolar_$smkPolar
  = \ (r_agspE :: Double) (theta_agspF :: Double) ->
      case r_agspE of { GHC.Types.D# x_igtxN ->
      case theta_agspF of { GHC.Types.D# x1_igtxC ->
      Data.Complex.:+
        @ Double
        (GHC.Types.D#
           (GHC.Prim.*## x_igtxN (GHC.Prim.cosDouble# x1_igtxC)))
        (GHC.Types.D#
           (GHC.Prim.*## x_igtxN (GHC.Prim.sinDouble# x1_igtxC)))
      }
      }

-- RHS size: {terms: 29, types: 22, coercions: 0, joins: 0/2}
Data.Complex.$wmkPolar [InlPrag=NOUSERINLINE[0]]
  :: forall a. Floating a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LLC(C(S))LLLL)LLL)LLLLLLLLLLLLLLLLLLLLLL),U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A,A),A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 0 0] 220 30}]
Data.Complex.$wmkPolar
  = \ (@ a_sgxwP)
      (w_sgxwQ :: Floating a_sgxwP)
      (w1_sgxwR :: a_sgxwP)
      (w2_sgxwS :: a_sgxwP) ->
      let {
        $dFractional_sgung [Dmd=<S(S(LLC(C(S))LLLL)LLL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A,A)>]
          :: Fractional a_sgxwP
        [LclId]
        $dFractional_sgung = GHC.Float.$p1Floating @ a_sgxwP w_sgxwQ } in
      let {
        $dNum_sgunf [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
          :: Num a_sgxwP
        [LclId]
        $dNum_sgunf
          = GHC.Real.$p1Fractional @ a_sgxwP $dFractional_sgung } in
      case * @ a_sgxwP
             $dNum_sgunf
             w1_sgxwR
             (cos @ a_sgxwP w_sgxwQ w2_sgxwS)
      of dt_XgsEp
      { __DEFAULT ->
      case * @ a_sgxwP
             $dNum_sgunf
             w1_sgxwR
             (sin @ a_sgxwP w_sgxwQ w2_sgxwS)
      of dt1_XgsEu
      { __DEFAULT ->
      (# dt_XgsEp, dt1_XgsEu #)
      }
      }

-- RHS size: {terms: 13, types: 15, coercions: 0, joins: 0/0}
mkPolar [InlPrag=NOUSERINLINE[0]]
  :: forall a. Floating a => a -> a -> Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(LLC(C(S))LLLL)LLL)LLLLLLLLLLLLLLLLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),A,A,A),A,A,A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxwP)
                 (w_sgxwQ [Occ=Once] :: Floating a_sgxwP)
                 (w1_sgxwR [Occ=Once] :: a_sgxwP)
                 (w2_sgxwS [Occ=Once] :: a_sgxwP) ->
                 case Data.Complex.$wmkPolar @ a_sgxwP w_sgxwQ w1_sgxwR w2_sgxwS of
                 { (# ww1_sgxQn [Occ=Once], ww2_sgxQo [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxwP ww1_sgxQn ww2_sgxQo
                 }}]
mkPolar
  = \ (@ a_sgxwP)
      (w_sgxwQ :: Floating a_sgxwP)
      (w1_sgxwR :: a_sgxwP)
      (w2_sgxwS :: a_sgxwP) ->
      case Data.Complex.$wmkPolar @ a_sgxwP w_sgxwQ w1_sgxwR w2_sgxwS of
      { (# ww1_sgxQn, ww2_sgxQo #) ->
      Data.Complex.:+ @ a_sgxwP ww1_sgxQn ww2_sgxQo
      }

-- RHS size: {terms: 23, types: 4, coercions: 0, joins: 0/0}
Data.Complex.$w$sphase [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> GHC.Prim.Double#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 122 0}]
Data.Complex.$w$sphase
  = \ (ww_sgxx3 :: GHC.Prim.Double#)
      (ww1_sgxx8 :: GHC.Prim.Double#) ->
      case GHC.Prim.==## ww_sgxx3 0.0## of {
        __DEFAULT -> GHC.Float.$w$catan2 (GHC.Types.D# ww1_sgxx8) ww_sgxx3;
        1# ->
          case GHC.Prim.==## ww1_sgxx8 0.0## of {
            __DEFAULT -> GHC.Float.$w$catan2 (GHC.Types.D# ww1_sgxx8) ww_sgxx3;
            1# -> 0.0##
          }
      }

-- RHS size: {terms: 17, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$sphase [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxwX [Occ=Once!] :: Complex Double) ->
                 case w_sgxwX of { :+ ww1_sgxx0 [Occ=Once!] ww2_sgxx5 [Occ=Once!] ->
                 case ww1_sgxx0 of { GHC.Types.D# ww4_sgxx3 [Occ=Once] ->
                 case ww2_sgxx5 of { GHC.Types.D# ww6_sgxx8 [Occ=Once] ->
                 case Data.Complex.$w$sphase ww4_sgxx3 ww6_sgxx8 of ww7_sgxxd
                 { __DEFAULT ->
                 GHC.Types.D# ww7_sgxxd
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$sphase
  = \ (w_sgxwX :: Complex Double) ->
      case w_sgxwX of { :+ ww1_sgxx0 ww2_sgxx5 ->
      case ww1_sgxx0 of { GHC.Types.D# ww4_sgzfR ->
      case ww2_sgxx5 of { GHC.Types.D# ww6_sgzfU ->
      case Data.Complex.$w$sphase ww4_sgzfR ww6_sgzfU of ww7_sgxxd
      { __DEFAULT ->
      GHC.Types.D# ww7_sgxxd
      }
      }
      }
      }

-- RHS size: {terms: 23, types: 4, coercions: 0, joins: 0/0}
Data.Complex.$w$sphase1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 122 0}]
Data.Complex.$w$sphase1
  = \ (ww_sgxxl :: GHC.Prim.Float#) (ww1_sgxxq :: GHC.Prim.Float#) ->
      case GHC.Prim.eqFloat# ww_sgxxl 0.0# of {
        __DEFAULT -> GHC.Float.$w$catan1 (GHC.Types.F# ww1_sgxxq) ww_sgxxl;
        1# ->
          case GHC.Prim.eqFloat# ww1_sgxxq 0.0# of {
            __DEFAULT -> GHC.Float.$w$catan1 (GHC.Types.F# ww1_sgxxq) ww_sgxxl;
            1# -> 0.0#
          }
      }

-- RHS size: {terms: 17, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$sphase1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxxf [Occ=Once!] :: Complex Float) ->
                 case w_sgxxf of { :+ ww1_sgxxi [Occ=Once!] ww2_sgxxn [Occ=Once!] ->
                 case ww1_sgxxi of { GHC.Types.F# ww4_sgxxl [Occ=Once] ->
                 case ww2_sgxxn of { GHC.Types.F# ww6_sgxxq [Occ=Once] ->
                 case Data.Complex.$w$sphase1 ww4_sgxxl ww6_sgxxq of ww7_sgxxv
                 { __DEFAULT ->
                 GHC.Types.F# ww7_sgxxv
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$sphase1
  = \ (w_sgxxf :: Complex Float) ->
      case w_sgxxf of { :+ ww1_sgxxi ww2_sgxxn ->
      case ww1_sgxxi of { GHC.Types.F# ww4_sgzfX ->
      case ww2_sgxxn of { GHC.Types.F# ww6_sgzg0 ->
      case Data.Complex.$w$sphase1 ww4_sgzfX ww6_sgzg0 of ww7_sgxxv
      { __DEFAULT ->
      GHC.Types.F# ww7_sgxxv
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex17 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Complex.$fFloatingComplex17 = 0

-- RHS size: {terms: 48, types: 30, coercions: 0, joins: 0/5}
Data.Complex.$wphase [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 0 0] 440 0}]
Data.Complex.$wphase
  = \ (@ a_sgxxx)
      (w_sgxxy :: RealFloat a_sgxxx)
      (ww_sgxxC
         :: a_sgxxx
         Unf=OtherCon [])
      (ww1_sgxxD
         :: a_sgxxx
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sgun0 [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxxx
        [LclId]
        $dRealFrac_sgun0 = GHC.Float.$p1RealFloat @ a_sgxxx w_sgxxy } in
      let {
        $dReal_sgumZ [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
          :: Real a_sgxxx
        [LclId]
        $dReal_sgumZ = GHC.Real.$p1RealFrac @ a_sgxxx $dRealFrac_sgun0 } in
      let {
        $dNum_sgumY [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: Num a_sgxxx
        [LclId]
        $dNum_sgumY = GHC.Real.$p1Real @ a_sgxxx $dReal_sgumZ } in
      let {
        $dOrd_sgumX [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
          :: Ord a_sgxxx
        [LclId]
        $dOrd_sgumX = GHC.Real.$p2Real @ a_sgxxx $dReal_sgumZ } in
      let {
        $dEq_sgumW [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq a_sgxxx
        [LclId]
        $dEq_sgumW = GHC.Classes.$p1Ord @ a_sgxxx $dOrd_sgumX } in
      case ==
             @ a_sgxxx
             $dEq_sgumW
             ww_sgxxC
             (fromInteger
                @ a_sgxxx $dNum_sgumY Data.Complex.$fFloatingComplex17)
      of {
        False -> atan2 @ a_sgxxx w_sgxxy ww1_sgxxD ww_sgxxC;
        True ->
          case ==
                 @ a_sgxxx
                 $dEq_sgumW
                 ww1_sgxxD
                 (fromInteger
                    @ a_sgxxx $dNum_sgumY Data.Complex.$fFloatingComplex17)
          of {
            False -> atan2 @ a_sgxxx w_sgxxy ww1_sgxxD ww_sgxxC;
            True ->
              fromInteger @ a_sgxxx $dNum_sgumY Data.Complex.$fFloatingComplex17
          }
      }

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
phase [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxxx)
                 (w_sgxxy [Occ=Once] :: RealFloat a_sgxxx)
                 (w1_sgxxz [Occ=Once!] :: Complex a_sgxxx) ->
                 case w1_sgxxz of { :+ ww1_sgxxC [Occ=Once] ww2_sgxxD [Occ=Once] ->
                 Data.Complex.$wphase @ a_sgxxx w_sgxxy ww1_sgxxC ww2_sgxxD
                 }}]
phase
  = \ (@ a_sgxxx)
      (w_sgxxy :: RealFloat a_sgxxx)
      (w1_sgxxz :: Complex a_sgxxx) ->
      case w1_sgxxz of { :+ ww1_sgxxC ww2_sgxxD ->
      Data.Complex.$wphase @ a_sgxxx w_sgxxy ww1_sgxxC ww2_sgxxD
      }

-- RHS size: {terms: 45, types: 11, coercions: 0, joins: 1/2}
Data.Complex.$w$smagnitude [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> GHC.Prim.Double#
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 207 0}]
Data.Complex.$w$smagnitude
  = \ (ww_sgxxN :: GHC.Prim.Double#)
      (ww1_sgxxS :: GHC.Prim.Double#) ->
      case GHC.Float.$w$cexponent ww_sgxxN of ww2_igtyh { __DEFAULT ->
      case GHC.Float.$w$cexponent ww1_sgxxS of ww3_XgtHp { __DEFAULT ->
      join {
        $j_sgwJL [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> GHC.Prim.Double#
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_sgwJL (x_i9wPy [OS=OneShot] :: GHC.Prim.Int#)
          = let {
              ww4_igtyq [Dmd=<S,U>] :: GHC.Prim.Int#
              [LclId]
              ww4_igtyq = GHC.Prim.negateInt# x_i9wPy } in
            case GHC.Float.$w$cscaleFloat ww4_igtyq ww_sgxxN of ww5_igtyx
            { __DEFAULT ->
            case GHC.Float.$w$cscaleFloat ww4_igtyq ww1_sgxxS of ww6_XgtHM
            { __DEFAULT ->
            GHC.Float.$w$cscaleFloat
              x_i9wPy
              (GHC.Prim.sqrtDouble#
                 (GHC.Prim.+##
                    (GHC.Prim.*## ww5_igtyx ww5_igtyx)
                    (GHC.Prim.*## ww6_XgtHM ww6_XgtHM)))
            }
            } } in
      case GHC.Prim.<=# ww2_igtyh ww3_XgtHp of {
        __DEFAULT -> jump $j_sgwJL ww2_igtyh;
        1# -> jump $j_sgwJL ww3_XgtHp
      }
      }
      }

-- RHS size: {terms: 17, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$smagnitude [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxxH [Occ=Once!] :: Complex Double) ->
                 case w_sgxxH of { :+ ww1_sgxxK [Occ=Once!] ww2_sgxxP [Occ=Once!] ->
                 case ww1_sgxxK of { GHC.Types.D# ww4_sgxxN [Occ=Once] ->
                 case ww2_sgxxP of { GHC.Types.D# ww6_sgxxS [Occ=Once] ->
                 case Data.Complex.$w$smagnitude ww4_sgxxN ww6_sgxxS of ww7_sgxxX
                 { __DEFAULT ->
                 GHC.Types.D# ww7_sgxxX
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$smagnitude
  = \ (w_sgxxH :: Complex Double) ->
      case w_sgxxH of { :+ ww1_sgxxK ww2_sgxxP ->
      case ww1_sgxxK of { GHC.Types.D# ww4_sgzg3 ->
      case ww2_sgxxP of { GHC.Types.D# ww6_sgzg6 ->
      case Data.Complex.$w$smagnitude ww4_sgzg3 ww6_sgzg6 of ww7_sgxxX
      { __DEFAULT ->
      GHC.Types.D# ww7_sgxxX
      }
      }
      }
      }

-- RHS size: {terms: 45, types: 11, coercions: 0, joins: 1/2}
Data.Complex.$w$smagnitude1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> GHC.Prim.Float#
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 207 0}]
Data.Complex.$w$smagnitude1
  = \ (ww_sgxy6 :: GHC.Prim.Float#) (ww1_sgxyb :: GHC.Prim.Float#) ->
      case GHC.Float.$w$cexponent1 ww_sgxy6 of ww2_igtvO { __DEFAULT ->
      case GHC.Float.$w$cexponent1 ww1_sgxyb of ww3_XgtEX { __DEFAULT ->
      join {
        $j_sgwJV [Dmd=<C(S),1*C1(U)>] :: GHC.Prim.Int# -> GHC.Prim.Float#
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_sgwJV (x_i9wPy [OS=OneShot] :: GHC.Prim.Int#)
          = let {
              ww4_igtvX [Dmd=<S,U>] :: GHC.Prim.Int#
              [LclId]
              ww4_igtvX = GHC.Prim.negateInt# x_i9wPy } in
            case GHC.Float.$w$cscaleFloat1 ww4_igtvX ww_sgxy6 of ww5_igtw4
            { __DEFAULT ->
            case GHC.Float.$w$cscaleFloat1 ww4_igtvX ww1_sgxyb of ww6_XgtFk
            { __DEFAULT ->
            GHC.Float.$w$cscaleFloat1
              x_i9wPy
              (GHC.Prim.sqrtFloat#
                 (GHC.Prim.plusFloat#
                    (GHC.Prim.timesFloat# ww5_igtw4 ww5_igtw4)
                    (GHC.Prim.timesFloat# ww6_XgtFk ww6_XgtFk)))
            }
            } } in
      case GHC.Prim.<=# ww2_igtvO ww3_XgtEX of {
        __DEFAULT -> jump $j_sgwJV ww2_igtvO;
        1# -> jump $j_sgwJV ww3_XgtEX
      }
      }
      }

-- RHS size: {terms: 17, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$smagnitude1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxy0 [Occ=Once!] :: Complex Float) ->
                 case w_sgxy0 of { :+ ww1_sgxy3 [Occ=Once!] ww2_sgxy8 [Occ=Once!] ->
                 case ww1_sgxy3 of { GHC.Types.F# ww4_sgxy6 [Occ=Once] ->
                 case ww2_sgxy8 of { GHC.Types.F# ww6_sgxyb [Occ=Once] ->
                 case Data.Complex.$w$smagnitude1 ww4_sgxy6 ww6_sgxyb of ww7_sgxyg
                 { __DEFAULT ->
                 GHC.Types.F# ww7_sgxyg
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$smagnitude1
  = \ (w_sgxy0 :: Complex Float) ->
      case w_sgxy0 of { :+ ww1_sgxy3 ww2_sgxy8 ->
      case ww1_sgxy3 of { GHC.Types.F# ww4_sgzg9 ->
      case ww2_sgxy8 of { GHC.Types.F# ww6_sgzgc ->
      case Data.Complex.$w$smagnitude1 ww4_sgzg9 ww6_sgzgc of ww7_sgxyg
      { __DEFAULT ->
      GHC.Types.F# ww7_sgxyg
      }
      }
      }
      }

-- RHS size: {terms: 65, types: 36, coercions: 0, joins: 0/7}
Data.Complex.$wmagnitude [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(C(S))LLLLLL),U(1*U(1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [210 0 0] 542 0}]
Data.Complex.$wmagnitude
  = \ (@ a_sgxyi)
      (w_sgxyj :: RealFloat a_sgxyi)
      (ww_sgxyn
         :: a_sgxyi
         Unf=OtherCon [])
      (ww1_sgxyo
         :: a_sgxyi
         Unf=OtherCon []) ->
      let {
        k_sgumm [Dmd=<L,U(U)>] :: Int
        [LclId]
        k_sgumm
          = case exponent @ a_sgxyi w_sgxyj ww_sgxyn of wild_at54
            { GHC.Types.I# x1_at56 ->
            case exponent @ a_sgxyi w_sgxyj ww1_sgxyo of wild1_at58
            { GHC.Types.I# y1_at5a ->
            case GHC.Prim.<=# x1_at56 y1_at5a of {
              __DEFAULT -> wild_at54;
              1# -> wild1_at58
            }
            }
            } } in
      scaleFloat
        @ a_sgxyi
        w_sgxyj
        k_sgumm
        (sqrt
           @ a_sgxyi
           (GHC.Float.$p2RealFloat @ a_sgxyi w_sgxyj)
           (let {
              $dRealFrac_sgump [Dmd=<S(S(S(C(C(S))LLLLLL)LL)LLLLLL),1*U(1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
                :: RealFrac a_sgxyi
              [LclId]
              $dRealFrac_sgump = GHC.Float.$p1RealFloat @ a_sgxyi w_sgxyj } in
            let {
              $dReal_sgumo [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A)>]
                :: Real a_sgxyi
              [LclId]
              $dReal_sgumo = GHC.Real.$p1RealFrac @ a_sgxyi $dRealFrac_sgump } in
            let {
              $dNum_sgumn [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A)>]
                :: Num a_sgxyi
              [LclId]
              $dNum_sgumn = GHC.Real.$p1Real @ a_sgxyi $dReal_sgumo } in
            let {
              mk_sguml :: Int
              [LclId]
              mk_sguml
                = case k_sgumm of { GHC.Types.I# x_i9wPy ->
                  GHC.Types.I# (GHC.Prim.negateInt# x_i9wPy)
                  } } in
            + @ a_sgxyi
              $dNum_sgumn
              (let {
                 z_sgumk :: a_sgxyi
                 [LclId]
                 z_sgumk = scaleFloat @ a_sgxyi w_sgxyj mk_sguml ww_sgxyn } in
               * @ a_sgxyi $dNum_sgumn z_sgumk z_sgumk)
              (let {
                 z_sgumi :: a_sgxyi
                 [LclId]
                 z_sgumi = scaleFloat @ a_sgxyi w_sgxyj mk_sguml ww1_sgxyo } in
               * @ a_sgxyi $dNum_sgumn z_sgumi z_sgumi)))

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
magnitude [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxyi)
                 (w_sgxyj [Occ=Once] :: RealFloat a_sgxyi)
                 (w1_sgxyk [Occ=Once!] :: Complex a_sgxyi) ->
                 case w1_sgxyk of { :+ ww1_sgxyn [Occ=Once] ww2_sgxyo [Occ=Once] ->
                 Data.Complex.$wmagnitude @ a_sgxyi w_sgxyj ww1_sgxyn ww2_sgxyo
                 }}]
magnitude
  = \ (@ a_sgxyi)
      (w_sgxyj :: RealFloat a_sgxyi)
      (w1_sgxyk :: Complex a_sgxyi) ->
      case w1_sgxyk of { :+ ww1_sgxyn ww2_sgxyo ->
      Data.Complex.$wmagnitude @ a_sgxyi w_sgxyj ww1_sgxyn ww2_sgxyo
      }

-- RHS size: {terms: 29, types: 14, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$clog1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxyr [Occ=Once!] :: Complex Float) ->
                 case w_sgxyr of { :+ ww1_sgxyu [Occ=Once!] ww2_sgxyz [Occ=Once!] ->
                 case ww1_sgxyu of { GHC.Types.F# ww4_sgxyx ->
                 case ww2_sgxyz of { GHC.Types.F# ww6_sgxyC ->
                 case Data.Complex.$w$smagnitude1 ww4_sgxyx ww6_sgxyC of ww7_sgxyg
                 { __DEFAULT ->
                 case GHC.Prim.logFloat# ww7_sgxyg of wild1_igtz0 { __DEFAULT ->
                 case Data.Complex.$w$sphase1 ww4_sgxyx ww6_sgxyC of ww8_sgxxv
                 { __DEFAULT ->
                 Data.Complex.:+
                   @ Float (GHC.Types.F# wild1_igtz0) (GHC.Types.F# ww8_sgxxv)
                 }
                 }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$clog1
  = \ (w_sgxyr :: Complex Float) ->
      case w_sgxyr of { :+ ww1_sgxyu ww2_sgxyz ->
      case ww1_sgxyu of { GHC.Types.F# ww4_sgzgf ->
      case ww2_sgxyz of { GHC.Types.F# ww6_sgzgi ->
      case Data.Complex.$w$smagnitude1 ww4_sgzgf ww6_sgzgi of ww7_sgxyg
      { __DEFAULT ->
      case GHC.Prim.logFloat# ww7_sgxyg of wild1_igtz0 { __DEFAULT ->
      case Data.Complex.$w$sphase1 ww4_sgzgf ww6_sgzgi of ww8_sgxxv
      { __DEFAULT ->
      Data.Complex.:+
        @ Float (GHC.Types.F# wild1_igtz0) (GHC.Types.F# ww8_sgxxv)
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 19, types: 12, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cabs1
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (z_agspm [Occ=Once] :: Complex Float) ->
                 case Data.Complex.$fFloatingComplex_$smagnitude1 z_agspm
                 of dt_XgsEL
                 { GHC.Types.F# _ [Occ=Dead] ->
                 Data.Complex.:+ @ Float dt_XgsEL Data.Complex.$fFloatingComplex9
                 }}]
Data.Complex.$fFloatingComplex_$s$cabs1
  = \ (z_agspm :: Complex Float) ->
      case z_agspm of { :+ ww1_sgxy3 ww2_sgxy8 ->
      case ww1_sgxy3 of { GHC.Types.F# ww4_sgzgl ->
      case ww2_sgxy8 of { GHC.Types.F# ww6_sgzgo ->
      case Data.Complex.$w$smagnitude1 ww4_sgzgl ww6_sgzgo of ww7_sgxyg
      { __DEFAULT ->
      Data.Complex.:+
        @ Float (GHC.Types.F# ww7_sgxyg) Data.Complex.$fFloatingComplex9
      }
      }
      }
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
Data.Complex.polar_$spolar :: Complex Double -> (Double, Double)
[GblId,
 Arity=1,
 Str=<L,U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (z_agspH :: Complex Double) ->
                 (Data.Complex.$fFloatingComplex_$smagnitude z_agspH,
                  Data.Complex.$fFloatingComplex_$sphase z_agspH)}]
Data.Complex.polar_$spolar
  = \ (z_agspH :: Complex Double) ->
      (Data.Complex.$fFloatingComplex_$smagnitude z_agspH,
       Data.Complex.$fFloatingComplex_$sphase z_agspH)

-- RHS size: {terms: 10, types: 10, coercions: 0, joins: 0/0}
polar :: forall a. RealFloat a => Complex a -> (a, a)
[GblId,
 Arity=2,
 Str=<L,U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_agsyd)
                 ($dRealFloat_agsyf :: RealFloat a_agsyd)
                 (z_agspH :: Complex a_agsyd) ->
                 (magnitude @ a_agsyd $dRealFloat_agsyf z_agspH,
                  phase @ a_agsyd $dRealFloat_agsyf z_agspH)}]
polar
  = \ (@ a_agsyd)
      ($dRealFloat_agsyf :: RealFloat a_agsyd)
      (z_agspH :: Complex a_agsyd) ->
      (magnitude @ a_agsyd $dRealFloat_agsyf z_agspH,
       phase @ a_agsyd $dRealFloat_agsyf z_agspH)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex1 :: Double
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Complex.$fFloatingComplex1 = GHC.Types.D# 0.0##

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cpi :: Complex Double
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fFloatingComplex_$s$cpi
  = Data.Complex.:+
      @ Double
      GHC.Float.$fFloatingDouble_$cpi
      Data.Complex.$fFloatingComplex1

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/0}
Data.Complex.$w$cpi [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => (# a, a #)
[GblId,
 Arity=1,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)S(LSLLLLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A),1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60] 150 30}]
Data.Complex.$w$cpi
  = \ (@ a_sgxyJ) (w_sgxyK :: RealFloat a_sgxyJ) ->
      case pi @ a_sgxyJ (GHC.Float.$p2RealFloat @ a_sgxyJ w_sgxyK)
      of dt_XgsEW
      { __DEFAULT ->
      case fromInteger
             @ a_sgxyJ
             (GHC.Real.$p1Real
                @ a_sgxyJ
                (GHC.Real.$p1RealFrac
                   @ a_sgxyJ (GHC.Float.$p1RealFloat @ a_sgxyJ w_sgxyK)))
             Data.Complex.$fFloatingComplex17
      of dt1_XgsF1
      { __DEFAULT ->
      (# dt_XgsEW, dt1_XgsF1 #)
      }
      }

-- RHS size: {terms: 9, types: 13, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$cpi [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a
[GblId,
 Arity=1,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)S(LSLLLLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxyJ) (w_sgxyK [Occ=Once] :: RealFloat a_sgxyJ) ->
                 case Data.Complex.$w$cpi @ a_sgxyJ w_sgxyK of
                 { (# ww1_sgxQt [Occ=Once], ww2_sgxQu [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxyJ ww1_sgxQt ww2_sgxQu
                 }}]
Data.Complex.$fFloatingComplex_$cpi
  = \ (@ a_sgxyJ) (w_sgxyK :: RealFloat a_sgxyJ) ->
      case Data.Complex.$w$cpi @ a_sgxyJ w_sgxyK of
      { (# ww1_sgxQt, ww2_sgxQu #) ->
      Data.Complex.:+ @ a_sgxyJ ww1_sgxQt ww2_sgxQu
      }

-- RHS size: {terms: 24, types: 12, coercions: 0, joins: 0/1}
Data.Complex.$fFloatingComplex_$s$cexp
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dgtaQ [Occ=Once!] :: Complex Double) ->
                 case ds_dgtaQ of { :+ x_agsnS [Occ=Once!] y_agsnT [Occ=Once!] ->
                 case x_agsnS of { GHC.Types.D# x1_sgurX [Occ=Once] ->
                 case y_agsnT of { GHC.Types.D# x2_sgus0 ->
                 let {
                   expx_sguIB :: GHC.Prim.Double#
                   [LclId]
                   expx_sguIB = GHC.Prim.expDouble# x1_sgurX } in
                 Data.Complex.:+
                   @ Double
                   (GHC.Types.D#
                      (GHC.Prim.*## expx_sguIB (GHC.Prim.cosDouble# x2_sgus0)))
                   (GHC.Types.D#
                      (GHC.Prim.*## expx_sguIB (GHC.Prim.sinDouble# x2_sgus0)))
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$cexp
  = \ (ds_dgtaQ :: Complex Double) ->
      case ds_dgtaQ of { :+ x_agsnS y_agsnT ->
      case x_agsnS of { GHC.Types.D# x1_sgzgr ->
      case y_agsnT of { GHC.Types.D# x2_sgzgu ->
      let {
        expx_sguIB :: GHC.Prim.Double#
        [LclId]
        expx_sguIB = GHC.Prim.expDouble# x1_sgzgr } in
      Data.Complex.:+
        @ Double
        (GHC.Types.D#
           (GHC.Prim.*## expx_sguIB (GHC.Prim.cosDouble# x2_sgzgu)))
        (GHC.Types.D#
           (GHC.Prim.*## expx_sguIB (GHC.Prim.sinDouble# x2_sgzgu)))
      }
      }
      }

-- RHS size: {terms: 39, types: 30, coercions: 0, joins: 0/5}
Data.Complex.$w$cexp [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 320 30}]
Data.Complex.$w$cexp
  = \ (@ a_sgxyP)
      (w_sgxyQ :: RealFloat a_sgxyP)
      (ww_sgxyU
         :: a_sgxyP
         Unf=OtherCon [])
      (ww1_sgxyV
         :: a_sgxyP
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sgum2 [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxyP
        [LclId]
        $dRealFrac_sgum2 = GHC.Float.$p1RealFloat @ a_sgxyP w_sgxyQ } in
      let {
        $dReal_sgum1 [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
          :: Real a_sgxyP
        [LclId]
        $dReal_sgum1 = GHC.Real.$p1RealFrac @ a_sgxyP $dRealFrac_sgum2 } in
      let {
        $dNum_sgum0 [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
          :: Num a_sgxyP
        [LclId]
        $dNum_sgum0 = GHC.Real.$p1Real @ a_sgxyP $dReal_sgum1 } in
      let {
        $dFloating_sgum3 [Dmd=<L,U(A,A,1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>]
          :: Floating a_sgxyP
        [LclId]
        $dFloating_sgum3 = GHC.Float.$p2RealFloat @ a_sgxyP w_sgxyQ } in
      let {
        expx_sgulZ :: a_sgxyP
        [LclId]
        expx_sgulZ = exp @ a_sgxyP $dFloating_sgum3 ww_sgxyU } in
      case * @ a_sgxyP
             $dNum_sgum0
             expx_sgulZ
             (cos @ a_sgxyP $dFloating_sgum3 ww1_sgxyV)
      of dt_XgsFg
      { __DEFAULT ->
      case * @ a_sgxyP
             $dNum_sgum0
             expx_sgulZ
             (sin @ a_sgxyP $dFloating_sgum3 ww1_sgxyV)
      of dt1_XgsFl
      { __DEFAULT ->
      (# dt_XgsFg, dt1_XgsFl #)
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$cexp [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxyP)
                 (w_sgxyQ [Occ=Once] :: RealFloat a_sgxyP)
                 (w1_sgxyR [Occ=Once!] :: Complex a_sgxyP) ->
                 case w1_sgxyR of { :+ ww1_sgxyU [Occ=Once] ww2_sgxyV [Occ=Once] ->
                 case Data.Complex.$w$cexp @ a_sgxyP w_sgxyQ ww1_sgxyU ww2_sgxyV of
                 { (# ww4_sgxQw [Occ=Once], ww5_sgxQx [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxyP ww4_sgxQw ww5_sgxQx
                 }
                 }}]
Data.Complex.$fFloatingComplex_$cexp
  = \ (@ a_sgxyP)
      (w_sgxyQ :: RealFloat a_sgxyP)
      (w1_sgxyR :: Complex a_sgxyP) ->
      case w1_sgxyR of { :+ ww1_sgxyU ww2_sgxyV ->
      case Data.Complex.$w$cexp @ a_sgxyP w_sgxyQ ww1_sgxyU ww2_sgxyV of
      { (# ww4_sgxQw, ww5_sgxQx #) ->
      Data.Complex.:+ @ a_sgxyP ww4_sgxQw ww5_sgxQx
      }
      }

-- RHS size: {terms: 29, types: 14, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$clog [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxz1 [Occ=Once!] :: Complex Double) ->
                 case w_sgxz1 of { :+ ww1_sgxz4 [Occ=Once!] ww2_sgxz9 [Occ=Once!] ->
                 case ww1_sgxz4 of { GHC.Types.D# ww4_sgxz7 ->
                 case ww2_sgxz9 of { GHC.Types.D# ww6_sgxzc ->
                 case Data.Complex.$w$smagnitude ww4_sgxz7 ww6_sgxzc of ww7_sgxxX
                 { __DEFAULT ->
                 case GHC.Prim.logDouble# ww7_sgxxX of wild1_igtzm { __DEFAULT ->
                 case Data.Complex.$w$sphase ww4_sgxz7 ww6_sgxzc of ww8_sgxxd
                 { __DEFAULT ->
                 Data.Complex.:+
                   @ Double (GHC.Types.D# wild1_igtzm) (GHC.Types.D# ww8_sgxxd)
                 }
                 }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$clog
  = \ (w_sgxz1 :: Complex Double) ->
      case w_sgxz1 of { :+ ww1_sgxz4 ww2_sgxz9 ->
      case ww1_sgxz4 of { GHC.Types.D# ww4_sgzgx ->
      case ww2_sgxz9 of { GHC.Types.D# ww6_sgzgA ->
      case Data.Complex.$w$smagnitude ww4_sgzgx ww6_sgzgA of ww7_sgxxX
      { __DEFAULT ->
      case GHC.Prim.logDouble# ww7_sgxxX of wild1_igtzm { __DEFAULT ->
      case Data.Complex.$w$sphase ww4_sgzgx ww6_sgzgA of ww8_sgxxd
      { __DEFAULT ->
      Data.Complex.:+
        @ Double (GHC.Types.D# wild1_igtzm) (GHC.Types.D# ww8_sgxxd)
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 22, types: 16, coercions: 0, joins: 0/0}
Data.Complex.$w$clog [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 150 30}]
Data.Complex.$w$clog
  = \ (@ a_sgxzj)
      (w_sgxzk :: RealFloat a_sgxzj)
      (ww_sgxzo
         :: a_sgxzj
         Unf=OtherCon [])
      (ww1_sgxzp
         :: a_sgxzj
         Unf=OtherCon []) ->
      case log
             @ a_sgxzj
             (GHC.Float.$p2RealFloat @ a_sgxzj w_sgxzk)
             (Data.Complex.$wmagnitude @ a_sgxzj w_sgxzk ww_sgxzo ww1_sgxzp)
      of dt_XgsF3
      { __DEFAULT ->
      case Data.Complex.$wphase @ a_sgxzj w_sgxzk ww_sgxzo ww1_sgxzp
      of dt1_XgsF8
      { __DEFAULT ->
      (# dt_XgsF3, dt1_XgsF8 #)
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$clog [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxzj)
                 (w_sgxzk [Occ=Once] :: RealFloat a_sgxzj)
                 (w1_sgxzl [Occ=Once!] :: Complex a_sgxzj) ->
                 case w1_sgxzl of { :+ ww1_sgxzo [Occ=Once] ww2_sgxzp [Occ=Once] ->
                 case Data.Complex.$w$clog @ a_sgxzj w_sgxzk ww1_sgxzo ww2_sgxzp of
                 { (# ww4_sgxQC [Occ=Once], ww5_sgxQD [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxzj ww4_sgxQC ww5_sgxQD
                 }
                 }}]
Data.Complex.$fFloatingComplex_$clog
  = \ (@ a_sgxzj)
      (w_sgxzk :: RealFloat a_sgxzj)
      (w1_sgxzl :: Complex a_sgxzj) ->
      case w1_sgxzl of { :+ ww1_sgxzo ww2_sgxzp ->
      case Data.Complex.$w$clog @ a_sgxzj w_sgxzk ww1_sgxzo ww2_sgxzp of
      { (# ww4_sgxQC, ww5_sgxQD #) ->
      Data.Complex.:+ @ a_sgxzj ww4_sgxQC ww5_sgxQD
      }
      }

-- RHS size: {terms: 23, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$csin
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dgteO [Occ=Once!] :: Complex Double) ->
                 case ds_dgteO of { :+ x_agsob [Occ=Once!] y_agsoc [Occ=Once!] ->
                 case y_agsoc of { GHC.Types.D# x1_sgus9 ->
                 case x_agsob of { GHC.Types.D# x2_sgus6 ->
                 Data.Complex.:+
                   @ Double
                   (GHC.Types.D#
                      (GHC.Prim.*##
                         (GHC.Prim.sinDouble# x2_sgus6) (GHC.Prim.coshDouble# x1_sgus9)))
                   (GHC.Types.D#
                      (GHC.Prim.*##
                         (GHC.Prim.cosDouble# x2_sgus6) (GHC.Prim.sinhDouble# x1_sgus9)))
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$csin
  = \ (ds_dgteO :: Complex Double) ->
      case ds_dgteO of { :+ x_agsob y_agsoc ->
      case y_agsoc of { GHC.Types.D# x1_sgzgD ->
      case x_agsob of { GHC.Types.D# x2_sgzgG ->
      Data.Complex.:+
        @ Double
        (GHC.Types.D#
           (GHC.Prim.*##
              (GHC.Prim.sinDouble# x2_sgzgG) (GHC.Prim.coshDouble# x1_sgzgD)))
        (GHC.Types.D#
           (GHC.Prim.*##
              (GHC.Prim.cosDouble# x2_sgzgG) (GHC.Prim.sinhDouble# x1_sgzgD)))
      }
      }
      }

-- RHS size: {terms: 39, types: 30, coercions: 0, joins: 0/4}
Data.Complex.$w$csin [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 340 30}]
Data.Complex.$w$csin
  = \ (@ a_sgxzv)
      (w_sgxzw :: RealFloat a_sgxzv)
      (ww_sgxzA
         :: a_sgxzv
         Unf=OtherCon [])
      (ww1_sgxzB
         :: a_sgxzv
         Unf=OtherCon []) ->
      let {
        $dFloating_sgulJ [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
          :: Floating a_sgxzv
        [LclId]
        $dFloating_sgulJ = GHC.Float.$p2RealFloat @ a_sgxzv w_sgxzw } in
      let {
        $dRealFrac_sgulI [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxzv
        [LclId]
        $dRealFrac_sgulI = GHC.Float.$p1RealFloat @ a_sgxzv w_sgxzw } in
      let {
        $dReal_sgulH [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
          :: Real a_sgxzv
        [LclId]
        $dReal_sgulH = GHC.Real.$p1RealFrac @ a_sgxzv $dRealFrac_sgulI } in
      let {
        $dNum_sgulG [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
          :: Num a_sgxzv
        [LclId]
        $dNum_sgulG = GHC.Real.$p1Real @ a_sgxzv $dReal_sgulH } in
      case * @ a_sgxzv
             $dNum_sgulG
             (sin @ a_sgxzv $dFloating_sgulJ ww_sgxzA)
             (cosh @ a_sgxzv $dFloating_sgulJ ww1_sgxzB)
      of dt_XgsFk
      { __DEFAULT ->
      case * @ a_sgxzv
             $dNum_sgulG
             (cos @ a_sgxzv $dFloating_sgulJ ww_sgxzA)
             (sinh @ a_sgxzv $dFloating_sgulJ ww1_sgxzB)
      of dt1_XgsFp
      { __DEFAULT ->
      (# dt_XgsFk, dt1_XgsFp #)
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$csin [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxzv)
                 (w_sgxzw [Occ=Once] :: RealFloat a_sgxzv)
                 (w1_sgxzx [Occ=Once!] :: Complex a_sgxzv) ->
                 case w1_sgxzx of { :+ ww1_sgxzA [Occ=Once] ww2_sgxzB [Occ=Once] ->
                 case Data.Complex.$w$csin @ a_sgxzv w_sgxzw ww1_sgxzA ww2_sgxzB of
                 { (# ww4_sgxQF [Occ=Once], ww5_sgxQG [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxzv ww4_sgxQF ww5_sgxQG
                 }
                 }}]
Data.Complex.$fFloatingComplex_$csin
  = \ (@ a_sgxzv)
      (w_sgxzw :: RealFloat a_sgxzv)
      (w1_sgxzx :: Complex a_sgxzv) ->
      case w1_sgxzx of { :+ ww1_sgxzA ww2_sgxzB ->
      case Data.Complex.$w$csin @ a_sgxzv w_sgxzw ww1_sgxzA ww2_sgxzB of
      { (# ww4_sgxQF, ww5_sgxQG #) ->
      Data.Complex.:+ @ a_sgxzv ww4_sgxQF ww5_sgxQG
      }
      }

-- RHS size: {terms: 24, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$ccos
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dgtf6 [Occ=Once!] :: Complex Double) ->
                 case ds_dgtf6 of { :+ x_agsod [Occ=Once!] y_agsoe [Occ=Once!] ->
                 case y_agsoe of { GHC.Types.D# x1_sgusl ->
                 case x_agsod of { GHC.Types.D# x2_sgusi ->
                 Data.Complex.:+
                   @ Double
                   (GHC.Types.D#
                      (GHC.Prim.*##
                         (GHC.Prim.cosDouble# x2_sgusi) (GHC.Prim.coshDouble# x1_sgusl)))
                   (GHC.Types.D#
                      (GHC.Prim.negateDouble#
                         (GHC.Prim.*##
                            (GHC.Prim.sinDouble# x2_sgusi) (GHC.Prim.sinhDouble# x1_sgusl))))
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$ccos
  = \ (ds_dgtf6 :: Complex Double) ->
      case ds_dgtf6 of { :+ x_agsod y_agsoe ->
      case y_agsoe of { GHC.Types.D# x1_sgzgJ ->
      case x_agsod of { GHC.Types.D# x2_sgzgM ->
      Data.Complex.:+
        @ Double
        (GHC.Types.D#
           (GHC.Prim.*##
              (GHC.Prim.cosDouble# x2_sgzgM) (GHC.Prim.coshDouble# x1_sgzgJ)))
        (GHC.Types.D#
           (GHC.Prim.negateDouble#
              (GHC.Prim.*##
                 (GHC.Prim.sinDouble# x2_sgzgM) (GHC.Prim.sinhDouble# x1_sgzgJ))))
      }
      }
      }

-- RHS size: {terms: 41, types: 31, coercions: 0, joins: 0/4}
Data.Complex.$w$ccos [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 370 30}]
Data.Complex.$w$ccos
  = \ (@ a_sgxzH)
      (w_sgxzI :: RealFloat a_sgxzH)
      (ww_sgxzM
         :: a_sgxzH
         Unf=OtherCon [])
      (ww1_sgxzN
         :: a_sgxzH
         Unf=OtherCon []) ->
      let {
        $dFloating_sgulB [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
          :: Floating a_sgxzH
        [LclId]
        $dFloating_sgulB = GHC.Float.$p2RealFloat @ a_sgxzH w_sgxzI } in
      let {
        $dRealFrac_sgulA [Dmd=<S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxzH
        [LclId]
        $dRealFrac_sgulA = GHC.Float.$p1RealFloat @ a_sgxzH w_sgxzI } in
      let {
        $dReal_sgulz [Dmd=<S(S(LLC(C(S))C(S)LLL)LL),1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A)>]
          :: Real a_sgxzH
        [LclId]
        $dReal_sgulz = GHC.Real.$p1RealFrac @ a_sgxzH $dRealFrac_sgulA } in
      let {
        $dNum_sguly [Dmd=<S(LLC(C(S))C(S)LLL),U(A,A,C(C1(U)),1*C1(U),A,A,A)>]
          :: Num a_sgxzH
        [LclId]
        $dNum_sguly = GHC.Real.$p1Real @ a_sgxzH $dReal_sgulz } in
      case * @ a_sgxzH
             $dNum_sguly
             (cos @ a_sgxzH $dFloating_sgulB ww_sgxzM)
             (cosh @ a_sgxzH $dFloating_sgulB ww1_sgxzN)
      of dt_XgsFn
      { __DEFAULT ->
      case negate
             @ a_sgxzH
             $dNum_sguly
             (* @ a_sgxzH
                $dNum_sguly
                (sin @ a_sgxzH $dFloating_sgulB ww_sgxzM)
                (sinh @ a_sgxzH $dFloating_sgulB ww1_sgxzN))
      of dt1_XgsFs
      { __DEFAULT ->
      (# dt_XgsFn, dt1_XgsFs #)
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$ccos [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),C(U),A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxzH)
                 (w_sgxzI [Occ=Once] :: RealFloat a_sgxzH)
                 (w1_sgxzJ [Occ=Once!] :: Complex a_sgxzH) ->
                 case w1_sgxzJ of { :+ ww1_sgxzM [Occ=Once] ww2_sgxzN [Occ=Once] ->
                 case Data.Complex.$w$ccos @ a_sgxzH w_sgxzI ww1_sgxzM ww2_sgxzN of
                 { (# ww4_sgxQI [Occ=Once], ww5_sgxQJ [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxzH ww4_sgxQI ww5_sgxQJ
                 }
                 }}]
Data.Complex.$fFloatingComplex_$ccos
  = \ (@ a_sgxzH)
      (w_sgxzI :: RealFloat a_sgxzH)
      (w1_sgxzJ :: Complex a_sgxzH) ->
      case w1_sgxzJ of { :+ ww1_sgxzM ww2_sgxzN ->
      case Data.Complex.$w$ccos @ a_sgxzH w_sgxzI ww1_sgxzM ww2_sgxzN of
      { (# ww4_sgxQI, ww5_sgxQJ #) ->
      Data.Complex.:+ @ a_sgxzH ww4_sgxQI ww5_sgxQJ
      }
      }

-- RHS size: {terms: 23, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$csinh
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dgtjT [Occ=Once!] :: Complex Double) ->
                 case ds_dgtjT of { :+ x_agsol [Occ=Once!] y_agsom [Occ=Once!] ->
                 case x_agsol of { GHC.Types.D# x1_sgusx ->
                 case y_agsom of { GHC.Types.D# x2_sgusu ->
                 Data.Complex.:+
                   @ Double
                   (GHC.Types.D#
                      (GHC.Prim.*##
                         (GHC.Prim.cosDouble# x2_sgusu) (GHC.Prim.sinhDouble# x1_sgusx)))
                   (GHC.Types.D#
                      (GHC.Prim.*##
                         (GHC.Prim.sinDouble# x2_sgusu) (GHC.Prim.coshDouble# x1_sgusx)))
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$csinh
  = \ (ds_dgtjT :: Complex Double) ->
      case ds_dgtjT of { :+ x_agsol y_agsom ->
      case x_agsol of { GHC.Types.D# x1_sgzgP ->
      case y_agsom of { GHC.Types.D# x2_sgzgS ->
      Data.Complex.:+
        @ Double
        (GHC.Types.D#
           (GHC.Prim.*##
              (GHC.Prim.cosDouble# x2_sgzgS) (GHC.Prim.sinhDouble# x1_sgzgP)))
        (GHC.Types.D#
           (GHC.Prim.*##
              (GHC.Prim.sinDouble# x2_sgzgS) (GHC.Prim.coshDouble# x1_sgzgP)))
      }
      }
      }

-- RHS size: {terms: 39, types: 30, coercions: 0, joins: 0/4}
Data.Complex.$w$csinh [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 340 30}]
Data.Complex.$w$csinh
  = \ (@ a_sgxzT)
      (w_sgxzU :: RealFloat a_sgxzT)
      (ww_sgxzY
         :: a_sgxzT
         Unf=OtherCon [])
      (ww1_sgxzZ
         :: a_sgxzT
         Unf=OtherCon []) ->
      let {
        $dFloating_sgult [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
          :: Floating a_sgxzT
        [LclId]
        $dFloating_sgult = GHC.Float.$p2RealFloat @ a_sgxzT w_sgxzU } in
      let {
        $dRealFrac_sguls [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxzT
        [LclId]
        $dRealFrac_sguls = GHC.Float.$p1RealFloat @ a_sgxzT w_sgxzU } in
      let {
        $dReal_sgulr [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
          :: Real a_sgxzT
        [LclId]
        $dReal_sgulr = GHC.Real.$p1RealFrac @ a_sgxzT $dRealFrac_sguls } in
      let {
        $dNum_sgulq [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
          :: Num a_sgxzT
        [LclId]
        $dNum_sgulq = GHC.Real.$p1Real @ a_sgxzT $dReal_sgulr } in
      case * @ a_sgxzT
             $dNum_sgulq
             (cos @ a_sgxzT $dFloating_sgult ww1_sgxzZ)
             (sinh @ a_sgxzT $dFloating_sgult ww_sgxzY)
      of dt_XgsFq
      { __DEFAULT ->
      case * @ a_sgxzT
             $dNum_sgulq
             (sin @ a_sgxzT $dFloating_sgult ww1_sgxzZ)
             (cosh @ a_sgxzT $dFloating_sgult ww_sgxzY)
      of dt1_XgsFv
      { __DEFAULT ->
      (# dt_XgsFq, dt1_XgsFv #)
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$csinh [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxzT)
                 (w_sgxzU [Occ=Once] :: RealFloat a_sgxzT)
                 (w1_sgxzV [Occ=Once!] :: Complex a_sgxzT) ->
                 case w1_sgxzV of { :+ ww1_sgxzY [Occ=Once] ww2_sgxzZ [Occ=Once] ->
                 case Data.Complex.$w$csinh @ a_sgxzT w_sgxzU ww1_sgxzY ww2_sgxzZ of
                 { (# ww4_sgxQL [Occ=Once], ww5_sgxQM [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxzT ww4_sgxQL ww5_sgxQM
                 }
                 }}]
Data.Complex.$fFloatingComplex_$csinh
  = \ (@ a_sgxzT)
      (w_sgxzU :: RealFloat a_sgxzT)
      (w1_sgxzV :: Complex a_sgxzT) ->
      case w1_sgxzV of { :+ ww1_sgxzY ww2_sgxzZ ->
      case Data.Complex.$w$csinh @ a_sgxzT w_sgxzU ww1_sgxzY ww2_sgxzZ of
      { (# ww4_sgxQL, ww5_sgxQM #) ->
      Data.Complex.:+ @ a_sgxzT ww4_sgxQL ww5_sgxQM
      }
      }

-- RHS size: {terms: 23, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$ccosh
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dgtkb [Occ=Once!] :: Complex Double) ->
                 case ds_dgtkb of { :+ x_agson [Occ=Once!] y_agsoo [Occ=Once!] ->
                 case x_agson of { GHC.Types.D# x1_sgusJ ->
                 case y_agsoo of { GHC.Types.D# x2_sgusG ->
                 Data.Complex.:+
                   @ Double
                   (GHC.Types.D#
                      (GHC.Prim.*##
                         (GHC.Prim.cosDouble# x2_sgusG) (GHC.Prim.coshDouble# x1_sgusJ)))
                   (GHC.Types.D#
                      (GHC.Prim.*##
                         (GHC.Prim.sinDouble# x2_sgusG) (GHC.Prim.sinhDouble# x1_sgusJ)))
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$ccosh
  = \ (ds_dgtkb :: Complex Double) ->
      case ds_dgtkb of { :+ x_agson y_agsoo ->
      case x_agson of { GHC.Types.D# x1_sgzgV ->
      case y_agsoo of { GHC.Types.D# x2_sgzgY ->
      Data.Complex.:+
        @ Double
        (GHC.Types.D#
           (GHC.Prim.*##
              (GHC.Prim.cosDouble# x2_sgzgY) (GHC.Prim.coshDouble# x1_sgzgV)))
        (GHC.Types.D#
           (GHC.Prim.*##
              (GHC.Prim.sinDouble# x2_sgzgY) (GHC.Prim.sinhDouble# x1_sgzgV)))
      }
      }
      }

-- RHS size: {terms: 39, types: 30, coercions: 0, joins: 0/4}
Data.Complex.$w$ccosh [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 340 30}]
Data.Complex.$w$ccosh
  = \ (@ a_sgxA5)
      (w_sgxA6 :: RealFloat a_sgxA5)
      (ww_sgxAa
         :: a_sgxA5
         Unf=OtherCon [])
      (ww1_sgxAb
         :: a_sgxA5
         Unf=OtherCon []) ->
      let {
        $dFloating_sgull [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
          :: Floating a_sgxA5
        [LclId]
        $dFloating_sgull = GHC.Float.$p2RealFloat @ a_sgxA5 w_sgxA6 } in
      let {
        $dRealFrac_sgulk [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxA5
        [LclId]
        $dRealFrac_sgulk = GHC.Float.$p1RealFloat @ a_sgxA5 w_sgxA6 } in
      let {
        $dReal_sgulj [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
          :: Real a_sgxA5
        [LclId]
        $dReal_sgulj = GHC.Real.$p1RealFrac @ a_sgxA5 $dRealFrac_sgulk } in
      let {
        $dNum_sguli [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
          :: Num a_sgxA5
        [LclId]
        $dNum_sguli = GHC.Real.$p1Real @ a_sgxA5 $dReal_sgulj } in
      case * @ a_sgxA5
             $dNum_sguli
             (cos @ a_sgxA5 $dFloating_sgull ww1_sgxAb)
             (cosh @ a_sgxA5 $dFloating_sgull ww_sgxAa)
      of dt_XgsFt
      { __DEFAULT ->
      case * @ a_sgxA5
             $dNum_sguli
             (sin @ a_sgxA5 $dFloating_sgull ww1_sgxAb)
             (sinh @ a_sgxA5 $dFloating_sgull ww_sgxAa)
      of dt1_XgsFy
      { __DEFAULT ->
      (# dt_XgsFt, dt1_XgsFy #)
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$ccosh [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxA5)
                 (w_sgxA6 [Occ=Once] :: RealFloat a_sgxA5)
                 (w1_sgxA7 [Occ=Once!] :: Complex a_sgxA5) ->
                 case w1_sgxA7 of { :+ ww1_sgxAa [Occ=Once] ww2_sgxAb [Occ=Once] ->
                 case Data.Complex.$w$ccosh @ a_sgxA5 w_sgxA6 ww1_sgxAa ww2_sgxAb of
                 { (# ww4_sgxQO [Occ=Once], ww5_sgxQP [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxA5 ww4_sgxQO ww5_sgxQP
                 }
                 }}]
Data.Complex.$fFloatingComplex_$ccosh
  = \ (@ a_sgxA5)
      (w_sgxA6 :: RealFloat a_sgxA5)
      (w1_sgxA7 :: Complex a_sgxA5) ->
      case w1_sgxA7 of { :+ ww1_sgxAa ww2_sgxAb ->
      case Data.Complex.$w$ccosh @ a_sgxA5 w_sgxA6 ww1_sgxAa ww2_sgxAb of
      { (# ww4_sgxQO, ww5_sgxQP #) ->
      Data.Complex.:+ @ a_sgxA5 ww4_sgxQO ww5_sgxQP
      }
      }

-- RHS size: {terms: 71, types: 23, coercions: 0, joins: 1/2}
Data.Complex.$w$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> GHC.Prim.Double#
     -> (# Double, Double #)
[GblId,
 Arity=4,
 Str=<S,U><S,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0 0] 202 0}]
Data.Complex.$w$s$c/
  = \ (ww_sgxAp :: GHC.Prim.Double#)
      (ww1_sgxAu :: GHC.Prim.Double#)
      (ww2_sgxAC :: GHC.Prim.Double#)
      (ww3_sgxAH :: GHC.Prim.Double#) ->
      case GHC.Float.$w$cexponent ww2_sgxAC of ww4_igtyh { __DEFAULT ->
      case GHC.Float.$w$cexponent ww3_sgxAH of ww5_XgtId { __DEFAULT ->
      join {
        $j_sgwyJ [Dmd=<C(S),1*C1(U(U,U))>]
          :: GHC.Prim.Int# -> (# Double, Double #)
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_sgwyJ (ww6_igtyq [OS=OneShot] :: GHC.Prim.Int#)
          = case GHC.Float.$w$cscaleFloat ww6_igtyq ww2_sgxAC of ww7_igtyx
            { __DEFAULT ->
            case GHC.Float.$w$cscaleFloat ww6_igtyq ww3_sgxAH of ww8_XgtIA
            { __DEFAULT ->
            let {
              y_igtAy [Dmd=<S,U>] :: GHC.Prim.Double#
              [LclId]
              y_igtAy
                = GHC.Prim.+##
                    (GHC.Prim.*## ww2_sgxAC ww7_igtyx)
                    (GHC.Prim.*## ww3_sgxAH ww8_XgtIA) } in
            case GHC.Prim./##
                   (GHC.Prim.+##
                      (GHC.Prim.*## ww_sgxAp ww7_igtyx)
                      (GHC.Prim.*## ww1_sgxAu ww8_XgtIA))
                   y_igtAy
            of wild2_igtAA
            { __DEFAULT ->
            case GHC.Prim./##
                   (GHC.Prim.-##
                      (GHC.Prim.*## ww1_sgxAu ww7_igtyx)
                      (GHC.Prim.*## ww_sgxAp ww8_XgtIA))
                   y_igtAy
            of wild1_XgtQI
            { __DEFAULT ->
            (# GHC.Types.D# wild2_igtAA, GHC.Types.D# wild1_XgtQI #)
            }
            }
            }
            } } in
      case GHC.Prim.<=# ww4_igtyh ww5_XgtId of {
        __DEFAULT -> jump $j_sgwyJ (GHC.Prim.negateInt# ww4_igtyh);
        1# -> jump $j_sgwyJ (GHC.Prim.negateInt# ww5_XgtId)
      }
      }
      }

-- RHS size: {terms: 30, types: 28, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double -> Complex Double
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxAi [Occ=Once!] :: Complex Double)
                 (w1_sgxAj [Occ=Once!] :: Complex Double) ->
                 case w_sgxAi of { :+ ww1_sgxAm [Occ=Once!] ww2_sgxAr [Occ=Once!] ->
                 case ww1_sgxAm of { GHC.Types.D# ww4_sgxAp [Occ=Once] ->
                 case ww2_sgxAr of { GHC.Types.D# ww6_sgxAu [Occ=Once] ->
                 case w1_sgxAj of
                 { :+ ww8_sgxAz [Occ=Once!] ww9_sgxAE [Occ=Once!] ->
                 case ww8_sgxAz of { GHC.Types.D# ww11_sgxAC [Occ=Once] ->
                 case ww9_sgxAE of { GHC.Types.D# ww13_sgxAH [Occ=Once] ->
                 case Data.Complex.$w$s$c/ ww4_sgxAp ww6_sgxAu ww11_sgxAC ww13_sgxAH
                 of
                 { (# ww15_sgxQR [Occ=Once], ww16_sgxQS [Occ=Once] #) ->
                 Data.Complex.:+ @ Double ww15_sgxQR ww16_sgxQS
                 }
                 }
                 }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$c/
  = \ (w_sgxAi :: Complex Double) (w1_sgxAj :: Complex Double) ->
      case w_sgxAi of { :+ ww1_sgxAm ww2_sgxAr ->
      case ww1_sgxAm of { GHC.Types.D# ww4_sgzh1 ->
      case ww2_sgxAr of { GHC.Types.D# ww6_sgzh4 ->
      case w1_sgxAj of { :+ ww8_sgxAz ww9_sgxAE ->
      case ww8_sgxAz of { GHC.Types.D# ww11_sgzh7 ->
      case ww9_sgxAE of { GHC.Types.D# ww13_sgzha ->
      case Data.Complex.$w$s$c/ ww4_sgzh1 ww6_sgzh4 ww11_sgzh7 ww13_sgzha
      of
      { (# ww15_sgxQR, ww16_sgxQS #) ->
      Data.Complex.:+ @ Double ww15_sgxQR ww16_sgxQS
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 95, types: 50, coercions: 0, joins: 0/8}
Data.Complex.$w$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(1*U(1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []]
Data.Complex.$w$c/
  = \ (@ a_sgxAO)
      (w_sgxAP :: RealFloat a_sgxAO)
      (ww_sgxAU
         :: a_sgxAO
         Unf=OtherCon [])
      (ww1_sgxAV
         :: a_sgxAO
         Unf=OtherCon [])
      (ww2_sgxAZ
         :: a_sgxAO
         Unf=OtherCon [])
      (ww3_sgxB0
         :: a_sgxAO
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sgul1 [Dmd=<S(LS(LC(C(S))LL)LLLLL),U(1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
          :: RealFrac a_sgxAO
        [LclId]
        $dRealFrac_sgul1 = GHC.Float.$p1RealFloat @ a_sgxAO w_sgxAP } in
      let {
        $dFractional_sgukY [Dmd=<S(LC(C(S))LL),U(A,C(C1(U)),A,A)>]
          :: Fractional a_sgxAO
        [LclId]
        $dFractional_sgukY
          = GHC.Real.$p2RealFrac @ a_sgxAO $dRealFrac_sgul1 } in
      let {
        $dReal_sgul0 [Dmd=<L,1*U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
          :: Real a_sgxAO
        [LclId]
        $dReal_sgul0 = GHC.Real.$p1RealFrac @ a_sgxAO $dRealFrac_sgul1 } in
      let {
        $dNum_sgukZ [Dmd=<L,U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
          :: Num a_sgxAO
        [LclId]
        $dNum_sgukZ = GHC.Real.$p1Real @ a_sgxAO $dReal_sgul0 } in
      let {
        k_sgukX :: Int
        [LclId]
        k_sgukX
          = case exponent @ a_sgxAO w_sgxAP ww2_sgxAZ of
            { GHC.Types.I# x1_at56 ->
            case exponent @ a_sgxAO w_sgxAP ww3_sgxB0 of
            { GHC.Types.I# y1_at5a ->
            case GHC.Prim.<=# x1_at56 y1_at5a of {
              __DEFAULT -> GHC.Types.I# (GHC.Prim.negateInt# x1_at56);
              1# -> GHC.Types.I# (GHC.Prim.negateInt# y1_at5a)
            }
            }
            } } in
      let {
        y''_sgukW :: a_sgxAO
        [LclId]
        y''_sgukW = scaleFloat @ a_sgxAO w_sgxAP k_sgukX ww3_sgxB0 } in
      let {
        x''_sgukV :: a_sgxAO
        [LclId]
        x''_sgukV = scaleFloat @ a_sgxAO w_sgxAP k_sgukX ww2_sgxAZ } in
      let {
        d_sgukU :: a_sgxAO
        [LclId]
        d_sgukU
          = + @ a_sgxAO
              $dNum_sgukZ
              (* @ a_sgxAO $dNum_sgukZ ww2_sgxAZ x''_sgukV)
              (* @ a_sgxAO $dNum_sgukZ ww3_sgxB0 y''_sgukW) } in
      case / @ a_sgxAO
             $dFractional_sgukY
             (+ @ a_sgxAO
                $dNum_sgukZ
                (* @ a_sgxAO $dNum_sgukZ ww_sgxAU x''_sgukV)
                (* @ a_sgxAO $dNum_sgukZ ww1_sgxAV y''_sgukW))
             d_sgukU
      of dt_XgsPZ
      { __DEFAULT ->
      case / @ a_sgxAO
             $dFractional_sgukY
             (- @ a_sgxAO
                $dNum_sgukZ
                (* @ a_sgxAO $dNum_sgukZ ww1_sgxAV x''_sgukV)
                (* @ a_sgxAO $dNum_sgukZ ww_sgxAU y''_sgukW))
             d_sgukU
      of dt1_XgsFQ
      { __DEFAULT ->
      (# dt_XgsPZ, dt1_XgsFQ #)
      }
      }

-- RHS size: {terms: 21, types: 25, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a -> Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxAO)
                 (w_sgxAP [Occ=Once] :: RealFloat a_sgxAO)
                 (w1_sgxAQ [Occ=Once!] :: Complex a_sgxAO)
                 (w2_sgxAR [Occ=Once!] :: Complex a_sgxAO) ->
                 case w1_sgxAQ of { :+ ww1_sgxAU [Occ=Once] ww2_sgxAV [Occ=Once] ->
                 case w2_sgxAR of { :+ ww4_sgxAZ [Occ=Once] ww5_sgxB0 [Occ=Once] ->
                 case Data.Complex.$w$c/
                        @ a_sgxAO w_sgxAP ww1_sgxAU ww2_sgxAV ww4_sgxAZ ww5_sgxB0
                 of
                 { (# ww7_sgxQU [Occ=Once], ww8_sgxQV [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxAO ww7_sgxQU ww8_sgxQV
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$c/
  = \ (@ a_sgxAO)
      (w_sgxAP :: RealFloat a_sgxAO)
      (w1_sgxAQ :: Complex a_sgxAO)
      (w2_sgxAR :: Complex a_sgxAO) ->
      case w1_sgxAQ of { :+ ww1_sgxAU ww2_sgxAV ->
      case w2_sgxAR of { :+ ww4_sgxAZ ww5_sgxB0 ->
      case Data.Complex.$w$c/
             @ a_sgxAO w_sgxAP ww1_sgxAU ww2_sgxAV ww4_sgxAZ ww5_sgxB0
      of
      { (# ww7_sgxQU, ww8_sgxQV #) ->
      Data.Complex.:+ @ a_sgxAO ww7_sgxQU ww8_sgxQV
      }
      }
      }

-- RHS size: {terms: 12, types: 8, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cfromRational
  :: Rational -> Complex Double
[GblId,
 Arity=1,
 Str=<S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_agsp6 [Occ=Once!] :: Rational) ->
                 case a_agsp6 of
                 { GHC.Real.:% n_iebpK [Occ=Once] d_iebpL [Occ=Once] ->
                 case GHC.Float.rationalToDouble n_iebpK d_iebpL of dt_XgsFo
                 { GHC.Types.D# _ [Occ=Dead] ->
                 Data.Complex.:+ @ Double dt_XgsFo Data.Complex.$fFloatingComplex1
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$cfromRational
  = \ (a_agsp6 :: Rational) ->
      case a_agsp6 of { GHC.Real.:% n_iebpK d_iebpL ->
      case GHC.Float.rationalToDouble n_iebpK d_iebpL of dt_XgsFo
      { GHC.Types.D# ipv_sguJv ->
      Data.Complex.:+ @ Double dt_XgsFo Data.Complex.$fFloatingComplex1
      }
      }

-- RHS size: {terms: 22, types: 19, coercions: 0, joins: 0/1}
Data.Complex.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Rational -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 170 30}]
Data.Complex.$w$cfromRational
  = \ (@ a_sgxB6)
      (w_sgxB7 :: RealFloat a_sgxB6)
      (w1_sgxB8 :: Rational) ->
      let {
        $dRealFrac_sgukL [Dmd=<S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A)>]
          :: RealFrac a_sgxB6
        [LclId]
        $dRealFrac_sgukL = GHC.Float.$p1RealFloat @ a_sgxB6 w_sgxB7 } in
      case fromRational
             @ a_sgxB6
             (GHC.Real.$p2RealFrac @ a_sgxB6 $dRealFrac_sgukL)
             w1_sgxB8
      of dt_XgsFp
      { __DEFAULT ->
      case fromInteger
             @ a_sgxB6
             (GHC.Real.$p1Real
                @ a_sgxB6 (GHC.Real.$p1RealFrac @ a_sgxB6 $dRealFrac_sgukL))
             Data.Complex.$fFloatingComplex17
      of dt1_XgsFu
      { __DEFAULT ->
      (# dt_XgsFp, dt1_XgsFu #)
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
Data.Complex.$fFractionalComplex_$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Rational -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LLLC(S))LLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),1*U(A,A,A,1*C1(U)),A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxB6)
                 (w_sgxB7 [Occ=Once] :: RealFloat a_sgxB6)
                 (w1_sgxB8 [Occ=Once] :: Rational) ->
                 case Data.Complex.$w$cfromRational @ a_sgxB6 w_sgxB7 w1_sgxB8 of
                 { (# ww1_sgxQX [Occ=Once], ww2_sgxQY [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxB6 ww1_sgxQX ww2_sgxQY
                 }}]
Data.Complex.$fFractionalComplex_$cfromRational
  = \ (@ a_sgxB6)
      (w_sgxB7 :: RealFloat a_sgxB6)
      (w1_sgxB8 :: Rational) ->
      case Data.Complex.$w$cfromRational @ a_sgxB6 w_sgxB7 w1_sgxB8 of
      { (# ww1_sgxQX, ww2_sgxQY #) ->
      Data.Complex.:+ @ a_sgxB6 ww1_sgxQX ww2_sgxQY
      }

-- RHS size: {terms: 29, types: 21, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double -> Complex Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxBd [Occ=Once!] :: Complex Double)
                 (w1_sgxBe [Occ=Once!] :: Complex Double) ->
                 case w_sgxBd of { :+ ww1_sgxBh [Occ=Once!] ww2_sgxBm [Occ=Once!] ->
                 case ww1_sgxBh of { GHC.Types.D# ww4_sgxBk [Occ=Once] ->
                 case ww2_sgxBm of { GHC.Types.D# ww6_sgxBp [Occ=Once] ->
                 case w1_sgxBe of
                 { :+ ww8_sgxBu [Occ=Once!] ww9_sgxBz [Occ=Once!] ->
                 case ww8_sgxBu of { GHC.Types.D# ww11_sgxBx [Occ=Once] ->
                 case ww9_sgxBz of { GHC.Types.D# ww13_sgxBC [Occ=Once] ->
                 Data.Complex.:+
                   @ Double
                   (GHC.Types.D# (GHC.Prim.+## ww4_sgxBk ww11_sgxBx))
                   (GHC.Types.D# (GHC.Prim.+## ww6_sgxBp ww13_sgxBC))
                 }
                 }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$c+
  = \ (w_sgxBd :: Complex Double) (w1_sgxBe :: Complex Double) ->
      case w_sgxBd of { :+ ww1_sgxBh ww2_sgxBm ->
      case ww1_sgxBh of { GHC.Types.D# ww4_sgzhd ->
      case ww2_sgxBm of { GHC.Types.D# ww6_sgzhg ->
      case w1_sgxBe of { :+ ww8_sgxBu ww9_sgxBz ->
      case ww8_sgxBu of { GHC.Types.D# ww11_sgzhj ->
      case ww9_sgxBz of { GHC.Types.D# ww13_sgzhm ->
      Data.Complex.:+
        @ Double
        (GHC.Types.D# (GHC.Prim.+## ww4_sgzhd ww11_sgzhj))
        (GHC.Types.D# (GHC.Prim.+## ww6_sgzhg ww13_sgzhm))
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 30, types: 25, coercions: 0, joins: 0/3}
Data.Complex.$w$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))LLLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 190 30}]
Data.Complex.$w$c+
  = \ (@ a_sgxBJ)
      (w_sgxBK :: RealFloat a_sgxBJ)
      (ww_sgxBP
         :: a_sgxBJ
         Unf=OtherCon [])
      (ww1_sgxBQ
         :: a_sgxBJ
         Unf=OtherCon [])
      (ww2_sgxBU
         :: a_sgxBJ
         Unf=OtherCon [])
      (ww3_sgxBV
         :: a_sgxBJ
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sgukD [Dmd=<S(S(S(C(C(S))LLLLLL)LL)LLLLLL),1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxBJ
        [LclId]
        $dRealFrac_sgukD = GHC.Float.$p1RealFloat @ a_sgxBJ w_sgxBK } in
      let {
        $dReal_sgukC [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A)>]
          :: Real a_sgxBJ
        [LclId]
        $dReal_sgukC = GHC.Real.$p1RealFrac @ a_sgxBJ $dRealFrac_sgukD } in
      let {
        $dNum_sgukB [Dmd=<S(C(C(S))LLLLLL),U(C(C1(U)),A,A,A,A,A,A)>]
          :: Num a_sgxBJ
        [LclId]
        $dNum_sgukB = GHC.Real.$p1Real @ a_sgxBJ $dReal_sgukC } in
      case + @ a_sgxBJ $dNum_sgukB ww_sgxBP ww2_sgxBU of dt_XgsFJ
      { __DEFAULT ->
      case + @ a_sgxBJ $dNum_sgukB ww1_sgxBQ ww3_sgxBV of dt1_XgsFO
      { __DEFAULT ->
      (# dt_XgsFJ, dt1_XgsFO #)
      }
      }

-- RHS size: {terms: 21, types: 25, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a -> Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))LLLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(C(C1(U)),A,A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxBJ)
                 (w_sgxBK [Occ=Once] :: RealFloat a_sgxBJ)
                 (w1_sgxBL [Occ=Once!] :: Complex a_sgxBJ)
                 (w2_sgxBM [Occ=Once!] :: Complex a_sgxBJ) ->
                 case w1_sgxBL of { :+ ww1_sgxBP [Occ=Once] ww2_sgxBQ [Occ=Once] ->
                 case w2_sgxBM of { :+ ww4_sgxBU [Occ=Once] ww5_sgxBV [Occ=Once] ->
                 case Data.Complex.$w$c+
                        @ a_sgxBJ w_sgxBK ww1_sgxBP ww2_sgxBQ ww4_sgxBU ww5_sgxBV
                 of
                 { (# ww7_sgxR3 [Occ=Once], ww8_sgxR4 [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxBJ ww7_sgxR3 ww8_sgxR4
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$c+
  = \ (@ a_sgxBJ)
      (w_sgxBK :: RealFloat a_sgxBJ)
      (w1_sgxBL :: Complex a_sgxBJ)
      (w2_sgxBM :: Complex a_sgxBJ) ->
      case w1_sgxBL of { :+ ww1_sgxBP ww2_sgxBQ ->
      case w2_sgxBM of { :+ ww4_sgxBU ww5_sgxBV ->
      case Data.Complex.$w$c+
             @ a_sgxBJ w_sgxBK ww1_sgxBP ww2_sgxBQ ww4_sgxBU ww5_sgxBV
      of
      { (# ww7_sgxR3, ww8_sgxR4 #) ->
      Data.Complex.:+ @ a_sgxBJ ww7_sgxR3 ww8_sgxR4
      }
      }
      }

-- RHS size: {terms: 29, types: 21, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$c- [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double -> Complex Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxC1 [Occ=Once!] :: Complex Double)
                 (w1_sgxC2 [Occ=Once!] :: Complex Double) ->
                 case w_sgxC1 of { :+ ww1_sgxC5 [Occ=Once!] ww2_sgxCa [Occ=Once!] ->
                 case ww1_sgxC5 of { GHC.Types.D# ww4_sgxC8 [Occ=Once] ->
                 case ww2_sgxCa of { GHC.Types.D# ww6_sgxCd [Occ=Once] ->
                 case w1_sgxC2 of
                 { :+ ww8_sgxCi [Occ=Once!] ww9_sgxCn [Occ=Once!] ->
                 case ww8_sgxCi of { GHC.Types.D# ww11_sgxCl [Occ=Once] ->
                 case ww9_sgxCn of { GHC.Types.D# ww13_sgxCq [Occ=Once] ->
                 Data.Complex.:+
                   @ Double
                   (GHC.Types.D# (GHC.Prim.-## ww4_sgxC8 ww11_sgxCl))
                   (GHC.Types.D# (GHC.Prim.-## ww6_sgxCd ww13_sgxCq))
                 }
                 }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$c-
  = \ (w_sgxC1 :: Complex Double) (w1_sgxC2 :: Complex Double) ->
      case w_sgxC1 of { :+ ww1_sgxC5 ww2_sgxCa ->
      case ww1_sgxC5 of { GHC.Types.D# ww4_sgzhp ->
      case ww2_sgxCa of { GHC.Types.D# ww6_sgzhs ->
      case w1_sgxC2 of { :+ ww8_sgxCi ww9_sgxCn ->
      case ww8_sgxCi of { GHC.Types.D# ww11_sgzhv ->
      case ww9_sgxCn of { GHC.Types.D# ww13_sgzhy ->
      Data.Complex.:+
        @ Double
        (GHC.Types.D# (GHC.Prim.-## ww4_sgzhp ww11_sgzhv))
        (GHC.Types.D# (GHC.Prim.-## ww6_sgzhs ww13_sgzhy))
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 30, types: 25, coercions: 0, joins: 0/3}
Data.Complex.$w$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 190 30}]
Data.Complex.$w$c-
  = \ (@ a_sgxCx)
      (w_sgxCy :: RealFloat a_sgxCx)
      (ww_sgxCD
         :: a_sgxCx
         Unf=OtherCon [])
      (ww1_sgxCE
         :: a_sgxCx
         Unf=OtherCon [])
      (ww2_sgxCI
         :: a_sgxCx
         Unf=OtherCon [])
      (ww3_sgxCJ
         :: a_sgxCx
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sgukv [Dmd=<S(S(S(LC(C(S))LLLLL)LL)LLLLLL),1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxCx
        [LclId]
        $dRealFrac_sgukv = GHC.Float.$p1RealFloat @ a_sgxCx w_sgxCy } in
      let {
        $dReal_sguku [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A)>]
          :: Real a_sgxCx
        [LclId]
        $dReal_sguku = GHC.Real.$p1RealFrac @ a_sgxCx $dRealFrac_sgukv } in
      let {
        $dNum_sgukt [Dmd=<S(LC(C(S))LLLLL),U(A,C(C1(U)),A,A,A,A,A)>]
          :: Num a_sgxCx
        [LclId]
        $dNum_sgukt = GHC.Real.$p1Real @ a_sgxCx $dReal_sguku } in
      case - @ a_sgxCx $dNum_sgukt ww_sgxCD ww2_sgxCI of dt_XgsFM
      { __DEFAULT ->
      case - @ a_sgxCx $dNum_sgukt ww1_sgxCE ww3_sgxCJ of dt1_XgsFR
      { __DEFAULT ->
      (# dt_XgsFM, dt1_XgsFR #)
      }
      }

-- RHS size: {terms: 21, types: 25, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a -> Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LC(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxCx)
                 (w_sgxCy [Occ=Once] :: RealFloat a_sgxCx)
                 (w1_sgxCz [Occ=Once!] :: Complex a_sgxCx)
                 (w2_sgxCA [Occ=Once!] :: Complex a_sgxCx) ->
                 case w1_sgxCz of { :+ ww1_sgxCD [Occ=Once] ww2_sgxCE [Occ=Once] ->
                 case w2_sgxCA of { :+ ww4_sgxCI [Occ=Once] ww5_sgxCJ [Occ=Once] ->
                 case Data.Complex.$w$c-
                        @ a_sgxCx w_sgxCy ww1_sgxCD ww2_sgxCE ww4_sgxCI ww5_sgxCJ
                 of
                 { (# ww7_sgxR9 [Occ=Once], ww8_sgxRa [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxCx ww7_sgxR9 ww8_sgxRa
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$c-
  = \ (@ a_sgxCx)
      (w_sgxCy :: RealFloat a_sgxCx)
      (w1_sgxCz :: Complex a_sgxCx)
      (w2_sgxCA :: Complex a_sgxCx) ->
      case w1_sgxCz of { :+ ww1_sgxCD ww2_sgxCE ->
      case w2_sgxCA of { :+ ww4_sgxCI ww5_sgxCJ ->
      case Data.Complex.$w$c-
             @ a_sgxCx w_sgxCy ww1_sgxCD ww2_sgxCE ww4_sgxCI ww5_sgxCJ
      of
      { (# ww7_sgxR9, ww8_sgxRa #) ->
      Data.Complex.:+ @ a_sgxCx ww7_sgxR9 ww8_sgxRa
      }
      }
      }

-- RHS size: {terms: 37, types: 21, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$c* [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double -> Complex Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))><S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxCP [Occ=Once!] :: Complex Double)
                 (w1_sgxCQ [Occ=Once!] :: Complex Double) ->
                 case w_sgxCP of { :+ ww1_sgxCT [Occ=Once!] ww2_sgxCY [Occ=Once!] ->
                 case ww1_sgxCT of { GHC.Types.D# ww4_sgxCW ->
                 case ww2_sgxCY of { GHC.Types.D# ww6_sgxD1 ->
                 case w1_sgxCQ of
                 { :+ ww8_sgxD6 [Occ=Once!] ww9_sgxDb [Occ=Once!] ->
                 case ww8_sgxD6 of { GHC.Types.D# ww11_sgxD9 ->
                 case ww9_sgxDb of { GHC.Types.D# ww13_sgxDe ->
                 Data.Complex.:+
                   @ Double
                   (GHC.Types.D#
                      (GHC.Prim.-##
                         (GHC.Prim.*## ww4_sgxCW ww11_sgxD9)
                         (GHC.Prim.*## ww6_sgxD1 ww13_sgxDe)))
                   (GHC.Types.D#
                      (GHC.Prim.+##
                         (GHC.Prim.*## ww4_sgxCW ww13_sgxDe)
                         (GHC.Prim.*## ww6_sgxD1 ww11_sgxD9)))
                 }
                 }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$c*
  = \ (w_sgxCP :: Complex Double) (w1_sgxCQ :: Complex Double) ->
      case w_sgxCP of { :+ ww1_sgxCT ww2_sgxCY ->
      case ww1_sgxCT of { GHC.Types.D# ww4_sgzhB ->
      case ww2_sgxCY of { GHC.Types.D# ww6_sgzhE ->
      case w1_sgxCQ of { :+ ww8_sgxD6 ww9_sgxDb ->
      case ww8_sgxD6 of { GHC.Types.D# ww11_sgzhH ->
      case ww9_sgxDb of { GHC.Types.D# ww13_sgzhK ->
      Data.Complex.:+
        @ Double
        (GHC.Types.D#
           (GHC.Prim.-##
              (GHC.Prim.*## ww4_sgzhB ww11_sgzhH)
              (GHC.Prim.*## ww6_sgzhE ww13_sgzhK)))
        (GHC.Types.D#
           (GHC.Prim.+##
              (GHC.Prim.*## ww4_sgzhB ww13_sgzhK)
              (GHC.Prim.*## ww6_sgzhE ww11_sgzhH)))
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 42, types: 29, coercions: 0, joins: 0/3}
Data.Complex.$w$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 350 30}]
Data.Complex.$w$c*
  = \ (@ a_sgxDl)
      (w_sgxDm :: RealFloat a_sgxDl)
      (ww_sgxDr
         :: a_sgxDl
         Unf=OtherCon [])
      (ww1_sgxDs
         :: a_sgxDl
         Unf=OtherCon [])
      (ww2_sgxDw
         :: a_sgxDl
         Unf=OtherCon [])
      (ww3_sgxDx
         :: a_sgxDl
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sgukp [Dmd=<S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL),1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxDl
        [LclId]
        $dRealFrac_sgukp = GHC.Float.$p1RealFloat @ a_sgxDl w_sgxDm } in
      let {
        $dReal_sguko [Dmd=<S(S(C(C(S))C(C(S))LLLLL)LL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
          :: Real a_sgxDl
        [LclId]
        $dReal_sguko = GHC.Real.$p1RealFrac @ a_sgxDl $dRealFrac_sgukp } in
      let {
        $dNum_sgukn [Dmd=<S(C(C(S))C(C(S))LLLLL),U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
          :: Num a_sgxDl
        [LclId]
        $dNum_sgukn = GHC.Real.$p1Real @ a_sgxDl $dReal_sguko } in
      case - @ a_sgxDl
             $dNum_sgukn
             (* @ a_sgxDl $dNum_sgukn ww_sgxDr ww2_sgxDw)
             (* @ a_sgxDl $dNum_sgukn ww1_sgxDs ww3_sgxDx)
      of dt_XgsQ7
      { __DEFAULT ->
      case + @ a_sgxDl
             $dNum_sgukn
             (* @ a_sgxDl $dNum_sgukn ww_sgxDr ww3_sgxDx)
             (* @ a_sgxDl $dNum_sgukn ww1_sgxDs ww2_sgxDw)
      of dt1_XgsQf
      { __DEFAULT ->
      (# dt_XgsQ7, dt1_XgsQf #)
      }
      }

-- RHS size: {terms: 21, types: 25, coercions: 0, joins: 0/0}
Data.Complex.$fNumComplex_$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a -> Complex a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxDl)
                 (w_sgxDm [Occ=Once] :: RealFloat a_sgxDl)
                 (w1_sgxDn [Occ=Once!] :: Complex a_sgxDl)
                 (w2_sgxDo [Occ=Once!] :: Complex a_sgxDl) ->
                 case w1_sgxDn of { :+ ww1_sgxDr [Occ=Once] ww2_sgxDs [Occ=Once] ->
                 case w2_sgxDo of { :+ ww4_sgxDw [Occ=Once] ww5_sgxDx [Occ=Once] ->
                 case Data.Complex.$w$c*
                        @ a_sgxDl w_sgxDm ww1_sgxDr ww2_sgxDs ww4_sgxDw ww5_sgxDx
                 of
                 { (# ww7_sgxRf [Occ=Once], ww8_sgxRg [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxDl ww7_sgxRf ww8_sgxRg
                 }
                 }
                 }}]
Data.Complex.$fNumComplex_$c*
  = \ (@ a_sgxDl)
      (w_sgxDm :: RealFloat a_sgxDl)
      (w1_sgxDn :: Complex a_sgxDl)
      (w2_sgxDo :: Complex a_sgxDl) ->
      case w1_sgxDn of { :+ ww1_sgxDr ww2_sgxDs ->
      case w2_sgxDo of { :+ ww4_sgxDw ww5_sgxDx ->
      case Data.Complex.$w$c*
             @ a_sgxDl w_sgxDm ww1_sgxDr ww2_sgxDs ww4_sgxDw ww5_sgxDx
      of
      { (# ww7_sgxRf, ww8_sgxRg #) ->
      Data.Complex.:+ @ a_sgxDl ww7_sgxRf ww8_sgxRg
      }
      }
      }

-- RHS size: {terms: 17, types: 11, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cnegate
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dgtpZ [Occ=Once!] :: Complex Double) ->
                 case ds_dgtpZ of { :+ x_agspk [Occ=Once!] y_agspl [Occ=Once!] ->
                 case x_agspk of { GHC.Types.D# x1_sgutY [Occ=Once] ->
                 case y_agspl of { GHC.Types.D# x2_sguu1 [Occ=Once] ->
                 Data.Complex.:+
                   @ Double
                   (GHC.Types.D# (GHC.Prim.negateDouble# x1_sgutY))
                   (GHC.Types.D# (GHC.Prim.negateDouble# x2_sguu1))
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$cnegate
  = \ (ds_dgtpZ :: Complex Double) ->
      case ds_dgtpZ of { :+ x_agspk y_agspl ->
      case x_agspk of { GHC.Types.D# x1_sgzhN ->
      case y_agspl of { GHC.Types.D# x2_sgzhQ ->
      Data.Complex.:+
        @ Double
        (GHC.Types.D# (GHC.Prim.negateDouble# x1_sgzhN))
        (GHC.Types.D# (GHC.Prim.negateDouble# x2_sgzhQ))
      }
      }
      }

-- RHS size: {terms: 26, types: 23, coercions: 0, joins: 0/3}
Data.Complex.$w$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLLC(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 170 30}]
Data.Complex.$w$cnegate
  = \ (@ a_sgxDD)
      (w_sgxDE :: RealFloat a_sgxDD)
      (ww_sgxDI
         :: a_sgxDD
         Unf=OtherCon [])
      (ww1_sgxDJ
         :: a_sgxDD
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sgukh [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxDD
        [LclId]
        $dRealFrac_sgukh = GHC.Float.$p1RealFloat @ a_sgxDD w_sgxDE } in
      let {
        $dReal_sgukg [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
          :: Real a_sgxDD
        [LclId]
        $dReal_sgukg = GHC.Real.$p1RealFrac @ a_sgxDD $dRealFrac_sgukh } in
      let {
        $dNum_sgukf [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
          :: Num a_sgxDD
        [LclId]
        $dNum_sgukf = GHC.Real.$p1Real @ a_sgxDD $dReal_sgukg } in
      case negate @ a_sgxDD $dNum_sgukf ww_sgxDI of dt_XgsPZ
      { __DEFAULT ->
      case negate @ a_sgxDD $dNum_sgukf ww1_sgxDJ of dt1_XgsFQ
      { __DEFAULT ->
      (# dt_XgsPZ, dt1_XgsFQ #)
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLLC(S)LLL)LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxDD)
                 (w_sgxDE [Occ=Once] :: RealFloat a_sgxDD)
                 (w1_sgxDF [Occ=Once!] :: Complex a_sgxDD) ->
                 case w1_sgxDF of { :+ ww1_sgxDI [Occ=Once] ww2_sgxDJ [Occ=Once] ->
                 case Data.Complex.$w$cnegate @ a_sgxDD w_sgxDE ww1_sgxDI ww2_sgxDJ
                 of
                 { (# ww4_sgxRi [Occ=Once], ww5_sgxRj [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxDD ww4_sgxRi ww5_sgxRj
                 }
                 }}]
Data.Complex.$fFloatingComplex_$cnegate
  = \ (@ a_sgxDD)
      (w_sgxDE :: RealFloat a_sgxDD)
      (w1_sgxDF :: Complex a_sgxDD) ->
      case w1_sgxDF of { :+ ww1_sgxDI ww2_sgxDJ ->
      case Data.Complex.$w$cnegate @ a_sgxDD w_sgxDE ww1_sgxDI ww2_sgxDJ
      of
      { (# ww4_sgxRi, ww5_sgxRj #) ->
      Data.Complex.:+ @ a_sgxDD ww4_sgxRi ww5_sgxRj
      }
      }

-- RHS size: {terms: 19, types: 12, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cabs
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (z_agspm [Occ=Once] :: Complex Double) ->
                 case Data.Complex.$fFloatingComplex_$smagnitude z_agspm of dt_XgsFz
                 { GHC.Types.D# _ [Occ=Dead] ->
                 Data.Complex.:+ @ Double dt_XgsFz Data.Complex.$fFloatingComplex1
                 }}]
Data.Complex.$fFloatingComplex_$s$cabs
  = \ (z_agspm :: Complex Double) ->
      case z_agspm of { :+ ww1_sgxxK ww2_sgxxP ->
      case ww1_sgxxK of { GHC.Types.D# ww4_sgzhT ->
      case ww2_sgxxP of { GHC.Types.D# ww6_sgzhW ->
      case Data.Complex.$w$smagnitude ww4_sgzhT ww6_sgzhW of ww7_sgxxX
      { __DEFAULT ->
      Data.Complex.:+
        @ Double (GHC.Types.D# ww7_sgxxX) Data.Complex.$fFloatingComplex1
      }
      }
      }
      }

-- RHS size: {terms: 21, types: 17, coercions: 0, joins: 0/0}
Data.Complex.$w$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,1*C1(U)),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 150 30}]
Data.Complex.$w$cabs
  = \ (@ a_sgxDP)
      (w_sgxDQ :: RealFloat a_sgxDP)
      (ww_sgxDU
         :: a_sgxDP
         Unf=OtherCon [])
      (ww1_sgxDV
         :: a_sgxDP
         Unf=OtherCon []) ->
      case Data.Complex.$wmagnitude @ a_sgxDP w_sgxDQ ww_sgxDU ww1_sgxDV
      of dt_XgsFE
      { __DEFAULT ->
      case fromInteger
             @ a_sgxDP
             (GHC.Real.$p1Real
                @ a_sgxDP
                (GHC.Real.$p1RealFrac
                   @ a_sgxDP (GHC.Float.$p1RealFloat @ a_sgxDP w_sgxDQ)))
             Data.Complex.$fFloatingComplex17
      of dt1_XgsFJ
      { __DEFAULT ->
      (# dt_XgsFE, dt1_XgsFJ #)
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fNumComplex_$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLC(C(S))LLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),A,A),A,A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxDP)
                 (w_sgxDQ [Occ=Once] :: RealFloat a_sgxDP)
                 (w1_sgxDR [Occ=Once!] :: Complex a_sgxDP) ->
                 case w1_sgxDR of { :+ ww1_sgxDU [Occ=Once] ww2_sgxDV [Occ=Once] ->
                 case Data.Complex.$w$cabs @ a_sgxDP w_sgxDQ ww1_sgxDU ww2_sgxDV of
                 { (# ww4_sgxRl [Occ=Once], ww5_sgxRm [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxDP ww4_sgxRl ww5_sgxRm
                 }
                 }}]
Data.Complex.$fNumComplex_$cabs
  = \ (@ a_sgxDP)
      (w_sgxDQ :: RealFloat a_sgxDP)
      (w1_sgxDR :: Complex a_sgxDP) ->
      case w1_sgxDR of { :+ ww1_sgxDU ww2_sgxDV ->
      case Data.Complex.$w$cabs @ a_sgxDP w_sgxDQ ww1_sgxDU ww2_sgxDV of
      { (# ww4_sgxRl, ww5_sgxRm #) ->
      Data.Complex.:+ @ a_sgxDP ww4_sgxRl ww5_sgxRm
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cfromInteger
  :: Integer -> Complex Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_agspr [Occ=Once] :: Integer) ->
                 case integer-simple-0.1.1.1:GHC.Integer.Type.doubleFromInteger
                        n_agspr
                 of wild_igo1s
                 { __DEFAULT ->
                 Data.Complex.:+
                   @ Double (GHC.Types.D# wild_igo1s) Data.Complex.$fFloatingComplex1
                 }}]
Data.Complex.$fFloatingComplex_$s$cfromInteger
  = \ (n_agspr :: Integer) ->
      case integer-simple-0.1.1.1:GHC.Integer.Type.doubleFromInteger
             n_agspr
      of wild_igo1s
      { __DEFAULT ->
      Data.Complex.:+
        @ Double (GHC.Types.D# wild_igo1s) Data.Complex.$fFloatingComplex1
      }

-- RHS size: {terms: 25, types: 22, coercions: 0, joins: 0/3}
Data.Complex.$w$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Integer -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 170 30}]
Data.Complex.$w$cfromInteger
  = \ (@ a_sgxE1)
      (w_sgxE2 :: RealFloat a_sgxE1)
      (w1_sgxE3 :: Integer) ->
      let {
        $dRealFrac_sguk1 [Dmd=<S(S(S(LLLLLLC(S))LL)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxE1
        [LclId]
        $dRealFrac_sguk1 = GHC.Float.$p1RealFloat @ a_sgxE1 w_sgxE2 } in
      let {
        $dReal_sguk0 [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
          :: Real a_sgxE1
        [LclId]
        $dReal_sguk0 = GHC.Real.$p1RealFrac @ a_sgxE1 $dRealFrac_sguk1 } in
      let {
        $dNum_sgujZ [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
          :: Num a_sgxE1
        [LclId]
        $dNum_sgujZ = GHC.Real.$p1Real @ a_sgxE1 $dReal_sguk0 } in
      case fromInteger @ a_sgxE1 $dNum_sgujZ w1_sgxE3 of dt_XgsQ7
      { __DEFAULT ->
      case fromInteger
             @ a_sgxE1 $dNum_sgujZ Data.Complex.$fFloatingComplex17
      of dt1_XgsQf
      { __DEFAULT ->
      (# dt_XgsQ7, dt1_XgsQf #)
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Integer -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)LLLLLL)LLLLLLLLLLLLLLL),1*U(1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxE1)
                 (w_sgxE2 [Occ=Once] :: RealFloat a_sgxE1)
                 (w1_sgxE3 [Occ=Once] :: Integer) ->
                 case Data.Complex.$w$cfromInteger @ a_sgxE1 w_sgxE2 w1_sgxE3 of
                 { (# ww1_sgxRo [Occ=Once], ww2_sgxRp [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxE1 ww1_sgxRo ww2_sgxRp
                 }}]
Data.Complex.$fFloatingComplex_$cfromInteger
  = \ (@ a_sgxE1)
      (w_sgxE2 :: RealFloat a_sgxE1)
      (w1_sgxE3 :: Integer) ->
      case Data.Complex.$w$cfromInteger @ a_sgxE1 w_sgxE2 w1_sgxE3 of
      { (# ww1_sgxRo, ww2_sgxRp #) ->
      Data.Complex.:+ @ a_sgxE1 ww1_sgxRo ww2_sgxRp
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex4 :: Complex Double
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fFloatingComplex4
  = Data.Complex.:+
      @ Double
      Data.Complex.$fFloatingComplex1
      Data.Complex.$fFloatingComplex1

-- RHS size: {terms: 63, types: 20, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$csignum [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxE8 [Occ=Once!] :: Complex Double) ->
                 case w_sgxE8 of { :+ ww1_sgxEb [Occ=Once!] ww2_sgxEg [Occ=Once!] ->
                 case ww1_sgxEb of { GHC.Types.D# ww4_sgxEe ->
                 case ww2_sgxEg of { GHC.Types.D# ww6_sgxEj ->
                 case GHC.Prim.==## ww4_sgxEe 0.0## of {
                   __DEFAULT ->
                     case Data.Complex.$w$smagnitude ww4_sgxEe ww6_sgxEj of ww7_sgxxX
                     { __DEFAULT ->
                     case GHC.Prim./## ww4_sgxEe ww7_sgxxX of wild2_igtAA { __DEFAULT ->
                     case GHC.Prim./## ww6_sgxEj ww7_sgxxX of wild1_XgtQC { __DEFAULT ->
                     Data.Complex.:+
                       @ Double (GHC.Types.D# wild2_igtAA) (GHC.Types.D# wild1_XgtQC)
                     }
                     }
                     };
                   1# ->
                     case GHC.Prim.==## ww6_sgxEj 0.0## of {
                       __DEFAULT ->
                         case Data.Complex.$w$smagnitude ww4_sgxEe ww6_sgxEj of ww7_sgxxX
                         { __DEFAULT ->
                         case GHC.Prim./## ww4_sgxEe ww7_sgxxX of wild2_igtAA { __DEFAULT ->
                         case GHC.Prim./## ww6_sgxEj ww7_sgxxX of wild1_XgtQC { __DEFAULT ->
                         Data.Complex.:+
                           @ Double (GHC.Types.D# wild2_igtAA) (GHC.Types.D# wild1_XgtQC)
                         }
                         }
                         };
                       1# ->
                         Data.Complex.:+
                           @ Double
                           Data.Complex.$fFloatingComplex1
                           Data.Complex.$fFloatingComplex1
                     }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$csignum
  = \ (w_sgxE8 :: Complex Double) ->
      case w_sgxE8 of { :+ ww1_sgxEb ww2_sgxEg ->
      case ww1_sgxEb of { GHC.Types.D# ww4_sgzhZ ->
      case ww2_sgxEg of { GHC.Types.D# ww6_sgzi2 ->
      case GHC.Prim.==## ww4_sgzhZ 0.0## of {
        __DEFAULT ->
          case Data.Complex.$w$smagnitude ww4_sgzhZ ww6_sgzi2 of ww7_sgxxX
          { __DEFAULT ->
          case GHC.Prim./## ww4_sgzhZ ww7_sgxxX of wild2_igtAA { __DEFAULT ->
          case GHC.Prim./## ww6_sgzi2 ww7_sgxxX of wild1_XgtQC { __DEFAULT ->
          Data.Complex.:+
            @ Double (GHC.Types.D# wild2_igtAA) (GHC.Types.D# wild1_XgtQC)
          }
          }
          };
        1# ->
          case GHC.Prim.==## ww6_sgzi2 0.0## of {
            __DEFAULT ->
              case Data.Complex.$w$smagnitude ww4_sgzhZ ww6_sgzi2 of ww7_sgxxX
              { __DEFAULT ->
              case GHC.Prim./## ww4_sgzhZ ww7_sgxxX of wild2_igtAA { __DEFAULT ->
              case GHC.Prim./## ww6_sgzi2 ww7_sgxxX of wild1_XgtQC { __DEFAULT ->
              Data.Complex.:+
                @ Double (GHC.Types.D# wild2_igtAA) (GHC.Types.D# wild1_XgtQC)
              }
              }
              };
            1# -> Data.Complex.$fFloatingComplex4
          }
      }
      }
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex12 :: Complex Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fFloatingComplex12
  = Data.Complex.:+
      @ Float
      Data.Complex.$fFloatingComplex9
      Data.Complex.$fFloatingComplex9

-- RHS size: {terms: 63, types: 20, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$csignum1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxEq [Occ=Once!] :: Complex Float) ->
                 case w_sgxEq of { :+ ww1_sgxEt [Occ=Once!] ww2_sgxEy [Occ=Once!] ->
                 case ww1_sgxEt of { GHC.Types.F# ww4_sgxEw ->
                 case ww2_sgxEy of { GHC.Types.F# ww6_sgxEB ->
                 case GHC.Prim.eqFloat# ww4_sgxEw 0.0# of {
                   __DEFAULT ->
                     case Data.Complex.$w$smagnitude1 ww4_sgxEw ww6_sgxEB of ww7_sgxyg
                     { __DEFAULT ->
                     case GHC.Prim.divideFloat# ww4_sgxEw ww7_sgxyg of wild2_igtwv
                     { __DEFAULT ->
                     case GHC.Prim.divideFloat# ww6_sgxEB ww7_sgxyg of wild1_XgtMF
                     { __DEFAULT ->
                     Data.Complex.:+
                       @ Float (GHC.Types.F# wild2_igtwv) (GHC.Types.F# wild1_XgtMF)
                     }
                     }
                     };
                   1# ->
                     case GHC.Prim.eqFloat# ww6_sgxEB 0.0# of {
                       __DEFAULT ->
                         case Data.Complex.$w$smagnitude1 ww4_sgxEw ww6_sgxEB of ww7_sgxyg
                         { __DEFAULT ->
                         case GHC.Prim.divideFloat# ww4_sgxEw ww7_sgxyg of wild2_igtwv
                         { __DEFAULT ->
                         case GHC.Prim.divideFloat# ww6_sgxEB ww7_sgxyg of wild1_XgtMF
                         { __DEFAULT ->
                         Data.Complex.:+
                           @ Float (GHC.Types.F# wild2_igtwv) (GHC.Types.F# wild1_XgtMF)
                         }
                         }
                         };
                       1# ->
                         Data.Complex.:+
                           @ Float
                           Data.Complex.$fFloatingComplex9
                           Data.Complex.$fFloatingComplex9
                     }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$csignum1
  = \ (w_sgxEq :: Complex Float) ->
      case w_sgxEq of { :+ ww1_sgxEt ww2_sgxEy ->
      case ww1_sgxEt of { GHC.Types.F# ww4_sgzi6 ->
      case ww2_sgxEy of { GHC.Types.F# ww6_sgzi9 ->
      case GHC.Prim.eqFloat# ww4_sgzi6 0.0# of {
        __DEFAULT ->
          case Data.Complex.$w$smagnitude1 ww4_sgzi6 ww6_sgzi9 of ww7_sgxyg
          { __DEFAULT ->
          case GHC.Prim.divideFloat# ww4_sgzi6 ww7_sgxyg of wild2_igtwv
          { __DEFAULT ->
          case GHC.Prim.divideFloat# ww6_sgzi9 ww7_sgxyg of wild1_XgtMF
          { __DEFAULT ->
          Data.Complex.:+
            @ Float (GHC.Types.F# wild2_igtwv) (GHC.Types.F# wild1_XgtMF)
          }
          }
          };
        1# ->
          case GHC.Prim.eqFloat# ww6_sgzi9 0.0# of {
            __DEFAULT ->
              case Data.Complex.$w$smagnitude1 ww4_sgzi6 ww6_sgzi9 of ww7_sgxyg
              { __DEFAULT ->
              case GHC.Prim.divideFloat# ww4_sgzi6 ww7_sgxyg of wild2_igtwv
              { __DEFAULT ->
              case GHC.Prim.divideFloat# ww6_sgzi9 ww7_sgxyg of wild1_XgtMF
              { __DEFAULT ->
              Data.Complex.:+
                @ Float (GHC.Types.F# wild2_igtwv) (GHC.Types.F# wild1_XgtMF)
              }
              }
              };
            1# -> Data.Complex.$fFloatingComplex12
          }
      }
      }
      }
      }

-- RHS size: {terms: 69, types: 48, coercions: 0, joins: 1/8}
Data.Complex.$w$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 548 0}]
Data.Complex.$w$csignum
  = \ (@ a_sgxEJ)
      (w_sgxEK :: RealFloat a_sgxEJ)
      (ww_sgxEO
         :: a_sgxEJ
         Unf=OtherCon [])
      (ww1_sgxEP
         :: a_sgxEJ
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sgujL [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
          :: RealFrac a_sgxEJ
        [LclId]
        $dRealFrac_sgujL = GHC.Float.$p1RealFloat @ a_sgxEJ w_sgxEK } in
      let {
        $dReal_sgujK [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
          :: Real a_sgxEJ
        [LclId]
        $dReal_sgujK = GHC.Real.$p1RealFrac @ a_sgxEJ $dRealFrac_sgujL } in
      let {
        $dNum_sgujJ [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: Num a_sgxEJ
        [LclId]
        $dNum_sgujJ = GHC.Real.$p1Real @ a_sgxEJ $dReal_sgujK } in
      let {
        $dOrd_sgujI [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
          :: Ord a_sgxEJ
        [LclId]
        $dOrd_sgujI = GHC.Real.$p2Real @ a_sgxEJ $dReal_sgujK } in
      let {
        $dEq_sgujH [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq a_sgxEJ
        [LclId]
        $dEq_sgujH = GHC.Classes.$p1Ord @ a_sgxEJ $dOrd_sgujI } in
      join {
        fail_sgujF [Dmd=<L,1*C1(U(U,U))>]
          :: GHC.Prim.Void# -> (# a_sgxEJ, a_sgxEJ #)
        [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
        fail_sgujF _ [Occ=Dead, OS=OneShot]
          = let {
              $dFractional_sgujG [Dmd=<S(LC(C(S))LL),U(A,C(C1(U)),A,A)>]
                :: Fractional a_sgxEJ
              [LclId]
              $dFractional_sgujG
                = GHC.Real.$p2RealFrac @ a_sgxEJ $dRealFrac_sgujL } in
            let {
              r_sgujN :: a_sgxEJ
              [LclId]
              r_sgujN
                = Data.Complex.$wmagnitude
                    @ a_sgxEJ w_sgxEK ww_sgxEO ww1_sgxEP } in
            case / @ a_sgxEJ $dFractional_sgujG ww_sgxEO r_sgujN of dt_XgsGq
            { __DEFAULT ->
            case / @ a_sgxEJ $dFractional_sgujG ww1_sgxEP r_sgujN of dt1_XgsGv
            { __DEFAULT ->
            (# dt_XgsGq, dt1_XgsGv #)
            }
            } } in
      case ==
             @ a_sgxEJ
             $dEq_sgujH
             ww_sgxEO
             (fromInteger
                @ a_sgxEJ $dNum_sgujJ Data.Complex.$fFloatingComplex17)
      of {
        False -> jump fail_sgujF GHC.Prim.void#;
        True ->
          case ==
                 @ a_sgxEJ
                 $dEq_sgujH
                 ww1_sgxEP
                 (fromInteger
                    @ a_sgxEJ $dNum_sgujJ Data.Complex.$fFloatingComplex17)
          of {
            False -> jump fail_sgujF GHC.Prim.void#;
            True ->
              Data.Complex.$w$cfromInteger
                @ a_sgxEJ w_sgxEK Data.Complex.$fFloatingComplex17
          }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fNumComplex_$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxEJ)
                 (w_sgxEK [Occ=Once] :: RealFloat a_sgxEJ)
                 (w1_sgxEL [Occ=Once!] :: Complex a_sgxEJ) ->
                 case w1_sgxEL of { :+ ww1_sgxEO [Occ=Once] ww2_sgxEP [Occ=Once] ->
                 case Data.Complex.$w$csignum @ a_sgxEJ w_sgxEK ww1_sgxEO ww2_sgxEP
                 of
                 { (# ww4_sgxRx [Occ=Once], ww5_sgxRy [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxEJ ww4_sgxRx ww5_sgxRy
                 }
                 }}]
Data.Complex.$fNumComplex_$csignum
  = \ (@ a_sgxEJ)
      (w_sgxEK :: RealFloat a_sgxEJ)
      (w1_sgxEL :: Complex a_sgxEJ) ->
      case w1_sgxEL of { :+ ww1_sgxEO ww2_sgxEP ->
      case Data.Complex.$w$csignum @ a_sgxEJ w_sgxEK ww1_sgxEO ww2_sgxEP
      of
      { (# ww4_sgxRx, ww5_sgxRy #) ->
      Data.Complex.:+ @ a_sgxEJ ww4_sgxRx ww5_sgxRy
      }
      }

-- RHS size: {terms: 8, types: 2, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$fNumComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Num (Complex Double)
[GblId,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Complex Double
                     Data.Complex.$fFloatingComplex_$s$c+
                     Data.Complex.$fFloatingComplex_$s$c-
                     Data.Complex.$fFloatingComplex_$s$c*
                     Data.Complex.$fFloatingComplex_$s$cnegate
                     Data.Complex.$fFloatingComplex_$s$cabs
                     Data.Complex.$fFloatingComplex_$s$csignum
                     Data.Complex.$fFloatingComplex_$s$cfromInteger]
Data.Complex.$fFloatingComplex_$s$fNumComplex
  = GHC.Num.C:Num
      @ (Complex Double)
      Data.Complex.$fFloatingComplex_$s$c+
      Data.Complex.$fFloatingComplex_$s$c-
      Data.Complex.$fFloatingComplex_$s$c*
      Data.Complex.$fFloatingComplex_$s$cnegate
      Data.Complex.$fFloatingComplex_$s$cabs
      Data.Complex.$fFloatingComplex_$s$csignum
      Data.Complex.$fFloatingComplex_$s$cfromInteger

-- RHS size: {terms: 8, types: 2, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$fNumComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Num (Complex Float)
[GblId,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Complex Float
                     Data.Complex.$fFloatingComplex_$s$c+1
                     Data.Complex.$fFloatingComplex_$s$c-1
                     Data.Complex.$fFloatingComplex_$s$c*1
                     Data.Complex.$fFloatingComplex_$s$cnegate1
                     Data.Complex.$fFloatingComplex_$s$cabs1
                     Data.Complex.$fFloatingComplex_$s$csignum1
                     Data.Complex.$fFloatingComplex_$s$cfromInteger1]
Data.Complex.$fFloatingComplex_$s$fNumComplex1
  = GHC.Num.C:Num
      @ (Complex Float)
      Data.Complex.$fFloatingComplex_$s$c+1
      Data.Complex.$fFloatingComplex_$s$c-1
      Data.Complex.$fFloatingComplex_$s$c*1
      Data.Complex.$fFloatingComplex_$s$cnegate1
      Data.Complex.$fFloatingComplex_$s$cabs1
      Data.Complex.$fFloatingComplex_$s$csignum1
      Data.Complex.$fFloatingComplex_$s$cfromInteger1

-- RHS size: {terms: 17, types: 13, coercions: 0, joins: 0/0}
Data.Complex.$fNumComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. RealFloat a => Num (Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_agsp7) (v_X7k :: RealFloat a_agsp7) ->
       GHC.Num.C:Num TYPE: Complex a_agsp7
                     Data.Complex.$fFloatingComplex_$c+ @ a_agsp7 v_X7k
                     Data.Complex.$fFloatingComplex_$c- @ a_agsp7 v_X7k
                     Data.Complex.$fNumComplex_$c* @ a_agsp7 v_X7k
                     Data.Complex.$fFloatingComplex_$cnegate @ a_agsp7 v_X7k
                     Data.Complex.$fNumComplex_$cabs @ a_agsp7 v_X7k
                     Data.Complex.$fNumComplex_$csignum @ a_agsp7 v_X7k
                     Data.Complex.$fFloatingComplex_$cfromInteger @ a_agsp7 v_X7k]
Data.Complex.$fNumComplex
  = \ (@ a_agt1x) ($dRealFloat_agt1y :: RealFloat a_agt1x) ->
      GHC.Num.C:Num
        @ (Complex a_agt1x)
        (Data.Complex.$fFloatingComplex_$c+ @ a_agt1x $dRealFloat_agt1y)
        (Data.Complex.$fFloatingComplex_$c- @ a_agt1x $dRealFloat_agt1y)
        (Data.Complex.$fNumComplex_$c* @ a_agt1x $dRealFloat_agt1y)
        (Data.Complex.$fFloatingComplex_$cnegate
           @ a_agt1x $dRealFloat_agt1y)
        (Data.Complex.$fNumComplex_$cabs @ a_agt1x $dRealFloat_agt1y)
        (Data.Complex.$fNumComplex_$csignum @ a_agt1x $dRealFloat_agt1y)
        (Data.Complex.$fFloatingComplex_$cfromInteger
           @ a_agt1x $dRealFloat_agt1y)

-- RHS size: {terms: 113, types: 41, coercions: 0, joins: 1/3}
Data.Complex.$w$s$csqrt1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> (# Float, Float #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 298 30}]
Data.Complex.$w$s$csqrt1
  = \ (ww_sgxF2 :: GHC.Prim.Float#) (ww1_sgxF7 :: GHC.Prim.Float#) ->
      join {
        fail_sgujr [Dmd=<L,1*C1(U(U,U))>]
          :: GHC.Prim.Void# -> (# Float, Float #)
        [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
        fail_sgujr _ [Occ=Dead, OS=OneShot]
          = case GHC.Prim.ltFloat# ww_sgxF2 0.0# of {
              __DEFAULT ->
                case Data.Complex.$w$smagnitude1 ww_sgxF2 ww1_sgxF7 of ww2_sgxyg
                { __DEFAULT ->
                let {
                  ipv_sguKI [Dmd=<S,U>] :: GHC.Prim.Float#
                  [LclId]
                  ipv_sguKI
                    = GHC.Prim.sqrtFloat#
                        (GHC.Prim.divideFloat#
                           (GHC.Prim.plusFloat# ww2_sgxyg (GHC.Prim.fabsFloat# ww_sgxF2))
                           2.0#) } in
                case GHC.Prim.ltFloat# ww1_sgxF7 0.0# of {
                  __DEFAULT ->
                    case GHC.Prim.divideFloat#
                           (GHC.Prim.fabsFloat# ww1_sgxF7)
                           (GHC.Prim.plusFloat# ipv_sguKI ipv_sguKI)
                    of wild2_igtwv
                    { __DEFAULT ->
                    (# GHC.Types.F# ipv_sguKI, GHC.Types.F# wild2_igtwv #)
                    };
                  1# ->
                    case GHC.Prim.divideFloat#
                           (GHC.Prim.fabsFloat# ww1_sgxF7)
                           (GHC.Prim.plusFloat# ipv_sguKI ipv_sguKI)
                    of wild2_igtwv
                    { __DEFAULT ->
                    (# GHC.Types.F# ipv_sguKI,
                       GHC.Types.F# (GHC.Prim.negateFloat# wild2_igtwv) #)
                    }
                }
                };
              1# ->
                case Data.Complex.$w$smagnitude1 ww_sgxF2 ww1_sgxF7 of ww2_sgxyg
                { __DEFAULT ->
                let {
                  x_igtuu [Dmd=<S,U>] :: GHC.Prim.Float#
                  [LclId]
                  x_igtuu
                    = GHC.Prim.sqrtFloat#
                        (GHC.Prim.divideFloat#
                           (GHC.Prim.plusFloat# ww2_sgxyg (GHC.Prim.fabsFloat# ww_sgxF2))
                           2.0#) } in
                case GHC.Prim.divideFloat#
                       (GHC.Prim.fabsFloat# ww1_sgxF7)
                       (GHC.Prim.plusFloat# x_igtuu x_igtuu)
                of wild2_igtwv
                { __DEFAULT ->
                case GHC.Prim.ltFloat# ww1_sgxF7 0.0# of {
                  __DEFAULT -> (# GHC.Types.F# wild2_igtwv, GHC.Types.F# x_igtuu #);
                  1# ->
                    (# GHC.Types.F# wild2_igtwv,
                       GHC.Types.F# (GHC.Prim.negateFloat# x_igtuu) #)
                }
                }
                }
            } } in
      case GHC.Prim.eqFloat# ww_sgxF2 0.0# of {
        __DEFAULT -> jump fail_sgujr GHC.Prim.void#;
        1# ->
          case GHC.Prim.eqFloat# ww1_sgxF7 0.0# of {
            __DEFAULT -> jump fail_sgujr GHC.Prim.void#;
            1# ->
              (# Data.Complex.$fFloatingComplex9,
                 Data.Complex.$fFloatingComplex9 #)
          }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$csqrt1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxEW [Occ=Once!] :: Complex Float) ->
                 case w_sgxEW of { :+ ww1_sgxEZ [Occ=Once!] ww2_sgxF4 [Occ=Once!] ->
                 case ww1_sgxEZ of { GHC.Types.F# ww4_sgxF2 [Occ=Once] ->
                 case ww2_sgxF4 of { GHC.Types.F# ww6_sgxF7 [Occ=Once] ->
                 case Data.Complex.$w$s$csqrt1 ww4_sgxF2 ww6_sgxF7 of
                 { (# ww8_sgxRA [Occ=Once], ww9_sgxRB [Occ=Once] #) ->
                 Data.Complex.:+ @ Float ww8_sgxRA ww9_sgxRB
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$csqrt1
  = \ (w_sgxEW :: Complex Float) ->
      case w_sgxEW of { :+ ww1_sgxEZ ww2_sgxF4 ->
      case ww1_sgxEZ of { GHC.Types.F# ww4_sgzid ->
      case ww2_sgxF4 of { GHC.Types.F# ww6_sgzig ->
      case Data.Complex.$w$s$csqrt1 ww4_sgzid ww6_sgzig of
      { (# ww8_sgxRA, ww9_sgxRB #) ->
      Data.Complex.:+ @ Float ww8_sgxRA ww9_sgxRB
      }
      }
      }
      }

-- RHS size: {terms: 113, types: 41, coercions: 0, joins: 1/3}
Data.Complex.$w$s$csqrt [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> (# Double, Double #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 298 30}]
Data.Complex.$w$s$csqrt
  = \ (ww_sgxFl :: GHC.Prim.Double#)
      (ww1_sgxFq :: GHC.Prim.Double#) ->
      join {
        fail_sgujj [Dmd=<L,1*C1(U(U,U))>]
          :: GHC.Prim.Void# -> (# Double, Double #)
        [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
        fail_sgujj _ [Occ=Dead, OS=OneShot]
          = case GHC.Prim.<## ww_sgxFl 0.0## of {
              __DEFAULT ->
                case Data.Complex.$w$smagnitude ww_sgxFl ww1_sgxFq of ww2_sgxxX
                { __DEFAULT ->
                let {
                  ipv_sguL7 [Dmd=<S,U>] :: GHC.Prim.Double#
                  [LclId]
                  ipv_sguL7
                    = GHC.Prim.sqrtDouble#
                        (GHC.Prim./##
                           (GHC.Prim.+## ww2_sgxxX (GHC.Prim.fabsDouble# ww_sgxFl))
                           2.0##) } in
                case GHC.Prim.<## ww1_sgxFq 0.0## of {
                  __DEFAULT ->
                    case GHC.Prim./##
                           (GHC.Prim.fabsDouble# ww1_sgxFq) (GHC.Prim.+## ipv_sguL7 ipv_sguL7)
                    of wild2_igtAA
                    { __DEFAULT ->
                    (# GHC.Types.D# ipv_sguL7, GHC.Types.D# wild2_igtAA #)
                    };
                  1# ->
                    case GHC.Prim./##
                           (GHC.Prim.fabsDouble# ww1_sgxFq) (GHC.Prim.+## ipv_sguL7 ipv_sguL7)
                    of wild2_igtAA
                    { __DEFAULT ->
                    (# GHC.Types.D# ipv_sguL7,
                       GHC.Types.D# (GHC.Prim.negateDouble# wild2_igtAA) #)
                    }
                }
                };
              1# ->
                case Data.Complex.$w$smagnitude ww_sgxFl ww1_sgxFq of ww2_sgxxX
                { __DEFAULT ->
                let {
                  x_igtxN [Dmd=<S,U>] :: GHC.Prim.Double#
                  [LclId]
                  x_igtxN
                    = GHC.Prim.sqrtDouble#
                        (GHC.Prim./##
                           (GHC.Prim.+## ww2_sgxxX (GHC.Prim.fabsDouble# ww_sgxFl))
                           2.0##) } in
                case GHC.Prim./##
                       (GHC.Prim.fabsDouble# ww1_sgxFq) (GHC.Prim.+## x_igtxN x_igtxN)
                of wild2_igtAA
                { __DEFAULT ->
                case GHC.Prim.<## ww1_sgxFq 0.0## of {
                  __DEFAULT -> (# GHC.Types.D# wild2_igtAA, GHC.Types.D# x_igtxN #);
                  1# ->
                    (# GHC.Types.D# wild2_igtAA,
                       GHC.Types.D# (GHC.Prim.negateDouble# x_igtxN) #)
                }
                }
                }
            } } in
      case GHC.Prim.==## ww_sgxFl 0.0## of {
        __DEFAULT -> jump fail_sgujj GHC.Prim.void#;
        1# ->
          case GHC.Prim.==## ww1_sgxFq 0.0## of {
            __DEFAULT -> jump fail_sgujj GHC.Prim.void#;
            1# ->
              (# Data.Complex.$fFloatingComplex1,
                 Data.Complex.$fFloatingComplex1 #)
          }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$csqrt [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxFf [Occ=Once!] :: Complex Double) ->
                 case w_sgxFf of { :+ ww1_sgxFi [Occ=Once!] ww2_sgxFn [Occ=Once!] ->
                 case ww1_sgxFi of { GHC.Types.D# ww4_sgxFl [Occ=Once] ->
                 case ww2_sgxFn of { GHC.Types.D# ww6_sgxFq [Occ=Once] ->
                 case Data.Complex.$w$s$csqrt ww4_sgxFl ww6_sgxFq of
                 { (# ww8_sgxRD [Occ=Once], ww9_sgxRE [Occ=Once] #) ->
                 Data.Complex.:+ @ Double ww8_sgxRD ww9_sgxRE
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$csqrt
  = \ (w_sgxFf :: Complex Double) ->
      case w_sgxFf of { :+ ww1_sgxFi ww2_sgxFn ->
      case ww1_sgxFi of { GHC.Types.D# ww4_sgzij ->
      case ww2_sgxFn of { GHC.Types.D# ww6_sgzim ->
      case Data.Complex.$w$s$csqrt ww4_sgzij ww6_sgzim of
      { (# ww8_sgxRD, ww9_sgxRE #) ->
      Data.Complex.:+ @ Double ww8_sgxRD ww9_sgxRE
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex21 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Complex.$fFloatingComplex21 = 2

-- RHS size: {terms: 123, types: 78, coercions: 0, joins: 2/10}
Data.Complex.$w$csqrt [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []]
Data.Complex.$w$csqrt
  = \ (@ a_sgxFA)
      (w_sgxFB :: RealFloat a_sgxFA)
      (ww_sgxFF
         :: a_sgxFA
         Unf=OtherCon [])
      (ww1_sgxFG
         :: a_sgxFA
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sgujb [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
          :: RealFrac a_sgxFA
        [LclId]
        $dRealFrac_sgujb = GHC.Float.$p1RealFloat @ a_sgxFA w_sgxFB } in
      let {
        $dReal_sguja [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A)>]
          :: Real a_sgxFA
        [LclId]
        $dReal_sguja = GHC.Real.$p1RealFrac @ a_sgxFA $dRealFrac_sgujb } in
      let {
        $dOrd_sguj8 [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)>]
          :: Ord a_sgxFA
        [LclId]
        $dOrd_sguj8 = GHC.Real.$p2Real @ a_sgxFA $dReal_sguja } in
      let {
        $dNum_sguj9 [Dmd=<L,U(1*C1(C1(U)),A,1*C1(C1(U)),1*C1(U),C(U),A,C(U))>]
          :: Num a_sgxFA
        [LclId]
        $dNum_sguj9 = GHC.Real.$p1Real @ a_sgxFA $dReal_sguja } in
      let {
        $dEq_sguj7 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq a_sgxFA
        [LclId]
        $dEq_sguj7 = GHC.Classes.$p1Ord @ a_sgxFA $dOrd_sguj8 } in
      join {
        fail_sguj5 [Dmd=<L,1*C1(U(U,U))>]
          :: GHC.Prim.Void# -> (# a_sgxFA, a_sgxFA #)
        [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
        fail_sguj5 _ [Occ=Dead, OS=OneShot]
          = let {
              $dFractional_sguj6 [Dmd=<L,U(A,C(C1(U)),A,A)>]
                :: Fractional a_sgxFA
              [LclId]
              $dFractional_sguj6
                = GHC.Real.$p2RealFrac @ a_sgxFA $dRealFrac_sgujb } in
            let {
              u'_sgujh :: a_sgxFA
              [LclId]
              u'_sgujh
                = sqrt
                    @ a_sgxFA
                    (GHC.Float.$p2RealFloat @ a_sgxFA w_sgxFB)
                    (/ @ a_sgxFA
                       $dFractional_sguj6
                       (+ @ a_sgxFA
                          $dNum_sguj9
                          (Data.Complex.$wmagnitude @ a_sgxFA w_sgxFB ww_sgxFF ww1_sgxFG)
                          (abs @ a_sgxFA $dNum_sguj9 ww_sgxFF))
                       (fromInteger
                          @ a_sgxFA $dNum_sguj9 Data.Complex.$fFloatingComplex21)) } in
            let {
              v'_sgujg :: a_sgxFA
              [LclId]
              v'_sgujg
                = / @ a_sgxFA
                    $dFractional_sguj6
                    (abs @ a_sgxFA $dNum_sguj9 ww1_sgxFG)
                    (* @ a_sgxFA
                       $dNum_sguj9
                       u'_sgujh
                       (fromInteger
                          @ a_sgxFA $dNum_sguj9 Data.Complex.$fFloatingComplex21)) } in
            join {
              $j_sgv2S [Dmd=<C(C(S)),1*C1(C1(U(U,U)))>]
                :: a_sgxFA -> a_sgxFA -> (# a_sgxFA, a_sgxFA #)
              [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
              $j_sgv2S (u_agsPQ [OS=OneShot] :: a_sgxFA)
                       (v_agsPS [OS=OneShot] :: a_sgxFA)
                = case u_agsPQ of dt_XgsH3 { __DEFAULT ->
                  case < @ a_sgxFA
                         $dOrd_sguj8
                         ww1_sgxFG
                         (fromInteger
                            @ a_sgxFA $dNum_sguj9 Data.Complex.$fFloatingComplex17)
                  of {
                    False ->
                      case v_agsPS of dt1_XgsH8 { __DEFAULT ->
                      (# dt_XgsH3, dt1_XgsH8 #)
                      };
                    True ->
                      case negate @ a_sgxFA $dNum_sguj9 v_agsPS of dt1_XgsH8
                      { __DEFAULT ->
                      (# dt_XgsH3, dt1_XgsH8 #)
                      }
                  }
                  } } in
            case < @ a_sgxFA
                   $dOrd_sguj8
                   ww_sgxFF
                   (fromInteger
                      @ a_sgxFA $dNum_sguj9 Data.Complex.$fFloatingComplex17)
            of {
              False -> jump $j_sgv2S u'_sgujh v'_sgujg;
              True -> jump $j_sgv2S v'_sgujg u'_sgujh
            } } in
      case ==
             @ a_sgxFA
             $dEq_sguj7
             ww_sgxFF
             (fromInteger
                @ a_sgxFA $dNum_sguj9 Data.Complex.$fFloatingComplex17)
      of {
        False -> jump fail_sguj5 GHC.Prim.void#;
        True ->
          case ==
                 @ a_sgxFA
                 $dEq_sguj7
                 ww1_sgxFG
                 (fromInteger
                    @ a_sgxFA $dNum_sguj9 Data.Complex.$fFloatingComplex17)
          of {
            False -> jump fail_sguj5 GHC.Prim.void#;
            True ->
              Data.Complex.$w$cfromInteger
                @ a_sgxFA w_sgxFB Data.Complex.$fFloatingComplex17
          }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$csqrt [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxFA)
                 (w_sgxFB [Occ=Once] :: RealFloat a_sgxFA)
                 (w1_sgxFC [Occ=Once!] :: Complex a_sgxFA) ->
                 case w1_sgxFC of { :+ ww1_sgxFF [Occ=Once] ww2_sgxFG [Occ=Once] ->
                 case Data.Complex.$w$csqrt @ a_sgxFA w_sgxFB ww1_sgxFF ww2_sgxFG of
                 { (# ww4_sgxRG [Occ=Once], ww5_sgxRH [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxFA ww4_sgxRG ww5_sgxRH
                 }
                 }}]
Data.Complex.$fFloatingComplex_$csqrt
  = \ (@ a_sgxFA)
      (w_sgxFB :: RealFloat a_sgxFA)
      (w1_sgxFC :: Complex a_sgxFA) ->
      case w1_sgxFC of { :+ ww1_sgxFF ww2_sgxFG ->
      case Data.Complex.$w$csqrt @ a_sgxFA w_sgxFB ww1_sgxFF ww2_sgxFG of
      { (# ww4_sgxRG, ww5_sgxRH #) ->
      Data.Complex.:+ @ a_sgxFA ww4_sgxRG ww5_sgxRH
      }
      }

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$crecip [InlPrag=INLINE (sat-args=1)]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_igtoC [Occ=Once] :: Complex Double) ->
                 Data.Complex.$fFloatingComplex_$s$c/
                   (Data.Complex.:+
                      @ Double (GHC.Types.D# 1.0##) (GHC.Types.D# 0.0##))
                   x_igtoC}]
Data.Complex.$fFloatingComplex_$s$crecip
  = \ (eta_X7q :: Complex Double) ->
      case eta_X7q of { :+ ww1_sgxAz ww2_sgxAE ->
      case ww1_sgxAz of { GHC.Types.D# ww4_sgzip ->
      case ww2_sgxAE of { GHC.Types.D# ww6_sgzis ->
      case Data.Complex.$w$s$c/ 1.0## 0.0## ww4_sgzip ww6_sgzis of
      { (# ww8_sgxQR, ww9_sgxQS #) ->
      Data.Complex.:+ @ Double ww8_sgxQR ww9_sgxQS
      }
      }
      }
      }

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$crecip1 [InlPrag=INLINE (sat-args=1)]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_igtoC [Occ=Once] :: Complex Float) ->
                 Data.Complex.$fFloatingComplex_$s$c/1
                   (Data.Complex.:+ @ Float (GHC.Types.F# 1.0#) (GHC.Types.F# 0.0#))
                   x_igtoC}]
Data.Complex.$fFloatingComplex_$s$crecip1
  = \ (eta_X7q :: Complex Float) ->
      case eta_X7q of { :+ ww1_sgxv2 ww2_sgxv7 ->
      case ww1_sgxv2 of { GHC.Types.F# ww4_sgziv ->
      case ww2_sgxv7 of { GHC.Types.F# ww6_sgziy ->
      case Data.Complex.$w$s$c/1 1.0# 0.0# ww4_sgziv ww6_sgziy of
      { (# ww8_sgxQb, ww9_sgxQc #) ->
      Data.Complex.:+ @ Float ww8_sgxQb ww9_sgxQc
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex19 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Complex.$fFloatingComplex19 = 1

-- RHS size: {terms: 22, types: 27, coercions: 0, joins: 0/0}
Data.Complex.$fFractionalComplex_$crecip [InlPrag=INLINE (sat-args=1)]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLLLLLC(S))LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),A,A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_agsZS)
                 ($dRealFloat_agsZT :: RealFloat a_agsZS)
                 (x_igtoC [Occ=Once] :: Complex a_agsZS) ->
                 Data.Complex.$fFloatingComplex_$c/
                   @ a_agsZS
                   $dRealFloat_agsZT
                   (Data.Complex.$fFloatingComplex_$cfromInteger
                      @ a_agsZS $dRealFloat_agsZT 1)
                   x_igtoC}]
Data.Complex.$fFractionalComplex_$crecip
  = \ (@ a_agsZS)
      ($dRealFloat_agsZT :: RealFloat a_agsZS)
      (eta_X7q :: Complex a_agsZS) ->
      case Data.Complex.$w$cfromInteger
             @ a_agsZS $dRealFloat_agsZT Data.Complex.$fFloatingComplex19
      of
      { (# ww1_sgxRo, ww2_sgxRp #) ->
      case eta_X7q of { :+ ww4_sgxAZ ww5_sgxB0 ->
      case Data.Complex.$w$c/
             @ a_agsZS $dRealFloat_agsZT ww1_sgxRo ww2_sgxRp ww4_sgxAZ ww5_sgxB0
      of
      { (# ww7_sgxQU, ww8_sgxQV #) ->
      Data.Complex.:+ @ a_agsZS ww7_sgxQU ww8_sgxQV
      }
      }
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$fFractionalComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Fractional (Complex Double)
[GblId,
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Fractional TYPE: Complex Double
                             Data.Complex.$fFloatingComplex_$s$fNumComplex
                             Data.Complex.$fFloatingComplex_$s$c/
                             Data.Complex.$fFloatingComplex_$s$crecip
                             Data.Complex.$fFloatingComplex_$s$cfromRational]
Data.Complex.$fFloatingComplex_$s$fFractionalComplex
  = GHC.Real.C:Fractional
      @ (Complex Double)
      Data.Complex.$fFloatingComplex_$s$fNumComplex
      Data.Complex.$fFloatingComplex_$s$c/
      Data.Complex.$fFloatingComplex_$s$crecip
      Data.Complex.$fFloatingComplex_$s$cfromRational

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$fFractionalComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Fractional (Complex Float)
[GblId,
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Fractional TYPE: Complex Float
                             Data.Complex.$fFloatingComplex_$s$fNumComplex1
                             Data.Complex.$fFloatingComplex_$s$c/1
                             Data.Complex.$fFloatingComplex_$s$crecip1
                             Data.Complex.$fFloatingComplex_$s$cfromRational1]
Data.Complex.$fFloatingComplex_$s$fFractionalComplex1
  = GHC.Real.C:Fractional
      @ (Complex Float)
      Data.Complex.$fFloatingComplex_$s$fNumComplex1
      Data.Complex.$fFloatingComplex_$s$c/1
      Data.Complex.$fFloatingComplex_$s$crecip1
      Data.Complex.$fFloatingComplex_$s$cfromRational1

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
Data.Complex.$fFractionalComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. RealFloat a => Fractional (Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_agsoX) (v_X7v :: RealFloat a_agsoX) ->
       GHC.Real.C:Fractional TYPE: Complex a_agsoX
                             Data.Complex.$fNumComplex @ a_agsoX v_X7v
                             Data.Complex.$fFloatingComplex_$c/ @ a_agsoX v_X7v
                             Data.Complex.$fFractionalComplex_$crecip @ a_agsoX v_X7v
                             Data.Complex.$fFractionalComplex_$cfromRational @ a_agsoX v_X7v]
Data.Complex.$fFractionalComplex
  = \ (@ a_agsZS) ($dRealFloat_agsZT :: RealFloat a_agsZS) ->
      GHC.Real.C:Fractional
        @ (Complex a_agsZS)
        (Data.Complex.$fNumComplex @ a_agsZS $dRealFloat_agsZT)
        (Data.Complex.$fFloatingComplex_$c/ @ a_agsZS $dRealFloat_agsZT)
        (Data.Complex.$fFractionalComplex_$crecip
           @ a_agsZS $dRealFloat_agsZT)
        (Data.Complex.$fFractionalComplex_$cfromRational
           @ a_agsZS $dRealFloat_agsZT)

-- RHS size: {terms: 41, types: 22, coercions: 0, joins: 0/4}
Data.Complex.$fFloatingComplex_$s$ctan1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxFM [Occ=Once!] :: Complex Float) ->
                 case w_sgxFM of { :+ ww1_sgxFP [Occ=Once!] ww2_sgxFU [Occ=Once!] ->
                 case ww1_sgxFP of { GHC.Types.F# ww4_sgxFS ->
                 case ww2_sgxFU of { GHC.Types.F# ww6_sgxFX ->
                 let {
                   sinx_sguLu [Dmd=<S,U>] :: GHC.Prim.Float#
                   [LclId]
                   sinx_sguLu = GHC.Prim.sinFloat# ww4_sgxFS } in
                 let {
                   cosx_sguLt [Dmd=<S,U>] :: GHC.Prim.Float#
                   [LclId]
                   cosx_sguLt = GHC.Prim.cosFloat# ww4_sgxFS } in
                 let {
                   sinhy_sguLs [Dmd=<S,U>] :: GHC.Prim.Float#
                   [LclId]
                   sinhy_sguLs = GHC.Prim.sinhFloat# ww6_sgxFX } in
                 let {
                   coshy_sguLr [Dmd=<S,U>] :: GHC.Prim.Float#
                   [LclId]
                   coshy_sguLr = GHC.Prim.coshFloat# ww6_sgxFX } in
                 case Data.Complex.$w$s$c/1
                        (GHC.Prim.timesFloat# sinx_sguLu coshy_sguLr)
                        (GHC.Prim.timesFloat# cosx_sguLt sinhy_sguLs)
                        (GHC.Prim.timesFloat# cosx_sguLt coshy_sguLr)
                        (GHC.Prim.negateFloat#
                           (GHC.Prim.timesFloat# sinx_sguLu sinhy_sguLs))
                 of
                 { (# ww8_sgxRJ [Occ=Once], ww9_sgxRK [Occ=Once] #) ->
                 Data.Complex.:+ @ Float ww8_sgxRJ ww9_sgxRK
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$ctan1
  = \ (w_sgxFM :: Complex Float) ->
      case w_sgxFM of { :+ ww1_sgxFP ww2_sgxFU ->
      case ww1_sgxFP of { GHC.Types.F# ww4_sgziB ->
      case ww2_sgxFU of { GHC.Types.F# ww6_sgziE ->
      let {
        coshy_sguLr [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        coshy_sguLr = GHC.Prim.coshFloat# ww6_sgziE } in
      let {
        sinhy_sguLs [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        sinhy_sguLs = GHC.Prim.sinhFloat# ww6_sgziE } in
      let {
        cosx_sguLt [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        cosx_sguLt = GHC.Prim.cosFloat# ww4_sgziB } in
      let {
        sinx_sguLu [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        sinx_sguLu = GHC.Prim.sinFloat# ww4_sgziB } in
      case Data.Complex.$w$s$c/1
             (GHC.Prim.timesFloat# sinx_sguLu coshy_sguLr)
             (GHC.Prim.timesFloat# cosx_sguLt sinhy_sguLs)
             (GHC.Prim.timesFloat# cosx_sguLt coshy_sguLr)
             (GHC.Prim.negateFloat#
                (GHC.Prim.timesFloat# sinx_sguLu sinhy_sguLs))
      of
      { (# ww8_sgxRJ, ww9_sgxRK #) ->
      Data.Complex.:+ @ Float ww8_sgxRJ ww9_sgxRK
      }
      }
      }
      }

-- RHS size: {terms: 41, types: 22, coercions: 0, joins: 0/4}
Data.Complex.$fFloatingComplex_$s$ctan [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxG4 [Occ=Once!] :: Complex Double) ->
                 case w_sgxG4 of { :+ ww1_sgxG7 [Occ=Once!] ww2_sgxGc [Occ=Once!] ->
                 case ww1_sgxG7 of { GHC.Types.D# ww4_sgxGa ->
                 case ww2_sgxGc of { GHC.Types.D# ww6_sgxGf ->
                 let {
                   sinx_sguLF [Dmd=<S,U>] :: GHC.Prim.Double#
                   [LclId]
                   sinx_sguLF = GHC.Prim.sinDouble# ww4_sgxGa } in
                 let {
                   cosx_sguLE [Dmd=<S,U>] :: GHC.Prim.Double#
                   [LclId]
                   cosx_sguLE = GHC.Prim.cosDouble# ww4_sgxGa } in
                 let {
                   sinhy_sguLD [Dmd=<S,U>] :: GHC.Prim.Double#
                   [LclId]
                   sinhy_sguLD = GHC.Prim.sinhDouble# ww6_sgxGf } in
                 let {
                   coshy_sguLC [Dmd=<S,U>] :: GHC.Prim.Double#
                   [LclId]
                   coshy_sguLC = GHC.Prim.coshDouble# ww6_sgxGf } in
                 case Data.Complex.$w$s$c/
                        (GHC.Prim.*## sinx_sguLF coshy_sguLC)
                        (GHC.Prim.*## cosx_sguLE sinhy_sguLD)
                        (GHC.Prim.*## cosx_sguLE coshy_sguLC)
                        (GHC.Prim.negateDouble# (GHC.Prim.*## sinx_sguLF sinhy_sguLD))
                 of
                 { (# ww8_sgxRM [Occ=Once], ww9_sgxRN [Occ=Once] #) ->
                 Data.Complex.:+ @ Double ww8_sgxRM ww9_sgxRN
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$ctan
  = \ (w_sgxG4 :: Complex Double) ->
      case w_sgxG4 of { :+ ww1_sgxG7 ww2_sgxGc ->
      case ww1_sgxG7 of { GHC.Types.D# ww4_sgziH ->
      case ww2_sgxGc of { GHC.Types.D# ww6_sgziK ->
      let {
        coshy_sguLC [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        coshy_sguLC = GHC.Prim.coshDouble# ww6_sgziK } in
      let {
        sinhy_sguLD [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        sinhy_sguLD = GHC.Prim.sinhDouble# ww6_sgziK } in
      let {
        cosx_sguLE [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        cosx_sguLE = GHC.Prim.cosDouble# ww4_sgziH } in
      let {
        sinx_sguLF [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        sinx_sguLF = GHC.Prim.sinDouble# ww4_sgziH } in
      case Data.Complex.$w$s$c/
             (GHC.Prim.*## sinx_sguLF coshy_sguLC)
             (GHC.Prim.*## cosx_sguLE sinhy_sguLD)
             (GHC.Prim.*## cosx_sguLE coshy_sguLC)
             (GHC.Prim.negateDouble# (GHC.Prim.*## sinx_sguLF sinhy_sguLD))
      of
      { (# ww8_sgxRM, ww9_sgxRN #) ->
      Data.Complex.:+ @ Double ww8_sgxRM ww9_sgxRN
      }
      }
      }
      }

-- RHS size: {terms: 64, types: 36, coercions: 0, joins: 0/8}
Data.Complex.$w$ctan [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),1*C1(U),A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 570 0}]
Data.Complex.$w$ctan
  = \ (@ a_sgxGm)
      (w_sgxGn :: RealFloat a_sgxGm)
      (ww_sgxGr
         :: a_sgxGm
         Unf=OtherCon [])
      (ww1_sgxGs
         :: a_sgxGm
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sguiu [Dmd=<S(S(S(LLC(C(S))C(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxGm
        [LclId]
        $dRealFrac_sguiu = GHC.Float.$p1RealFloat @ a_sgxGm w_sgxGn } in
      let {
        $dReal_sguit [Dmd=<S(S(LLC(C(S))C(S)LLL)LL),1*U(1*U(A,A,C(C1(U)),1*C1(U),A,A,A),A,A)>]
          :: Real a_sgxGm
        [LclId]
        $dReal_sguit = GHC.Real.$p1RealFrac @ a_sgxGm $dRealFrac_sguiu } in
      let {
        $dNum_sguis [Dmd=<S(LLC(C(S))C(S)LLL),U(A,A,C(C1(U)),1*C1(U),A,A,A)>]
          :: Num a_sgxGm
        [LclId]
        $dNum_sguis = GHC.Real.$p1Real @ a_sgxGm $dReal_sguit } in
      let {
        $dFloating_sguiv [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
          :: Floating a_sgxGm
        [LclId]
        $dFloating_sguiv = GHC.Float.$p2RealFloat @ a_sgxGm w_sgxGn } in
      let {
        coshy_sguiD :: a_sgxGm
        [LclId]
        coshy_sguiD = cosh @ a_sgxGm $dFloating_sguiv ww1_sgxGs } in
      let {
        sinx_sguiA :: a_sgxGm
        [LclId]
        sinx_sguiA = sin @ a_sgxGm $dFloating_sguiv ww_sgxGr } in
      case * @ a_sgxGm $dNum_sguis sinx_sguiA coshy_sguiD of dt_XgsHu
      { __DEFAULT ->
      let {
        sinhy_sguiC :: a_sgxGm
        [LclId]
        sinhy_sguiC = sinh @ a_sgxGm $dFloating_sguiv ww1_sgxGs } in
      let {
        cosx_sguiB :: a_sgxGm
        [LclId]
        cosx_sguiB = cos @ a_sgxGm $dFloating_sguiv ww_sgxGr } in
      case * @ a_sgxGm $dNum_sguis cosx_sguiB sinhy_sguiC of dt1_XgsHz
      { __DEFAULT ->
      case * @ a_sgxGm $dNum_sguis cosx_sguiB coshy_sguiD of dt2_XgsUK
      { __DEFAULT ->
      case negate
             @ a_sgxGm
             $dNum_sguis
             (* @ a_sgxGm $dNum_sguis sinx_sguiA sinhy_sguiC)
      of dt3_XgsUS
      { __DEFAULT ->
      Data.Complex.$w$c/
        @ a_sgxGm w_sgxGn dt_XgsHu dt1_XgsHz dt2_XgsUK dt3_XgsUS
      }
      }
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$ctan [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxGm)
                 (w_sgxGn [Occ=Once] :: RealFloat a_sgxGm)
                 (w1_sgxGo [Occ=Once!] :: Complex a_sgxGm) ->
                 case w1_sgxGo of { :+ ww1_sgxGr [Occ=Once] ww2_sgxGs [Occ=Once] ->
                 case Data.Complex.$w$ctan @ a_sgxGm w_sgxGn ww1_sgxGr ww2_sgxGs of
                 { (# ww4_sgxRP [Occ=Once], ww5_sgxRQ [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxGm ww4_sgxRP ww5_sgxRQ
                 }
                 }}]
Data.Complex.$fFloatingComplex_$ctan
  = \ (@ a_sgxGm)
      (w_sgxGn :: RealFloat a_sgxGm)
      (w1_sgxGo :: Complex a_sgxGm) ->
      case w1_sgxGo of { :+ ww1_sgxGr ww2_sgxGs ->
      case Data.Complex.$w$ctan @ a_sgxGm w_sgxGn ww1_sgxGr ww2_sgxGs of
      { (# ww4_sgxRP, ww5_sgxRQ #) ->
      Data.Complex.:+ @ a_sgxGm ww4_sgxRP ww5_sgxRQ
      }
      }

-- RHS size: {terms: 40, types: 22, coercions: 0, joins: 0/4}
Data.Complex.$fFloatingComplex_$s$ctanh1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxGy [Occ=Once!] :: Complex Float) ->
                 case w_sgxGy of { :+ ww1_sgxGB [Occ=Once!] ww2_sgxGG [Occ=Once!] ->
                 case ww1_sgxGB of { GHC.Types.F# ww4_sgxGE ->
                 case ww2_sgxGG of { GHC.Types.F# ww6_sgxGJ ->
                 let {
                   siny_sguLR [Dmd=<S,U>] :: GHC.Prim.Float#
                   [LclId]
                   siny_sguLR = GHC.Prim.sinFloat# ww6_sgxGJ } in
                 let {
                   cosy_sguLQ [Dmd=<S,U>] :: GHC.Prim.Float#
                   [LclId]
                   cosy_sguLQ = GHC.Prim.cosFloat# ww6_sgxGJ } in
                 let {
                   sinhx_sguLP [Dmd=<S,U>] :: GHC.Prim.Float#
                   [LclId]
                   sinhx_sguLP = GHC.Prim.sinhFloat# ww4_sgxGE } in
                 let {
                   coshx_sguLO [Dmd=<S,U>] :: GHC.Prim.Float#
                   [LclId]
                   coshx_sguLO = GHC.Prim.coshFloat# ww4_sgxGE } in
                 case Data.Complex.$w$s$c/1
                        (GHC.Prim.timesFloat# cosy_sguLQ sinhx_sguLP)
                        (GHC.Prim.timesFloat# siny_sguLR coshx_sguLO)
                        (GHC.Prim.timesFloat# cosy_sguLQ coshx_sguLO)
                        (GHC.Prim.timesFloat# siny_sguLR sinhx_sguLP)
                 of
                 { (# ww8_sgxRS [Occ=Once], ww9_sgxRT [Occ=Once] #) ->
                 Data.Complex.:+ @ Float ww8_sgxRS ww9_sgxRT
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$ctanh1
  = \ (w_sgxGy :: Complex Float) ->
      case w_sgxGy of { :+ ww1_sgxGB ww2_sgxGG ->
      case ww1_sgxGB of { GHC.Types.F# ww4_sgziN ->
      case ww2_sgxGG of { GHC.Types.F# ww6_sgziQ ->
      let {
        coshx_sguLO [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        coshx_sguLO = GHC.Prim.coshFloat# ww4_sgziN } in
      let {
        sinhx_sguLP [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        sinhx_sguLP = GHC.Prim.sinhFloat# ww4_sgziN } in
      let {
        cosy_sguLQ [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        cosy_sguLQ = GHC.Prim.cosFloat# ww6_sgziQ } in
      let {
        siny_sguLR [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        siny_sguLR = GHC.Prim.sinFloat# ww6_sgziQ } in
      case Data.Complex.$w$s$c/1
             (GHC.Prim.timesFloat# cosy_sguLQ sinhx_sguLP)
             (GHC.Prim.timesFloat# siny_sguLR coshx_sguLO)
             (GHC.Prim.timesFloat# cosy_sguLQ coshx_sguLO)
             (GHC.Prim.timesFloat# siny_sguLR sinhx_sguLP)
      of
      { (# ww8_sgxRS, ww9_sgxRT #) ->
      Data.Complex.:+ @ Float ww8_sgxRS ww9_sgxRT
      }
      }
      }
      }

-- RHS size: {terms: 40, types: 22, coercions: 0, joins: 0/4}
Data.Complex.$fFloatingComplex_$s$ctanh [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxGQ [Occ=Once!] :: Complex Double) ->
                 case w_sgxGQ of { :+ ww1_sgxGT [Occ=Once!] ww2_sgxGY [Occ=Once!] ->
                 case ww1_sgxGT of { GHC.Types.D# ww4_sgxGW ->
                 case ww2_sgxGY of { GHC.Types.D# ww6_sgxH1 ->
                 let {
                   siny_sguM2 [Dmd=<S,U>] :: GHC.Prim.Double#
                   [LclId]
                   siny_sguM2 = GHC.Prim.sinDouble# ww6_sgxH1 } in
                 let {
                   cosy_sguM1 [Dmd=<S,U>] :: GHC.Prim.Double#
                   [LclId]
                   cosy_sguM1 = GHC.Prim.cosDouble# ww6_sgxH1 } in
                 let {
                   sinhx_sguM0 [Dmd=<S,U>] :: GHC.Prim.Double#
                   [LclId]
                   sinhx_sguM0 = GHC.Prim.sinhDouble# ww4_sgxGW } in
                 let {
                   coshx_sguLZ [Dmd=<S,U>] :: GHC.Prim.Double#
                   [LclId]
                   coshx_sguLZ = GHC.Prim.coshDouble# ww4_sgxGW } in
                 case Data.Complex.$w$s$c/
                        (GHC.Prim.*## cosy_sguM1 sinhx_sguM0)
                        (GHC.Prim.*## siny_sguM2 coshx_sguLZ)
                        (GHC.Prim.*## cosy_sguM1 coshx_sguLZ)
                        (GHC.Prim.*## siny_sguM2 sinhx_sguM0)
                 of
                 { (# ww8_sgxRV [Occ=Once], ww9_sgxRW [Occ=Once] #) ->
                 Data.Complex.:+ @ Double ww8_sgxRV ww9_sgxRW
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$ctanh
  = \ (w_sgxGQ :: Complex Double) ->
      case w_sgxGQ of { :+ ww1_sgxGT ww2_sgxGY ->
      case ww1_sgxGT of { GHC.Types.D# ww4_sgziT ->
      case ww2_sgxGY of { GHC.Types.D# ww6_sgziW ->
      let {
        coshx_sguLZ [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        coshx_sguLZ = GHC.Prim.coshDouble# ww4_sgziT } in
      let {
        sinhx_sguM0 [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        sinhx_sguM0 = GHC.Prim.sinhDouble# ww4_sgziT } in
      let {
        cosy_sguM1 [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        cosy_sguM1 = GHC.Prim.cosDouble# ww6_sgziW } in
      let {
        siny_sguM2 [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        siny_sguM2 = GHC.Prim.sinDouble# ww6_sgziW } in
      case Data.Complex.$w$s$c/
             (GHC.Prim.*## cosy_sguM1 sinhx_sguM0)
             (GHC.Prim.*## siny_sguM2 coshx_sguLZ)
             (GHC.Prim.*## cosy_sguM1 coshx_sguLZ)
             (GHC.Prim.*## siny_sguM2 sinhx_sguM0)
      of
      { (# ww8_sgxRV, ww9_sgxRW #) ->
      Data.Complex.:+ @ Double ww8_sgxRV ww9_sgxRW
      }
      }
      }
      }

-- RHS size: {terms: 62, types: 35, coercions: 0, joins: 0/8}
Data.Complex.$w$ctanh [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),1*U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 540 0}]
Data.Complex.$w$ctanh
  = \ (@ a_sgxH8)
      (w_sgxH9 :: RealFloat a_sgxH8)
      (ww_sgxHd
         :: a_sgxH8
         Unf=OtherCon [])
      (ww1_sgxHe
         :: a_sgxH8
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sguhY [Dmd=<S(S(S(LLC(C(S))LLLL)LL)LLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxH8
        [LclId]
        $dRealFrac_sguhY = GHC.Float.$p1RealFloat @ a_sgxH8 w_sgxH9 } in
      let {
        $dReal_sguhX [Dmd=<S(S(LLC(C(S))LLLL)LL),1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
          :: Real a_sgxH8
        [LclId]
        $dReal_sguhX = GHC.Real.$p1RealFrac @ a_sgxH8 $dRealFrac_sguhY } in
      let {
        $dNum_sguhW [Dmd=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)>]
          :: Num a_sgxH8
        [LclId]
        $dNum_sguhW = GHC.Real.$p1Real @ a_sgxH8 $dReal_sguhX } in
      let {
        $dFloating_sguhZ [Dmd=<L,U(A,A,A,A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,1*C1(U),1*C1(U),A,A,A,A,A,A,A,A)>]
          :: Floating a_sgxH8
        [LclId]
        $dFloating_sguhZ = GHC.Float.$p2RealFloat @ a_sgxH8 w_sgxH9 } in
      let {
        sinhx_sgui6 :: a_sgxH8
        [LclId]
        sinhx_sgui6 = sinh @ a_sgxH8 $dFloating_sguhZ ww_sgxHd } in
      let {
        cosy_sgui5 :: a_sgxH8
        [LclId]
        cosy_sgui5 = cos @ a_sgxH8 $dFloating_sguhZ ww1_sgxHe } in
      case * @ a_sgxH8 $dNum_sguhW cosy_sgui5 sinhx_sgui6 of dt_XgsHy
      { __DEFAULT ->
      let {
        coshx_sgui7 :: a_sgxH8
        [LclId]
        coshx_sgui7 = cosh @ a_sgxH8 $dFloating_sguhZ ww_sgxHd } in
      let {
        siny_sgui4 :: a_sgxH8
        [LclId]
        siny_sgui4 = sin @ a_sgxH8 $dFloating_sguhZ ww1_sgxHe } in
      case * @ a_sgxH8 $dNum_sguhW siny_sgui4 coshx_sgui7 of dt1_XgsHD
      { __DEFAULT ->
      case * @ a_sgxH8 $dNum_sguhW cosy_sgui5 coshx_sgui7 of dt2_XgsUV
      { __DEFAULT ->
      case * @ a_sgxH8 $dNum_sguhW siny_sgui4 sinhx_sgui6 of dt3_XgsV3
      { __DEFAULT ->
      Data.Complex.$w$c/
        @ a_sgxH8 w_sgxH9 dt_XgsHy dt1_XgsHD dt2_XgsUV dt3_XgsV3
      }
      }
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$ctanh [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(S(LLC(C(S))LLLL)LL)S(LC(C(S))LL)LLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,A),A,A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxH8)
                 (w_sgxH9 [Occ=Once] :: RealFloat a_sgxH8)
                 (w1_sgxHa [Occ=Once!] :: Complex a_sgxH8) ->
                 case w1_sgxHa of { :+ ww1_sgxHd [Occ=Once] ww2_sgxHe [Occ=Once] ->
                 case Data.Complex.$w$ctanh @ a_sgxH8 w_sgxH9 ww1_sgxHd ww2_sgxHe of
                 { (# ww4_sgxRY [Occ=Once], ww5_sgxRZ [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxH8 ww4_sgxRY ww5_sgxRZ
                 }
                 }}]
Data.Complex.$fFloatingComplex_$ctanh
  = \ (@ a_sgxH8)
      (w_sgxH9 :: RealFloat a_sgxH8)
      (w1_sgxHa :: Complex a_sgxH8) ->
      case w1_sgxHa of { :+ ww1_sgxHd ww2_sgxHe ->
      case Data.Complex.$w$ctanh @ a_sgxH8 w_sgxH9 ww1_sgxHd ww2_sgxHe of
      { (# ww4_sgxRY, ww5_sgxRZ #) ->
      Data.Complex.:+ @ a_sgxH8 ww4_sgxRY ww5_sgxRZ
      }
      }

-- RHS size: {terms: 67, types: 33, coercions: 0, joins: 0/2}
Data.Complex.$w$s$cacosh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> (# Float, Float #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 234 30}]
Data.Complex.$w$s$cacosh1
  = \ (ww_sgxHD :: GHC.Prim.Float#) (ww1_sgxHI :: GHC.Prim.Float#) ->
      case Data.Complex.$w$s$csqrt1
             (GHC.Prim.plusFloat# ww_sgxHD 1.0#) ww1_sgxHI
      of
      { (# ww3_sgxRA, ww4_sgxRB #) ->
      case ww4_sgxRB of { GHC.Types.F# x_sgziZ ->
      case ww3_sgxRA of { GHC.Types.F# x1_sgzj2 ->
      case Data.Complex.$w$s$csqrt1
             (GHC.Prim.minusFloat# ww_sgxHD 1.0#) ww1_sgxHI
      of
      { (# ww6_Xgy54, ww7_Xgy56 #) ->
      case ww7_Xgy56 of { GHC.Types.F# y_sgzj5 ->
      case ww6_Xgy54 of { GHC.Types.F# y1_sgzj8 ->
      let {
        ww8_sgy5d [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        ww8_sgy5d
          = GHC.Prim.plusFloat#
              ww1_sgxHI
              (GHC.Prim.plusFloat#
                 (GHC.Prim.timesFloat# x1_sgzj2 y_sgzj5)
                 (GHC.Prim.timesFloat# x_sgziZ y1_sgzj8)) } in
      let {
        ww9_sgy5c [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        ww9_sgy5c
          = GHC.Prim.plusFloat#
              ww_sgxHD
              (GHC.Prim.minusFloat#
                 (GHC.Prim.timesFloat# x1_sgzj2 y1_sgzj8)
                 (GHC.Prim.timesFloat# x_sgziZ y_sgzj5)) } in
      case Data.Complex.$w$smagnitude1 ww9_sgy5c ww8_sgy5d of ww10_sgxyg
      { __DEFAULT ->
      case GHC.Prim.logFloat# ww10_sgxyg of wild4_igtz0 { __DEFAULT ->
      case Data.Complex.$w$sphase1 ww9_sgy5c ww8_sgy5d of ww11_sgxxv
      { __DEFAULT ->
      (# GHC.Types.F# wild4_igtz0, GHC.Types.F# ww11_sgxxv #)
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cacosh1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxHx [Occ=Once!] :: Complex Float) ->
                 case w_sgxHx of { :+ ww1_sgxHA [Occ=Once!] ww2_sgxHF [Occ=Once!] ->
                 case ww1_sgxHA of { GHC.Types.F# ww4_sgxHD [Occ=Once] ->
                 case ww2_sgxHF of { GHC.Types.F# ww6_sgxHI [Occ=Once] ->
                 case Data.Complex.$w$s$cacosh1 ww4_sgxHD ww6_sgxHI of
                 { (# ww8_sgxS1 [Occ=Once], ww9_sgxS2 [Occ=Once] #) ->
                 Data.Complex.:+ @ Float ww8_sgxS1 ww9_sgxS2
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$cacosh1
  = \ (w_sgxHx :: Complex Float) ->
      case w_sgxHx of { :+ ww1_sgxHA ww2_sgxHF ->
      case ww1_sgxHA of { GHC.Types.F# ww4_sgzjb ->
      case ww2_sgxHF of { GHC.Types.F# ww6_sgzje ->
      case Data.Complex.$w$s$cacosh1 ww4_sgzjb ww6_sgzje of
      { (# ww8_sgxS1, ww9_sgxS2 #) ->
      Data.Complex.:+ @ Float ww8_sgxS1 ww9_sgxS2
      }
      }
      }
      }

-- RHS size: {terms: 67, types: 33, coercions: 0, joins: 0/2}
Data.Complex.$w$s$cacosh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> (# Double, Double #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 234 30}]
Data.Complex.$w$s$cacosh
  = \ (ww_sgxI8 :: GHC.Prim.Double#)
      (ww1_sgxId :: GHC.Prim.Double#) ->
      case Data.Complex.$w$s$csqrt
             (GHC.Prim.+## ww_sgxI8 1.0##) ww1_sgxId
      of
      { (# ww3_sgxRD, ww4_sgxRE #) ->
      case ww4_sgxRE of { GHC.Types.D# x_sgzjh ->
      case ww3_sgxRD of { GHC.Types.D# x1_sgzjk ->
      case Data.Complex.$w$s$csqrt
             (GHC.Prim.-## ww_sgxI8 1.0##) ww1_sgxId
      of
      { (# ww6_Xgy59, ww7_Xgy5b #) ->
      case ww7_Xgy5b of { GHC.Types.D# y_sgzjn ->
      case ww6_Xgy59 of { GHC.Types.D# y1_sgzjq ->
      let {
        ww8_sgy5A [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        ww8_sgy5A
          = GHC.Prim.+##
              ww1_sgxId
              (GHC.Prim.+##
                 (GHC.Prim.*## x1_sgzjk y_sgzjn)
                 (GHC.Prim.*## x_sgzjh y1_sgzjq)) } in
      let {
        ww9_sgy5z [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        ww9_sgy5z
          = GHC.Prim.+##
              ww_sgxI8
              (GHC.Prim.-##
                 (GHC.Prim.*## x1_sgzjk y1_sgzjq)
                 (GHC.Prim.*## x_sgzjh y_sgzjn)) } in
      case Data.Complex.$w$smagnitude ww9_sgy5z ww8_sgy5A of ww10_sgxxX
      { __DEFAULT ->
      case GHC.Prim.logDouble# ww10_sgxxX of wild4_igtzm { __DEFAULT ->
      case Data.Complex.$w$sphase ww9_sgy5z ww8_sgy5A of ww11_sgxxd
      { __DEFAULT ->
      (# GHC.Types.D# wild4_igtzm, GHC.Types.D# ww11_sgxxd #)
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cacosh [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxI2 [Occ=Once!] :: Complex Double) ->
                 case w_sgxI2 of { :+ ww1_sgxI5 [Occ=Once!] ww2_sgxIa [Occ=Once!] ->
                 case ww1_sgxI5 of { GHC.Types.D# ww4_sgxI8 [Occ=Once] ->
                 case ww2_sgxIa of { GHC.Types.D# ww6_sgxId [Occ=Once] ->
                 case Data.Complex.$w$s$cacosh ww4_sgxI8 ww6_sgxId of
                 { (# ww8_sgxS4 [Occ=Once], ww9_sgxS5 [Occ=Once] #) ->
                 Data.Complex.:+ @ Double ww8_sgxS4 ww9_sgxS5
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$cacosh
  = \ (w_sgxI2 :: Complex Double) ->
      case w_sgxI2 of { :+ ww1_sgxI5 ww2_sgxIa ->
      case ww1_sgxI5 of { GHC.Types.D# ww4_sgzjt ->
      case ww2_sgxIa of { GHC.Types.D# ww6_sgzjw ->
      case Data.Complex.$w$s$cacosh ww4_sgzjt ww6_sgzjw of
      { (# ww8_sgxS4, ww9_sgxS5 #) ->
      Data.Complex.:+ @ Double ww8_sgxS4 ww9_sgxS5
      }
      }
      }
      }

-- RHS size: {terms: 57, types: 63, coercions: 0, joins: 0/0}
Data.Complex.$w$cacosh [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 460 0}]
Data.Complex.$w$cacosh
  = \ (@ a_sgxIk)
      (w_sgxIl :: RealFloat a_sgxIk)
      (ww_sgxIp
         :: a_sgxIk
         Unf=OtherCon [])
      (ww1_sgxIq
         :: a_sgxIk
         Unf=OtherCon []) ->
      case Data.Complex.$w$cfromInteger
             @ a_sgxIk w_sgxIl Data.Complex.$fFloatingComplex19
      of
      { (# ww3_sgxRo, ww4_sgxRp #) ->
      case Data.Complex.$w$c+
             @ a_sgxIk w_sgxIl ww_sgxIp ww1_sgxIq ww3_sgxRo ww4_sgxRp
      of
      { (# ww6_sgxR3, ww7_sgxR4 #) ->
      case Data.Complex.$w$csqrt @ a_sgxIk w_sgxIl ww6_sgxR3 ww7_sgxR4 of
      { (# ww9_sgxRG, ww10_sgxRH #) ->
      case Data.Complex.$w$c-
             @ a_sgxIk w_sgxIl ww_sgxIp ww1_sgxIq ww3_sgxRo ww4_sgxRp
      of
      { (# ww12_sgxR9, ww13_sgxRa #) ->
      case Data.Complex.$w$csqrt @ a_sgxIk w_sgxIl ww12_sgxR9 ww13_sgxRa
      of
      { (# ww15_Xgy5v, ww16_Xgy5x #) ->
      case Data.Complex.$w$c*
             @ a_sgxIk w_sgxIl ww9_sgxRG ww10_sgxRH ww15_Xgy5v ww16_Xgy5x
      of
      { (# ww18_sgxRf, ww19_sgxRg #) ->
      case Data.Complex.$w$c+
             @ a_sgxIk w_sgxIl ww_sgxIp ww1_sgxIq ww18_sgxRf ww19_sgxRg
      of
      { (# ww21_Xgy56, ww22_Xgy58 #) ->
      Data.Complex.$w$clog @ a_sgxIk w_sgxIl ww21_Xgy56 ww22_Xgy58
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$cacosh [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxIk)
                 (w_sgxIl [Occ=Once] :: RealFloat a_sgxIk)
                 (w1_sgxIm [Occ=Once!] :: Complex a_sgxIk) ->
                 case w1_sgxIm of { :+ ww1_sgxIp [Occ=Once] ww2_sgxIq [Occ=Once] ->
                 case Data.Complex.$w$cacosh @ a_sgxIk w_sgxIl ww1_sgxIp ww2_sgxIq
                 of
                 { (# ww4_sgxS7 [Occ=Once], ww5_sgxS8 [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxIk ww4_sgxS7 ww5_sgxS8
                 }
                 }}]
Data.Complex.$fFloatingComplex_$cacosh
  = \ (@ a_sgxIk)
      (w_sgxIl :: RealFloat a_sgxIk)
      (w1_sgxIm :: Complex a_sgxIk) ->
      case w1_sgxIm of { :+ ww1_sgxIp ww2_sgxIq ->
      case Data.Complex.$w$cacosh @ a_sgxIk w_sgxIl ww1_sgxIp ww2_sgxIq
      of
      { (# ww4_sgxS7, ww5_sgxS8 #) ->
      Data.Complex.:+ @ a_sgxIk ww4_sgxS7 ww5_sgxS8
      }
      }

-- RHS size: {terms: 54, types: 22, coercions: 0, joins: 0/2}
Data.Complex.$w$s$casinh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> (# Float, Float #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 173 30}]
Data.Complex.$w$s$casinh1
  = \ (ww_sgxIP :: GHC.Prim.Float#) (ww1_sgxIU :: GHC.Prim.Float#) ->
      case Data.Complex.$w$s$csqrt1
             (GHC.Prim.plusFloat#
                1.0#
                (GHC.Prim.minusFloat#
                   (GHC.Prim.timesFloat# ww_sgxIP ww_sgxIP)
                   (GHC.Prim.timesFloat# ww1_sgxIU ww1_sgxIU)))
             (GHC.Prim.plusFloat#
                (GHC.Prim.timesFloat# ww_sgxIP ww1_sgxIU)
                (GHC.Prim.timesFloat# ww1_sgxIU ww_sgxIP))
      of
      { (# ww3_sgxRA, ww4_sgxRB #) ->
      case ww3_sgxRA of { GHC.Types.F# y_sgzjz ->
      case ww4_sgxRB of { GHC.Types.F# y1_sgzjC ->
      let {
        ww5_sgy67 [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        ww5_sgy67 = GHC.Prim.plusFloat# ww1_sgxIU y1_sgzjC } in
      let {
        ww6_sgy66 [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        ww6_sgy66 = GHC.Prim.plusFloat# ww_sgxIP y_sgzjz } in
      case Data.Complex.$w$smagnitude1 ww6_sgy66 ww5_sgy67 of ww7_sgxyg
      { __DEFAULT ->
      case GHC.Prim.logFloat# ww7_sgxyg of wild3_igtz0 { __DEFAULT ->
      case Data.Complex.$w$sphase1 ww6_sgy66 ww5_sgy67 of ww8_sgxxv
      { __DEFAULT ->
      (# GHC.Types.F# wild3_igtz0, GHC.Types.F# ww8_sgxxv #)
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$casinh1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxIJ [Occ=Once!] :: Complex Float) ->
                 case w_sgxIJ of { :+ ww1_sgxIM [Occ=Once!] ww2_sgxIR [Occ=Once!] ->
                 case ww1_sgxIM of { GHC.Types.F# ww4_sgxIP [Occ=Once] ->
                 case ww2_sgxIR of { GHC.Types.F# ww6_sgxIU [Occ=Once] ->
                 case Data.Complex.$w$s$casinh1 ww4_sgxIP ww6_sgxIU of
                 { (# ww8_sgxSa [Occ=Once], ww9_sgxSb [Occ=Once] #) ->
                 Data.Complex.:+ @ Float ww8_sgxSa ww9_sgxSb
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$casinh1
  = \ (w_sgxIJ :: Complex Float) ->
      case w_sgxIJ of { :+ ww1_sgxIM ww2_sgxIR ->
      case ww1_sgxIM of { GHC.Types.F# ww4_sgzjF ->
      case ww2_sgxIR of { GHC.Types.F# ww6_sgzjI ->
      case Data.Complex.$w$s$casinh1 ww4_sgzjF ww6_sgzjI of
      { (# ww8_sgxSa, ww9_sgxSb #) ->
      Data.Complex.:+ @ Float ww8_sgxSa ww9_sgxSb
      }
      }
      }
      }

-- RHS size: {terms: 54, types: 22, coercions: 0, joins: 0/2}
Data.Complex.$w$s$casinh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> (# Double, Double #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 173 30}]
Data.Complex.$w$s$casinh
  = \ (ww_sgxJk :: GHC.Prim.Double#)
      (ww1_sgxJp :: GHC.Prim.Double#) ->
      case Data.Complex.$w$s$csqrt
             (GHC.Prim.+##
                1.0##
                (GHC.Prim.-##
                   (GHC.Prim.*## ww_sgxJk ww_sgxJk)
                   (GHC.Prim.*## ww1_sgxJp ww1_sgxJp)))
             (GHC.Prim.+##
                (GHC.Prim.*## ww_sgxJk ww1_sgxJp)
                (GHC.Prim.*## ww1_sgxJp ww_sgxJk))
      of
      { (# ww3_sgxRD, ww4_sgxRE #) ->
      case ww3_sgxRD of { GHC.Types.D# y_sgzjL ->
      case ww4_sgxRE of { GHC.Types.D# y1_sgzjO ->
      let {
        ww5_sgy6r [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        ww5_sgy6r = GHC.Prim.+## ww1_sgxJp y1_sgzjO } in
      let {
        ww6_sgy6q [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        ww6_sgy6q = GHC.Prim.+## ww_sgxJk y_sgzjL } in
      case Data.Complex.$w$smagnitude ww6_sgy6q ww5_sgy6r of ww7_sgxxX
      { __DEFAULT ->
      case GHC.Prim.logDouble# ww7_sgxxX of wild3_igtzm { __DEFAULT ->
      case Data.Complex.$w$sphase ww6_sgy6q ww5_sgy6r of ww8_sgxxd
      { __DEFAULT ->
      (# GHC.Types.D# wild3_igtzm, GHC.Types.D# ww8_sgxxd #)
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$casinh [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxJe [Occ=Once!] :: Complex Double) ->
                 case w_sgxJe of { :+ ww1_sgxJh [Occ=Once!] ww2_sgxJm [Occ=Once!] ->
                 case ww1_sgxJh of { GHC.Types.D# ww4_sgxJk [Occ=Once] ->
                 case ww2_sgxJm of { GHC.Types.D# ww6_sgxJp [Occ=Once] ->
                 case Data.Complex.$w$s$casinh ww4_sgxJk ww6_sgxJp of
                 { (# ww8_sgxSd [Occ=Once], ww9_sgxSe [Occ=Once] #) ->
                 Data.Complex.:+ @ Double ww8_sgxSd ww9_sgxSe
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$casinh
  = \ (w_sgxJe :: Complex Double) ->
      case w_sgxJe of { :+ ww1_sgxJh ww2_sgxJm ->
      case ww1_sgxJh of { GHC.Types.D# ww4_sgzjR ->
      case ww2_sgxJm of { GHC.Types.D# ww6_sgzjU ->
      case Data.Complex.$w$s$casinh ww4_sgzjR ww6_sgzjU of
      { (# ww8_sgxSd, ww9_sgxSe #) ->
      Data.Complex.:+ @ Double ww8_sgxSd ww9_sgxSe
      }
      }
      }
      }

-- RHS size: {terms: 43, types: 47, coercions: 0, joins: 0/0}
Data.Complex.$w$casinh [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),1*C1(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 340 0}]
Data.Complex.$w$casinh
  = \ (@ a_sgxJw)
      (w_sgxJx :: RealFloat a_sgxJw)
      (ww_sgxJB
         :: a_sgxJw
         Unf=OtherCon [])
      (ww1_sgxJC
         :: a_sgxJw
         Unf=OtherCon []) ->
      case Data.Complex.$w$cfromInteger
             @ a_sgxJw w_sgxJx Data.Complex.$fFloatingComplex19
      of
      { (# ww3_sgxRo, ww4_sgxRp #) ->
      case Data.Complex.$w$c*
             @ a_sgxJw w_sgxJx ww_sgxJB ww1_sgxJC ww_sgxJB ww1_sgxJC
      of
      { (# ww6_sgxRf, ww7_sgxRg #) ->
      case Data.Complex.$w$c+
             @ a_sgxJw w_sgxJx ww3_sgxRo ww4_sgxRp ww6_sgxRf ww7_sgxRg
      of
      { (# ww9_sgxR3, ww10_sgxR4 #) ->
      case Data.Complex.$w$csqrt @ a_sgxJw w_sgxJx ww9_sgxR3 ww10_sgxR4
      of
      { (# ww12_sgxRG, ww13_sgxRH #) ->
      case Data.Complex.$w$c+
             @ a_sgxJw w_sgxJx ww_sgxJB ww1_sgxJC ww12_sgxRG ww13_sgxRH
      of
      { (# ww15_Xgy4T, ww16_Xgy4V #) ->
      Data.Complex.$w$clog @ a_sgxJw w_sgxJx ww15_Xgy4T ww16_Xgy4V
      }
      }
      }
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$casinh [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxJw)
                 (w_sgxJx [Occ=Once] :: RealFloat a_sgxJw)
                 (w1_sgxJy [Occ=Once!] :: Complex a_sgxJw) ->
                 case w1_sgxJy of { :+ ww1_sgxJB [Occ=Once] ww2_sgxJC [Occ=Once] ->
                 case Data.Complex.$w$casinh @ a_sgxJw w_sgxJx ww1_sgxJB ww2_sgxJC
                 of
                 { (# ww4_sgxSg [Occ=Once], ww5_sgxSh [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxJw ww4_sgxSg ww5_sgxSh
                 }
                 }}]
Data.Complex.$fFloatingComplex_$casinh
  = \ (@ a_sgxJw)
      (w_sgxJx :: RealFloat a_sgxJw)
      (w1_sgxJy :: Complex a_sgxJw) ->
      case w1_sgxJy of { :+ ww1_sgxJB ww2_sgxJC ->
      case Data.Complex.$w$casinh @ a_sgxJw w_sgxJx ww1_sgxJB ww2_sgxJC
      of
      { (# ww4_sgxSg, ww5_sgxSh #) ->
      Data.Complex.:+ @ a_sgxJw ww4_sgxSg ww5_sgxSh
      }
      }

-- RHS size: {terms: 62, types: 31, coercions: 0, joins: 0/0}
Data.Complex.$w$s$catan1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> (# Float, Float #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 253 30}]
Data.Complex.$w$s$catan1
  = \ (ww_sgxK1 :: GHC.Prim.Float#) (ww1_sgxK6 :: GHC.Prim.Float#) ->
      case Data.Complex.$w$s$csqrt1
             (GHC.Prim.plusFloat#
                1.0#
                (GHC.Prim.minusFloat#
                   (GHC.Prim.timesFloat# ww_sgxK1 ww_sgxK1)
                   (GHC.Prim.timesFloat# ww1_sgxK6 ww1_sgxK6)))
             (GHC.Prim.plusFloat#
                (GHC.Prim.timesFloat# ww_sgxK1 ww1_sgxK6)
                (GHC.Prim.timesFloat# ww1_sgxK6 ww_sgxK1))
      of
      { (# ww3_sgxRA, ww4_sgxRB #) ->
      case ww3_sgxRA of { GHC.Types.F# ww6_sgzjX ->
      case ww4_sgxRB of { GHC.Types.F# ww8_sgzk0 ->
      case Data.Complex.$w$s$c/1
             (GHC.Prim.minusFloat# 1.0# ww1_sgxK6) ww_sgxK1 ww6_sgzjX ww8_sgzk0
      of
      { (# ww10_sgxQb, ww11_sgxQc #) ->
      case ww10_sgxQb of { GHC.Types.F# ww13_sgzk3 ->
      case ww11_sgxQc of { GHC.Types.F# ww15_sgzk6 ->
      case Data.Complex.$w$smagnitude1 ww13_sgzk3 ww15_sgzk6
      of ww16_sgxyg
      { __DEFAULT ->
      case GHC.Prim.logFloat# ww16_sgxyg of wild1_igtz0 { __DEFAULT ->
      case Data.Complex.$w$sphase1 ww13_sgzk3 ww15_sgzk6 of ww17_sgxxv
      { __DEFAULT ->
      (# GHC.Types.F# ww17_sgxxv,
         GHC.Types.F# (GHC.Prim.negateFloat# wild1_igtz0) #)
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$catan1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxJV [Occ=Once!] :: Complex Float) ->
                 case w_sgxJV of { :+ ww1_sgxJY [Occ=Once!] ww2_sgxK3 [Occ=Once!] ->
                 case ww1_sgxJY of { GHC.Types.F# ww4_sgxK1 [Occ=Once] ->
                 case ww2_sgxK3 of { GHC.Types.F# ww6_sgxK6 [Occ=Once] ->
                 case Data.Complex.$w$s$catan1 ww4_sgxK1 ww6_sgxK6 of
                 { (# ww8_sgxSj [Occ=Once], ww9_sgxSk [Occ=Once] #) ->
                 Data.Complex.:+ @ Float ww8_sgxSj ww9_sgxSk
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$catan1
  = \ (w_sgxJV :: Complex Float) ->
      case w_sgxJV of { :+ ww1_sgxJY ww2_sgxK3 ->
      case ww1_sgxJY of { GHC.Types.F# ww4_sgzk9 ->
      case ww2_sgxK3 of { GHC.Types.F# ww6_sgzkc ->
      case Data.Complex.$w$s$catan1 ww4_sgzk9 ww6_sgzkc of
      { (# ww8_sgxSj, ww9_sgxSk #) ->
      Data.Complex.:+ @ Float ww8_sgxSj ww9_sgxSk
      }
      }
      }
      }

-- RHS size: {terms: 62, types: 31, coercions: 0, joins: 0/0}
Data.Complex.$w$s$catan [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> (# Double, Double #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 253 30}]
Data.Complex.$w$s$catan
  = \ (ww_sgxKw :: GHC.Prim.Double#)
      (ww1_sgxKB :: GHC.Prim.Double#) ->
      case Data.Complex.$w$s$csqrt
             (GHC.Prim.+##
                1.0##
                (GHC.Prim.-##
                   (GHC.Prim.*## ww_sgxKw ww_sgxKw)
                   (GHC.Prim.*## ww1_sgxKB ww1_sgxKB)))
             (GHC.Prim.+##
                (GHC.Prim.*## ww_sgxKw ww1_sgxKB)
                (GHC.Prim.*## ww1_sgxKB ww_sgxKw))
      of
      { (# ww3_sgxRD, ww4_sgxRE #) ->
      case ww3_sgxRD of { GHC.Types.D# ww6_sgzkf ->
      case ww4_sgxRE of { GHC.Types.D# ww8_sgzki ->
      case Data.Complex.$w$s$c/
             (GHC.Prim.-## 1.0## ww1_sgxKB) ww_sgxKw ww6_sgzkf ww8_sgzki
      of
      { (# ww10_sgxQR, ww11_sgxQS #) ->
      case ww10_sgxQR of { GHC.Types.D# ww13_sgzkl ->
      case ww11_sgxQS of { GHC.Types.D# ww15_sgzko ->
      case Data.Complex.$w$smagnitude ww13_sgzkl ww15_sgzko of ww16_sgxxX
      { __DEFAULT ->
      case GHC.Prim.logDouble# ww16_sgxxX of wild1_igtzm { __DEFAULT ->
      case Data.Complex.$w$sphase ww13_sgzkl ww15_sgzko of ww17_sgxxd
      { __DEFAULT ->
      (# GHC.Types.D# ww17_sgxxd,
         GHC.Types.D# (GHC.Prim.negateDouble# wild1_igtzm) #)
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$catan [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxKq [Occ=Once!] :: Complex Double) ->
                 case w_sgxKq of { :+ ww1_sgxKt [Occ=Once!] ww2_sgxKy [Occ=Once!] ->
                 case ww1_sgxKt of { GHC.Types.D# ww4_sgxKw [Occ=Once] ->
                 case ww2_sgxKy of { GHC.Types.D# ww6_sgxKB [Occ=Once] ->
                 case Data.Complex.$w$s$catan ww4_sgxKw ww6_sgxKB of
                 { (# ww8_sgxSm [Occ=Once], ww9_sgxSn [Occ=Once] #) ->
                 Data.Complex.:+ @ Double ww8_sgxSm ww9_sgxSn
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$catan
  = \ (w_sgxKq :: Complex Double) ->
      case w_sgxKq of { :+ ww1_sgxKt ww2_sgxKy ->
      case ww1_sgxKt of { GHC.Types.D# ww4_sgzkr ->
      case ww2_sgxKy of { GHC.Types.D# ww6_sgzku ->
      case Data.Complex.$w$s$catan ww4_sgzkr ww6_sgzku of
      { (# ww8_sgxSm, ww9_sgxSn #) ->
      Data.Complex.:+ @ Double ww8_sgxSm ww9_sgxSn
      }
      }
      }
      }

-- RHS size: {terms: 79, types: 70, coercions: 0, joins: 0/3}
Data.Complex.$w$catan [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 660 30}]
Data.Complex.$w$catan
  = \ (@ a_sgxKN)
      (w_sgxKO :: RealFloat a_sgxKN)
      (ww_sgxKS
         :: a_sgxKN
         Unf=OtherCon [])
      (ww1_sgxKT
         :: a_sgxKN
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sguhF [Dmd=<S(S(S(LC(C(S))LC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U)),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxKN
        [LclId]
        $dRealFrac_sguhF = GHC.Float.$p1RealFloat @ a_sgxKN w_sgxKO } in
      let {
        $dReal_sguhE [Dmd=<S(S(LC(C(S))LC(S)LLL)LL),1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U)),A,A)>]
          :: Real a_sgxKN
        [LclId]
        $dReal_sguhE = GHC.Real.$p1RealFrac @ a_sgxKN $dRealFrac_sguhF } in
      let {
        $dNum_sguhD [Dmd=<S(LC(C(S))LC(S)LLL),U(A,1*C1(C1(U)),A,1*C1(U),A,A,1*C1(U))>]
          :: Num a_sgxKN
        [LclId]
        $dNum_sguhD = GHC.Real.$p1Real @ a_sgxKN $dReal_sguhE } in
      case - @ a_sgxKN
             $dNum_sguhD
             (fromInteger
                @ a_sgxKN $dNum_sguhD Data.Complex.$fFloatingComplex19)
             ww1_sgxKT
      of dt_XgsIn
      { __DEFAULT ->
      case Data.Complex.$w$cfromInteger
             @ a_sgxKN w_sgxKO Data.Complex.$fFloatingComplex19
      of
      { (# ww3_sgxRo, ww4_sgxRp #) ->
      case Data.Complex.$w$c*
             @ a_sgxKN w_sgxKO ww_sgxKS ww1_sgxKT ww_sgxKS ww1_sgxKT
      of
      { (# ww6_sgxRf, ww7_sgxRg #) ->
      case Data.Complex.$w$c+
             @ a_sgxKN w_sgxKO ww3_sgxRo ww4_sgxRp ww6_sgxRf ww7_sgxRg
      of
      { (# ww9_sgxR3, ww10_sgxR4 #) ->
      case Data.Complex.$w$csqrt @ a_sgxKN w_sgxKO ww9_sgxR3 ww10_sgxR4
      of
      { (# ww12_sgxRG, ww13_sgxRH #) ->
      case Data.Complex.$w$c/
             @ a_sgxKN w_sgxKO dt_XgsIn ww_sgxKS ww12_sgxRG ww13_sgxRH
      of
      { (# ww15_sgxQU, ww16_sgxQV #) ->
      case log
             @ a_sgxKN
             (GHC.Float.$p2RealFloat @ a_sgxKN w_sgxKO)
             (Data.Complex.$wmagnitude @ a_sgxKN w_sgxKO ww15_sgxQU ww16_sgxQV)
      of dt1_XgsF3
      { __DEFAULT ->
      case Data.Complex.$wphase @ a_sgxKN w_sgxKO ww15_sgxQU ww16_sgxQV
      of dt2_XgsF8
      { __DEFAULT ->
      case negate @ a_sgxKN $dNum_sguhD dt1_XgsF3 of dt3_XgsIv
      { __DEFAULT ->
      (# dt2_XgsF8, dt3_XgsIv #)
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$catan [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxKN)
                 (w_sgxKO [Occ=Once] :: RealFloat a_sgxKN)
                 (w1_sgxKP [Occ=Once!] :: Complex a_sgxKN) ->
                 case w1_sgxKP of { :+ ww1_sgxKS [Occ=Once] ww2_sgxKT [Occ=Once] ->
                 case Data.Complex.$w$catan @ a_sgxKN w_sgxKO ww1_sgxKS ww2_sgxKT of
                 { (# ww4_sgxSp [Occ=Once], ww5_sgxSq [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxKN ww4_sgxSp ww5_sgxSq
                 }
                 }}]
Data.Complex.$fFloatingComplex_$catan
  = \ (@ a_sgxKN)
      (w_sgxKO :: RealFloat a_sgxKN)
      (w1_sgxKP :: Complex a_sgxKN) ->
      case w1_sgxKP of { :+ ww1_sgxKS ww2_sgxKT ->
      case Data.Complex.$w$catan @ a_sgxKN w_sgxKO ww1_sgxKS ww2_sgxKT of
      { (# ww4_sgxSp, ww5_sgxSq #) ->
      Data.Complex.:+ @ a_sgxKN ww4_sgxSp ww5_sgxSq
      }
      }

-- RHS size: {terms: 58, types: 22, coercions: 0, joins: 0/2}
Data.Complex.$w$s$cacos1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> (# Float, Float #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 176 30}]
Data.Complex.$w$s$cacos1
  = \ (ww_sgxLi :: GHC.Prim.Float#) (ww1_sgxLn :: GHC.Prim.Float#) ->
      case Data.Complex.$w$s$csqrt1
             (GHC.Prim.minusFloat#
                1.0#
                (GHC.Prim.minusFloat#
                   (GHC.Prim.timesFloat# ww_sgxLi ww_sgxLi)
                   (GHC.Prim.timesFloat# ww1_sgxLn ww1_sgxLn)))
             (GHC.Prim.minusFloat#
                0.0#
                (GHC.Prim.plusFloat#
                   (GHC.Prim.timesFloat# ww_sgxLi ww1_sgxLn)
                   (GHC.Prim.timesFloat# ww1_sgxLn ww_sgxLi)))
      of
      { (# ww3_sgxRA, ww4_sgxRB #) ->
      case ww4_sgxRB of { GHC.Types.F# x_sgzkx ->
      case ww3_sgxRA of { GHC.Types.F# y_sgzkA ->
      let {
        ww5_sgy7O [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        ww5_sgy7O = GHC.Prim.plusFloat# ww1_sgxLn y_sgzkA } in
      let {
        ww6_sgy7N [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        ww6_sgy7N
          = GHC.Prim.plusFloat# ww_sgxLi (GHC.Prim.negateFloat# x_sgzkx) } in
      case Data.Complex.$w$smagnitude1 ww6_sgy7N ww5_sgy7O of ww7_sgxyg
      { __DEFAULT ->
      case GHC.Prim.logFloat# ww7_sgxyg of wild2_igtz0 { __DEFAULT ->
      case Data.Complex.$w$sphase1 ww6_sgy7N ww5_sgy7O of ww8_sgxxv
      { __DEFAULT ->
      (# GHC.Types.F# ww8_sgxxv,
         GHC.Types.F# (GHC.Prim.negateFloat# wild2_igtz0) #)
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cacos1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxLc [Occ=Once!] :: Complex Float) ->
                 case w_sgxLc of { :+ ww1_sgxLf [Occ=Once!] ww2_sgxLk [Occ=Once!] ->
                 case ww1_sgxLf of { GHC.Types.F# ww4_sgxLi [Occ=Once] ->
                 case ww2_sgxLk of { GHC.Types.F# ww6_sgxLn [Occ=Once] ->
                 case Data.Complex.$w$s$cacos1 ww4_sgxLi ww6_sgxLn of
                 { (# ww8_sgxSs [Occ=Once], ww9_sgxSt [Occ=Once] #) ->
                 Data.Complex.:+ @ Float ww8_sgxSs ww9_sgxSt
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$cacos1
  = \ (w_sgxLc :: Complex Float) ->
      case w_sgxLc of { :+ ww1_sgxLf ww2_sgxLk ->
      case ww1_sgxLf of { GHC.Types.F# ww4_sgzkD ->
      case ww2_sgxLk of { GHC.Types.F# ww6_sgzkG ->
      case Data.Complex.$w$s$cacos1 ww4_sgzkD ww6_sgzkG of
      { (# ww8_sgxSs, ww9_sgxSt #) ->
      Data.Complex.:+ @ Float ww8_sgxSs ww9_sgxSt
      }
      }
      }
      }

-- RHS size: {terms: 58, types: 22, coercions: 0, joins: 0/2}
Data.Complex.$w$s$cacos [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> (# Double, Double #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 176 30}]
Data.Complex.$w$s$cacos
  = \ (ww_sgxLN :: GHC.Prim.Double#)
      (ww1_sgxLS :: GHC.Prim.Double#) ->
      case Data.Complex.$w$s$csqrt
             (GHC.Prim.-##
                1.0##
                (GHC.Prim.-##
                   (GHC.Prim.*## ww_sgxLN ww_sgxLN)
                   (GHC.Prim.*## ww1_sgxLS ww1_sgxLS)))
             (GHC.Prim.-##
                0.0##
                (GHC.Prim.+##
                   (GHC.Prim.*## ww_sgxLN ww1_sgxLS)
                   (GHC.Prim.*## ww1_sgxLS ww_sgxLN)))
      of
      { (# ww3_sgxRD, ww4_sgxRE #) ->
      case ww4_sgxRE of { GHC.Types.D# x_sgzkJ ->
      case ww3_sgxRD of { GHC.Types.D# y_sgzkM ->
      let {
        ww5_sgy89 [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        ww5_sgy89 = GHC.Prim.+## ww1_sgxLS y_sgzkM } in
      let {
        ww6_sgy88 [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        ww6_sgy88
          = GHC.Prim.+## ww_sgxLN (GHC.Prim.negateDouble# x_sgzkJ) } in
      case Data.Complex.$w$smagnitude ww6_sgy88 ww5_sgy89 of ww7_sgxxX
      { __DEFAULT ->
      case GHC.Prim.logDouble# ww7_sgxxX of wild2_igtzm { __DEFAULT ->
      case Data.Complex.$w$sphase ww6_sgy88 ww5_sgy89 of ww8_sgxxd
      { __DEFAULT ->
      (# GHC.Types.D# ww8_sgxxd,
         GHC.Types.D# (GHC.Prim.negateDouble# wild2_igtzm) #)
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$cacos [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxLH [Occ=Once!] :: Complex Double) ->
                 case w_sgxLH of { :+ ww1_sgxLK [Occ=Once!] ww2_sgxLP [Occ=Once!] ->
                 case ww1_sgxLK of { GHC.Types.D# ww4_sgxLN [Occ=Once] ->
                 case ww2_sgxLP of { GHC.Types.D# ww6_sgxLS [Occ=Once] ->
                 case Data.Complex.$w$s$cacos ww4_sgxLN ww6_sgxLS of
                 { (# ww8_sgxSv [Occ=Once], ww9_sgxSw [Occ=Once] #) ->
                 Data.Complex.:+ @ Double ww8_sgxSv ww9_sgxSw
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$cacos
  = \ (w_sgxLH :: Complex Double) ->
      case w_sgxLH of { :+ ww1_sgxLK ww2_sgxLP ->
      case ww1_sgxLK of { GHC.Types.D# ww4_sgzkP ->
      case ww2_sgxLP of { GHC.Types.D# ww6_sgzkS ->
      case Data.Complex.$w$s$cacos ww4_sgzkP ww6_sgzkS of
      { (# ww8_sgxSv, ww9_sgxSw #) ->
      Data.Complex.:+ @ Double ww8_sgxSv ww9_sgxSw
      }
      }
      }
      }

-- RHS size: {terms: 76, types: 69, coercions: 0, joins: 0/3}
Data.Complex.$w$cacos [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 620 30}]
Data.Complex.$w$cacos
  = \ (@ a_sgxM9)
      (w_sgxMa :: RealFloat a_sgxM9)
      (ww_sgxMe
         :: a_sgxM9
         Unf=OtherCon [])
      (ww1_sgxMf
         :: a_sgxM9
         Unf=OtherCon []) ->
      case Data.Complex.$w$cfromInteger
             @ a_sgxM9 w_sgxMa Data.Complex.$fFloatingComplex19
      of
      { (# ww3_sgxRo, ww4_sgxRp #) ->
      case Data.Complex.$w$c*
             @ a_sgxM9 w_sgxMa ww_sgxMe ww1_sgxMf ww_sgxMe ww1_sgxMf
      of
      { (# ww6_sgxRf, ww7_sgxRg #) ->
      case Data.Complex.$w$c-
             @ a_sgxM9 w_sgxMa ww3_sgxRo ww4_sgxRp ww6_sgxRf ww7_sgxRg
      of
      { (# ww9_sgxR9, ww10_sgxRa #) ->
      case Data.Complex.$w$csqrt @ a_sgxM9 w_sgxMa ww9_sgxR9 ww10_sgxRa
      of
      { (# ww12_sgxRG, ww13_sgxRH #) ->
      let {
        $dRealFrac_sguhn [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxM9
        [LclId]
        $dRealFrac_sguhn = GHC.Float.$p1RealFloat @ a_sgxM9 w_sgxMa } in
      let {
        $dReal_sguhm [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
          :: Real a_sgxM9
        [LclId]
        $dReal_sguhm = GHC.Real.$p1RealFrac @ a_sgxM9 $dRealFrac_sguhn } in
      let {
        $dNum_sguhl [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
          :: Num a_sgxM9
        [LclId]
        $dNum_sguhl = GHC.Real.$p1Real @ a_sgxM9 $dReal_sguhm } in
      case negate @ a_sgxM9 $dNum_sguhl ww13_sgxRH of dt_XgsIx
      { __DEFAULT ->
      case Data.Complex.$w$c+
             @ a_sgxM9 w_sgxMa ww_sgxMe ww1_sgxMf dt_XgsIx ww12_sgxRG
      of
      { (# ww15_sgxR3, ww16_sgxR4 #) ->
      case log
             @ a_sgxM9
             (GHC.Float.$p2RealFloat @ a_sgxM9 w_sgxMa)
             (Data.Complex.$wmagnitude @ a_sgxM9 w_sgxMa ww15_sgxR3 ww16_sgxR4)
      of dt1_XgsF3
      { __DEFAULT ->
      case Data.Complex.$wphase @ a_sgxM9 w_sgxMa ww15_sgxR3 ww16_sgxR4
      of dt2_XgsF8
      { __DEFAULT ->
      case negate @ a_sgxM9 $dNum_sguhl dt1_XgsF3 of dt3_XgsIF
      { __DEFAULT ->
      (# dt2_XgsF8, dt3_XgsIF #)
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$cacos [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxM9)
                 (w_sgxMa [Occ=Once] :: RealFloat a_sgxM9)
                 (w1_sgxMb [Occ=Once!] :: Complex a_sgxM9) ->
                 case w1_sgxMb of { :+ ww1_sgxMe [Occ=Once] ww2_sgxMf [Occ=Once] ->
                 case Data.Complex.$w$cacos @ a_sgxM9 w_sgxMa ww1_sgxMe ww2_sgxMf of
                 { (# ww4_sgxSy [Occ=Once], ww5_sgxSz [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxM9 ww4_sgxSy ww5_sgxSz
                 }
                 }}]
Data.Complex.$fFloatingComplex_$cacos
  = \ (@ a_sgxM9)
      (w_sgxMa :: RealFloat a_sgxM9)
      (w1_sgxMb :: Complex a_sgxM9) ->
      case w1_sgxMb of { :+ ww1_sgxMe ww2_sgxMf ->
      case Data.Complex.$w$cacos @ a_sgxM9 w_sgxMa ww1_sgxMe ww2_sgxMf of
      { (# ww4_sgxSy, ww5_sgxSz #) ->
      Data.Complex.:+ @ a_sgxM9 ww4_sgxSy ww5_sgxSz
      }
      }

-- RHS size: {terms: 58, types: 22, coercions: 0, joins: 0/2}
Data.Complex.$w$s$casin1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> (# Float, Float #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 176 30}]
Data.Complex.$w$s$casin1
  = \ (ww_sgxME :: GHC.Prim.Float#) (ww1_sgxMJ :: GHC.Prim.Float#) ->
      case Data.Complex.$w$s$csqrt1
             (GHC.Prim.minusFloat#
                1.0#
                (GHC.Prim.minusFloat#
                   (GHC.Prim.timesFloat# ww_sgxME ww_sgxME)
                   (GHC.Prim.timesFloat# ww1_sgxMJ ww1_sgxMJ)))
             (GHC.Prim.minusFloat#
                0.0#
                (GHC.Prim.plusFloat#
                   (GHC.Prim.timesFloat# ww_sgxME ww1_sgxMJ)
                   (GHC.Prim.timesFloat# ww1_sgxMJ ww_sgxME)))
      of
      { (# ww3_sgxRA, ww4_sgxRB #) ->
      case ww3_sgxRA of { GHC.Types.F# y_sgzkV ->
      case ww4_sgxRB of { GHC.Types.F# y1_sgzkY ->
      let {
        ww5_sgy8D [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        ww5_sgy8D = GHC.Prim.plusFloat# ww_sgxME y1_sgzkY } in
      let {
        ww6_sgy8C [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        ww6_sgy8C
          = GHC.Prim.plusFloat#
              (GHC.Prim.negateFloat# ww1_sgxMJ) y_sgzkV } in
      case Data.Complex.$w$smagnitude1 ww6_sgy8C ww5_sgy8D of ww7_sgxyg
      { __DEFAULT ->
      case GHC.Prim.logFloat# ww7_sgxyg of wild3_igtz0 { __DEFAULT ->
      case Data.Complex.$w$sphase1 ww6_sgy8C ww5_sgy8D of ww8_sgxxv
      { __DEFAULT ->
      (# GHC.Types.F# ww8_sgxxv,
         GHC.Types.F# (GHC.Prim.negateFloat# wild3_igtz0) #)
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$casin1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxMy [Occ=Once!] :: Complex Float) ->
                 case w_sgxMy of { :+ ww1_sgxMB [Occ=Once!] ww2_sgxMG [Occ=Once!] ->
                 case ww1_sgxMB of { GHC.Types.F# ww4_sgxME [Occ=Once] ->
                 case ww2_sgxMG of { GHC.Types.F# ww6_sgxMJ [Occ=Once] ->
                 case Data.Complex.$w$s$casin1 ww4_sgxME ww6_sgxMJ of
                 { (# ww8_sgxSB [Occ=Once], ww9_sgxSC [Occ=Once] #) ->
                 Data.Complex.:+ @ Float ww8_sgxSB ww9_sgxSC
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$casin1
  = \ (w_sgxMy :: Complex Float) ->
      case w_sgxMy of { :+ ww1_sgxMB ww2_sgxMG ->
      case ww1_sgxMB of { GHC.Types.F# ww4_sgzl1 ->
      case ww2_sgxMG of { GHC.Types.F# ww6_sgzl4 ->
      case Data.Complex.$w$s$casin1 ww4_sgzl1 ww6_sgzl4 of
      { (# ww8_sgxSB, ww9_sgxSC #) ->
      Data.Complex.:+ @ Float ww8_sgxSB ww9_sgxSC
      }
      }
      }
      }

-- RHS size: {terms: 58, types: 22, coercions: 0, joins: 0/2}
Data.Complex.$w$s$casin [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> (# Double, Double #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 176 30}]
Data.Complex.$w$s$casin
  = \ (ww_sgxN9 :: GHC.Prim.Double#)
      (ww1_sgxNe :: GHC.Prim.Double#) ->
      case Data.Complex.$w$s$csqrt
             (GHC.Prim.-##
                1.0##
                (GHC.Prim.-##
                   (GHC.Prim.*## ww_sgxN9 ww_sgxN9)
                   (GHC.Prim.*## ww1_sgxNe ww1_sgxNe)))
             (GHC.Prim.-##
                0.0##
                (GHC.Prim.+##
                   (GHC.Prim.*## ww_sgxN9 ww1_sgxNe)
                   (GHC.Prim.*## ww1_sgxNe ww_sgxN9)))
      of
      { (# ww3_sgxRD, ww4_sgxRE #) ->
      case ww3_sgxRD of { GHC.Types.D# y_sgzl7 ->
      case ww4_sgxRE of { GHC.Types.D# y1_sgzla ->
      let {
        ww5_sgy8Y [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        ww5_sgy8Y = GHC.Prim.+## ww_sgxN9 y1_sgzla } in
      let {
        ww6_sgy8X [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        ww6_sgy8X
          = GHC.Prim.+## (GHC.Prim.negateDouble# ww1_sgxNe) y_sgzl7 } in
      case Data.Complex.$w$smagnitude ww6_sgy8X ww5_sgy8Y of ww7_sgxxX
      { __DEFAULT ->
      case GHC.Prim.logDouble# ww7_sgxxX of wild3_igtzm { __DEFAULT ->
      case Data.Complex.$w$sphase ww6_sgy8X ww5_sgy8Y of ww8_sgxxd
      { __DEFAULT ->
      (# GHC.Types.D# ww8_sgxxd,
         GHC.Types.D# (GHC.Prim.negateDouble# wild3_igtzm) #)
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$casin [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxN3 [Occ=Once!] :: Complex Double) ->
                 case w_sgxN3 of { :+ ww1_sgxN6 [Occ=Once!] ww2_sgxNb [Occ=Once!] ->
                 case ww1_sgxN6 of { GHC.Types.D# ww4_sgxN9 [Occ=Once] ->
                 case ww2_sgxNb of { GHC.Types.D# ww6_sgxNe [Occ=Once] ->
                 case Data.Complex.$w$s$casin ww4_sgxN9 ww6_sgxNe of
                 { (# ww8_sgxSE [Occ=Once], ww9_sgxSF [Occ=Once] #) ->
                 Data.Complex.:+ @ Double ww8_sgxSE ww9_sgxSF
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$casin
  = \ (w_sgxN3 :: Complex Double) ->
      case w_sgxN3 of { :+ ww1_sgxN6 ww2_sgxNb ->
      case ww1_sgxN6 of { GHC.Types.D# ww4_sgzld ->
      case ww2_sgxNb of { GHC.Types.D# ww6_sgzlg ->
      case Data.Complex.$w$s$casin ww4_sgzld ww6_sgzlg of
      { (# ww8_sgxSE, ww9_sgxSF #) ->
      Data.Complex.:+ @ Double ww8_sgxSE ww9_sgxSF
      }
      }
      }
      }

-- RHS size: {terms: 76, types: 69, coercions: 0, joins: 0/3}
Data.Complex.$w$casin [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 620 30}]
Data.Complex.$w$casin
  = \ (@ a_sgxNq)
      (w_sgxNr :: RealFloat a_sgxNq)
      (ww_sgxNv
         :: a_sgxNq
         Unf=OtherCon [])
      (ww1_sgxNw
         :: a_sgxNq
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sguh7 [Dmd=<S(S(S(LLLC(S)LLL)LL)LLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,A),A,A),A,A,A,A,A,A)>]
          :: RealFrac a_sgxNq
        [LclId]
        $dRealFrac_sguh7 = GHC.Float.$p1RealFloat @ a_sgxNq w_sgxNr } in
      let {
        $dReal_sguh6 [Dmd=<S(S(LLLC(S)LLL)LL),1*U(1*U(A,A,A,C(U),A,A,A),A,A)>]
          :: Real a_sgxNq
        [LclId]
        $dReal_sguh6 = GHC.Real.$p1RealFrac @ a_sgxNq $dRealFrac_sguh7 } in
      let {
        $dNum_sguh5 [Dmd=<S(LLLC(S)LLL),U(A,A,A,C(U),A,A,A)>]
          :: Num a_sgxNq
        [LclId]
        $dNum_sguh5 = GHC.Real.$p1Real @ a_sgxNq $dReal_sguh6 } in
      case negate @ a_sgxNq $dNum_sguh5 ww1_sgxNw of dt_XgsIR
      { __DEFAULT ->
      case Data.Complex.$w$cfromInteger
             @ a_sgxNq w_sgxNr Data.Complex.$fFloatingComplex19
      of
      { (# ww3_sgxRo, ww4_sgxRp #) ->
      case Data.Complex.$w$c*
             @ a_sgxNq w_sgxNr ww_sgxNv ww1_sgxNw ww_sgxNv ww1_sgxNw
      of
      { (# ww6_sgxRf, ww7_sgxRg #) ->
      case Data.Complex.$w$c-
             @ a_sgxNq w_sgxNr ww3_sgxRo ww4_sgxRp ww6_sgxRf ww7_sgxRg
      of
      { (# ww9_sgxR9, ww10_sgxRa #) ->
      case Data.Complex.$w$csqrt @ a_sgxNq w_sgxNr ww9_sgxR9 ww10_sgxRa
      of
      { (# ww12_sgxRG, ww13_sgxRH #) ->
      case Data.Complex.$w$c+
             @ a_sgxNq w_sgxNr dt_XgsIR ww_sgxNv ww12_sgxRG ww13_sgxRH
      of
      { (# ww15_sgxR3, ww16_sgxR4 #) ->
      case log
             @ a_sgxNq
             (GHC.Float.$p2RealFloat @ a_sgxNq w_sgxNr)
             (Data.Complex.$wmagnitude @ a_sgxNq w_sgxNr ww15_sgxR3 ww16_sgxR4)
      of dt1_XgsF3
      { __DEFAULT ->
      case Data.Complex.$wphase @ a_sgxNq w_sgxNr ww15_sgxR3 ww16_sgxR4
      of dt2_XgsF8
      { __DEFAULT ->
      case negate @ a_sgxNq $dNum_sguh5 dt1_XgsF3 of dt3_XgsIZ
      { __DEFAULT ->
      (# dt2_XgsF8, dt3_XgsIZ #)
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$casin [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LC(S)LLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxNq)
                 (w_sgxNr [Occ=Once] :: RealFloat a_sgxNq)
                 (w1_sgxNs [Occ=Once!] :: Complex a_sgxNq) ->
                 case w1_sgxNs of { :+ ww1_sgxNv [Occ=Once] ww2_sgxNw [Occ=Once] ->
                 case Data.Complex.$w$casin @ a_sgxNq w_sgxNr ww1_sgxNv ww2_sgxNw of
                 { (# ww4_sgxSH [Occ=Once], ww5_sgxSI [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxNq ww4_sgxSH ww5_sgxSI
                 }
                 }}]
Data.Complex.$fFloatingComplex_$casin
  = \ (@ a_sgxNq)
      (w_sgxNr :: RealFloat a_sgxNq)
      (w1_sgxNs :: Complex a_sgxNq) ->
      case w1_sgxNs of { :+ ww1_sgxNv ww2_sgxNw ->
      case Data.Complex.$w$casin @ a_sgxNq w_sgxNr ww1_sgxNv ww2_sgxNw of
      { (# ww4_sgxSH, ww5_sgxSI #) ->
      Data.Complex.:+ @ a_sgxNq ww4_sgxSH ww5_sgxSI
      }
      }

-- RHS size: {terms: 52, types: 20, coercions: 0, joins: 0/0}
Data.Complex.$w$s$catanh1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Float# -> GHC.Prim.Float# -> (# Float, Float #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 193 30}]
Data.Complex.$w$s$catanh1
  = \ (ww_sgxNV :: GHC.Prim.Float#) (ww1_sgxO0 :: GHC.Prim.Float#) ->
      case Data.Complex.$w$s$c/1
             (GHC.Prim.plusFloat# 1.0# ww_sgxNV)
             ww1_sgxO0
             (GHC.Prim.minusFloat# 1.0# ww_sgxNV)
             (GHC.Prim.minusFloat# 0.0# ww1_sgxO0)
      of
      { (# ww3_sgxQb, ww4_sgxQc #) ->
      case ww3_sgxQb of { GHC.Types.F# ww6_sgzlj ->
      case ww4_sgxQc of { GHC.Types.F# ww8_sgzlm ->
      case Data.Complex.$w$smagnitude1 ww6_sgzlj ww8_sgzlm of ww9_sgxyg
      { __DEFAULT ->
      case GHC.Prim.logFloat# ww9_sgxyg of wild1_igtz0 { __DEFAULT ->
      case Data.Complex.$w$sphase1 ww6_sgzlj ww8_sgzlm of ww10_sgxxv
      { __DEFAULT ->
      (# GHC.Types.F#
           (GHC.Prim.minusFloat#
              (GHC.Prim.timesFloat# 0.5# wild1_igtz0)
              (GHC.Prim.timesFloat# 0.0# ww10_sgxxv)),
         GHC.Types.F#
           (GHC.Prim.plusFloat#
              (GHC.Prim.timesFloat# 0.5# ww10_sgxxv)
              (GHC.Prim.timesFloat# 0.0# wild1_igtz0)) #)
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$catanh1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxNP [Occ=Once!] :: Complex Float) ->
                 case w_sgxNP of { :+ ww1_sgxNS [Occ=Once!] ww2_sgxNX [Occ=Once!] ->
                 case ww1_sgxNS of { GHC.Types.F# ww4_sgxNV [Occ=Once] ->
                 case ww2_sgxNX of { GHC.Types.F# ww6_sgxO0 [Occ=Once] ->
                 case Data.Complex.$w$s$catanh1 ww4_sgxNV ww6_sgxO0 of
                 { (# ww8_sgxSK [Occ=Once], ww9_sgxSL [Occ=Once] #) ->
                 Data.Complex.:+ @ Float ww8_sgxSK ww9_sgxSL
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$catanh1
  = \ (w_sgxNP :: Complex Float) ->
      case w_sgxNP of { :+ ww1_sgxNS ww2_sgxNX ->
      case ww1_sgxNS of { GHC.Types.F# ww4_sgzlp ->
      case ww2_sgxNX of { GHC.Types.F# ww6_sgzls ->
      case Data.Complex.$w$s$catanh1 ww4_sgzlp ww6_sgzls of
      { (# ww8_sgxSK, ww9_sgxSL #) ->
      Data.Complex.:+ @ Float ww8_sgxSK ww9_sgxSL
      }
      }
      }
      }

-- RHS size: {terms: 52, types: 20, coercions: 0, joins: 0/0}
Data.Complex.$w$s$catanh [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Double# -> GHC.Prim.Double# -> (# Double, Double #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 193 30}]
Data.Complex.$w$s$catanh
  = \ (ww_sgxOq :: GHC.Prim.Double#)
      (ww1_sgxOv :: GHC.Prim.Double#) ->
      case Data.Complex.$w$s$c/
             (GHC.Prim.+## 1.0## ww_sgxOq)
             ww1_sgxOv
             (GHC.Prim.-## 1.0## ww_sgxOq)
             (GHC.Prim.-## 0.0## ww1_sgxOv)
      of
      { (# ww3_sgxQR, ww4_sgxQS #) ->
      case ww3_sgxQR of { GHC.Types.D# ww6_sgzlv ->
      case ww4_sgxQS of { GHC.Types.D# ww8_sgzly ->
      case Data.Complex.$w$smagnitude ww6_sgzlv ww8_sgzly of ww9_sgxxX
      { __DEFAULT ->
      case GHC.Prim.logDouble# ww9_sgxxX of wild1_igtzm { __DEFAULT ->
      case Data.Complex.$w$sphase ww6_sgzlv ww8_sgzly of ww10_sgxxd
      { __DEFAULT ->
      (# GHC.Types.D#
           (GHC.Prim.-##
              (GHC.Prim.*## 0.5## wild1_igtzm) (GHC.Prim.*## 0.0## ww10_sgxxd)),
         GHC.Types.D#
           (GHC.Prim.+##
              (GHC.Prim.*## 0.5## ww10_sgxxd)
              (GHC.Prim.*## 0.0## wild1_igtzm)) #)
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$catanh [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxOk [Occ=Once!] :: Complex Double) ->
                 case w_sgxOk of { :+ ww1_sgxOn [Occ=Once!] ww2_sgxOs [Occ=Once!] ->
                 case ww1_sgxOn of { GHC.Types.D# ww4_sgxOq [Occ=Once] ->
                 case ww2_sgxOs of { GHC.Types.D# ww6_sgxOv [Occ=Once] ->
                 case Data.Complex.$w$s$catanh ww4_sgxOq ww6_sgxOv of
                 { (# ww8_sgxSN [Occ=Once], ww9_sgxSO [Occ=Once] #) ->
                 Data.Complex.:+ @ Double ww8_sgxSN ww9_sgxSO
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$catanh
  = \ (w_sgxOk :: Complex Double) ->
      case w_sgxOk of { :+ ww1_sgxOn ww2_sgxOs ->
      case ww1_sgxOn of { GHC.Types.D# ww4_sgzlB ->
      case ww2_sgxOs of { GHC.Types.D# ww6_sgzlE ->
      case Data.Complex.$w$s$catanh ww4_sgzlB ww6_sgzlE of
      { (# ww8_sgxSN, ww9_sgxSO #) ->
      Data.Complex.:+ @ Double ww8_sgxSN ww9_sgxSO
      }
      }
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex20 :: GHC.Real.Ratio Integer
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fFloatingComplex20
  = GHC.Real.:%
      @ Integer
      Data.Complex.$fFloatingComplex19
      Data.Complex.$fFloatingComplex21

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex18 :: GHC.Real.Ratio Integer
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fFloatingComplex18
  = GHC.Real.:%
      @ Integer
      Data.Complex.$fFloatingComplex19
      Data.Complex.$fFloatingComplex19

-- RHS size: {terms: 59, types: 53, coercions: 0, joins: 0/0}
Data.Complex.$w$catanh [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LC(S))LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,1*C1(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 500 0}]
Data.Complex.$w$catanh
  = \ (@ a_sgxOH)
      (w_sgxOI :: RealFloat a_sgxOH)
      (ww_sgxOM
         :: a_sgxOH
         Unf=OtherCon [])
      (ww1_sgxON
         :: a_sgxOH
         Unf=OtherCon []) ->
      case Data.Complex.$w$cfromRational
             @ a_sgxOH w_sgxOI Data.Complex.$fFloatingComplex20
      of
      { (# ww3_sgxQX, ww4_sgxQY #) ->
      case Data.Complex.$w$cfromRational
             @ a_sgxOH w_sgxOI Data.Complex.$fFloatingComplex18
      of
      { (# ww6_Xgy51, ww7_Xgy53 #) ->
      case Data.Complex.$w$c+
             @ a_sgxOH w_sgxOI ww6_Xgy51 ww7_Xgy53 ww_sgxOM ww1_sgxON
      of
      { (# ww9_sgxR3, ww10_sgxR4 #) ->
      case Data.Complex.$w$c-
             @ a_sgxOH w_sgxOI ww6_Xgy51 ww7_Xgy53 ww_sgxOM ww1_sgxON
      of
      { (# ww12_sgxR9, ww13_sgxRa #) ->
      case Data.Complex.$w$c/
             @ a_sgxOH w_sgxOI ww9_sgxR3 ww10_sgxR4 ww12_sgxR9 ww13_sgxRa
      of
      { (# ww15_sgxQU, ww16_sgxQV #) ->
      case log
             @ a_sgxOH
             (GHC.Float.$p2RealFloat @ a_sgxOH w_sgxOI)
             (Data.Complex.$wmagnitude @ a_sgxOH w_sgxOI ww15_sgxQU ww16_sgxQV)
      of dt_XgsF3
      { __DEFAULT ->
      case Data.Complex.$wphase @ a_sgxOH w_sgxOI ww15_sgxQU ww16_sgxQV
      of dt1_XgsF8
      { __DEFAULT ->
      Data.Complex.$w$c*
        @ a_sgxOH w_sgxOI ww3_sgxQX ww4_sgxQY dt_XgsF3 dt1_XgsF8
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$catanh [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(C(C(S))C(C(S))LLLLC(S))S(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LC(S))LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxOH)
                 (w_sgxOI [Occ=Once] :: RealFloat a_sgxOH)
                 (w1_sgxOJ [Occ=Once!] :: Complex a_sgxOH) ->
                 case w1_sgxOJ of { :+ ww1_sgxOM [Occ=Once] ww2_sgxON [Occ=Once] ->
                 case Data.Complex.$w$catanh @ a_sgxOH w_sgxOI ww1_sgxOM ww2_sgxON
                 of
                 { (# ww4_sgxSQ [Occ=Once], ww5_sgxSR [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxOH ww4_sgxSQ ww5_sgxSR
                 }
                 }}]
Data.Complex.$fFloatingComplex_$catanh
  = \ (@ a_sgxOH)
      (w_sgxOI :: RealFloat a_sgxOH)
      (w1_sgxOJ :: Complex a_sgxOH) ->
      case w1_sgxOJ of { :+ ww1_sgxOM ww2_sgxON ->
      case Data.Complex.$w$catanh @ a_sgxOH w_sgxOI ww1_sgxOM ww2_sgxON
      of
      { (# ww4_sgxSQ, ww5_sgxSR #) ->
      Data.Complex.:+ @ a_sgxOH ww4_sgxSQ ww5_sgxSR
      }
      }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_nan :: Double
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 11 20}]
Data.Complex.$fFloatingComplex_nan
  = case GHC.Prim./## 0.0## 0.0## of wild2_igtAA { __DEFAULT ->
    GHC.Types.D# wild2_igtAA
    }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_inf :: Double
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 11 20}]
Data.Complex.$fFloatingComplex_inf
  = case GHC.Prim./## 1.0## 0.0## of wild2_igtAA { __DEFAULT ->
    GHC.Types.D# wild2_igtAA
    }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex6 :: Complex Double
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fFloatingComplex6
  = Data.Complex.:+
      @ Double
      Data.Complex.$fFloatingComplex_nan
      Data.Complex.$fFloatingComplex_nan

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex5 :: Complex Double
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=True, Expandable=False, Guidance=IF_ARGS [] 10 0}]
Data.Complex.$fFloatingComplex5
  = case Data.Complex.$fFloatingComplex_nan of
    { GHC.Types.D# ipv_sguPi ->
    Data.Complex.$fFloatingComplex6
    }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex8 :: Complex Double
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fFloatingComplex8
  = Data.Complex.:+
      @ Double
      Data.Complex.$fFloatingComplex_inf
      Data.Complex.$fFloatingComplex1

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex7 :: Complex Double
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=True, Expandable=False, Guidance=IF_ARGS [] 10 0}]
Data.Complex.$fFloatingComplex7
  = case Data.Complex.$fFloatingComplex_inf of
    { GHC.Types.D# ipv_sguPl ->
    Data.Complex.$fFloatingComplex8
    }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex3 :: Double
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Complex.$fFloatingComplex3 = GHC.Types.D# 1.0##

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex2 :: Complex Double
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fFloatingComplex2
  = Data.Complex.:+
      @ Double
      Data.Complex.$fFloatingComplex3
      Data.Complex.$fFloatingComplex1

-- RHS size: {terms: 154, types: 60, coercions: 0, joins: 2/4}
Data.Complex.$w$s$c** [InlPrag=NOUSERINLINE[0]]
  :: Complex Double
     -> GHC.Prim.Double# -> GHC.Prim.Double# -> Complex Double
[GblId,
 Arity=3,
 Str=<L,1*U(U(U),U(U))><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 0 0] 470 0}]
Data.Complex.$w$s$c**
  = \ (w_sgxOV :: Complex Double)
      (ww_sgxP2 :: GHC.Prim.Double#)
      (ww1_sgxP7 :: GHC.Prim.Double#) ->
      join {
        fail_sgugV [Dmd=<L,1*C1(U(U,U))>]
          :: GHC.Prim.Void# -> Complex Double
        [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
        fail_sgugV _ [Occ=Dead, OS=OneShot]
          = case w_sgxOV of { :+ ds1_dgtdW ds2_dgtdX ->
            case ds2_dgtdX of { GHC.Types.D# ds4_sgzlN ->
            case ds1_dgtdW of { GHC.Types.D# ds6_sgzlQ ->
            join {
              fail1_sgugZ [Dmd=<L,1*C1(U(U,U))>]
                :: GHC.Prim.Void# -> Complex Double
              [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
              fail1_sgugZ _ [Occ=Dead, OS=OneShot]
                = case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_igtEG
                         ds6_sgzlQ GHC.Prim.realWorld#
                  of
                  { (# ds8_igtEL, ds9_igtEM #) ->
                  case ds9_igtEM of {
                    __DEFAULT ->
                      case GHC.Prim.<## ww_sgxP2 0.0## of {
                        __DEFAULT ->
                          case GHC.Prim.==## ww_sgxP2 0.0## of {
                            __DEFAULT -> Data.Complex.$fFloatingComplex7;
                            1# -> Data.Complex.$fFloatingComplex5
                          };
                        1# -> Data.Complex.$fFloatingComplex4
                      };
                    0# ->
                      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_igtEG
                             ds4_sgzlN GHC.Prim.realWorld#
                      of
                      { (# ds10_XgtYQ, ds11_XgtYS #) ->
                      case ds11_XgtYS of {
                        __DEFAULT ->
                          case GHC.Prim.<## ww_sgxP2 0.0## of {
                            __DEFAULT ->
                              case GHC.Prim.==## ww_sgxP2 0.0## of {
                                __DEFAULT -> Data.Complex.$fFloatingComplex7;
                                1# -> Data.Complex.$fFloatingComplex5
                              };
                            1# -> Data.Complex.$fFloatingComplex4
                          };
                        0# ->
                          case Data.Complex.$w$smagnitude ds6_sgzlQ ds4_sgzlN of ww2_sgxxX
                          { __DEFAULT ->
                          case GHC.Prim.logDouble# ww2_sgxxX of wild5_igtzm { __DEFAULT ->
                          case Data.Complex.$w$sphase ds6_sgzlQ ds4_sgzlN of ww3_sgxxd
                          { __DEFAULT ->
                          let {
                            y_sgv5k :: GHC.Prim.Double#
                            [LclId]
                            y_sgv5k
                              = GHC.Prim.+##
                                  (GHC.Prim.*## wild5_igtzm ww1_sgxP7)
                                  (GHC.Prim.*## ww3_sgxxd ww_sgxP2) } in
                          let {
                            expx_sguIB :: GHC.Prim.Double#
                            [LclId]
                            expx_sguIB
                              = GHC.Prim.expDouble#
                                  (GHC.Prim.-##
                                     (GHC.Prim.*## wild5_igtzm ww_sgxP2)
                                     (GHC.Prim.*## ww3_sgxxd ww1_sgxP7)) } in
                          Data.Complex.:+
                            @ Double
                            (GHC.Types.D#
                               (GHC.Prim.*## expx_sguIB (GHC.Prim.cosDouble# y_sgv5k)))
                            (GHC.Types.D#
                               (GHC.Prim.*## expx_sguIB (GHC.Prim.sinDouble# y_sgv5k)))
                          }
                          }
                          }
                      }
                      }
                  }
                  } } in
            case GHC.Prim.==## ds6_sgzlQ 0.0## of {
              __DEFAULT -> jump fail1_sgugZ GHC.Prim.void#;
              1# ->
                case GHC.Prim.==## ds4_sgzlN 0.0## of {
                  __DEFAULT -> jump fail1_sgugZ GHC.Prim.void#;
                  1# ->
                    case GHC.Prim.<## ww_sgxP2 0.0## of {
                      __DEFAULT ->
                        case GHC.Prim.==## ww_sgxP2 0.0## of {
                          __DEFAULT -> Data.Complex.$fFloatingComplex4;
                          1# -> Data.Complex.$fFloatingComplex5
                        };
                      1# -> Data.Complex.$fFloatingComplex7
                    }
                }
            }
            }
            }
            } } in
      case GHC.Prim.==## ww_sgxP2 0.0## of {
        __DEFAULT -> jump fail_sgugV GHC.Prim.void#;
        1# ->
          case GHC.Prim.==## ww1_sgxP7 0.0## of {
            __DEFAULT -> jump fail_sgugV GHC.Prim.void#;
            1# -> Data.Complex.$fFloatingComplex2
          }
      }

-- RHS size: {terms: 15, types: 12, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$c** [InlPrag=NOUSERINLINE[0]]
  :: Complex Double -> Complex Double -> Complex Double
[GblId,
 Arity=2,
 Str=<L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxOV [Occ=Once] :: Complex Double)
                 (w1_sgxOW [Occ=Once!] :: Complex Double) ->
                 case w1_sgxOW of
                 { :+ ww1_sgxOZ [Occ=Once!] ww2_sgxP4 [Occ=Once!] ->
                 case ww1_sgxOZ of { GHC.Types.D# ww4_sgxP2 [Occ=Once] ->
                 case ww2_sgxP4 of { GHC.Types.D# ww6_sgxP7 [Occ=Once] ->
                 Data.Complex.$w$s$c** w_sgxOV ww4_sgxP2 ww6_sgxP7
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$c**
  = \ (w_sgxOV :: Complex Double) (w1_sgxOW :: Complex Double) ->
      case w1_sgxOW of { :+ ww1_sgxOZ ww2_sgxP4 ->
      case ww1_sgxOZ of { GHC.Types.D# ww4_sgzlT ->
      case ww2_sgxP4 of { GHC.Types.D# ww6_sgzlW ->
      Data.Complex.$w$s$c** w_sgxOV ww4_sgzlT ww6_sgzlW
      }
      }
      }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_nan1 :: Float
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 11 20}]
Data.Complex.$fFloatingComplex_nan1
  = case GHC.Prim.divideFloat# 0.0# 0.0# of wild2_igtwv
    { __DEFAULT ->
    GHC.Types.F# wild2_igtwv
    }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_inf1 :: Float
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 11 20}]
Data.Complex.$fFloatingComplex_inf1
  = case GHC.Prim.divideFloat# 1.0# 0.0# of wild2_igtwv
    { __DEFAULT ->
    GHC.Types.F# wild2_igtwv
    }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex14 :: Complex Float
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fFloatingComplex14
  = Data.Complex.:+
      @ Float
      Data.Complex.$fFloatingComplex_nan1
      Data.Complex.$fFloatingComplex_nan1

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex13 :: Complex Float
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=True, Expandable=False, Guidance=IF_ARGS [] 10 0}]
Data.Complex.$fFloatingComplex13
  = case Data.Complex.$fFloatingComplex_nan1 of
    { GHC.Types.F# ipv_sguPX ->
    Data.Complex.$fFloatingComplex14
    }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex16 :: Complex Float
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fFloatingComplex16
  = Data.Complex.:+
      @ Float
      Data.Complex.$fFloatingComplex_inf1
      Data.Complex.$fFloatingComplex9

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex15 :: Complex Float
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=True, Expandable=False, Guidance=IF_ARGS [] 10 0}]
Data.Complex.$fFloatingComplex15
  = case Data.Complex.$fFloatingComplex_inf1 of
    { GHC.Types.F# ipv_sguQ0 ->
    Data.Complex.$fFloatingComplex16
    }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex11 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Complex.$fFloatingComplex11 = GHC.Types.F# 1.0#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex10 :: Complex Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Complex.$fFloatingComplex10
  = Data.Complex.:+
      @ Float
      Data.Complex.$fFloatingComplex11
      Data.Complex.$fFloatingComplex9

-- RHS size: {terms: 154, types: 60, coercions: 0, joins: 2/4}
Data.Complex.$w$s$c**1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float
     -> GHC.Prim.Float# -> GHC.Prim.Float# -> Complex Float
[GblId,
 Arity=3,
 Str=<L,1*U(U(U),U(U))><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 0 0] 470 0}]
Data.Complex.$w$s$c**1
  = \ (w_sgxPd :: Complex Float)
      (ww_sgxPk :: GHC.Prim.Float#)
      (ww1_sgxPp :: GHC.Prim.Float#) ->
      join {
        fail_sgugN [Dmd=<L,1*C1(U(U,U))>]
          :: GHC.Prim.Void# -> Complex Float
        [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
        fail_sgugN _ [Occ=Dead, OS=OneShot]
          = case w_sgxPd of { :+ ds1_dgtdW ds2_dgtdX ->
            case ds2_dgtdX of { GHC.Types.F# ds4_sgzm5 ->
            case ds1_dgtdW of { GHC.Types.F# ds6_sgzm8 ->
            join {
              fail1_sgugR [Dmd=<L,1*C1(U(U,U))>]
                :: GHC.Prim.Void# -> Complex Float
              [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
              fail1_sgugR _ [Occ=Dead, OS=OneShot]
                = case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_igtE4
                         ds6_sgzm8 GHC.Prim.realWorld#
                  of
                  { (# ds8_igtE9, ds9_igtEa #) ->
                  case ds9_igtEa of {
                    __DEFAULT ->
                      case GHC.Prim.ltFloat# ww_sgxPk 0.0# of {
                        __DEFAULT ->
                          case GHC.Prim.eqFloat# ww_sgxPk 0.0# of {
                            __DEFAULT -> Data.Complex.$fFloatingComplex15;
                            1# -> Data.Complex.$fFloatingComplex13
                          };
                        1# -> Data.Complex.$fFloatingComplex12
                      };
                    0# ->
                      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Int# #)}_igtE4
                             ds4_sgzm5 GHC.Prim.realWorld#
                      of
                      { (# ds10_XgtYE, ds11_XgtYG #) ->
                      case ds11_XgtYG of {
                        __DEFAULT ->
                          case GHC.Prim.ltFloat# ww_sgxPk 0.0# of {
                            __DEFAULT ->
                              case GHC.Prim.eqFloat# ww_sgxPk 0.0# of {
                                __DEFAULT -> Data.Complex.$fFloatingComplex15;
                                1# -> Data.Complex.$fFloatingComplex13
                              };
                            1# -> Data.Complex.$fFloatingComplex12
                          };
                        0# ->
                          case Data.Complex.$w$smagnitude1 ds6_sgzm8 ds4_sgzm5 of ww2_sgxyg
                          { __DEFAULT ->
                          case GHC.Prim.logFloat# ww2_sgxyg of wild5_igtz0 { __DEFAULT ->
                          case Data.Complex.$w$sphase1 ds6_sgzm8 ds4_sgzm5 of ww3_sgxxv
                          { __DEFAULT ->
                          let {
                            y_sgv5Q :: GHC.Prim.Float#
                            [LclId]
                            y_sgv5Q
                              = GHC.Prim.plusFloat#
                                  (GHC.Prim.timesFloat# wild5_igtz0 ww1_sgxPp)
                                  (GHC.Prim.timesFloat# ww3_sgxxv ww_sgxPk) } in
                          let {
                            expx_sguGv :: GHC.Prim.Float#
                            [LclId]
                            expx_sguGv
                              = GHC.Prim.expFloat#
                                  (GHC.Prim.minusFloat#
                                     (GHC.Prim.timesFloat# wild5_igtz0 ww_sgxPk)
                                     (GHC.Prim.timesFloat# ww3_sgxxv ww1_sgxPp)) } in
                          Data.Complex.:+
                            @ Float
                            (GHC.Types.F#
                               (GHC.Prim.timesFloat# expx_sguGv (GHC.Prim.cosFloat# y_sgv5Q)))
                            (GHC.Types.F#
                               (GHC.Prim.timesFloat# expx_sguGv (GHC.Prim.sinFloat# y_sgv5Q)))
                          }
                          }
                          }
                      }
                      }
                  }
                  } } in
            case GHC.Prim.eqFloat# ds6_sgzm8 0.0# of {
              __DEFAULT -> jump fail1_sgugR GHC.Prim.void#;
              1# ->
                case GHC.Prim.eqFloat# ds4_sgzm5 0.0# of {
                  __DEFAULT -> jump fail1_sgugR GHC.Prim.void#;
                  1# ->
                    case GHC.Prim.ltFloat# ww_sgxPk 0.0# of {
                      __DEFAULT ->
                        case GHC.Prim.eqFloat# ww_sgxPk 0.0# of {
                          __DEFAULT -> Data.Complex.$fFloatingComplex12;
                          1# -> Data.Complex.$fFloatingComplex13
                        };
                      1# -> Data.Complex.$fFloatingComplex15
                    }
                }
            }
            }
            }
            } } in
      case GHC.Prim.eqFloat# ww_sgxPk 0.0# of {
        __DEFAULT -> jump fail_sgugN GHC.Prim.void#;
        1# ->
          case GHC.Prim.eqFloat# ww1_sgxPp 0.0# of {
            __DEFAULT -> jump fail_sgugN GHC.Prim.void#;
            1# -> Data.Complex.$fFloatingComplex10
          }
      }

-- RHS size: {terms: 15, types: 12, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$c**1 [InlPrag=NOUSERINLINE[0]]
  :: Complex Float -> Complex Float -> Complex Float
[GblId,
 Arity=2,
 Str=<L,1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sgxPd [Occ=Once] :: Complex Float)
                 (w1_sgxPe [Occ=Once!] :: Complex Float) ->
                 case w1_sgxPe of
                 { :+ ww1_sgxPh [Occ=Once!] ww2_sgxPm [Occ=Once!] ->
                 case ww1_sgxPh of { GHC.Types.F# ww4_sgxPk [Occ=Once] ->
                 case ww2_sgxPm of { GHC.Types.F# ww6_sgxPp [Occ=Once] ->
                 Data.Complex.$w$s$c**1 w_sgxPd ww4_sgxPk ww6_sgxPp
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$c**1
  = \ (w_sgxPd :: Complex Float) (w1_sgxPe :: Complex Float) ->
      case w1_sgxPe of { :+ ww1_sgxPh ww2_sgxPm ->
      case ww1_sgxPh of { GHC.Types.F# ww4_sgzmb ->
      case ww2_sgxPm of { GHC.Types.F# ww6_sgzme ->
      Data.Complex.$w$s$c**1 w_sgxPd ww4_sgzmb ww6_sgzme
      }
      }
      }

-- RHS size: {terms: 208, types: 140, coercions: 0, joins: 3/11}
Data.Complex.$w$c** [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> a -> a -> (# a, a #)
[GblId,
 Arity=4,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))><L,1*U(U,U)><L,U><L,U>,
 Unf=OtherCon []]
Data.Complex.$w$c**
  = \ (@ a_sgxPv)
      (w_sgxPw :: RealFloat a_sgxPv)
      (w1_sgxPx :: Complex a_sgxPv)
      (ww_sgxPB
         :: a_sgxPv
         Unf=OtherCon [])
      (ww1_sgxPC
         :: a_sgxPv
         Unf=OtherCon []) ->
      let {
        $dRealFrac_sgugH [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),1*U(A,C(C1(U)),A,A),A,A,A,A,A)>]
          :: RealFrac a_sgxPv
        [LclId]
        $dRealFrac_sgugH = GHC.Float.$p1RealFloat @ a_sgxPv w_sgxPw } in
      let {
        $dReal_sgugG [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A)>]
          :: Real a_sgxPv
        [LclId]
        $dReal_sgugG = GHC.Real.$p1RealFrac @ a_sgxPv $dRealFrac_sgugH } in
      let {
        $dOrd_sgugE [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A)>]
          :: Ord a_sgxPv
        [LclId]
        $dOrd_sgugE = GHC.Real.$p2Real @ a_sgxPv $dReal_sgugG } in
      let {
        $dEq_sgugD [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq a_sgxPv
        [LclId]
        $dEq_sgugD = GHC.Classes.$p1Ord @ a_sgxPv $dOrd_sgugE } in
      let {
        $dNum_sgugF [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: Num a_sgxPv
        [LclId]
        $dNum_sgugF = GHC.Real.$p1Real @ a_sgxPv $dReal_sgugG } in
      join {
        fail_sgugz [Dmd=<L,1*C1(U(U,U))>]
          :: GHC.Prim.Void# -> (# a_sgxPv, a_sgxPv #)
        [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
        fail_sgugz _ [Occ=Dead, OS=OneShot]
          = case w1_sgxPx of { :+ ds1_dgtdW ds2_dgtdX ->
            let {
              $dFractional_sgugC [Dmd=<L,U(A,C(C1(U)),A,A)>]
                :: Fractional a_sgxPv
              [LclId]
              $dFractional_sgugC
                = GHC.Real.$p2RealFrac @ a_sgxPv $dRealFrac_sgugH } in
            let {
              nan_sgugB [Dmd=<L,1*U>] :: a_sgxPv
              [LclId]
              nan_sgugB
                = / @ a_sgxPv
                    $dFractional_sgugC
                    (fromInteger
                       @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17)
                    (fromInteger
                       @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17) } in
            let {
              inf_sgugA [Dmd=<L,1*U>] :: a_sgxPv
              [LclId]
              inf_sgugA
                = / @ a_sgxPv
                    $dFractional_sgugC
                    (fromInteger
                       @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex19)
                    (fromInteger
                       @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17) } in
            join {
              fail1_sgugJ [Dmd=<L,1*C1(U(U,U))>]
                :: GHC.Prim.Void# -> (# a_sgxPv, a_sgxPv #)
              [LclId[JoinId(1)], Arity=1, Str=<L,A>, Unf=OtherCon []]
              fail1_sgugJ _ [Occ=Dead, OS=OneShot]
                = join {
                    $j_sguQC [Dmd=<L,1*U(U,U)>] :: (# a_sgxPv, a_sgxPv #)
                    [LclId[JoinId(0)]]
                    $j_sguQC
                      = case compare
                               @ a_sgxPv
                               $dOrd_sgugE
                               ww_sgxPB
                               (fromInteger
                                  @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17)
                        of {
                          LT ->
                            case fromInteger
                                   @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17
                            of dt_XgsL4
                            { __DEFAULT ->
                            (# dt_XgsL4, dt_XgsL4 #)
                            };
                          EQ ->
                            case nan_sgugB of dt_Xgsqi { __DEFAULT ->
                            (# dt_Xgsqi, dt_Xgsqi #)
                            };
                          GT ->
                            case inf_sgugA of dt_XgsL4 { __DEFAULT ->
                            case fromInteger
                                   @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17
                            of dt1_XgsL9
                            { __DEFAULT ->
                            (# dt_XgsL4, dt1_XgsL9 #)
                            }
                            }
                        } } in
                  case isInfinite @ a_sgxPv w_sgxPw ds1_dgtdW of {
                    False ->
                      case isInfinite @ a_sgxPv w_sgxPw ds2_dgtdX of {
                        False ->
                          case Data.Complex.$w$clog @ a_sgxPv w_sgxPw ds1_dgtdW ds2_dgtdX of
                          { (# ww3_sgxQC, ww4_sgxQD #) ->
                          case Data.Complex.$w$c*
                                 @ a_sgxPv w_sgxPw ww3_sgxQC ww4_sgxQD ww_sgxPB ww1_sgxPC
                          of
                          { (# ww6_sgxRf, ww7_sgxRg #) ->
                          Data.Complex.$w$cexp @ a_sgxPv w_sgxPw ww6_sgxRf ww7_sgxRg
                          }
                          };
                        True -> jump $j_sguQC
                      };
                    True -> jump $j_sguQC
                  } } in
            case ==
                   @ a_sgxPv
                   $dEq_sgugD
                   ds1_dgtdW
                   (fromInteger
                      @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17)
            of {
              False -> jump fail1_sgugJ GHC.Prim.void#;
              True ->
                case ==
                       @ a_sgxPv
                       $dEq_sgugD
                       ds2_dgtdX
                       (fromInteger
                          @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17)
                of {
                  False -> jump fail1_sgugJ GHC.Prim.void#;
                  True ->
                    case compare
                           @ a_sgxPv
                           $dOrd_sgugE
                           ww_sgxPB
                           (fromInteger
                              @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17)
                    of {
                      LT ->
                        case inf_sgugA of dt_XgsL8 { __DEFAULT ->
                        case fromInteger
                               @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17
                        of dt1_XgsLd
                        { __DEFAULT ->
                        (# dt_XgsL8, dt1_XgsLd #)
                        }
                        };
                      EQ ->
                        case nan_sgugB of dt_Xgsqi { __DEFAULT ->
                        (# dt_Xgsqi, dt_Xgsqi #)
                        };
                      GT ->
                        case fromInteger
                               @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17
                        of dt_XgsL8
                        { __DEFAULT ->
                        (# dt_XgsL8, dt_XgsL8 #)
                        }
                    }
                }
            }
            } } in
      case ==
             @ a_sgxPv
             $dEq_sgugD
             ww_sgxPB
             (fromInteger
                @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17)
      of {
        False -> jump fail_sgugz GHC.Prim.void#;
        True ->
          case ==
                 @ a_sgxPv
                 $dEq_sgugD
                 ww1_sgxPC
                 (fromInteger
                    @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17)
          of {
            False -> jump fail_sgugz GHC.Prim.void#;
            True ->
              case fromInteger
                     @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex19
              of dt_XgsKX
              { __DEFAULT ->
              case fromInteger
                     @ a_sgxPv $dNum_sgugF Data.Complex.$fFloatingComplex17
              of dt1_XgsL2
              { __DEFAULT ->
              (# dt_XgsKX, dt1_XgsL2 #)
              }
              }
          }
      }

-- RHS size: {terms: 17, types: 21, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$c** [InlPrag=NOUSERINLINE[0]]
  :: forall a. RealFloat a => Complex a -> Complex a -> Complex a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))><L,1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sgxPv)
                 (w_sgxPw [Occ=Once] :: RealFloat a_sgxPv)
                 (w1_sgxPx [Occ=Once] :: Complex a_sgxPv)
                 (w2_sgxPy [Occ=Once!] :: Complex a_sgxPv) ->
                 case w2_sgxPy of { :+ ww1_sgxPB [Occ=Once] ww2_sgxPC [Occ=Once] ->
                 case Data.Complex.$w$c**
                        @ a_sgxPv w_sgxPw w1_sgxPx ww1_sgxPB ww2_sgxPC
                 of
                 { (# ww4_sgxST [Occ=Once], ww5_sgxSU [Occ=Once] #) ->
                 Data.Complex.:+ @ a_sgxPv ww4_sgxST ww5_sgxSU
                 }
                 }}]
Data.Complex.$fFloatingComplex_$c**
  = \ (@ a_sgxPv)
      (w_sgxPw :: RealFloat a_sgxPv)
      (w1_sgxPx :: Complex a_sgxPv)
      (w2_sgxPy :: Complex a_sgxPv) ->
      case w2_sgxPy of { :+ ww1_sgxPB ww2_sgxPC ->
      case Data.Complex.$w$c**
             @ a_sgxPv w_sgxPw w1_sgxPx ww1_sgxPB ww2_sgxPC
      of
      { (# ww4_sgxST, ww5_sgxSU #) ->
      Data.Complex.:+ @ a_sgxPv ww4_sgxST ww5_sgxSU
      }
      }

-- RHS size: {terms: 71, types: 27, coercions: 0, joins: 0/3}
Data.Complex.$fFloatingComplex_$s$cexpm2 [InlPrag=INLINE (sat-args=1)]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_agsoR [Occ=Once!] :: Complex Float) ->
                 case x_agsoR of { :+ a_agsoS [Occ=Once!] b_agsoT [Occ=Once!] ->
                 case a_agsoS of { GHC.Types.F# x1_igtuu ->
                 case b_agsoT of { GHC.Types.F# x2_XgtPj ->
                 case GHC.Prim.ltFloat#
                        (GHC.Prim.plusFloat#
                           (GHC.Prim.timesFloat# x1_igtuu x1_igtuu)
                           (GHC.Prim.timesFloat# x2_XgtPj x2_XgtPj))
                        1.0#
                 of {
                   __DEFAULT ->
                     let {
                       expx_sguGv :: GHC.Prim.Float#
                       [LclId]
                       expx_sguGv = GHC.Prim.expFloat# x1_igtuu } in
                     Data.Complex.:+
                       @ Float
                       (GHC.Types.F#
                          (GHC.Prim.minusFloat#
                             (GHC.Prim.timesFloat# expx_sguGv (GHC.Prim.cosFloat# x2_XgtPj))
                             1.0#))
                       (GHC.Types.F#
                          (GHC.Prim.timesFloat# expx_sguGv (GHC.Prim.sinFloat# x2_XgtPj)));
                   1# ->
                     let {
                       v_sguRh :: GHC.Prim.Float#
                       [LclId]
                       v_sguRh
                         = GHC.Prim.sinFloat# (GHC.Prim.divideFloat# x2_XgtPj 2.0#) } in
                     let {
                       w_sguRi :: GHC.Prim.Float#
                       [LclId]
                       w_sguRi
                         = GHC.Prim.negateFloat#
                             (GHC.Prim.timesFloat#
                                (GHC.Prim.plusFloat# v_sguRh v_sguRh) v_sguRh) } in
                     case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_iguQV
                            x1_igtuu GHC.Prim.realWorld#
                     of
                     { (# _ [Occ=Dead], ds4_iguR1 #) ->
                     Data.Complex.$W:+
                       @ Float
                       (GHC.Types.F#
                          (GHC.Prim.plusFloat#
                             (GHC.Prim.plusFloat#
                                (GHC.Prim.timesFloat# ds4_iguR1 w_sguRi) ds4_iguR1)
                             w_sguRi))
                       (GHC.Types.F#
                          (GHC.Prim.timesFloat#
                             (GHC.Prim.plusFloat# ds4_iguR1 1.0#)
                             (GHC.Prim.sinFloat# x2_XgtPj)))
                     }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$cexpm2
  = \ (eta_X87 :: Complex Float) ->
      case eta_X87 of { :+ a_agsoS b_agsoT ->
      case a_agsoS of { GHC.Types.F# x_sgzmh ->
      case b_agsoT of { GHC.Types.F# x1_sgzmk ->
      case GHC.Prim.ltFloat#
             (GHC.Prim.plusFloat#
                (GHC.Prim.timesFloat# x_sgzmh x_sgzmh)
                (GHC.Prim.timesFloat# x1_sgzmk x1_sgzmk))
             1.0#
      of {
        __DEFAULT ->
          let {
            expx_sguGv :: GHC.Prim.Float#
            [LclId]
            expx_sguGv = GHC.Prim.expFloat# x_sgzmh } in
          Data.Complex.:+
            @ Float
            (GHC.Types.F#
               (GHC.Prim.minusFloat#
                  (GHC.Prim.timesFloat# expx_sguGv (GHC.Prim.cosFloat# x1_sgzmk))
                  1.0#))
            (GHC.Types.F#
               (GHC.Prim.timesFloat# expx_sguGv (GHC.Prim.sinFloat# x1_sgzmk)));
        1# ->
          case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_iguQV
                 x_sgzmh GHC.Prim.realWorld#
          of
          { (# ds3_iguR0, ds4_iguR1 #) ->
          let {
            v_sguR4 [Dmd=<S,U>] :: GHC.Prim.Float#
            [LclId]
            v_sguR4
              = GHC.Prim.sinFloat# (GHC.Prim.divideFloat# x1_sgzmk 2.0#) } in
          let {
            w_sguR5 :: GHC.Prim.Float#
            [LclId]
            w_sguR5
              = GHC.Prim.negateFloat#
                  (GHC.Prim.timesFloat#
                     (GHC.Prim.plusFloat# v_sguR4 v_sguR4) v_sguR4) } in
          Data.Complex.:+
            @ Float
            (GHC.Types.F#
               (GHC.Prim.plusFloat#
                  (GHC.Prim.plusFloat#
                     (GHC.Prim.timesFloat# ds4_iguR1 w_sguR5) ds4_iguR1)
                  w_sguR5))
            (GHC.Types.F#
               (GHC.Prim.timesFloat#
                  (GHC.Prim.plusFloat# ds4_iguR1 1.0#)
                  (GHC.Prim.sinFloat# x1_sgzmk)))
          }
      }
      }
      }
      }

-- RHS size: {terms: 71, types: 27, coercions: 0, joins: 0/3}
Data.Complex.$fFloatingComplex_$s$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_agsoR [Occ=Once!] :: Complex Double) ->
                 case x_agsoR of { :+ a_agsoS [Occ=Once!] b_agsoT [Occ=Once!] ->
                 case a_agsoS of { GHC.Types.D# x1_igtxN ->
                 case b_agsoT of { GHC.Types.D# x2_XgtSY ->
                 case GHC.Prim.<##
                        (GHC.Prim.+##
                           (GHC.Prim.*## x1_igtxN x1_igtxN) (GHC.Prim.*## x2_XgtSY x2_XgtSY))
                        1.0##
                 of {
                   __DEFAULT ->
                     let {
                       expx_sguIB :: GHC.Prim.Double#
                       [LclId]
                       expx_sguIB = GHC.Prim.expDouble# x1_igtxN } in
                     Data.Complex.:+
                       @ Double
                       (GHC.Types.D#
                          (GHC.Prim.-##
                             (GHC.Prim.*## expx_sguIB (GHC.Prim.cosDouble# x2_XgtSY)) 1.0##))
                       (GHC.Types.D#
                          (GHC.Prim.*## expx_sguIB (GHC.Prim.sinDouble# x2_XgtSY)));
                   1# ->
                     let {
                       v_sguRQ :: GHC.Prim.Double#
                       [LclId]
                       v_sguRQ = GHC.Prim.sinDouble# (GHC.Prim./## x2_XgtSY 2.0##) } in
                     let {
                       w_sguRR :: GHC.Prim.Double#
                       [LclId]
                       w_sguRR
                         = GHC.Prim.negateDouble#
                             (GHC.Prim.*## (GHC.Prim.+## v_sguRQ v_sguRQ) v_sguRQ) } in
                     case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_iguRu
                            x1_igtxN GHC.Prim.realWorld#
                     of
                     { (# _ [Occ=Dead], ds4_iguRA #) ->
                     Data.Complex.$W:+
                       @ Double
                       (GHC.Types.D#
                          (GHC.Prim.+##
                             (GHC.Prim.+## (GHC.Prim.*## ds4_iguRA w_sguRR) ds4_iguRA) w_sguRR))
                       (GHC.Types.D#
                          (GHC.Prim.*##
                             (GHC.Prim.+## ds4_iguRA 1.0##) (GHC.Prim.sinDouble# x2_XgtSY)))
                     }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$cexpm1
  = \ (eta_X87 :: Complex Double) ->
      case eta_X87 of { :+ a_agsoS b_agsoT ->
      case a_agsoS of { GHC.Types.D# x_sgzmn ->
      case b_agsoT of { GHC.Types.D# x1_sgzmq ->
      case GHC.Prim.<##
             (GHC.Prim.+##
                (GHC.Prim.*## x_sgzmn x_sgzmn) (GHC.Prim.*## x1_sgzmq x1_sgzmq))
             1.0##
      of {
        __DEFAULT ->
          let {
            expx_sguIB :: GHC.Prim.Double#
            [LclId]
            expx_sguIB = GHC.Prim.expDouble# x_sgzmn } in
          Data.Complex.:+
            @ Double
            (GHC.Types.D#
               (GHC.Prim.-##
                  (GHC.Prim.*## expx_sguIB (GHC.Prim.cosDouble# x1_sgzmq)) 1.0##))
            (GHC.Types.D#
               (GHC.Prim.*## expx_sguIB (GHC.Prim.sinDouble# x1_sgzmq)));
        1# ->
          case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_iguRu
                 x_sgzmn GHC.Prim.realWorld#
          of
          { (# ds3_iguRz, ds4_iguRA #) ->
          let {
            v_sguRD [Dmd=<S,U>] :: GHC.Prim.Double#
            [LclId]
            v_sguRD = GHC.Prim.sinDouble# (GHC.Prim./## x1_sgzmq 2.0##) } in
          let {
            w_sguRE :: GHC.Prim.Double#
            [LclId]
            w_sguRE
              = GHC.Prim.negateDouble#
                  (GHC.Prim.*## (GHC.Prim.+## v_sguRD v_sguRD) v_sguRD) } in
          Data.Complex.:+
            @ Double
            (GHC.Types.D#
               (GHC.Prim.+##
                  (GHC.Prim.+## (GHC.Prim.*## ds4_iguRA w_sguRE) ds4_iguRA) w_sguRE))
            (GHC.Types.D#
               (GHC.Prim.*##
                  (GHC.Prim.+## ds4_iguRA 1.0##) (GHC.Prim.sinDouble# x1_sgzmq)))
          }
      }
      }
      }
      }

-- RHS size: {terms: 113, types: 76, coercions: 0, joins: 0/7}
Data.Complex.$fFloatingComplex_$cexpm1 [InlPrag=INLINE (sat-args=1)]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(LLC(C(S))LLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A),U(A,A,C(U),A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_agsO1) ($dRealFloat_agsO2 :: RealFloat a_agsO1) ->
                 let {
                   $dFloating_agt63 :: Floating a_agsO1
                   [LclId]
                   $dFloating_agt63
                     = GHC.Float.$p2RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
                 let {
                   $dRealFrac_agt62 :: RealFrac a_agsO1
                   [LclId]
                   $dRealFrac_agt62
                     = GHC.Float.$p1RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
                 let {
                   $dReal_agt64 :: Real a_agsO1
                   [LclId]
                   $dReal_agt64 = GHC.Real.$p1RealFrac @ a_agsO1 $dRealFrac_agt62 } in
                 let {
                   $dNum_agt66 :: Num a_agsO1
                   [LclId]
                   $dNum_agt66 = GHC.Real.$p1Real @ a_agsO1 $dReal_agt64 } in
                 let {
                   $dOrd_agsYQ [Occ=OnceL] :: Ord a_agsO1
                   [LclId]
                   $dOrd_agsYQ = GHC.Real.$p2Real @ a_agsO1 $dReal_agt64 } in
                 let {
                   $dFractional_agsZ7 [Occ=OnceL] :: Fractional a_agsO1
                   [LclId]
                   $dFractional_agsZ7
                     = GHC.Real.$p2RealFrac @ a_agsO1 $dRealFrac_agt62 } in
                 \ (x_agsoR [Occ=Once!] :: Complex a_agsO1) ->
                   case x_agsoR of wild_X7x { :+ a1_agsoS b_agsoT ->
                   case < @ a_agsO1
                          $dOrd_agsYQ
                          (+ @ a_agsO1
                             $dNum_agt66
                             (* @ a_agsO1 $dNum_agt66 a1_agsoS a1_agsoS)
                             (* @ a_agsO1 $dNum_agt66 b_agsoT b_agsoT))
                          (fromInteger @ a_agsO1 $dNum_agt66 1)
                   of {
                     False ->
                       Data.Complex.$fFloatingComplex_$c-
                         @ a_agsO1
                         $dRealFloat_agsO2
                         (Data.Complex.$fFloatingComplex_$cexp
                            @ a_agsO1 $dRealFloat_agsO2 wild_X7x)
                         (Data.Complex.$fFloatingComplex_$cfromInteger
                            @ a_agsO1 $dRealFloat_agsO2 1);
                     True ->
                       let {
                         u_agsoU :: a_agsO1
                         [LclId]
                         u_agsoU = expm1 @ a_agsO1 $dFloating_agt63 a1_agsoS } in
                       let {
                         v_agsoV :: a_agsO1
                         [LclId]
                         v_agsoV
                           = sin
                               @ a_agsO1
                               $dFloating_agt63
                               (/ @ a_agsO1
                                  $dFractional_agsZ7
                                  b_agsoT
                                  (fromInteger @ a_agsO1 $dNum_agt66 2)) } in
                       let {
                         w_agsoW :: a_agsO1
                         [LclId]
                         w_agsoW
                           = negate
                               @ a_agsO1
                               $dNum_agt66
                               (* @ a_agsO1
                                  $dNum_agt66
                                  (* @ a_agsO1
                                     $dNum_agt66
                                     (fromInteger @ a_agsO1 $dNum_agt66 2)
                                     v_agsoV)
                                  v_agsoV) } in
                       Data.Complex.$W:+
                         @ a_agsO1
                         (+ @ a_agsO1
                            $dNum_agt66
                            (+ @ a_agsO1
                               $dNum_agt66
                               (* @ a_agsO1 $dNum_agt66 u_agsoU w_agsoW)
                               u_agsoU)
                            w_agsoW)
                         (* @ a_agsO1
                            $dNum_agt66
                            (+ @ a_agsO1
                               $dNum_agt66
                               u_agsoU
                               (fromInteger @ a_agsO1 $dNum_agt66 1))
                            (sin @ a_agsO1 $dFloating_agt63 b_agsoT))
                   }
                   }}]
Data.Complex.$fFloatingComplex_$cexpm1
  = \ (@ a_agsO1)
      ($dRealFloat_agsO2 :: RealFloat a_agsO1)
      (eta_X87 :: Complex a_agsO1) ->
      case eta_X87 of { :+ a1_agsoS b_agsoT ->
      let {
        $dRealFrac_sgufM [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,A),A,A,A,A,A)>]
          :: RealFrac a_agsO1
        [LclId]
        $dRealFrac_sgufM
          = GHC.Float.$p1RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
      let {
        $dReal_sgufL [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
          :: Real a_agsO1
        [LclId]
        $dReal_sgufL = GHC.Real.$p1RealFrac @ a_agsO1 $dRealFrac_sgufM } in
      let {
        $dNum_sgufK [Dmd=<L,U(C(C1(U)),A,C(C1(U)),1*C1(U),A,A,C(U))>]
          :: Num a_agsO1
        [LclId]
        $dNum_sgufK = GHC.Real.$p1Real @ a_agsO1 $dReal_sgufL } in
      case < @ a_agsO1
             (GHC.Real.$p2Real @ a_agsO1 $dReal_sgufL)
             (+ @ a_agsO1
                $dNum_sgufK
                (* @ a_agsO1 $dNum_sgufK a1_agsoS a1_agsoS)
                (* @ a_agsO1 $dNum_sgufK b_agsoT b_agsoT))
             (fromInteger
                @ a_agsO1 $dNum_sgufK Data.Complex.$fFloatingComplex19)
      of {
        False ->
          case Data.Complex.$w$cexp
                 @ a_agsO1 $dRealFloat_agsO2 a1_agsoS b_agsoT
          of
          { (# ww1_sgxQw, ww2_sgxQx #) ->
          case Data.Complex.$w$cfromInteger
                 @ a_agsO1 $dRealFloat_agsO2 Data.Complex.$fFloatingComplex19
          of
          { (# ww4_sgxRo, ww5_sgxRp #) ->
          case Data.Complex.$w$c-
                 @ a_agsO1 $dRealFloat_agsO2 ww1_sgxQw ww2_sgxQx ww4_sgxRo ww5_sgxRp
          of
          { (# ww7_sgxR9, ww8_sgxRa #) ->
          Data.Complex.:+ @ a_agsO1 ww7_sgxR9 ww8_sgxRa
          }
          }
          };
        True ->
          let {
            $dFloating_sgufN [Dmd=<L,U(A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A)>]
              :: Floating a_agsO1
            [LclId]
            $dFloating_sgufN
              = GHC.Float.$p2RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
          let {
            u_sgufT :: a_agsO1
            [LclId]
            u_sgufT = expm1 @ a_agsO1 $dFloating_sgufN a1_agsoS } in
          let {
            w_sgufR :: a_agsO1
            [LclId]
            w_sgufR
              = negate
                  @ a_agsO1
                  $dNum_sgufK
                  (let {
                     v_sgufS :: a_agsO1
                     [LclId]
                     v_sgufS
                       = sin
                           @ a_agsO1
                           $dFloating_sgufN
                           (/ @ a_agsO1
                              (GHC.Real.$p2RealFrac @ a_agsO1 $dRealFrac_sgufM)
                              b_agsoT
                              (fromInteger
                                 @ a_agsO1 $dNum_sgufK Data.Complex.$fFloatingComplex21)) } in
                   * @ a_agsO1
                     $dNum_sgufK
                     (* @ a_agsO1
                        $dNum_sgufK
                        (fromInteger
                           @ a_agsO1 $dNum_sgufK Data.Complex.$fFloatingComplex21)
                        v_sgufS)
                     v_sgufS) } in
          case + @ a_agsO1
                 $dNum_sgufK
                 (+ @ a_agsO1
                    $dNum_sgufK
                    (* @ a_agsO1 $dNum_sgufK u_sgufT w_sgufR)
                    u_sgufT)
                 w_sgufR
          of dt_XgsLE
          { __DEFAULT ->
          case * @ a_agsO1
                 $dNum_sgufK
                 (+ @ a_agsO1
                    $dNum_sgufK
                    u_sgufT
                    (fromInteger
                       @ a_agsO1 $dNum_sgufK Data.Complex.$fFloatingComplex19))
                 (sin @ a_agsO1 $dFloating_sgufN b_agsoT)
          of dt1_XgsLJ
          { __DEFAULT ->
          Data.Complex.:+ @ a_agsO1 dt_XgsLE dt1_XgsLJ
          }
          }
      }
      }

-- RHS size: {terms: 90, types: 34, coercions: 0, joins: 1/3}
Data.Complex.$fFloatingComplex_$s$clog1p1 [InlPrag=INLINE (sat-args=1)]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_agsoN [Occ=Once!] :: Complex Float) ->
                 case x_agsoN of { :+ a_agsoO [Occ=Once!] b_agsoP ->
                 case a_agsoO of { GHC.Types.F# x1_igtCh ->
                 join {
                   $j_sguSJ [Occ=Once*T[0]] :: Complex Float
                   [LclId[JoinId(0)]]
                   $j_sguSJ
                     = let {
                         eta_X6D :: Complex Float
                         [LclId]
                         eta_X6D
                           = case b_agsoP of { GHC.Types.F# y_XgtSx [Occ=Once] ->
                             Data.Complex.:+
                               @ Float
                               (GHC.Types.F# (GHC.Prim.plusFloat# 1.0# x1_igtCh))
                               (GHC.Types.F# y_XgtSx)
                             } } in
                       case Data.Complex.$fFloatingComplex_$smagnitude1 eta_X6D of
                       { GHC.Types.F# x2_igtyY [Occ=Once] ->
                       case GHC.Prim.logFloat# x2_igtyY of wild3_igtz0 { __DEFAULT ->
                       case Data.Complex.$fFloatingComplex_$sphase1 eta_X6D of dt_XgsF8
                       { GHC.Types.F# _ [Occ=Dead] ->
                       Data.Complex.:+ @ Float (GHC.Types.F# wild3_igtz0) dt_XgsF8
                       }
                       }
                       } } in
                 case GHC.Prim.ltFloat# (GHC.Prim.fabsFloat# x1_igtCh) 0.5# of {
                   __DEFAULT -> jump $j_sguSJ;
                   1# ->
                     case b_agsoP of wild2_XgtYa { GHC.Types.F# x2_XgtYe ->
                     case GHC.Prim.ltFloat# (GHC.Prim.fabsFloat# x2_XgtYe) 0.5# of {
                       __DEFAULT -> jump $j_sguSJ;
                       1# ->
                         let {
                           x3_igtwp :: GHC.Prim.Float#
                           [LclId]
                           x3_igtwp
                             = GHC.Prim.plusFloat#
                                 (GHC.Prim.plusFloat#
                                    (GHC.Prim.plusFloat# x1_igtCh x1_igtCh)
                                    (GHC.Prim.timesFloat# x1_igtCh x1_igtCh))
                                 (GHC.Prim.timesFloat# x2_XgtYe x2_XgtYe) } in
                         case GHC.Prim.divideFloat#
                                x3_igtwp
                                (GHC.Prim.plusFloat#
                                   1.0# (GHC.Prim.sqrtFloat# (GHC.Prim.plusFloat# x3_igtwp 1.0#)))
                         of wild3_igtwv
                         { __DEFAULT ->
                         case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_iguSb
                                wild3_igtwv GHC.Prim.realWorld#
                         of
                         { (# _ [Occ=Dead], ds4_iguSh [Occ=Once] #) ->
                         Data.Complex.$W:+
                           @ Float
                           (GHC.Types.F# ds4_iguSh)
                           (GHC.Float.$fRealFloatFloat_$catan2
                              (GHC.Types.F# (GHC.Prim.plusFloat# 1.0# x1_igtCh)) wild2_XgtYa)
                         }
                         }
                     }
                     }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$clog1p1
  = \ (eta_X88 :: Complex Float) ->
      case eta_X88 of { :+ a_agsoO b_agsoP ->
      case a_agsoO of { GHC.Types.F# x_sgzmt ->
      case b_agsoP of { GHC.Types.F# y_sgzmw ->
      join {
        $j_sguSp [Dmd=<L,1*U(U,U)>] :: Complex Float
        [LclId[JoinId(0)], Str=m]
        $j_sguSp
          = let {
              ww_sgyc3 [Dmd=<S,U>] :: GHC.Prim.Float#
              [LclId]
              ww_sgyc3 = GHC.Prim.plusFloat# 1.0# x_sgzmt } in
            case Data.Complex.$w$smagnitude1 ww_sgyc3 y_sgzmw of ww1_sgxyg
            { __DEFAULT ->
            case GHC.Prim.logFloat# ww1_sgxyg of wild3_igtz0 { __DEFAULT ->
            case Data.Complex.$w$sphase1 ww_sgyc3 y_sgzmw of ww2_sgxxv
            { __DEFAULT ->
            Data.Complex.:+
              @ Float (GHC.Types.F# wild3_igtz0) (GHC.Types.F# ww2_sgxxv)
            }
            }
            } } in
      case GHC.Prim.ltFloat# (GHC.Prim.fabsFloat# x_sgzmt) 0.5# of {
        __DEFAULT -> jump $j_sguSp;
        1# ->
          case GHC.Prim.ltFloat# (GHC.Prim.fabsFloat# y_sgzmw) 0.5# of {
            __DEFAULT -> jump $j_sguSp;
            1# ->
              let {
                x1_igtwp [Dmd=<S,U>] :: GHC.Prim.Float#
                [LclId]
                x1_igtwp
                  = GHC.Prim.plusFloat#
                      (GHC.Prim.plusFloat#
                         (GHC.Prim.plusFloat# x_sgzmt x_sgzmt)
                         (GHC.Prim.timesFloat# x_sgzmt x_sgzmt))
                      (GHC.Prim.timesFloat# y_sgzmw y_sgzmw) } in
              case GHC.Prim.divideFloat#
                     x1_igtwp
                     (GHC.Prim.plusFloat#
                        1.0# (GHC.Prim.sqrtFloat# (GHC.Prim.plusFloat# x1_igtwp 1.0#)))
              of wild3_igtwv
              { __DEFAULT ->
              case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_iguSb
                     wild3_igtwv GHC.Prim.realWorld#
              of
              { (# ds3_iguSg, ds4_iguSh #) ->
              case GHC.Float.$w$catan1
                     (GHC.Types.F# (GHC.Prim.plusFloat# 1.0# x_sgzmt)) y_sgzmw
              of ww2_iguI2
              { __DEFAULT ->
              Data.Complex.:+
                @ Float (GHC.Types.F# ds4_iguSh) (GHC.Types.F# ww2_iguI2)
              }
              }
              }
          }
      }
      }
      }
      }

-- RHS size: {terms: 90, types: 34, coercions: 0, joins: 1/3}
Data.Complex.$fFloatingComplex_$s$clog1p [InlPrag=INLINE (sat-args=1)]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_agsoN [Occ=Once!] :: Complex Double) ->
                 case x_agsoN of { :+ a_agsoO [Occ=Once!] b_agsoP ->
                 case a_agsoO of { GHC.Types.D# x1_igtCI ->
                 join {
                   $j_sguTB [Occ=Once*T[0]] :: Complex Double
                   [LclId[JoinId(0)]]
                   $j_sguTB
                     = let {
                         eta_X6D :: Complex Double
                         [LclId]
                         eta_X6D
                           = case b_agsoP of { GHC.Types.D# y_XgtVB [Occ=Once] ->
                             Data.Complex.:+
                               @ Double
                               (GHC.Types.D# (GHC.Prim.+## 1.0## x1_igtCI))
                               (GHC.Types.D# y_XgtVB)
                             } } in
                       case Data.Complex.$fFloatingComplex_$smagnitude eta_X6D of
                       { GHC.Types.D# x2_igtzk [Occ=Once] ->
                       case GHC.Prim.logDouble# x2_igtzk of wild3_igtzm { __DEFAULT ->
                       case Data.Complex.$fFloatingComplex_$sphase eta_X6D of dt_XgsF8
                       { GHC.Types.D# _ [Occ=Dead] ->
                       Data.Complex.:+ @ Double (GHC.Types.D# wild3_igtzm) dt_XgsF8
                       }
                       }
                       } } in
                 case GHC.Prim.<## (GHC.Prim.fabsDouble# x1_igtCI) 0.5## of {
                   __DEFAULT -> jump $j_sguTB;
                   1# ->
                     case b_agsoP of wild2_XgtZ7 { GHC.Types.D# x2_XgtZb ->
                     case GHC.Prim.<## (GHC.Prim.fabsDouble# x2_XgtZb) 0.5## of {
                       __DEFAULT -> jump $j_sguTB;
                       1# ->
                         let {
                           x3_igtAu :: GHC.Prim.Double#
                           [LclId]
                           x3_igtAu
                             = GHC.Prim.+##
                                 (GHC.Prim.+##
                                    (GHC.Prim.+## x1_igtCI x1_igtCI)
                                    (GHC.Prim.*## x1_igtCI x1_igtCI))
                                 (GHC.Prim.*## x2_XgtZb x2_XgtZb) } in
                         case GHC.Prim./##
                                x3_igtAu
                                (GHC.Prim.+##
                                   1.0## (GHC.Prim.sqrtDouble# (GHC.Prim.+## x3_igtAu 1.0##)))
                         of wild3_igtAA
                         { __DEFAULT ->
                         case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_iguT3
                                wild3_igtAA GHC.Prim.realWorld#
                         of
                         { (# _ [Occ=Dead], ds4_iguT9 [Occ=Once] #) ->
                         Data.Complex.$W:+
                           @ Double
                           (GHC.Types.D# ds4_iguT9)
                           (GHC.Float.$fRealFloatDouble_$catan2
                              (GHC.Types.D# (GHC.Prim.+## 1.0## x1_igtCI)) wild2_XgtZ7)
                         }
                         }
                     }
                     }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$clog1p
  = \ (eta_X88 :: Complex Double) ->
      case eta_X88 of { :+ a_agsoO b_agsoP ->
      case a_agsoO of { GHC.Types.D# x_sgzmC ->
      case b_agsoP of { GHC.Types.D# y_sgzmF ->
      join {
        $j_sguTh [Dmd=<L,1*U(U,U)>] :: Complex Double
        [LclId[JoinId(0)], Str=m]
        $j_sguTh
          = let {
              ww_sgyct [Dmd=<S,U>] :: GHC.Prim.Double#
              [LclId]
              ww_sgyct = GHC.Prim.+## 1.0## x_sgzmC } in
            case Data.Complex.$w$smagnitude ww_sgyct y_sgzmF of ww1_sgxxX
            { __DEFAULT ->
            case GHC.Prim.logDouble# ww1_sgxxX of wild3_igtzm { __DEFAULT ->
            case Data.Complex.$w$sphase ww_sgyct y_sgzmF of ww2_sgxxd
            { __DEFAULT ->
            Data.Complex.:+
              @ Double (GHC.Types.D# wild3_igtzm) (GHC.Types.D# ww2_sgxxd)
            }
            }
            } } in
      case GHC.Prim.<## (GHC.Prim.fabsDouble# x_sgzmC) 0.5## of {
        __DEFAULT -> jump $j_sguTh;
        1# ->
          case GHC.Prim.<## (GHC.Prim.fabsDouble# y_sgzmF) 0.5## of {
            __DEFAULT -> jump $j_sguTh;
            1# ->
              let {
                x1_igtAu [Dmd=<S,U>] :: GHC.Prim.Double#
                [LclId]
                x1_igtAu
                  = GHC.Prim.+##
                      (GHC.Prim.+##
                         (GHC.Prim.+## x_sgzmC x_sgzmC) (GHC.Prim.*## x_sgzmC x_sgzmC))
                      (GHC.Prim.*## y_sgzmF y_sgzmF) } in
              case GHC.Prim./##
                     x1_igtAu
                     (GHC.Prim.+##
                        1.0## (GHC.Prim.sqrtDouble# (GHC.Prim.+## x1_igtAu 1.0##)))
              of wild3_igtAA
              { __DEFAULT ->
              case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_iguT3
                     wild3_igtAA GHC.Prim.realWorld#
              of
              { (# ds3_iguT8, ds4_iguT9 #) ->
              case GHC.Float.$w$catan2
                     (GHC.Types.D# (GHC.Prim.+## 1.0## x_sgzmC)) y_sgzmF
              of ww2_igty4
              { __DEFAULT ->
              Data.Complex.:+
                @ Double (GHC.Types.D# ds4_iguT9) (GHC.Types.D# ww2_igty4)
              }
              }
              }
          }
      }
      }
      }
      }

-- RHS size: {terms: 143, types: 106, coercions: 0, joins: 0/7}
Data.Complex.$fFloatingComplex_$clog1p [InlPrag=INLINE (sat-args=1)]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(LS(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_agsO1) ($dRealFloat_agsO2 :: RealFloat a_agsO1) ->
                 let {
                   $dFloating_agt63 :: Floating a_agsO1
                   [LclId]
                   $dFloating_agt63
                     = GHC.Float.$p2RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
                 let {
                   $dRealFrac_agt62 :: RealFrac a_agsO1
                   [LclId]
                   $dRealFrac_agt62
                     = GHC.Float.$p1RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
                 let {
                   $dReal_agt64 :: Real a_agsO1
                   [LclId]
                   $dReal_agt64 = GHC.Real.$p1RealFrac @ a_agsO1 $dRealFrac_agt62 } in
                 let {
                   $dNum_agt66 :: Num a_agsO1
                   [LclId]
                   $dNum_agt66 = GHC.Real.$p1Real @ a_agsO1 $dReal_agt64 } in
                 let {
                   $dOrd_agt67 :: Ord a_agsO1
                   [LclId]
                   $dOrd_agt67 = GHC.Real.$p2Real @ a_agsO1 $dReal_agt64 } in
                 let {
                   $dFractional_agt65 :: Fractional a_agsO1
                   [LclId]
                   $dFractional_agt65
                     = GHC.Real.$p2RealFrac @ a_agsO1 $dRealFrac_agt62 } in
                 \ (x_agsoN [Occ=Once!] :: Complex a_agsO1) ->
                   case x_agsoN of wild_X7w { :+ a1_agsoO b_agsoP ->
                   case < @ a_agsO1
                          $dOrd_agt67
                          (abs @ a_agsO1 $dNum_agt66 a1_agsoO)
                          (fromRational
                             @ a_agsO1 $dFractional_agt65 (GHC.Real.:% @ Integer 1 2))
                   of {
                     False ->
                       Data.Complex.$fFloatingComplex_$clog
                         @ a_agsO1
                         $dRealFloat_agsO2
                         (Data.Complex.$fFloatingComplex_$c+
                            @ a_agsO1
                            $dRealFloat_agsO2
                            (Data.Complex.$fFloatingComplex_$cfromInteger
                               @ a_agsO1 $dRealFloat_agsO2 1)
                            wild_X7w);
                     True ->
                       case < @ a_agsO1
                              $dOrd_agt67
                              (abs @ a_agsO1 $dNum_agt66 b_agsoP)
                              (fromRational
                                 @ a_agsO1 $dFractional_agt65 (GHC.Real.:% @ Integer 1 2))
                       of {
                         False ->
                           Data.Complex.$fFloatingComplex_$clog
                             @ a_agsO1
                             $dRealFloat_agsO2
                             (Data.Complex.$fFloatingComplex_$c+
                                @ a_agsO1
                                $dRealFloat_agsO2
                                (Data.Complex.$fFloatingComplex_$cfromInteger
                                   @ a_agsO1 $dRealFloat_agsO2 1)
                                wild_X7w);
                         True ->
                           let {
                             u_agsoQ :: a_agsO1
                             [LclId]
                             u_agsoQ
                               = + @ a_agsO1
                                   $dNum_agt66
                                   (+ @ a_agsO1
                                      $dNum_agt66
                                      (* @ a_agsO1
                                         $dNum_agt66
                                         (fromInteger @ a_agsO1 $dNum_agt66 2)
                                         a1_agsoO)
                                      (* @ a_agsO1 $dNum_agt66 a1_agsoO a1_agsoO))
                                   (* @ a_agsO1 $dNum_agt66 b_agsoP b_agsoP) } in
                           Data.Complex.$W:+
                             @ a_agsO1
                             (log1p
                                @ a_agsO1
                                $dFloating_agt63
                                (/ @ a_agsO1
                                   $dFractional_agt65
                                   u_agsoQ
                                   (+ @ a_agsO1
                                      $dNum_agt66
                                      (fromInteger @ a_agsO1 $dNum_agt66 1)
                                      (sqrt
                                         @ a_agsO1
                                         $dFloating_agt63
                                         (+ @ a_agsO1
                                            $dNum_agt66
                                            u_agsoQ
                                            (fromInteger @ a_agsO1 $dNum_agt66 1))))))
                             (atan2
                                @ a_agsO1
                                $dRealFloat_agsO2
                                (+ @ a_agsO1
                                   $dNum_agt66
                                   (fromInteger @ a_agsO1 $dNum_agt66 1)
                                   a1_agsoO)
                                b_agsoP)
                       }
                   }
                   }}]
Data.Complex.$fFloatingComplex_$clog1p
  = \ (@ a_agsO1)
      ($dRealFloat_agsO2 :: RealFloat a_agsO1)
      (eta_X88 :: Complex a_agsO1) ->
      case eta_X88 of { :+ a1_agsoO b_agsoP ->
      let {
        $dRealFrac_sguf6 [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
          :: RealFrac a_agsO1
        [LclId]
        $dRealFrac_sguf6
          = GHC.Float.$p1RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
      let {
        $dReal_sguf5 [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
          :: Real a_agsO1
        [LclId]
        $dReal_sguf5 = GHC.Real.$p1RealFrac @ a_agsO1 $dRealFrac_sguf6 } in
      let {
        $dNum_sguf4 [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
          :: Num a_agsO1
        [LclId]
        $dNum_sguf4 = GHC.Real.$p1Real @ a_agsO1 $dReal_sguf5 } in
      let {
        $dOrd_sguf3 [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
          :: Ord a_agsO1
        [LclId]
        $dOrd_sguf3 = GHC.Real.$p2Real @ a_agsO1 $dReal_sguf5 } in
      let {
        $dFractional_sguf2 [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
          :: Fractional a_agsO1
        [LclId]
        $dFractional_sguf2
          = GHC.Real.$p2RealFrac @ a_agsO1 $dRealFrac_sguf6 } in
      case < @ a_agsO1
             $dOrd_sguf3
             (abs @ a_agsO1 $dNum_sguf4 a1_agsoO)
             (fromRational
                @ a_agsO1 $dFractional_sguf2 Data.Complex.$fFloatingComplex20)
      of {
        False ->
          case Data.Complex.$w$cfromInteger
                 @ a_agsO1 $dRealFloat_agsO2 Data.Complex.$fFloatingComplex19
          of
          { (# ww1_sgxRo, ww2_sgxRp #) ->
          case Data.Complex.$w$c+
                 @ a_agsO1 $dRealFloat_agsO2 ww1_sgxRo ww2_sgxRp a1_agsoO b_agsoP
          of
          { (# ww4_sgxR3, ww5_sgxR4 #) ->
          case Data.Complex.$w$clog
                 @ a_agsO1 $dRealFloat_agsO2 ww4_sgxR3 ww5_sgxR4
          of
          { (# ww7_sgxQC, ww8_sgxQD #) ->
          Data.Complex.:+ @ a_agsO1 ww7_sgxQC ww8_sgxQD
          }
          }
          };
        True ->
          case < @ a_agsO1
                 $dOrd_sguf3
                 (abs @ a_agsO1 $dNum_sguf4 b_agsoP)
                 (fromRational
                    @ a_agsO1 $dFractional_sguf2 Data.Complex.$fFloatingComplex20)
          of {
            False ->
              case Data.Complex.$w$cfromInteger
                     @ a_agsO1 $dRealFloat_agsO2 Data.Complex.$fFloatingComplex19
              of
              { (# ww1_sgxRo, ww2_sgxRp #) ->
              case Data.Complex.$w$c+
                     @ a_agsO1 $dRealFloat_agsO2 ww1_sgxRo ww2_sgxRp a1_agsoO b_agsoP
              of
              { (# ww4_sgxR3, ww5_sgxR4 #) ->
              case Data.Complex.$w$clog
                     @ a_agsO1 $dRealFloat_agsO2 ww4_sgxR3 ww5_sgxR4
              of
              { (# ww7_sgxQC, ww8_sgxQD #) ->
              Data.Complex.:+ @ a_agsO1 ww7_sgxQC ww8_sgxQD
              }
              }
              };
            True ->
              let {
                $dFloating_sguf7 [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                  :: Floating a_agsO1
                [LclId]
                $dFloating_sguf7
                  = GHC.Float.$p2RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
              case log1p
                     @ a_agsO1
                     $dFloating_sguf7
                     (let {
                        u_sguf9 :: a_agsO1
                        [LclId]
                        u_sguf9
                          = + @ a_agsO1
                              $dNum_sguf4
                              (+ @ a_agsO1
                                 $dNum_sguf4
                                 (* @ a_agsO1
                                    $dNum_sguf4
                                    (fromInteger
                                       @ a_agsO1 $dNum_sguf4 Data.Complex.$fFloatingComplex21)
                                    a1_agsoO)
                                 (* @ a_agsO1 $dNum_sguf4 a1_agsoO a1_agsoO))
                              (* @ a_agsO1 $dNum_sguf4 b_agsoP b_agsoP) } in
                      / @ a_agsO1
                        $dFractional_sguf2
                        u_sguf9
                        (+ @ a_agsO1
                           $dNum_sguf4
                           (fromInteger
                              @ a_agsO1 $dNum_sguf4 Data.Complex.$fFloatingComplex19)
                           (sqrt
                              @ a_agsO1
                              $dFloating_sguf7
                              (+ @ a_agsO1
                                 $dNum_sguf4
                                 u_sguf9
                                 (fromInteger
                                    @ a_agsO1 $dNum_sguf4 Data.Complex.$fFloatingComplex19)))))
              of dt_XgsMS
              { __DEFAULT ->
              case atan2
                     @ a_agsO1
                     $dRealFloat_agsO2
                     (+ @ a_agsO1
                        $dNum_sguf4
                        (fromInteger
                           @ a_agsO1 $dNum_sguf4 Data.Complex.$fFloatingComplex19)
                        a1_agsoO)
                     b_agsoP
              of dt1_XgsMX
              { __DEFAULT ->
              Data.Complex.:+ @ a_agsO1 dt_XgsMS dt1_XgsMX
              }
              }
          }
      }
      }

-- RHS size: {terms: 105, types: 37, coercions: 0, joins: 1/6}
Data.Complex.$fFloatingComplex_$s$clog1mexp1 [InlPrag=INLINE (sat-args=1)]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_igjqb [Occ=Once!] :: Complex Float) ->
                 case x_igjqb of { :+ x1_agsnS [Occ=Once!] y_agsnT [Occ=Once!] ->
                 case x1_agsnS of { GHC.Types.F# x2_sguph [Occ=Once] ->
                 case y_agsnT of { GHC.Types.F# x3_sgupk ->
                 let {
                   expx_sguGv :: GHC.Prim.Float#
                   [LclId]
                   expx_sguGv = GHC.Prim.expFloat# x2_sguph } in
                 let {
                   dt_sguUk :: GHC.Prim.Float#
                   [LclId]
                   dt_sguUk
                     = GHC.Prim.negateFloat#
                         (GHC.Prim.timesFloat#
                            expx_sguGv (GHC.Prim.cosFloat# x3_sgupk)) } in
                 let {
                   dt1_sguUl :: GHC.Prim.Float#
                   [LclId]
                   dt1_sguUl
                     = GHC.Prim.negateFloat#
                         (GHC.Prim.timesFloat#
                            expx_sguGv (GHC.Prim.sinFloat# x3_sgupk)) } in
                 join {
                   $j_sguUv [Occ=Once*T[0]] :: Complex Float
                   [LclId[JoinId(0)]]
                   $j_sguUv
                     = let {
                         dt2_sguUm [Occ=OnceL] :: GHC.Prim.Float#
                         [LclId]
                         dt2_sguUm = GHC.Prim.plusFloat# 1.0# dt_sguUk } in
                       let {
                         dt3_XgsFJ [Occ=OnceL] :: Float
                         [LclId, Unf=OtherCon []]
                         dt3_XgsFJ = GHC.Types.F# dt2_sguUm } in
                       let {
                         dt4_XgsFO [Occ=OnceL] :: Float
                         [LclId, Unf=OtherCon []]
                         dt4_XgsFO = GHC.Types.F# dt1_sguUl } in
                       let {
                         eta_X6D :: Complex Float
                         [LclId, Unf=OtherCon []]
                         eta_X6D = Data.Complex.:+ @ Float dt3_XgsFJ dt4_XgsFO } in
                       case Data.Complex.$fFloatingComplex_$smagnitude1 eta_X6D of
                       { GHC.Types.F# x4_igtyY [Occ=Once] ->
                       case GHC.Prim.logFloat# x4_igtyY of wild4_igtz0 { __DEFAULT ->
                       case Data.Complex.$fFloatingComplex_$sphase1 eta_X6D of dt5_XgsF8
                       { GHC.Types.F# _ [Occ=Dead] ->
                       Data.Complex.:+ @ Float (GHC.Types.F# wild4_igtz0) dt5_XgsF8
                       }
                       }
                       } } in
                 case GHC.Prim.ltFloat# (GHC.Prim.fabsFloat# dt_sguUk) 0.5# of {
                   __DEFAULT -> jump $j_sguUv;
                   1# ->
                     case GHC.Prim.ltFloat# (GHC.Prim.fabsFloat# dt1_sguUl) 0.5# of {
                       __DEFAULT -> jump $j_sguUv;
                       1# ->
                         let {
                           u_sguUs :: GHC.Prim.Float#
                           [LclId]
                           u_sguUs
                             = GHC.Prim.plusFloat#
                                 (GHC.Prim.plusFloat#
                                    (GHC.Prim.plusFloat# dt_sguUk dt_sguUk)
                                    (GHC.Prim.timesFloat# dt_sguUk dt_sguUk))
                                 (GHC.Prim.timesFloat# dt1_sguUl dt1_sguUl) } in
                         case GHC.Prim.divideFloat#
                                u_sguUs
                                (GHC.Prim.plusFloat#
                                   1.0# (GHC.Prim.sqrtFloat# (GHC.Prim.plusFloat# u_sguUs 1.0#)))
                         of wild3_igtwv
                         { __DEFAULT ->
                         case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_iguSb
                                wild3_igtwv GHC.Prim.realWorld#
                         of
                         { (# _ [Occ=Dead], ds4_iguSh [Occ=Once] #) ->
                         Data.Complex.$W:+
                           @ Float
                           (GHC.Types.F# ds4_iguSh)
                           (GHC.Float.$fRealFloatFloat_$catan2
                              (GHC.Types.F# (GHC.Prim.plusFloat# 1.0# dt_sguUk))
                              (GHC.Types.F# dt1_sguUl))
                         }
                         }
                     }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$clog1mexp1
  = \ (eta_X89 :: Complex Float) ->
      case eta_X89 of { :+ x_agsnS y_agsnT ->
      case x_agsnS of { GHC.Types.F# x1_sgzmL ->
      case y_agsnT of { GHC.Types.F# x2_sgzmO ->
      let {
        expx_sguGv [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        expx_sguGv = GHC.Prim.expFloat# x1_sgzmL } in
      let {
        dt_sguTV [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        dt_sguTV
          = GHC.Prim.negateFloat#
              (GHC.Prim.timesFloat#
                 expx_sguGv (GHC.Prim.cosFloat# x2_sgzmO)) } in
      let {
        dt1_sguTW [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        dt1_sguTW
          = GHC.Prim.negateFloat#
              (GHC.Prim.timesFloat#
                 expx_sguGv (GHC.Prim.sinFloat# x2_sgzmO)) } in
      join {
        $j_sguU9 [Dmd=<L,1*U(U,U)>] :: Complex Float
        [LclId[JoinId(0)], Str=m]
        $j_sguU9
          = let {
              dt2_sguTX [Dmd=<S,U>] :: GHC.Prim.Float#
              [LclId]
              dt2_sguTX = GHC.Prim.plusFloat# 1.0# dt_sguTV } in
            case Data.Complex.$w$smagnitude1 dt2_sguTX dt1_sguTW of ww_sgxyg
            { __DEFAULT ->
            case GHC.Prim.logFloat# ww_sgxyg of wild3_igtz0 { __DEFAULT ->
            case Data.Complex.$w$sphase1 dt2_sguTX dt1_sguTW of ww1_sgxxv
            { __DEFAULT ->
            Data.Complex.:+
              @ Float (GHC.Types.F# wild3_igtz0) (GHC.Types.F# ww1_sgxxv)
            }
            }
            } } in
      case GHC.Prim.ltFloat# (GHC.Prim.fabsFloat# dt_sguTV) 0.5# of {
        __DEFAULT -> jump $j_sguU9;
        1# ->
          case GHC.Prim.ltFloat# (GHC.Prim.fabsFloat# dt1_sguTW) 0.5# of {
            __DEFAULT -> jump $j_sguU9;
            1# ->
              let {
                u_sguU3 [Dmd=<S,U>] :: GHC.Prim.Float#
                [LclId]
                u_sguU3
                  = GHC.Prim.plusFloat#
                      (GHC.Prim.plusFloat#
                         (GHC.Prim.plusFloat# dt_sguTV dt_sguTV)
                         (GHC.Prim.timesFloat# dt_sguTV dt_sguTV))
                      (GHC.Prim.timesFloat# dt1_sguTW dt1_sguTW) } in
              case GHC.Prim.divideFloat#
                     u_sguU3
                     (GHC.Prim.plusFloat#
                        1.0# (GHC.Prim.sqrtFloat# (GHC.Prim.plusFloat# u_sguU3 1.0#)))
              of wild3_igtwv
              { __DEFAULT ->
              case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_iguSb
                     wild3_igtwv GHC.Prim.realWorld#
              of
              { (# ds3_iguSg, ds4_iguSh #) ->
              case GHC.Float.$w$catan1
                     (GHC.Types.F# (GHC.Prim.plusFloat# 1.0# dt_sguTV)) dt1_sguTW
              of ww2_iguI2
              { __DEFAULT ->
              Data.Complex.:+
                @ Float (GHC.Types.F# ds4_iguSh) (GHC.Types.F# ww2_iguI2)
              }
              }
              }
          }
      }
      }
      }
      }

-- RHS size: {terms: 105, types: 37, coercions: 0, joins: 1/6}
Data.Complex.$fFloatingComplex_$s$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_igjqb [Occ=Once!] :: Complex Double) ->
                 case x_igjqb of { :+ x1_agsnS [Occ=Once!] y_agsnT [Occ=Once!] ->
                 case x1_agsnS of { GHC.Types.D# x2_sgurX [Occ=Once] ->
                 case y_agsnT of { GHC.Types.D# x3_sgus0 ->
                 let {
                   expx_sguIB :: GHC.Prim.Double#
                   [LclId]
                   expx_sguIB = GHC.Prim.expDouble# x2_sgurX } in
                 let {
                   dt_sguV5 :: GHC.Prim.Double#
                   [LclId]
                   dt_sguV5
                     = GHC.Prim.negateDouble#
                         (GHC.Prim.*## expx_sguIB (GHC.Prim.cosDouble# x3_sgus0)) } in
                 let {
                   dt1_sguV6 :: GHC.Prim.Double#
                   [LclId]
                   dt1_sguV6
                     = GHC.Prim.negateDouble#
                         (GHC.Prim.*## expx_sguIB (GHC.Prim.sinDouble# x3_sgus0)) } in
                 join {
                   $j_sguVg [Occ=Once*T[0]] :: Complex Double
                   [LclId[JoinId(0)]]
                   $j_sguVg
                     = let {
                         dt2_sguV7 [Occ=OnceL] :: GHC.Prim.Double#
                         [LclId]
                         dt2_sguV7 = GHC.Prim.+## 1.0## dt_sguV5 } in
                       let {
                         dt3_XgsFJ [Occ=OnceL] :: Double
                         [LclId, Unf=OtherCon []]
                         dt3_XgsFJ = GHC.Types.D# dt2_sguV7 } in
                       let {
                         dt4_XgsFO [Occ=OnceL] :: Double
                         [LclId, Unf=OtherCon []]
                         dt4_XgsFO = GHC.Types.D# dt1_sguV6 } in
                       let {
                         eta_X6D :: Complex Double
                         [LclId, Unf=OtherCon []]
                         eta_X6D = Data.Complex.:+ @ Double dt3_XgsFJ dt4_XgsFO } in
                       case Data.Complex.$fFloatingComplex_$smagnitude eta_X6D of
                       { GHC.Types.D# x4_igtzk [Occ=Once] ->
                       case GHC.Prim.logDouble# x4_igtzk of wild4_igtzm { __DEFAULT ->
                       case Data.Complex.$fFloatingComplex_$sphase eta_X6D of dt5_XgsF8
                       { GHC.Types.D# _ [Occ=Dead] ->
                       Data.Complex.:+ @ Double (GHC.Types.D# wild4_igtzm) dt5_XgsF8
                       }
                       }
                       } } in
                 case GHC.Prim.<## (GHC.Prim.fabsDouble# dt_sguV5) 0.5## of {
                   __DEFAULT -> jump $j_sguVg;
                   1# ->
                     case GHC.Prim.<## (GHC.Prim.fabsDouble# dt1_sguV6) 0.5## of {
                       __DEFAULT -> jump $j_sguVg;
                       1# ->
                         let {
                           u_sguVd :: GHC.Prim.Double#
                           [LclId]
                           u_sguVd
                             = GHC.Prim.+##
                                 (GHC.Prim.+##
                                    (GHC.Prim.+## dt_sguV5 dt_sguV5)
                                    (GHC.Prim.*## dt_sguV5 dt_sguV5))
                                 (GHC.Prim.*## dt1_sguV6 dt1_sguV6) } in
                         case GHC.Prim./##
                                u_sguVd
                                (GHC.Prim.+##
                                   1.0## (GHC.Prim.sqrtDouble# (GHC.Prim.+## u_sguVd 1.0##)))
                         of wild3_igtAA
                         { __DEFAULT ->
                         case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_iguT3
                                wild3_igtAA GHC.Prim.realWorld#
                         of
                         { (# _ [Occ=Dead], ds4_iguT9 [Occ=Once] #) ->
                         Data.Complex.$W:+
                           @ Double
                           (GHC.Types.D# ds4_iguT9)
                           (GHC.Float.$fRealFloatDouble_$catan2
                              (GHC.Types.D# (GHC.Prim.+## 1.0## dt_sguV5))
                              (GHC.Types.D# dt1_sguV6))
                         }
                         }
                     }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$clog1mexp
  = \ (eta_X89 :: Complex Double) ->
      case eta_X89 of { :+ x_agsnS y_agsnT ->
      case x_agsnS of { GHC.Types.D# x1_sgzmR ->
      case y_agsnT of { GHC.Types.D# x2_sgzmU ->
      let {
        expx_sguIB [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        expx_sguIB = GHC.Prim.expDouble# x1_sgzmR } in
      let {
        dt_sguUG [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        dt_sguUG
          = GHC.Prim.negateDouble#
              (GHC.Prim.*## expx_sguIB (GHC.Prim.cosDouble# x2_sgzmU)) } in
      let {
        dt1_sguUH [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        dt1_sguUH
          = GHC.Prim.negateDouble#
              (GHC.Prim.*## expx_sguIB (GHC.Prim.sinDouble# x2_sgzmU)) } in
      join {
        $j_sguUU [Dmd=<L,1*U(U,U)>] :: Complex Double
        [LclId[JoinId(0)], Str=m]
        $j_sguUU
          = let {
              dt2_sguUI [Dmd=<S,U>] :: GHC.Prim.Double#
              [LclId]
              dt2_sguUI = GHC.Prim.+## 1.0## dt_sguUG } in
            case Data.Complex.$w$smagnitude dt2_sguUI dt1_sguUH of ww_sgxxX
            { __DEFAULT ->
            case GHC.Prim.logDouble# ww_sgxxX of wild3_igtzm { __DEFAULT ->
            case Data.Complex.$w$sphase dt2_sguUI dt1_sguUH of ww1_sgxxd
            { __DEFAULT ->
            Data.Complex.:+
              @ Double (GHC.Types.D# wild3_igtzm) (GHC.Types.D# ww1_sgxxd)
            }
            }
            } } in
      case GHC.Prim.<## (GHC.Prim.fabsDouble# dt_sguUG) 0.5## of {
        __DEFAULT -> jump $j_sguUU;
        1# ->
          case GHC.Prim.<## (GHC.Prim.fabsDouble# dt1_sguUH) 0.5## of {
            __DEFAULT -> jump $j_sguUU;
            1# ->
              let {
                u_sguUO [Dmd=<S,U>] :: GHC.Prim.Double#
                [LclId]
                u_sguUO
                  = GHC.Prim.+##
                      (GHC.Prim.+##
                         (GHC.Prim.+## dt_sguUG dt_sguUG) (GHC.Prim.*## dt_sguUG dt_sguUG))
                      (GHC.Prim.*## dt1_sguUH dt1_sguUH) } in
              case GHC.Prim./##
                     u_sguUO
                     (GHC.Prim.+##
                        1.0## (GHC.Prim.sqrtDouble# (GHC.Prim.+## u_sguUO 1.0##)))
              of wild3_igtAA
              { __DEFAULT ->
              case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_iguT3
                     wild3_igtAA GHC.Prim.realWorld#
              of
              { (# ds3_iguT8, ds4_iguT9 #) ->
              case GHC.Float.$w$catan2
                     (GHC.Types.D# (GHC.Prim.+## 1.0## dt_sguUG)) dt1_sguUH
              of ww2_igty4
              { __DEFAULT ->
              Data.Complex.:+
                @ Double (GHC.Types.D# ds4_iguT9) (GHC.Types.D# ww2_igty4)
              }
              }
              }
          }
      }
      }
      }
      }

-- RHS size: {terms: 155, types: 122, coercions: 0, joins: 0/7}
Data.Complex.$fFloatingComplex_$clog1mexp [InlPrag=INLINE (sat-args=1)]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLC(C(S))C(S)LLL)S(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_agsO1)
                 ($dRealFloat_agsO2 :: RealFloat a_agsO1)
                 (x_igjqb [Occ=Once] :: Complex a_agsO1) ->
                 let {
                   $dFloating_agt63 :: Floating a_agsO1
                   [LclId]
                   $dFloating_agt63
                     = GHC.Float.$p2RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
                 let {
                   $dRealFrac_agt62 :: RealFrac a_agsO1
                   [LclId]
                   $dRealFrac_agt62
                     = GHC.Float.$p1RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
                 let {
                   $dReal_agt64 :: Real a_agsO1
                   [LclId]
                   $dReal_agt64 = GHC.Real.$p1RealFrac @ a_agsO1 $dRealFrac_agt62 } in
                 let {
                   $dNum_agt66 :: Num a_agsO1
                   [LclId]
                   $dNum_agt66 = GHC.Real.$p1Real @ a_agsO1 $dReal_agt64 } in
                 let {
                   $dOrd_agt67 :: Ord a_agsO1
                   [LclId]
                   $dOrd_agt67 = GHC.Real.$p2Real @ a_agsO1 $dReal_agt64 } in
                 let {
                   $dFractional_agt65 :: Fractional a_agsO1
                   [LclId]
                   $dFractional_agt65
                     = GHC.Real.$p2RealFrac @ a_agsO1 $dRealFrac_agt62 } in
                 case Data.Complex.$fFloatingComplex_$cnegate
                        @ a_agsO1
                        $dRealFloat_agsO2
                        (Data.Complex.$fFloatingComplex_$cexp
                           @ a_agsO1 $dRealFloat_agsO2 x_igjqb)
                 of wild_X7w
                 { :+ a1_agsoO b_agsoP ->
                 case < @ a_agsO1
                        $dOrd_agt67
                        (abs @ a_agsO1 $dNum_agt66 a1_agsoO)
                        (fromRational
                           @ a_agsO1 $dFractional_agt65 (GHC.Real.:% @ Integer 1 2))
                 of {
                   False ->
                     Data.Complex.$fFloatingComplex_$clog
                       @ a_agsO1
                       $dRealFloat_agsO2
                       (Data.Complex.$fFloatingComplex_$c+
                          @ a_agsO1
                          $dRealFloat_agsO2
                          (Data.Complex.$fFloatingComplex_$cfromInteger
                             @ a_agsO1 $dRealFloat_agsO2 1)
                          wild_X7w);
                   True ->
                     case < @ a_agsO1
                            $dOrd_agt67
                            (abs @ a_agsO1 $dNum_agt66 b_agsoP)
                            (fromRational
                               @ a_agsO1 $dFractional_agt65 (GHC.Real.:% @ Integer 1 2))
                     of {
                       False ->
                         Data.Complex.$fFloatingComplex_$clog
                           @ a_agsO1
                           $dRealFloat_agsO2
                           (Data.Complex.$fFloatingComplex_$c+
                              @ a_agsO1
                              $dRealFloat_agsO2
                              (Data.Complex.$fFloatingComplex_$cfromInteger
                                 @ a_agsO1 $dRealFloat_agsO2 1)
                              wild_X7w);
                       True ->
                         let {
                           u_agsoQ :: a_agsO1
                           [LclId]
                           u_agsoQ
                             = + @ a_agsO1
                                 $dNum_agt66
                                 (+ @ a_agsO1
                                    $dNum_agt66
                                    (* @ a_agsO1
                                       $dNum_agt66
                                       (fromInteger @ a_agsO1 $dNum_agt66 2)
                                       a1_agsoO)
                                    (* @ a_agsO1 $dNum_agt66 a1_agsoO a1_agsoO))
                                 (* @ a_agsO1 $dNum_agt66 b_agsoP b_agsoP) } in
                         Data.Complex.$W:+
                           @ a_agsO1
                           (log1p
                              @ a_agsO1
                              $dFloating_agt63
                              (/ @ a_agsO1
                                 $dFractional_agt65
                                 u_agsoQ
                                 (+ @ a_agsO1
                                    $dNum_agt66
                                    (fromInteger @ a_agsO1 $dNum_agt66 1)
                                    (sqrt
                                       @ a_agsO1
                                       $dFloating_agt63
                                       (+ @ a_agsO1
                                          $dNum_agt66
                                          u_agsoQ
                                          (fromInteger @ a_agsO1 $dNum_agt66 1))))))
                           (atan2
                              @ a_agsO1
                              $dRealFloat_agsO2
                              (+ @ a_agsO1
                                 $dNum_agt66
                                 (fromInteger @ a_agsO1 $dNum_agt66 1)
                                 a1_agsoO)
                              b_agsoP)
                     }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$clog1mexp
  = \ (@ a_agsO1)
      ($dRealFloat_agsO2 :: RealFloat a_agsO1)
      (eta_X89 :: Complex a_agsO1) ->
      case eta_X89 of { :+ ww1_sgxyU ww2_sgxyV ->
      case Data.Complex.$w$cexp
             @ a_agsO1 $dRealFloat_agsO2 ww1_sgxyU ww2_sgxyV
      of
      { (# ww4_sgxQw, ww5_sgxQx #) ->
      case Data.Complex.$w$cnegate
             @ a_agsO1 $dRealFloat_agsO2 ww4_sgxQw ww5_sgxQx
      of
      { (# ww7_sgxRi, ww8_sgxRj #) ->
      let {
        $dRealFrac_sguem [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
          :: RealFrac a_agsO1
        [LclId]
        $dRealFrac_sguem
          = GHC.Float.$p1RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
      let {
        $dReal_sguel [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
          :: Real a_agsO1
        [LclId]
        $dReal_sguel = GHC.Real.$p1RealFrac @ a_agsO1 $dRealFrac_sguem } in
      let {
        $dNum_sguek [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
          :: Num a_agsO1
        [LclId]
        $dNum_sguek = GHC.Real.$p1Real @ a_agsO1 $dReal_sguel } in
      let {
        $dOrd_sguej [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
          :: Ord a_agsO1
        [LclId]
        $dOrd_sguej = GHC.Real.$p2Real @ a_agsO1 $dReal_sguel } in
      let {
        $dFractional_sguei [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
          :: Fractional a_agsO1
        [LclId]
        $dFractional_sguei
          = GHC.Real.$p2RealFrac @ a_agsO1 $dRealFrac_sguem } in
      case < @ a_agsO1
             $dOrd_sguej
             (abs @ a_agsO1 $dNum_sguek ww7_sgxRi)
             (fromRational
                @ a_agsO1 $dFractional_sguei Data.Complex.$fFloatingComplex20)
      of {
        False ->
          case Data.Complex.$w$cfromInteger
                 @ a_agsO1 $dRealFloat_agsO2 Data.Complex.$fFloatingComplex19
          of
          { (# ww10_sgxRo, ww11_sgxRp #) ->
          case Data.Complex.$w$c+
                 @ a_agsO1
                 $dRealFloat_agsO2
                 ww10_sgxRo
                 ww11_sgxRp
                 ww7_sgxRi
                 ww8_sgxRj
          of
          { (# ww13_sgxR3, ww14_sgxR4 #) ->
          case Data.Complex.$w$clog
                 @ a_agsO1 $dRealFloat_agsO2 ww13_sgxR3 ww14_sgxR4
          of
          { (# ww16_sgxQC, ww17_sgxQD #) ->
          Data.Complex.:+ @ a_agsO1 ww16_sgxQC ww17_sgxQD
          }
          }
          };
        True ->
          case < @ a_agsO1
                 $dOrd_sguej
                 (abs @ a_agsO1 $dNum_sguek ww8_sgxRj)
                 (fromRational
                    @ a_agsO1 $dFractional_sguei Data.Complex.$fFloatingComplex20)
          of {
            False ->
              case Data.Complex.$w$cfromInteger
                     @ a_agsO1 $dRealFloat_agsO2 Data.Complex.$fFloatingComplex19
              of
              { (# ww10_sgxRo, ww11_sgxRp #) ->
              case Data.Complex.$w$c+
                     @ a_agsO1
                     $dRealFloat_agsO2
                     ww10_sgxRo
                     ww11_sgxRp
                     ww7_sgxRi
                     ww8_sgxRj
              of
              { (# ww13_sgxR3, ww14_sgxR4 #) ->
              case Data.Complex.$w$clog
                     @ a_agsO1 $dRealFloat_agsO2 ww13_sgxR3 ww14_sgxR4
              of
              { (# ww16_sgxQC, ww17_sgxQD #) ->
              Data.Complex.:+ @ a_agsO1 ww16_sgxQC ww17_sgxQD
              }
              }
              };
            True ->
              let {
                $dFloating_sguen [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                  :: Floating a_agsO1
                [LclId]
                $dFloating_sguen
                  = GHC.Float.$p2RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
              case log1p
                     @ a_agsO1
                     $dFloating_sguen
                     (let {
                        u_sguep :: a_agsO1
                        [LclId]
                        u_sguep
                          = + @ a_agsO1
                              $dNum_sguek
                              (+ @ a_agsO1
                                 $dNum_sguek
                                 (* @ a_agsO1
                                    $dNum_sguek
                                    (fromInteger
                                       @ a_agsO1 $dNum_sguek Data.Complex.$fFloatingComplex21)
                                    ww7_sgxRi)
                                 (* @ a_agsO1 $dNum_sguek ww7_sgxRi ww7_sgxRi))
                              (* @ a_agsO1 $dNum_sguek ww8_sgxRj ww8_sgxRj) } in
                      / @ a_agsO1
                        $dFractional_sguei
                        u_sguep
                        (+ @ a_agsO1
                           $dNum_sguek
                           (fromInteger
                              @ a_agsO1 $dNum_sguek Data.Complex.$fFloatingComplex19)
                           (sqrt
                              @ a_agsO1
                              $dFloating_sguen
                              (+ @ a_agsO1
                                 $dNum_sguek
                                 u_sguep
                                 (fromInteger
                                    @ a_agsO1 $dNum_sguek Data.Complex.$fFloatingComplex19)))))
              of dt_XgsO6
              { __DEFAULT ->
              case atan2
                     @ a_agsO1
                     $dRealFloat_agsO2
                     (+ @ a_agsO1
                        $dNum_sguek
                        (fromInteger
                           @ a_agsO1 $dNum_sguek Data.Complex.$fFloatingComplex19)
                        ww7_sgxRi)
                     ww8_sgxRj
              of dt1_XgsOb
              { __DEFAULT ->
              Data.Complex.:+ @ a_agsO1 dt_XgsO6 dt1_XgsOb
              }
              }
          }
      }
      }
      }
      }

-- RHS size: {terms: 103, types: 37, coercions: 0, joins: 1/6}
Data.Complex.$fFloatingComplex_$s$clog1pexp1 [InlPrag=INLINE (sat-args=1)]
  :: Complex Float -> Complex Float
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_igjq6 [Occ=Once!] :: Complex Float) ->
                 case x_igjq6 of { :+ x1_agsnS [Occ=Once!] y_agsnT [Occ=Once!] ->
                 case x1_agsnS of { GHC.Types.F# x2_sguph [Occ=Once] ->
                 case y_agsnT of { GHC.Types.F# x3_sgupk ->
                 let {
                   expx_sguGv :: GHC.Prim.Float#
                   [LclId]
                   expx_sguGv = GHC.Prim.expFloat# x2_sguph } in
                 let {
                   a_sguVU :: GHC.Prim.Float#
                   [LclId]
                   a_sguVU
                     = GHC.Prim.timesFloat#
                         expx_sguGv (GHC.Prim.cosFloat# x3_sgupk) } in
                 let {
                   b_sguVV :: GHC.Prim.Float#
                   [LclId]
                   b_sguVV
                     = GHC.Prim.timesFloat#
                         expx_sguGv (GHC.Prim.sinFloat# x3_sgupk) } in
                 join {
                   $j_sguW5 [Occ=Once*T[0]] :: Complex Float
                   [LclId[JoinId(0)]]
                   $j_sguW5
                     = let {
                         dt_sguVW [Occ=OnceL] :: GHC.Prim.Float#
                         [LclId]
                         dt_sguVW = GHC.Prim.plusFloat# 1.0# a_sguVU } in
                       let {
                         dt1_XgsFJ [Occ=OnceL] :: Float
                         [LclId, Unf=OtherCon []]
                         dt1_XgsFJ = GHC.Types.F# dt_sguVW } in
                       let {
                         dt2_XgsFO [Occ=OnceL] :: Float
                         [LclId, Unf=OtherCon []]
                         dt2_XgsFO = GHC.Types.F# b_sguVV } in
                       let {
                         eta_X6D :: Complex Float
                         [LclId, Unf=OtherCon []]
                         eta_X6D = Data.Complex.:+ @ Float dt1_XgsFJ dt2_XgsFO } in
                       case Data.Complex.$fFloatingComplex_$smagnitude1 eta_X6D of
                       { GHC.Types.F# x4_igtyY [Occ=Once] ->
                       case GHC.Prim.logFloat# x4_igtyY of wild4_igtz0 { __DEFAULT ->
                       case Data.Complex.$fFloatingComplex_$sphase1 eta_X6D of dt3_XgsF8
                       { GHC.Types.F# _ [Occ=Dead] ->
                       Data.Complex.:+ @ Float (GHC.Types.F# wild4_igtz0) dt3_XgsF8
                       }
                       }
                       } } in
                 case GHC.Prim.ltFloat# (GHC.Prim.fabsFloat# a_sguVU) 0.5# of {
                   __DEFAULT -> jump $j_sguW5;
                   1# ->
                     case GHC.Prim.ltFloat# (GHC.Prim.fabsFloat# b_sguVV) 0.5# of {
                       __DEFAULT -> jump $j_sguW5;
                       1# ->
                         let {
                           u_sguW2 :: GHC.Prim.Float#
                           [LclId]
                           u_sguW2
                             = GHC.Prim.plusFloat#
                                 (GHC.Prim.plusFloat#
                                    (GHC.Prim.plusFloat# a_sguVU a_sguVU)
                                    (GHC.Prim.timesFloat# a_sguVU a_sguVU))
                                 (GHC.Prim.timesFloat# b_sguVV b_sguVV) } in
                         case GHC.Prim.divideFloat#
                                u_sguW2
                                (GHC.Prim.plusFloat#
                                   1.0# (GHC.Prim.sqrtFloat# (GHC.Prim.plusFloat# u_sguW2 1.0#)))
                         of wild3_igtwv
                         { __DEFAULT ->
                         case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_iguSb
                                wild3_igtwv GHC.Prim.realWorld#
                         of
                         { (# _ [Occ=Dead], ds4_iguSh [Occ=Once] #) ->
                         Data.Complex.$W:+
                           @ Float
                           (GHC.Types.F# ds4_iguSh)
                           (GHC.Float.$fRealFloatFloat_$catan2
                              (GHC.Types.F# (GHC.Prim.plusFloat# 1.0# a_sguVU))
                              (GHC.Types.F# b_sguVV))
                         }
                         }
                     }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$clog1pexp1
  = \ (eta_X8a :: Complex Float) ->
      case eta_X8a of { :+ x_agsnS y_agsnT ->
      case x_agsnS of { GHC.Types.F# x1_sgzmX ->
      case y_agsnT of { GHC.Types.F# x2_sgzn0 ->
      let {
        expx_sguGv [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        expx_sguGv = GHC.Prim.expFloat# x1_sgzmX } in
      let {
        a_sguVx [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        a_sguVx
          = GHC.Prim.timesFloat#
              expx_sguGv (GHC.Prim.cosFloat# x2_sgzn0) } in
      let {
        b_sguVy [Dmd=<S,U>] :: GHC.Prim.Float#
        [LclId]
        b_sguVy
          = GHC.Prim.timesFloat#
              expx_sguGv (GHC.Prim.sinFloat# x2_sgzn0) } in
      join {
        $j_sguVL [Dmd=<L,1*U(U,U)>] :: Complex Float
        [LclId[JoinId(0)], Str=m]
        $j_sguVL
          = let {
              dt_sguVz [Dmd=<S,U>] :: GHC.Prim.Float#
              [LclId]
              dt_sguVz = GHC.Prim.plusFloat# 1.0# a_sguVx } in
            case Data.Complex.$w$smagnitude1 dt_sguVz b_sguVy of ww_sgxyg
            { __DEFAULT ->
            case GHC.Prim.logFloat# ww_sgxyg of wild3_igtz0 { __DEFAULT ->
            case Data.Complex.$w$sphase1 dt_sguVz b_sguVy of ww1_sgxxv
            { __DEFAULT ->
            Data.Complex.:+
              @ Float (GHC.Types.F# wild3_igtz0) (GHC.Types.F# ww1_sgxxv)
            }
            }
            } } in
      case GHC.Prim.ltFloat# (GHC.Prim.fabsFloat# a_sguVx) 0.5# of {
        __DEFAULT -> jump $j_sguVL;
        1# ->
          case GHC.Prim.ltFloat# (GHC.Prim.fabsFloat# b_sguVy) 0.5# of {
            __DEFAULT -> jump $j_sguVL;
            1# ->
              let {
                u_sguVF [Dmd=<S,U>] :: GHC.Prim.Float#
                [LclId]
                u_sguVF
                  = GHC.Prim.plusFloat#
                      (GHC.Prim.plusFloat#
                         (GHC.Prim.plusFloat# a_sguVx a_sguVx)
                         (GHC.Prim.timesFloat# a_sguVx a_sguVx))
                      (GHC.Prim.timesFloat# b_sguVy b_sguVy) } in
              case GHC.Prim.divideFloat#
                     u_sguVF
                     (GHC.Prim.plusFloat#
                        1.0# (GHC.Prim.sqrtFloat# (GHC.Prim.plusFloat# u_sguVF 1.0#)))
              of wild3_igtwv
              { __DEFAULT ->
              case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_iguSb
                     wild3_igtwv GHC.Prim.realWorld#
              of
              { (# ds3_iguSg, ds4_iguSh #) ->
              case GHC.Float.$w$catan1
                     (GHC.Types.F# (GHC.Prim.plusFloat# 1.0# a_sguVx)) b_sguVy
              of ww2_iguI2
              { __DEFAULT ->
              Data.Complex.:+
                @ Float (GHC.Types.F# ds4_iguSh) (GHC.Types.F# ww2_iguI2)
              }
              }
              }
          }
      }
      }
      }
      }

-- RHS size: {terms: 103, types: 37, coercions: 0, joins: 1/6}
Data.Complex.$fFloatingComplex_$s$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: Complex Double -> Complex Double
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_igjq6 [Occ=Once!] :: Complex Double) ->
                 case x_igjq6 of { :+ x1_agsnS [Occ=Once!] y_agsnT [Occ=Once!] ->
                 case x1_agsnS of { GHC.Types.D# x2_sgurX [Occ=Once] ->
                 case y_agsnT of { GHC.Types.D# x3_sgus0 ->
                 let {
                   expx_sguIB :: GHC.Prim.Double#
                   [LclId]
                   expx_sguIB = GHC.Prim.expDouble# x2_sgurX } in
                 let {
                   a_sguWB :: GHC.Prim.Double#
                   [LclId]
                   a_sguWB
                     = GHC.Prim.*## expx_sguIB (GHC.Prim.cosDouble# x3_sgus0) } in
                 let {
                   b_sguWC :: GHC.Prim.Double#
                   [LclId]
                   b_sguWC
                     = GHC.Prim.*## expx_sguIB (GHC.Prim.sinDouble# x3_sgus0) } in
                 join {
                   $j_sguWM [Occ=Once*T[0]] :: Complex Double
                   [LclId[JoinId(0)]]
                   $j_sguWM
                     = let {
                         dt_sguWD [Occ=OnceL] :: GHC.Prim.Double#
                         [LclId]
                         dt_sguWD = GHC.Prim.+## 1.0## a_sguWB } in
                       let {
                         dt1_XgsFJ [Occ=OnceL] :: Double
                         [LclId, Unf=OtherCon []]
                         dt1_XgsFJ = GHC.Types.D# dt_sguWD } in
                       let {
                         dt2_XgsFO [Occ=OnceL] :: Double
                         [LclId, Unf=OtherCon []]
                         dt2_XgsFO = GHC.Types.D# b_sguWC } in
                       let {
                         eta_X6D :: Complex Double
                         [LclId, Unf=OtherCon []]
                         eta_X6D = Data.Complex.:+ @ Double dt1_XgsFJ dt2_XgsFO } in
                       case Data.Complex.$fFloatingComplex_$smagnitude eta_X6D of
                       { GHC.Types.D# x4_igtzk [Occ=Once] ->
                       case GHC.Prim.logDouble# x4_igtzk of wild4_igtzm { __DEFAULT ->
                       case Data.Complex.$fFloatingComplex_$sphase eta_X6D of dt3_XgsF8
                       { GHC.Types.D# _ [Occ=Dead] ->
                       Data.Complex.:+ @ Double (GHC.Types.D# wild4_igtzm) dt3_XgsF8
                       }
                       }
                       } } in
                 case GHC.Prim.<## (GHC.Prim.fabsDouble# a_sguWB) 0.5## of {
                   __DEFAULT -> jump $j_sguWM;
                   1# ->
                     case GHC.Prim.<## (GHC.Prim.fabsDouble# b_sguWC) 0.5## of {
                       __DEFAULT -> jump $j_sguWM;
                       1# ->
                         let {
                           u_sguWJ :: GHC.Prim.Double#
                           [LclId]
                           u_sguWJ
                             = GHC.Prim.+##
                                 (GHC.Prim.+##
                                    (GHC.Prim.+## a_sguWB a_sguWB) (GHC.Prim.*## a_sguWB a_sguWB))
                                 (GHC.Prim.*## b_sguWC b_sguWC) } in
                         case GHC.Prim./##
                                u_sguWJ
                                (GHC.Prim.+##
                                   1.0## (GHC.Prim.sqrtDouble# (GHC.Prim.+## u_sguWJ 1.0##)))
                         of wild3_igtAA
                         { __DEFAULT ->
                         case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_iguT3
                                wild3_igtAA GHC.Prim.realWorld#
                         of
                         { (# _ [Occ=Dead], ds4_iguT9 [Occ=Once] #) ->
                         Data.Complex.$W:+
                           @ Double
                           (GHC.Types.D# ds4_iguT9)
                           (GHC.Float.$fRealFloatDouble_$catan2
                              (GHC.Types.D# (GHC.Prim.+## 1.0## a_sguWB)) (GHC.Types.D# b_sguWC))
                         }
                         }
                     }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$clog1pexp
  = \ (eta_X8a :: Complex Double) ->
      case eta_X8a of { :+ x_agsnS y_agsnT ->
      case x_agsnS of { GHC.Types.D# x1_sgzn3 ->
      case y_agsnT of { GHC.Types.D# x2_sgzn6 ->
      let {
        expx_sguIB [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        expx_sguIB = GHC.Prim.expDouble# x1_sgzn3 } in
      let {
        a_sguWe [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        a_sguWe
          = GHC.Prim.*## expx_sguIB (GHC.Prim.cosDouble# x2_sgzn6) } in
      let {
        b_sguWf [Dmd=<S,U>] :: GHC.Prim.Double#
        [LclId]
        b_sguWf
          = GHC.Prim.*## expx_sguIB (GHC.Prim.sinDouble# x2_sgzn6) } in
      join {
        $j_sguWs [Dmd=<L,1*U(U,U)>] :: Complex Double
        [LclId[JoinId(0)], Str=m]
        $j_sguWs
          = let {
              dt_sguWg [Dmd=<S,U>] :: GHC.Prim.Double#
              [LclId]
              dt_sguWg = GHC.Prim.+## 1.0## a_sguWe } in
            case Data.Complex.$w$smagnitude dt_sguWg b_sguWf of ww_sgxxX
            { __DEFAULT ->
            case GHC.Prim.logDouble# ww_sgxxX of wild3_igtzm { __DEFAULT ->
            case Data.Complex.$w$sphase dt_sguWg b_sguWf of ww1_sgxxd
            { __DEFAULT ->
            Data.Complex.:+
              @ Double (GHC.Types.D# wild3_igtzm) (GHC.Types.D# ww1_sgxxd)
            }
            }
            } } in
      case GHC.Prim.<## (GHC.Prim.fabsDouble# a_sguWe) 0.5## of {
        __DEFAULT -> jump $j_sguWs;
        1# ->
          case GHC.Prim.<## (GHC.Prim.fabsDouble# b_sguWf) 0.5## of {
            __DEFAULT -> jump $j_sguWs;
            1# ->
              let {
                u_sguWm [Dmd=<S,U>] :: GHC.Prim.Double#
                [LclId]
                u_sguWm
                  = GHC.Prim.+##
                      (GHC.Prim.+##
                         (GHC.Prim.+## a_sguWe a_sguWe) (GHC.Prim.*## a_sguWe a_sguWe))
                      (GHC.Prim.*## b_sguWf b_sguWf) } in
              case GHC.Prim./##
                     u_sguWm
                     (GHC.Prim.+##
                        1.0## (GHC.Prim.sqrtDouble# (GHC.Prim.+## u_sguWm 1.0##)))
              of wild3_igtAA
              { __DEFAULT ->
              case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_iguT3
                     wild3_igtAA GHC.Prim.realWorld#
              of
              { (# ds3_iguT8, ds4_iguT9 #) ->
              case GHC.Float.$w$catan2
                     (GHC.Types.D# (GHC.Prim.+## 1.0## a_sguWe)) b_sguWf
              of ww2_igty4
              { __DEFAULT ->
              Data.Complex.:+
                @ Double (GHC.Types.D# ds4_iguT9) (GHC.Types.D# ww2_igty4)
              }
              }
              }
          }
      }
      }
      }
      }

-- RHS size: {terms: 149, types: 114, coercions: 0, joins: 0/7}
Data.Complex.$fFloatingComplex_$clog1pexp [InlPrag=INLINE (sat-args=1)]
  :: forall a. RealFloat a => Complex a -> Complex a
[GblId,
 Arity=2,
 Str=<S(S(S(S(LLC(C(S))LLLL)S(LLC(C(S))LLLLL)L)LLLLLL)SLLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A),U(A,A,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_agsO1)
                 ($dRealFloat_agsO2 :: RealFloat a_agsO1)
                 (x_igjq6 [Occ=Once] :: Complex a_agsO1) ->
                 let {
                   $dFloating_agt63 :: Floating a_agsO1
                   [LclId]
                   $dFloating_agt63
                     = GHC.Float.$p2RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
                 let {
                   $dRealFrac_agt62 :: RealFrac a_agsO1
                   [LclId]
                   $dRealFrac_agt62
                     = GHC.Float.$p1RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
                 let {
                   $dReal_agt64 :: Real a_agsO1
                   [LclId]
                   $dReal_agt64 = GHC.Real.$p1RealFrac @ a_agsO1 $dRealFrac_agt62 } in
                 let {
                   $dNum_agt66 :: Num a_agsO1
                   [LclId]
                   $dNum_agt66 = GHC.Real.$p1Real @ a_agsO1 $dReal_agt64 } in
                 let {
                   $dOrd_agt67 :: Ord a_agsO1
                   [LclId]
                   $dOrd_agt67 = GHC.Real.$p2Real @ a_agsO1 $dReal_agt64 } in
                 let {
                   $dFractional_agt65 :: Fractional a_agsO1
                   [LclId]
                   $dFractional_agt65
                     = GHC.Real.$p2RealFrac @ a_agsO1 $dRealFrac_agt62 } in
                 case Data.Complex.$fFloatingComplex_$cexp
                        @ a_agsO1 $dRealFloat_agsO2 x_igjq6
                 of wild_X7w
                 { :+ a1_agsoO b_agsoP ->
                 case < @ a_agsO1
                        $dOrd_agt67
                        (abs @ a_agsO1 $dNum_agt66 a1_agsoO)
                        (fromRational
                           @ a_agsO1 $dFractional_agt65 (GHC.Real.:% @ Integer 1 2))
                 of {
                   False ->
                     Data.Complex.$fFloatingComplex_$clog
                       @ a_agsO1
                       $dRealFloat_agsO2
                       (Data.Complex.$fFloatingComplex_$c+
                          @ a_agsO1
                          $dRealFloat_agsO2
                          (Data.Complex.$fFloatingComplex_$cfromInteger
                             @ a_agsO1 $dRealFloat_agsO2 1)
                          wild_X7w);
                   True ->
                     case < @ a_agsO1
                            $dOrd_agt67
                            (abs @ a_agsO1 $dNum_agt66 b_agsoP)
                            (fromRational
                               @ a_agsO1 $dFractional_agt65 (GHC.Real.:% @ Integer 1 2))
                     of {
                       False ->
                         Data.Complex.$fFloatingComplex_$clog
                           @ a_agsO1
                           $dRealFloat_agsO2
                           (Data.Complex.$fFloatingComplex_$c+
                              @ a_agsO1
                              $dRealFloat_agsO2
                              (Data.Complex.$fFloatingComplex_$cfromInteger
                                 @ a_agsO1 $dRealFloat_agsO2 1)
                              wild_X7w);
                       True ->
                         let {
                           u_agsoQ :: a_agsO1
                           [LclId]
                           u_agsoQ
                             = + @ a_agsO1
                                 $dNum_agt66
                                 (+ @ a_agsO1
                                    $dNum_agt66
                                    (* @ a_agsO1
                                       $dNum_agt66
                                       (fromInteger @ a_agsO1 $dNum_agt66 2)
                                       a1_agsoO)
                                    (* @ a_agsO1 $dNum_agt66 a1_agsoO a1_agsoO))
                                 (* @ a_agsO1 $dNum_agt66 b_agsoP b_agsoP) } in
                         Data.Complex.$W:+
                           @ a_agsO1
                           (log1p
                              @ a_agsO1
                              $dFloating_agt63
                              (/ @ a_agsO1
                                 $dFractional_agt65
                                 u_agsoQ
                                 (+ @ a_agsO1
                                    $dNum_agt66
                                    (fromInteger @ a_agsO1 $dNum_agt66 1)
                                    (sqrt
                                       @ a_agsO1
                                       $dFloating_agt63
                                       (+ @ a_agsO1
                                          $dNum_agt66
                                          u_agsoQ
                                          (fromInteger @ a_agsO1 $dNum_agt66 1))))))
                           (atan2
                              @ a_agsO1
                              $dRealFloat_agsO2
                              (+ @ a_agsO1
                                 $dNum_agt66
                                 (fromInteger @ a_agsO1 $dNum_agt66 1)
                                 a1_agsoO)
                              b_agsoP)
                     }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$clog1pexp
  = \ (@ a_agsO1)
      ($dRealFloat_agsO2 :: RealFloat a_agsO1)
      (eta_X8a :: Complex a_agsO1) ->
      case eta_X8a of { :+ ww1_sgxyU ww2_sgxyV ->
      case Data.Complex.$w$cexp
             @ a_agsO1 $dRealFloat_agsO2 ww1_sgxyU ww2_sgxyV
      of
      { (# ww4_sgxQw, ww5_sgxQx #) ->
      let {
        $dRealFrac_sgudC [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A),1*U(A,1*C1(C1(U)),A,C(U)),A,A,A,A,A)>]
          :: RealFrac a_agsO1
        [LclId]
        $dRealFrac_sgudC
          = GHC.Float.$p1RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
      let {
        $dReal_sgudB [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),1*U(A,A,C(C1(U)),A,A,A,A,A),A)>]
          :: Real a_agsO1
        [LclId]
        $dReal_sgudB = GHC.Real.$p1RealFrac @ a_agsO1 $dRealFrac_sgudC } in
      let {
        $dNum_sgudA [Dmd=<L,U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U))>]
          :: Num a_agsO1
        [LclId]
        $dNum_sgudA = GHC.Real.$p1Real @ a_agsO1 $dReal_sgudB } in
      let {
        $dOrd_sgudz [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
          :: Ord a_agsO1
        [LclId]
        $dOrd_sgudz = GHC.Real.$p2Real @ a_agsO1 $dReal_sgudB } in
      let {
        $dFractional_sgudy [Dmd=<L,U(A,1*C1(C1(U)),A,C(U))>]
          :: Fractional a_agsO1
        [LclId]
        $dFractional_sgudy
          = GHC.Real.$p2RealFrac @ a_agsO1 $dRealFrac_sgudC } in
      case < @ a_agsO1
             $dOrd_sgudz
             (abs @ a_agsO1 $dNum_sgudA ww4_sgxQw)
             (fromRational
                @ a_agsO1 $dFractional_sgudy Data.Complex.$fFloatingComplex20)
      of {
        False ->
          case Data.Complex.$w$cfromInteger
                 @ a_agsO1 $dRealFloat_agsO2 Data.Complex.$fFloatingComplex19
          of
          { (# ww7_sgxRo, ww8_sgxRp #) ->
          case Data.Complex.$w$c+
                 @ a_agsO1 $dRealFloat_agsO2 ww7_sgxRo ww8_sgxRp ww4_sgxQw ww5_sgxQx
          of
          { (# ww10_sgxR3, ww11_sgxR4 #) ->
          case Data.Complex.$w$clog
                 @ a_agsO1 $dRealFloat_agsO2 ww10_sgxR3 ww11_sgxR4
          of
          { (# ww13_sgxQC, ww14_sgxQD #) ->
          Data.Complex.:+ @ a_agsO1 ww13_sgxQC ww14_sgxQD
          }
          }
          };
        True ->
          case < @ a_agsO1
                 $dOrd_sgudz
                 (abs @ a_agsO1 $dNum_sgudA ww5_sgxQx)
                 (fromRational
                    @ a_agsO1 $dFractional_sgudy Data.Complex.$fFloatingComplex20)
          of {
            False ->
              case Data.Complex.$w$cfromInteger
                     @ a_agsO1 $dRealFloat_agsO2 Data.Complex.$fFloatingComplex19
              of
              { (# ww7_sgxRo, ww8_sgxRp #) ->
              case Data.Complex.$w$c+
                     @ a_agsO1 $dRealFloat_agsO2 ww7_sgxRo ww8_sgxRp ww4_sgxQw ww5_sgxQx
              of
              { (# ww10_sgxR3, ww11_sgxR4 #) ->
              case Data.Complex.$w$clog
                     @ a_agsO1 $dRealFloat_agsO2 ww10_sgxR3 ww11_sgxR4
              of
              { (# ww13_sgxQC, ww14_sgxQD #) ->
              Data.Complex.:+ @ a_agsO1 ww13_sgxQC ww14_sgxQD
              }
              }
              };
            True ->
              let {
                $dFloating_sgudD [Dmd=<S(LLLLLLLLLLLLLLLLLLLC(S)LLL),U(A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A)>]
                  :: Floating a_agsO1
                [LclId]
                $dFloating_sgudD
                  = GHC.Float.$p2RealFloat @ a_agsO1 $dRealFloat_agsO2 } in
              case log1p
                     @ a_agsO1
                     $dFloating_sgudD
                     (let {
                        u_sgudF :: a_agsO1
                        [LclId]
                        u_sgudF
                          = + @ a_agsO1
                              $dNum_sgudA
                              (+ @ a_agsO1
                                 $dNum_sgudA
                                 (* @ a_agsO1
                                    $dNum_sgudA
                                    (fromInteger
                                       @ a_agsO1 $dNum_sgudA Data.Complex.$fFloatingComplex21)
                                    ww4_sgxQw)
                                 (* @ a_agsO1 $dNum_sgudA ww4_sgxQw ww4_sgxQw))
                              (* @ a_agsO1 $dNum_sgudA ww5_sgxQx ww5_sgxQx) } in
                      / @ a_agsO1
                        $dFractional_sgudy
                        u_sgudF
                        (+ @ a_agsO1
                           $dNum_sgudA
                           (fromInteger
                              @ a_agsO1 $dNum_sgudA Data.Complex.$fFloatingComplex19)
                           (sqrt
                              @ a_agsO1
                              $dFloating_sgudD
                              (+ @ a_agsO1
                                 $dNum_sgudA
                                 u_sgudF
                                 (fromInteger
                                    @ a_agsO1 $dNum_sgudA Data.Complex.$fFloatingComplex19)))))
              of dt_XgsPl
              { __DEFAULT ->
              case atan2
                     @ a_agsO1
                     $dRealFloat_agsO2
                     (+ @ a_agsO1
                        $dNum_sgudA
                        (fromInteger
                           @ a_agsO1 $dNum_sgudA Data.Complex.$fFloatingComplex19)
                        ww4_sgxQw)
                     ww5_sgxQx
              of dt1_XgsPq
              { __DEFAULT ->
              Data.Complex.:+ @ a_agsO1 dt_XgsPl dt1_XgsPq
              }
              }
          }
      }
      }
      }

-- RHS size: {terms: 58, types: 34, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$clogBase1 [InlPrag=INLINE (sat-args=2)]
  :: Complex Float -> Complex Float -> Complex Float
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_igteM :: Complex Float) (y_igteN :: Complex Float) ->
                 case Data.Complex.$fFloatingComplex_$smagnitude1 y_igteN of
                 { GHC.Types.F# x1_igtyY [Occ=Once] ->
                 case GHC.Prim.logFloat# x1_igtyY of wild1_igtz0 { __DEFAULT ->
                 case Data.Complex.$fFloatingComplex_$sphase1 y_igteN of dt_XgsF8
                 { GHC.Types.F# _ [Occ=Dead] ->
                 case Data.Complex.$fFloatingComplex_$smagnitude1 x_igteM of
                 { GHC.Types.F# x2_XgtOP [Occ=Once] ->
                 case GHC.Prim.logFloat# x2_XgtOP of wild3_XgtOT { __DEFAULT ->
                 case Data.Complex.$fFloatingComplex_$sphase1 x_igteM of dt1_XgsV4
                 { GHC.Types.F# _ [Occ=Dead] ->
                 Data.Complex.$fFloatingComplex_$s$c/1
                   (Data.Complex.:+ @ Float (GHC.Types.F# wild1_igtz0) dt_XgsF8)
                   (Data.Complex.:+ @ Float (GHC.Types.F# wild3_XgtOT) dt1_XgsV4)
                 }
                 }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$clogBase1
  = \ (eta_X8c :: Complex Float) (eta1_Xgn :: Complex Float) ->
      case eta1_Xgn of { :+ ww1_sgxy3 ww2_sgxy8 ->
      case ww1_sgxy3 of { GHC.Types.F# ww4_sgzn9 ->
      case ww2_sgxy8 of { GHC.Types.F# ww6_sgznc ->
      case Data.Complex.$w$smagnitude1 ww4_sgzn9 ww6_sgznc of ww7_sgxyg
      { __DEFAULT ->
      case GHC.Prim.logFloat# ww7_sgxyg of wild1_igtz0 { __DEFAULT ->
      case Data.Complex.$w$sphase1 ww4_sgzn9 ww6_sgznc of ww8_sgxxv
      { __DEFAULT ->
      case eta_X8c of { :+ ww10_XgxOk ww11_XgxOq ->
      case ww10_XgxOk of { GHC.Types.F# ww13_sgznf ->
      case ww11_XgxOq of { GHC.Types.F# ww15_sgzni ->
      case Data.Complex.$w$smagnitude1 ww13_sgznf ww15_sgzni
      of ww16_XgxOL
      { __DEFAULT ->
      case GHC.Prim.logFloat# ww16_XgxOL of wild2_XgtPz { __DEFAULT ->
      case Data.Complex.$w$sphase1 ww13_sgznf ww15_sgzni of ww17_XgxOb
      { __DEFAULT ->
      case Data.Complex.$w$s$c/1
             wild1_igtz0 ww8_sgxxv wild2_XgtPz ww17_XgxOb
      of
      { (# ww19_sgxQb, ww20_sgxQc #) ->
      Data.Complex.:+ @ Float ww19_sgxQb ww20_sgxQc
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 58, types: 34, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$clogBase [InlPrag=INLINE (sat-args=2)]
  :: Complex Double -> Complex Double -> Complex Double
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(U(U),U(U))><S(S(S)S(S)),1*U(U(U),U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_igteM :: Complex Double) (y_igteN :: Complex Double) ->
                 case Data.Complex.$fFloatingComplex_$smagnitude y_igteN of
                 { GHC.Types.D# x1_igtzk [Occ=Once] ->
                 case GHC.Prim.logDouble# x1_igtzk of wild1_igtzm { __DEFAULT ->
                 case Data.Complex.$fFloatingComplex_$sphase y_igteN of dt_XgsF8
                 { GHC.Types.D# _ [Occ=Dead] ->
                 case Data.Complex.$fFloatingComplex_$smagnitude x_igteM of
                 { GHC.Types.D# x2_XgtPc [Occ=Once] ->
                 case GHC.Prim.logDouble# x2_XgtPc of wild3_XgtPg { __DEFAULT ->
                 case Data.Complex.$fFloatingComplex_$sphase x_igteM of dt1_XgsV5
                 { GHC.Types.D# _ [Occ=Dead] ->
                 Data.Complex.$fFloatingComplex_$s$c/
                   (Data.Complex.:+ @ Double (GHC.Types.D# wild1_igtzm) dt_XgsF8)
                   (Data.Complex.:+ @ Double (GHC.Types.D# wild3_XgtPg) dt1_XgsV5)
                 }
                 }
                 }
                 }
                 }
                 }}]
Data.Complex.$fFloatingComplex_$s$clogBase
  = \ (eta_X8c :: Complex Double) (eta1_Xgn :: Complex Double) ->
      case eta1_Xgn of { :+ ww1_sgxxK ww2_sgxxP ->
      case ww1_sgxxK of { GHC.Types.D# ww4_sgznl ->
      case ww2_sgxxP of { GHC.Types.D# ww6_sgzno ->
      case Data.Complex.$w$smagnitude ww4_sgznl ww6_sgzno of ww7_sgxxX
      { __DEFAULT ->
      case GHC.Prim.logDouble# ww7_sgxxX of wild1_igtzm { __DEFAULT ->
      case Data.Complex.$w$sphase ww4_sgznl ww6_sgzno of ww8_sgxxd
      { __DEFAULT ->
      case eta_X8c of { :+ ww10_XgxO2 ww11_XgxO8 ->
      case ww10_XgxO2 of { GHC.Types.D# ww13_sgznr ->
      case ww11_XgxO8 of { GHC.Types.D# ww15_sgznu ->
      case Data.Complex.$w$smagnitude ww13_sgznr ww15_sgznu of ww16_XgxOt
      { __DEFAULT ->
      case GHC.Prim.logDouble# ww16_XgxOt of wild2_XgtPW { __DEFAULT ->
      case Data.Complex.$w$sphase ww13_sgznr ww15_sgznu of ww17_XgxNU
      { __DEFAULT ->
      case Data.Complex.$w$s$c/
             wild1_igtzm ww8_sgxxd wild2_XgtPW ww17_XgxNU
      of
      { (# ww19_sgxQR, ww20_sgxQS #) ->
      Data.Complex.:+ @ Double ww19_sgxQR ww20_sgxQS
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 33, types: 41, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$clogBase [InlPrag=INLINE (sat-args=2)]
  :: forall a. RealFloat a => Complex a -> Complex a -> Complex a
[GblId,
 Arity=3,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)S(LC(C(S))LL)LLLLL)S(LLLC(S)LLLLLLLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),U(A,C(C1(U)),A,A),A,A,A,A,A),U(A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,A,A,A,A,C(C1(U)))><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_agsO1)
                 ($dRealFloat_agsO2 :: RealFloat a_agsO1)
                 (x_igteM [Occ=Once] :: Complex a_agsO1)
                 (y_igteN [Occ=Once] :: Complex a_agsO1) ->
                 Data.Complex.$fFloatingComplex_$c/
                   @ a_agsO1
                   $dRealFloat_agsO2
                   (Data.Complex.$fFloatingComplex_$clog
                      @ a_agsO1 $dRealFloat_agsO2 y_igteN)
                   (Data.Complex.$fFloatingComplex_$clog
                      @ a_agsO1 $dRealFloat_agsO2 x_igteM)}]
Data.Complex.$fFloatingComplex_$clogBase
  = \ (@ a_agsO1)
      ($dRealFloat_agsO2 :: RealFloat a_agsO1)
      (eta_X8c :: Complex a_agsO1)
      (eta1_Xgn :: Complex a_agsO1) ->
      case eta1_Xgn of { :+ ww1_sgxzo ww2_sgxzp ->
      case Data.Complex.$w$clog
             @ a_agsO1 $dRealFloat_agsO2 ww1_sgxzo ww2_sgxzp
      of
      { (# ww4_sgxQC, ww5_sgxQD #) ->
      case eta_X8c of { :+ ww7_XgxPm ww8_XgxPo ->
      case Data.Complex.$w$clog
             @ a_agsO1 $dRealFloat_agsO2 ww7_XgxPm ww8_XgxPo
      of
      { (# ww10_Xgy6G, ww11_Xgy6I #) ->
      case Data.Complex.$w$c/
             @ a_agsO1
             $dRealFloat_agsO2
             ww4_sgxQC
             ww5_sgxQD
             ww10_Xgy6G
             ww11_Xgy6I
      of
      { (# ww13_sgxQU, ww14_sgxQV #) ->
      Data.Complex.:+ @ a_agsO1 ww13_sgxQU ww14_sgxQV
      }
      }
      }
      }
      }

-- RHS size: {terms: 24, types: 2, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$fFloatingComplex1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Floating (Complex Float)
[GblId,
 Unf=DFun: \ ->
       GHC.Float.C:Floating TYPE: Complex Float
                            Data.Complex.$fFloatingComplex_$s$fFractionalComplex1
                            Data.Complex.$fFloatingComplex_$s$cpi1
                            Data.Complex.$fFloatingComplex_$s$cexp1
                            Data.Complex.$fFloatingComplex_$s$clog1
                            Data.Complex.$fFloatingComplex_$s$csqrt1
                            Data.Complex.$fFloatingComplex_$s$c**1
                            Data.Complex.$fFloatingComplex_$s$clogBase1
                            Data.Complex.$fFloatingComplex_$s$csin1
                            Data.Complex.$fFloatingComplex_$s$ccos1
                            Data.Complex.$fFloatingComplex_$s$ctan1
                            Data.Complex.$fFloatingComplex_$s$casin1
                            Data.Complex.$fFloatingComplex_$s$cacos1
                            Data.Complex.$fFloatingComplex_$s$catan1
                            Data.Complex.$fFloatingComplex_$s$csinh1
                            Data.Complex.$fFloatingComplex_$s$ccosh1
                            Data.Complex.$fFloatingComplex_$s$ctanh1
                            Data.Complex.$fFloatingComplex_$s$casinh1
                            Data.Complex.$fFloatingComplex_$s$cacosh1
                            Data.Complex.$fFloatingComplex_$s$catanh1
                            Data.Complex.$fFloatingComplex_$s$clog1p1
                            Data.Complex.$fFloatingComplex_$s$cexpm2
                            Data.Complex.$fFloatingComplex_$s$clog1pexp1
                            Data.Complex.$fFloatingComplex_$s$clog1mexp1]
Data.Complex.$fFloatingComplex_$s$fFloatingComplex1
  = GHC.Float.C:Floating
      @ (Complex Float)
      Data.Complex.$fFloatingComplex_$s$fFractionalComplex1
      Data.Complex.$fFloatingComplex_$s$cpi1
      Data.Complex.$fFloatingComplex_$s$cexp1
      Data.Complex.$fFloatingComplex_$s$clog1
      Data.Complex.$fFloatingComplex_$s$csqrt1
      Data.Complex.$fFloatingComplex_$s$c**1
      Data.Complex.$fFloatingComplex_$s$clogBase1
      Data.Complex.$fFloatingComplex_$s$csin1
      Data.Complex.$fFloatingComplex_$s$ccos1
      Data.Complex.$fFloatingComplex_$s$ctan1
      Data.Complex.$fFloatingComplex_$s$casin1
      Data.Complex.$fFloatingComplex_$s$cacos1
      Data.Complex.$fFloatingComplex_$s$catan1
      Data.Complex.$fFloatingComplex_$s$csinh1
      Data.Complex.$fFloatingComplex_$s$ccosh1
      Data.Complex.$fFloatingComplex_$s$ctanh1
      Data.Complex.$fFloatingComplex_$s$casinh1
      Data.Complex.$fFloatingComplex_$s$cacosh1
      Data.Complex.$fFloatingComplex_$s$catanh1
      Data.Complex.$fFloatingComplex_$s$clog1p1
      Data.Complex.$fFloatingComplex_$s$cexpm2
      Data.Complex.$fFloatingComplex_$s$clog1pexp1
      Data.Complex.$fFloatingComplex_$s$clog1mexp1

-- RHS size: {terms: 24, types: 2, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex_$s$fFloatingComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: Floating (Complex Double)
[GblId,
 Unf=DFun: \ ->
       GHC.Float.C:Floating TYPE: Complex Double
                            Data.Complex.$fFloatingComplex_$s$fFractionalComplex
                            Data.Complex.$fFloatingComplex_$s$cpi
                            Data.Complex.$fFloatingComplex_$s$cexp
                            Data.Complex.$fFloatingComplex_$s$clog
                            Data.Complex.$fFloatingComplex_$s$csqrt
                            Data.Complex.$fFloatingComplex_$s$c**
                            Data.Complex.$fFloatingComplex_$s$clogBase
                            Data.Complex.$fFloatingComplex_$s$csin
                            Data.Complex.$fFloatingComplex_$s$ccos
                            Data.Complex.$fFloatingComplex_$s$ctan
                            Data.Complex.$fFloatingComplex_$s$casin
                            Data.Complex.$fFloatingComplex_$s$cacos
                            Data.Complex.$fFloatingComplex_$s$catan
                            Data.Complex.$fFloatingComplex_$s$csinh
                            Data.Complex.$fFloatingComplex_$s$ccosh
                            Data.Complex.$fFloatingComplex_$s$ctanh
                            Data.Complex.$fFloatingComplex_$s$casinh
                            Data.Complex.$fFloatingComplex_$s$cacosh
                            Data.Complex.$fFloatingComplex_$s$catanh
                            Data.Complex.$fFloatingComplex_$s$clog1p
                            Data.Complex.$fFloatingComplex_$s$cexpm1
                            Data.Complex.$fFloatingComplex_$s$clog1pexp
                            Data.Complex.$fFloatingComplex_$s$clog1mexp]
Data.Complex.$fFloatingComplex_$s$fFloatingComplex
  = GHC.Float.C:Floating
      @ (Complex Double)
      Data.Complex.$fFloatingComplex_$s$fFractionalComplex
      Data.Complex.$fFloatingComplex_$s$cpi
      Data.Complex.$fFloatingComplex_$s$cexp
      Data.Complex.$fFloatingComplex_$s$clog
      Data.Complex.$fFloatingComplex_$s$csqrt
      Data.Complex.$fFloatingComplex_$s$c**
      Data.Complex.$fFloatingComplex_$s$clogBase
      Data.Complex.$fFloatingComplex_$s$csin
      Data.Complex.$fFloatingComplex_$s$ccos
      Data.Complex.$fFloatingComplex_$s$ctan
      Data.Complex.$fFloatingComplex_$s$casin
      Data.Complex.$fFloatingComplex_$s$cacos
      Data.Complex.$fFloatingComplex_$s$catan
      Data.Complex.$fFloatingComplex_$s$csinh
      Data.Complex.$fFloatingComplex_$s$ccosh
      Data.Complex.$fFloatingComplex_$s$ctanh
      Data.Complex.$fFloatingComplex_$s$casinh
      Data.Complex.$fFloatingComplex_$s$cacosh
      Data.Complex.$fFloatingComplex_$s$catanh
      Data.Complex.$fFloatingComplex_$s$clog1p
      Data.Complex.$fFloatingComplex_$s$cexpm1
      Data.Complex.$fFloatingComplex_$s$clog1pexp
      Data.Complex.$fFloatingComplex_$s$clog1mexp

-- RHS size: {terms: 49, types: 29, coercions: 0, joins: 0/0}
Data.Complex.$fFloatingComplex [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. RealFloat a => Floating (Complex a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),A,C(U)),U(U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A),A),U(A,C(C1(U)),A,C(U)),A,A,A,A,A),U(A,U,C(U),C(U),C(U),A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A,A,A,C(U),C(U),A,A),A,A,A,A,A,C(U(U)),A,C(C1(U)),A,C(U),A,A,A,C(C1(U)))>,
 Unf=DFun: \ (@ a_agsnR) (v_X8o :: RealFloat a_agsnR) ->
       GHC.Float.C:Floating TYPE: Complex a_agsnR
                            Data.Complex.$fFractionalComplex @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$cpi @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$cexp @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$clog @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$csqrt @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$c** @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$clogBase @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$csin @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$ccos @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$ctan @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$casin @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$cacos @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$catan @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$csinh @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$ccosh @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$ctanh @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$casinh @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$cacosh @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$catanh @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$clog1p @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$cexpm1 @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$clog1pexp @ a_agsnR v_X8o
                            Data.Complex.$fFloatingComplex_$clog1mexp @ a_agsnR v_X8o]
Data.Complex.$fFloatingComplex
  = \ (@ a_agsO1) ($dRealFloat_agsO2 :: RealFloat a_agsO1) ->
      GHC.Float.C:Floating
        @ (Complex a_agsO1)
        (Data.Complex.$fFractionalComplex @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$cpi @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$cexp @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$clog @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$csqrt @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$c** @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$clogBase
           @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$csin @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$ccos @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$ctan @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$casin @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$cacos @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$catan @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$csinh @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$ccosh @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$ctanh @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$casinh
           @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$cacosh
           @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$catanh
           @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$clog1p
           @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$cexpm1
           @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$clog1pexp
           @ a_agsO1 $dRealFloat_agsO2)
        (Data.Complex.$fFloatingComplex_$clog1mexp
           @ a_agsO1 $dRealFloat_agsO2)


------ Local rules for imported ids --------
"SPEC conjugate"
    forall ($dNum_agszp :: Num Double).
      conjugate @ Double $dNum_agszp
      = Data.Complex.conjugate_$sconjugate
"SPEC cis"
    forall ($dFloating_agsyL :: Floating Double).
      cis @ Double $dFloating_agsyL
      = Data.Complex.cis_$scis
"SPEC mkPolar"
    forall ($dFloating_agsz9 :: Floating Double).
      mkPolar @ Double $dFloating_agsz9
      = Data.Complex.mkPolar_$smkPolar
"SPEC phase @ Float"
    forall ($dRealFloat_sgun1 :: RealFloat Float).
      phase @ Float $dRealFloat_sgun1
      = Data.Complex.$fFloatingComplex_$sphase1
"SPEC phase"
    forall ($dRealFloat_agsx3 :: RealFloat Double).
      phase @ Double $dRealFloat_agsx3
      = Data.Complex.$fFloatingComplex_$sphase
"SPEC magnitude @ Float"
    forall ($dRealFloat_sgumq :: RealFloat Float).
      magnitude @ Float $dRealFloat_sgumq
      = Data.Complex.$fFloatingComplex_$smagnitude1
"SPEC magnitude"
    forall ($dRealFloat_agsyc :: RealFloat Double).
      magnitude @ Double $dRealFloat_agsyc
      = Data.Complex.$fFloatingComplex_$smagnitude
"SPEC polar"
    forall ($dRealFloat_agsyt :: RealFloat Double).
      polar @ Double $dRealFloat_agsyt
      = Data.Complex.polar_$spolar
"SPEC $cpi"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$cpi @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$cpi1
"SPEC $cpi"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$cpi @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$cpi
"SPEC $cexp"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$cexp @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$cexp1
"SPEC $cexp"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$cexp @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$cexp
"SPEC $clog"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$clog @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$clog1
"SPEC $clog"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$clog @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$clog
"SPEC $csin"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$csin @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$csin1
"SPEC $csin"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$csin @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$csin
"SPEC $ccos"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$ccos @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$ccos1
"SPEC $ccos"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$ccos @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$ccos
"SPEC $csinh"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$csinh @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$csinh1
"SPEC $csinh"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$csinh @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$csinh
"SPEC $ccosh"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$ccosh @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$ccosh1
"SPEC $ccosh"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$ccosh @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$ccosh
"SPEC $c/"
    forall ($dRealFloat_agsZX :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$c/ @ Float $dRealFloat_agsZX
      = Data.Complex.$fFloatingComplex_$s$c/1
"SPEC $c/"
    forall ($dRealFloat_agt01 :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$c/ @ Double $dRealFloat_agt01
      = Data.Complex.$fFloatingComplex_$s$c/
"SPEC $cfromRational"
    forall ($dRealFloat_agsZX :: RealFloat Float).
      Data.Complex.$fFractionalComplex_$cfromRational @ Float
                                                      $dRealFloat_agsZX
      = Data.Complex.$fFloatingComplex_$s$cfromRational1
"SPEC $cfromRational"
    forall ($dRealFloat_agt01 :: RealFloat Double).
      Data.Complex.$fFractionalComplex_$cfromRational @ Double
                                                      $dRealFloat_agt01
      = Data.Complex.$fFloatingComplex_$s$cfromRational
"SPEC $c+"
    forall ($dRealFloat_agt1C :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$c+ @ Float $dRealFloat_agt1C
      = Data.Complex.$fFloatingComplex_$s$c+1
"SPEC $c+"
    forall ($dRealFloat_agt1G :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$c+ @ Double $dRealFloat_agt1G
      = Data.Complex.$fFloatingComplex_$s$c+
"SPEC $c-"
    forall ($dRealFloat_agt1C :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$c- @ Float $dRealFloat_agt1C
      = Data.Complex.$fFloatingComplex_$s$c-1
"SPEC $c-"
    forall ($dRealFloat_agt1G :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$c- @ Double $dRealFloat_agt1G
      = Data.Complex.$fFloatingComplex_$s$c-
"SPEC $c*"
    forall ($dRealFloat_agt1C :: RealFloat Float).
      Data.Complex.$fNumComplex_$c* @ Float $dRealFloat_agt1C
      = Data.Complex.$fFloatingComplex_$s$c*1
"SPEC $c*"
    forall ($dRealFloat_agt1G :: RealFloat Double).
      Data.Complex.$fNumComplex_$c* @ Double $dRealFloat_agt1G
      = Data.Complex.$fFloatingComplex_$s$c*
"SPEC $cnegate"
    forall ($dRealFloat_agt1C :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$cnegate @ Float $dRealFloat_agt1C
      = Data.Complex.$fFloatingComplex_$s$cnegate1
"SPEC $cnegate"
    forall ($dRealFloat_agt1G :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$cnegate @ Double $dRealFloat_agt1G
      = Data.Complex.$fFloatingComplex_$s$cnegate
"SPEC $cabs"
    forall ($dRealFloat_agt1C :: RealFloat Float).
      Data.Complex.$fNumComplex_$cabs @ Float $dRealFloat_agt1C
      = Data.Complex.$fFloatingComplex_$s$cabs1
"SPEC $cabs"
    forall ($dRealFloat_agt1G :: RealFloat Double).
      Data.Complex.$fNumComplex_$cabs @ Double $dRealFloat_agt1G
      = Data.Complex.$fFloatingComplex_$s$cabs
"SPEC $cfromInteger"
    forall ($dRealFloat_agt1C :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$cfromInteger @ Float
                                                   $dRealFloat_agt1C
      = Data.Complex.$fFloatingComplex_$s$cfromInteger1
"SPEC $cfromInteger"
    forall ($dRealFloat_agt1G :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$cfromInteger @ Double
                                                   $dRealFloat_agt1G
      = Data.Complex.$fFloatingComplex_$s$cfromInteger
"SPEC $csignum"
    forall ($dRealFloat_agt1C :: RealFloat Float).
      Data.Complex.$fNumComplex_$csignum @ Float $dRealFloat_agt1C
      = Data.Complex.$fFloatingComplex_$s$csignum1
"SPEC $csignum"
    forall ($dRealFloat_agt1G :: RealFloat Double).
      Data.Complex.$fNumComplex_$csignum @ Double $dRealFloat_agt1G
      = Data.Complex.$fFloatingComplex_$s$csignum
"SPEC $fNumComplex"
    forall ($dRealFloat_agt1C :: RealFloat Float).
      Data.Complex.$fNumComplex @ Float $dRealFloat_agt1C
      = Data.Complex.$fFloatingComplex_$s$fNumComplex1
"SPEC $fNumComplex"
    forall ($dRealFloat_agt1G :: RealFloat Double).
      Data.Complex.$fNumComplex @ Double $dRealFloat_agt1G
      = Data.Complex.$fFloatingComplex_$s$fNumComplex
"SPEC $csqrt"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$csqrt @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$csqrt1
"SPEC $csqrt"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$csqrt @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$csqrt
"SPEC $crecip @ Double"
    forall ($dRealFloat_sguiW :: RealFloat Double).
      Data.Complex.$fFractionalComplex_$crecip @ Double $dRealFloat_sguiW
      = Data.Complex.$fFloatingComplex_$s$crecip
"SPEC $crecip @ Float"
    forall ($dRealFloat_sguiU :: RealFloat Float).
      Data.Complex.$fFractionalComplex_$crecip @ Float $dRealFloat_sguiU
      = Data.Complex.$fFloatingComplex_$s$crecip1
"SPEC $fFractionalComplex"
    forall ($dRealFloat_agsZX :: RealFloat Float).
      Data.Complex.$fFractionalComplex @ Float $dRealFloat_agsZX
      = Data.Complex.$fFloatingComplex_$s$fFractionalComplex1
"SPEC $fFractionalComplex"
    forall ($dRealFloat_agt01 :: RealFloat Double).
      Data.Complex.$fFractionalComplex @ Double $dRealFloat_agt01
      = Data.Complex.$fFloatingComplex_$s$fFractionalComplex
"SPEC $ctan"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$ctan @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$ctan1
"SPEC $ctan"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$ctan @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$ctan
"SPEC $ctanh"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$ctanh @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$ctanh1
"SPEC $ctanh"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$ctanh @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$ctanh
"SPEC $cacosh"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$cacosh @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$cacosh1
"SPEC $cacosh"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$cacosh @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$cacosh
"SPEC $casinh"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$casinh @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$casinh1
"SPEC $casinh"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$casinh @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$casinh
"SPEC $catan"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$catan @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$catan1
"SPEC $catan"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$catan @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$catan
"SPEC $cacos"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$cacos @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$cacos1
"SPEC $cacos"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$cacos @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$cacos
"SPEC $casin"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$casin @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$casin1
"SPEC $casin"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$casin @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$casin
"SPEC $catanh"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$catanh @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$catanh1
"SPEC $catanh"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$catanh @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$catanh
"SPEC $c**"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$c** @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$c**1
"SPEC $c**"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$c** @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$c**
"SPEC $cexpm1 @ Float"
    forall ($dRealFloat_sguga :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$cexpm1 @ Float $dRealFloat_sguga
      = Data.Complex.$fFloatingComplex_$s$cexpm2
"SPEC $cexpm1 @ Double"
    forall ($dRealFloat_sgufU :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$cexpm1 @ Double $dRealFloat_sgufU
      = Data.Complex.$fFloatingComplex_$s$cexpm1
"SPEC $clog1p @ Float"
    forall ($dRealFloat_sgufq :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$clog1p @ Float $dRealFloat_sgufq
      = Data.Complex.$fFloatingComplex_$s$clog1p1
"SPEC $clog1p @ Double"
    forall ($dRealFloat_sgufa :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$clog1p @ Double $dRealFloat_sgufa
      = Data.Complex.$fFloatingComplex_$s$clog1p
"SPEC $clog1mexp @ Float"
    forall ($dRealFloat_sgueG :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$clog1mexp @ Float $dRealFloat_sgueG
      = Data.Complex.$fFloatingComplex_$s$clog1mexp1
"SPEC $clog1mexp @ Double"
    forall ($dRealFloat_sgueq :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$clog1mexp @ Double
                                                $dRealFloat_sgueq
      = Data.Complex.$fFloatingComplex_$s$clog1mexp
"SPEC $clog1pexp @ Float"
    forall ($dRealFloat_sgudW :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$clog1pexp @ Float $dRealFloat_sgudW
      = Data.Complex.$fFloatingComplex_$s$clog1pexp1
"SPEC $clog1pexp @ Double"
    forall ($dRealFloat_sgudG :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$clog1pexp @ Double
                                                $dRealFloat_sgudG
      = Data.Complex.$fFloatingComplex_$s$clog1pexp
"SPEC $clogBase @ Float"
    forall ($dRealFloat_sgudq :: RealFloat Float).
      Data.Complex.$fFloatingComplex_$clogBase @ Float $dRealFloat_sgudq
      = Data.Complex.$fFloatingComplex_$s$clogBase1
"SPEC $clogBase @ Double"
    forall ($dRealFloat_sgudo :: RealFloat Double).
      Data.Complex.$fFloatingComplex_$clogBase @ Double $dRealFloat_sgudo
      = Data.Complex.$fFloatingComplex_$s$clogBase
"SPEC $fFloatingComplex"
    forall ($dRealFloat_agsO6 :: RealFloat Float).
      Data.Complex.$fFloatingComplex @ Float $dRealFloat_agsO6
      = Data.Complex.$fFloatingComplex_$s$fFloatingComplex1
"SPEC $fFloatingComplex"
    forall ($dRealFloat_agsOa :: RealFloat Double).
      Data.Complex.$fFloatingComplex @ Double $dRealFloat_agsOa
      = Data.Complex.$fFloatingComplex_$s$fFloatingComplex
"realToFrac/a->Complex Double"
    forall (@ a_agt3j)
           ($dReal_agt3g :: Real a_agt3j)
           ($dFractional_agt3h :: Fractional (Complex Double)).
      realToFrac @ a_agt3j
                 @ (Complex Double)
                 $dReal_agt3g
                 $dFractional_agt3h
      = \ (x_agspQ :: a_agt3j) ->
          Data.Complex.$W:+
            @ Double
            (realToFrac
               @ a_agt3j
               @ Double
               $dReal_agt3g
               GHC.Float.$fFractionalDouble
               x_agspQ)
            (GHC.Types.D# 0.0##)
"realToFrac/a->Complex Float"
    forall (@ a_agt3H)
           ($dReal_agt3E :: Real a_agt3H)
           ($dFractional_agt3F :: Fractional (Complex Float)).
      realToFrac @ a_agt3H
                 @ (Complex Float)
                 $dReal_agt3E
                 $dFractional_agt3F
      = \ (x_agspR :: a_agt3H) ->
          Data.Complex.$W:+
            @ Float
            (realToFrac
               @ a_agt3H @ Float $dReal_agt3E GHC.Float.$fFractionalFloat x_agspR)
            (GHC.Types.F# 0.0#)

