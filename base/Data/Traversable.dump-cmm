
==================== Output Cmm ====================
2018-03-16 16:06:49.861901112 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:49.86282411 UTC

[section ""data" . Data.Traversable.$p1Traversable_closure" {
     Data.Traversable.$p1Traversable_closure:
         const Data.Traversable.$p1Traversable_info;
 },
 Data.Traversable.$p1Traversable_entry() //  [R2]
         { info_tbl: [(cbX84,
                       label: Data.Traversable.$p1Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX84: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbX85; else goto cbX86;
       cbX85: // global
           R2 = R2;
           R1 = Data.Traversable.$p1Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbX86: // global
           I64[Sp - 8] = block_cbX81_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubX8a; else goto cbX82;
       ubX8a: // global
           call _cbX81(R1) args: 0, res: 0, upd: 0;
       cbX82: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbX81() //  [R1]
         { info_tbl: [(cbX81,
                       label: block_cbX81_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX81: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.864094578 UTC

[section ""data" . Data.Traversable.$p2Traversable_closure" {
     Data.Traversable.$p2Traversable_closure:
         const Data.Traversable.$p2Traversable_info;
 },
 Data.Traversable.$p2Traversable_entry() //  [R2]
         { info_tbl: [(cbX8i,
                       label: Data.Traversable.$p2Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX8i: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbX8j; else goto cbX8k;
       cbX8j: // global
           R2 = R2;
           R1 = Data.Traversable.$p2Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbX8k: // global
           I64[Sp - 8] = block_cbX8f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubX8o; else goto cbX8g;
       ubX8o: // global
           call _cbX8f(R1) args: 0, res: 0, upd: 0;
       cbX8g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbX8f() //  [R1]
         { info_tbl: [(cbX8f,
                       label: block_cbX8f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX8f: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.865319396 UTC

[section ""data" . Data.Traversable.traverse_closure" {
     Data.Traversable.traverse_closure:
         const Data.Traversable.traverse_info;
 },
 Data.Traversable.traverse_entry() //  [R2]
         { info_tbl: [(cbX8w,
                       label: Data.Traversable.traverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX8w: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbX8x; else goto cbX8y;
       cbX8x: // global
           R2 = R2;
           R1 = Data.Traversable.traverse_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbX8y: // global
           I64[Sp - 8] = block_cbX8t_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubX8C; else goto cbX8u;
       ubX8C: // global
           call _cbX8t(R1) args: 0, res: 0, upd: 0;
       cbX8u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbX8t() //  [R1]
         { info_tbl: [(cbX8t,
                       label: block_cbX8t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX8t: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.866465273 UTC

[section ""data" . Data.Traversable.sequenceA_closure" {
     Data.Traversable.sequenceA_closure:
         const Data.Traversable.sequenceA_info;
 },
 Data.Traversable.sequenceA_entry() //  [R2]
         { info_tbl: [(cbX8K,
                       label: Data.Traversable.sequenceA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX8K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbX8L; else goto cbX8M;
       cbX8L: // global
           R2 = R2;
           R1 = Data.Traversable.sequenceA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbX8M: // global
           I64[Sp - 8] = block_cbX8H_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubX8Q; else goto cbX8I;
       ubX8Q: // global
           call _cbX8H(R1) args: 0, res: 0, upd: 0;
       cbX8I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbX8H() //  [R1]
         { info_tbl: [(cbX8H,
                       label: block_cbX8H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX8H: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.867586526 UTC

[section ""data" . Data.Traversable.mapM_closure" {
     Data.Traversable.mapM_closure:
         const Data.Traversable.mapM_info;
 },
 Data.Traversable.mapM_entry() //  [R2]
         { info_tbl: [(cbX8Y,
                       label: Data.Traversable.mapM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX8Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbX8Z; else goto cbX90;
       cbX8Z: // global
           R2 = R2;
           R1 = Data.Traversable.mapM_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbX90: // global
           I64[Sp - 8] = block_cbX8V_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubX94; else goto cbX8W;
       ubX94: // global
           call _cbX8V(R1) args: 0, res: 0, upd: 0;
       cbX8W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbX8V() //  [R1]
         { info_tbl: [(cbX8V,
                       label: block_cbX8V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX8V: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.86873615 UTC

[section ""data" . Data.Traversable.sequence_closure" {
     Data.Traversable.sequence_closure:
         const Data.Traversable.sequence_info;
 },
 Data.Traversable.sequence_entry() //  [R2]
         { info_tbl: [(cbX9c,
                       label: Data.Traversable.sequence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX9c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbX9d; else goto cbX9e;
       cbX9d: // global
           R2 = R2;
           R1 = Data.Traversable.sequence_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbX9e: // global
           I64[Sp - 8] = block_cbX99_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubX9i; else goto cbX9a;
       ubX9i: // global
           call _cbX99(R1) args: 0, res: 0, upd: 0;
       cbX9a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbX99() //  [R1]
         { info_tbl: [(cbX99,
                       label: block_cbX99_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX99: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.870171819 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$ctraverse_closure" {
     Data.Traversable.$fTraversableFirst_$ctraverse_closure:
         const Data.Traversable.$fTraversableFirst_$ctraverse_info;
 },
 Data.Traversable.$fTraversableFirst_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbX9u,
                       label: Data.Traversable.$fTraversableFirst_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX9u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbX9v; else goto cbX9w;
       cbX9v: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableFirst_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbX9w: // global
           I64[Sp - 24] = block_cbX9n_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubX9L; else goto cbX9o;
       ubX9L: // global
           call _cbX9n(R1) args: 0, res: 0, upd: 0;
       cbX9o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbX9n() //  [R1]
         { info_tbl: [(cbX9n,
                       label: block_cbX9n_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX9n: // global
           _sbWUL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbX9r; else goto cbX9s;
       cbX9r: // global
           R2 = _sbWUL::P64;
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cbX9s: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbX9G; else goto cbX9F;
       cbX9G: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbX9F: // global
           _sbWUP::P64 = P64[R1 + 6];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbWUP::P64;
           I64[Sp + 8] = block_cbX9D_info;
           R2 = _sbWUL::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbX9D() //  [R1]
         { info_tbl: [(cbX9D,
                       label: block_cbX9D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX9D: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.872313649 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$ctraverse_closure" {
     Data.Traversable.$fTraversable[]_$ctraverse_closure:
         const Data.Traversable.$fTraversable[]_$ctraverse_info;
 },
 z_sbWUU_entry() //  [R1]
         { info_tbl: [(cbX9U,
                       label: z_sbWUU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbX9U: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbX9V; else goto cbX9W;
       cbX9V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbX9W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbWUV_entry() //  [R1, R2]
         { info_tbl: [(cbXa9,
                       label: go_sbWUV_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXa9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXaa; else goto cbXab;
       cbXaa: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXab: // global
           I64[Sp - 40] = block_cbXa2_info;
           _sbWUV::P64 = R1;
           _sbWUS::P64 = P64[R1 + 7];
           _sbWUT::P64 = P64[R1 + 15];
           _sbWUU::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sbWUS::P64;
           P64[Sp - 24] = _sbWUT::P64;
           P64[Sp - 16] = _sbWUU::P64;
           P64[Sp - 8] = _sbWUV::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubXam; else goto cbXa3;
       ubXam: // global
           call _cbXa2(R1) args: 0, res: 0, upd: 0;
       cbXa3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXa2() //  [R1]
         { info_tbl: [(cbXa2,
                       label: block_cbXa2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXa2: // global
           if (R1 & 7 == 1) goto cbXa6; else goto cbXa7;
       cbXa6: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbXa7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbXaj; else goto cbXai;
       cbXaj: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXai: // global
           _sbWUY::P64 = P64[R1 + 6];
           _sbWUZ::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sbWUZ::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbWUY::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$ctraverse_entry() //  [R2, R3]
         { info_tbl: [(cbXan,
                       label: Data.Traversable.$fTraversable[]_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXan: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbXar; else goto cbXaq;
       cbXar: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$ctraverse_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXaq: // global
           I64[Hp - 48] = z_sbWUU_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_sbWUV_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.87469918 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$ctraverse_closure" {
     Data.Traversable.$fTraversableEither_$ctraverse_closure:
         const Data.Traversable.$fTraversableEither_$ctraverse_info;
 },
 Data.Traversable.$fTraversableEither_$ctraverse_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cbXaD,
                       label: Data.Traversable.$fTraversableEither_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXaD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXaE; else goto cbXaF;
       cbXaE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXaF: // global
           I64[Sp - 24] = block_cbXaw_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubXaU; else goto cbXax;
       ubXaU: // global
           call _cbXaw(R1) args: 0, res: 0, upd: 0;
       cbXax: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXaw() //  [R1]
         { info_tbl: [(cbXaw,
                       label: block_cbXaw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXaw: // global
           _sbWV2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbXaA; else goto cbXaB;
       cbXaA: // global
           R2 = _sbWV2::P64;
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cbXaB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXaP; else goto cbXaO;
       cbXaP: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXaO: // global
           _sbWV8::P64 = P64[R1 + 6];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbWV8::P64;
           I64[Sp + 8] = block_cbXaM_info;
           R2 = _sbWV2::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXaM() //  [R1]
         { info_tbl: [(cbXaM,
                       label: block_cbXaM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXaM: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.876601592 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$ctraverse_closure" {
     Data.Traversable.$fTraversable(,)_$ctraverse_closure:
         const Data.Traversable.$fTraversable(,)_$ctraverse_info;
 },
 sat_sbWVi_entry() //  [R1, R2]
         { info_tbl: [(cbXbb,
                       label: sat_sbWVi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXbb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbXbf; else goto cbXbe;
       cbXbf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXbe: // global
           _sbWVf::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbWVf::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$ctraverse_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbXbg,
                       label: Data.Traversable.$fTraversable(,)_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXbg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXbi; else goto cbXbj;
       cbXbi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXbj: // global
           I64[Sp - 24] = block_cbXaZ_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubXbr; else goto cbXb0;
       ubXbr: // global
           call _cbXaZ(R1) args: 0, res: 0, upd: 0;
       cbXb0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXaZ() //  [R1]
         { info_tbl: [(cbXaZ,
                       label: block_cbXaZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXaZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXbm; else goto cbXbl;
       cbXbm: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXbl: // global
           _sbWVf::P64 = P64[R1 + 7];
           _sbWVg::P64 = P64[R1 + 15];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbWVg::P64;
           I64[Hp - 8] = sat_sbWVi_info;
           P64[Hp] = _sbWVf::P64;
           I64[Sp] = block_cbXbh_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 7;
           P64[Sp + 16] = Hp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXbh() //  [R1]
         { info_tbl: [(cbXbh,
                       label: block_cbXbh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXbh: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.878398588 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$csequence_closure" {
     Data.Traversable.$fTraversableProxy_$csequence_closure:
         const Data.Traversable.$fTraversableProxy_$csequence_info;
 },
 Data.Traversable.$fTraversableProxy_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXby,
                       label: Data.Traversable.$fTraversableProxy_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXby: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXbz; else goto cbXbA;
       cbXbz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXbA: // global
           I64[Sp - 8] = block_cbXbw_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXbw() //  [R1]
         { info_tbl: [(cbXbw,
                       label: block_cbXbw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXbw: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.879518394 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$cmapM_closure" {
     Data.Traversable.$fTraversableProxy_$cmapM_closure:
         const Data.Traversable.$fTraversableProxy_$cmapM_info;
 },
 Data.Traversable.$fTraversableProxy_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXbK,
                       label: Data.Traversable.$fTraversableProxy_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXbK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXbL; else goto cbXbM;
       cbXbL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXbM: // global
           I64[Sp - 8] = block_cbXbI_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXbI() //  [R1]
         { info_tbl: [(cbXbI,
                       label: block_cbXbI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXbI: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.880514944 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$csequenceA_closure" {
     Data.Traversable.$fTraversableProxy_$csequenceA_closure:
         const Data.Traversable.$fTraversableProxy_$csequenceA_info;
 },
 Data.Traversable.$fTraversableProxy_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbXbU,
                       label: Data.Traversable.$fTraversableProxy_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXbU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXbV; else goto cbXbW;
       cbXbV: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXbW: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.881490239 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$ctraverse_closure" {
     Data.Traversable.$fTraversableProxy_$ctraverse_closure:
         const Data.Traversable.$fTraversableProxy_$ctraverse_info;
 },
 Data.Traversable.$fTraversableProxy_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbXc1,
                       label: Data.Traversable.$fTraversableProxy_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXc1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXc2; else goto cbXc3;
       cbXc2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXc3: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.882384244 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_closure" {
     Data.Traversable.$fTraversableProxy_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Proxy.$fFunctorProxy_closure;
         const Data.Foldable.$fFoldableProxy_closure;
         const Data.Traversable.$fTraversableProxy_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableProxy_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableProxy_$cmapM_closure+3;
         const Data.Traversable.$fTraversableProxy_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.883104416 UTC

[section ""data" . Data.Traversable.$fTraversableConst_$ctraverse_closure" {
     Data.Traversable.$fTraversableConst_$ctraverse_closure:
         const Data.Traversable.$fTraversableConst_$ctraverse_info;
 },
 Data.Traversable.$fTraversableConst_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbXc8,
                       label: Data.Traversable.$fTraversableConst_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXc8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXc9; else goto cbXca;
       cbXc9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableConst_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXca: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.883992101 UTC

[section ""data" . Data.Traversable.$fTraversableDual1_closure" {
     Data.Traversable.$fTraversableDual1_closure:
         const Data.Traversable.$fTraversableDual1_info;
 },
 Data.Traversable.$fTraversableDual1_entry() //  [R2]
         { info_tbl: [(cbXcf,
                       label: Data.Traversable.$fTraversableDual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXcf: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.884925744 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$ctraverse_closure" {
     Data.Traversable.$fTraversableDual_$ctraverse_closure:
         const Data.Traversable.$fTraversableDual_$ctraverse_info;
 },
 Data.Traversable.$fTraversableDual_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbXcp,
                       label: Data.Traversable.$fTraversableDual_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXcp: // global
           _sbWVC::P64 = R4;
           _sbWVB::P64 = R3;
           _sbWVA::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXcq; else goto cbXcr;
       cbXcr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXct; else goto cbXcs;
       cbXct: // global
           HpAlloc = 32;
           goto cbXcq;
       cbXcq: // global
           R4 = _sbWVC::P64;
           R3 = _sbWVB::P64;
           R2 = _sbWVA::P64;
           R1 = Data.Traversable.$fTraversableDual_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXcs: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWVB::P64;
           P64[Hp] = _sbWVC::P64;
           I64[Sp - 16] = block_cbXcn_info;
           R2 = _sbWVA::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXcn() //  [R1]
         { info_tbl: [(cbXcn,
                       label: block_cbXcn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXcn: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.886480812 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$ctraverse_closure" {
     Data.Traversable.$fTraversableSum_$ctraverse_closure:
         const Data.Traversable.$fTraversableSum_$ctraverse_info;
 },
 Data.Traversable.$fTraversableSum_$ctraverse_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbXcE,
                       label: Data.Traversable.$fTraversableSum_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXcE: // global
           _sbWVH::P64 = R4;
           _sbWVG::P64 = R3;
           _sbWVF::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXcF; else goto cbXcG;
       cbXcG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXcI; else goto cbXcH;
       cbXcI: // global
           HpAlloc = 32;
           goto cbXcF;
       cbXcF: // global
           R4 = _sbWVH::P64;
           R3 = _sbWVG::P64;
           R2 = _sbWVF::P64;
           R1 = Data.Traversable.$fTraversableSum_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXcH: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWVG::P64;
           P64[Hp] = _sbWVH::P64;
           I64[Sp - 16] = block_cbXcC_info;
           R2 = _sbWVF::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXcC() //  [R1]
         { info_tbl: [(cbXcC,
                       label: block_cbXcC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXcC: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.887780958 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$ctraverse_closure" {
     Data.Traversable.$fTraversableProduct_$ctraverse_closure:
         const Data.Traversable.$fTraversableProduct_$ctraverse_info;
 },
 Data.Traversable.$fTraversableProduct_$ctraverse_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbXcT,
                       label: Data.Traversable.$fTraversableProduct_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXcT: // global
           _sbWVM::P64 = R4;
           _sbWVL::P64 = R3;
           _sbWVK::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXcU; else goto cbXcV;
       cbXcV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXcX; else goto cbXcW;
       cbXcX: // global
           HpAlloc = 32;
           goto cbXcU;
       cbXcU: // global
           R4 = _sbWVM::P64;
           R3 = _sbWVL::P64;
           R2 = _sbWVK::P64;
           R1 = Data.Traversable.$fTraversableProduct_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXcW: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWVL::P64;
           P64[Hp] = _sbWVM::P64;
           I64[Sp - 16] = block_cbXcR_info;
           R2 = _sbWVK::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXcR() //  [R1]
         { info_tbl: [(cbXcR,
                       label: block_cbXcR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXcR: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.889039411 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$csequence_closure" {
     Data.Traversable.$fTraversableU1_$csequence_closure:
         const Data.Traversable.$fTraversableU1_$csequence_info;
 },
 Data.Traversable.$fTraversableU1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXd7,
                       label: Data.Traversable.$fTraversableU1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXd7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXd8; else goto cbXd9;
       cbXd8: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXd9: // global
           I64[Sp - 8] = block_cbXd5_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXd5() //  [R1]
         { info_tbl: [(cbXd5,
                       label: block_cbXd5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXd5: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Generics.U1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.890196585 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$cmapM_closure" {
     Data.Traversable.$fTraversableU1_$cmapM_closure:
         const Data.Traversable.$fTraversableU1_$cmapM_info;
 },
 Data.Traversable.$fTraversableU1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXdj,
                       label: Data.Traversable.$fTraversableU1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXdj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXdk; else goto cbXdl;
       cbXdk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXdl: // global
           I64[Sp - 8] = block_cbXdh_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXdh() //  [R1]
         { info_tbl: [(cbXdh,
                       label: block_cbXdh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXdh: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Generics.U1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.891261966 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$csequenceA_closure" {
     Data.Traversable.$fTraversableU1_$csequenceA_closure:
         const Data.Traversable.$fTraversableU1_$csequenceA_info;
 },
 Data.Traversable.$fTraversableU1_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbXdt,
                       label: Data.Traversable.$fTraversableU1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXdt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXdu; else goto cbXdv;
       cbXdu: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXdv: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Generics.U1_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.89220685 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$ctraverse_closure" {
     Data.Traversable.$fTraversableU1_$ctraverse_closure:
         const Data.Traversable.$fTraversableU1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableU1_$ctraverse_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbXdA,
                       label: Data.Traversable.$fTraversableU1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXdA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXdB; else goto cbXdC;
       cbXdB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXdC: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Generics.U1_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.893057822 UTC

[section ""data" . Data.Traversable.$fTraversableU1_closure" {
     Data.Traversable.$fTraversableU1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorU1_closure;
         const Data.Foldable.$fFoldableU1_closure;
         const Data.Traversable.$fTraversableU1_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableU1_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableU1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableU1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.893894902 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$ctraverse_closure" {
     Data.Traversable.$fTraversableIdentity_$ctraverse_closure:
         const Data.Traversable.$fTraversableIdentity_$ctraverse_info;
 },
 Data.Traversable.$fTraversableIdentity_$ctraverse_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cbXdK,
                       label: Data.Traversable.$fTraversableIdentity_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXdK: // global
           _sbWW3::P64 = R4;
           _sbWW2::P64 = R3;
           _sbWW1::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXdL; else goto cbXdM;
       cbXdM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXdO; else goto cbXdN;
       cbXdO: // global
           HpAlloc = 32;
           goto cbXdL;
       cbXdL: // global
           R4 = _sbWW3::P64;
           R3 = _sbWW2::P64;
           R2 = _sbWW1::P64;
           R1 = Data.Traversable.$fTraversableIdentity_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXdN: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWW2::P64;
           P64[Hp] = _sbWW3::P64;
           I64[Sp - 16] = block_cbXdI_info;
           R2 = _sbWW1::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXdI() //  [R1]
         { info_tbl: [(cbXdI,
                       label: block_cbXdI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXdI: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.895162765 UTC

[section ""data" . Data.Traversable.$fTraversableV1_$ctraverse_closure" {
     Data.Traversable.$fTraversableV1_$ctraverse_closure:
         const Data.Traversable.$fTraversableV1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableV1_$ctraverse_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbXdW,
                       label: Data.Traversable.$fTraversableV1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXdW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXdX; else goto cbXdY;
       cbXdX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableV1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXdY: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.896227164 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$ctraverse_closure" {
     Data.Traversable.$fTraversablePar1_$ctraverse_closure:
         const Data.Traversable.$fTraversablePar1_$ctraverse_info;
 },
 Data.Traversable.$fTraversablePar1_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbXe6,
                       label: Data.Traversable.$fTraversablePar1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXe6: // global
           _sbWWb::P64 = R4;
           _sbWWa::P64 = R3;
           _sbWW9::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXe7; else goto cbXe8;
       cbXe8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXea; else goto cbXe9;
       cbXea: // global
           HpAlloc = 32;
           goto cbXe7;
       cbXe7: // global
           R4 = _sbWWb::P64;
           R3 = _sbWWa::P64;
           R2 = _sbWW9::P64;
           R1 = Data.Traversable.$fTraversablePar1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXe9: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWWa::P64;
           P64[Hp] = _sbWWb::P64;
           I64[Sp - 16] = block_cbXe4_info;
           R2 = _sbWW9::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXe4() //  [R1]
         { info_tbl: [(cbXe4,
                       label: block_cbXe4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXe4: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.897418854 UTC

[section ""data" . Data.Traversable.$fTraversableM2_closure" {
     Data.Traversable.$fTraversableM2_closure:
         const Data.Traversable.$fTraversableM2_info;
 },
 Data.Traversable.$fTraversableM2_entry() //  [R2]
         { info_tbl: [(cbXei,
                       label: Data.Traversable.$fTraversableM2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXei: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.898538919 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$ctraverse_closure" {
     Data.Traversable.$fTraversableRec1_$ctraverse_closure:
         const Data.Traversable.$fTraversableRec1_$ctraverse_info;
 },
 sat_sbWWk_entry() //  [R1]
         { info_tbl: [(cbXet,
                       label: sat_sbWWk_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXet: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbXeu; else goto cbXev;
       cbXeu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXev: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$ctraverse_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cbXey,
                       label: Data.Traversable.$fTraversableRec1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXey: // global
           _sbWWi::P64 = R5;
           _sbWWh::P64 = R4;
           _sbWWg::P64 = R3;
           _sbWWf::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXez; else goto cbXeA;
       cbXeA: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXeC; else goto cbXeB;
       cbXeC: // global
           HpAlloc = 48;
           goto cbXez;
       cbXez: // global
           R5 = _sbWWi::P64;
           R4 = _sbWWh::P64;
           R3 = _sbWWg::P64;
           R2 = _sbWWf::P64;
           R1 = Data.Traversable.$fTraversableRec1_$ctraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXeB: // global
           I64[Hp - 40] = sat_sbWWk_info;
           P64[Hp - 24] = _sbWWf::P64;
           P64[Hp - 16] = _sbWWg::P64;
           P64[Hp - 8] = _sbWWh::P64;
           P64[Hp] = _sbWWi::P64;
           I64[Sp - 16] = block_cbXew_info;
           R2 = _sbWWg::P64;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXew() //  [R1]
         { info_tbl: [(cbXew,
                       label: block_cbXew_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXew: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.900226102 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$cp2Traversable_closure" {
     Data.Traversable.$fTraversableRec1_$cp2Traversable_closure:
         const Data.Traversable.$fTraversableRec1_$cp2Traversable_info;
         const 0;
 },
 sat_sbWWm_entry() //  [R1]
         { info_tbl: [(cbXeO,
                       label: sat_sbWWm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXeO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXeP; else goto cbXeQ;
       cbXeP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXeQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$cp2Traversable_entry() //  [R2]
         { info_tbl: [(cbXeR,
                       label: Data.Traversable.$fTraversableRec1_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXeR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbXeV; else goto cbXeU;
       cbXeV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$cp2Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXeU: // global
           I64[Hp - 16] = sat_sbWWm_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldableRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.901802322 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$cp1Traversable_closure" {
     Data.Traversable.$fTraversableRec1_$cp1Traversable_closure:
         const Data.Traversable.$fTraversableRec1_$cp1Traversable_info;
 },
 sat_sbWWo_entry() //  [R1]
         { info_tbl: [(cbXf5,
                       label: sat_sbWWo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXf5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXf6; else goto cbXf7;
       cbXf6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXf7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$cp1Traversable_entry() //  [R2]
         { info_tbl: [(cbXf8,
                       label: Data.Traversable.$fTraversableRec1_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXf8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbXfc; else goto cbXfb;
       cbXfc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$cp1Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXfb: // global
           I64[Hp - 16] = sat_sbWWo_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctorRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.902977124 UTC

[section ""data" . Data.Traversable.$fTraversableK1_$ctraverse_closure" {
     Data.Traversable.$fTraversableK1_$ctraverse_closure:
         const Data.Traversable.$fTraversableK1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableK1_$ctraverse_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbXfh,
                       label: Data.Traversable.$fTraversableK1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXfh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXfi; else goto cbXfj;
       cbXfi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableK1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXfj: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.904163872 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$ctraverse_closure" {
     Data.Traversable.$fTraversableM1_$ctraverse_closure:
         const Data.Traversable.$fTraversableM1_$ctraverse_info;
 },
 sat_sbWWx_entry() //  [R1]
         { info_tbl: [(cbXfs,
                       label: sat_sbWWx_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXfs: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbXft; else goto cbXfu;
       cbXft: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXfu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$ctraverse_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cbXfx,
                       label: Data.Traversable.$fTraversableM1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXfx: // global
           _sbWWv::P64 = R5;
           _sbWWu::P64 = R4;
           _sbWWt::P64 = R3;
           _sbWWs::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXfy; else goto cbXfz;
       cbXfz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXfB; else goto cbXfA;
       cbXfB: // global
           HpAlloc = 48;
           goto cbXfy;
       cbXfy: // global
           R5 = _sbWWv::P64;
           R4 = _sbWWu::P64;
           R3 = _sbWWt::P64;
           R2 = _sbWWs::P64;
           R1 = Data.Traversable.$fTraversableM1_$ctraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXfA: // global
           I64[Hp - 40] = sat_sbWWx_info;
           P64[Hp - 24] = _sbWWs::P64;
           P64[Hp - 16] = _sbWWt::P64;
           P64[Hp - 8] = _sbWWu::P64;
           P64[Hp] = _sbWWv::P64;
           I64[Sp - 16] = block_cbXfv_info;
           R2 = _sbWWt::P64;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXfv() //  [R1]
         { info_tbl: [(cbXfv,
                       label: block_cbXfv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXfv: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.905818172 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$cp2Traversable_closure" {
     Data.Traversable.$fTraversableM1_$cp2Traversable_closure:
         const Data.Traversable.$fTraversableM1_$cp2Traversable_info;
         const 0;
 },
 sat_sbWWz_entry() //  [R1]
         { info_tbl: [(cbXfN,
                       label: sat_sbWWz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXfN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXfO; else goto cbXfP;
       cbXfO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXfP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$cp2Traversable_entry() //  [R2]
         { info_tbl: [(cbXfQ,
                       label: Data.Traversable.$fTraversableM1_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXfQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbXfU; else goto cbXfT;
       cbXfU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$cp2Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXfT: // global
           I64[Hp - 16] = sat_sbWWz_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldableM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.907127429 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$cp1Traversable_closure" {
     Data.Traversable.$fTraversableM1_$cp1Traversable_closure:
         const Data.Traversable.$fTraversableM1_$cp1Traversable_info;
 },
 sat_sbWWB_entry() //  [R1]
         { info_tbl: [(cbXg3,
                       label: sat_sbWWB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXg3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXg4; else goto cbXg5;
       cbXg4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXg5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$cp1Traversable_entry() //  [R2]
         { info_tbl: [(cbXg6,
                       label: Data.Traversable.$fTraversableM1_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXg6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbXga; else goto cbXg9;
       cbXga: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$cp1Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXg9: // global
           I64[Hp - 16] = sat_sbWWB_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctorM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.909043007 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$ctraverse_closure" {
     Data.Traversable.$fTraversable:+:_$ctraverse_closure:
         const Data.Traversable.$fTraversable:+:_$ctraverse_info;
 },
 sat_sbWWK_entry() //  [R1]
         { info_tbl: [(cbXgo,
                       label: sat_sbWWK_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXgo: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbXgp; else goto cbXgq;
       cbXgp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXgq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sbWWN_entry() //  [R1]
         { info_tbl: [(cbXgx,
                       label: sat_sbWWN_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXgx: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbXgy; else goto cbXgz;
       cbXgy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXgz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cbXgE,
                       label: Data.Traversable.$fTraversable:+:_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXgE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXgF; else goto cbXgG;
       cbXgF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXgG: // global
           I64[Sp - 40] = block_cbXgf_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubXgX; else goto cbXgg;
       ubXgX: // global
           call _cbXgf(R1) args: 0, res: 0, upd: 0;
       cbXgg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXgf() //  [R1]
         { info_tbl: [(cbXgf,
                       label: block_cbXgf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXgf: // global
           _sbWWE::P64 = P64[Sp + 24];
           _sbWWF::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cbXgB; else goto cbXgC;
       cbXgB: // global
           Hp = Hp + 48;
           _sbWWH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbXgS; else goto cbXgJ;
       cbXgJ: // global
           _sbWWI::P64 = P64[_sbWWH::P64 + 7];
           I64[Hp - 40] = sat_sbWWK_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbWWE::P64;
           P64[Hp - 8] = _sbWWF::P64;
           P64[Hp] = _sbWWI::P64;
           I64[Sp + 24] = block_cbXgH_info;
           R2 = _sbWWE::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
       cbXgC: // global
           Hp = Hp + 48;
           _sbWWH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbXgS; else goto cbXgR;
       cbXgS: // global
           HpAlloc = 48;
           R1 = _sbWWH::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXgR: // global
           _sbWWL::P64 = P64[_sbWWH::P64 + 6];
           I64[Hp - 40] = sat_sbWWN_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbWWE::P64;
           P64[Hp - 8] = _sbWWF::P64;
           P64[Hp] = _sbWWL::P64;
           I64[Sp + 24] = block_cbXgP_info;
           R2 = _sbWWE::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXgH() //  [R1]
         { info_tbl: [(cbXgH,
                       label: block_cbXgH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXgH: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Generics.L1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cbXgP() //  [R1]
         { info_tbl: [(cbXgP,
                       label: block_cbXgP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXgP: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Generics.R1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.911686953 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$cp2Traversable_closure" {
     Data.Traversable.$fTraversable:+:_$cp2Traversable_closure:
         const Data.Traversable.$fTraversable:+:_$cp2Traversable_info;
         const 0;
 },
 sat_sbWWR_entry() //  [R1]
         { info_tbl: [(cbXh6,
                       label: sat_sbWWR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXh6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXh7; else goto cbXh8;
       cbXh7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXh8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWWQ_entry() //  [R1]
         { info_tbl: [(cbXhd,
                       label: sat_sbWWQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXhd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXhe; else goto cbXhf;
       cbXhe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXhf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbXhg,
                       label: Data.Traversable.$fTraversable:+:_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXhg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXhk; else goto cbXhj;
       cbXhk: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXhj: // global
           I64[Hp - 40] = sat_sbWWR_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWWQ_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldable:+:_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.913714202 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$cp1Traversable_closure" {
     Data.Traversable.$fTraversable:+:_$cp1Traversable_closure:
         const Data.Traversable.$fTraversable:+:_$cp1Traversable_info;
 },
 sat_sbWWV_entry() //  [R1]
         { info_tbl: [(cbXht,
                       label: sat_sbWWV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXht: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXhu; else goto cbXhv;
       cbXhu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXhv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWWU_entry() //  [R1]
         { info_tbl: [(cbXhA,
                       label: sat_sbWWU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXhA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXhB; else goto cbXhC;
       cbXhB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXhC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbXhD,
                       label: Data.Traversable.$fTraversable:+:_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXhD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXhH; else goto cbXhG;
       cbXhH: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXhG: // global
           I64[Hp - 40] = sat_sbWWV_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWWU_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctor:+:_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.915536188 UTC

[section ""data" . Data.Traversable.$w$ctraverse_closure" {
     Data.Traversable.$w$ctraverse_closure:
         const Data.Traversable.$w$ctraverse_info;
 },
 sat_sbWX3_entry() //  [R1]
         { info_tbl: [(cbXhQ,
                       label: sat_sbWX3_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXhQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbXhR; else goto cbXhS;
       cbXhR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXhS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sbWX2_entry() //  [R1]
         { info_tbl: [(cbXhX,
                       label: sat_sbWX2_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXhX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbXhY; else goto cbXhZ;
       cbXhY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXhZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$w$ctraverse_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbXi0,
                       label: Data.Traversable.$w$ctraverse_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXi0: // global
           _sbWX0::P64 = R6;
           _sbWWZ::P64 = R5;
           _sbWWY::P64 = R4;
           _sbWWX::P64 = R3;
           _sbWWW::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXi1; else goto cbXi2;
       cbXi2: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbXi4; else goto cbXi3;
       cbXi4: // global
           HpAlloc = 96;
           goto cbXi1;
       cbXi1: // global
           R6 = _sbWX0::P64;
           R5 = _sbWWZ::P64;
           R4 = _sbWWY::P64;
           R3 = _sbWWX::P64;
           R2 = _sbWWW::P64;
           R1 = Data.Traversable.$w$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbXi3: // global
           I64[Hp - 88] = sat_sbWX3_info;
           P64[Hp - 72] = _sbWWX::P64;
           P64[Hp - 64] = _sbWWY::P64;
           P64[Hp - 56] = _sbWWZ::P64;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = sat_sbWX2_info;
           P64[Hp - 24] = _sbWWW::P64;
           P64[Hp - 16] = _sbWWY::P64;
           P64[Hp - 8] = _sbWWZ::P64;
           P64[Hp] = _sbWX0::P64;
           R2 = _sbWWY::P64;
           I64[Sp - 24] = stg_ap_ppp_info;
           P64[Sp - 16] = GHC.Generics.:*:_closure+2;
           P64[Sp - 8] = Hp - 40;
           P64[Sp] = Hp - 88;
           Sp = Sp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.917462971 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$ctraverse_closure" {
     Data.Traversable.$fTraversable:*:_$ctraverse_closure:
         const Data.Traversable.$fTraversable:*:_$ctraverse_info;
 },
 Data.Traversable.$fTraversable:*:_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cbXic,
                       label: Data.Traversable.$fTraversable:*:_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXic: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXid; else goto cbXie;
       cbXid: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXie: // global
           I64[Sp - 40] = block_cbXi9_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubXii; else goto cbXia;
       ubXii: // global
           call _cbXi9(R1) args: 0, res: 0, upd: 0;
       cbXia: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXi9() //  [R1]
         { info_tbl: [(cbXi9,
                       label: block_cbXi9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXi9: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.921328117 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$cp2Traversable_closure" {
     Data.Traversable.$fTraversable:*:_$cp2Traversable_closure:
         const Data.Traversable.$fTraversable:*:_$cp2Traversable_info;
         const 0;
 },
 sat_sbWXf_entry() //  [R1]
         { info_tbl: [(cbXir,
                       label: sat_sbWXf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXir: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXis; else goto cbXit;
       cbXis: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXit: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWXe_entry() //  [R1]
         { info_tbl: [(cbXiy,
                       label: sat_sbWXe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXiy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXiz; else goto cbXiA;
       cbXiz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXiA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:*:_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbXiB,
                       label: Data.Traversable.$fTraversable:*:_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXiB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXiF; else goto cbXiE;
       cbXiF: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXiE: // global
           I64[Hp - 40] = sat_sbWXf_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWXe_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldable:*:_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.923038891 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$cp1Traversable_closure" {
     Data.Traversable.$fTraversable:*:_$cp1Traversable_closure:
         const Data.Traversable.$fTraversable:*:_$cp1Traversable_info;
 },
 sat_sbWXj_entry() //  [R1]
         { info_tbl: [(cbXiO,
                       label: sat_sbWXj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXiO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXiP; else goto cbXiQ;
       cbXiP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXiQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWXi_entry() //  [R1]
         { info_tbl: [(cbXiV,
                       label: sat_sbWXi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXiV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXiW; else goto cbXiX;
       cbXiW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXiX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:*:_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbXiY,
                       label: Data.Traversable.$fTraversable:*:_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXiY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXj2; else goto cbXj1;
       cbXj2: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXj1: // global
           I64[Hp - 40] = sat_sbWXj_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWXi_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctor:*:_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.924418217 UTC

[section ""data" . Data.Traversable.$fTraversable:.:1_closure" {
     Data.Traversable.$fTraversable:.:1_closure:
         const Data.Traversable.$fTraversable:.:1_info;
 },
 Data.Traversable.$fTraversable:.:1_entry() //  [R2]
         { info_tbl: [(cbXj7,
                       label: Data.Traversable.$fTraversable:.:1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXj7: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.925830434 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$ctraverse_closure" {
     Data.Traversable.$fTraversable:.:_$ctraverse_closure:
         const Data.Traversable.$fTraversable:.:_$ctraverse_info;
 },
 sat_sbWXr_entry() //  [R1]
         { info_tbl: [(cbXjm,
                       label: sat_sbWXr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXjm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXjn; else goto cbXjo;
       cbXjn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXjo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbWXs_entry() //  [R1]
         { info_tbl: [(cbXjp,
                       label: sat_sbWXs_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXjp: // global
           _sbWXs::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cbXjq; else goto cbXjr;
       cbXjr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbXjt; else goto cbXjs;
       cbXjt: // global
           HpAlloc = 40;
           goto cbXjq;
       cbXjq: // global
           R1 = _sbWXs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXjs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbWXs::P64;
           _sbWXl::P64 = P64[_sbWXs::P64 + 16];
           _sbWXm::P64 = P64[_sbWXs::P64 + 24];
           _sbWXn::P64 = P64[_sbWXs::P64 + 32];
           _sbWXo::P64 = P64[_sbWXs::P64 + 40];
           _sbWXp::P64 = P64[_sbWXs::P64 + 48];
           I64[Hp - 32] = sat_sbWXr_info;
           P64[Hp - 16] = _sbWXm::P64;
           P64[Hp - 8] = _sbWXn::P64;
           P64[Hp] = _sbWXo::P64;
           R2 = _sbWXl::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = _sbWXn::P64;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _sbWXp::P64;
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cbXjw,
                       label: Data.Traversable.$fTraversable:.:_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXjw: // global
           _sbWXp::P64 = R6;
           _sbWXo::P64 = R5;
           _sbWXn::P64 = R4;
           _sbWXm::P64 = R3;
           _sbWXl::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXjx; else goto cbXjy;
       cbXjy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbXjA; else goto cbXjz;
       cbXjA: // global
           HpAlloc = 56;
           goto cbXjx;
       cbXjx: // global
           R6 = _sbWXp::P64;
           R5 = _sbWXo::P64;
           R4 = _sbWXn::P64;
           R3 = _sbWXm::P64;
           R2 = _sbWXl::P64;
           R1 = Data.Traversable.$fTraversable:.:_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXjz: // global
           I64[Hp - 48] = sat_sbWXs_info;
           P64[Hp - 32] = _sbWXl::P64;
           P64[Hp - 24] = _sbWXm::P64;
           P64[Hp - 16] = _sbWXn::P64;
           P64[Hp - 8] = _sbWXo::P64;
           P64[Hp] = _sbWXp::P64;
           I64[Sp - 16] = block_cbXju_info;
           R2 = _sbWXn::P64;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXju() //  [R1]
         { info_tbl: [(cbXju,
                       label: block_cbXju_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXju: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversable:.:1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.927981657 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$cp2Traversable_closure" {
     Data.Traversable.$fTraversable:.:_$cp2Traversable_closure:
         const Data.Traversable.$fTraversable:.:_$cp2Traversable_info;
         const 0;
 },
 sat_sbWXw_entry() //  [R1]
         { info_tbl: [(cbXjM,
                       label: sat_sbWXw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXjM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXjN; else goto cbXjO;
       cbXjN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXjO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWXv_entry() //  [R1]
         { info_tbl: [(cbXjT,
                       label: sat_sbWXv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXjT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXjU; else goto cbXjV;
       cbXjU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXjV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbXjW,
                       label: Data.Traversable.$fTraversable:.:_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXjW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXk0; else goto cbXjZ;
       cbXk0: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXjZ: // global
           I64[Hp - 40] = sat_sbWXw_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWXv_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldable:.:_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.92965284 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$cp1Traversable_closure" {
     Data.Traversable.$fTraversable:.:_$cp1Traversable_closure:
         const Data.Traversable.$fTraversable:.:_$cp1Traversable_info;
 },
 sat_sbWXA_entry() //  [R1]
         { info_tbl: [(cbXk9,
                       label: sat_sbWXA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXk9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXka; else goto cbXkb;
       cbXka: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXkb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWXz_entry() //  [R1]
         { info_tbl: [(cbXkg,
                       label: sat_sbWXz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXkg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXkh; else goto cbXki;
       cbXkh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXki: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbXkj,
                       label: Data.Traversable.$fTraversable:.:_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXkj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXkn; else goto cbXkm;
       cbXkn: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXkm: // global
           I64[Hp - 40] = sat_sbWXA_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWXz_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctor:.:_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.931094698 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec4_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec4_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec4_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbXku,
                       label: Data.Traversable.$fTraversableURec4_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXku: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXkv; else goto cbXkw;
       cbXkv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXkw: // global
           I64[Sp - 16] = block_cbXks_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXks() //  [R1]
         { info_tbl: [(cbXks,
                       label: block_cbXks_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXks: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.932256807 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec3_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec3_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec3_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbXkG,
                       label: Data.Traversable.$fTraversableURec3_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXkG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXkH; else goto cbXkI;
       cbXkH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXkI: // global
           I64[Sp - 16] = block_cbXkE_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXkE() //  [R1]
         { info_tbl: [(cbXkE,
                       label: block_cbXkE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXkE: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.933470676 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec2_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec2_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec2_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbXkS,
                       label: Data.Traversable.$fTraversableURec2_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXkS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXkT; else goto cbXkU;
       cbXkT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXkU: // global
           I64[Sp - 16] = block_cbXkQ_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXkQ() //  [R1]
         { info_tbl: [(cbXkQ,
                       label: block_cbXkQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXkQ: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.934595955 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec1_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec1_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbXl4,
                       label: Data.Traversable.$fTraversableURec1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXl4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXl5; else goto cbXl6;
       cbXl5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXl6: // global
           I64[Sp - 16] = block_cbXl2_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXl2() //  [R1]
         { info_tbl: [(cbXl2,
                       label: block_cbXl2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXl2: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.935739641 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec0_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec0_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec0_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbXlg,
                       label: Data.Traversable.$fTraversableURec0_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXlg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXlh; else goto cbXli;
       cbXlh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXli: // global
           I64[Sp - 16] = block_cbXle_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXle() //  [R1]
         { info_tbl: [(cbXle,
                       label: block_cbXle_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXle: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.936884372 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbXls,
                       label: Data.Traversable.$fTraversableURec_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXls: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXlt; else goto cbXlu;
       cbXlt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXlu: // global
           I64[Sp - 16] = block_cbXlq_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXlq() //  [R1]
         { info_tbl: [(cbXlq,
                       label: block_cbXlq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXlq: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.938281483 UTC

[section ""data" . Data.Traversable.$dmsequence_closure" {
     Data.Traversable.$dmsequence_closure:
         const Data.Traversable.$dmsequence_info;
 },
 sat_sbWYd_entry() //  [R1]
         { info_tbl: [(cbXlG,
                       label: sat_sbWYd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXlG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXlH; else goto cbXlI;
       cbXlH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXlI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$dmsequence_entry() //  [R2, R3]
         { info_tbl: [(cbXlJ,
                       label: Data.Traversable.$dmsequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXlJ: // global
           _sbWYc::P64 = R3;
           _sbWYb::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbXlK; else goto cbXlL;
       cbXlL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbXlN; else goto cbXlM;
       cbXlN: // global
           HpAlloc = 24;
           goto cbXlK;
       cbXlK: // global
           R3 = _sbWYc::P64;
           R2 = _sbWYb::P64;
           R1 = Data.Traversable.$dmsequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXlM: // global
           I64[Hp - 16] = sat_sbWYd_info;
           P64[Hp] = _sbWYc::P64;
           R2 = _sbWYb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Traversable.sequenceA_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.939659933 UTC

[section ""data" . Data.Traversable.$dmmapM_closure" {
     Data.Traversable.$dmmapM_closure:
         const Data.Traversable.$dmmapM_info;
 },
 sat_sbWYg_entry() //  [R1]
         { info_tbl: [(cbXlW,
                       label: sat_sbWYg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXlW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXlX; else goto cbXlY;
       cbXlX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXlY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$dmmapM_entry() //  [R2, R3]
         { info_tbl: [(cbXlZ,
                       label: Data.Traversable.$dmmapM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXlZ: // global
           _sbWYf::P64 = R3;
           _sbWYe::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbXm0; else goto cbXm1;
       cbXm1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbXm3; else goto cbXm2;
       cbXm3: // global
           HpAlloc = 24;
           goto cbXm0;
       cbXm0: // global
           R3 = _sbWYf::P64;
           R2 = _sbWYe::P64;
           R1 = Data.Traversable.$dmmapM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXm2: // global
           I64[Hp - 16] = sat_sbWYg_info;
           P64[Hp] = _sbWYf::P64;
           R2 = _sbWYe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Traversable.traverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.940915636 UTC

[section ""data" . Data.Traversable.$dmsequenceA_closure" {
     Data.Traversable.$dmsequenceA_closure:
         const Data.Traversable.$dmsequenceA_info;
 },
 Data.Traversable.$dmsequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbXm8,
                       label: Data.Traversable.$dmsequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXm8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXm9; else goto cbXma;
       cbXm9: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$dmsequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXma: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 24;
           call Data.Traversable.traverse_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.941909505 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbXmh,
                       label: Data.Traversable.$fTraversableURec_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXmh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXmi; else goto cbXmj;
       cbXmi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXmj: // global
           I64[Sp - 16] = block_cbXmf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXmf() //  [R1]
         { info_tbl: [(cbXmf,
                       label: block_cbXmf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXmf: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.943045223 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$cmapM_closure" {
     Data.Traversable.$fTraversableURec_$cmapM_closure:
         const Data.Traversable.$fTraversableURec_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXmt,
                       label: Data.Traversable.$fTraversableURec_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXmt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXmx; else goto cbXmy;
       cbXmx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXmy: // global
           I64[Sp - 16] = block_cbXmr_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXmr() //  [R1]
         { info_tbl: [(cbXmr,
                       label: block_cbXmr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXmr: // global
           I64[Sp] = block_cbXmw_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXmw() //  [R1]
         { info_tbl: [(cbXmw,
                       label: block_cbXmw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXmw: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.944280702 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$csequence_closure" {
     Data.Traversable.$fTraversableURec_$csequence_closure:
         const Data.Traversable.$fTraversableURec_$csequence_info;
 },
 Data.Traversable.$fTraversableURec_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXmK,
                       label: Data.Traversable.$fTraversableURec_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXmK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXmO; else goto cbXmP;
       cbXmO: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXmP: // global
           I64[Sp - 16] = block_cbXmI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXmI() //  [R1]
         { info_tbl: [(cbXmI,
                       label: block_cbXmI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXmI: // global
           I64[Sp] = block_cbXmN_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXmN() //  [R1]
         { info_tbl: [(cbXmN,
                       label: block_cbXmN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXmN: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.94533872 UTC

[section ""data" . Data.Traversable.$fTraversableURec_closure" {
     Data.Traversable.$fTraversableURec_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec_closure;
         const Data.Foldable.$fFoldableURec_closure;
         const Data.Traversable.$fTraversableURec_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.946135999 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec0_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec0_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec0_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbXn1,
                       label: Data.Traversable.$fTraversableURec0_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXn1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXn2; else goto cbXn3;
       cbXn2: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXn3: // global
           I64[Sp - 16] = block_cbXmZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXmZ() //  [R1]
         { info_tbl: [(cbXmZ,
                       label: block_cbXmZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXmZ: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.947317754 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$cmapM_closure" {
     Data.Traversable.$fTraversableURec0_$cmapM_closure:
         const Data.Traversable.$fTraversableURec0_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec0_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXnd,
                       label: Data.Traversable.$fTraversableURec0_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXnd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXnh; else goto cbXni;
       cbXnh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXni: // global
           I64[Sp - 16] = block_cbXnb_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXnb() //  [R1]
         { info_tbl: [(cbXnb,
                       label: block_cbXnb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXnb: // global
           I64[Sp] = block_cbXng_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXng() //  [R1]
         { info_tbl: [(cbXng,
                       label: block_cbXng_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXng: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.948560357 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$csequence_closure" {
     Data.Traversable.$fTraversableURec0_$csequence_closure:
         const Data.Traversable.$fTraversableURec0_$csequence_info;
 },
 Data.Traversable.$fTraversableURec0_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXnu,
                       label: Data.Traversable.$fTraversableURec0_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXnu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXny; else goto cbXnz;
       cbXny: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXnz: // global
           I64[Sp - 16] = block_cbXns_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXns() //  [R1]
         { info_tbl: [(cbXns,
                       label: block_cbXns_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXns: // global
           I64[Sp] = block_cbXnx_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXnx() //  [R1]
         { info_tbl: [(cbXnx,
                       label: block_cbXnx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXnx: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.949815289 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_closure" {
     Data.Traversable.$fTraversableURec0_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec0_closure;
         const Data.Foldable.$fFoldableURec0_closure;
         const Data.Traversable.$fTraversableURec0_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec0_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec0_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec0_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.950617113 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec1_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec1_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec1_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbXnL,
                       label: Data.Traversable.$fTraversableURec1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXnL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXnM; else goto cbXnN;
       cbXnM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXnN: // global
           I64[Sp - 16] = block_cbXnJ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXnJ() //  [R1]
         { info_tbl: [(cbXnJ,
                       label: block_cbXnJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXnJ: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.951727047 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$cmapM_closure" {
     Data.Traversable.$fTraversableURec1_$cmapM_closure:
         const Data.Traversable.$fTraversableURec1_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXnX,
                       label: Data.Traversable.$fTraversableURec1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXnX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXo1; else goto cbXo2;
       cbXo1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXo2: // global
           I64[Sp - 16] = block_cbXnV_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXnV() //  [R1]
         { info_tbl: [(cbXnV,
                       label: block_cbXnV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXnV: // global
           I64[Sp] = block_cbXo0_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXo0() //  [R1]
         { info_tbl: [(cbXo0,
                       label: block_cbXo0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXo0: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.95299155 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$csequence_closure" {
     Data.Traversable.$fTraversableURec1_$csequence_closure:
         const Data.Traversable.$fTraversableURec1_$csequence_info;
 },
 Data.Traversable.$fTraversableURec1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXoe,
                       label: Data.Traversable.$fTraversableURec1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXoe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXoi; else goto cbXoj;
       cbXoi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXoj: // global
           I64[Sp - 16] = block_cbXoc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXoc() //  [R1]
         { info_tbl: [(cbXoc,
                       label: block_cbXoc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXoc: // global
           I64[Sp] = block_cbXoh_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXoh() //  [R1]
         { info_tbl: [(cbXoh,
                       label: block_cbXoh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXoh: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.954081592 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_closure" {
     Data.Traversable.$fTraversableURec1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec1_closure;
         const Data.Foldable.$fFoldableURec1_closure;
         const Data.Traversable.$fTraversableURec1_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec1_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.9548311 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec2_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec2_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec2_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbXov,
                       label: Data.Traversable.$fTraversableURec2_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXov: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXow; else goto cbXox;
       cbXow: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXox: // global
           I64[Sp - 16] = block_cbXot_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXot() //  [R1]
         { info_tbl: [(cbXot,
                       label: block_cbXot_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXot: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.955921877 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$cmapM_closure" {
     Data.Traversable.$fTraversableURec2_$cmapM_closure:
         const Data.Traversable.$fTraversableURec2_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec2_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXoH,
                       label: Data.Traversable.$fTraversableURec2_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXoH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXoL; else goto cbXoM;
       cbXoL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXoM: // global
           I64[Sp - 16] = block_cbXoF_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXoF() //  [R1]
         { info_tbl: [(cbXoF,
                       label: block_cbXoF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXoF: // global
           I64[Sp] = block_cbXoK_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXoK() //  [R1]
         { info_tbl: [(cbXoK,
                       label: block_cbXoK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXoK: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.957164545 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$csequence_closure" {
     Data.Traversable.$fTraversableURec2_$csequence_closure:
         const Data.Traversable.$fTraversableURec2_$csequence_info;
 },
 Data.Traversable.$fTraversableURec2_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXoY,
                       label: Data.Traversable.$fTraversableURec2_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXoY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXp2; else goto cbXp3;
       cbXp2: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXp3: // global
           I64[Sp - 16] = block_cbXoW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXoW() //  [R1]
         { info_tbl: [(cbXoW,
                       label: block_cbXoW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXoW: // global
           I64[Sp] = block_cbXp1_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXp1() //  [R1]
         { info_tbl: [(cbXp1,
                       label: block_cbXp1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXp1: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.958204564 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_closure" {
     Data.Traversable.$fTraversableURec2_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec2_closure;
         const Data.Foldable.$fFoldableURec2_closure;
         const Data.Traversable.$fTraversableURec2_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec2_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec2_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec2_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.958980539 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec3_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec3_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec3_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbXpf,
                       label: Data.Traversable.$fTraversableURec3_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXpf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXpg; else goto cbXph;
       cbXpg: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXph: // global
           I64[Sp - 16] = block_cbXpd_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXpd() //  [R1]
         { info_tbl: [(cbXpd,
                       label: block_cbXpd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXpd: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.960184283 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$cmapM_closure" {
     Data.Traversable.$fTraversableURec3_$cmapM_closure:
         const Data.Traversable.$fTraversableURec3_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec3_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXpr,
                       label: Data.Traversable.$fTraversableURec3_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXpr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXpv; else goto cbXpw;
       cbXpv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXpw: // global
           I64[Sp - 16] = block_cbXpp_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXpp() //  [R1]
         { info_tbl: [(cbXpp,
                       label: block_cbXpp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXpp: // global
           I64[Sp] = block_cbXpu_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXpu() //  [R1]
         { info_tbl: [(cbXpu,
                       label: block_cbXpu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXpu: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.961453412 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$csequence_closure" {
     Data.Traversable.$fTraversableURec3_$csequence_closure:
         const Data.Traversable.$fTraversableURec3_$csequence_info;
 },
 Data.Traversable.$fTraversableURec3_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXpI,
                       label: Data.Traversable.$fTraversableURec3_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXpI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXpM; else goto cbXpN;
       cbXpM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXpN: // global
           I64[Sp - 16] = block_cbXpG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXpG() //  [R1]
         { info_tbl: [(cbXpG,
                       label: block_cbXpG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXpG: // global
           I64[Sp] = block_cbXpL_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXpL() //  [R1]
         { info_tbl: [(cbXpL,
                       label: block_cbXpL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXpL: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.962455073 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_closure" {
     Data.Traversable.$fTraversableURec3_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec3_closure;
         const Data.Foldable.$fFoldableURec3_closure;
         const Data.Traversable.$fTraversableURec3_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec3_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec3_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec3_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.963294487 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec4_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec4_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec4_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbXpZ,
                       label: Data.Traversable.$fTraversableURec4_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXpZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXq0; else goto cbXq1;
       cbXq0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXq1: // global
           I64[Sp - 16] = block_cbXpX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXpX() //  [R1]
         { info_tbl: [(cbXpX,
                       label: block_cbXpX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXpX: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.964485481 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$cmapM_closure" {
     Data.Traversable.$fTraversableURec4_$cmapM_closure:
         const Data.Traversable.$fTraversableURec4_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec4_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXqb,
                       label: Data.Traversable.$fTraversableURec4_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXqb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXqf; else goto cbXqg;
       cbXqf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXqg: // global
           I64[Sp - 16] = block_cbXq9_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXq9() //  [R1]
         { info_tbl: [(cbXq9,
                       label: block_cbXq9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXq9: // global
           I64[Sp] = block_cbXqe_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXqe() //  [R1]
         { info_tbl: [(cbXqe,
                       label: block_cbXqe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXqe: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.965994619 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$csequence_closure" {
     Data.Traversable.$fTraversableURec4_$csequence_closure:
         const Data.Traversable.$fTraversableURec4_$csequence_info;
 },
 Data.Traversable.$fTraversableURec4_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXqs,
                       label: Data.Traversable.$fTraversableURec4_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXqs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXqw; else goto cbXqx;
       cbXqw: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXqx: // global
           I64[Sp - 16] = block_cbXqq_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXqq() //  [R1]
         { info_tbl: [(cbXqq,
                       label: block_cbXqq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXqq: // global
           I64[Sp] = block_cbXqv_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXqv() //  [R1]
         { info_tbl: [(cbXqv,
                       label: block_cbXqv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXqv: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.96702897 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_closure" {
     Data.Traversable.$fTraversableURec4_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec4_closure;
         const Data.Foldable.$fFoldableURec4_closure;
         const Data.Traversable.$fTraversableURec4_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec4_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec4_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec4_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.967745343 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$csequenceA_closure" {
     Data.Traversable.$fTraversable:.:_$csequenceA_closure:
         const Data.Traversable.$fTraversable:.:_$csequenceA_info;
 },
 Data.Traversable.$fTraversable:.:_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cbXqH,
                       label: Data.Traversable.$fTraversable:.:_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXqH: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.968715863 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$cmapM_closure" {
     Data.Traversable.$fTraversable:.:_$cmapM_closure:
         const Data.Traversable.$fTraversable:.:_$cmapM_info;
 },
 Data.Traversable.$fTraversable:.:_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cbXqQ,
                       label: Data.Traversable.$fTraversable:.:_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXqQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXqR; else goto cbXqS;
       cbXqR: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXqS: // global
           I64[Sp - 40] = block_cbXqO_info;
           _sbX06::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sbX06::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXqO() //  [R1]
         { info_tbl: [(cbXqO,
                       label: block_cbXqO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXqO: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.970035284 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$csequence_closure" {
     Data.Traversable.$fTraversable:.:_$csequence_closure:
         const Data.Traversable.$fTraversable:.:_$csequence_info;
 },
 Data.Traversable.$fTraversable:.:_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cbXr2,
                       label: Data.Traversable.$fTraversable:.:_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXr2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXr3; else goto cbXr4;
       cbXr3: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXr4: // global
           I64[Sp - 32] = block_cbXr0_info;
           _sbX0c::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sbX0c::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXr0() //  [R1]
         { info_tbl: [(cbXr0,
                       label: block_cbXr0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXr0: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.972037568 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_closure" {
     Data.Traversable.$fTraversable:.:_closure:
         const Data.Traversable.$fTraversable:.:_info;
         const 0;
 },
 sat_sbX0o_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXrh,
                       label: sat_sbX0o_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXrh: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:.:_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0n_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbXrp,
                       label: sat_sbX0n_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXrp: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:.:_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0m_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXrx,
                       label: sat_sbX0m_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXrx: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:.:_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0l_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbXrF,
                       label: sat_sbX0l_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXrF: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0k_entry() //  [R1]
         { info_tbl: [(cbXrM,
                       label: sat_sbX0k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXrM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXrN; else goto cbXrO;
       cbXrN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXrO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:.:_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX0j_entry() //  [R1]
         { info_tbl: [(cbXrT,
                       label: sat_sbX0j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXrT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXrU; else goto cbXrV;
       cbXrU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXrV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:.:_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_entry() //  [R2, R3]
         { info_tbl: [(cbXrX,
                       label: Data.Traversable.$fTraversable:.:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXrX: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cbXs1; else goto cbXs0;
       cbXs1: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXs0: // global
           I64[Hp - 208] = sat_sbX0o_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sbX0n_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sbX0m_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sbX0l_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sbX0k_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sbX0j_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.976190823 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$csequenceA_closure" {
     Data.Traversable.$fTraversable:*:_$csequenceA_closure:
         const Data.Traversable.$fTraversable:*:_$csequenceA_info;
 },
 Data.Traversable.$fTraversable:*:_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cbXs9,
                       label: Data.Traversable.$fTraversable:*:_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXs9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXsa; else goto cbXsb;
       cbXsa: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$csequenceA_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXsb: // global
           I64[Sp - 32] = block_cbXs6_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubXsf; else goto cbXs7;
       ubXsf: // global
           call _cbXs6(R1) args: 0, res: 0, upd: 0;
       cbXs7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXs6() //  [R1]
         { info_tbl: [(cbXs6,
                       label: block_cbXs6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXs6: // global
           R6 = P64[R1 + 7];
           R5 = GHC.Base.id_closure+1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.977937313 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$cmapM_closure" {
     Data.Traversable.$fTraversable:*:_$cmapM_closure:
         const Data.Traversable.$fTraversable:*:_$cmapM_info;
 },
 Data.Traversable.$fTraversable:*:_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cbXsn,
                       label: Data.Traversable.$fTraversable:*:_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXsn: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbXsr; else goto cbXss;
       cbXsr: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXss: // global
           I64[Sp - 40] = block_cbXsk_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubXsy; else goto cbXsl;
       ubXsy: // global
           call _cbXsk(R1) args: 0, res: 0, upd: 0;
       cbXsl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXsk() //  [R1]
         { info_tbl: [(cbXsk,
                       label: block_cbXsk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXsk: // global
           I64[Sp - 8] = block_cbXsq_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXsq() //  [R1]
         { info_tbl: [(cbXsq,
                       label: block_cbXsq_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXsq: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 40];
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.979452208 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$csequence_closure" {
     Data.Traversable.$fTraversable:*:_$csequence_closure:
         const Data.Traversable.$fTraversable:*:_$csequence_info;
 },
 Data.Traversable.$fTraversable:*:_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cbXsG,
                       label: Data.Traversable.$fTraversable:*:_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXsG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXsK; else goto cbXsL;
       cbXsK: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXsL: // global
           I64[Sp - 32] = block_cbXsD_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubXsR; else goto cbXsE;
       ubXsR: // global
           call _cbXsD(R1) args: 0, res: 0, upd: 0;
       cbXsE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXsD() //  [R1]
         { info_tbl: [(cbXsD,
                       label: block_cbXsD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXsD: // global
           I64[Sp - 8] = block_cbXsJ_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXsJ() //  [R1]
         { info_tbl: [(cbXsJ,
                       label: block_cbXsJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXsJ: // global
           R6 = P64[Sp + 32];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.981574136 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_closure" {
     Data.Traversable.$fTraversable:*:_closure:
         const Data.Traversable.$fTraversable:*:_info;
         const 0;
 },
 sat_sbX0U_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXt1,
                       label: sat_sbX0U_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXt1: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:*:_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0T_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbXt9,
                       label: sat_sbX0T_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXt9: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:*:_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0S_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXth,
                       label: sat_sbX0S_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXth: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:*:_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0R_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbXtp,
                       label: sat_sbX0R_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXtp: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:*:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0Q_entry() //  [R1]
         { info_tbl: [(cbXtw,
                       label: sat_sbX0Q_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXtw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXtx; else goto cbXty;
       cbXtx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXty: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:*:_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX0P_entry() //  [R1]
         { info_tbl: [(cbXtD,
                       label: sat_sbX0P_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXtD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXtE; else goto cbXtF;
       cbXtE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXtF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:*:_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:*:_entry() //  [R2, R3]
         { info_tbl: [(cbXtH,
                       label: Data.Traversable.$fTraversable:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXtH: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cbXtL; else goto cbXtK;
       cbXtL: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXtK: // global
           I64[Hp - 208] = sat_sbX0U_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sbX0T_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sbX0S_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sbX0R_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sbX0Q_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sbX0P_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.983915087 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$csequenceA_closure" {
     Data.Traversable.$fTraversable:+:_$csequenceA_closure:
         const Data.Traversable.$fTraversable:+:_$csequenceA_info;
 },
 Data.Traversable.$fTraversable:+:_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cbXtQ,
                       label: Data.Traversable.$fTraversable:+:_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXtQ: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.984879061 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$cmapM_closure" {
     Data.Traversable.$fTraversable:+:_$cmapM_closure:
         const Data.Traversable.$fTraversable:+:_$cmapM_info;
 },
 Data.Traversable.$fTraversable:+:_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cbXtZ,
                       label: Data.Traversable.$fTraversable:+:_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXtZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXu0; else goto cbXu1;
       cbXu0: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXu1: // global
           I64[Sp - 40] = block_cbXtX_info;
           _sbX0Y::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sbX0Y::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXtX() //  [R1]
         { info_tbl: [(cbXtX,
                       label: block_cbXtX_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXtX: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.986114267 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$csequence_closure" {
     Data.Traversable.$fTraversable:+:_$csequence_closure:
         const Data.Traversable.$fTraversable:+:_$csequence_info;
 },
 Data.Traversable.$fTraversable:+:_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cbXub,
                       label: Data.Traversable.$fTraversable:+:_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXub: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXuc; else goto cbXud;
       cbXuc: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXud: // global
           I64[Sp - 32] = block_cbXu9_info;
           _sbX14::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sbX14::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXu9() //  [R1]
         { info_tbl: [(cbXu9,
                       label: block_cbXu9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXu9: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.98804195 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_closure" {
     Data.Traversable.$fTraversable:+:_closure:
         const Data.Traversable.$fTraversable:+:_info;
         const 0;
 },
 sat_sbX1g_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXuq,
                       label: sat_sbX1g_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXuq: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:+:_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1f_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbXuy,
                       label: sat_sbX1f_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXuy: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:+:_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1e_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXuG,
                       label: sat_sbX1e_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXuG: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:+:_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1d_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbXuO,
                       label: sat_sbX1d_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXuO: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1c_entry() //  [R1]
         { info_tbl: [(cbXuV,
                       label: sat_sbX1c_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXuV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXuW; else goto cbXuX;
       cbXuW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXuX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:+:_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX1b_entry() //  [R1]
         { info_tbl: [(cbXv2,
                       label: sat_sbX1b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXv2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXv3; else goto cbXv4;
       cbXv3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXv4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:+:_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_entry() //  [R2, R3]
         { info_tbl: [(cbXv6,
                       label: Data.Traversable.$fTraversable:+:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXv6: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cbXva; else goto cbXv9;
       cbXva: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXv9: // global
           I64[Hp - 208] = sat_sbX1g_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sbX1f_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sbX1e_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sbX1d_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sbX1c_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sbX1b_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.99079125 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$csequenceA_closure" {
     Data.Traversable.$fTraversableM1_$csequenceA_closure:
         const Data.Traversable.$fTraversableM1_$csequenceA_info;
 },
 sat_sbX1l_entry() //  [R1]
         { info_tbl: [(cbXvj,
                       label: sat_sbX1l_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXvj: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbXvk; else goto cbXvl;
       cbXvk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXvl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$csequenceA_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbXvo,
                       label: Data.Traversable.$fTraversableM1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXvo: // global
           _sbX1j::P64 = R4;
           _sbX1i::P64 = R3;
           _sbX1h::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXvp; else goto cbXvq;
       cbXvq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbXvs; else goto cbXvr;
       cbXvs: // global
           HpAlloc = 40;
           goto cbXvp;
       cbXvp: // global
           R4 = _sbX1j::P64;
           R3 = _sbX1i::P64;
           R2 = _sbX1h::P64;
           R1 = Data.Traversable.$fTraversableM1_$csequenceA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXvr: // global
           I64[Hp - 32] = sat_sbX1l_info;
           P64[Hp - 16] = _sbX1h::P64;
           P64[Hp - 8] = _sbX1i::P64;
           P64[Hp] = _sbX1j::P64;
           I64[Sp - 16] = block_cbXvm_info;
           R2 = _sbX1i::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXvm() //  [R1]
         { info_tbl: [(cbXvm,
                       label: block_cbXvm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXvm: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.992519483 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$cmapM_closure" {
     Data.Traversable.$fTraversableM1_$cmapM_closure:
         const Data.Traversable.$fTraversableM1_$cmapM_info;
 },
 sat_sbX1s_entry() //  [R1]
         { info_tbl: [(cbXvI,
                       label: sat_sbX1s_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXvI: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbXvJ; else goto cbXvK;
       cbXvJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXvK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$cmapM_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cbXvL,
                       label: Data.Traversable.$fTraversableM1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXvL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXvN; else goto cbXvO;
       cbXvN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$cmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXvO: // global
           I64[Sp - 32] = block_cbXvA_info;
           _sbX1m::P64 = R2;
           R2 = R3;
           P64[Sp - 24] = _sbX1m::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXvA() //  [R1]
         { info_tbl: [(cbXvA,
                       label: block_cbXvA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXvA: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXvR; else goto cbXvQ;
       cbXvR: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXvQ: // global
           I64[Hp - 40] = sat_sbX1s_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           I64[Sp + 16] = block_cbXvM_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 40;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXvM() //  [R1]
         { info_tbl: [(cbXvM,
                       label: block_cbXvM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXvM: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.994511533 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$csequence_closure" {
     Data.Traversable.$fTraversableM1_$csequence_closure:
         const Data.Traversable.$fTraversableM1_$csequence_info;
 },
 sat_sbX1y_entry() //  [R1]
         { info_tbl: [(cbXw8,
                       label: sat_sbX1y_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXw8: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbXw9; else goto cbXwa;
       cbXw9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXwa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$csequence_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbXwb,
                       label: Data.Traversable.$fTraversableM1_$csequence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXwb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXwd; else goto cbXwe;
       cbXwd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$csequence_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXwe: // global
           I64[Sp - 24] = block_cbXw0_info;
           _sbX1t::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _sbX1t::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXw0() //  [R1]
         { info_tbl: [(cbXw0,
                       label: block_cbXw0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXw0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbXwh; else goto cbXwg;
       cbXwh: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXwg: // global
           I64[Hp - 32] = sat_sbX1y_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbXwc_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXwc() //  [R1]
         { info_tbl: [(cbXwc,
                       label: block_cbXwc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXwc: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.996761275 UTC

[section ""data" . Data.Traversable.$fTraversableM1_closure" {
     Data.Traversable.$fTraversableM1_closure:
         const Data.Traversable.$fTraversableM1_info;
         const 0;
 },
 sat_sbX1F_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXwv,
                       label: sat_sbX1F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXwv: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableM1_$csequence_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1E_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbXwD,
                       label: sat_sbX1E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXwD: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableM1_$cmapM_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1D_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXwL,
                       label: sat_sbX1D_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXwL: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableM1_$csequenceA_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1C_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbXwT,
                       label: sat_sbX1C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXwT: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableM1_$ctraverse_entry(R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1B_entry() //  [R1]
         { info_tbl: [(cbXx0,
                       label: sat_sbX1B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXx0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXx1; else goto cbXx2;
       cbXx1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXx2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableM1_$cp2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX1A_entry() //  [R1]
         { info_tbl: [(cbXx7,
                       label: sat_sbX1A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXx7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXx8; else goto cbXx9;
       cbXx8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXx9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableM1_$cp1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_entry() //  [R2]
         { info_tbl: [(cbXxb,
                       label: Data.Traversable.$fTraversableM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXxb: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbXxf; else goto cbXxe;
       cbXxf: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXxe: // global
           I64[Hp - 160] = sat_sbX1F_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sbX1E_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbX1D_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbX1C_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbX1B_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbX1A_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 96;
           P64[Hp - 24] = Hp - 109;
           P64[Hp - 16] = Hp - 126;
           P64[Hp - 8] = Hp - 141;
           P64[Hp] = Hp - 158;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:49.998975295 UTC

[section ""data" . Data.Traversable.$fTraversableK1_$cmapM_closure" {
     Data.Traversable.$fTraversableK1_$cmapM_closure:
         const Data.Traversable.$fTraversableK1_$cmapM_info;
 },
 Data.Traversable.$fTraversableK1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXxm,
                       label: Data.Traversable.$fTraversableK1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXxm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXxn; else goto cbXxo;
       cbXxn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableK1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXxo: // global
           I64[Sp - 16] = block_cbXxk_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXxk() //  [R1]
         { info_tbl: [(cbXxk,
                       label: block_cbXxk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXxk: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.000022345 UTC

[section ""data" . Data.Traversable.$fTraversableK1_$csequence_closure" {
     Data.Traversable.$fTraversableK1_$csequence_closure:
         const Data.Traversable.$fTraversableK1_$csequence_info;
 },
 Data.Traversable.$fTraversableK1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXxy,
                       label: Data.Traversable.$fTraversableK1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXxy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXxz; else goto cbXxA;
       cbXxz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableK1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXxA: // global
           I64[Sp - 16] = block_cbXxw_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXxw() //  [R1]
         { info_tbl: [(cbXxw,
                       label: block_cbXxw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXxw: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.001008269 UTC

[section ""data" . $fTraversableK2_rbWTS_closure" {
     $fTraversableK2_rbWTS_closure:
         const $fTraversableK2_rbWTS_info;
 },
 $fTraversableK2_rbWTS_entry() //  [R2, R3]
         { info_tbl: [(cbXxI,
                       label: $fTraversableK2_rbWTS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXxI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXxJ; else goto cbXxK;
       cbXxJ: // global
           R3 = R3;
           R2 = R2;
           R1 = $fTraversableK2_rbWTS_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXxK: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.001927722 UTC

[section ""data" . Data.Traversable.$fTraversableK1_closure" {
     Data.Traversable.$fTraversableK1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorK1_closure;
         const Data.Foldable.$fFoldableK1_closure;
         const Data.Traversable.$fTraversableK1_$ctraverse_closure+3;
         const $fTraversableK2_rbWTS_closure+2;
         const Data.Traversable.$fTraversableK1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableK1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.002855595 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$csequenceA_closure" {
     Data.Traversable.$fTraversableRec1_$csequenceA_closure:
         const Data.Traversable.$fTraversableRec1_$csequenceA_info;
 },
 sat_sbX1T_entry() //  [R1]
         { info_tbl: [(cbXxT,
                       label: sat_sbX1T_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXxT: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbXxU; else goto cbXxV;
       cbXxU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXxV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$csequenceA_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbXxY,
                       label: Data.Traversable.$fTraversableRec1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXxY: // global
           _sbX1R::P64 = R4;
           _sbX1Q::P64 = R3;
           _sbX1P::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXxZ; else goto cbXy0;
       cbXy0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbXy2; else goto cbXy1;
       cbXy2: // global
           HpAlloc = 40;
           goto cbXxZ;
       cbXxZ: // global
           R4 = _sbX1R::P64;
           R3 = _sbX1Q::P64;
           R2 = _sbX1P::P64;
           R1 = Data.Traversable.$fTraversableRec1_$csequenceA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXy1: // global
           I64[Hp - 32] = sat_sbX1T_info;
           P64[Hp - 16] = _sbX1P::P64;
           P64[Hp - 8] = _sbX1Q::P64;
           P64[Hp] = _sbX1R::P64;
           I64[Sp - 16] = block_cbXxW_info;
           R2 = _sbX1Q::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXxW() //  [R1]
         { info_tbl: [(cbXxW,
                       label: block_cbXxW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXxW: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.004609453 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$cmapM_closure" {
     Data.Traversable.$fTraversableRec1_$cmapM_closure:
         const Data.Traversable.$fTraversableRec1_$cmapM_info;
 },
 sat_sbX20_entry() //  [R1]
         { info_tbl: [(cbXyi,
                       label: sat_sbX20_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXyi: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbXyj; else goto cbXyk;
       cbXyj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXyk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$cmapM_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cbXyl,
                       label: Data.Traversable.$fTraversableRec1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXyl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXyn; else goto cbXyo;
       cbXyn: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$cmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXyo: // global
           I64[Sp - 32] = block_cbXya_info;
           _sbX1U::P64 = R2;
           R2 = R3;
           P64[Sp - 24] = _sbX1U::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXya() //  [R1]
         { info_tbl: [(cbXya,
                       label: block_cbXya_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXya: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXyr; else goto cbXyq;
       cbXyr: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXyq: // global
           I64[Hp - 40] = sat_sbX20_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           I64[Sp + 16] = block_cbXym_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 40;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXym() //  [R1]
         { info_tbl: [(cbXym,
                       label: block_cbXym_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXym: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.006560225 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$csequence_closure" {
     Data.Traversable.$fTraversableRec1_$csequence_closure:
         const Data.Traversable.$fTraversableRec1_$csequence_info;
 },
 sat_sbX26_entry() //  [R1]
         { info_tbl: [(cbXyI,
                       label: sat_sbX26_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXyI: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbXyJ; else goto cbXyK;
       cbXyJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXyK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$csequence_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbXyL,
                       label: Data.Traversable.$fTraversableRec1_$csequence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXyL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXyN; else goto cbXyO;
       cbXyN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$csequence_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXyO: // global
           I64[Sp - 24] = block_cbXyA_info;
           _sbX21::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _sbX21::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXyA() //  [R1]
         { info_tbl: [(cbXyA,
                       label: block_cbXyA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXyA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbXyR; else goto cbXyQ;
       cbXyR: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXyQ: // global
           I64[Hp - 32] = sat_sbX26_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbXyM_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXyM() //  [R1]
         { info_tbl: [(cbXyM,
                       label: block_cbXyM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXyM: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.008836543 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_closure" {
     Data.Traversable.$fTraversableRec1_closure:
         const Data.Traversable.$fTraversableRec1_info;
         const 0;
 },
 sat_sbX2d_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXz5,
                       label: sat_sbX2d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXz5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableRec1_$csequence_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX2c_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbXzd,
                       label: sat_sbX2c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXzd: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableRec1_$cmapM_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX2b_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXzl,
                       label: sat_sbX2b_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXzl: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableRec1_$csequenceA_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX2a_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbXzt,
                       label: sat_sbX2a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXzt: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableRec1_$ctraverse_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX29_entry() //  [R1]
         { info_tbl: [(cbXzA,
                       label: sat_sbX29_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXzA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXzB; else goto cbXzC;
       cbXzB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXzC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableRec1_$cp2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX28_entry() //  [R1]
         { info_tbl: [(cbXzH,
                       label: sat_sbX28_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXzH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXzI; else goto cbXzJ;
       cbXzI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXzJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableRec1_$cp1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_entry() //  [R2]
         { info_tbl: [(cbXzL,
                       label: Data.Traversable.$fTraversableRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXzL: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbXzP; else goto cbXzO;
       cbXzP: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXzO: // global
           I64[Hp - 160] = sat_sbX2d_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sbX2c_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbX2b_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbX2a_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbX29_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbX28_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 96;
           P64[Hp - 24] = Hp - 109;
           P64[Hp - 16] = Hp - 126;
           P64[Hp - 8] = Hp - 141;
           P64[Hp] = Hp - 158;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.011036557 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$csequenceA_closure" {
     Data.Traversable.$fTraversablePar1_$csequenceA_closure:
         const Data.Traversable.$fTraversablePar1_$csequenceA_info;
 },
 Data.Traversable.$fTraversablePar1_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbXzW,
                       label: Data.Traversable.$fTraversablePar1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXzW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXzX; else goto cbXzY;
       cbXzX: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversablePar1_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXzY: // global
           I64[Sp - 16] = block_cbXzU_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXzU() //  [R1]
         { info_tbl: [(cbXzU,
                       label: block_cbXzU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXzU: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.012244084 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$cmapM_closure" {
     Data.Traversable.$fTraversablePar1_$cmapM_closure:
         const Data.Traversable.$fTraversablePar1_$cmapM_info;
 },
 Data.Traversable.$fTraversablePar1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXA9,
                       label: Data.Traversable.$fTraversablePar1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXA9: // global
           _sbX2j::P64 = R4;
           _sbX2i::P64 = R3;
           _sbX2h::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXAd; else goto cbXAe;
       cbXAe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXAg; else goto cbXAf;
       cbXAg: // global
           HpAlloc = 32;
           goto cbXAd;
       cbXAd: // global
           R4 = _sbX2j::P64;
           R3 = _sbX2i::P64;
           R2 = _sbX2h::P64;
           R1 = Data.Traversable.$fTraversablePar1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXAf: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX2i::P64;
           P64[Hp] = _sbX2j::P64;
           I64[Sp - 16] = block_cbXA7_info;
           R2 = _sbX2h::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXA7() //  [R1]
         { info_tbl: [(cbXA7,
                       label: block_cbXA7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXA7: // global
           I64[Sp] = block_cbXAc_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXAc() //  [R1]
         { info_tbl: [(cbXAc,
                       label: block_cbXAc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXAc: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.013779189 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$csequence_closure" {
     Data.Traversable.$fTraversablePar1_$csequence_closure:
         const Data.Traversable.$fTraversablePar1_$csequence_info;
 },
 Data.Traversable.$fTraversablePar1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXAs,
                       label: Data.Traversable.$fTraversablePar1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXAs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXAw; else goto cbXAx;
       cbXAw: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversablePar1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXAx: // global
           I64[Sp - 16] = block_cbXAq_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXAq() //  [R1]
         { info_tbl: [(cbXAq,
                       label: block_cbXAq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXAq: // global
           I64[Sp] = block_cbXAv_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXAv() //  [R1]
         { info_tbl: [(cbXAv,
                       label: block_cbXAv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXAv: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.014818503 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_closure" {
     Data.Traversable.$fTraversablePar1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorPar1_closure;
         const Data.Foldable.$fFoldablePar1_closure;
         const Data.Traversable.$fTraversablePar1_$ctraverse_closure+3;
         const Data.Traversable.$fTraversablePar1_$csequenceA_closure+2;
         const Data.Traversable.$fTraversablePar1_$cmapM_closure+3;
         const Data.Traversable.$fTraversablePar1_$csequence_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.015629928 UTC

[section ""data" . Data.Traversable.$fTraversableV1_$cmapM_closure" {
     Data.Traversable.$fTraversableV1_$cmapM_closure:
         const Data.Traversable.$fTraversableV1_$cmapM_info;
 },
 Data.Traversable.$fTraversableV1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXAJ,
                       label: Data.Traversable.$fTraversableV1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXAJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXAK; else goto cbXAL;
       cbXAK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableV1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXAL: // global
           I64[Sp - 16] = block_cbXAH_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXAH() //  [R1]
         { info_tbl: [(cbXAH,
                       label: block_cbXAH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXAH: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.016677551 UTC

[section ""data" . Data.Traversable.$fTraversableV1_$csequence_closure" {
     Data.Traversable.$fTraversableV1_$csequence_closure:
         const Data.Traversable.$fTraversableV1_$csequence_info;
 },
 Data.Traversable.$fTraversableV1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXAV,
                       label: Data.Traversable.$fTraversableV1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXAV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXAW; else goto cbXAX;
       cbXAW: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableV1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXAX: // global
           I64[Sp - 16] = block_cbXAT_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXAT() //  [R1]
         { info_tbl: [(cbXAT,
                       label: block_cbXAT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXAT: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.017708191 UTC

[section ""data" . $fTraversableV2_rbWTT_closure" {
     $fTraversableV2_rbWTT_closure:
         const $fTraversableV2_rbWTT_info;
 },
 $fTraversableV2_rbWTT_entry() //  [R2, R3]
         { info_tbl: [(cbXB5,
                       label: $fTraversableV2_rbWTT_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXB5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXB6; else goto cbXB7;
       cbXB6: // global
           R3 = R3;
           R2 = R2;
           R1 = $fTraversableV2_rbWTT_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXB7: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.018486286 UTC

[section ""data" . Data.Traversable.$fTraversableV1_closure" {
     Data.Traversable.$fTraversableV1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorV1_closure;
         const Data.Foldable.$fFoldableV1_closure;
         const Data.Traversable.$fTraversableV1_$ctraverse_closure+3;
         const $fTraversableV2_rbWTT_closure+2;
         const Data.Traversable.$fTraversableV1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableV1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.01923661 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$csequenceA_closure" {
     Data.Traversable.$fTraversableIdentity_$csequenceA_closure:
         const Data.Traversable.$fTraversableIdentity_$csequenceA_info;
 },
 Data.Traversable.$fTraversableIdentity_$csequenceA_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cbXBe,
                       label: Data.Traversable.$fTraversableIdentity_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXBe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXBf; else goto cbXBg;
       cbXBf: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableIdentity_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXBg: // global
           I64[Sp - 16] = block_cbXBc_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXBc() //  [R1]
         { info_tbl: [(cbXBc,
                       label: block_cbXBc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXBc: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.020361516 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$cmapM_closure" {
     Data.Traversable.$fTraversableIdentity_$cmapM_closure:
         const Data.Traversable.$fTraversableIdentity_$cmapM_info;
 },
 Data.Traversable.$fTraversableIdentity_$cmapM_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbXBr,
                       label: Data.Traversable.$fTraversableIdentity_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXBr: // global
           _sbX2F::P64 = R4;
           _sbX2E::P64 = R3;
           _sbX2D::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXBv; else goto cbXBw;
       cbXBw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXBy; else goto cbXBx;
       cbXBy: // global
           HpAlloc = 32;
           goto cbXBv;
       cbXBv: // global
           R4 = _sbX2F::P64;
           R3 = _sbX2E::P64;
           R2 = _sbX2D::P64;
           R1 = Data.Traversable.$fTraversableIdentity_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXBx: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX2E::P64;
           P64[Hp] = _sbX2F::P64;
           I64[Sp - 16] = block_cbXBp_info;
           R2 = _sbX2D::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXBp() //  [R1]
         { info_tbl: [(cbXBp,
                       label: block_cbXBp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXBp: // global
           I64[Sp] = block_cbXBu_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXBu() //  [R1]
         { info_tbl: [(cbXBu,
                       label: block_cbXBu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXBu: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.021681236 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$csequence_closure" {
     Data.Traversable.$fTraversableIdentity_$csequence_closure:
         const Data.Traversable.$fTraversableIdentity_$csequence_info;
 },
 Data.Traversable.$fTraversableIdentity_$csequence_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbXBK,
                       label: Data.Traversable.$fTraversableIdentity_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXBK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXBO; else goto cbXBP;
       cbXBO: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableIdentity_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXBP: // global
           I64[Sp - 16] = block_cbXBI_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXBI() //  [R1]
         { info_tbl: [(cbXBI,
                       label: block_cbXBI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXBI: // global
           I64[Sp] = block_cbXBN_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXBN() //  [R1]
         { info_tbl: [(cbXBN,
                       label: block_cbXBN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXBN: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.022737274 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_closure" {
     Data.Traversable.$fTraversableIdentity_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Functor.Identity.$fFunctorIdentity_closure;
         const Data.Functor.Identity.$fFoldableIdentity_closure;
         const Data.Traversable.$fTraversableIdentity_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableIdentity_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableIdentity_$cmapM_closure+3;
         const Data.Traversable.$fTraversableIdentity_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.023518086 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$csequenceA_closure" {
     Data.Traversable.$fTraversableProduct_$csequenceA_closure:
         const Data.Traversable.$fTraversableProduct_$csequenceA_info;
 },
 Data.Traversable.$fTraversableProduct_$csequenceA_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbXC1,
                       label: Data.Traversable.$fTraversableProduct_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXC1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXC2; else goto cbXC3;
       cbXC2: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProduct_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXC3: // global
           I64[Sp - 16] = block_cbXBZ_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXBZ() //  [R1]
         { info_tbl: [(cbXBZ,
                       label: block_cbXBZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXBZ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.024689314 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$cmapM_closure" {
     Data.Traversable.$fTraversableProduct_$cmapM_closure:
         const Data.Traversable.$fTraversableProduct_$cmapM_info;
 },
 Data.Traversable.$fTraversableProduct_$cmapM_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbXCe,
                       label: Data.Traversable.$fTraversableProduct_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXCe: // global
           _sbX2S::P64 = R4;
           _sbX2R::P64 = R3;
           _sbX2Q::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXCi; else goto cbXCj;
       cbXCj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXCl; else goto cbXCk;
       cbXCl: // global
           HpAlloc = 32;
           goto cbXCi;
       cbXCi: // global
           R4 = _sbX2S::P64;
           R3 = _sbX2R::P64;
           R2 = _sbX2Q::P64;
           R1 = Data.Traversable.$fTraversableProduct_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXCk: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX2R::P64;
           P64[Hp] = _sbX2S::P64;
           I64[Sp - 16] = block_cbXCc_info;
           R2 = _sbX2Q::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXCc() //  [R1]
         { info_tbl: [(cbXCc,
                       label: block_cbXCc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXCc: // global
           I64[Sp] = block_cbXCh_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXCh() //  [R1]
         { info_tbl: [(cbXCh,
                       label: block_cbXCh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXCh: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.026058385 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$csequence_closure" {
     Data.Traversable.$fTraversableProduct_$csequence_closure:
         const Data.Traversable.$fTraversableProduct_$csequence_info;
 },
 Data.Traversable.$fTraversableProduct_$csequence_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cbXCx,
                       label: Data.Traversable.$fTraversableProduct_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXCx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXCB; else goto cbXCC;
       cbXCB: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProduct_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXCC: // global
           I64[Sp - 16] = block_cbXCv_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXCv() //  [R1]
         { info_tbl: [(cbXCv,
                       label: block_cbXCv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXCv: // global
           I64[Sp] = block_cbXCA_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXCA() //  [R1]
         { info_tbl: [(cbXCA,
                       label: block_cbXCA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXCA: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.027078294 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_closure" {
     Data.Traversable.$fTraversableProduct_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Semigroup.Internal.$fFunctorProduct_closure;
         const Data.Foldable.$fFoldableProduct_closure;
         const Data.Traversable.$fTraversableProduct_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableProduct_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableProduct_$cmapM_closure+3;
         const Data.Traversable.$fTraversableProduct_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.027881907 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$csequenceA_closure" {
     Data.Traversable.$fTraversableSum_$csequenceA_closure:
         const Data.Traversable.$fTraversableSum_$csequenceA_info;
 },
 Data.Traversable.$fTraversableSum_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbXCO,
                       label: Data.Traversable.$fTraversableSum_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXCO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXCP; else goto cbXCQ;
       cbXCP: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableSum_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXCQ: // global
           I64[Sp - 16] = block_cbXCM_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXCM() //  [R1]
         { info_tbl: [(cbXCM,
                       label: block_cbXCM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXCM: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.029091485 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$cmapM_closure" {
     Data.Traversable.$fTraversableSum_$cmapM_closure:
         const Data.Traversable.$fTraversableSum_$cmapM_info;
 },
 Data.Traversable.$fTraversableSum_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXD1,
                       label: Data.Traversable.$fTraversableSum_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXD1: // global
           _sbX35::P64 = R4;
           _sbX34::P64 = R3;
           _sbX33::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXD5; else goto cbXD6;
       cbXD6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXD8; else goto cbXD7;
       cbXD8: // global
           HpAlloc = 32;
           goto cbXD5;
       cbXD5: // global
           R4 = _sbX35::P64;
           R3 = _sbX34::P64;
           R2 = _sbX33::P64;
           R1 = Data.Traversable.$fTraversableSum_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXD7: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX34::P64;
           P64[Hp] = _sbX35::P64;
           I64[Sp - 16] = block_cbXCZ_info;
           R2 = _sbX33::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXCZ() //  [R1]
         { info_tbl: [(cbXCZ,
                       label: block_cbXCZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXCZ: // global
           I64[Sp] = block_cbXD4_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXD4() //  [R1]
         { info_tbl: [(cbXD4,
                       label: block_cbXD4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXD4: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.030647171 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$csequence_closure" {
     Data.Traversable.$fTraversableSum_$csequence_closure:
         const Data.Traversable.$fTraversableSum_$csequence_info;
 },
 Data.Traversable.$fTraversableSum_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXDk,
                       label: Data.Traversable.$fTraversableSum_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXDk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXDo; else goto cbXDp;
       cbXDo: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableSum_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXDp: // global
           I64[Sp - 16] = block_cbXDi_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXDi() //  [R1]
         { info_tbl: [(cbXDi,
                       label: block_cbXDi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXDi: // global
           I64[Sp] = block_cbXDn_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXDn() //  [R1]
         { info_tbl: [(cbXDn,
                       label: block_cbXDn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXDn: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.031691425 UTC

[section ""data" . Data.Traversable.$fTraversableSum_closure" {
     Data.Traversable.$fTraversableSum_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Semigroup.Internal.$fFunctorSum_closure;
         const Data.Foldable.$fFoldableSum_closure;
         const Data.Traversable.$fTraversableSum_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableSum_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableSum_$cmapM_closure+3;
         const Data.Traversable.$fTraversableSum_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.032455306 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$csequenceA_closure" {
     Data.Traversable.$fTraversableDual_$csequenceA_closure:
         const Data.Traversable.$fTraversableDual_$csequenceA_info;
 },
 Data.Traversable.$fTraversableDual_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbXDB,
                       label: Data.Traversable.$fTraversableDual_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXDB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXDC; else goto cbXDD;
       cbXDC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableDual_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXDD: // global
           I64[Sp - 16] = block_cbXDz_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXDz() //  [R1]
         { info_tbl: [(cbXDz,
                       label: block_cbXDz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXDz: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.033680407 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$cmapM_closure" {
     Data.Traversable.$fTraversableDual_$cmapM_closure:
         const Data.Traversable.$fTraversableDual_$cmapM_info;
 },
 Data.Traversable.$fTraversableDual_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXDO,
                       label: Data.Traversable.$fTraversableDual_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXDO: // global
           _sbX3i::P64 = R4;
           _sbX3h::P64 = R3;
           _sbX3g::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXDS; else goto cbXDT;
       cbXDT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXDV; else goto cbXDU;
       cbXDV: // global
           HpAlloc = 32;
           goto cbXDS;
       cbXDS: // global
           R4 = _sbX3i::P64;
           R3 = _sbX3h::P64;
           R2 = _sbX3g::P64;
           R1 = Data.Traversable.$fTraversableDual_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXDU: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX3h::P64;
           P64[Hp] = _sbX3i::P64;
           I64[Sp - 16] = block_cbXDM_info;
           R2 = _sbX3g::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXDM() //  [R1]
         { info_tbl: [(cbXDM,
                       label: block_cbXDM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXDM: // global
           I64[Sp] = block_cbXDR_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXDR() //  [R1]
         { info_tbl: [(cbXDR,
                       label: block_cbXDR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXDR: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.035038578 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$csequence_closure" {
     Data.Traversable.$fTraversableDual_$csequence_closure:
         const Data.Traversable.$fTraversableDual_$csequence_info;
 },
 Data.Traversable.$fTraversableDual_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXE7,
                       label: Data.Traversable.$fTraversableDual_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXE7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXEb; else goto cbXEc;
       cbXEb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableDual_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXEc: // global
           I64[Sp - 16] = block_cbXE5_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXE5() //  [R1]
         { info_tbl: [(cbXE5,
                       label: block_cbXE5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXE5: // global
           I64[Sp] = block_cbXEa_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXEa() //  [R1]
         { info_tbl: [(cbXEa,
                       label: block_cbXEa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXEa: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.037856565 UTC

[section ""data" . Data.Traversable.$fTraversableDual_closure" {
     Data.Traversable.$fTraversableDual_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Semigroup.Internal.$fFunctorDual_closure;
         const Data.Foldable.$fFoldableDual_closure;
         const Data.Traversable.$fTraversableDual_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableDual_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableDual_$cmapM_closure+3;
         const Data.Traversable.$fTraversableDual_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.038614264 UTC

[section ""data" . Data.Traversable.$fTraversableConst_$cmapM_closure" {
     Data.Traversable.$fTraversableConst_$cmapM_closure:
         const Data.Traversable.$fTraversableConst_$cmapM_info;
 },
 Data.Traversable.$fTraversableConst_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXEo,
                       label: Data.Traversable.$fTraversableConst_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXEo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXEp; else goto cbXEq;
       cbXEp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableConst_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXEq: // global
           I64[Sp - 16] = block_cbXEm_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXEm() //  [R1]
         { info_tbl: [(cbXEm,
                       label: block_cbXEm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXEm: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.039672249 UTC

[section ""data" . Data.Traversable.$fTraversableConst_$csequence_closure" {
     Data.Traversable.$fTraversableConst_$csequence_closure:
         const Data.Traversable.$fTraversableConst_$csequence_info;
 },
 Data.Traversable.$fTraversableConst_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXEA,
                       label: Data.Traversable.$fTraversableConst_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXEA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXEB; else goto cbXEC;
       cbXEB: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableConst_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXEC: // global
           I64[Sp - 16] = block_cbXEy_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXEy() //  [R1]
         { info_tbl: [(cbXEy,
                       label: block_cbXEy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXEy: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.040710749 UTC

[section ""data" . $fTraversableConst1_rbWTU_closure" {
     $fTraversableConst1_rbWTU_closure:
         const $fTraversableConst1_rbWTU_info;
 },
 $fTraversableConst1_rbWTU_entry() //  [R2, R3]
         { info_tbl: [(cbXEK,
                       label: $fTraversableConst1_rbWTU_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXEK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXEL; else goto cbXEM;
       cbXEL: // global
           R3 = R3;
           R2 = R2;
           R1 = $fTraversableConst1_rbWTU_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXEM: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.041857576 UTC

[section ""data" . Data.Traversable.$fTraversableConst_closure" {
     Data.Traversable.$fTraversableConst_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Functor.Const.$fFunctorConst_closure;
         const Data.Functor.Const.$fFoldableConst_closure;
         const Data.Traversable.$fTraversableConst_$ctraverse_closure+3;
         const $fTraversableConst1_rbWTU_closure+2;
         const Data.Traversable.$fTraversableConst_$cmapM_closure+3;
         const Data.Traversable.$fTraversableConst_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.042958113 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$csequenceA_closure" {
     Data.Traversable.$fTraversable(,)_$csequenceA_closure:
         const Data.Traversable.$fTraversable(,)_$csequenceA_info;
 },
 sat_sbX3F_entry() //  [R1, R2]
         { info_tbl: [(cbXF2,
                       label: sat_sbX3F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXF2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbXF6; else goto cbXF5;
       cbXF6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXF5: // global
           _sbX3C::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbX3C::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbXF7,
                       label: Data.Traversable.$fTraversable(,)_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXF7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXF9; else goto cbXFa;
       cbXF9: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXFa: // global
           I64[Sp - 16] = block_cbXER_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubXFi; else goto cbXES;
       ubXFi: // global
           call _cbXER(R1) args: 0, res: 0, upd: 0;
       cbXES: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXER() //  [R1]
         { info_tbl: [(cbXER,
                       label: block_cbXER_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXER: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbXFd; else goto cbXFc;
       cbXFd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXFc: // global
           _sbX3C::P64 = P64[R1 + 7];
           _sbX3D::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sbX3F_info;
           P64[Hp] = _sbX3C::P64;
           I64[Sp - 8] = block_cbXF8_info;
           R2 = P64[Sp + 8];
           P64[Sp] = _sbX3D::P64;
           P64[Sp + 8] = Hp - 7;
           Sp = Sp - 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXF8() //  [R1]
         { info_tbl: [(cbXF8,
                       label: block_cbXF8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXF8: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _sbX3D::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sbX3D::P64;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.045074322 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$cmapM_closure" {
     Data.Traversable.$fTraversable(,)_$cmapM_closure:
         const Data.Traversable.$fTraversable(,)_$cmapM_info;
 },
 sat_sbX3O_entry() //  [R1, R2]
         { info_tbl: [(cbXFz,
                       label: sat_sbX3O_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXFz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbXFD; else goto cbXFC;
       cbXFD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXFC: // global
           _sbX3K::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbX3K::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXFE,
                       label: Data.Traversable.$fTraversable(,)_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXFE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXFK; else goto cbXFL;
       cbXFK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXFL: // global
           I64[Sp - 24] = block_cbXFn_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubXFU; else goto cbXFo;
       ubXFU: // global
           call _cbXFn(R1) args: 0, res: 0, upd: 0;
       cbXFo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXFn() //  [R1]
         { info_tbl: [(cbXFn,
                       label: block_cbXFn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXFn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXFO; else goto cbXFN;
       cbXFO: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXFN: // global
           _sbX3K::P64 = P64[R1 + 7];
           _sbX3L::P64 = P64[R1 + 15];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbX3L::P64;
           I64[Hp - 8] = sat_sbX3O_info;
           P64[Hp] = _sbX3K::P64;
           I64[Sp] = block_cbXFF_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 7;
           P64[Sp + 16] = Hp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXFF() //  [R1]
         { info_tbl: [(cbXFF,
                       label: block_cbXFF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXFF: // global
           I64[Sp] = block_cbXFJ_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXFJ() //  [R1]
         { info_tbl: [(cbXFJ,
                       label: block_cbXFJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXFJ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.04725899 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$csequence_closure" {
     Data.Traversable.$fTraversable(,)_$csequence_closure:
         const Data.Traversable.$fTraversable(,)_$csequence_info;
 },
 sat_sbX3X_entry() //  [R1, R2]
         { info_tbl: [(cbXGa,
                       label: sat_sbX3X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXGa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbXGe; else goto cbXGd;
       cbXGe: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXGd: // global
           _sbX3T::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbX3T::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXGf,
                       label: Data.Traversable.$fTraversable(,)_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXGf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXGl; else goto cbXGm;
       cbXGl: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXGm: // global
           I64[Sp - 16] = block_cbXFZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubXGv; else goto cbXG0;
       ubXGv: // global
           call _cbXFZ(R1) args: 0, res: 0, upd: 0;
       cbXG0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXFZ() //  [R1]
         { info_tbl: [(cbXFZ,
                       label: block_cbXFZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXFZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbXGp; else goto cbXGo;
       cbXGp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXGo: // global
           _sbX3T::P64 = P64[R1 + 7];
           _sbX3U::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sbX3X_info;
           P64[Hp] = _sbX3T::P64;
           I64[Sp - 8] = block_cbXGg_info;
           R2 = P64[Sp + 8];
           P64[Sp] = _sbX3U::P64;
           P64[Sp + 8] = Hp - 7;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXGg() //  [R1]
         { info_tbl: [(cbXGg,
                       label: block_cbXGg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXGg: // global
           I64[Sp] = block_cbXGk_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXGk() //  [R1]
         { info_tbl: [(cbXGk,
                       label: block_cbXGk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXGk: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _sbX3U::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sbX3U::P64;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.048826905 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_closure" {
     Data.Traversable.$fTraversable(,)_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctor(,)_closure;
         const Data.Foldable.$fFoldable(,)_closure;
         const Data.Traversable.$fTraversable(,)_$ctraverse_closure+3;
         const Data.Traversable.$fTraversable(,)_$csequenceA_closure+2;
         const Data.Traversable.$fTraversable(,)_$cmapM_closure+3;
         const Data.Traversable.$fTraversable(,)_$csequence_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.049750045 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$csequenceA_closure" {
     Data.Traversable.$fTraversableEither_$csequenceA_closure:
         const Data.Traversable.$fTraversableEither_$csequenceA_info;
 },
 Data.Traversable.$fTraversableEither_$csequenceA_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cbXGH,
                       label: Data.Traversable.$fTraversableEither_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXGH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXGI; else goto cbXGJ;
       cbXGI: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXGJ: // global
           I64[Sp - 16] = block_cbXGA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubXGV; else goto cbXGB;
       ubXGV: // global
           call _cbXGA(R1) args: 0, res: 0, upd: 0;
       cbXGB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXGA() //  [R1]
         { info_tbl: [(cbXGA,
                       label: block_cbXGA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXGA: // global
           _sbX3Y::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbXGE; else goto cbXGF;
       cbXGE: // global
           R2 = _sbX3Y::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cbXGF: // global
           I64[Sp] = block_cbXGP_info;
           R2 = _sbX3Y::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXGP() //  [R1]
         { info_tbl: [(cbXGP,
                       label: block_cbXGP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXGP: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.051091476 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$cmapM_closure" {
     Data.Traversable.$fTraversableEither_$cmapM_closure:
         const Data.Traversable.$fTraversableEither_$cmapM_info;
 },
 Data.Traversable.$fTraversableEither_$cmapM_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbXH2,
                       label: Data.Traversable.$fTraversableEither_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXH2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXH3; else goto cbXH4;
       cbXH3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXH4: // global
           I64[Sp - 24] = block_cbXH0_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXH0() //  [R1]
         { info_tbl: [(cbXH0,
                       label: block_cbXH0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXH0: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableEither_$ctraverse_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.052391551 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$csequence_closure" {
     Data.Traversable.$fTraversableEither_$csequence_closure:
         const Data.Traversable.$fTraversableEither_$csequence_info;
 },
 Data.Traversable.$fTraversableEither_$csequence_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbXHj,
                       label: Data.Traversable.$fTraversableEither_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXHj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXHk; else goto cbXHl;
       cbXHk: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXHl: // global
           I64[Sp - 16] = block_cbXHc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubXHH; else goto cbXHd;
       ubXHH: // global
           call _cbXHc(R1) args: 0, res: 0, upd: 0;
       cbXHd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXHc() //  [R1]
         { info_tbl: [(cbXHc,
                       label: block_cbXHc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXHc: // global
           _sbX49::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbXHg; else goto cbXHh;
       cbXHg: // global
           I64[Sp] = block_cbXHo_info;
           R2 = _sbX49::P64;
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
       cbXHh: // global
           I64[Sp] = block_cbXHw_info;
           R2 = _sbX49::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXHo() //  [R1]
         { info_tbl: [(cbXHo,
                       label: block_cbXHo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXHo: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 _cbXHw() //  [R1]
         { info_tbl: [(cbXHw,
                       label: block_cbXHw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXHw: // global
           I64[Sp] = block_cbXHA_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXHA() //  [R1]
         { info_tbl: [(cbXHA,
                       label: block_cbXHA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXHA: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.053824192 UTC

[section ""data" . Data.Traversable.$fTraversableEither_closure" {
     Data.Traversable.$fTraversableEither_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Either.$fFunctorEither_closure;
         const Data.Foldable.$fFoldableEither_closure;
         const Data.Traversable.$fTraversableEither_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableEither_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableEither_$cmapM_closure+3;
         const Data.Traversable.$fTraversableEither_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.055071278 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$csequenceA_closure" {
     Data.Traversable.$fTraversable[]_$csequenceA_closure:
         const Data.Traversable.$fTraversable[]_$csequenceA_info;
 },
 z_sbX4j_entry() //  [R1]
         { info_tbl: [(cbXHQ,
                       label: z_sbX4j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXHQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXHR; else goto cbXHS;
       cbXHR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXHS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX4k_entry() //  [R1, R2]
         { info_tbl: [(cbXI5,
                       label: go_sbX4k_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXI5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXI6; else goto cbXI7;
       cbXI6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXI7: // global
           I64[Sp - 32] = block_cbXHY_info;
           _sbX4k::P64 = R1;
           _sbX4i::P64 = P64[R1 + 7];
           _sbX4j::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sbX4i::P64;
           P64[Sp - 16] = _sbX4j::P64;
           P64[Sp - 8] = _sbX4k::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubXIh; else goto cbXHZ;
       ubXIh: // global
           call _cbXHY(R1) args: 0, res: 0, upd: 0;
       cbXHZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXHY() //  [R1]
         { info_tbl: [(cbXHY,
                       label: block_cbXHY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXHY: // global
           if (R1 & 7 == 1) goto cbXI2; else goto cbXI3;
       cbXI2: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbXI3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXIf; else goto cbXIe;
       cbXIf: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXIe: // global
           _sbX4n::P64 = P64[R1 + 6];
           _sbX4o::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sbX4o::P64;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 16] = _sbX4n::P64;
           P64[Sp + 24] = Hp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$csequenceA_entry() //  [R2]
         { info_tbl: [(cbXIi,
                       label: Data.Traversable.$fTraversable[]_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXIi: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXIm; else goto cbXIl;
       cbXIm: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$csequenceA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXIl: // global
           I64[Hp - 40] = z_sbX4j_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_sbX4k_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.057808131 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$cmapM_closure" {
     Data.Traversable.$fTraversable[]_$cmapM_closure:
         const Data.Traversable.$fTraversable[]_$cmapM_info;
 },
 $dApplicative_sbX4s_entry() //  [R1]
         { info_tbl: [(cbXIv,
                       label: $dApplicative_sbX4s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXIv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXIw; else goto cbXIx;
       cbXIw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXIx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_sbX4t_entry() //  [R1]
         { info_tbl: [(cbXIC,
                       label: z_sbX4t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXIC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXID; else goto cbXIE;
       cbXID: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXIE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX4u_entry() //  [R1, R2]
         { info_tbl: [(cbXIR,
                       label: go_sbX4u_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXIR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXIS; else goto cbXIT;
       cbXIS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXIT: // global
           I64[Sp - 40] = block_cbXIK_info;
           _sbX4u::P64 = R1;
           _sbX4r::P64 = P64[R1 + 7];
           _sbX4s::P64 = P64[R1 + 15];
           _sbX4t::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sbX4r::P64;
           P64[Sp - 24] = _sbX4s::P64;
           P64[Sp - 16] = _sbX4t::P64;
           P64[Sp - 8] = _sbX4u::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubXJ4; else goto cbXIL;
       ubXJ4: // global
           call _cbXIK(R1) args: 0, res: 0, upd: 0;
       cbXIL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXIK() //  [R1]
         { info_tbl: [(cbXIK,
                       label: block_cbXIK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXIK: // global
           if (R1 & 7 == 1) goto cbXIO; else goto cbXIP;
       cbXIO: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbXIP: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbXJ1; else goto cbXJ0;
       cbXJ1: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXJ0: // global
           _sbX4x::P64 = P64[R1 + 6];
           _sbX4y::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sbX4y::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sbX4x::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$cmapM_entry() //  [R2, R3]
         { info_tbl: [(cbXJ5,
                       label: Data.Traversable.$fTraversable[]_$cmapM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXJ5: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbXJ9; else goto cbXJ8;
       cbXJ9: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$cmapM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXJ8: // global
           I64[Hp - 72] = $dApplicative_sbX4s_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = z_sbX4t_info;
           _cbXIr::P64 = Hp - 72;
           P64[Hp - 32] = _cbXIr::P64;
           I64[Hp - 24] = go_sbX4u_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cbXIr::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.060619188 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$csequence_closure" {
     Data.Traversable.$fTraversable[]_$csequence_closure:
         const Data.Traversable.$fTraversable[]_$csequence_info;
 },
 $dApplicative_sbX4C_entry() //  [R1]
         { info_tbl: [(cbXJi,
                       label: $dApplicative_sbX4C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXJi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXJj; else goto cbXJk;
       cbXJj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXJk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_sbX4D_entry() //  [R1]
         { info_tbl: [(cbXJp,
                       label: z_sbX4D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXJp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXJq; else goto cbXJr;
       cbXJq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXJr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX4E_entry() //  [R1, R2]
         { info_tbl: [(cbXJE,
                       label: go_sbX4E_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXJE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXJF; else goto cbXJG;
       cbXJF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXJG: // global
           I64[Sp - 32] = block_cbXJx_info;
           _sbX4E::P64 = R1;
           _sbX4C::P64 = P64[R1 + 7];
           _sbX4D::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sbX4C::P64;
           P64[Sp - 16] = _sbX4D::P64;
           P64[Sp - 8] = _sbX4E::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubXJQ; else goto cbXJy;
       ubXJQ: // global
           call _cbXJx(R1) args: 0, res: 0, upd: 0;
       cbXJy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXJx() //  [R1]
         { info_tbl: [(cbXJx,
                       label: block_cbXJx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXJx: // global
           if (R1 & 7 == 1) goto cbXJB; else goto cbXJC;
       cbXJB: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbXJC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXJO; else goto cbXJN;
       cbXJO: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXJN: // global
           _sbX4H::P64 = P64[R1 + 6];
           _sbX4I::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sbX4I::P64;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 16] = _sbX4H::P64;
           P64[Sp + 24] = Hp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$csequence_entry() //  [R2]
         { info_tbl: [(cbXJR,
                       label: Data.Traversable.$fTraversable[]_$csequence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXJR: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbXJV; else goto cbXJU;
       cbXJV: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$csequence_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXJU: // global
           I64[Hp - 64] = $dApplicative_sbX4C_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = z_sbX4D_info;
           _cbXJe::P64 = Hp - 64;
           P64[Hp - 24] = _cbXJe::P64;
           I64[Hp - 16] = go_sbX4E_info;
           P64[Hp - 8] = _cbXJe::P64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.062597099 UTC

[section ""data" . Data.Traversable.$fTraversable[]_closure" {
     Data.Traversable.$fTraversable[]_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctor[]_closure;
         const Data.Foldable.$fFoldable[]_closure;
         const Data.Traversable.$fTraversable[]_$ctraverse_closure+2;
         const Data.Traversable.$fTraversable[]_$csequenceA_closure+1;
         const Data.Traversable.$fTraversable[]_$cmapM_closure+2;
         const Data.Traversable.$fTraversable[]_$csequence_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.063351677 UTC

[section ""data" . Data.Traversable.$fTraversableZipList1_closure" {
     Data.Traversable.$fTraversableZipList1_closure:
         const Data.Traversable.$fTraversableZipList1_info;
 },
 Data.Traversable.$fTraversableZipList1_entry() //  [R2]
         { info_tbl: [(cbXK0,
                       label: Data.Traversable.$fTraversableZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXK0: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.064990609 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$ctraverse_closure" {
     Data.Traversable.$fTraversableZipList_$ctraverse_closure:
         const Data.Traversable.$fTraversableZipList_$ctraverse_info;
 },
 z_sbX4P_entry() //  [R1]
         { info_tbl: [(cbXKf,
                       label: z_sbX4P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXKf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXKg; else goto cbXKh;
       cbXKg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXKh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX4Q_entry() //  [R1, R2]
         { info_tbl: [(cbXKu,
                       label: go_sbX4Q_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXKu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXKv; else goto cbXKw;
       cbXKv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXKw: // global
           I64[Sp - 40] = block_cbXKn_info;
           _sbX4Q::P64 = R1;
           _sbX4L::P64 = P64[R1 + 7];
           _sbX4M::P64 = P64[R1 + 15];
           _sbX4P::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sbX4L::P64;
           P64[Sp - 24] = _sbX4M::P64;
           P64[Sp - 16] = _sbX4P::P64;
           P64[Sp - 8] = _sbX4Q::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubXKH; else goto cbXKo;
       ubXKH: // global
           call _cbXKn(R1) args: 0, res: 0, upd: 0;
       cbXKo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXKn() //  [R1]
         { info_tbl: [(cbXKn,
                       label: block_cbXKn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXKn: // global
           if (R1 & 7 == 1) goto cbXKr; else goto cbXKs;
       cbXKr: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbXKs: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbXKE; else goto cbXKD;
       cbXKE: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXKD: // global
           _sbX4T::P64 = P64[R1 + 6];
           _sbX4U::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sbX4U::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbX4T::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sbX4X_entry() //  [R1]
         { info_tbl: [(cbXKI,
                       label: sat_sbX4X_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXKI: // global
           _sbX4X::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbXKJ; else goto cbXKK;
       cbXKK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbXKM; else goto cbXKL;
       cbXKM: // global
           HpAlloc = 56;
           goto cbXKJ;
       cbXKJ: // global
           R1 = _sbX4X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXKL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbX4X::P64;
           _sbX4L::P64 = P64[_sbX4X::P64 + 16];
           _sbX4M::P64 = P64[_sbX4X::P64 + 24];
           _sbX4N::P64 = P64[_sbX4X::P64 + 32];
           I64[Hp - 48] = z_sbX4P_info;
           P64[Hp - 32] = _sbX4L::P64;
           I64[Hp - 24] = go_sbX4Q_info;
           P64[Hp - 16] = _sbX4L::P64;
           P64[Hp - 8] = _sbX4M::P64;
           P64[Hp] = Hp - 48;
           R2 = _sbX4N::P64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call go_sbX4Q_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableZipList_$ctraverse_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbXKP,
                       label: Data.Traversable.$fTraversableZipList_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXKP: // global
           _sbX4N::P64 = R4;
           _sbX4M::P64 = R3;
           _sbX4L::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXKQ; else goto cbXKR;
       cbXKR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbXKT; else goto cbXKS;
       cbXKT: // global
           HpAlloc = 40;
           goto cbXKQ;
       cbXKQ: // global
           R4 = _sbX4N::P64;
           R3 = _sbX4M::P64;
           R2 = _sbX4L::P64;
           R1 = Data.Traversable.$fTraversableZipList_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXKS: // global
           I64[Hp - 32] = sat_sbX4X_info;
           P64[Hp - 16] = _sbX4L::P64;
           P64[Hp - 8] = _sbX4M::P64;
           P64[Hp] = _sbX4N::P64;
           I64[Sp - 16] = block_cbXKN_info;
           R2 = _sbX4L::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXKN() //  [R1]
         { info_tbl: [(cbXKN,
                       label: block_cbXKN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXKN: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableZipList1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.067570862 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$csequenceA_closure" {
     Data.Traversable.$fTraversableZipList_$csequenceA_closure:
         const Data.Traversable.$fTraversableZipList_$csequenceA_info;
 },
 Data.Traversable.$fTraversableZipList_$csequenceA_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbXL1,
                       label: Data.Traversable.$fTraversableZipList_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXL1: // global
           R4 = R3;
           R3 = GHC.Base.id_closure+1;
           R2 = R2;
           call Data.Traversable.$fTraversableZipList_$ctraverse_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.068493859 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$cmapM_closure" {
     Data.Traversable.$fTraversableZipList_$cmapM_closure:
         const Data.Traversable.$fTraversableZipList_$cmapM_info;
 },
 Data.Traversable.$fTraversableZipList_$cmapM_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbXLa,
                       label: Data.Traversable.$fTraversableZipList_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXLa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXLb; else goto cbXLc;
       cbXLb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableZipList_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXLc: // global
           I64[Sp - 24] = block_cbXL8_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXL8() //  [R1]
         { info_tbl: [(cbXL8,
                       label: block_cbXL8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXL8: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableZipList_$ctraverse_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.069641883 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$csequence_closure" {
     Data.Traversable.$fTraversableZipList_$csequence_closure:
         const Data.Traversable.$fTraversableZipList_$csequence_info;
 },
 Data.Traversable.$fTraversableZipList_$csequence_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cbXLm,
                       label: Data.Traversable.$fTraversableZipList_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXLm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXLn; else goto cbXLo;
       cbXLn: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableZipList_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXLo: // global
           I64[Sp - 16] = block_cbXLk_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXLk() //  [R1]
         { info_tbl: [(cbXLk,
                       label: block_cbXLk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXLk: // global
           R4 = P64[Sp + 8];
           R3 = GHC.Base.id_closure+1;
           R2 = R1;
           Sp = Sp + 16;
           call Data.Traversable.$fTraversableZipList_$ctraverse_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.070603558 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_closure" {
     Data.Traversable.$fTraversableZipList_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Control.Applicative.$fFunctorZipList_closure;
         const Control.Applicative.$fFoldableZipList_closure;
         const Data.Traversable.$fTraversableZipList_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableZipList_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableZipList_$cmapM_closure+3;
         const Data.Traversable.$fTraversableZipList_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.072910992 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$ctraverse_closure" {
     Data.Traversable.$fTraversableArray_$ctraverse_closure:
         const Data.Traversable.$fTraversableArray_$ctraverse_info;
         const 0;
 },
 n_sbX5j_entry() //  [R1]
         { info_tbl: [(cbXLM,
                       label: n_sbX5j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXLM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXLN; else goto cbXLO;
       cbXLN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXLO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbX5t_entry() //  [R1]
         { info_tbl: [(cbXM6,
                       label: sat_sbX5t_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXM6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXM7; else goto cbXM8;
       cbXM7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXM8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _sbX5m::I64 = I64[R1 + 40];
           if (_sbX5m::I64 == I64[R1 + 32]) goto cbXM5; else goto cbXM4;
       cbXM5: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbXM4: // global
           R2 = _sbX5m::I64 + 1;
           R1 = P64[R1 + 24];
           Sp = Sp - 16;
           call go_sbX5l_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5p_entry() //  [R1]
         { info_tbl: [(cbXMj,
                       label: sat_sbX5p_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXMj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXMk; else goto cbXMl;
       cbXMk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXMl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = P64[P64[R1 + 16] + ((I64[R1 + 24] << 3) + 24)];
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5q_entry() //  [R1]
         { info_tbl: [(cbXMm,
                       label: sat_sbX5q_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXMm: // global
           _sbX5q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbXMn; else goto cbXMo;
       cbXMo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXMq; else goto cbXMp;
       cbXMq: // global
           HpAlloc = 32;
           goto cbXMn;
       cbXMn: // global
           R1 = _sbX5q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXMp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbX5q::P64;
           _sbX58::P64 = P64[_sbX5q::P64 + 16];
           _sbX5h::P64 = P64[_sbX5q::P64 + 24];
           _sbX5m::I64 = I64[_sbX5q::P64 + 32];
           I64[Hp - 24] = sat_sbX5p_info;
           P64[Hp - 8] = _sbX5h::P64;
           I64[Hp] = _sbX5m::I64;
           R2 = Hp - 24;
           R1 = _sbX58::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sbX5l_entry() //  [R1, R2]
         { info_tbl: [(cbXMr,
                       label: go_sbX5l_info
                       rep:HeapRep 4 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXMr: // global
           _sbX5m::I64 = R2;
           _sbX5l::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbXMs; else goto cbXMt;
       cbXMt: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbXMv; else goto cbXMu;
       cbXMv: // global
           HpAlloc = 88;
           goto cbXMs;
       cbXMs: // global
           R2 = _sbX5m::I64;
           R1 = _sbX5l::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXMu: // global
           _sbX57::P64 = P64[_sbX5l::P64 + 7];
           _sbX58::P64 = P64[_sbX5l::P64 + 15];
           _sbX5h::P64 = P64[_sbX5l::P64 + 23];
           _sbX5j::P64 = P64[_sbX5l::P64 + 31];
           _sbX5i::I64 = I64[_sbX5l::P64 + 39];
           I64[Hp - 80] = sat_sbX5t_info;
           P64[Hp - 64] = _sbX5j::P64;
           P64[Hp - 56] = _sbX5l::P64;
           I64[Hp - 48] = _sbX5i::I64;
           I64[Hp - 40] = _sbX5m::I64;
           I64[Hp - 32] = sat_sbX5q_info;
           P64[Hp - 16] = _sbX58::P64;
           P64[Hp - 8] = _sbX5h::P64;
           I64[Hp] = _sbX5m::I64;
           R2 = _sbX57::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = Hp - 80;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sbX5u_entry() //  [R1]
         { info_tbl: [(cbXMw,
                       label: sat_sbX5u_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXMw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXMx; else goto cbXMy;
       cbXMx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXMy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbXLA_info;
           _sbX57::P64 = P64[R1 + 16];
           _sbX58::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sbX57::P64;
           P64[Sp - 24] = _sbX58::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubXMF; else goto cbXLB;
       ubXMF: // global
           call _cbXLA(R1) args: 0, res: 0, upd: 0;
       cbXLB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbXLA() //  [R1]
         { info_tbl: [(cbXLA,
                       label: block_cbXLA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXLA: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbXMB; else goto cbXMA;
       cbXMB: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbXMA: // global
           _sbX5h::P64 = P64[R1 + 23];
           _sbX5i::I64 = I64[R1 + 31] - 1;
           I64[Hp - 64] = n_sbX5j_info;
           _sbX57::P64 = P64[Sp + 8];
           P64[Hp - 48] = _sbX57::P64;
           _cbXLI::P64 = Hp - 64;
           if (%MO_S_Le_W64(0, _sbX5i::I64)) goto cbXMD; else goto cbXME;
       cbXMD: // global
           I64[Hp - 40] = go_sbX5l_info;
           P64[Hp - 32] = _sbX57::P64;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbX5h::P64;
           P64[Hp - 8] = _cbXLI::P64;
           I64[Hp] = _sbX5i::I64;
           R2 = 0;
           R1 = Hp - 39;
           Sp = Sp + 24;
           call go_sbX5l_entry(R2, R1) args: 24, res: 0, upd: 24;
       cbXME: // global
           Hp = Hp - 48;
           R1 = _cbXLI::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5b_entry() //  [R1]
         { info_tbl: [(cbXMK,
                       label: sat_sbX5b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXMK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXML; else goto cbXMM;
       cbXML: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXMM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.bounds_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5c_entry() //  [R1, R2]
         { info_tbl: [(cbXMS,
                       label: sat_sbX5c_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXMS: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Arr.listArray_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversableArray_$ctraverse_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cbXMX,
                       label: Data.Traversable.$fTraversableArray_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXMX: // global
           _sbX59::P64 = R5;
           _sbX58::P64 = R4;
           _sbX57::P64 = R3;
           _sbX56::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXMY; else goto cbXMZ;
       cbXMZ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbXN1; else goto cbXN0;
       cbXN1: // global
           HpAlloc = 88;
           goto cbXMY;
       cbXMY: // global
           R5 = _sbX59::P64;
           R4 = _sbX58::P64;
           R3 = _sbX57::P64;
           R2 = _sbX56::P64;
           R1 = Data.Traversable.$fTraversableArray_$ctraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXN0: // global
           I64[Hp - 80] = sat_sbX5u_info;
           P64[Hp - 64] = _sbX57::P64;
           P64[Hp - 56] = _sbX58::P64;
           P64[Hp - 48] = _sbX59::P64;
           I64[Hp - 40] = sat_sbX5b_info;
           P64[Hp - 24] = _sbX59::P64;
           I64[Hp - 16] = sat_sbX5c_info;
           P64[Hp - 8] = _sbX56::P64;
           P64[Hp] = Hp - 40;
           I64[Sp - 24] = block_cbXMV_info;
           R2 = _sbX57::P64;
           P64[Sp - 16] = Hp - 80;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXMV() //  [R1]
         { info_tbl: [(cbXMV,
                       label: block_cbXMV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXMV: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbXLw::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbXLw::P64;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.077644772 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$csequenceA_closure" {
     Data.Traversable.$fTraversableArray_$csequenceA_closure:
         const Data.Traversable.$fTraversableArray_$csequenceA_info;
         const 0;
 },
 Data.Traversable.$fTraversableArray_$csequenceA_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cbXN9,
                       label: Data.Traversable.$fTraversableArray_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXN9: // global
           R5 = R4;
           R4 = GHC.Base.id_closure+1;
           R3 = R3;
           R2 = R2;
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.078581849 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$cmapM_closure" {
     Data.Traversable.$fTraversableArray_$cmapM_closure:
         const Data.Traversable.$fTraversableArray_$cmapM_info;
         const 0;
 },
 Data.Traversable.$fTraversableArray_$cmapM_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cbXNi,
                       label: Data.Traversable.$fTraversableArray_$cmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXNi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXNj; else goto cbXNk;
       cbXNj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableArray_$cmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXNk: // global
           I64[Sp - 32] = block_cbXNg_info;
           _sbX5x::P64 = R2;
           R2 = R3;
           P64[Sp - 24] = _sbX5x::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXNg() //  [R1]
         { info_tbl: [(cbXNg,
                       label: block_cbXNg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXNg: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.079841564 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$csequence_closure" {
     Data.Traversable.$fTraversableArray_$csequence_closure:
         const Data.Traversable.$fTraversableArray_$csequence_info;
         const 0;
 },
 Data.Traversable.$fTraversableArray_$csequence_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbXNu,
                       label: Data.Traversable.$fTraversableArray_$csequence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXNu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXNv; else goto cbXNw;
       cbXNv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableArray_$csequence_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXNw: // global
           I64[Sp - 24] = block_cbXNs_info;
           _sbX5C::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _sbX5C::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXNs() //  [R1]
         { info_tbl: [(cbXNs,
                       label: block_cbXNs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXNs: // global
           R5 = P64[Sp + 16];
           R4 = GHC.Base.id_closure+1;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.081526098 UTC

[section ""data" . Data.Traversable.$fTraversableArray_closure" {
     Data.Traversable.$fTraversableArray_closure:
         const Data.Traversable.$fTraversableArray_info;
         const 0;
 },
 sat_sbX5K_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXNJ,
                       label: sat_sbX5K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXNJ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableArray_$csequence_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX5J_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbXNR,
                       label: sat_sbX5J_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXNR: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableArray_$cmapM_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX5I_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXNZ,
                       label: sat_sbX5I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXNZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableArray_$csequenceA_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX5H_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbXO7,
                       label: sat_sbX5H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXO7: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversableArray_entry() //  [R2]
         { info_tbl: [(cbXOb,
                       label: Data.Traversable.$fTraversableArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXOb: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cbXOf; else goto cbXOe;
       cbXOf: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXOe: // global
           I64[Hp - 112] = sat_sbX5K_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbX5J_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbX5I_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbX5H_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = GHC.Arr.$fFunctorArray_closure;
           P64[Hp - 32] = Data.Foldable.$fFoldableArray_closure;
           P64[Hp - 24] = Hp - 61;
           P64[Hp - 16] = Hp - 78;
           P64[Hp - 8] = Hp - 93;
           P64[Hp] = Hp - 110;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.084378523 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure" {
     Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure:
         const Data.Traversable.$fTraversableNonEmpty_$ctraverse_info;
 },
 z_sbX5W_entry() //  [R1]
         { info_tbl: [(cbXOx,
                       label: z_sbX5W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXOx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXOy; else goto cbXOz;
       cbXOy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXOz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX5X_entry() //  [R1, R2]
         { info_tbl: [(cbXOM,
                       label: go_sbX5X_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXOM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXON; else goto cbXOO;
       cbXON: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXOO: // global
           I64[Sp - 40] = block_cbXOF_info;
           _sbX5X::P64 = R1;
           _sbX5L::P64 = P64[R1 + 7];
           _sbX5M::P64 = P64[R1 + 15];
           _sbX5W::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sbX5L::P64;
           P64[Sp - 24] = _sbX5M::P64;
           P64[Sp - 16] = _sbX5W::P64;
           P64[Sp - 8] = _sbX5X::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubXOZ; else goto cbXOG;
       ubXOZ: // global
           call _cbXOF(R1) args: 0, res: 0, upd: 0;
       cbXOG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXOF() //  [R1]
         { info_tbl: [(cbXOF,
                       label: block_cbXOF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXOF: // global
           if (R1 & 7 == 1) goto cbXOJ; else goto cbXOK;
       cbXOJ: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbXOK: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbXOW; else goto cbXOV;
       cbXOW: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXOV: // global
           _sbX60::P64 = P64[R1 + 6];
           _sbX61::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sbX61::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbX60::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sbX64_entry() //  [R1]
         { info_tbl: [(cbXP0,
                       label: sat_sbX64_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXP0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXP1; else goto cbXP2;
       cbXP1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXP2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbXOo_info;
           _sbX5L::P64 = P64[R1 + 16];
           _sbX5M::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sbX5L::P64;
           P64[Sp - 24] = _sbX5M::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubXP6; else goto cbXOp;
       ubXP6: // global
           call _cbXOo(R1) args: 0, res: 0, upd: 0;
       cbXOp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbXOo() //  [R1]
         { info_tbl: [(cbXOo,
                       label: block_cbXOo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXOo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbXP5; else goto cbXP4;
       cbXP5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbXP4: // global
           _sbX5V::P64 = P64[R1 + 15];
           I64[Hp - 48] = z_sbX5W_info;
           _sbX5L::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sbX5L::P64;
           I64[Hp - 24] = go_sbX5X_info;
           P64[Hp - 16] = _sbX5L::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R2 = _sbX5V::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call go_sbX5X_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5S_entry() //  [R1]
         { info_tbl: [(cbXPc,
                       label: sat_sbX5S_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXPc: // global
           _sbX5S::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbXPd; else goto cbXPe;
       cbXPe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbXPg; else goto cbXPf;
       cbXPg: // global
           HpAlloc = 24;
           goto cbXPd;
       cbXPd: // global
           R1 = _sbX5S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXPf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbX5S::P64;
           _sbX5M::P64 = P64[_sbX5S::P64 + 16];
           _sbX5N::P64 = P64[_sbX5S::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbX5N::P64;
           R2 = Hp - 16;
           R1 = _sbX5M::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cbXPh,
                       label: Data.Traversable.$fTraversableNonEmpty_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXPh: // global
           _sbX5N::P64 = R4;
           _sbX5M::P64 = R3;
           _sbX5L::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cbXPi; else goto cbXPj;
       cbXPj: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbXPl; else goto cbXPk;
       cbXPl: // global
           HpAlloc = 72;
           goto cbXPi;
       cbXPi: // global
           R4 = _sbX5N::P64;
           R3 = _sbX5M::P64;
           R2 = _sbX5L::P64;
           R1 = Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXPk: // global
           I64[Hp - 64] = sat_sbX64_info;
           P64[Hp - 48] = _sbX5L::P64;
           P64[Hp - 40] = _sbX5M::P64;
           P64[Hp - 32] = _sbX5N::P64;
           I64[Hp - 24] = sat_sbX5S_info;
           P64[Hp - 8] = _sbX5M::P64;
           P64[Hp] = _sbX5N::P64;
           R2 = _sbX5L::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Base.:|_closure+2;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.087664848 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$csequenceA_closure" {
     Data.Traversable.$fTraversableNonEmpty_$csequenceA_closure:
         const Data.Traversable.$fTraversableNonEmpty_$csequenceA_info;
 },
 Data.Traversable.$fTraversableNonEmpty_$csequenceA_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cbXPq,
                       label: Data.Traversable.$fTraversableNonEmpty_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXPq: // global
           R4 = R3;
           R3 = GHC.Base.id_closure+1;
           R2 = R2;
           call Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.088518566 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$cmapM_closure" {
     Data.Traversable.$fTraversableNonEmpty_$cmapM_closure:
         const Data.Traversable.$fTraversableNonEmpty_$cmapM_info;
 },
 Data.Traversable.$fTraversableNonEmpty_$cmapM_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbXPz,
                       label: Data.Traversable.$fTraversableNonEmpty_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXPz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXPA; else goto cbXPB;
       cbXPA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableNonEmpty_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXPB: // global
           I64[Sp - 24] = block_cbXPx_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXPx() //  [R1]
         { info_tbl: [(cbXPx,
                       label: block_cbXPx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXPx: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.089692886 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$csequence_closure" {
     Data.Traversable.$fTraversableNonEmpty_$csequence_closure:
         const Data.Traversable.$fTraversableNonEmpty_$csequence_info;
 },
 Data.Traversable.$fTraversableNonEmpty_$csequence_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbXPL,
                       label: Data.Traversable.$fTraversableNonEmpty_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXPL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXPM; else goto cbXPN;
       cbXPM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableNonEmpty_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXPN: // global
           I64[Sp - 16] = block_cbXPJ_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXPJ() //  [R1]
         { info_tbl: [(cbXPJ,
                       label: block_cbXPJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXPJ: // global
           R4 = P64[Sp + 8];
           R3 = GHC.Base.id_closure+1;
           R2 = R1;
           Sp = Sp + 16;
           call Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.090665823 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_closure" {
     Data.Traversable.$fTraversableNonEmpty_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctorNonEmpty_closure;
         const Data.Foldable.$fFoldableNonEmpty_closure;
         const Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableNonEmpty_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableNonEmpty_$cmapM_closure+3;
         const Data.Traversable.$fTraversableNonEmpty_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.091594202 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_$csequenceA_closure" {
     Data.Traversable.$fTraversableMaybe_$csequenceA_closure:
         const Data.Traversable.$fTraversableMaybe_$csequenceA_info;
 },
 Data.Traversable.$fTraversableMaybe_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbXQ2,
                       label: Data.Traversable.$fTraversableMaybe_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXQ2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXQ3; else goto cbXQ4;
       cbXQ3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableMaybe_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXQ4: // global
           I64[Sp - 16] = block_cbXPV_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubXQg; else goto cbXPW;
       ubXQg: // global
           call _cbXPV(R1) args: 0, res: 0, upd: 0;
       cbXPW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXPV() //  [R1]
         { info_tbl: [(cbXPV,
                       label: block_cbXPV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXPV: // global
           _sbX6d::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbXPZ; else goto cbXQ0;
       cbXPZ: // global
           R2 = _sbX6d::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cbXQ0: // global
           I64[Sp] = block_cbXQa_info;
           R2 = _sbX6d::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXQa() //  [R1]
         { info_tbl: [(cbXQa,
                       label: block_cbXQa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXQa: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.092982325 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_$cmapM_closure" {
     Data.Traversable.$fTraversableMaybe_$cmapM_closure:
         const Data.Traversable.$fTraversableMaybe_$cmapM_info;
 },
 Data.Traversable.$fTraversableMaybe_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXQn,
                       label: Data.Traversable.$fTraversableMaybe_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXQn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXQo; else goto cbXQp;
       cbXQo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableMaybe_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXQp: // global
           I64[Sp - 24] = block_cbXQl_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXQl() //  [R1]
         { info_tbl: [(cbXQl,
                       label: block_cbXQl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXQl: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.094313565 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_$csequence_closure" {
     Data.Traversable.$fTraversableMaybe_$csequence_closure:
         const Data.Traversable.$fTraversableMaybe_$csequence_info;
 },
 Data.Traversable.$fTraversableMaybe_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXQE,
                       label: Data.Traversable.$fTraversableMaybe_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXQE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXQF; else goto cbXQG;
       cbXQF: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableMaybe_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXQG: // global
           I64[Sp - 16] = block_cbXQx_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubXR2; else goto cbXQy;
       ubXR2: // global
           call _cbXQx(R1) args: 0, res: 0, upd: 0;
       cbXQy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXQx() //  [R1]
         { info_tbl: [(cbXQx,
                       label: block_cbXQx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXQx: // global
           _sbX6m::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbXQB; else goto cbXQC;
       cbXQB: // global
           I64[Sp + 8] = block_cbXQJ_info;
           R2 = _sbX6m::P64;
           Sp = Sp + 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
       cbXQC: // global
           I64[Sp] = block_cbXQR_info;
           R2 = _sbX6m::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXQJ() //  [R1]
         { info_tbl: [(cbXQJ,
                       label: block_cbXQJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXQJ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 _cbXQR() //  [R1]
         { info_tbl: [(cbXQR,
                       label: block_cbXQR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXQR: // global
           I64[Sp] = block_cbXQV_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXQV() //  [R1]
         { info_tbl: [(cbXQV,
                       label: block_cbXQV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXQV: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.095718208 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_closure" {
     Data.Traversable.$fTraversableMaybe_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctorMaybe_closure;
         const Data.Foldable.$fFoldableMaybe_closure;
         const Data.Traversable.$fTraversableFirst_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableMaybe_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableMaybe_$cmapM_closure+3;
         const Data.Traversable.$fTraversableMaybe_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.096391153 UTC

[section ""data" . Data.Traversable.$fTraversableFirst1_closure" {
     Data.Traversable.$fTraversableFirst1_closure:
         const Data.Traversable.$fTraversableFirst1_info;
 },
 Data.Traversable.$fTraversableFirst1_entry() //  [R2]
         { info_tbl: [(cbXR7,
                       label: Data.Traversable.$fTraversableFirst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXR7: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.097575302 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$ctraverse_closure" {
     Data.Traversable.$fTraversableLast_$ctraverse_closure:
         const Data.Traversable.$fTraversableLast_$ctraverse_info;
 },
 sat_sbX6y_entry() //  [R1]
         { info_tbl: [(cbXRi,
                       label: sat_sbX6y_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXRi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXRj; else goto cbXRk;
       cbXRj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXRk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbXRn,
                       label: Data.Traversable.$fTraversableLast_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXRn: // global
           _sbX6w::P64 = R4;
           _sbX6v::P64 = R3;
           _sbX6u::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXRo; else goto cbXRp;
       cbXRp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbXRr; else goto cbXRq;
       cbXRr: // global
           HpAlloc = 40;
           goto cbXRo;
       cbXRo: // global
           R4 = _sbX6w::P64;
           R3 = _sbX6v::P64;
           R2 = _sbX6u::P64;
           R1 = Data.Traversable.$fTraversableLast_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXRq: // global
           I64[Hp - 32] = sat_sbX6y_info;
           P64[Hp - 16] = _sbX6u::P64;
           P64[Hp - 8] = _sbX6v::P64;
           P64[Hp] = _sbX6w::P64;
           I64[Sp - 16] = block_cbXRl_info;
           R2 = _sbX6u::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXRl() //  [R1]
         { info_tbl: [(cbXRl,
                       label: block_cbXRl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXRl: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.099418892 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$csequenceA_closure" {
     Data.Traversable.$fTraversableLast_$csequenceA_closure:
         const Data.Traversable.$fTraversableLast_$csequenceA_info;
 },
 sat_sbX6F_entry() //  [R1]
         { info_tbl: [(cbXRK,
                       label: sat_sbX6F_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXRK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXRL; else goto cbXRM;
       cbXRL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXRM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbXRD_info;
           _sbX6z::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbX6z::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubXRY; else goto cbXRE;
       ubXRY: // global
           call _cbXRD(R1) args: 0, res: 0, upd: 0;
       cbXRE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbXRD() //  [R1]
         { info_tbl: [(cbXRD,
                       label: block_cbXRD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXRD: // global
           _sbX6z::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbXRH; else goto cbXRI;
       cbXRH: // global
           R2 = _sbX6z::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cbXRI: // global
           I64[Sp] = block_cbXRS_info;
           R2 = _sbX6z::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbXRS() //  [R1]
         { info_tbl: [(cbXRS,
                       label: block_cbXRS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXRS: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbXS1,
                       label: Data.Traversable.$fTraversableLast_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXS1: // global
           _sbX6A::P64 = R3;
           _sbX6z::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXS2; else goto cbXS3;
       cbXS3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXS5; else goto cbXS4;
       cbXS5: // global
           HpAlloc = 32;
           goto cbXS2;
       cbXS2: // global
           R3 = _sbX6A::P64;
           R2 = _sbX6z::P64;
           R1 = Data.Traversable.$fTraversableLast_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXS4: // global
           I64[Hp - 24] = sat_sbX6F_info;
           P64[Hp - 8] = _sbX6z::P64;
           P64[Hp] = _sbX6A::P64;
           I64[Sp - 16] = block_cbXRZ_info;
           R2 = _sbX6z::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXRZ() //  [R1]
         { info_tbl: [(cbXRZ,
                       label: block_cbXRZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXRZ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.101571031 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$cmapM_closure" {
     Data.Traversable.$fTraversableLast_$cmapM_closure:
         const Data.Traversable.$fTraversableLast_$cmapM_info;
 },
 sat_sbX6L_entry() //  [R1]
         { info_tbl: [(cbXSl,
                       label: sat_sbX6L_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXSl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXSm; else goto cbXSn;
       cbXSm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXSn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXSo,
                       label: Data.Traversable.$fTraversableLast_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXSo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXSq; else goto cbXSr;
       cbXSq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableLast_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXSr: // global
           I64[Sp - 24] = block_cbXSd_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXSd() //  [R1]
         { info_tbl: [(cbXSd,
                       label: block_cbXSd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXSd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbXSu; else goto cbXSt;
       cbXSu: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXSt: // global
           I64[Hp - 32] = sat_sbX6L_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbXSp_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXSp() //  [R1]
         { info_tbl: [(cbXSp,
                       label: block_cbXSp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXSp: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.103676241 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$csequence_closure" {
     Data.Traversable.$fTraversableLast_$csequence_closure:
         const Data.Traversable.$fTraversableLast_$csequence_info;
 },
 sat_sbX6T_entry() //  [R1]
         { info_tbl: [(cbXSS,
                       label: sat_sbX6T_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXSS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXST; else goto cbXSU;
       cbXST: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXSU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbXSL_info;
           _sbX6O::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbX6O::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubXT6; else goto cbXSM;
       ubXT6: // global
           call _cbXSL(R1) args: 0, res: 0, upd: 0;
       cbXSM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbXSL() //  [R1]
         { info_tbl: [(cbXSL,
                       label: block_cbXSL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXSL: // global
           _sbX6O::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbXSP; else goto cbXSQ;
       cbXSP: // global
           R2 = _sbX6O::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cbXSQ: // global
           I64[Sp] = block_cbXT0_info;
           R2 = _sbX6O::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbXT0() //  [R1]
         { info_tbl: [(cbXT0,
                       label: block_cbXT0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXT0: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXT7,
                       label: Data.Traversable.$fTraversableLast_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXT7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXT9; else goto cbXTa;
       cbXT9: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableLast_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXTa: // global
           I64[Sp - 16] = block_cbXSD_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXSD() //  [R1]
         { info_tbl: [(cbXSD,
                       label: block_cbXSD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXSD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXTd; else goto cbXTc;
       cbXTd: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXTc: // global
           I64[Hp - 24] = sat_sbX6T_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_cbXT8_info;
           R2 = R1;
           P64[Sp + 8] = Hp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXT8() //  [R1]
         { info_tbl: [(cbXT8,
                       label: block_cbXT8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXT8: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.107587992 UTC

[section ""data" . Data.Traversable.$fTraversableLast_closure" {
     Data.Traversable.$fTraversableLast_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Monoid.$fFunctorLast_closure;
         const Data.Foldable.$fFoldableLast_closure;
         const Data.Traversable.$fTraversableLast_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableLast_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableLast_$cmapM_closure+3;
         const Data.Traversable.$fTraversableLast_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.108508115 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$ctraverse1_closure" {
     Data.Traversable.$fTraversableFirst_$ctraverse1_closure:
         const Data.Traversable.$fTraversableFirst_$ctraverse1_info;
 },
 sat_sbX6Y_entry() //  [R1]
         { info_tbl: [(cbXTq,
                       label: sat_sbX6Y_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXTq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXTr; else goto cbXTs;
       cbXTr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXTs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$ctraverse1_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cbXTv,
                       label: Data.Traversable.$fTraversableFirst_$ctraverse1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXTv: // global
           _sbX6W::P64 = R4;
           _sbX6V::P64 = R3;
           _sbX6U::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXTw; else goto cbXTx;
       cbXTx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbXTz; else goto cbXTy;
       cbXTz: // global
           HpAlloc = 40;
           goto cbXTw;
       cbXTw: // global
           R4 = _sbX6W::P64;
           R3 = _sbX6V::P64;
           R2 = _sbX6U::P64;
           R1 = Data.Traversable.$fTraversableFirst_$ctraverse1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXTy: // global
           I64[Hp - 32] = sat_sbX6Y_info;
           P64[Hp - 16] = _sbX6U::P64;
           P64[Hp - 8] = _sbX6V::P64;
           P64[Hp] = _sbX6W::P64;
           I64[Sp - 16] = block_cbXTt_info;
           R2 = _sbX6U::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXTt() //  [R1]
         { info_tbl: [(cbXTt,
                       label: block_cbXTt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXTt: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.110576422 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$csequenceA_closure" {
     Data.Traversable.$fTraversableFirst_$csequenceA_closure:
         const Data.Traversable.$fTraversableFirst_$csequenceA_info;
 },
 sat_sbX75_entry() //  [R1]
         { info_tbl: [(cbXTS,
                       label: sat_sbX75_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXTS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXTT; else goto cbXTU;
       cbXTT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXTU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbXTL_info;
           _sbX6Z::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbX6Z::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubXU6; else goto cbXTM;
       ubXU6: // global
           call _cbXTL(R1) args: 0, res: 0, upd: 0;
       cbXTM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbXTL() //  [R1]
         { info_tbl: [(cbXTL,
                       label: block_cbXTL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXTL: // global
           _sbX6Z::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbXTP; else goto cbXTQ;
       cbXTP: // global
           R2 = _sbX6Z::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cbXTQ: // global
           I64[Sp] = block_cbXU0_info;
           R2 = _sbX6Z::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbXU0() //  [R1]
         { info_tbl: [(cbXU0,
                       label: block_cbXU0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXU0: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbXU9,
                       label: Data.Traversable.$fTraversableFirst_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXU9: // global
           _sbX70::P64 = R3;
           _sbX6Z::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbXUa; else goto cbXUb;
       cbXUb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXUd; else goto cbXUc;
       cbXUd: // global
           HpAlloc = 32;
           goto cbXUa;
       cbXUa: // global
           R3 = _sbX70::P64;
           R2 = _sbX6Z::P64;
           R1 = Data.Traversable.$fTraversableFirst_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXUc: // global
           I64[Hp - 24] = sat_sbX75_info;
           P64[Hp - 8] = _sbX6Z::P64;
           P64[Hp] = _sbX70::P64;
           I64[Sp - 16] = block_cbXU7_info;
           R2 = _sbX6Z::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXU7() //  [R1]
         { info_tbl: [(cbXU7,
                       label: block_cbXU7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXU7: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.112659219 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$cmapM_closure" {
     Data.Traversable.$fTraversableFirst_$cmapM_closure:
         const Data.Traversable.$fTraversableFirst_$cmapM_info;
 },
 sat_sbX7b_entry() //  [R1]
         { info_tbl: [(cbXUt,
                       label: sat_sbX7b_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXUt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXUu; else goto cbXUv;
       cbXUu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXUv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXUw,
                       label: Data.Traversable.$fTraversableFirst_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXUw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXUy; else goto cbXUz;
       cbXUy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableFirst_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXUz: // global
           I64[Sp - 24] = block_cbXUl_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXUl() //  [R1]
         { info_tbl: [(cbXUl,
                       label: block_cbXUl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXUl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbXUC; else goto cbXUB;
       cbXUC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXUB: // global
           I64[Hp - 32] = sat_sbX7b_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbXUx_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXUx() //  [R1]
         { info_tbl: [(cbXUx,
                       label: block_cbXUx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXUx: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.114735838 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$csequence_closure" {
     Data.Traversable.$fTraversableFirst_$csequence_closure:
         const Data.Traversable.$fTraversableFirst_$csequence_info;
 },
 sat_sbX7j_entry() //  [R1]
         { info_tbl: [(cbXV0,
                       label: sat_sbX7j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXV0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbXV1; else goto cbXV2;
       cbXV1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXV2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbXUT_info;
           _sbX7e::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbX7e::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubXVe; else goto cbXUU;
       ubXVe: // global
           call _cbXUT(R1) args: 0, res: 0, upd: 0;
       cbXUU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbXUT() //  [R1]
         { info_tbl: [(cbXUT,
                       label: block_cbXUT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXUT: // global
           _sbX7e::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbXUX; else goto cbXUY;
       cbXUX: // global
           R2 = _sbX7e::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cbXUY: // global
           I64[Sp] = block_cbXV8_info;
           R2 = _sbX7e::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbXV8() //  [R1]
         { info_tbl: [(cbXV8,
                       label: block_cbXV8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXV8: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbXVf,
                       label: Data.Traversable.$fTraversableFirst_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXVf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXVh; else goto cbXVi;
       cbXVh: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableFirst_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXVi: // global
           I64[Sp - 16] = block_cbXUL_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXUL() //  [R1]
         { info_tbl: [(cbXUL,
                       label: block_cbXUL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXUL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXVl; else goto cbXVk;
       cbXVl: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXVk: // global
           I64[Hp - 24] = sat_sbX7j_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_cbXVg_info;
           R2 = R1;
           P64[Sp + 8] = Hp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXVg() //  [R1]
         { info_tbl: [(cbXVg,
                       label: block_cbXVg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXVg: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.116506337 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_closure" {
     Data.Traversable.$fTraversableFirst_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Monoid.$fFunctorFirst_closure;
         const Data.Foldable.$fFoldableFirst_closure;
         const Data.Traversable.$fTraversableFirst_$ctraverse1_closure+3;
         const Data.Traversable.$fTraversableFirst_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableFirst_$cmapM_closure+3;
         const Data.Traversable.$fTraversableFirst_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.117776001 UTC

[section ""data" . Data.Traversable.$dmtraverse_closure" {
     Data.Traversable.$dmtraverse_closure:
         const Data.Traversable.$dmtraverse_info;
 },
 f1_sbX7n_entry() //  [R1]
         { info_tbl: [(cbXVy,
                       label: f1_sbX7n_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXVy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXVz; else goto cbXVA;
       cbXVz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXVA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.sequenceA_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 g_sbX7o_entry() //  [R1]
         { info_tbl: [(cbXVH,
                       label: g_sbX7o_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXVH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXVI; else goto cbXVJ;
       cbXVI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXVJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbXVF_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.$p1Traversable_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbXVF() //  [R1]
         { info_tbl: [(cbXVF,
                       label: block_cbXVF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXVF: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbX7s_entry() //  [R1, R2]
         { info_tbl: [(cbXVT,
                       label: sat_sbX7s_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXVT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXVX; else goto cbXVW;
       cbXVX: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXVW: // global
           _sbX7n::P64 = P64[R1 + 7];
           _sbX7o::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX7o::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sbX7n::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$dmtraverse_entry() //  [R2, R3, R4]
         { info_tbl: [(cbXVY,
                       label: Data.Traversable.$dmtraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXVY: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbXW2; else goto cbXW1;
       cbXW2: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$dmtraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXW1: // global
           I64[Hp - 80] = f1_sbX7n_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = g_sbX7o_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sbX7s_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.119854097 UTC

[section ""data" . Data.Traversable.for_closure" {
     Data.Traversable.for_closure:
         const Data.Traversable.for_info;
 },
 f1_sbX7v_entry() //  [R1]
         { info_tbl: [(cbXWb,
                       label: f1_sbX7v_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXWb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXWc; else goto cbXWd;
       cbXWc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXWd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.traverse_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbX7y_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXWj,
                       label: sat_sbX7y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXWj: // global
           _sbX7x::P64 = R3;
           R3 = R2;
           R2 = _sbX7x::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.for_entry() //  [R2, R3]
         { info_tbl: [(cbXWm,
                       label: Data.Traversable.for_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXWm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXWq; else goto cbXWp;
       cbXWq: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.for_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXWp: // global
           I64[Hp - 40] = f1_sbX7v_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sbX7y_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.121589457 UTC

[section ""data" . Data.Traversable.forM_closure" {
     Data.Traversable.forM_closure:
         const Data.Traversable.forM_info;
 },
 f_sbX7B_entry() //  [R1]
         { info_tbl: [(cbXWz,
                       label: f_sbX7B_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXWz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbXWA; else goto cbXWB;
       cbXWA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXWB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.mapM_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbX7E_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXWH,
                       label: sat_sbX7E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXWH: // global
           _sbX7D::P64 = R3;
           R3 = R2;
           R2 = _sbX7D::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.forM_entry() //  [R2, R3]
         { info_tbl: [(cbXWK,
                       label: Data.Traversable.forM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXWK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbXWO; else goto cbXWN;
       cbXWO: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.forM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXWN: // global
           I64[Hp - 40] = f_sbX7B_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sbX7E_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.123140732 UTC

[section ""data" . Data.Traversable.mapAccumL_closure" {
     Data.Traversable.mapAccumL_closure:
         const Data.Traversable.mapAccumL_info;
         const 0;
 },
 sat_sbX7L_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXWY,
                       label: sat_sbX7L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXWY: // global
           _sbX7K::P64 = R3;
           R3 = R2;
           R2 = _sbX7K::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.mapAccumL_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbXX1,
                       label: Data.Traversable.mapAccumL_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXX1: // global
           _sbX7I::P64 = R5;
           _sbX7H::P64 = R4;
           _sbX7G::P64 = R3;
           _sbX7F::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cbXX2; else goto cbXX3;
       cbXX3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbXX5; else goto cbXX4;
       cbXX5: // global
           HpAlloc = 16;
           goto cbXX2;
       cbXX2: // global
           R5 = _sbX7I::P64;
           R4 = _sbX7H::P64;
           R3 = _sbX7G::P64;
           R2 = _sbX7F::P64;
           R1 = Data.Traversable.mapAccumL_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXX4: // global
           I64[Hp - 8] = sat_sbX7L_info;
           P64[Hp] = _sbX7G::P64;
           R2 = _sbX7F::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Functor.Utils.$fApplicativeStateL_closure;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = _sbX7I::P64;
           P64[Sp - 8] = _sbX7H::P64;
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.124609595 UTC

[section ""data" . Data.Traversable.mapAccumR_closure" {
     Data.Traversable.mapAccumR_closure:
         const Data.Traversable.mapAccumR_info;
         const 0;
 },
 sat_sbX7S_entry() //  [R1, R2, R3]
         { info_tbl: [(cbXXf,
                       label: sat_sbX7S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXXf: // global
           _sbX7R::P64 = R3;
           R3 = R2;
           R2 = _sbX7R::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.mapAccumR_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbXXi,
                       label: Data.Traversable.mapAccumR_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXXi: // global
           _sbX7P::P64 = R5;
           _sbX7O::P64 = R4;
           _sbX7N::P64 = R3;
           _sbX7M::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cbXXj; else goto cbXXk;
       cbXXk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbXXm; else goto cbXXl;
       cbXXm: // global
           HpAlloc = 16;
           goto cbXXj;
       cbXXj: // global
           R5 = _sbX7P::P64;
           R4 = _sbX7O::P64;
           R3 = _sbX7N::P64;
           R2 = _sbX7M::P64;
           R1 = Data.Traversable.mapAccumR_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXXl: // global
           I64[Hp - 8] = sat_sbX7S_info;
           P64[Hp] = _sbX7N::P64;
           R2 = _sbX7M::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Functor.Utils.$fApplicativeStateR_closure;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = _sbX7P::P64;
           P64[Sp - 8] = _sbX7O::P64;
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.125820818 UTC

[section ""data" . fmapDefault1_rbWTV_closure" {
     fmapDefault1_rbWTV_closure:
         const fmapDefault1_rbWTV_info;
         const 0;
 },
 fmapDefault1_rbWTV_entry() //  [R2]
         { info_tbl: [(cbXXr,
                       label: fmapDefault1_rbWTV_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXXr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXXs; else goto cbXXt;
       cbXXs: // global
           R2 = R2;
           R1 = fmapDefault1_rbWTV_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXXt: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Functor.Identity.$fApplicativeIdentity_closure;
           Sp = Sp - 16;
           call Data.Traversable.traverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.126747069 UTC

[section ""data" . Data.Traversable.fmapDefault_closure" {
     Data.Traversable.fmapDefault_closure:
         const Data.Traversable.fmapDefault_info;
         const 0;
 },
 Data.Traversable.fmapDefault_entry() //  [R2]
         { info_tbl: [(cbXXy,
                       label: Data.Traversable.fmapDefault_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXXy: // global
           R2 = R2;
           call fmapDefault1_rbWTV_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.127718426 UTC

[section ""data" . foldMapDefault1_rbWTW_closure" {
     foldMapDefault1_rbWTW_closure:
         const foldMapDefault1_rbWTW_info;
         const 0;
 },
 sat_sbX7W_entry() //  [R1]
         { info_tbl: [(cbXXJ,
                       label: sat_sbX7W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXXJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbXXK; else goto cbXXL;
       cbXXK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbXXL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fApplicativeConst_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 foldMapDefault1_rbWTW_entry() //  [R2, R3]
         { info_tbl: [(cbXXM,
                       label: foldMapDefault1_rbWTW_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXXM: // global
           _sbX7V::P64 = R3;
           _sbX7U::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbXXN; else goto cbXXO;
       cbXXO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbXXQ; else goto cbXXP;
       cbXXQ: // global
           HpAlloc = 24;
           goto cbXXN;
       cbXXN: // global
           R3 = _sbX7V::P64;
           R2 = _sbX7U::P64;
           R1 = foldMapDefault1_rbWTW_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXXP: // global
           I64[Hp - 16] = sat_sbX7W_info;
           P64[Hp] = _sbX7V::P64;
           R2 = _sbX7U::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Traversable.traverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.12893023 UTC

[section ""data" . Data.Traversable.foldMapDefault_closure" {
     Data.Traversable.foldMapDefault_closure:
         const Data.Traversable.foldMapDefault_info;
         const 0;
 },
 Data.Traversable.foldMapDefault_entry() //  [R2, R3]
         { info_tbl: [(cbXXV,
                       label: Data.Traversable.foldMapDefault_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXXV: // global
           R3 = R3;
           R2 = R2;
           call foldMapDefault1_rbWTW_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.129659803 UTC

[section ""cstring" . Data.Traversable.$trModule4_bytes" {
     Data.Traversable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.130172938 UTC

[section ""data" . Data.Traversable.$trModule3_closure" {
     Data.Traversable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Traversable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.130702458 UTC

[section ""cstring" . Data.Traversable.$trModule2_bytes" {
     Data.Traversable.$trModule2_bytes:
         I8[] [68,97,116,97,46,84,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.131283205 UTC

[section ""data" . Data.Traversable.$trModule1_closure" {
     Data.Traversable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Traversable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.131835133 UTC

[section ""data" . Data.Traversable.$trModule_closure" {
     Data.Traversable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Traversable.$trModule3_closure+1;
         const Data.Traversable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.132380873 UTC

[section ""data" . $krep_rbWTX_closure" {
     $krep_rbWTX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.132973712 UTC

[section ""data" . Data.Traversable.$tcTraversable1_closure" {
     Data.Traversable.$tcTraversable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rbWTX_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.133575449 UTC

[section ""cstring" . Data.Traversable.$tcTraversable3_bytes" {
     Data.Traversable.$tcTraversable3_bytes:
         I8[] [84,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.134110927 UTC

[section ""data" . Data.Traversable.$tcTraversable2_closure" {
     Data.Traversable.$tcTraversable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Traversable.$tcTraversable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.134655225 UTC

[section ""data" . Data.Traversable.$tcTraversable_closure" {
     Data.Traversable.$tcTraversable_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Traversable.$trModule_closure+1;
         const Data.Traversable.$tcTraversable2_closure+1;
         const Data.Traversable.$tcTraversable1_closure+4;
         const 9002450311536760373;
         const 4172295783860716183;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.135478714 UTC

[section ""data" . Data.Traversable.C:Traversable_closure" {
     Data.Traversable.C:Traversable_closure:
         const Data.Traversable.C:Traversable_info;
 },
 Data.Traversable.C:Traversable_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbXY3,
                       label: Data.Traversable.C:Traversable_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXY3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbXY7; else goto cbXY6;
       cbXY7: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.C:Traversable_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbXY6: // global
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.136425679 UTC

[Data.Traversable.C:Traversable_con_entry() //  [R1]
         { info_tbl: [(cbXY8,
                       label: Data.Traversable.C:Traversable_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,114,97,118,101,114,115,97,98,108,101,46,67,58,84,114,97,118,101,114,115,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXY8: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.137013564 UTC

[section ""relreadonly" . SbXeW_srt" {
     SbXeW_srt:
         const Data.Foldable.$fFoldableRec1_closure;
         const Data.Traversable.$fTraversableRec1_$cp2Traversable_closure;
         const Data.Foldable.$fFoldableM1_closure;
         const Data.Traversable.$fTraversableM1_$cp2Traversable_closure;
         const Data.Foldable.$fFoldable:+:_closure;
         const Data.Traversable.$fTraversable:+:_$cp2Traversable_closure;
         const Data.Foldable.$fFoldable:*:_closure;
         const Data.Traversable.$fTraversable:*:_$cp2Traversable_closure;
         const Data.Foldable.$fFoldable:.:_closure;
         const Data.Traversable.$fTraversable:.:_$cp2Traversable_closure;
         const Data.Traversable.$fTraversable:.:_closure;
         const Data.Traversable.$fTraversable:*:_closure;
         const Data.Traversable.$fTraversable:+:_closure;
         const Data.Traversable.$fTraversableM1_closure;
         const Data.Traversable.$fTraversableRec1_closure;
         const GHC.Arr.listArray_closure;
         const Data.Traversable.$fTraversableArray_$ctraverse_closure;
         const Data.Traversable.$fTraversableArray_$cmapM_closure;
         const Data.Traversable.$fTraversableArray_$csequence_closure;
         const Data.Traversable.$fTraversableArray_$csequenceA_closure;
         const GHC.Arr.$fFunctorArray_closure;
         const Data.Foldable.$fFoldableArray_closure;
         const Data.Traversable.$fTraversableArray_closure;
         const Data.Functor.Utils.$fApplicativeStateL_closure;
         const Data.Traversable.mapAccumL_closure;
         const Data.Functor.Utils.$fApplicativeStateR_closure;
         const Data.Traversable.mapAccumR_closure;
         const Data.Functor.Identity.$fApplicativeIdentity_closure;
         const fmapDefault1_rbWTV_closure;
         const Data.Functor.Const.$fApplicativeConst_closure;
         const foldMapDefault1_rbWTW_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.137753054 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:50.138487639 UTC

[section ""data" . Data.Traversable.$p1Traversable_closure" {
     Data.Traversable.$p1Traversable_closure:
         const Data.Traversable.$p1Traversable_info;
 },
 Data.Traversable.$p1Traversable_entry() //  [R2]
         { info_tbl: [(cbXYg,
                       label: Data.Traversable.$p1Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXYg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbXYh; else goto cbXYi;
       cbXYh: // global
           R2 = R2;
           R1 = Data.Traversable.$p1Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXYi: // global
           I64[Sp - 8] = block_cbXYd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubXYm; else goto cbXYe;
       ubXYm: // global
           call _cbXYd(R1) args: 0, res: 0, upd: 0;
       cbXYe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXYd() //  [R1]
         { info_tbl: [(cbXYd,
                       label: block_cbXYd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXYd: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.139671534 UTC

[section ""data" . Data.Traversable.$p2Traversable_closure" {
     Data.Traversable.$p2Traversable_closure:
         const Data.Traversable.$p2Traversable_info;
 },
 Data.Traversable.$p2Traversable_entry() //  [R2]
         { info_tbl: [(cbXYu,
                       label: Data.Traversable.$p2Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXYu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbXYv; else goto cbXYw;
       cbXYv: // global
           R2 = R2;
           R1 = Data.Traversable.$p2Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXYw: // global
           I64[Sp - 8] = block_cbXYr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubXYA; else goto cbXYs;
       ubXYA: // global
           call _cbXYr(R1) args: 0, res: 0, upd: 0;
       cbXYs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXYr() //  [R1]
         { info_tbl: [(cbXYr,
                       label: block_cbXYr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXYr: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.140806069 UTC

[section ""data" . Data.Traversable.traverse_closure" {
     Data.Traversable.traverse_closure:
         const Data.Traversable.traverse_info;
 },
 Data.Traversable.traverse_entry() //  [R2]
         { info_tbl: [(cbXYI,
                       label: Data.Traversable.traverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXYI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbXYJ; else goto cbXYK;
       cbXYJ: // global
           R2 = R2;
           R1 = Data.Traversable.traverse_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXYK: // global
           I64[Sp - 8] = block_cbXYF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubXYO; else goto cbXYG;
       ubXYO: // global
           call _cbXYF(R1) args: 0, res: 0, upd: 0;
       cbXYG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXYF() //  [R1]
         { info_tbl: [(cbXYF,
                       label: block_cbXYF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXYF: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.141965526 UTC

[section ""data" . Data.Traversable.sequenceA_closure" {
     Data.Traversable.sequenceA_closure:
         const Data.Traversable.sequenceA_info;
 },
 Data.Traversable.sequenceA_entry() //  [R2]
         { info_tbl: [(cbXYW,
                       label: Data.Traversable.sequenceA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXYW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbXYX; else goto cbXYY;
       cbXYX: // global
           R2 = R2;
           R1 = Data.Traversable.sequenceA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXYY: // global
           I64[Sp - 8] = block_cbXYT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubXZ2; else goto cbXYU;
       ubXZ2: // global
           call _cbXYT(R1) args: 0, res: 0, upd: 0;
       cbXYU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXYT() //  [R1]
         { info_tbl: [(cbXYT,
                       label: block_cbXYT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXYT: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.143102635 UTC

[section ""data" . Data.Traversable.mapM_closure" {
     Data.Traversable.mapM_closure:
         const Data.Traversable.mapM_info;
 },
 Data.Traversable.mapM_entry() //  [R2]
         { info_tbl: [(cbXZa,
                       label: Data.Traversable.mapM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXZa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbXZb; else goto cbXZc;
       cbXZb: // global
           R2 = R2;
           R1 = Data.Traversable.mapM_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXZc: // global
           I64[Sp - 8] = block_cbXZ7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubXZg; else goto cbXZ8;
       ubXZg: // global
           call _cbXZ7(R1) args: 0, res: 0, upd: 0;
       cbXZ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXZ7() //  [R1]
         { info_tbl: [(cbXZ7,
                       label: block_cbXZ7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXZ7: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.144199977 UTC

[section ""data" . Data.Traversable.sequence_closure" {
     Data.Traversable.sequence_closure:
         const Data.Traversable.sequence_info;
 },
 Data.Traversable.sequence_entry() //  [R2]
         { info_tbl: [(cbXZo,
                       label: Data.Traversable.sequence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXZo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbXZp; else goto cbXZq;
       cbXZp: // global
           R2 = R2;
           R1 = Data.Traversable.sequence_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbXZq: // global
           I64[Sp - 8] = block_cbXZl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubXZu; else goto cbXZm;
       ubXZu: // global
           call _cbXZl(R1) args: 0, res: 0, upd: 0;
       cbXZm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXZl() //  [R1]
         { info_tbl: [(cbXZl,
                       label: block_cbXZl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXZl: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.145998437 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$ctraverse_closure" {
     Data.Traversable.$fTraversableFirst_$ctraverse_closure:
         const Data.Traversable.$fTraversableFirst_$ctraverse_info;
 },
 Data.Traversable.$fTraversableFirst_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbXZG,
                       label: Data.Traversable.$fTraversableFirst_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXZG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbXZH; else goto cbXZI;
       cbXZH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableFirst_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbXZI: // global
           I64[Sp - 24] = block_cbXZz_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubXZX; else goto cbXZA;
       ubXZX: // global
           call _cbXZz(R1) args: 0, res: 0, upd: 0;
       cbXZA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbXZz() //  [R1]
         { info_tbl: [(cbXZz,
                       label: block_cbXZz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXZz: // global
           _sbWUL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbXZD; else goto cbXZE;
       cbXZD: // global
           R2 = _sbWUL::P64;
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cbXZE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbXZS; else goto cbXZR;
       cbXZS: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbXZR: // global
           _sbWUP::P64 = P64[R1 + 6];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbWUP::P64;
           I64[Sp + 8] = block_cbXZP_info;
           R2 = _sbWUL::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbXZP() //  [R1]
         { info_tbl: [(cbXZP,
                       label: block_cbXZP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbXZP: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.148125263 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$ctraverse_closure" {
     Data.Traversable.$fTraversable[]_$ctraverse_closure:
         const Data.Traversable.$fTraversable[]_$ctraverse_info;
 },
 z_sbWUU_entry() //  [R1]
         { info_tbl: [(cbY06,
                       label: z_sbWUU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY06: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbY07; else goto cbY08;
       cbY07: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY08: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbWUV_entry() //  [R1, R2]
         { info_tbl: [(cbY0l,
                       label: go_sbWUV_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY0l: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbY0m; else goto cbY0n;
       cbY0m: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbY0n: // global
           I64[Sp - 40] = block_cbY0e_info;
           _sbWUV::P64 = R1;
           _sbWUS::P64 = P64[R1 + 7];
           _sbWUT::P64 = P64[R1 + 15];
           _sbWUU::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sbWUS::P64;
           P64[Sp - 24] = _sbWUT::P64;
           P64[Sp - 16] = _sbWUU::P64;
           P64[Sp - 8] = _sbWUV::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubY0y; else goto cbY0f;
       ubY0y: // global
           call _cbY0e(R1) args: 0, res: 0, upd: 0;
       cbY0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbY0e() //  [R1]
         { info_tbl: [(cbY0e,
                       label: block_cbY0e_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY0e: // global
           if (R1 & 7 == 1) goto cbY0i; else goto cbY0j;
       cbY0i: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbY0j: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbY0v; else goto cbY0u;
       cbY0v: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbY0u: // global
           _sbWUY::P64 = P64[R1 + 6];
           _sbWUZ::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sbWUZ::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbWUY::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$ctraverse_entry() //  [R2, R3]
         { info_tbl: [(cbY0z,
                       label: Data.Traversable.$fTraversable[]_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY0z: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbY0D; else goto cbY0C;
       cbY0D: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$ctraverse_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY0C: // global
           I64[Hp - 48] = z_sbWUU_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_sbWUV_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.150375838 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$ctraverse_closure" {
     Data.Traversable.$fTraversableEither_$ctraverse_closure:
         const Data.Traversable.$fTraversableEither_$ctraverse_info;
 },
 Data.Traversable.$fTraversableEither_$ctraverse_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cbY0P,
                       label: Data.Traversable.$fTraversableEither_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY0P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbY0Q; else goto cbY0R;
       cbY0Q: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY0R: // global
           I64[Sp - 24] = block_cbY0I_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubY16; else goto cbY0J;
       ubY16: // global
           call _cbY0I(R1) args: 0, res: 0, upd: 0;
       cbY0J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbY0I() //  [R1]
         { info_tbl: [(cbY0I,
                       label: block_cbY0I_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY0I: // global
           _sbWV2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbY0M; else goto cbY0N;
       cbY0M: // global
           R2 = _sbWV2::P64;
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cbY0N: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbY11; else goto cbY10;
       cbY11: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbY10: // global
           _sbWV8::P64 = P64[R1 + 6];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbWV8::P64;
           I64[Sp + 8] = block_cbY0Y_info;
           R2 = _sbWV2::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY0Y() //  [R1]
         { info_tbl: [(cbY0Y,
                       label: block_cbY0Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY0Y: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.152195475 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$ctraverse_closure" {
     Data.Traversable.$fTraversable(,)_$ctraverse_closure:
         const Data.Traversable.$fTraversable(,)_$ctraverse_info;
 },
 sat_sbWVi_entry() //  [R1, R2]
         { info_tbl: [(cbY1n,
                       label: sat_sbWVi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY1n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbY1r; else goto cbY1q;
       cbY1r: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbY1q: // global
           _sbWVf::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbWVf::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$ctraverse_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbY1s,
                       label: Data.Traversable.$fTraversable(,)_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY1s: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbY1u; else goto cbY1v;
       cbY1u: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY1v: // global
           I64[Sp - 24] = block_cbY1b_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubY1D; else goto cbY1c;
       ubY1D: // global
           call _cbY1b(R1) args: 0, res: 0, upd: 0;
       cbY1c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbY1b() //  [R1]
         { info_tbl: [(cbY1b,
                       label: block_cbY1b_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY1b: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbY1y; else goto cbY1x;
       cbY1y: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbY1x: // global
           _sbWVf::P64 = P64[R1 + 7];
           _sbWVg::P64 = P64[R1 + 15];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbWVg::P64;
           I64[Hp - 8] = sat_sbWVi_info;
           P64[Hp] = _sbWVf::P64;
           I64[Sp] = block_cbY1t_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 7;
           P64[Sp + 16] = Hp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY1t() //  [R1]
         { info_tbl: [(cbY1t,
                       label: block_cbY1t_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY1t: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.153997117 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$csequence_closure" {
     Data.Traversable.$fTraversableProxy_$csequence_closure:
         const Data.Traversable.$fTraversableProxy_$csequence_info;
 },
 Data.Traversable.$fTraversableProxy_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbY1K,
                       label: Data.Traversable.$fTraversableProxy_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY1K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY1L; else goto cbY1M;
       cbY1L: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY1M: // global
           I64[Sp - 8] = block_cbY1I_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY1I() //  [R1]
         { info_tbl: [(cbY1I,
                       label: block_cbY1I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY1I: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.155122745 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$cmapM_closure" {
     Data.Traversable.$fTraversableProxy_$cmapM_closure:
         const Data.Traversable.$fTraversableProxy_$cmapM_info;
 },
 Data.Traversable.$fTraversableProxy_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbY1W,
                       label: Data.Traversable.$fTraversableProxy_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY1W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY1X; else goto cbY1Y;
       cbY1X: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY1Y: // global
           I64[Sp - 8] = block_cbY1U_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY1U() //  [R1]
         { info_tbl: [(cbY1U,
                       label: block_cbY1U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY1U: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.156180628 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$csequenceA_closure" {
     Data.Traversable.$fTraversableProxy_$csequenceA_closure:
         const Data.Traversable.$fTraversableProxy_$csequenceA_info;
 },
 Data.Traversable.$fTraversableProxy_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbY26,
                       label: Data.Traversable.$fTraversableProxy_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY26: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY27; else goto cbY28;
       cbY27: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY28: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.157120934 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$ctraverse_closure" {
     Data.Traversable.$fTraversableProxy_$ctraverse_closure:
         const Data.Traversable.$fTraversableProxy_$ctraverse_info;
 },
 Data.Traversable.$fTraversableProxy_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbY2d,
                       label: Data.Traversable.$fTraversableProxy_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY2d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY2e; else goto cbY2f;
       cbY2e: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY2f: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.159673876 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_closure" {
     Data.Traversable.$fTraversableProxy_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Proxy.$fFunctorProxy_closure;
         const Data.Foldable.$fFoldableProxy_closure;
         const Data.Traversable.$fTraversableProxy_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableProxy_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableProxy_$cmapM_closure+3;
         const Data.Traversable.$fTraversableProxy_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.160445515 UTC

[section ""data" . Data.Traversable.$fTraversableConst_$ctraverse_closure" {
     Data.Traversable.$fTraversableConst_$ctraverse_closure:
         const Data.Traversable.$fTraversableConst_$ctraverse_info;
 },
 Data.Traversable.$fTraversableConst_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbY2k,
                       label: Data.Traversable.$fTraversableConst_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY2k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY2l; else goto cbY2m;
       cbY2l: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableConst_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY2m: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.161627398 UTC

[section ""data" . Data.Traversable.$fTraversableDual1_closure" {
     Data.Traversable.$fTraversableDual1_closure:
         const Data.Traversable.$fTraversableDual1_info;
 },
 Data.Traversable.$fTraversableDual1_entry() //  [R2]
         { info_tbl: [(cbY2r,
                       label: Data.Traversable.$fTraversableDual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY2r: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.162521766 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$ctraverse_closure" {
     Data.Traversable.$fTraversableDual_$ctraverse_closure:
         const Data.Traversable.$fTraversableDual_$ctraverse_info;
 },
 Data.Traversable.$fTraversableDual_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbY2B,
                       label: Data.Traversable.$fTraversableDual_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY2B: // global
           _sbWVC::P64 = R4;
           _sbWVB::P64 = R3;
           _sbWVA::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbY2C; else goto cbY2D;
       cbY2D: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbY2F; else goto cbY2E;
       cbY2F: // global
           HpAlloc = 32;
           goto cbY2C;
       cbY2C: // global
           R4 = _sbWVC::P64;
           R3 = _sbWVB::P64;
           R2 = _sbWVA::P64;
           R1 = Data.Traversable.$fTraversableDual_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY2E: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWVB::P64;
           P64[Hp] = _sbWVC::P64;
           I64[Sp - 16] = block_cbY2z_info;
           R2 = _sbWVA::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY2z() //  [R1]
         { info_tbl: [(cbY2z,
                       label: block_cbY2z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY2z: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.163831211 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$ctraverse_closure" {
     Data.Traversable.$fTraversableSum_$ctraverse_closure:
         const Data.Traversable.$fTraversableSum_$ctraverse_info;
 },
 Data.Traversable.$fTraversableSum_$ctraverse_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbY2Q,
                       label: Data.Traversable.$fTraversableSum_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY2Q: // global
           _sbWVH::P64 = R4;
           _sbWVG::P64 = R3;
           _sbWVF::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbY2R; else goto cbY2S;
       cbY2S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbY2U; else goto cbY2T;
       cbY2U: // global
           HpAlloc = 32;
           goto cbY2R;
       cbY2R: // global
           R4 = _sbWVH::P64;
           R3 = _sbWVG::P64;
           R2 = _sbWVF::P64;
           R1 = Data.Traversable.$fTraversableSum_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY2T: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWVG::P64;
           P64[Hp] = _sbWVH::P64;
           I64[Sp - 16] = block_cbY2O_info;
           R2 = _sbWVF::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY2O() //  [R1]
         { info_tbl: [(cbY2O,
                       label: block_cbY2O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY2O: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.165131797 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$ctraverse_closure" {
     Data.Traversable.$fTraversableProduct_$ctraverse_closure:
         const Data.Traversable.$fTraversableProduct_$ctraverse_info;
 },
 Data.Traversable.$fTraversableProduct_$ctraverse_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbY35,
                       label: Data.Traversable.$fTraversableProduct_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY35: // global
           _sbWVM::P64 = R4;
           _sbWVL::P64 = R3;
           _sbWVK::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbY36; else goto cbY37;
       cbY37: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbY39; else goto cbY38;
       cbY39: // global
           HpAlloc = 32;
           goto cbY36;
       cbY36: // global
           R4 = _sbWVM::P64;
           R3 = _sbWVL::P64;
           R2 = _sbWVK::P64;
           R1 = Data.Traversable.$fTraversableProduct_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY38: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWVL::P64;
           P64[Hp] = _sbWVM::P64;
           I64[Sp - 16] = block_cbY33_info;
           R2 = _sbWVK::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY33() //  [R1]
         { info_tbl: [(cbY33,
                       label: block_cbY33_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY33: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.166391465 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$csequence_closure" {
     Data.Traversable.$fTraversableU1_$csequence_closure:
         const Data.Traversable.$fTraversableU1_$csequence_info;
 },
 Data.Traversable.$fTraversableU1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbY3j,
                       label: Data.Traversable.$fTraversableU1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY3j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY3k; else goto cbY3l;
       cbY3k: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY3l: // global
           I64[Sp - 8] = block_cbY3h_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY3h() //  [R1]
         { info_tbl: [(cbY3h,
                       label: block_cbY3h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY3h: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Generics.U1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.167460662 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$cmapM_closure" {
     Data.Traversable.$fTraversableU1_$cmapM_closure:
         const Data.Traversable.$fTraversableU1_$cmapM_info;
 },
 Data.Traversable.$fTraversableU1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbY3v,
                       label: Data.Traversable.$fTraversableU1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY3v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY3w; else goto cbY3x;
       cbY3w: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY3x: // global
           I64[Sp - 8] = block_cbY3t_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY3t() //  [R1]
         { info_tbl: [(cbY3t,
                       label: block_cbY3t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY3t: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Generics.U1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.16848539 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$csequenceA_closure" {
     Data.Traversable.$fTraversableU1_$csequenceA_closure:
         const Data.Traversable.$fTraversableU1_$csequenceA_info;
 },
 Data.Traversable.$fTraversableU1_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbY3F,
                       label: Data.Traversable.$fTraversableU1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY3F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY3G; else goto cbY3H;
       cbY3G: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY3H: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Generics.U1_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.169437113 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$ctraverse_closure" {
     Data.Traversable.$fTraversableU1_$ctraverse_closure:
         const Data.Traversable.$fTraversableU1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableU1_$ctraverse_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbY3M,
                       label: Data.Traversable.$fTraversableU1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY3M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY3N; else goto cbY3O;
       cbY3N: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY3O: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Generics.U1_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.170254051 UTC

[section ""data" . Data.Traversable.$fTraversableU1_closure" {
     Data.Traversable.$fTraversableU1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorU1_closure;
         const Data.Foldable.$fFoldableU1_closure;
         const Data.Traversable.$fTraversableU1_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableU1_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableU1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableU1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.171138496 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$ctraverse_closure" {
     Data.Traversable.$fTraversableIdentity_$ctraverse_closure:
         const Data.Traversable.$fTraversableIdentity_$ctraverse_info;
 },
 Data.Traversable.$fTraversableIdentity_$ctraverse_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cbY3W,
                       label: Data.Traversable.$fTraversableIdentity_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY3W: // global
           _sbWW3::P64 = R4;
           _sbWW2::P64 = R3;
           _sbWW1::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbY3X; else goto cbY3Y;
       cbY3Y: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbY40; else goto cbY3Z;
       cbY40: // global
           HpAlloc = 32;
           goto cbY3X;
       cbY3X: // global
           R4 = _sbWW3::P64;
           R3 = _sbWW2::P64;
           R2 = _sbWW1::P64;
           R1 = Data.Traversable.$fTraversableIdentity_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY3Z: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWW2::P64;
           P64[Hp] = _sbWW3::P64;
           I64[Sp - 16] = block_cbY3U_info;
           R2 = _sbWW1::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY3U() //  [R1]
         { info_tbl: [(cbY3U,
                       label: block_cbY3U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY3U: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.172298811 UTC

[section ""data" . Data.Traversable.$fTraversableV1_$ctraverse_closure" {
     Data.Traversable.$fTraversableV1_$ctraverse_closure:
         const Data.Traversable.$fTraversableV1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableV1_$ctraverse_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbY48,
                       label: Data.Traversable.$fTraversableV1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY48: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY49; else goto cbY4a;
       cbY49: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableV1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY4a: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.173583673 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$ctraverse_closure" {
     Data.Traversable.$fTraversablePar1_$ctraverse_closure:
         const Data.Traversable.$fTraversablePar1_$ctraverse_info;
 },
 Data.Traversable.$fTraversablePar1_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbY4i,
                       label: Data.Traversable.$fTraversablePar1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY4i: // global
           _sbWWb::P64 = R4;
           _sbWWa::P64 = R3;
           _sbWW9::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbY4j; else goto cbY4k;
       cbY4k: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbY4m; else goto cbY4l;
       cbY4m: // global
           HpAlloc = 32;
           goto cbY4j;
       cbY4j: // global
           R4 = _sbWWb::P64;
           R3 = _sbWWa::P64;
           R2 = _sbWW9::P64;
           R1 = Data.Traversable.$fTraversablePar1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY4l: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWWa::P64;
           P64[Hp] = _sbWWb::P64;
           I64[Sp - 16] = block_cbY4g_info;
           R2 = _sbWW9::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY4g() //  [R1]
         { info_tbl: [(cbY4g,
                       label: block_cbY4g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY4g: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.17470002 UTC

[section ""data" . Data.Traversable.$fTraversableM2_closure" {
     Data.Traversable.$fTraversableM2_closure:
         const Data.Traversable.$fTraversableM2_info;
 },
 Data.Traversable.$fTraversableM2_entry() //  [R2]
         { info_tbl: [(cbY4u,
                       label: Data.Traversable.$fTraversableM2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY4u: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.17572326 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$ctraverse_closure" {
     Data.Traversable.$fTraversableRec1_$ctraverse_closure:
         const Data.Traversable.$fTraversableRec1_$ctraverse_info;
 },
 sat_sbWWk_entry() //  [R1]
         { info_tbl: [(cbY4F,
                       label: sat_sbWWk_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY4F: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbY4G; else goto cbY4H;
       cbY4G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY4H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$ctraverse_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cbY4K,
                       label: Data.Traversable.$fTraversableRec1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY4K: // global
           _sbWWi::P64 = R5;
           _sbWWh::P64 = R4;
           _sbWWg::P64 = R3;
           _sbWWf::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbY4L; else goto cbY4M;
       cbY4M: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbY4O; else goto cbY4N;
       cbY4O: // global
           HpAlloc = 48;
           goto cbY4L;
       cbY4L: // global
           R5 = _sbWWi::P64;
           R4 = _sbWWh::P64;
           R3 = _sbWWg::P64;
           R2 = _sbWWf::P64;
           R1 = Data.Traversable.$fTraversableRec1_$ctraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY4N: // global
           I64[Hp - 40] = sat_sbWWk_info;
           P64[Hp - 24] = _sbWWf::P64;
           P64[Hp - 16] = _sbWWg::P64;
           P64[Hp - 8] = _sbWWh::P64;
           P64[Hp] = _sbWWi::P64;
           I64[Sp - 16] = block_cbY4I_info;
           R2 = _sbWWg::P64;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY4I() //  [R1]
         { info_tbl: [(cbY4I,
                       label: block_cbY4I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY4I: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.17737046 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$cp2Traversable_closure" {
     Data.Traversable.$fTraversableRec1_$cp2Traversable_closure:
         const Data.Traversable.$fTraversableRec1_$cp2Traversable_info;
         const 0;
 },
 sat_sbWWm_entry() //  [R1]
         { info_tbl: [(cbY50,
                       label: sat_sbWWm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY50: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY51; else goto cbY52;
       cbY51: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY52: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$cp2Traversable_entry() //  [R2]
         { info_tbl: [(cbY53,
                       label: Data.Traversable.$fTraversableRec1_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY53: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbY57; else goto cbY56;
       cbY57: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$cp2Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbY56: // global
           I64[Hp - 16] = sat_sbWWm_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldableRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.178646667 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$cp1Traversable_closure" {
     Data.Traversable.$fTraversableRec1_$cp1Traversable_closure:
         const Data.Traversable.$fTraversableRec1_$cp1Traversable_info;
 },
 sat_sbWWo_entry() //  [R1]
         { info_tbl: [(cbY5g,
                       label: sat_sbWWo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY5g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY5h; else goto cbY5i;
       cbY5h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY5i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$cp1Traversable_entry() //  [R2]
         { info_tbl: [(cbY5j,
                       label: Data.Traversable.$fTraversableRec1_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY5j: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbY5n; else goto cbY5m;
       cbY5n: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$cp1Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbY5m: // global
           I64[Hp - 16] = sat_sbWWo_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctorRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.17976501 UTC

[section ""data" . Data.Traversable.$fTraversableK1_$ctraverse_closure" {
     Data.Traversable.$fTraversableK1_$ctraverse_closure:
         const Data.Traversable.$fTraversableK1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableK1_$ctraverse_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbY5s,
                       label: Data.Traversable.$fTraversableK1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY5s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY5t; else goto cbY5u;
       cbY5t: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableK1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY5u: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.180969135 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$ctraverse_closure" {
     Data.Traversable.$fTraversableM1_$ctraverse_closure:
         const Data.Traversable.$fTraversableM1_$ctraverse_info;
 },
 sat_sbWWx_entry() //  [R1]
         { info_tbl: [(cbY5D,
                       label: sat_sbWWx_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY5D: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbY5E; else goto cbY5F;
       cbY5E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY5F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$ctraverse_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cbY5I,
                       label: Data.Traversable.$fTraversableM1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY5I: // global
           _sbWWv::P64 = R5;
           _sbWWu::P64 = R4;
           _sbWWt::P64 = R3;
           _sbWWs::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbY5J; else goto cbY5K;
       cbY5K: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbY5M; else goto cbY5L;
       cbY5M: // global
           HpAlloc = 48;
           goto cbY5J;
       cbY5J: // global
           R5 = _sbWWv::P64;
           R4 = _sbWWu::P64;
           R3 = _sbWWt::P64;
           R2 = _sbWWs::P64;
           R1 = Data.Traversable.$fTraversableM1_$ctraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY5L: // global
           I64[Hp - 40] = sat_sbWWx_info;
           P64[Hp - 24] = _sbWWs::P64;
           P64[Hp - 16] = _sbWWt::P64;
           P64[Hp - 8] = _sbWWu::P64;
           P64[Hp] = _sbWWv::P64;
           I64[Sp - 16] = block_cbY5G_info;
           R2 = _sbWWt::P64;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY5G() //  [R1]
         { info_tbl: [(cbY5G,
                       label: block_cbY5G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY5G: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.18259258 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$cp2Traversable_closure" {
     Data.Traversable.$fTraversableM1_$cp2Traversable_closure:
         const Data.Traversable.$fTraversableM1_$cp2Traversable_info;
         const 0;
 },
 sat_sbWWz_entry() //  [R1]
         { info_tbl: [(cbY5Y,
                       label: sat_sbWWz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY5Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY5Z; else goto cbY60;
       cbY5Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY60: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$cp2Traversable_entry() //  [R2]
         { info_tbl: [(cbY61,
                       label: Data.Traversable.$fTraversableM1_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY61: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbY65; else goto cbY64;
       cbY65: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$cp2Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbY64: // global
           I64[Hp - 16] = sat_sbWWz_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldableM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.183874142 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$cp1Traversable_closure" {
     Data.Traversable.$fTraversableM1_$cp1Traversable_closure:
         const Data.Traversable.$fTraversableM1_$cp1Traversable_info;
 },
 sat_sbWWB_entry() //  [R1]
         { info_tbl: [(cbY6e,
                       label: sat_sbWWB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY6e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY6f; else goto cbY6g;
       cbY6f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY6g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$cp1Traversable_entry() //  [R2]
         { info_tbl: [(cbY6h,
                       label: Data.Traversable.$fTraversableM1_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY6h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbY6l; else goto cbY6k;
       cbY6l: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$cp1Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbY6k: // global
           I64[Hp - 16] = sat_sbWWB_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctorM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.186005116 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$ctraverse_closure" {
     Data.Traversable.$fTraversable:+:_$ctraverse_closure:
         const Data.Traversable.$fTraversable:+:_$ctraverse_info;
 },
 sat_sbWWK_entry() //  [R1]
         { info_tbl: [(cbY6z,
                       label: sat_sbWWK_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY6z: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbY6A; else goto cbY6B;
       cbY6A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY6B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sbWWN_entry() //  [R1]
         { info_tbl: [(cbY6I,
                       label: sat_sbWWN_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY6I: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbY6J; else goto cbY6K;
       cbY6J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY6K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cbY6P,
                       label: Data.Traversable.$fTraversable:+:_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY6P: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbY6Q; else goto cbY6R;
       cbY6Q: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY6R: // global
           I64[Sp - 40] = block_cbY6q_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubY78; else goto cbY6r;
       ubY78: // global
           call _cbY6q(R1) args: 0, res: 0, upd: 0;
       cbY6r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbY6q() //  [R1]
         { info_tbl: [(cbY6q,
                       label: block_cbY6q_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY6q: // global
           _sbWWE::P64 = P64[Sp + 24];
           _sbWWF::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cbY6M; else goto cbY6N;
       cbY6M: // global
           Hp = Hp + 48;
           _sbWWH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbY73; else goto cbY6U;
       cbY6U: // global
           _sbWWI::P64 = P64[_sbWWH::P64 + 7];
           I64[Hp - 40] = sat_sbWWK_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbWWE::P64;
           P64[Hp - 8] = _sbWWF::P64;
           P64[Hp] = _sbWWI::P64;
           I64[Sp + 24] = block_cbY6S_info;
           R2 = _sbWWE::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
       cbY6N: // global
           Hp = Hp + 48;
           _sbWWH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbY73; else goto cbY72;
       cbY73: // global
           HpAlloc = 48;
           R1 = _sbWWH::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbY72: // global
           _sbWWL::P64 = P64[_sbWWH::P64 + 6];
           I64[Hp - 40] = sat_sbWWN_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbWWE::P64;
           P64[Hp - 8] = _sbWWF::P64;
           P64[Hp] = _sbWWL::P64;
           I64[Sp + 24] = block_cbY70_info;
           R2 = _sbWWE::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY6S() //  [R1]
         { info_tbl: [(cbY6S,
                       label: block_cbY6S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY6S: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Generics.L1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cbY70() //  [R1]
         { info_tbl: [(cbY70,
                       label: block_cbY70_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY70: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Generics.R1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.188577687 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$cp2Traversable_closure" {
     Data.Traversable.$fTraversable:+:_$cp2Traversable_closure:
         const Data.Traversable.$fTraversable:+:_$cp2Traversable_info;
         const 0;
 },
 sat_sbWWR_entry() //  [R1]
         { info_tbl: [(cbY7h,
                       label: sat_sbWWR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY7h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY7i; else goto cbY7j;
       cbY7i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY7j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWWQ_entry() //  [R1]
         { info_tbl: [(cbY7o,
                       label: sat_sbWWQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY7o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY7p; else goto cbY7q;
       cbY7p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY7q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbY7r,
                       label: Data.Traversable.$fTraversable:+:_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY7r: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbY7v; else goto cbY7u;
       cbY7v: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY7u: // global
           I64[Hp - 40] = sat_sbWWR_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWWQ_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldable:+:_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.190239403 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$cp1Traversable_closure" {
     Data.Traversable.$fTraversable:+:_$cp1Traversable_closure:
         const Data.Traversable.$fTraversable:+:_$cp1Traversable_info;
 },
 sat_sbWWV_entry() //  [R1]
         { info_tbl: [(cbY7E,
                       label: sat_sbWWV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY7E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY7F; else goto cbY7G;
       cbY7F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY7G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWWU_entry() //  [R1]
         { info_tbl: [(cbY7L,
                       label: sat_sbWWU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY7L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY7M; else goto cbY7N;
       cbY7M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY7N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbY7O,
                       label: Data.Traversable.$fTraversable:+:_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY7O: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbY7S; else goto cbY7R;
       cbY7S: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY7R: // global
           I64[Hp - 40] = sat_sbWWV_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWWU_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctor:+:_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.192048975 UTC

[section ""data" . Data.Traversable.$w$ctraverse_closure" {
     Data.Traversable.$w$ctraverse_closure:
         const Data.Traversable.$w$ctraverse_info;
 },
 sat_sbWX3_entry() //  [R1]
         { info_tbl: [(cbY81,
                       label: sat_sbWX3_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY81: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbY82; else goto cbY83;
       cbY82: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY83: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sbWX2_entry() //  [R1]
         { info_tbl: [(cbY88,
                       label: sat_sbWX2_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY88: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbY89; else goto cbY8a;
       cbY89: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY8a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$w$ctraverse_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbY8b,
                       label: Data.Traversable.$w$ctraverse_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY8b: // global
           _sbWX0::P64 = R6;
           _sbWWZ::P64 = R5;
           _sbWWY::P64 = R4;
           _sbWWX::P64 = R3;
           _sbWWW::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbY8c; else goto cbY8d;
       cbY8d: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbY8f; else goto cbY8e;
       cbY8f: // global
           HpAlloc = 96;
           goto cbY8c;
       cbY8c: // global
           R6 = _sbWX0::P64;
           R5 = _sbWWZ::P64;
           R4 = _sbWWY::P64;
           R3 = _sbWWX::P64;
           R2 = _sbWWW::P64;
           R1 = Data.Traversable.$w$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbY8e: // global
           I64[Hp - 88] = sat_sbWX3_info;
           P64[Hp - 72] = _sbWWX::P64;
           P64[Hp - 64] = _sbWWY::P64;
           P64[Hp - 56] = _sbWWZ::P64;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = sat_sbWX2_info;
           P64[Hp - 24] = _sbWWW::P64;
           P64[Hp - 16] = _sbWWY::P64;
           P64[Hp - 8] = _sbWWZ::P64;
           P64[Hp] = _sbWX0::P64;
           R2 = _sbWWY::P64;
           I64[Sp - 24] = stg_ap_ppp_info;
           P64[Sp - 16] = GHC.Generics.:*:_closure+2;
           P64[Sp - 8] = Hp - 40;
           P64[Sp] = Hp - 88;
           Sp = Sp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.193954973 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$ctraverse_closure" {
     Data.Traversable.$fTraversable:*:_$ctraverse_closure:
         const Data.Traversable.$fTraversable:*:_$ctraverse_info;
 },
 Data.Traversable.$fTraversable:*:_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cbY8n,
                       label: Data.Traversable.$fTraversable:*:_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY8n: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbY8o; else goto cbY8p;
       cbY8o: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY8p: // global
           I64[Sp - 40] = block_cbY8k_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubY8t; else goto cbY8l;
       ubY8t: // global
           call _cbY8k(R1) args: 0, res: 0, upd: 0;
       cbY8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbY8k() //  [R1]
         { info_tbl: [(cbY8k,
                       label: block_cbY8k_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY8k: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.195451749 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$cp2Traversable_closure" {
     Data.Traversable.$fTraversable:*:_$cp2Traversable_closure:
         const Data.Traversable.$fTraversable:*:_$cp2Traversable_info;
         const 0;
 },
 sat_sbWXf_entry() //  [R1]
         { info_tbl: [(cbY8C,
                       label: sat_sbWXf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY8C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY8D; else goto cbY8E;
       cbY8D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY8E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWXe_entry() //  [R1]
         { info_tbl: [(cbY8J,
                       label: sat_sbWXe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY8J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY8K; else goto cbY8L;
       cbY8K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY8L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:*:_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbY8M,
                       label: Data.Traversable.$fTraversable:*:_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY8M: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbY8Q; else goto cbY8P;
       cbY8Q: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY8P: // global
           I64[Hp - 40] = sat_sbWXf_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWXe_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldable:*:_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.19711222 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$cp1Traversable_closure" {
     Data.Traversable.$fTraversable:*:_$cp1Traversable_closure:
         const Data.Traversable.$fTraversable:*:_$cp1Traversable_info;
 },
 sat_sbWXj_entry() //  [R1]
         { info_tbl: [(cbY8Z,
                       label: sat_sbWXj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY8Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY90; else goto cbY91;
       cbY90: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY91: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWXi_entry() //  [R1]
         { info_tbl: [(cbY96,
                       label: sat_sbWXi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY96: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY97; else goto cbY98;
       cbY97: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY98: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:*:_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbY99,
                       label: Data.Traversable.$fTraversable:*:_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY99: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbY9d; else goto cbY9c;
       cbY9d: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY9c: // global
           I64[Hp - 40] = sat_sbWXj_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWXi_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctor:*:_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.198674082 UTC

[section ""data" . Data.Traversable.$fTraversable:.:1_closure" {
     Data.Traversable.$fTraversable:.:1_closure:
         const Data.Traversable.$fTraversable:.:1_info;
 },
 Data.Traversable.$fTraversable:.:1_entry() //  [R2]
         { info_tbl: [(cbY9i,
                       label: Data.Traversable.$fTraversable:.:1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY9i: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.199857776 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$ctraverse_closure" {
     Data.Traversable.$fTraversable:.:_$ctraverse_closure:
         const Data.Traversable.$fTraversable:.:_$ctraverse_info;
 },
 sat_sbWXr_entry() //  [R1]
         { info_tbl: [(cbY9x,
                       label: sat_sbWXr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY9x: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbY9y; else goto cbY9z;
       cbY9y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY9z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbWXs_entry() //  [R1]
         { info_tbl: [(cbY9A,
                       label: sat_sbWXs_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY9A: // global
           _sbWXs::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cbY9B; else goto cbY9C;
       cbY9C: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbY9E; else goto cbY9D;
       cbY9E: // global
           HpAlloc = 40;
           goto cbY9B;
       cbY9B: // global
           R1 = _sbWXs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY9D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbWXs::P64;
           _sbWXl::P64 = P64[_sbWXs::P64 + 16];
           _sbWXm::P64 = P64[_sbWXs::P64 + 24];
           _sbWXn::P64 = P64[_sbWXs::P64 + 32];
           _sbWXo::P64 = P64[_sbWXs::P64 + 40];
           _sbWXp::P64 = P64[_sbWXs::P64 + 48];
           I64[Hp - 32] = sat_sbWXr_info;
           P64[Hp - 16] = _sbWXm::P64;
           P64[Hp - 8] = _sbWXn::P64;
           P64[Hp] = _sbWXo::P64;
           R2 = _sbWXl::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = _sbWXn::P64;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _sbWXp::P64;
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cbY9H,
                       label: Data.Traversable.$fTraversable:.:_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY9H: // global
           _sbWXp::P64 = R6;
           _sbWXo::P64 = R5;
           _sbWXn::P64 = R4;
           _sbWXm::P64 = R3;
           _sbWXl::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbY9I; else goto cbY9J;
       cbY9J: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbY9L; else goto cbY9K;
       cbY9L: // global
           HpAlloc = 56;
           goto cbY9I;
       cbY9I: // global
           R6 = _sbWXp::P64;
           R5 = _sbWXo::P64;
           R4 = _sbWXn::P64;
           R3 = _sbWXm::P64;
           R2 = _sbWXl::P64;
           R1 = Data.Traversable.$fTraversable:.:_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbY9K: // global
           I64[Hp - 48] = sat_sbWXs_info;
           P64[Hp - 32] = _sbWXl::P64;
           P64[Hp - 24] = _sbWXm::P64;
           P64[Hp - 16] = _sbWXn::P64;
           P64[Hp - 8] = _sbWXo::P64;
           P64[Hp] = _sbWXp::P64;
           I64[Sp - 16] = block_cbY9F_info;
           R2 = _sbWXn::P64;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbY9F() //  [R1]
         { info_tbl: [(cbY9F,
                       label: block_cbY9F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY9F: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversable:.:1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.20202784 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$cp2Traversable_closure" {
     Data.Traversable.$fTraversable:.:_$cp2Traversable_closure:
         const Data.Traversable.$fTraversable:.:_$cp2Traversable_info;
         const 0;
 },
 sat_sbWXw_entry() //  [R1]
         { info_tbl: [(cbY9X,
                       label: sat_sbWXw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbY9X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbY9Y; else goto cbY9Z;
       cbY9Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbY9Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWXv_entry() //  [R1]
         { info_tbl: [(cbYa4,
                       label: sat_sbWXv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYa4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYa5; else goto cbYa6;
       cbYa5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYa6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbYa7,
                       label: Data.Traversable.$fTraversable:.:_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYa7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbYab; else goto cbYaa;
       cbYab: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYaa: // global
           I64[Hp - 40] = sat_sbWXw_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWXv_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldable:.:_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.203660427 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$cp1Traversable_closure" {
     Data.Traversable.$fTraversable:.:_$cp1Traversable_closure:
         const Data.Traversable.$fTraversable:.:_$cp1Traversable_info;
 },
 sat_sbWXA_entry() //  [R1]
         { info_tbl: [(cbYak,
                       label: sat_sbWXA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYak: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYal; else goto cbYam;
       cbYal: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYam: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWXz_entry() //  [R1]
         { info_tbl: [(cbYar,
                       label: sat_sbWXz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYar: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYas; else goto cbYat;
       cbYas: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYat: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbYau,
                       label: Data.Traversable.$fTraversable:.:_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYau: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbYay; else goto cbYax;
       cbYay: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYax: // global
           I64[Hp - 40] = sat_sbWXA_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWXz_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctor:.:_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.205166176 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec4_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec4_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec4_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbYaF,
                       label: Data.Traversable.$fTraversableURec4_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYaF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYaG; else goto cbYaH;
       cbYaG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYaH: // global
           I64[Sp - 16] = block_cbYaD_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYaD() //  [R1]
         { info_tbl: [(cbYaD,
                       label: block_cbYaD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYaD: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.206296294 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec3_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec3_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec3_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbYaR,
                       label: Data.Traversable.$fTraversableURec3_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYaR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYaS; else goto cbYaT;
       cbYaS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYaT: // global
           I64[Sp - 16] = block_cbYaP_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYaP() //  [R1]
         { info_tbl: [(cbYaP,
                       label: block_cbYaP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYaP: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.207425133 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec2_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec2_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec2_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbYb3,
                       label: Data.Traversable.$fTraversableURec2_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYb3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYb4; else goto cbYb5;
       cbYb4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYb5: // global
           I64[Sp - 16] = block_cbYb1_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYb1() //  [R1]
         { info_tbl: [(cbYb1,
                       label: block_cbYb1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYb1: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.208604645 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec1_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec1_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbYbf,
                       label: Data.Traversable.$fTraversableURec1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYbf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYbg; else goto cbYbh;
       cbYbg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYbh: // global
           I64[Sp - 16] = block_cbYbd_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYbd() //  [R1]
         { info_tbl: [(cbYbd,
                       label: block_cbYbd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYbd: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.209798071 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec0_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec0_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec0_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbYbr,
                       label: Data.Traversable.$fTraversableURec0_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYbr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYbs; else goto cbYbt;
       cbYbs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYbt: // global
           I64[Sp - 16] = block_cbYbp_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYbp() //  [R1]
         { info_tbl: [(cbYbp,
                       label: block_cbYbp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYbp: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.210920803 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbYbD,
                       label: Data.Traversable.$fTraversableURec_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYbD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYbE; else goto cbYbF;
       cbYbE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYbF: // global
           I64[Sp - 16] = block_cbYbB_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYbB() //  [R1]
         { info_tbl: [(cbYbB,
                       label: block_cbYbB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYbB: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.212155797 UTC

[section ""data" . Data.Traversable.$dmsequence_closure" {
     Data.Traversable.$dmsequence_closure:
         const Data.Traversable.$dmsequence_info;
 },
 sat_sbWYd_entry() //  [R1]
         { info_tbl: [(cbYbR,
                       label: sat_sbWYd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYbR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYbS; else goto cbYbT;
       cbYbS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYbT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$dmsequence_entry() //  [R2, R3]
         { info_tbl: [(cbYbU,
                       label: Data.Traversable.$dmsequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYbU: // global
           _sbWYc::P64 = R3;
           _sbWYb::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbYbV; else goto cbYbW;
       cbYbW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbYbY; else goto cbYbX;
       cbYbY: // global
           HpAlloc = 24;
           goto cbYbV;
       cbYbV: // global
           R3 = _sbWYc::P64;
           R2 = _sbWYb::P64;
           R1 = Data.Traversable.$dmsequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYbX: // global
           I64[Hp - 16] = sat_sbWYd_info;
           P64[Hp] = _sbWYc::P64;
           R2 = _sbWYb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Traversable.sequenceA_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.213740488 UTC

[section ""data" . Data.Traversable.$dmmapM_closure" {
     Data.Traversable.$dmmapM_closure:
         const Data.Traversable.$dmmapM_info;
 },
 sat_sbWYg_entry() //  [R1]
         { info_tbl: [(cbYc7,
                       label: sat_sbWYg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYc7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYc8; else goto cbYc9;
       cbYc8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYc9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$dmmapM_entry() //  [R2, R3]
         { info_tbl: [(cbYca,
                       label: Data.Traversable.$dmmapM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYca: // global
           _sbWYf::P64 = R3;
           _sbWYe::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbYcb; else goto cbYcc;
       cbYcc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbYce; else goto cbYcd;
       cbYce: // global
           HpAlloc = 24;
           goto cbYcb;
       cbYcb: // global
           R3 = _sbWYf::P64;
           R2 = _sbWYe::P64;
           R1 = Data.Traversable.$dmmapM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYcd: // global
           I64[Hp - 16] = sat_sbWYg_info;
           P64[Hp] = _sbWYf::P64;
           R2 = _sbWYe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Traversable.traverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.21497614 UTC

[section ""data" . Data.Traversable.$dmsequenceA_closure" {
     Data.Traversable.$dmsequenceA_closure:
         const Data.Traversable.$dmsequenceA_info;
 },
 Data.Traversable.$dmsequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbYcj,
                       label: Data.Traversable.$dmsequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYcj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYck; else goto cbYcl;
       cbYck: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$dmsequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYcl: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 24;
           call Data.Traversable.traverse_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.215970646 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbYcs,
                       label: Data.Traversable.$fTraversableURec_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYcs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYct; else goto cbYcu;
       cbYct: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYcu: // global
           I64[Sp - 16] = block_cbYcq_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYcq() //  [R1]
         { info_tbl: [(cbYcq,
                       label: block_cbYcq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYcq: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.218920714 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$cmapM_closure" {
     Data.Traversable.$fTraversableURec_$cmapM_closure:
         const Data.Traversable.$fTraversableURec_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYcE,
                       label: Data.Traversable.$fTraversableURec_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYcE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYcI; else goto cbYcJ;
       cbYcI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYcJ: // global
           I64[Sp - 16] = block_cbYcC_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYcC() //  [R1]
         { info_tbl: [(cbYcC,
                       label: block_cbYcC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYcC: // global
           I64[Sp] = block_cbYcH_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYcH() //  [R1]
         { info_tbl: [(cbYcH,
                       label: block_cbYcH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYcH: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.220187567 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$csequence_closure" {
     Data.Traversable.$fTraversableURec_$csequence_closure:
         const Data.Traversable.$fTraversableURec_$csequence_info;
 },
 Data.Traversable.$fTraversableURec_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYcV,
                       label: Data.Traversable.$fTraversableURec_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYcV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYcZ; else goto cbYd0;
       cbYcZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYd0: // global
           I64[Sp - 16] = block_cbYcT_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYcT() //  [R1]
         { info_tbl: [(cbYcT,
                       label: block_cbYcT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYcT: // global
           I64[Sp] = block_cbYcY_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYcY() //  [R1]
         { info_tbl: [(cbYcY,
                       label: block_cbYcY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYcY: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.221218828 UTC

[section ""data" . Data.Traversable.$fTraversableURec_closure" {
     Data.Traversable.$fTraversableURec_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec_closure;
         const Data.Foldable.$fFoldableURec_closure;
         const Data.Traversable.$fTraversableURec_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.222057344 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec0_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec0_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec0_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbYdc,
                       label: Data.Traversable.$fTraversableURec0_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYdc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYdd; else goto cbYde;
       cbYdd: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYde: // global
           I64[Sp - 16] = block_cbYda_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYda() //  [R1]
         { info_tbl: [(cbYda,
                       label: block_cbYda_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYda: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.223180358 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$cmapM_closure" {
     Data.Traversable.$fTraversableURec0_$cmapM_closure:
         const Data.Traversable.$fTraversableURec0_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec0_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYdo,
                       label: Data.Traversable.$fTraversableURec0_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYdo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYds; else goto cbYdt;
       cbYds: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYdt: // global
           I64[Sp - 16] = block_cbYdm_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYdm() //  [R1]
         { info_tbl: [(cbYdm,
                       label: block_cbYdm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYdm: // global
           I64[Sp] = block_cbYdr_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYdr() //  [R1]
         { info_tbl: [(cbYdr,
                       label: block_cbYdr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYdr: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.224447324 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$csequence_closure" {
     Data.Traversable.$fTraversableURec0_$csequence_closure:
         const Data.Traversable.$fTraversableURec0_$csequence_info;
 },
 Data.Traversable.$fTraversableURec0_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYdF,
                       label: Data.Traversable.$fTraversableURec0_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYdF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYdJ; else goto cbYdK;
       cbYdJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYdK: // global
           I64[Sp - 16] = block_cbYdD_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYdD() //  [R1]
         { info_tbl: [(cbYdD,
                       label: block_cbYdD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYdD: // global
           I64[Sp] = block_cbYdI_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYdI() //  [R1]
         { info_tbl: [(cbYdI,
                       label: block_cbYdI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYdI: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.225697912 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_closure" {
     Data.Traversable.$fTraversableURec0_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec0_closure;
         const Data.Foldable.$fFoldableURec0_closure;
         const Data.Traversable.$fTraversableURec0_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec0_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec0_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec0_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.22645576 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec1_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec1_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec1_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbYdW,
                       label: Data.Traversable.$fTraversableURec1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYdW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYdX; else goto cbYdY;
       cbYdX: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYdY: // global
           I64[Sp - 16] = block_cbYdU_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYdU() //  [R1]
         { info_tbl: [(cbYdU,
                       label: block_cbYdU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYdU: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.2275708 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$cmapM_closure" {
     Data.Traversable.$fTraversableURec1_$cmapM_closure:
         const Data.Traversable.$fTraversableURec1_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYe8,
                       label: Data.Traversable.$fTraversableURec1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYe8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYec; else goto cbYed;
       cbYec: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYed: // global
           I64[Sp - 16] = block_cbYe6_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYe6() //  [R1]
         { info_tbl: [(cbYe6,
                       label: block_cbYe6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYe6: // global
           I64[Sp] = block_cbYeb_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYeb() //  [R1]
         { info_tbl: [(cbYeb,
                       label: block_cbYeb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYeb: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.228776862 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$csequence_closure" {
     Data.Traversable.$fTraversableURec1_$csequence_closure:
         const Data.Traversable.$fTraversableURec1_$csequence_info;
 },
 Data.Traversable.$fTraversableURec1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYep,
                       label: Data.Traversable.$fTraversableURec1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYep: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYet; else goto cbYeu;
       cbYet: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYeu: // global
           I64[Sp - 16] = block_cbYen_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYen() //  [R1]
         { info_tbl: [(cbYen,
                       label: block_cbYen_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYen: // global
           I64[Sp] = block_cbYes_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYes() //  [R1]
         { info_tbl: [(cbYes,
                       label: block_cbYes_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYes: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.229844516 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_closure" {
     Data.Traversable.$fTraversableURec1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec1_closure;
         const Data.Foldable.$fFoldableURec1_closure;
         const Data.Traversable.$fTraversableURec1_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec1_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.230617262 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec2_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec2_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec2_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbYeG,
                       label: Data.Traversable.$fTraversableURec2_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYeG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYeH; else goto cbYeI;
       cbYeH: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYeI: // global
           I64[Sp - 16] = block_cbYeE_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYeE() //  [R1]
         { info_tbl: [(cbYeE,
                       label: block_cbYeE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYeE: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.231766831 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$cmapM_closure" {
     Data.Traversable.$fTraversableURec2_$cmapM_closure:
         const Data.Traversable.$fTraversableURec2_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec2_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYeS,
                       label: Data.Traversable.$fTraversableURec2_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYeS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYeW; else goto cbYeX;
       cbYeW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYeX: // global
           I64[Sp - 16] = block_cbYeQ_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYeQ() //  [R1]
         { info_tbl: [(cbYeQ,
                       label: block_cbYeQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYeQ: // global
           I64[Sp] = block_cbYeV_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYeV() //  [R1]
         { info_tbl: [(cbYeV,
                       label: block_cbYeV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYeV: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.233056646 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$csequence_closure" {
     Data.Traversable.$fTraversableURec2_$csequence_closure:
         const Data.Traversable.$fTraversableURec2_$csequence_info;
 },
 Data.Traversable.$fTraversableURec2_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYf9,
                       label: Data.Traversable.$fTraversableURec2_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYf9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYfd; else goto cbYfe;
       cbYfd: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYfe: // global
           I64[Sp - 16] = block_cbYf7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYf7() //  [R1]
         { info_tbl: [(cbYf7,
                       label: block_cbYf7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYf7: // global
           I64[Sp] = block_cbYfc_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYfc() //  [R1]
         { info_tbl: [(cbYfc,
                       label: block_cbYfc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYfc: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.234102481 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_closure" {
     Data.Traversable.$fTraversableURec2_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec2_closure;
         const Data.Foldable.$fFoldableURec2_closure;
         const Data.Traversable.$fTraversableURec2_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec2_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec2_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec2_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.234903496 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec3_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec3_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec3_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbYfq,
                       label: Data.Traversable.$fTraversableURec3_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYfq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYfr; else goto cbYfs;
       cbYfr: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYfs: // global
           I64[Sp - 16] = block_cbYfo_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYfo() //  [R1]
         { info_tbl: [(cbYfo,
                       label: block_cbYfo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYfo: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.236026919 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$cmapM_closure" {
     Data.Traversable.$fTraversableURec3_$cmapM_closure:
         const Data.Traversable.$fTraversableURec3_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec3_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYfC,
                       label: Data.Traversable.$fTraversableURec3_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYfC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYfG; else goto cbYfH;
       cbYfG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYfH: // global
           I64[Sp - 16] = block_cbYfA_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYfA() //  [R1]
         { info_tbl: [(cbYfA,
                       label: block_cbYfA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYfA: // global
           I64[Sp] = block_cbYfF_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYfF() //  [R1]
         { info_tbl: [(cbYfF,
                       label: block_cbYfF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYfF: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.23727567 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$csequence_closure" {
     Data.Traversable.$fTraversableURec3_$csequence_closure:
         const Data.Traversable.$fTraversableURec3_$csequence_info;
 },
 Data.Traversable.$fTraversableURec3_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYfT,
                       label: Data.Traversable.$fTraversableURec3_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYfT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYfX; else goto cbYfY;
       cbYfX: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYfY: // global
           I64[Sp - 16] = block_cbYfR_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYfR() //  [R1]
         { info_tbl: [(cbYfR,
                       label: block_cbYfR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYfR: // global
           I64[Sp] = block_cbYfW_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYfW() //  [R1]
         { info_tbl: [(cbYfW,
                       label: block_cbYfW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYfW: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.238255403 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_closure" {
     Data.Traversable.$fTraversableURec3_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec3_closure;
         const Data.Foldable.$fFoldableURec3_closure;
         const Data.Traversable.$fTraversableURec3_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec3_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec3_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec3_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.23906386 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec4_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec4_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec4_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbYga,
                       label: Data.Traversable.$fTraversableURec4_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYga: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYgb; else goto cbYgc;
       cbYgb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYgc: // global
           I64[Sp - 16] = block_cbYg8_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYg8() //  [R1]
         { info_tbl: [(cbYg8,
                       label: block_cbYg8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYg8: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.240214553 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$cmapM_closure" {
     Data.Traversable.$fTraversableURec4_$cmapM_closure:
         const Data.Traversable.$fTraversableURec4_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec4_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYgm,
                       label: Data.Traversable.$fTraversableURec4_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYgm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYgq; else goto cbYgr;
       cbYgq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYgr: // global
           I64[Sp - 16] = block_cbYgk_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYgk() //  [R1]
         { info_tbl: [(cbYgk,
                       label: block_cbYgk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYgk: // global
           I64[Sp] = block_cbYgp_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYgp() //  [R1]
         { info_tbl: [(cbYgp,
                       label: block_cbYgp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYgp: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.24152984 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$csequence_closure" {
     Data.Traversable.$fTraversableURec4_$csequence_closure:
         const Data.Traversable.$fTraversableURec4_$csequence_info;
 },
 Data.Traversable.$fTraversableURec4_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYgD,
                       label: Data.Traversable.$fTraversableURec4_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYgD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYgH; else goto cbYgI;
       cbYgH: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYgI: // global
           I64[Sp - 16] = block_cbYgB_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYgB() //  [R1]
         { info_tbl: [(cbYgB,
                       label: block_cbYgB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYgB: // global
           I64[Sp] = block_cbYgG_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYgG() //  [R1]
         { info_tbl: [(cbYgG,
                       label: block_cbYgG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYgG: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.24253257 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_closure" {
     Data.Traversable.$fTraversableURec4_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec4_closure;
         const Data.Foldable.$fFoldableURec4_closure;
         const Data.Traversable.$fTraversableURec4_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec4_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec4_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec4_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.24327708 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$csequenceA_closure" {
     Data.Traversable.$fTraversable:.:_$csequenceA_closure:
         const Data.Traversable.$fTraversable:.:_$csequenceA_info;
 },
 Data.Traversable.$fTraversable:.:_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cbYgS,
                       label: Data.Traversable.$fTraversable:.:_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYgS: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.244206713 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$cmapM_closure" {
     Data.Traversable.$fTraversable:.:_$cmapM_closure:
         const Data.Traversable.$fTraversable:.:_$cmapM_info;
 },
 Data.Traversable.$fTraversable:.:_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cbYh1,
                       label: Data.Traversable.$fTraversable:.:_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYh1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbYh2; else goto cbYh3;
       cbYh2: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYh3: // global
           I64[Sp - 40] = block_cbYgZ_info;
           _sbX06::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sbX06::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYgZ() //  [R1]
         { info_tbl: [(cbYgZ,
                       label: block_cbYgZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYgZ: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.245508555 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$csequence_closure" {
     Data.Traversable.$fTraversable:.:_$csequence_closure:
         const Data.Traversable.$fTraversable:.:_$csequence_info;
 },
 Data.Traversable.$fTraversable:.:_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cbYhd,
                       label: Data.Traversable.$fTraversable:.:_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYhd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYhe; else goto cbYhf;
       cbYhe: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYhf: // global
           I64[Sp - 32] = block_cbYhb_info;
           _sbX0c::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sbX0c::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYhb() //  [R1]
         { info_tbl: [(cbYhb,
                       label: block_cbYhb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYhb: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.24750066 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_closure" {
     Data.Traversable.$fTraversable:.:_closure:
         const Data.Traversable.$fTraversable:.:_info;
         const 0;
 },
 sat_sbX0o_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYhs,
                       label: sat_sbX0o_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYhs: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:.:_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0n_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbYhA,
                       label: sat_sbX0n_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYhA: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:.:_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0m_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYhI,
                       label: sat_sbX0m_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYhI: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:.:_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0l_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbYhQ,
                       label: sat_sbX0l_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYhQ: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0k_entry() //  [R1]
         { info_tbl: [(cbYhX,
                       label: sat_sbX0k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYhX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYhY; else goto cbYhZ;
       cbYhY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYhZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:.:_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX0j_entry() //  [R1]
         { info_tbl: [(cbYi4,
                       label: sat_sbX0j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYi4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYi5; else goto cbYi6;
       cbYi5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYi6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:.:_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_entry() //  [R2, R3]
         { info_tbl: [(cbYi8,
                       label: Data.Traversable.$fTraversable:.:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYi8: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cbYic; else goto cbYib;
       cbYic: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYib: // global
           I64[Hp - 208] = sat_sbX0o_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sbX0n_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sbX0m_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sbX0l_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sbX0k_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sbX0j_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.250050867 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$csequenceA_closure" {
     Data.Traversable.$fTraversable:*:_$csequenceA_closure:
         const Data.Traversable.$fTraversable:*:_$csequenceA_info;
 },
 Data.Traversable.$fTraversable:*:_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cbYik,
                       label: Data.Traversable.$fTraversable:*:_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYik: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYil; else goto cbYim;
       cbYil: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$csequenceA_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYim: // global
           I64[Sp - 32] = block_cbYih_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubYiq; else goto cbYii;
       ubYiq: // global
           call _cbYih(R1) args: 0, res: 0, upd: 0;
       cbYii: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYih() //  [R1]
         { info_tbl: [(cbYih,
                       label: block_cbYih_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYih: // global
           R6 = P64[R1 + 7];
           R5 = GHC.Base.id_closure+1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.25140863 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$cmapM_closure" {
     Data.Traversable.$fTraversable:*:_$cmapM_closure:
         const Data.Traversable.$fTraversable:*:_$cmapM_info;
 },
 Data.Traversable.$fTraversable:*:_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cbYiy,
                       label: Data.Traversable.$fTraversable:*:_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYiy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbYiC; else goto cbYiD;
       cbYiC: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYiD: // global
           I64[Sp - 40] = block_cbYiv_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubYiJ; else goto cbYiw;
       ubYiJ: // global
           call _cbYiv(R1) args: 0, res: 0, upd: 0;
       cbYiw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYiv() //  [R1]
         { info_tbl: [(cbYiv,
                       label: block_cbYiv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYiv: // global
           I64[Sp - 8] = block_cbYiB_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYiB() //  [R1]
         { info_tbl: [(cbYiB,
                       label: block_cbYiB_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYiB: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 40];
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.252982082 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$csequence_closure" {
     Data.Traversable.$fTraversable:*:_$csequence_closure:
         const Data.Traversable.$fTraversable:*:_$csequence_info;
 },
 Data.Traversable.$fTraversable:*:_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cbYiR,
                       label: Data.Traversable.$fTraversable:*:_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYiR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbYiV; else goto cbYiW;
       cbYiV: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYiW: // global
           I64[Sp - 32] = block_cbYiO_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubYj2; else goto cbYiP;
       ubYj2: // global
           call _cbYiO(R1) args: 0, res: 0, upd: 0;
       cbYiP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYiO() //  [R1]
         { info_tbl: [(cbYiO,
                       label: block_cbYiO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYiO: // global
           I64[Sp - 8] = block_cbYiU_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYiU() //  [R1]
         { info_tbl: [(cbYiU,
                       label: block_cbYiU_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYiU: // global
           R6 = P64[Sp + 32];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.255177862 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_closure" {
     Data.Traversable.$fTraversable:*:_closure:
         const Data.Traversable.$fTraversable:*:_info;
         const 0;
 },
 sat_sbX0U_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYjc,
                       label: sat_sbX0U_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYjc: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:*:_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0T_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbYjk,
                       label: sat_sbX0T_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYjk: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:*:_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0S_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYjs,
                       label: sat_sbX0S_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYjs: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:*:_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0R_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbYjA,
                       label: sat_sbX0R_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYjA: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:*:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0Q_entry() //  [R1]
         { info_tbl: [(cbYjH,
                       label: sat_sbX0Q_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYjH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYjI; else goto cbYjJ;
       cbYjI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYjJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:*:_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX0P_entry() //  [R1]
         { info_tbl: [(cbYjO,
                       label: sat_sbX0P_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYjO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYjP; else goto cbYjQ;
       cbYjP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYjQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:*:_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:*:_entry() //  [R2, R3]
         { info_tbl: [(cbYjS,
                       label: Data.Traversable.$fTraversable:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYjS: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cbYjW; else goto cbYjV;
       cbYjW: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYjV: // global
           I64[Hp - 208] = sat_sbX0U_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sbX0T_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sbX0S_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sbX0R_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sbX0Q_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sbX0P_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.258034113 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$csequenceA_closure" {
     Data.Traversable.$fTraversable:+:_$csequenceA_closure:
         const Data.Traversable.$fTraversable:+:_$csequenceA_info;
 },
 Data.Traversable.$fTraversable:+:_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cbYk1,
                       label: Data.Traversable.$fTraversable:+:_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYk1: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.259041761 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$cmapM_closure" {
     Data.Traversable.$fTraversable:+:_$cmapM_closure:
         const Data.Traversable.$fTraversable:+:_$cmapM_info;
 },
 Data.Traversable.$fTraversable:+:_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cbYka,
                       label: Data.Traversable.$fTraversable:+:_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYka: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbYkb; else goto cbYkc;
       cbYkb: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYkc: // global
           I64[Sp - 40] = block_cbYk8_info;
           _sbX0Y::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sbX0Y::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYk8() //  [R1]
         { info_tbl: [(cbYk8,
                       label: block_cbYk8_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYk8: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.260320355 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$csequence_closure" {
     Data.Traversable.$fTraversable:+:_$csequence_closure:
         const Data.Traversable.$fTraversable:+:_$csequence_info;
 },
 Data.Traversable.$fTraversable:+:_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cbYkm,
                       label: Data.Traversable.$fTraversable:+:_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYkm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYkn; else goto cbYko;
       cbYkn: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYko: // global
           I64[Sp - 32] = block_cbYkk_info;
           _sbX14::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sbX14::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYkk() //  [R1]
         { info_tbl: [(cbYkk,
                       label: block_cbYkk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYkk: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.262268805 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_closure" {
     Data.Traversable.$fTraversable:+:_closure:
         const Data.Traversable.$fTraversable:+:_info;
         const 0;
 },
 sat_sbX1g_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYkB,
                       label: sat_sbX1g_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYkB: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:+:_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1f_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbYkJ,
                       label: sat_sbX1f_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYkJ: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:+:_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1e_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYkR,
                       label: sat_sbX1e_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYkR: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:+:_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1d_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbYkZ,
                       label: sat_sbX1d_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYkZ: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1c_entry() //  [R1]
         { info_tbl: [(cbYl6,
                       label: sat_sbX1c_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYl6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYl7; else goto cbYl8;
       cbYl7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYl8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:+:_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX1b_entry() //  [R1]
         { info_tbl: [(cbYld,
                       label: sat_sbX1b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYld: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYle; else goto cbYlf;
       cbYle: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYlf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:+:_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_entry() //  [R2, R3]
         { info_tbl: [(cbYlh,
                       label: Data.Traversable.$fTraversable:+:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYlh: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cbYll; else goto cbYlk;
       cbYll: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYlk: // global
           I64[Hp - 208] = sat_sbX1g_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sbX1f_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sbX1e_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sbX1d_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sbX1c_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sbX1b_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.264887307 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$csequenceA_closure" {
     Data.Traversable.$fTraversableM1_$csequenceA_closure:
         const Data.Traversable.$fTraversableM1_$csequenceA_info;
 },
 sat_sbX1l_entry() //  [R1]
         { info_tbl: [(cbYlu,
                       label: sat_sbX1l_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYlu: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbYlv; else goto cbYlw;
       cbYlv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYlw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$csequenceA_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbYlz,
                       label: Data.Traversable.$fTraversableM1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYlz: // global
           _sbX1j::P64 = R4;
           _sbX1i::P64 = R3;
           _sbX1h::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYlA; else goto cbYlB;
       cbYlB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbYlD; else goto cbYlC;
       cbYlD: // global
           HpAlloc = 40;
           goto cbYlA;
       cbYlA: // global
           R4 = _sbX1j::P64;
           R3 = _sbX1i::P64;
           R2 = _sbX1h::P64;
           R1 = Data.Traversable.$fTraversableM1_$csequenceA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYlC: // global
           I64[Hp - 32] = sat_sbX1l_info;
           P64[Hp - 16] = _sbX1h::P64;
           P64[Hp - 8] = _sbX1i::P64;
           P64[Hp] = _sbX1j::P64;
           I64[Sp - 16] = block_cbYlx_info;
           R2 = _sbX1i::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYlx() //  [R1]
         { info_tbl: [(cbYlx,
                       label: block_cbYlx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYlx: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.266724993 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$cmapM_closure" {
     Data.Traversable.$fTraversableM1_$cmapM_closure:
         const Data.Traversable.$fTraversableM1_$cmapM_info;
 },
 sat_sbX1s_entry() //  [R1]
         { info_tbl: [(cbYlT,
                       label: sat_sbX1s_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYlT: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbYlU; else goto cbYlV;
       cbYlU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYlV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$cmapM_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cbYlW,
                       label: Data.Traversable.$fTraversableM1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYlW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYlY; else goto cbYlZ;
       cbYlY: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$cmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYlZ: // global
           I64[Sp - 32] = block_cbYlL_info;
           _sbX1m::P64 = R2;
           R2 = R3;
           P64[Sp - 24] = _sbX1m::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYlL() //  [R1]
         { info_tbl: [(cbYlL,
                       label: block_cbYlL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYlL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbYm2; else goto cbYm1;
       cbYm2: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYm1: // global
           I64[Hp - 40] = sat_sbX1s_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           I64[Sp + 16] = block_cbYlX_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 40;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYlX() //  [R1]
         { info_tbl: [(cbYlX,
                       label: block_cbYlX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYlX: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.268672146 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$csequence_closure" {
     Data.Traversable.$fTraversableM1_$csequence_closure:
         const Data.Traversable.$fTraversableM1_$csequence_info;
 },
 sat_sbX1y_entry() //  [R1]
         { info_tbl: [(cbYmj,
                       label: sat_sbX1y_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYmj: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbYmk; else goto cbYml;
       cbYmk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYml: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$csequence_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbYmm,
                       label: Data.Traversable.$fTraversableM1_$csequence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYmm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYmo; else goto cbYmp;
       cbYmo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$csequence_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYmp: // global
           I64[Sp - 24] = block_cbYmb_info;
           _sbX1t::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _sbX1t::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYmb() //  [R1]
         { info_tbl: [(cbYmb,
                       label: block_cbYmb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYmb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbYms; else goto cbYmr;
       cbYms: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYmr: // global
           I64[Hp - 32] = sat_sbX1y_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbYmn_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYmn() //  [R1]
         { info_tbl: [(cbYmn,
                       label: block_cbYmn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYmn: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.271252171 UTC

[section ""data" . Data.Traversable.$fTraversableM1_closure" {
     Data.Traversable.$fTraversableM1_closure:
         const Data.Traversable.$fTraversableM1_info;
         const 0;
 },
 sat_sbX1F_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYmG,
                       label: sat_sbX1F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYmG: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableM1_$csequence_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1E_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbYmO,
                       label: sat_sbX1E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYmO: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableM1_$cmapM_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1D_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYmW,
                       label: sat_sbX1D_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYmW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableM1_$csequenceA_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1C_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbYn4,
                       label: sat_sbX1C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYn4: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableM1_$ctraverse_entry(R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1B_entry() //  [R1]
         { info_tbl: [(cbYnb,
                       label: sat_sbX1B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYnb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYnc; else goto cbYnd;
       cbYnc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYnd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableM1_$cp2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX1A_entry() //  [R1]
         { info_tbl: [(cbYni,
                       label: sat_sbX1A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYni: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYnj; else goto cbYnk;
       cbYnj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYnk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableM1_$cp1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_entry() //  [R2]
         { info_tbl: [(cbYnm,
                       label: Data.Traversable.$fTraversableM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYnm: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbYnq; else goto cbYnp;
       cbYnq: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYnp: // global
           I64[Hp - 160] = sat_sbX1F_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sbX1E_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbX1D_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbX1C_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbX1B_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbX1A_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 96;
           P64[Hp - 24] = Hp - 109;
           P64[Hp - 16] = Hp - 126;
           P64[Hp - 8] = Hp - 141;
           P64[Hp] = Hp - 158;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.273550426 UTC

[section ""data" . Data.Traversable.$fTraversableK1_$cmapM_closure" {
     Data.Traversable.$fTraversableK1_$cmapM_closure:
         const Data.Traversable.$fTraversableK1_$cmapM_info;
 },
 Data.Traversable.$fTraversableK1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYnx,
                       label: Data.Traversable.$fTraversableK1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYnx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYny; else goto cbYnz;
       cbYny: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableK1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYnz: // global
           I64[Sp - 16] = block_cbYnv_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYnv() //  [R1]
         { info_tbl: [(cbYnv,
                       label: block_cbYnv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYnv: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.274652192 UTC

[section ""data" . Data.Traversable.$fTraversableK1_$csequence_closure" {
     Data.Traversable.$fTraversableK1_$csequence_closure:
         const Data.Traversable.$fTraversableK1_$csequence_info;
 },
 Data.Traversable.$fTraversableK1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYnJ,
                       label: Data.Traversable.$fTraversableK1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYnJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYnK; else goto cbYnL;
       cbYnK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableK1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYnL: // global
           I64[Sp - 16] = block_cbYnH_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYnH() //  [R1]
         { info_tbl: [(cbYnH,
                       label: block_cbYnH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYnH: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.27569367 UTC

[section ""data" . $fTraversableK2_rbWTS_closure" {
     $fTraversableK2_rbWTS_closure:
         const $fTraversableK2_rbWTS_info;
 },
 $fTraversableK2_rbWTS_entry() //  [R2, R3]
         { info_tbl: [(cbYnT,
                       label: $fTraversableK2_rbWTS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYnT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYnU; else goto cbYnV;
       cbYnU: // global
           R3 = R3;
           R2 = R2;
           R1 = $fTraversableK2_rbWTS_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYnV: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.27836281 UTC

[section ""data" . Data.Traversable.$fTraversableK1_closure" {
     Data.Traversable.$fTraversableK1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorK1_closure;
         const Data.Foldable.$fFoldableK1_closure;
         const Data.Traversable.$fTraversableK1_$ctraverse_closure+3;
         const $fTraversableK2_rbWTS_closure+2;
         const Data.Traversable.$fTraversableK1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableK1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.279348383 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$csequenceA_closure" {
     Data.Traversable.$fTraversableRec1_$csequenceA_closure:
         const Data.Traversable.$fTraversableRec1_$csequenceA_info;
 },
 sat_sbX1T_entry() //  [R1]
         { info_tbl: [(cbYo4,
                       label: sat_sbX1T_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYo4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbYo5; else goto cbYo6;
       cbYo5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYo6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$csequenceA_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbYo9,
                       label: Data.Traversable.$fTraversableRec1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYo9: // global
           _sbX1R::P64 = R4;
           _sbX1Q::P64 = R3;
           _sbX1P::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYoa; else goto cbYob;
       cbYob: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbYod; else goto cbYoc;
       cbYod: // global
           HpAlloc = 40;
           goto cbYoa;
       cbYoa: // global
           R4 = _sbX1R::P64;
           R3 = _sbX1Q::P64;
           R2 = _sbX1P::P64;
           R1 = Data.Traversable.$fTraversableRec1_$csequenceA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYoc: // global
           I64[Hp - 32] = sat_sbX1T_info;
           P64[Hp - 16] = _sbX1P::P64;
           P64[Hp - 8] = _sbX1Q::P64;
           P64[Hp] = _sbX1R::P64;
           I64[Sp - 16] = block_cbYo7_info;
           R2 = _sbX1Q::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYo7() //  [R1]
         { info_tbl: [(cbYo7,
                       label: block_cbYo7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYo7: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.281172093 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$cmapM_closure" {
     Data.Traversable.$fTraversableRec1_$cmapM_closure:
         const Data.Traversable.$fTraversableRec1_$cmapM_info;
 },
 sat_sbX20_entry() //  [R1]
         { info_tbl: [(cbYot,
                       label: sat_sbX20_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYot: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbYou; else goto cbYov;
       cbYou: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYov: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$cmapM_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cbYow,
                       label: Data.Traversable.$fTraversableRec1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYow: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYoy; else goto cbYoz;
       cbYoy: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$cmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYoz: // global
           I64[Sp - 32] = block_cbYol_info;
           _sbX1U::P64 = R2;
           R2 = R3;
           P64[Sp - 24] = _sbX1U::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYol() //  [R1]
         { info_tbl: [(cbYol,
                       label: block_cbYol_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYol: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbYoC; else goto cbYoB;
       cbYoC: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYoB: // global
           I64[Hp - 40] = sat_sbX20_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           I64[Sp + 16] = block_cbYox_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 40;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYox() //  [R1]
         { info_tbl: [(cbYox,
                       label: block_cbYox_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYox: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.283317543 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$csequence_closure" {
     Data.Traversable.$fTraversableRec1_$csequence_closure:
         const Data.Traversable.$fTraversableRec1_$csequence_info;
 },
 sat_sbX26_entry() //  [R1]
         { info_tbl: [(cbYoT,
                       label: sat_sbX26_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYoT: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbYoU; else goto cbYoV;
       cbYoU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYoV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$csequence_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbYoW,
                       label: Data.Traversable.$fTraversableRec1_$csequence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYoW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYoY; else goto cbYoZ;
       cbYoY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$csequence_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYoZ: // global
           I64[Sp - 24] = block_cbYoL_info;
           _sbX21::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _sbX21::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYoL() //  [R1]
         { info_tbl: [(cbYoL,
                       label: block_cbYoL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYoL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbYp2; else goto cbYp1;
       cbYp2: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYp1: // global
           I64[Hp - 32] = sat_sbX26_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbYoX_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYoX() //  [R1]
         { info_tbl: [(cbYoX,
                       label: block_cbYoX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYoX: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.285642568 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_closure" {
     Data.Traversable.$fTraversableRec1_closure:
         const Data.Traversable.$fTraversableRec1_info;
         const 0;
 },
 sat_sbX2d_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYpg,
                       label: sat_sbX2d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYpg: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableRec1_$csequence_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX2c_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbYpo,
                       label: sat_sbX2c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYpo: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableRec1_$cmapM_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX2b_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYpw,
                       label: sat_sbX2b_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYpw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableRec1_$csequenceA_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX2a_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbYpE,
                       label: sat_sbX2a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYpE: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableRec1_$ctraverse_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX29_entry() //  [R1]
         { info_tbl: [(cbYpL,
                       label: sat_sbX29_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYpL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYpM; else goto cbYpN;
       cbYpM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYpN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableRec1_$cp2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX28_entry() //  [R1]
         { info_tbl: [(cbYpS,
                       label: sat_sbX28_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYpS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYpT; else goto cbYpU;
       cbYpT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYpU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableRec1_$cp1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_entry() //  [R2]
         { info_tbl: [(cbYpW,
                       label: Data.Traversable.$fTraversableRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYpW: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbYq0; else goto cbYpZ;
       cbYq0: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYpZ: // global
           I64[Hp - 160] = sat_sbX2d_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sbX2c_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbX2b_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbX2a_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbX29_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbX28_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 96;
           P64[Hp - 24] = Hp - 109;
           P64[Hp - 16] = Hp - 126;
           P64[Hp - 8] = Hp - 141;
           P64[Hp] = Hp - 158;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.287796205 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$csequenceA_closure" {
     Data.Traversable.$fTraversablePar1_$csequenceA_closure:
         const Data.Traversable.$fTraversablePar1_$csequenceA_info;
 },
 Data.Traversable.$fTraversablePar1_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbYq7,
                       label: Data.Traversable.$fTraversablePar1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYq7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYq8; else goto cbYq9;
       cbYq8: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversablePar1_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYq9: // global
           I64[Sp - 16] = block_cbYq5_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYq5() //  [R1]
         { info_tbl: [(cbYq5,
                       label: block_cbYq5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYq5: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.288967451 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$cmapM_closure" {
     Data.Traversable.$fTraversablePar1_$cmapM_closure:
         const Data.Traversable.$fTraversablePar1_$cmapM_info;
 },
 Data.Traversable.$fTraversablePar1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYqk,
                       label: Data.Traversable.$fTraversablePar1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYqk: // global
           _sbX2j::P64 = R4;
           _sbX2i::P64 = R3;
           _sbX2h::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYqo; else goto cbYqp;
       cbYqp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYqr; else goto cbYqq;
       cbYqr: // global
           HpAlloc = 32;
           goto cbYqo;
       cbYqo: // global
           R4 = _sbX2j::P64;
           R3 = _sbX2i::P64;
           R2 = _sbX2h::P64;
           R1 = Data.Traversable.$fTraversablePar1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYqq: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX2i::P64;
           P64[Hp] = _sbX2j::P64;
           I64[Sp - 16] = block_cbYqi_info;
           R2 = _sbX2h::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYqi() //  [R1]
         { info_tbl: [(cbYqi,
                       label: block_cbYqi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYqi: // global
           I64[Sp] = block_cbYqn_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYqn() //  [R1]
         { info_tbl: [(cbYqn,
                       label: block_cbYqn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYqn: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.290351162 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$csequence_closure" {
     Data.Traversable.$fTraversablePar1_$csequence_closure:
         const Data.Traversable.$fTraversablePar1_$csequence_info;
 },
 Data.Traversable.$fTraversablePar1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYqD,
                       label: Data.Traversable.$fTraversablePar1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYqD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYqH; else goto cbYqI;
       cbYqH: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversablePar1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYqI: // global
           I64[Sp - 16] = block_cbYqB_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYqB() //  [R1]
         { info_tbl: [(cbYqB,
                       label: block_cbYqB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYqB: // global
           I64[Sp] = block_cbYqG_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYqG() //  [R1]
         { info_tbl: [(cbYqG,
                       label: block_cbYqG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYqG: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.291413834 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_closure" {
     Data.Traversable.$fTraversablePar1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorPar1_closure;
         const Data.Foldable.$fFoldablePar1_closure;
         const Data.Traversable.$fTraversablePar1_$ctraverse_closure+3;
         const Data.Traversable.$fTraversablePar1_$csequenceA_closure+2;
         const Data.Traversable.$fTraversablePar1_$cmapM_closure+3;
         const Data.Traversable.$fTraversablePar1_$csequence_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.292192639 UTC

[section ""data" . Data.Traversable.$fTraversableV1_$cmapM_closure" {
     Data.Traversable.$fTraversableV1_$cmapM_closure:
         const Data.Traversable.$fTraversableV1_$cmapM_info;
 },
 Data.Traversable.$fTraversableV1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYqU,
                       label: Data.Traversable.$fTraversableV1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYqU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYqV; else goto cbYqW;
       cbYqV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableV1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYqW: // global
           I64[Sp - 16] = block_cbYqS_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYqS() //  [R1]
         { info_tbl: [(cbYqS,
                       label: block_cbYqS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYqS: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.293522147 UTC

[section ""data" . Data.Traversable.$fTraversableV1_$csequence_closure" {
     Data.Traversable.$fTraversableV1_$csequence_closure:
         const Data.Traversable.$fTraversableV1_$csequence_info;
 },
 Data.Traversable.$fTraversableV1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYr6,
                       label: Data.Traversable.$fTraversableV1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYr6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYr7; else goto cbYr8;
       cbYr7: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableV1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYr8: // global
           I64[Sp - 16] = block_cbYr4_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYr4() //  [R1]
         { info_tbl: [(cbYr4,
                       label: block_cbYr4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYr4: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.29453846 UTC

[section ""data" . $fTraversableV2_rbWTT_closure" {
     $fTraversableV2_rbWTT_closure:
         const $fTraversableV2_rbWTT_info;
 },
 $fTraversableV2_rbWTT_entry() //  [R2, R3]
         { info_tbl: [(cbYrg,
                       label: $fTraversableV2_rbWTT_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYrg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYrh; else goto cbYri;
       cbYrh: // global
           R3 = R3;
           R2 = R2;
           R1 = $fTraversableV2_rbWTT_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYri: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.295336945 UTC

[section ""data" . Data.Traversable.$fTraversableV1_closure" {
     Data.Traversable.$fTraversableV1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorV1_closure;
         const Data.Foldable.$fFoldableV1_closure;
         const Data.Traversable.$fTraversableV1_$ctraverse_closure+3;
         const $fTraversableV2_rbWTT_closure+2;
         const Data.Traversable.$fTraversableV1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableV1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.296088087 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$csequenceA_closure" {
     Data.Traversable.$fTraversableIdentity_$csequenceA_closure:
         const Data.Traversable.$fTraversableIdentity_$csequenceA_info;
 },
 Data.Traversable.$fTraversableIdentity_$csequenceA_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cbYrp,
                       label: Data.Traversable.$fTraversableIdentity_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYrp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYrq; else goto cbYrr;
       cbYrq: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableIdentity_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYrr: // global
           I64[Sp - 16] = block_cbYrn_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYrn() //  [R1]
         { info_tbl: [(cbYrn,
                       label: block_cbYrn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYrn: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.297302251 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$cmapM_closure" {
     Data.Traversable.$fTraversableIdentity_$cmapM_closure:
         const Data.Traversable.$fTraversableIdentity_$cmapM_info;
 },
 Data.Traversable.$fTraversableIdentity_$cmapM_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbYrC,
                       label: Data.Traversable.$fTraversableIdentity_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYrC: // global
           _sbX2F::P64 = R4;
           _sbX2E::P64 = R3;
           _sbX2D::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYrG; else goto cbYrH;
       cbYrH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYrJ; else goto cbYrI;
       cbYrJ: // global
           HpAlloc = 32;
           goto cbYrG;
       cbYrG: // global
           R4 = _sbX2F::P64;
           R3 = _sbX2E::P64;
           R2 = _sbX2D::P64;
           R1 = Data.Traversable.$fTraversableIdentity_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYrI: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX2E::P64;
           P64[Hp] = _sbX2F::P64;
           I64[Sp - 16] = block_cbYrA_info;
           R2 = _sbX2D::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYrA() //  [R1]
         { info_tbl: [(cbYrA,
                       label: block_cbYrA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYrA: // global
           I64[Sp] = block_cbYrF_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYrF() //  [R1]
         { info_tbl: [(cbYrF,
                       label: block_cbYrF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYrF: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.298680611 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$csequence_closure" {
     Data.Traversable.$fTraversableIdentity_$csequence_closure:
         const Data.Traversable.$fTraversableIdentity_$csequence_info;
 },
 Data.Traversable.$fTraversableIdentity_$csequence_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbYrV,
                       label: Data.Traversable.$fTraversableIdentity_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYrV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYrZ; else goto cbYs0;
       cbYrZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableIdentity_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYs0: // global
           I64[Sp - 16] = block_cbYrT_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYrT() //  [R1]
         { info_tbl: [(cbYrT,
                       label: block_cbYrT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYrT: // global
           I64[Sp] = block_cbYrY_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYrY() //  [R1]
         { info_tbl: [(cbYrY,
                       label: block_cbYrY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYrY: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.299763851 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_closure" {
     Data.Traversable.$fTraversableIdentity_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Functor.Identity.$fFunctorIdentity_closure;
         const Data.Functor.Identity.$fFoldableIdentity_closure;
         const Data.Traversable.$fTraversableIdentity_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableIdentity_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableIdentity_$cmapM_closure+3;
         const Data.Traversable.$fTraversableIdentity_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.300553229 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$csequenceA_closure" {
     Data.Traversable.$fTraversableProduct_$csequenceA_closure:
         const Data.Traversable.$fTraversableProduct_$csequenceA_info;
 },
 Data.Traversable.$fTraversableProduct_$csequenceA_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbYsc,
                       label: Data.Traversable.$fTraversableProduct_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYsc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYsd; else goto cbYse;
       cbYsd: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProduct_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYse: // global
           I64[Sp - 16] = block_cbYsa_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYsa() //  [R1]
         { info_tbl: [(cbYsa,
                       label: block_cbYsa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYsa: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.301790689 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$cmapM_closure" {
     Data.Traversable.$fTraversableProduct_$cmapM_closure:
         const Data.Traversable.$fTraversableProduct_$cmapM_info;
 },
 Data.Traversable.$fTraversableProduct_$cmapM_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbYsp,
                       label: Data.Traversable.$fTraversableProduct_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYsp: // global
           _sbX2S::P64 = R4;
           _sbX2R::P64 = R3;
           _sbX2Q::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYst; else goto cbYsu;
       cbYsu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYsw; else goto cbYsv;
       cbYsw: // global
           HpAlloc = 32;
           goto cbYst;
       cbYst: // global
           R4 = _sbX2S::P64;
           R3 = _sbX2R::P64;
           R2 = _sbX2Q::P64;
           R1 = Data.Traversable.$fTraversableProduct_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYsv: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX2R::P64;
           P64[Hp] = _sbX2S::P64;
           I64[Sp - 16] = block_cbYsn_info;
           R2 = _sbX2Q::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYsn() //  [R1]
         { info_tbl: [(cbYsn,
                       label: block_cbYsn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYsn: // global
           I64[Sp] = block_cbYss_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYss() //  [R1]
         { info_tbl: [(cbYss,
                       label: block_cbYss_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYss: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.303169078 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$csequence_closure" {
     Data.Traversable.$fTraversableProduct_$csequence_closure:
         const Data.Traversable.$fTraversableProduct_$csequence_info;
 },
 Data.Traversable.$fTraversableProduct_$csequence_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cbYsI,
                       label: Data.Traversable.$fTraversableProduct_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYsI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYsM; else goto cbYsN;
       cbYsM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProduct_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYsN: // global
           I64[Sp - 16] = block_cbYsG_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYsG() //  [R1]
         { info_tbl: [(cbYsG,
                       label: block_cbYsG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYsG: // global
           I64[Sp] = block_cbYsL_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYsL() //  [R1]
         { info_tbl: [(cbYsL,
                       label: block_cbYsL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYsL: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.304187408 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_closure" {
     Data.Traversable.$fTraversableProduct_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Semigroup.Internal.$fFunctorProduct_closure;
         const Data.Foldable.$fFoldableProduct_closure;
         const Data.Traversable.$fTraversableProduct_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableProduct_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableProduct_$cmapM_closure+3;
         const Data.Traversable.$fTraversableProduct_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.304960824 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$csequenceA_closure" {
     Data.Traversable.$fTraversableSum_$csequenceA_closure:
         const Data.Traversable.$fTraversableSum_$csequenceA_info;
 },
 Data.Traversable.$fTraversableSum_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbYsZ,
                       label: Data.Traversable.$fTraversableSum_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYsZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYt0; else goto cbYt1;
       cbYt0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableSum_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYt1: // global
           I64[Sp - 16] = block_cbYsX_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYsX() //  [R1]
         { info_tbl: [(cbYsX,
                       label: block_cbYsX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYsX: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.306349415 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$cmapM_closure" {
     Data.Traversable.$fTraversableSum_$cmapM_closure:
         const Data.Traversable.$fTraversableSum_$cmapM_info;
 },
 Data.Traversable.$fTraversableSum_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYtc,
                       label: Data.Traversable.$fTraversableSum_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYtc: // global
           _sbX35::P64 = R4;
           _sbX34::P64 = R3;
           _sbX33::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYtg; else goto cbYth;
       cbYth: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYtj; else goto cbYti;
       cbYtj: // global
           HpAlloc = 32;
           goto cbYtg;
       cbYtg: // global
           R4 = _sbX35::P64;
           R3 = _sbX34::P64;
           R2 = _sbX33::P64;
           R1 = Data.Traversable.$fTraversableSum_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYti: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX34::P64;
           P64[Hp] = _sbX35::P64;
           I64[Sp - 16] = block_cbYta_info;
           R2 = _sbX33::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYta() //  [R1]
         { info_tbl: [(cbYta,
                       label: block_cbYta_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYta: // global
           I64[Sp] = block_cbYtf_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYtf() //  [R1]
         { info_tbl: [(cbYtf,
                       label: block_cbYtf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYtf: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.307714152 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$csequence_closure" {
     Data.Traversable.$fTraversableSum_$csequence_closure:
         const Data.Traversable.$fTraversableSum_$csequence_info;
 },
 Data.Traversable.$fTraversableSum_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYtv,
                       label: Data.Traversable.$fTraversableSum_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYtv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYtz; else goto cbYtA;
       cbYtz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableSum_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYtA: // global
           I64[Sp - 16] = block_cbYtt_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYtt() //  [R1]
         { info_tbl: [(cbYtt,
                       label: block_cbYtt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYtt: // global
           I64[Sp] = block_cbYty_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYty() //  [R1]
         { info_tbl: [(cbYty,
                       label: block_cbYty_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYty: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.308709342 UTC

[section ""data" . Data.Traversable.$fTraversableSum_closure" {
     Data.Traversable.$fTraversableSum_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Semigroup.Internal.$fFunctorSum_closure;
         const Data.Foldable.$fFoldableSum_closure;
         const Data.Traversable.$fTraversableSum_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableSum_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableSum_$cmapM_closure+3;
         const Data.Traversable.$fTraversableSum_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.309536561 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$csequenceA_closure" {
     Data.Traversable.$fTraversableDual_$csequenceA_closure:
         const Data.Traversable.$fTraversableDual_$csequenceA_info;
 },
 Data.Traversable.$fTraversableDual_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbYtM,
                       label: Data.Traversable.$fTraversableDual_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYtM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYtN; else goto cbYtO;
       cbYtN: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableDual_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYtO: // global
           I64[Sp - 16] = block_cbYtK_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYtK() //  [R1]
         { info_tbl: [(cbYtK,
                       label: block_cbYtK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYtK: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.310753911 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$cmapM_closure" {
     Data.Traversable.$fTraversableDual_$cmapM_closure:
         const Data.Traversable.$fTraversableDual_$cmapM_info;
 },
 Data.Traversable.$fTraversableDual_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYtZ,
                       label: Data.Traversable.$fTraversableDual_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYtZ: // global
           _sbX3i::P64 = R4;
           _sbX3h::P64 = R3;
           _sbX3g::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYu3; else goto cbYu4;
       cbYu4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYu6; else goto cbYu5;
       cbYu6: // global
           HpAlloc = 32;
           goto cbYu3;
       cbYu3: // global
           R4 = _sbX3i::P64;
           R3 = _sbX3h::P64;
           R2 = _sbX3g::P64;
           R1 = Data.Traversable.$fTraversableDual_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYu5: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX3h::P64;
           P64[Hp] = _sbX3i::P64;
           I64[Sp - 16] = block_cbYtX_info;
           R2 = _sbX3g::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYtX() //  [R1]
         { info_tbl: [(cbYtX,
                       label: block_cbYtX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYtX: // global
           I64[Sp] = block_cbYu2_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYu2() //  [R1]
         { info_tbl: [(cbYu2,
                       label: block_cbYu2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYu2: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.312102191 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$csequence_closure" {
     Data.Traversable.$fTraversableDual_$csequence_closure:
         const Data.Traversable.$fTraversableDual_$csequence_info;
 },
 Data.Traversable.$fTraversableDual_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYui,
                       label: Data.Traversable.$fTraversableDual_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYui: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYum; else goto cbYun;
       cbYum: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableDual_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYun: // global
           I64[Sp - 16] = block_cbYug_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYug() //  [R1]
         { info_tbl: [(cbYug,
                       label: block_cbYug_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYug: // global
           I64[Sp] = block_cbYul_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYul() //  [R1]
         { info_tbl: [(cbYul,
                       label: block_cbYul_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYul: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.313188795 UTC

[section ""data" . Data.Traversable.$fTraversableDual_closure" {
     Data.Traversable.$fTraversableDual_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Semigroup.Internal.$fFunctorDual_closure;
         const Data.Foldable.$fFoldableDual_closure;
         const Data.Traversable.$fTraversableDual_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableDual_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableDual_$cmapM_closure+3;
         const Data.Traversable.$fTraversableDual_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.314008481 UTC

[section ""data" . Data.Traversable.$fTraversableConst_$cmapM_closure" {
     Data.Traversable.$fTraversableConst_$cmapM_closure:
         const Data.Traversable.$fTraversableConst_$cmapM_info;
 },
 Data.Traversable.$fTraversableConst_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYuz,
                       label: Data.Traversable.$fTraversableConst_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYuz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYuA; else goto cbYuB;
       cbYuA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableConst_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYuB: // global
           I64[Sp - 16] = block_cbYux_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYux() //  [R1]
         { info_tbl: [(cbYux,
                       label: block_cbYux_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYux: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.31510395 UTC

[section ""data" . Data.Traversable.$fTraversableConst_$csequence_closure" {
     Data.Traversable.$fTraversableConst_$csequence_closure:
         const Data.Traversable.$fTraversableConst_$csequence_info;
 },
 Data.Traversable.$fTraversableConst_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYuL,
                       label: Data.Traversable.$fTraversableConst_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYuL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYuM; else goto cbYuN;
       cbYuM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableConst_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYuN: // global
           I64[Sp - 16] = block_cbYuJ_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYuJ() //  [R1]
         { info_tbl: [(cbYuJ,
                       label: block_cbYuJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYuJ: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.31611364 UTC

[section ""data" . $fTraversableConst1_rbWTU_closure" {
     $fTraversableConst1_rbWTU_closure:
         const $fTraversableConst1_rbWTU_info;
 },
 $fTraversableConst1_rbWTU_entry() //  [R2, R3]
         { info_tbl: [(cbYuV,
                       label: $fTraversableConst1_rbWTU_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYuV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYuW; else goto cbYuX;
       cbYuW: // global
           R3 = R3;
           R2 = R2;
           R1 = $fTraversableConst1_rbWTU_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYuX: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.316878587 UTC

[section ""data" . Data.Traversable.$fTraversableConst_closure" {
     Data.Traversable.$fTraversableConst_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Functor.Const.$fFunctorConst_closure;
         const Data.Functor.Const.$fFoldableConst_closure;
         const Data.Traversable.$fTraversableConst_$ctraverse_closure+3;
         const $fTraversableConst1_rbWTU_closure+2;
         const Data.Traversable.$fTraversableConst_$cmapM_closure+3;
         const Data.Traversable.$fTraversableConst_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.318247437 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$csequenceA_closure" {
     Data.Traversable.$fTraversable(,)_$csequenceA_closure:
         const Data.Traversable.$fTraversable(,)_$csequenceA_info;
 },
 sat_sbX3F_entry() //  [R1, R2]
         { info_tbl: [(cbYvd,
                       label: sat_sbX3F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYvd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbYvh; else goto cbYvg;
       cbYvh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYvg: // global
           _sbX3C::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbX3C::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbYvi,
                       label: Data.Traversable.$fTraversable(,)_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYvi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYvk; else goto cbYvl;
       cbYvk: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYvl: // global
           I64[Sp - 16] = block_cbYv2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubYvt; else goto cbYv3;
       ubYvt: // global
           call _cbYv2(R1) args: 0, res: 0, upd: 0;
       cbYv3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYv2() //  [R1]
         { info_tbl: [(cbYv2,
                       label: block_cbYv2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYv2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbYvo; else goto cbYvn;
       cbYvo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYvn: // global
           _sbX3C::P64 = P64[R1 + 7];
           _sbX3D::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sbX3F_info;
           P64[Hp] = _sbX3C::P64;
           I64[Sp - 8] = block_cbYvj_info;
           R2 = P64[Sp + 8];
           P64[Sp] = _sbX3D::P64;
           P64[Sp + 8] = Hp - 7;
           Sp = Sp - 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYvj() //  [R1]
         { info_tbl: [(cbYvj,
                       label: block_cbYvj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYvj: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _sbX3D::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sbX3D::P64;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.320342701 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$cmapM_closure" {
     Data.Traversable.$fTraversable(,)_$cmapM_closure:
         const Data.Traversable.$fTraversable(,)_$cmapM_info;
 },
 sat_sbX3O_entry() //  [R1, R2]
         { info_tbl: [(cbYvK,
                       label: sat_sbX3O_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYvK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbYvO; else goto cbYvN;
       cbYvO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYvN: // global
           _sbX3K::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbX3K::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYvP,
                       label: Data.Traversable.$fTraversable(,)_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYvP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYvV; else goto cbYvW;
       cbYvV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYvW: // global
           I64[Sp - 24] = block_cbYvy_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubYw5; else goto cbYvz;
       ubYw5: // global
           call _cbYvy(R1) args: 0, res: 0, upd: 0;
       cbYvz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYvy() //  [R1]
         { info_tbl: [(cbYvy,
                       label: block_cbYvy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYvy: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbYvZ; else goto cbYvY;
       cbYvZ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYvY: // global
           _sbX3K::P64 = P64[R1 + 7];
           _sbX3L::P64 = P64[R1 + 15];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbX3L::P64;
           I64[Hp - 8] = sat_sbX3O_info;
           P64[Hp] = _sbX3K::P64;
           I64[Sp] = block_cbYvQ_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 7;
           P64[Sp + 16] = Hp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYvQ() //  [R1]
         { info_tbl: [(cbYvQ,
                       label: block_cbYvQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYvQ: // global
           I64[Sp] = block_cbYvU_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYvU() //  [R1]
         { info_tbl: [(cbYvU,
                       label: block_cbYvU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYvU: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.322585225 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$csequence_closure" {
     Data.Traversable.$fTraversable(,)_$csequence_closure:
         const Data.Traversable.$fTraversable(,)_$csequence_info;
 },
 sat_sbX3X_entry() //  [R1, R2]
         { info_tbl: [(cbYwl,
                       label: sat_sbX3X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYwl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbYwp; else goto cbYwo;
       cbYwp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYwo: // global
           _sbX3T::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbX3T::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYwq,
                       label: Data.Traversable.$fTraversable(,)_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYwq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYww; else goto cbYwx;
       cbYww: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYwx: // global
           I64[Sp - 16] = block_cbYwa_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubYwG; else goto cbYwb;
       ubYwG: // global
           call _cbYwa(R1) args: 0, res: 0, upd: 0;
       cbYwb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYwa() //  [R1]
         { info_tbl: [(cbYwa,
                       label: block_cbYwa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYwa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbYwA; else goto cbYwz;
       cbYwA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYwz: // global
           _sbX3T::P64 = P64[R1 + 7];
           _sbX3U::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sbX3X_info;
           P64[Hp] = _sbX3T::P64;
           I64[Sp - 8] = block_cbYwr_info;
           R2 = P64[Sp + 8];
           P64[Sp] = _sbX3U::P64;
           P64[Sp + 8] = Hp - 7;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYwr() //  [R1]
         { info_tbl: [(cbYwr,
                       label: block_cbYwr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYwr: // global
           I64[Sp] = block_cbYwv_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYwv() //  [R1]
         { info_tbl: [(cbYwv,
                       label: block_cbYwv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYwv: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _sbX3U::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sbX3U::P64;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.324194279 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_closure" {
     Data.Traversable.$fTraversable(,)_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctor(,)_closure;
         const Data.Foldable.$fFoldable(,)_closure;
         const Data.Traversable.$fTraversable(,)_$ctraverse_closure+3;
         const Data.Traversable.$fTraversable(,)_$csequenceA_closure+2;
         const Data.Traversable.$fTraversable(,)_$cmapM_closure+3;
         const Data.Traversable.$fTraversable(,)_$csequence_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.325169364 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$csequenceA_closure" {
     Data.Traversable.$fTraversableEither_$csequenceA_closure:
         const Data.Traversable.$fTraversableEither_$csequenceA_info;
 },
 Data.Traversable.$fTraversableEither_$csequenceA_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cbYwS,
                       label: Data.Traversable.$fTraversableEither_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYwS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYwT; else goto cbYwU;
       cbYwT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYwU: // global
           I64[Sp - 16] = block_cbYwL_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubYx6; else goto cbYwM;
       ubYx6: // global
           call _cbYwL(R1) args: 0, res: 0, upd: 0;
       cbYwM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYwL() //  [R1]
         { info_tbl: [(cbYwL,
                       label: block_cbYwL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYwL: // global
           _sbX3Y::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbYwP; else goto cbYwQ;
       cbYwP: // global
           R2 = _sbX3Y::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cbYwQ: // global
           I64[Sp] = block_cbYx0_info;
           R2 = _sbX3Y::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYx0() //  [R1]
         { info_tbl: [(cbYx0,
                       label: block_cbYx0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYx0: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.326627312 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$cmapM_closure" {
     Data.Traversable.$fTraversableEither_$cmapM_closure:
         const Data.Traversable.$fTraversableEither_$cmapM_info;
 },
 Data.Traversable.$fTraversableEither_$cmapM_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbYxd,
                       label: Data.Traversable.$fTraversableEither_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYxd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYxe; else goto cbYxf;
       cbYxe: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYxf: // global
           I64[Sp - 24] = block_cbYxb_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYxb() //  [R1]
         { info_tbl: [(cbYxb,
                       label: block_cbYxb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYxb: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableEither_$ctraverse_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.327981175 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$csequence_closure" {
     Data.Traversable.$fTraversableEither_$csequence_closure:
         const Data.Traversable.$fTraversableEither_$csequence_info;
 },
 Data.Traversable.$fTraversableEither_$csequence_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbYxu,
                       label: Data.Traversable.$fTraversableEither_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYxu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYxv; else goto cbYxw;
       cbYxv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYxw: // global
           I64[Sp - 16] = block_cbYxn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubYxS; else goto cbYxo;
       ubYxS: // global
           call _cbYxn(R1) args: 0, res: 0, upd: 0;
       cbYxo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYxn() //  [R1]
         { info_tbl: [(cbYxn,
                       label: block_cbYxn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYxn: // global
           _sbX49::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbYxr; else goto cbYxs;
       cbYxr: // global
           I64[Sp] = block_cbYxz_info;
           R2 = _sbX49::P64;
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
       cbYxs: // global
           I64[Sp] = block_cbYxH_info;
           R2 = _sbX49::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYxz() //  [R1]
         { info_tbl: [(cbYxz,
                       label: block_cbYxz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYxz: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 _cbYxH() //  [R1]
         { info_tbl: [(cbYxH,
                       label: block_cbYxH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYxH: // global
           I64[Sp] = block_cbYxL_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYxL() //  [R1]
         { info_tbl: [(cbYxL,
                       label: block_cbYxL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYxL: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.329635772 UTC

[section ""data" . Data.Traversable.$fTraversableEither_closure" {
     Data.Traversable.$fTraversableEither_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Either.$fFunctorEither_closure;
         const Data.Foldable.$fFoldableEither_closure;
         const Data.Traversable.$fTraversableEither_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableEither_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableEither_$cmapM_closure+3;
         const Data.Traversable.$fTraversableEither_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.330907002 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$csequenceA_closure" {
     Data.Traversable.$fTraversable[]_$csequenceA_closure:
         const Data.Traversable.$fTraversable[]_$csequenceA_info;
 },
 z_sbX4j_entry() //  [R1]
         { info_tbl: [(cbYy1,
                       label: z_sbX4j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYy1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYy2; else goto cbYy3;
       cbYy2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYy3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX4k_entry() //  [R1, R2]
         { info_tbl: [(cbYyg,
                       label: go_sbX4k_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYyg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYyh; else goto cbYyi;
       cbYyh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYyi: // global
           I64[Sp - 32] = block_cbYy9_info;
           _sbX4k::P64 = R1;
           _sbX4i::P64 = P64[R1 + 7];
           _sbX4j::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sbX4i::P64;
           P64[Sp - 16] = _sbX4j::P64;
           P64[Sp - 8] = _sbX4k::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubYys; else goto cbYya;
       ubYys: // global
           call _cbYy9(R1) args: 0, res: 0, upd: 0;
       cbYya: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYy9() //  [R1]
         { info_tbl: [(cbYy9,
                       label: block_cbYy9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYy9: // global
           if (R1 & 7 == 1) goto cbYyd; else goto cbYye;
       cbYyd: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbYye: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYyq; else goto cbYyp;
       cbYyq: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYyp: // global
           _sbX4n::P64 = P64[R1 + 6];
           _sbX4o::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sbX4o::P64;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 16] = _sbX4n::P64;
           P64[Sp + 24] = Hp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$csequenceA_entry() //  [R2]
         { info_tbl: [(cbYyt,
                       label: Data.Traversable.$fTraversable[]_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYyt: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbYyx; else goto cbYyw;
       cbYyx: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$csequenceA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYyw: // global
           I64[Hp - 40] = z_sbX4j_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_sbX4k_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.333533038 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$cmapM_closure" {
     Data.Traversable.$fTraversable[]_$cmapM_closure:
         const Data.Traversable.$fTraversable[]_$cmapM_info;
 },
 $dApplicative_sbX4s_entry() //  [R1]
         { info_tbl: [(cbYyG,
                       label: $dApplicative_sbX4s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYyG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYyH; else goto cbYyI;
       cbYyH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYyI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_sbX4t_entry() //  [R1]
         { info_tbl: [(cbYyN,
                       label: z_sbX4t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYyN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYyO; else goto cbYyP;
       cbYyO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYyP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX4u_entry() //  [R1, R2]
         { info_tbl: [(cbYz2,
                       label: go_sbX4u_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYz2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbYz3; else goto cbYz4;
       cbYz3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYz4: // global
           I64[Sp - 40] = block_cbYyV_info;
           _sbX4u::P64 = R1;
           _sbX4r::P64 = P64[R1 + 7];
           _sbX4s::P64 = P64[R1 + 15];
           _sbX4t::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sbX4r::P64;
           P64[Sp - 24] = _sbX4s::P64;
           P64[Sp - 16] = _sbX4t::P64;
           P64[Sp - 8] = _sbX4u::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubYzf; else goto cbYyW;
       ubYzf: // global
           call _cbYyV(R1) args: 0, res: 0, upd: 0;
       cbYyW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYyV() //  [R1]
         { info_tbl: [(cbYyV,
                       label: block_cbYyV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYyV: // global
           if (R1 & 7 == 1) goto cbYyZ; else goto cbYz0;
       cbYyZ: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbYz0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbYzc; else goto cbYzb;
       cbYzc: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYzb: // global
           _sbX4x::P64 = P64[R1 + 6];
           _sbX4y::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sbX4y::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sbX4x::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$cmapM_entry() //  [R2, R3]
         { info_tbl: [(cbYzg,
                       label: Data.Traversable.$fTraversable[]_$cmapM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYzg: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbYzk; else goto cbYzj;
       cbYzk: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$cmapM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYzj: // global
           I64[Hp - 72] = $dApplicative_sbX4s_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = z_sbX4t_info;
           _cbYyC::P64 = Hp - 72;
           P64[Hp - 32] = _cbYyC::P64;
           I64[Hp - 24] = go_sbX4u_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cbYyC::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.3398648 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$csequence_closure" {
     Data.Traversable.$fTraversable[]_$csequence_closure:
         const Data.Traversable.$fTraversable[]_$csequence_info;
 },
 $dApplicative_sbX4C_entry() //  [R1]
         { info_tbl: [(cbYzt,
                       label: $dApplicative_sbX4C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYzt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYzu; else goto cbYzv;
       cbYzu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYzv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_sbX4D_entry() //  [R1]
         { info_tbl: [(cbYzA,
                       label: z_sbX4D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYzA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYzB; else goto cbYzC;
       cbYzB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYzC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX4E_entry() //  [R1, R2]
         { info_tbl: [(cbYzP,
                       label: go_sbX4E_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYzP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYzQ; else goto cbYzR;
       cbYzQ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYzR: // global
           I64[Sp - 32] = block_cbYzI_info;
           _sbX4E::P64 = R1;
           _sbX4C::P64 = P64[R1 + 7];
           _sbX4D::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sbX4C::P64;
           P64[Sp - 16] = _sbX4D::P64;
           P64[Sp - 8] = _sbX4E::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubYA1; else goto cbYzJ;
       ubYA1: // global
           call _cbYzI(R1) args: 0, res: 0, upd: 0;
       cbYzJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYzI() //  [R1]
         { info_tbl: [(cbYzI,
                       label: block_cbYzI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYzI: // global
           if (R1 & 7 == 1) goto cbYzM; else goto cbYzN;
       cbYzM: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbYzN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYzZ; else goto cbYzY;
       cbYzZ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYzY: // global
           _sbX4H::P64 = P64[R1 + 6];
           _sbX4I::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sbX4I::P64;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 16] = _sbX4H::P64;
           P64[Sp + 24] = Hp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$csequence_entry() //  [R2]
         { info_tbl: [(cbYA2,
                       label: Data.Traversable.$fTraversable[]_$csequence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYA2: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbYA6; else goto cbYA5;
       cbYA6: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$csequence_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYA5: // global
           I64[Hp - 64] = $dApplicative_sbX4C_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = z_sbX4D_info;
           _cbYzp::P64 = Hp - 64;
           P64[Hp - 24] = _cbYzp::P64;
           I64[Hp - 16] = go_sbX4E_info;
           P64[Hp - 8] = _cbYzp::P64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.3422388 UTC

[section ""data" . Data.Traversable.$fTraversable[]_closure" {
     Data.Traversable.$fTraversable[]_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctor[]_closure;
         const Data.Foldable.$fFoldable[]_closure;
         const Data.Traversable.$fTraversable[]_$ctraverse_closure+2;
         const Data.Traversable.$fTraversable[]_$csequenceA_closure+1;
         const Data.Traversable.$fTraversable[]_$cmapM_closure+2;
         const Data.Traversable.$fTraversable[]_$csequence_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.342956127 UTC

[section ""data" . Data.Traversable.$fTraversableZipList1_closure" {
     Data.Traversable.$fTraversableZipList1_closure:
         const Data.Traversable.$fTraversableZipList1_info;
 },
 Data.Traversable.$fTraversableZipList1_entry() //  [R2]
         { info_tbl: [(cbYAb,
                       label: Data.Traversable.$fTraversableZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYAb: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.344676399 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$ctraverse_closure" {
     Data.Traversable.$fTraversableZipList_$ctraverse_closure:
         const Data.Traversable.$fTraversableZipList_$ctraverse_info;
 },
 z_sbX4P_entry() //  [R1]
         { info_tbl: [(cbYAq,
                       label: z_sbX4P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYAq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYAr; else goto cbYAs;
       cbYAr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYAs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX4Q_entry() //  [R1, R2]
         { info_tbl: [(cbYAF,
                       label: go_sbX4Q_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYAF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbYAG; else goto cbYAH;
       cbYAG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYAH: // global
           I64[Sp - 40] = block_cbYAy_info;
           _sbX4Q::P64 = R1;
           _sbX4L::P64 = P64[R1 + 7];
           _sbX4M::P64 = P64[R1 + 15];
           _sbX4P::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sbX4L::P64;
           P64[Sp - 24] = _sbX4M::P64;
           P64[Sp - 16] = _sbX4P::P64;
           P64[Sp - 8] = _sbX4Q::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubYAS; else goto cbYAz;
       ubYAS: // global
           call _cbYAy(R1) args: 0, res: 0, upd: 0;
       cbYAz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYAy() //  [R1]
         { info_tbl: [(cbYAy,
                       label: block_cbYAy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYAy: // global
           if (R1 & 7 == 1) goto cbYAC; else goto cbYAD;
       cbYAC: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbYAD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbYAP; else goto cbYAO;
       cbYAP: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYAO: // global
           _sbX4T::P64 = P64[R1 + 6];
           _sbX4U::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sbX4U::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbX4T::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sbX4X_entry() //  [R1]
         { info_tbl: [(cbYAT,
                       label: sat_sbX4X_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYAT: // global
           _sbX4X::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbYAU; else goto cbYAV;
       cbYAV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbYAX; else goto cbYAW;
       cbYAX: // global
           HpAlloc = 56;
           goto cbYAU;
       cbYAU: // global
           R1 = _sbX4X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYAW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbX4X::P64;
           _sbX4L::P64 = P64[_sbX4X::P64 + 16];
           _sbX4M::P64 = P64[_sbX4X::P64 + 24];
           _sbX4N::P64 = P64[_sbX4X::P64 + 32];
           I64[Hp - 48] = z_sbX4P_info;
           P64[Hp - 32] = _sbX4L::P64;
           I64[Hp - 24] = go_sbX4Q_info;
           P64[Hp - 16] = _sbX4L::P64;
           P64[Hp - 8] = _sbX4M::P64;
           P64[Hp] = Hp - 48;
           R2 = _sbX4N::P64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call go_sbX4Q_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableZipList_$ctraverse_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbYB0,
                       label: Data.Traversable.$fTraversableZipList_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYB0: // global
           _sbX4N::P64 = R4;
           _sbX4M::P64 = R3;
           _sbX4L::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYB1; else goto cbYB2;
       cbYB2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbYB4; else goto cbYB3;
       cbYB4: // global
           HpAlloc = 40;
           goto cbYB1;
       cbYB1: // global
           R4 = _sbX4N::P64;
           R3 = _sbX4M::P64;
           R2 = _sbX4L::P64;
           R1 = Data.Traversable.$fTraversableZipList_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYB3: // global
           I64[Hp - 32] = sat_sbX4X_info;
           P64[Hp - 16] = _sbX4L::P64;
           P64[Hp - 8] = _sbX4M::P64;
           P64[Hp] = _sbX4N::P64;
           I64[Sp - 16] = block_cbYAY_info;
           R2 = _sbX4L::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYAY() //  [R1]
         { info_tbl: [(cbYAY,
                       label: block_cbYAY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYAY: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableZipList1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.347382416 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$csequenceA_closure" {
     Data.Traversable.$fTraversableZipList_$csequenceA_closure:
         const Data.Traversable.$fTraversableZipList_$csequenceA_info;
 },
 Data.Traversable.$fTraversableZipList_$csequenceA_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbYBc,
                       label: Data.Traversable.$fTraversableZipList_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYBc: // global
           R4 = R3;
           R3 = GHC.Base.id_closure+1;
           R2 = R2;
           call Data.Traversable.$fTraversableZipList_$ctraverse_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.348312131 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$cmapM_closure" {
     Data.Traversable.$fTraversableZipList_$cmapM_closure:
         const Data.Traversable.$fTraversableZipList_$cmapM_info;
 },
 Data.Traversable.$fTraversableZipList_$cmapM_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbYBl,
                       label: Data.Traversable.$fTraversableZipList_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYBl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYBm; else goto cbYBn;
       cbYBm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableZipList_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYBn: // global
           I64[Sp - 24] = block_cbYBj_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYBj() //  [R1]
         { info_tbl: [(cbYBj,
                       label: block_cbYBj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYBj: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableZipList_$ctraverse_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.349614923 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$csequence_closure" {
     Data.Traversable.$fTraversableZipList_$csequence_closure:
         const Data.Traversable.$fTraversableZipList_$csequence_info;
 },
 Data.Traversable.$fTraversableZipList_$csequence_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cbYBx,
                       label: Data.Traversable.$fTraversableZipList_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYBx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYBy; else goto cbYBz;
       cbYBy: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableZipList_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYBz: // global
           I64[Sp - 16] = block_cbYBv_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYBv() //  [R1]
         { info_tbl: [(cbYBv,
                       label: block_cbYBv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYBv: // global
           R4 = P64[Sp + 8];
           R3 = GHC.Base.id_closure+1;
           R2 = R1;
           Sp = Sp + 16;
           call Data.Traversable.$fTraversableZipList_$ctraverse_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.350648472 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_closure" {
     Data.Traversable.$fTraversableZipList_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Control.Applicative.$fFunctorZipList_closure;
         const Control.Applicative.$fFoldableZipList_closure;
         const Data.Traversable.$fTraversableZipList_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableZipList_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableZipList_$cmapM_closure+3;
         const Data.Traversable.$fTraversableZipList_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.353134309 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$ctraverse_closure" {
     Data.Traversable.$fTraversableArray_$ctraverse_closure:
         const Data.Traversable.$fTraversableArray_$ctraverse_info;
         const 0;
 },
 n_sbX5j_entry() //  [R1]
         { info_tbl: [(cbYBX,
                       label: n_sbX5j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYBX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYBY; else goto cbYBZ;
       cbYBY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYBZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbX5t_entry() //  [R1]
         { info_tbl: [(cbYCh,
                       label: sat_sbX5t_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYCh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYCi; else goto cbYCj;
       cbYCi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYCj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _sbX5m::I64 = I64[R1 + 40];
           if (_sbX5m::I64 == I64[R1 + 32]) goto cbYCg; else goto cbYCf;
       cbYCg: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbYCf: // global
           R2 = _sbX5m::I64 + 1;
           R1 = P64[R1 + 24];
           Sp = Sp - 16;
           call go_sbX5l_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5p_entry() //  [R1]
         { info_tbl: [(cbYCu,
                       label: sat_sbX5p_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYCu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYCv; else goto cbYCw;
       cbYCv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYCw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = P64[P64[R1 + 16] + ((I64[R1 + 24] << 3) + 24)];
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5q_entry() //  [R1]
         { info_tbl: [(cbYCx,
                       label: sat_sbX5q_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYCx: // global
           _sbX5q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbYCy; else goto cbYCz;
       cbYCz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYCB; else goto cbYCA;
       cbYCB: // global
           HpAlloc = 32;
           goto cbYCy;
       cbYCy: // global
           R1 = _sbX5q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYCA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbX5q::P64;
           _sbX58::P64 = P64[_sbX5q::P64 + 16];
           _sbX5h::P64 = P64[_sbX5q::P64 + 24];
           _sbX5m::I64 = I64[_sbX5q::P64 + 32];
           I64[Hp - 24] = sat_sbX5p_info;
           P64[Hp - 8] = _sbX5h::P64;
           I64[Hp] = _sbX5m::I64;
           R2 = Hp - 24;
           R1 = _sbX58::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sbX5l_entry() //  [R1, R2]
         { info_tbl: [(cbYCC,
                       label: go_sbX5l_info
                       rep:HeapRep 4 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYCC: // global
           _sbX5m::I64 = R2;
           _sbX5l::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbYCD; else goto cbYCE;
       cbYCE: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbYCG; else goto cbYCF;
       cbYCG: // global
           HpAlloc = 88;
           goto cbYCD;
       cbYCD: // global
           R2 = _sbX5m::I64;
           R1 = _sbX5l::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYCF: // global
           _sbX57::P64 = P64[_sbX5l::P64 + 7];
           _sbX58::P64 = P64[_sbX5l::P64 + 15];
           _sbX5h::P64 = P64[_sbX5l::P64 + 23];
           _sbX5j::P64 = P64[_sbX5l::P64 + 31];
           _sbX5i::I64 = I64[_sbX5l::P64 + 39];
           I64[Hp - 80] = sat_sbX5t_info;
           P64[Hp - 64] = _sbX5j::P64;
           P64[Hp - 56] = _sbX5l::P64;
           I64[Hp - 48] = _sbX5i::I64;
           I64[Hp - 40] = _sbX5m::I64;
           I64[Hp - 32] = sat_sbX5q_info;
           P64[Hp - 16] = _sbX58::P64;
           P64[Hp - 8] = _sbX5h::P64;
           I64[Hp] = _sbX5m::I64;
           R2 = _sbX57::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = Hp - 80;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sbX5u_entry() //  [R1]
         { info_tbl: [(cbYCH,
                       label: sat_sbX5u_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYCH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbYCI; else goto cbYCJ;
       cbYCI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYCJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbYBL_info;
           _sbX57::P64 = P64[R1 + 16];
           _sbX58::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sbX57::P64;
           P64[Sp - 24] = _sbX58::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubYCQ; else goto cbYBM;
       ubYCQ: // global
           call _cbYBL(R1) args: 0, res: 0, upd: 0;
       cbYBM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbYBL() //  [R1]
         { info_tbl: [(cbYBL,
                       label: block_cbYBL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYBL: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbYCM; else goto cbYCL;
       cbYCM: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbYCL: // global
           _sbX5h::P64 = P64[R1 + 23];
           _sbX5i::I64 = I64[R1 + 31] - 1;
           I64[Hp - 64] = n_sbX5j_info;
           _sbX57::P64 = P64[Sp + 8];
           P64[Hp - 48] = _sbX57::P64;
           _cbYBT::P64 = Hp - 64;
           if (%MO_S_Le_W64(0, _sbX5i::I64)) goto cbYCO; else goto cbYCP;
       cbYCO: // global
           I64[Hp - 40] = go_sbX5l_info;
           P64[Hp - 32] = _sbX57::P64;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbX5h::P64;
           P64[Hp - 8] = _cbYBT::P64;
           I64[Hp] = _sbX5i::I64;
           R2 = 0;
           R1 = Hp - 39;
           Sp = Sp + 24;
           call go_sbX5l_entry(R2, R1) args: 24, res: 0, upd: 24;
       cbYCP: // global
           Hp = Hp - 48;
           R1 = _cbYBT::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5b_entry() //  [R1]
         { info_tbl: [(cbYCV,
                       label: sat_sbX5b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYCV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYCW; else goto cbYCX;
       cbYCW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYCX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.bounds_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5c_entry() //  [R1, R2]
         { info_tbl: [(cbYD3,
                       label: sat_sbX5c_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYD3: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Arr.listArray_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversableArray_$ctraverse_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cbYD8,
                       label: Data.Traversable.$fTraversableArray_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYD8: // global
           _sbX59::P64 = R5;
           _sbX58::P64 = R4;
           _sbX57::P64 = R3;
           _sbX56::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYD9; else goto cbYDa;
       cbYDa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbYDc; else goto cbYDb;
       cbYDc: // global
           HpAlloc = 88;
           goto cbYD9;
       cbYD9: // global
           R5 = _sbX59::P64;
           R4 = _sbX58::P64;
           R3 = _sbX57::P64;
           R2 = _sbX56::P64;
           R1 = Data.Traversable.$fTraversableArray_$ctraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYDb: // global
           I64[Hp - 80] = sat_sbX5u_info;
           P64[Hp - 64] = _sbX57::P64;
           P64[Hp - 56] = _sbX58::P64;
           P64[Hp - 48] = _sbX59::P64;
           I64[Hp - 40] = sat_sbX5b_info;
           P64[Hp - 24] = _sbX59::P64;
           I64[Hp - 16] = sat_sbX5c_info;
           P64[Hp - 8] = _sbX56::P64;
           P64[Hp] = Hp - 40;
           I64[Sp - 24] = block_cbYD6_info;
           R2 = _sbX57::P64;
           P64[Sp - 16] = Hp - 80;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYD6() //  [R1]
         { info_tbl: [(cbYD6,
                       label: block_cbYD6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYD6: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbYBH::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbYBH::P64;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.357447573 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$csequenceA_closure" {
     Data.Traversable.$fTraversableArray_$csequenceA_closure:
         const Data.Traversable.$fTraversableArray_$csequenceA_info;
         const 0;
 },
 Data.Traversable.$fTraversableArray_$csequenceA_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cbYDk,
                       label: Data.Traversable.$fTraversableArray_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYDk: // global
           R5 = R4;
           R4 = GHC.Base.id_closure+1;
           R3 = R3;
           R2 = R2;
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.35842829 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$cmapM_closure" {
     Data.Traversable.$fTraversableArray_$cmapM_closure:
         const Data.Traversable.$fTraversableArray_$cmapM_info;
         const 0;
 },
 Data.Traversable.$fTraversableArray_$cmapM_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cbYDt,
                       label: Data.Traversable.$fTraversableArray_$cmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYDt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYDu; else goto cbYDv;
       cbYDu: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableArray_$cmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYDv: // global
           I64[Sp - 32] = block_cbYDr_info;
           _sbX5x::P64 = R2;
           R2 = R3;
           P64[Sp - 24] = _sbX5x::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYDr() //  [R1]
         { info_tbl: [(cbYDr,
                       label: block_cbYDr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYDr: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.359700236 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$csequence_closure" {
     Data.Traversable.$fTraversableArray_$csequence_closure:
         const Data.Traversable.$fTraversableArray_$csequence_info;
         const 0;
 },
 Data.Traversable.$fTraversableArray_$csequence_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbYDF,
                       label: Data.Traversable.$fTraversableArray_$csequence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYDF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYDG; else goto cbYDH;
       cbYDG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableArray_$csequence_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYDH: // global
           I64[Sp - 24] = block_cbYDD_info;
           _sbX5C::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _sbX5C::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYDD() //  [R1]
         { info_tbl: [(cbYDD,
                       label: block_cbYDD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYDD: // global
           R5 = P64[Sp + 16];
           R4 = GHC.Base.id_closure+1;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.361468132 UTC

[section ""data" . Data.Traversable.$fTraversableArray_closure" {
     Data.Traversable.$fTraversableArray_closure:
         const Data.Traversable.$fTraversableArray_info;
         const 0;
 },
 sat_sbX5K_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYDU,
                       label: sat_sbX5K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYDU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableArray_$csequence_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX5J_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbYE2,
                       label: sat_sbX5J_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYE2: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableArray_$cmapM_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX5I_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYEa,
                       label: sat_sbX5I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYEa: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableArray_$csequenceA_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX5H_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbYEi,
                       label: sat_sbX5H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYEi: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversableArray_entry() //  [R2]
         { info_tbl: [(cbYEm,
                       label: Data.Traversable.$fTraversableArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYEm: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cbYEq; else goto cbYEp;
       cbYEq: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYEp: // global
           I64[Hp - 112] = sat_sbX5K_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbX5J_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbX5I_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbX5H_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = GHC.Arr.$fFunctorArray_closure;
           P64[Hp - 32] = Data.Foldable.$fFoldableArray_closure;
           P64[Hp - 24] = Hp - 61;
           P64[Hp - 16] = Hp - 78;
           P64[Hp - 8] = Hp - 93;
           P64[Hp] = Hp - 110;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.364396136 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure" {
     Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure:
         const Data.Traversable.$fTraversableNonEmpty_$ctraverse_info;
 },
 z_sbX5W_entry() //  [R1]
         { info_tbl: [(cbYEI,
                       label: z_sbX5W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYEI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYEJ; else goto cbYEK;
       cbYEJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYEK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX5X_entry() //  [R1, R2]
         { info_tbl: [(cbYEX,
                       label: go_sbX5X_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYEX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbYEY; else goto cbYEZ;
       cbYEY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYEZ: // global
           I64[Sp - 40] = block_cbYEQ_info;
           _sbX5X::P64 = R1;
           _sbX5L::P64 = P64[R1 + 7];
           _sbX5M::P64 = P64[R1 + 15];
           _sbX5W::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sbX5L::P64;
           P64[Sp - 24] = _sbX5M::P64;
           P64[Sp - 16] = _sbX5W::P64;
           P64[Sp - 8] = _sbX5X::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubYFa; else goto cbYER;
       ubYFa: // global
           call _cbYEQ(R1) args: 0, res: 0, upd: 0;
       cbYER: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYEQ() //  [R1]
         { info_tbl: [(cbYEQ,
                       label: block_cbYEQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYEQ: // global
           if (R1 & 7 == 1) goto cbYEU; else goto cbYEV;
       cbYEU: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbYEV: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbYF7; else goto cbYF6;
       cbYF7: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYF6: // global
           _sbX60::P64 = P64[R1 + 6];
           _sbX61::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sbX61::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbX60::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sbX64_entry() //  [R1]
         { info_tbl: [(cbYFb,
                       label: sat_sbX64_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYFb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbYFc; else goto cbYFd;
       cbYFc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYFd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbYEz_info;
           _sbX5L::P64 = P64[R1 + 16];
           _sbX5M::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sbX5L::P64;
           P64[Sp - 24] = _sbX5M::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubYFh; else goto cbYEA;
       ubYFh: // global
           call _cbYEz(R1) args: 0, res: 0, upd: 0;
       cbYEA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbYEz() //  [R1]
         { info_tbl: [(cbYEz,
                       label: block_cbYEz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYEz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbYFg; else goto cbYFf;
       cbYFg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbYFf: // global
           _sbX5V::P64 = P64[R1 + 15];
           I64[Hp - 48] = z_sbX5W_info;
           _sbX5L::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sbX5L::P64;
           I64[Hp - 24] = go_sbX5X_info;
           P64[Hp - 16] = _sbX5L::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R2 = _sbX5V::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call go_sbX5X_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5S_entry() //  [R1]
         { info_tbl: [(cbYFn,
                       label: sat_sbX5S_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYFn: // global
           _sbX5S::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbYFo; else goto cbYFp;
       cbYFp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbYFr; else goto cbYFq;
       cbYFr: // global
           HpAlloc = 24;
           goto cbYFo;
       cbYFo: // global
           R1 = _sbX5S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYFq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbX5S::P64;
           _sbX5M::P64 = P64[_sbX5S::P64 + 16];
           _sbX5N::P64 = P64[_sbX5S::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbX5N::P64;
           R2 = Hp - 16;
           R1 = _sbX5M::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cbYFs,
                       label: Data.Traversable.$fTraversableNonEmpty_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYFs: // global
           _sbX5N::P64 = R4;
           _sbX5M::P64 = R3;
           _sbX5L::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cbYFt; else goto cbYFu;
       cbYFu: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbYFw; else goto cbYFv;
       cbYFw: // global
           HpAlloc = 72;
           goto cbYFt;
       cbYFt: // global
           R4 = _sbX5N::P64;
           R3 = _sbX5M::P64;
           R2 = _sbX5L::P64;
           R1 = Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYFv: // global
           I64[Hp - 64] = sat_sbX64_info;
           P64[Hp - 48] = _sbX5L::P64;
           P64[Hp - 40] = _sbX5M::P64;
           P64[Hp - 32] = _sbX5N::P64;
           I64[Hp - 24] = sat_sbX5S_info;
           P64[Hp - 8] = _sbX5M::P64;
           P64[Hp] = _sbX5N::P64;
           R2 = _sbX5L::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Base.:|_closure+2;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.367690068 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$csequenceA_closure" {
     Data.Traversable.$fTraversableNonEmpty_$csequenceA_closure:
         const Data.Traversable.$fTraversableNonEmpty_$csequenceA_info;
 },
 Data.Traversable.$fTraversableNonEmpty_$csequenceA_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cbYFB,
                       label: Data.Traversable.$fTraversableNonEmpty_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYFB: // global
           R4 = R3;
           R3 = GHC.Base.id_closure+1;
           R2 = R2;
           call Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.368681289 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$cmapM_closure" {
     Data.Traversable.$fTraversableNonEmpty_$cmapM_closure:
         const Data.Traversable.$fTraversableNonEmpty_$cmapM_info;
 },
 Data.Traversable.$fTraversableNonEmpty_$cmapM_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbYFK,
                       label: Data.Traversable.$fTraversableNonEmpty_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYFK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYFL; else goto cbYFM;
       cbYFL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableNonEmpty_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYFM: // global
           I64[Sp - 24] = block_cbYFI_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYFI() //  [R1]
         { info_tbl: [(cbYFI,
                       label: block_cbYFI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYFI: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.369974799 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$csequence_closure" {
     Data.Traversable.$fTraversableNonEmpty_$csequence_closure:
         const Data.Traversable.$fTraversableNonEmpty_$csequence_info;
 },
 Data.Traversable.$fTraversableNonEmpty_$csequence_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbYFW,
                       label: Data.Traversable.$fTraversableNonEmpty_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYFW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYFX; else goto cbYFY;
       cbYFX: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableNonEmpty_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYFY: // global
           I64[Sp - 16] = block_cbYFU_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYFU() //  [R1]
         { info_tbl: [(cbYFU,
                       label: block_cbYFU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYFU: // global
           R4 = P64[Sp + 8];
           R3 = GHC.Base.id_closure+1;
           R2 = R1;
           Sp = Sp + 16;
           call Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.371022504 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_closure" {
     Data.Traversable.$fTraversableNonEmpty_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctorNonEmpty_closure;
         const Data.Foldable.$fFoldableNonEmpty_closure;
         const Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableNonEmpty_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableNonEmpty_$cmapM_closure+3;
         const Data.Traversable.$fTraversableNonEmpty_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.371993202 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_$csequenceA_closure" {
     Data.Traversable.$fTraversableMaybe_$csequenceA_closure:
         const Data.Traversable.$fTraversableMaybe_$csequenceA_info;
 },
 Data.Traversable.$fTraversableMaybe_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbYGd,
                       label: Data.Traversable.$fTraversableMaybe_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYGd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYGe; else goto cbYGf;
       cbYGe: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableMaybe_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYGf: // global
           I64[Sp - 16] = block_cbYG6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubYGr; else goto cbYG7;
       ubYGr: // global
           call _cbYG6(R1) args: 0, res: 0, upd: 0;
       cbYG7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYG6() //  [R1]
         { info_tbl: [(cbYG6,
                       label: block_cbYG6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYG6: // global
           _sbX6d::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbYGa; else goto cbYGb;
       cbYGa: // global
           R2 = _sbX6d::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cbYGb: // global
           I64[Sp] = block_cbYGl_info;
           R2 = _sbX6d::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYGl() //  [R1]
         { info_tbl: [(cbYGl,
                       label: block_cbYGl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYGl: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.373472974 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_$cmapM_closure" {
     Data.Traversable.$fTraversableMaybe_$cmapM_closure:
         const Data.Traversable.$fTraversableMaybe_$cmapM_info;
 },
 Data.Traversable.$fTraversableMaybe_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYGy,
                       label: Data.Traversable.$fTraversableMaybe_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYGy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYGz; else goto cbYGA;
       cbYGz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableMaybe_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYGA: // global
           I64[Sp - 24] = block_cbYGw_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYGw() //  [R1]
         { info_tbl: [(cbYGw,
                       label: block_cbYGw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYGw: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.374837851 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_$csequence_closure" {
     Data.Traversable.$fTraversableMaybe_$csequence_closure:
         const Data.Traversable.$fTraversableMaybe_$csequence_info;
 },
 Data.Traversable.$fTraversableMaybe_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYGP,
                       label: Data.Traversable.$fTraversableMaybe_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYGP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYGQ; else goto cbYGR;
       cbYGQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableMaybe_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYGR: // global
           I64[Sp - 16] = block_cbYGI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubYHd; else goto cbYGJ;
       ubYHd: // global
           call _cbYGI(R1) args: 0, res: 0, upd: 0;
       cbYGJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYGI() //  [R1]
         { info_tbl: [(cbYGI,
                       label: block_cbYGI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYGI: // global
           _sbX6m::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbYGM; else goto cbYGN;
       cbYGM: // global
           I64[Sp + 8] = block_cbYGU_info;
           R2 = _sbX6m::P64;
           Sp = Sp + 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
       cbYGN: // global
           I64[Sp] = block_cbYH2_info;
           R2 = _sbX6m::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYGU() //  [R1]
         { info_tbl: [(cbYGU,
                       label: block_cbYGU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYGU: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 _cbYH2() //  [R1]
         { info_tbl: [(cbYH2,
                       label: block_cbYH2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYH2: // global
           I64[Sp] = block_cbYH6_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYH6() //  [R1]
         { info_tbl: [(cbYH6,
                       label: block_cbYH6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYH6: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.376350967 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_closure" {
     Data.Traversable.$fTraversableMaybe_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctorMaybe_closure;
         const Data.Foldable.$fFoldableMaybe_closure;
         const Data.Traversable.$fTraversableFirst_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableMaybe_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableMaybe_$cmapM_closure+3;
         const Data.Traversable.$fTraversableMaybe_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.377065553 UTC

[section ""data" . Data.Traversable.$fTraversableFirst1_closure" {
     Data.Traversable.$fTraversableFirst1_closure:
         const Data.Traversable.$fTraversableFirst1_info;
 },
 Data.Traversable.$fTraversableFirst1_entry() //  [R2]
         { info_tbl: [(cbYHi,
                       label: Data.Traversable.$fTraversableFirst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYHi: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.37825172 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$ctraverse_closure" {
     Data.Traversable.$fTraversableLast_$ctraverse_closure:
         const Data.Traversable.$fTraversableLast_$ctraverse_info;
 },
 sat_sbX6y_entry() //  [R1]
         { info_tbl: [(cbYHt,
                       label: sat_sbX6y_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYHt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYHu; else goto cbYHv;
       cbYHu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYHv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbYHy,
                       label: Data.Traversable.$fTraversableLast_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYHy: // global
           _sbX6w::P64 = R4;
           _sbX6v::P64 = R3;
           _sbX6u::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYHz; else goto cbYHA;
       cbYHA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbYHC; else goto cbYHB;
       cbYHC: // global
           HpAlloc = 40;
           goto cbYHz;
       cbYHz: // global
           R4 = _sbX6w::P64;
           R3 = _sbX6v::P64;
           R2 = _sbX6u::P64;
           R1 = Data.Traversable.$fTraversableLast_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYHB: // global
           I64[Hp - 32] = sat_sbX6y_info;
           P64[Hp - 16] = _sbX6u::P64;
           P64[Hp - 8] = _sbX6v::P64;
           P64[Hp] = _sbX6w::P64;
           I64[Sp - 16] = block_cbYHw_info;
           R2 = _sbX6u::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYHw() //  [R1]
         { info_tbl: [(cbYHw,
                       label: block_cbYHw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYHw: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.380158235 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$csequenceA_closure" {
     Data.Traversable.$fTraversableLast_$csequenceA_closure:
         const Data.Traversable.$fTraversableLast_$csequenceA_info;
 },
 sat_sbX6F_entry() //  [R1]
         { info_tbl: [(cbYHV,
                       label: sat_sbX6F_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYHV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbYHW; else goto cbYHX;
       cbYHW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYHX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbYHO_info;
           _sbX6z::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbX6z::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubYI9; else goto cbYHP;
       ubYI9: // global
           call _cbYHO(R1) args: 0, res: 0, upd: 0;
       cbYHP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbYHO() //  [R1]
         { info_tbl: [(cbYHO,
                       label: block_cbYHO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYHO: // global
           _sbX6z::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbYHS; else goto cbYHT;
       cbYHS: // global
           R2 = _sbX6z::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cbYHT: // global
           I64[Sp] = block_cbYI3_info;
           R2 = _sbX6z::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbYI3() //  [R1]
         { info_tbl: [(cbYI3,
                       label: block_cbYI3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYI3: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbYIc,
                       label: Data.Traversable.$fTraversableLast_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYIc: // global
           _sbX6A::P64 = R3;
           _sbX6z::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYId; else goto cbYIe;
       cbYIe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYIg; else goto cbYIf;
       cbYIg: // global
           HpAlloc = 32;
           goto cbYId;
       cbYId: // global
           R3 = _sbX6A::P64;
           R2 = _sbX6z::P64;
           R1 = Data.Traversable.$fTraversableLast_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYIf: // global
           I64[Hp - 24] = sat_sbX6F_info;
           P64[Hp - 8] = _sbX6z::P64;
           P64[Hp] = _sbX6A::P64;
           I64[Sp - 16] = block_cbYIa_info;
           R2 = _sbX6z::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYIa() //  [R1]
         { info_tbl: [(cbYIa,
                       label: block_cbYIa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYIa: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.3824143 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$cmapM_closure" {
     Data.Traversable.$fTraversableLast_$cmapM_closure:
         const Data.Traversable.$fTraversableLast_$cmapM_info;
 },
 sat_sbX6L_entry() //  [R1]
         { info_tbl: [(cbYIw,
                       label: sat_sbX6L_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYIw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYIx; else goto cbYIy;
       cbYIx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYIy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYIz,
                       label: Data.Traversable.$fTraversableLast_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYIz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYIB; else goto cbYIC;
       cbYIB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableLast_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYIC: // global
           I64[Sp - 24] = block_cbYIo_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYIo() //  [R1]
         { info_tbl: [(cbYIo,
                       label: block_cbYIo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYIo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbYIF; else goto cbYIE;
       cbYIF: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYIE: // global
           I64[Hp - 32] = sat_sbX6L_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbYIA_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYIA() //  [R1]
         { info_tbl: [(cbYIA,
                       label: block_cbYIA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYIA: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.384560541 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$csequence_closure" {
     Data.Traversable.$fTraversableLast_$csequence_closure:
         const Data.Traversable.$fTraversableLast_$csequence_info;
 },
 sat_sbX6T_entry() //  [R1]
         { info_tbl: [(cbYJ3,
                       label: sat_sbX6T_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYJ3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbYJ4; else goto cbYJ5;
       cbYJ4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYJ5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbYIW_info;
           _sbX6O::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbX6O::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubYJh; else goto cbYIX;
       ubYJh: // global
           call _cbYIW(R1) args: 0, res: 0, upd: 0;
       cbYIX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbYIW() //  [R1]
         { info_tbl: [(cbYIW,
                       label: block_cbYIW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYIW: // global
           _sbX6O::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbYJ0; else goto cbYJ1;
       cbYJ0: // global
           R2 = _sbX6O::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cbYJ1: // global
           I64[Sp] = block_cbYJb_info;
           R2 = _sbX6O::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbYJb() //  [R1]
         { info_tbl: [(cbYJb,
                       label: block_cbYJb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYJb: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYJi,
                       label: Data.Traversable.$fTraversableLast_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYJi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYJk; else goto cbYJl;
       cbYJk: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableLast_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYJl: // global
           I64[Sp - 16] = block_cbYIO_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYIO() //  [R1]
         { info_tbl: [(cbYIO,
                       label: block_cbYIO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYIO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYJo; else goto cbYJn;
       cbYJo: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYJn: // global
           I64[Hp - 24] = sat_sbX6T_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_cbYJj_info;
           R2 = R1;
           P64[Sp + 8] = Hp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYJj() //  [R1]
         { info_tbl: [(cbYJj,
                       label: block_cbYJj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYJj: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.386576378 UTC

[section ""data" . Data.Traversable.$fTraversableLast_closure" {
     Data.Traversable.$fTraversableLast_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Monoid.$fFunctorLast_closure;
         const Data.Foldable.$fFoldableLast_closure;
         const Data.Traversable.$fTraversableLast_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableLast_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableLast_$cmapM_closure+3;
         const Data.Traversable.$fTraversableLast_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.387556402 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$ctraverse1_closure" {
     Data.Traversable.$fTraversableFirst_$ctraverse1_closure:
         const Data.Traversable.$fTraversableFirst_$ctraverse1_info;
 },
 sat_sbX6Y_entry() //  [R1]
         { info_tbl: [(cbYJB,
                       label: sat_sbX6Y_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYJB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYJC; else goto cbYJD;
       cbYJC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYJD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$ctraverse1_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cbYJG,
                       label: Data.Traversable.$fTraversableFirst_$ctraverse1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYJG: // global
           _sbX6W::P64 = R4;
           _sbX6V::P64 = R3;
           _sbX6U::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYJH; else goto cbYJI;
       cbYJI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbYJK; else goto cbYJJ;
       cbYJK: // global
           HpAlloc = 40;
           goto cbYJH;
       cbYJH: // global
           R4 = _sbX6W::P64;
           R3 = _sbX6V::P64;
           R2 = _sbX6U::P64;
           R1 = Data.Traversable.$fTraversableFirst_$ctraverse1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYJJ: // global
           I64[Hp - 32] = sat_sbX6Y_info;
           P64[Hp - 16] = _sbX6U::P64;
           P64[Hp - 8] = _sbX6V::P64;
           P64[Hp] = _sbX6W::P64;
           I64[Sp - 16] = block_cbYJE_info;
           R2 = _sbX6U::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYJE() //  [R1]
         { info_tbl: [(cbYJE,
                       label: block_cbYJE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYJE: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.389538392 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$csequenceA_closure" {
     Data.Traversable.$fTraversableFirst_$csequenceA_closure:
         const Data.Traversable.$fTraversableFirst_$csequenceA_info;
 },
 sat_sbX75_entry() //  [R1]
         { info_tbl: [(cbYK3,
                       label: sat_sbX75_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYK3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbYK4; else goto cbYK5;
       cbYK4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYK5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbYJW_info;
           _sbX6Z::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbX6Z::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubYKh; else goto cbYJX;
       ubYKh: // global
           call _cbYJW(R1) args: 0, res: 0, upd: 0;
       cbYJX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbYJW() //  [R1]
         { info_tbl: [(cbYJW,
                       label: block_cbYJW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYJW: // global
           _sbX6Z::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbYK0; else goto cbYK1;
       cbYK0: // global
           R2 = _sbX6Z::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cbYK1: // global
           I64[Sp] = block_cbYKb_info;
           R2 = _sbX6Z::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbYKb() //  [R1]
         { info_tbl: [(cbYKb,
                       label: block_cbYKb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYKb: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbYKk,
                       label: Data.Traversable.$fTraversableFirst_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYKk: // global
           _sbX70::P64 = R3;
           _sbX6Z::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYKl; else goto cbYKm;
       cbYKm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYKo; else goto cbYKn;
       cbYKo: // global
           HpAlloc = 32;
           goto cbYKl;
       cbYKl: // global
           R3 = _sbX70::P64;
           R2 = _sbX6Z::P64;
           R1 = Data.Traversable.$fTraversableFirst_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYKn: // global
           I64[Hp - 24] = sat_sbX75_info;
           P64[Hp - 8] = _sbX6Z::P64;
           P64[Hp] = _sbX70::P64;
           I64[Sp - 16] = block_cbYKi_info;
           R2 = _sbX6Z::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYKi() //  [R1]
         { info_tbl: [(cbYKi,
                       label: block_cbYKi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYKi: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.391682485 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$cmapM_closure" {
     Data.Traversable.$fTraversableFirst_$cmapM_closure:
         const Data.Traversable.$fTraversableFirst_$cmapM_info;
 },
 sat_sbX7b_entry() //  [R1]
         { info_tbl: [(cbYKE,
                       label: sat_sbX7b_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYKE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYKF; else goto cbYKG;
       cbYKF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYKG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYKH,
                       label: Data.Traversable.$fTraversableFirst_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYKH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYKJ; else goto cbYKK;
       cbYKJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableFirst_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYKK: // global
           I64[Sp - 24] = block_cbYKw_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYKw() //  [R1]
         { info_tbl: [(cbYKw,
                       label: block_cbYKw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYKw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbYKN; else goto cbYKM;
       cbYKN: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYKM: // global
           I64[Hp - 32] = sat_sbX7b_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbYKI_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYKI() //  [R1]
         { info_tbl: [(cbYKI,
                       label: block_cbYKI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYKI: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.39399369 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$csequence_closure" {
     Data.Traversable.$fTraversableFirst_$csequence_closure:
         const Data.Traversable.$fTraversableFirst_$csequence_info;
 },
 sat_sbX7j_entry() //  [R1]
         { info_tbl: [(cbYLb,
                       label: sat_sbX7j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYLb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbYLc; else goto cbYLd;
       cbYLc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYLd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbYL4_info;
           _sbX7e::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbX7e::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubYLp; else goto cbYL5;
       ubYLp: // global
           call _cbYL4(R1) args: 0, res: 0, upd: 0;
       cbYL5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbYL4() //  [R1]
         { info_tbl: [(cbYL4,
                       label: block_cbYL4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYL4: // global
           _sbX7e::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbYL8; else goto cbYL9;
       cbYL8: // global
           R2 = _sbX7e::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cbYL9: // global
           I64[Sp] = block_cbYLj_info;
           R2 = _sbX7e::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbYLj() //  [R1]
         { info_tbl: [(cbYLj,
                       label: block_cbYLj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYLj: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYLq,
                       label: Data.Traversable.$fTraversableFirst_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYLq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYLs; else goto cbYLt;
       cbYLs: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableFirst_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYLt: // global
           I64[Sp - 16] = block_cbYKW_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYKW() //  [R1]
         { info_tbl: [(cbYKW,
                       label: block_cbYKW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYKW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYLw; else goto cbYLv;
       cbYLw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYLv: // global
           I64[Hp - 24] = sat_sbX7j_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_cbYLr_info;
           R2 = R1;
           P64[Sp + 8] = Hp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYLr() //  [R1]
         { info_tbl: [(cbYLr,
                       label: block_cbYLr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYLr: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.395824214 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_closure" {
     Data.Traversable.$fTraversableFirst_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Monoid.$fFunctorFirst_closure;
         const Data.Foldable.$fFoldableFirst_closure;
         const Data.Traversable.$fTraversableFirst_$ctraverse1_closure+3;
         const Data.Traversable.$fTraversableFirst_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableFirst_$cmapM_closure+3;
         const Data.Traversable.$fTraversableFirst_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.397125447 UTC

[section ""data" . Data.Traversable.$dmtraverse_closure" {
     Data.Traversable.$dmtraverse_closure:
         const Data.Traversable.$dmtraverse_info;
 },
 f1_sbX7n_entry() //  [R1]
         { info_tbl: [(cbYLJ,
                       label: f1_sbX7n_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYLJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYLK; else goto cbYLL;
       cbYLK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYLL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.sequenceA_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 g_sbX7o_entry() //  [R1]
         { info_tbl: [(cbYLS,
                       label: g_sbX7o_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYLS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYLT; else goto cbYLU;
       cbYLT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYLU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbYLQ_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.$p1Traversable_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbYLQ() //  [R1]
         { info_tbl: [(cbYLQ,
                       label: block_cbYLQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYLQ: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbX7s_entry() //  [R1, R2]
         { info_tbl: [(cbYM4,
                       label: sat_sbX7s_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYM4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYM8; else goto cbYM7;
       cbYM8: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYM7: // global
           _sbX7n::P64 = P64[R1 + 7];
           _sbX7o::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX7o::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sbX7n::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$dmtraverse_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYM9,
                       label: Data.Traversable.$dmtraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYM9: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbYMd; else goto cbYMc;
       cbYMd: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$dmtraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYMc: // global
           I64[Hp - 80] = f1_sbX7n_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = g_sbX7o_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sbX7s_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.399381157 UTC

[section ""data" . Data.Traversable.for_closure" {
     Data.Traversable.for_closure:
         const Data.Traversable.for_info;
 },
 f1_sbX7v_entry() //  [R1]
         { info_tbl: [(cbYMm,
                       label: f1_sbX7v_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYMm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYMn; else goto cbYMo;
       cbYMn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYMo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.traverse_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbX7y_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYMu,
                       label: sat_sbX7y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYMu: // global
           _sbX7x::P64 = R3;
           R3 = R2;
           R2 = _sbX7x::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.for_entry() //  [R2, R3]
         { info_tbl: [(cbYMx,
                       label: Data.Traversable.for_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYMx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbYMB; else goto cbYMA;
       cbYMB: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.for_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYMA: // global
           I64[Hp - 40] = f1_sbX7v_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sbX7y_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.401003296 UTC

[section ""data" . Data.Traversable.forM_closure" {
     Data.Traversable.forM_closure:
         const Data.Traversable.forM_info;
 },
 f_sbX7B_entry() //  [R1]
         { info_tbl: [(cbYMK,
                       label: f_sbX7B_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYMK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYML; else goto cbYMM;
       cbYML: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYMM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.mapM_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbX7E_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYMS,
                       label: sat_sbX7E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYMS: // global
           _sbX7D::P64 = R3;
           R3 = R2;
           R2 = _sbX7D::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.forM_entry() //  [R2, R3]
         { info_tbl: [(cbYMV,
                       label: Data.Traversable.forM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYMV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbYMZ; else goto cbYMY;
       cbYMZ: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.forM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYMY: // global
           I64[Hp - 40] = f_sbX7B_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sbX7E_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.402567723 UTC

[section ""data" . Data.Traversable.mapAccumL_closure" {
     Data.Traversable.mapAccumL_closure:
         const Data.Traversable.mapAccumL_info;
         const 0;
 },
 sat_sbX7L_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYN9,
                       label: sat_sbX7L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYN9: // global
           _sbX7K::P64 = R3;
           R3 = R2;
           R2 = _sbX7K::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.mapAccumL_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbYNc,
                       label: Data.Traversable.mapAccumL_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYNc: // global
           _sbX7I::P64 = R5;
           _sbX7H::P64 = R4;
           _sbX7G::P64 = R3;
           _sbX7F::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cbYNd; else goto cbYNe;
       cbYNe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbYNg; else goto cbYNf;
       cbYNg: // global
           HpAlloc = 16;
           goto cbYNd;
       cbYNd: // global
           R5 = _sbX7I::P64;
           R4 = _sbX7H::P64;
           R3 = _sbX7G::P64;
           R2 = _sbX7F::P64;
           R1 = Data.Traversable.mapAccumL_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYNf: // global
           I64[Hp - 8] = sat_sbX7L_info;
           P64[Hp] = _sbX7G::P64;
           R2 = _sbX7F::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Functor.Utils.$fApplicativeStateL_closure;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = _sbX7I::P64;
           P64[Sp - 8] = _sbX7H::P64;
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.404157141 UTC

[section ""data" . Data.Traversable.mapAccumR_closure" {
     Data.Traversable.mapAccumR_closure:
         const Data.Traversable.mapAccumR_info;
         const 0;
 },
 sat_sbX7S_entry() //  [R1, R2, R3]
         { info_tbl: [(cbYNq,
                       label: sat_sbX7S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYNq: // global
           _sbX7R::P64 = R3;
           R3 = R2;
           R2 = _sbX7R::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.mapAccumR_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cbYNt,
                       label: Data.Traversable.mapAccumR_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYNt: // global
           _sbX7P::P64 = R5;
           _sbX7O::P64 = R4;
           _sbX7N::P64 = R3;
           _sbX7M::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cbYNu; else goto cbYNv;
       cbYNv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbYNx; else goto cbYNw;
       cbYNx: // global
           HpAlloc = 16;
           goto cbYNu;
       cbYNu: // global
           R5 = _sbX7P::P64;
           R4 = _sbX7O::P64;
           R3 = _sbX7N::P64;
           R2 = _sbX7M::P64;
           R1 = Data.Traversable.mapAccumR_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYNw: // global
           I64[Hp - 8] = sat_sbX7S_info;
           P64[Hp] = _sbX7N::P64;
           R2 = _sbX7M::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Functor.Utils.$fApplicativeStateR_closure;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = _sbX7P::P64;
           P64[Sp - 8] = _sbX7O::P64;
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.40545936 UTC

[section ""data" . fmapDefault1_rbWTV_closure" {
     fmapDefault1_rbWTV_closure:
         const fmapDefault1_rbWTV_info;
         const 0;
 },
 fmapDefault1_rbWTV_entry() //  [R2]
         { info_tbl: [(cbYNC,
                       label: fmapDefault1_rbWTV_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYNC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYND; else goto cbYNE;
       cbYND: // global
           R2 = R2;
           R1 = fmapDefault1_rbWTV_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYNE: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Functor.Identity.$fApplicativeIdentity_closure;
           Sp = Sp - 16;
           call Data.Traversable.traverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.406350371 UTC

[section ""data" . Data.Traversable.fmapDefault_closure" {
     Data.Traversable.fmapDefault_closure:
         const Data.Traversable.fmapDefault_info;
         const 0;
 },
 Data.Traversable.fmapDefault_entry() //  [R2]
         { info_tbl: [(cbYNJ,
                       label: Data.Traversable.fmapDefault_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYNJ: // global
           R2 = R2;
           call fmapDefault1_rbWTV_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.407364334 UTC

[section ""data" . foldMapDefault1_rbWTW_closure" {
     foldMapDefault1_rbWTW_closure:
         const foldMapDefault1_rbWTW_info;
         const 0;
 },
 sat_sbX7W_entry() //  [R1]
         { info_tbl: [(cbYNU,
                       label: sat_sbX7W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYNU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYNV; else goto cbYNW;
       cbYNV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYNW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fApplicativeConst_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 foldMapDefault1_rbWTW_entry() //  [R2, R3]
         { info_tbl: [(cbYNX,
                       label: foldMapDefault1_rbWTW_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYNX: // global
           _sbX7V::P64 = R3;
           _sbX7U::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbYNY; else goto cbYNZ;
       cbYNZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbYO1; else goto cbYO0;
       cbYO1: // global
           HpAlloc = 24;
           goto cbYNY;
       cbYNY: // global
           R3 = _sbX7V::P64;
           R2 = _sbX7U::P64;
           R1 = foldMapDefault1_rbWTW_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYO0: // global
           I64[Hp - 16] = sat_sbX7W_info;
           P64[Hp] = _sbX7V::P64;
           R2 = _sbX7U::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Traversable.traverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.408633143 UTC

[section ""data" . Data.Traversable.foldMapDefault_closure" {
     Data.Traversable.foldMapDefault_closure:
         const Data.Traversable.foldMapDefault_info;
         const 0;
 },
 Data.Traversable.foldMapDefault_entry() //  [R2, R3]
         { info_tbl: [(cbYO6,
                       label: Data.Traversable.foldMapDefault_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYO6: // global
           R3 = R3;
           R2 = R2;
           call foldMapDefault1_rbWTW_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.409369219 UTC

[section ""cstring" . Data.Traversable.$trModule4_bytes" {
     Data.Traversable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.412372484 UTC

[section ""data" . Data.Traversable.$trModule3_closure" {
     Data.Traversable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Traversable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.412926049 UTC

[section ""cstring" . Data.Traversable.$trModule2_bytes" {
     Data.Traversable.$trModule2_bytes:
         I8[] [68,97,116,97,46,84,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.413495524 UTC

[section ""data" . Data.Traversable.$trModule1_closure" {
     Data.Traversable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Traversable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.414077932 UTC

[section ""data" . Data.Traversable.$trModule_closure" {
     Data.Traversable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Traversable.$trModule3_closure+1;
         const Data.Traversable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.414628839 UTC

[section ""data" . $krep_rbWTX_closure" {
     $krep_rbWTX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.415219452 UTC

[section ""data" . Data.Traversable.$tcTraversable1_closure" {
     Data.Traversable.$tcTraversable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rbWTX_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.415761561 UTC

[section ""cstring" . Data.Traversable.$tcTraversable3_bytes" {
     Data.Traversable.$tcTraversable3_bytes:
         I8[] [84,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.416297679 UTC

[section ""data" . Data.Traversable.$tcTraversable2_closure" {
     Data.Traversable.$tcTraversable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Traversable.$tcTraversable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.416865362 UTC

[section ""data" . Data.Traversable.$tcTraversable_closure" {
     Data.Traversable.$tcTraversable_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Traversable.$trModule_closure+1;
         const Data.Traversable.$tcTraversable2_closure+1;
         const Data.Traversable.$tcTraversable1_closure+4;
         const 9002450311536760373;
         const 4172295783860716183;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.418095162 UTC

[section ""data" . Data.Traversable.C:Traversable_closure" {
     Data.Traversable.C:Traversable_closure:
         const Data.Traversable.C:Traversable_info;
 },
 Data.Traversable.C:Traversable_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbYOe,
                       label: Data.Traversable.C:Traversable_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYOe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbYOi; else goto cbYOh;
       cbYOi: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.C:Traversable_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbYOh: // global
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.419048492 UTC

[Data.Traversable.C:Traversable_con_entry() //  [R1]
         { info_tbl: [(cbYOj,
                       label: Data.Traversable.C:Traversable_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,114,97,118,101,114,115,97,98,108,101,46,67,58,84,114,97,118,101,114,115,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYOj: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.419722538 UTC

[section ""relreadonly" . SbXeW_srt" {
     SbXeW_srt:
         const Data.Foldable.$fFoldableRec1_closure;
         const Data.Traversable.$fTraversableRec1_$cp2Traversable_closure;
         const Data.Foldable.$fFoldableM1_closure;
         const Data.Traversable.$fTraversableM1_$cp2Traversable_closure;
         const Data.Foldable.$fFoldable:+:_closure;
         const Data.Traversable.$fTraversable:+:_$cp2Traversable_closure;
         const Data.Foldable.$fFoldable:*:_closure;
         const Data.Traversable.$fTraversable:*:_$cp2Traversable_closure;
         const Data.Foldable.$fFoldable:.:_closure;
         const Data.Traversable.$fTraversable:.:_$cp2Traversable_closure;
         const Data.Traversable.$fTraversable:.:_closure;
         const Data.Traversable.$fTraversable:*:_closure;
         const Data.Traversable.$fTraversable:+:_closure;
         const Data.Traversable.$fTraversableM1_closure;
         const Data.Traversable.$fTraversableRec1_closure;
         const GHC.Arr.listArray_closure;
         const Data.Traversable.$fTraversableArray_$ctraverse_closure;
         const Data.Traversable.$fTraversableArray_$cmapM_closure;
         const Data.Traversable.$fTraversableArray_$csequence_closure;
         const Data.Traversable.$fTraversableArray_$csequenceA_closure;
         const GHC.Arr.$fFunctorArray_closure;
         const Data.Foldable.$fFoldableArray_closure;
         const Data.Traversable.$fTraversableArray_closure;
         const Data.Functor.Utils.$fApplicativeStateL_closure;
         const Data.Traversable.mapAccumL_closure;
         const Data.Functor.Utils.$fApplicativeStateR_closure;
         const Data.Traversable.mapAccumR_closure;
         const Data.Functor.Identity.$fApplicativeIdentity_closure;
         const fmapDefault1_rbWTV_closure;
         const Data.Functor.Const.$fApplicativeConst_closure;
         const foldMapDefault1_rbWTW_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.420714221 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:50.422108107 UTC

[section ""data" . Data.Traversable.$p1Traversable_closure" {
     Data.Traversable.$p1Traversable_closure:
         const Data.Traversable.$p1Traversable_info;
 },
 Data.Traversable.$p1Traversable_entry() //  [R2]
         { info_tbl: [(cbYOs,
                       label: Data.Traversable.$p1Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYOs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbYOt; else goto cbYOu;
       cbYOt: // global
           R2 = R2;
           R1 = Data.Traversable.$p1Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYOu: // global
           I64[Sp - 8] = block_cbYOp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubYOy; else goto cbYOq;
       ubYOy: // global
           call _cbYOp(R1) args: 0, res: 0, upd: 0;
       cbYOq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYOp() //  [R1]
         { info_tbl: [(cbYOp,
                       label: block_cbYOp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYOp: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.427629913 UTC

[section ""data" . Data.Traversable.$p2Traversable_closure" {
     Data.Traversable.$p2Traversable_closure:
         const Data.Traversable.$p2Traversable_info;
 },
 Data.Traversable.$p2Traversable_entry() //  [R2]
         { info_tbl: [(cbYOR,
                       label: Data.Traversable.$p2Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYOR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbYOS; else goto cbYOT;
       cbYOS: // global
           R2 = R2;
           R1 = Data.Traversable.$p2Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYOT: // global
           I64[Sp - 8] = block_cbYOO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubYOX; else goto cbYOP;
       ubYOX: // global
           call _cbYOO(R1) args: 0, res: 0, upd: 0;
       cbYOP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYOO() //  [R1]
         { info_tbl: [(cbYOO,
                       label: block_cbYOO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYOO: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.432743595 UTC

[section ""data" . Data.Traversable.traverse_closure" {
     Data.Traversable.traverse_closure:
         const Data.Traversable.traverse_info;
 },
 Data.Traversable.traverse_entry() //  [R2]
         { info_tbl: [(cbYPg,
                       label: Data.Traversable.traverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYPg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbYPh; else goto cbYPi;
       cbYPh: // global
           R2 = R2;
           R1 = Data.Traversable.traverse_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYPi: // global
           I64[Sp - 8] = block_cbYPd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubYPm; else goto cbYPe;
       ubYPm: // global
           call _cbYPd(R1) args: 0, res: 0, upd: 0;
       cbYPe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYPd() //  [R1]
         { info_tbl: [(cbYPd,
                       label: block_cbYPd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYPd: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.438245024 UTC

[section ""data" . Data.Traversable.sequenceA_closure" {
     Data.Traversable.sequenceA_closure:
         const Data.Traversable.sequenceA_info;
 },
 Data.Traversable.sequenceA_entry() //  [R2]
         { info_tbl: [(cbYPD,
                       label: Data.Traversable.sequenceA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYPD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbYPE; else goto cbYPF;
       cbYPE: // global
           R2 = R2;
           R1 = Data.Traversable.sequenceA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYPF: // global
           I64[Sp - 8] = block_cbYPA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubYPJ; else goto cbYPB;
       ubYPJ: // global
           call _cbYPA(R1) args: 0, res: 0, upd: 0;
       cbYPB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYPA() //  [R1]
         { info_tbl: [(cbYPA,
                       label: block_cbYPA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYPA: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.444444639 UTC

[section ""data" . Data.Traversable.mapM_closure" {
     Data.Traversable.mapM_closure:
         const Data.Traversable.mapM_info;
 },
 Data.Traversable.mapM_entry() //  [R2]
         { info_tbl: [(cbYQ0,
                       label: Data.Traversable.mapM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYQ0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbYQ1; else goto cbYQ2;
       cbYQ1: // global
           R2 = R2;
           R1 = Data.Traversable.mapM_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYQ2: // global
           I64[Sp - 8] = block_cbYPX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubYQ6; else goto cbYPY;
       ubYQ6: // global
           call _cbYPX(R1) args: 0, res: 0, upd: 0;
       cbYPY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYPX() //  [R1]
         { info_tbl: [(cbYPX,
                       label: block_cbYPX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYPX: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.449994311 UTC

[section ""data" . Data.Traversable.sequence_closure" {
     Data.Traversable.sequence_closure:
         const Data.Traversable.sequence_info;
 },
 Data.Traversable.sequence_entry() //  [R2]
         { info_tbl: [(cbYQn,
                       label: Data.Traversable.sequence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYQn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbYQo; else goto cbYQp;
       cbYQo: // global
           R2 = R2;
           R1 = Data.Traversable.sequence_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYQp: // global
           I64[Sp - 8] = block_cbYQk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubYQt; else goto cbYQl;
       ubYQt: // global
           call _cbYQk(R1) args: 0, res: 0, upd: 0;
       cbYQl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYQk() //  [R1]
         { info_tbl: [(cbYQk,
                       label: block_cbYQk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYQk: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.45533885 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$ctraverse_closure" {
     Data.Traversable.$fTraversableFirst_$ctraverse_closure:
         const Data.Traversable.$fTraversableFirst_$ctraverse_info;
 },
 Data.Traversable.$fTraversableFirst_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbYQO,
                       label: Data.Traversable.$fTraversableFirst_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYQO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYQP; else goto cbYQQ;
       cbYQP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableFirst_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYQQ: // global
           I64[Sp - 24] = block_cbYQH_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubYR5; else goto cbYQI;
       ubYR5: // global
           call _cbYQH(R1) args: 0, res: 0, upd: 0;
       cbYQI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYQH() //  [R1]
         { info_tbl: [(cbYQH,
                       label: block_cbYQH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYQH: // global
           _sbWUL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbYQL; else goto cbYQM;
       cbYQL: // global
           R2 = _sbWUL::P64;
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cbYQM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYR0; else goto cbYQZ;
       cbYR0: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYQZ: // global
           _sbWUP::P64 = P64[R1 + 6];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbWUP::P64;
           I64[Sp + 8] = block_cbYQX_info;
           R2 = _sbWUL::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYQX() //  [R1]
         { info_tbl: [(cbYQX,
                       label: block_cbYQX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYQX: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.463369373 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$ctraverse_closure" {
     Data.Traversable.$fTraversable[]_$ctraverse_closure:
         const Data.Traversable.$fTraversable[]_$ctraverse_info;
 },
 z_sbWUU_entry() //  [R1]
         { info_tbl: [(cbYRu,
                       label: z_sbWUU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYRu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbYRv; else goto cbYRw;
       cbYRv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYRw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbWUV_entry() //  [R1, R2]
         { info_tbl: [(cbYRJ,
                       label: go_sbWUV_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYRJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbYRK; else goto cbYRL;
       cbYRK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYRL: // global
           I64[Sp - 40] = block_cbYRC_info;
           _sbWUV::P64 = R1;
           _sbWUS::P64 = P64[R1 + 7];
           _sbWUT::P64 = P64[R1 + 15];
           _sbWUU::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sbWUS::P64;
           P64[Sp - 24] = _sbWUT::P64;
           P64[Sp - 16] = _sbWUU::P64;
           P64[Sp - 8] = _sbWUV::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubYRW; else goto cbYRD;
       ubYRW: // global
           call _cbYRC(R1) args: 0, res: 0, upd: 0;
       cbYRD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYRC() //  [R1]
         { info_tbl: [(cbYRC,
                       label: block_cbYRC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYRC: // global
           if (R1 & 7 == 1) goto cbYRG; else goto cbYRH;
       cbYRG: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbYRH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbYRT; else goto cbYRS;
       cbYRT: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYRS: // global
           _sbWUY::P64 = P64[R1 + 6];
           _sbWUZ::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sbWUZ::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbWUY::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$ctraverse_entry() //  [R2, R3]
         { info_tbl: [(cbYRX,
                       label: Data.Traversable.$fTraversable[]_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYRX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbYS1; else goto cbYS0;
       cbYS1: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$ctraverse_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYS0: // global
           I64[Hp - 48] = z_sbWUU_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_sbWUV_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.474071166 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$ctraverse_closure" {
     Data.Traversable.$fTraversableEither_$ctraverse_closure:
         const Data.Traversable.$fTraversableEither_$ctraverse_info;
 },
 Data.Traversable.$fTraversableEither_$ctraverse_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cbYSB,
                       label: Data.Traversable.$fTraversableEither_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYSB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYSC; else goto cbYSD;
       cbYSC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYSD: // global
           I64[Sp - 24] = block_cbYSu_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubYSS; else goto cbYSv;
       ubYSS: // global
           call _cbYSu(R1) args: 0, res: 0, upd: 0;
       cbYSv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYSu() //  [R1]
         { info_tbl: [(cbYSu,
                       label: block_cbYSu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYSu: // global
           _sbWV2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbYSy; else goto cbYSz;
       cbYSy: // global
           R2 = _sbWV2::P64;
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cbYSz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYSN; else goto cbYSM;
       cbYSN: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYSM: // global
           _sbWV8::P64 = P64[R1 + 6];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbWV8::P64;
           I64[Sp + 8] = block_cbYSK_info;
           R2 = _sbWV2::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYSK() //  [R1]
         { info_tbl: [(cbYSK,
                       label: block_cbYSK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYSK: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.48333082 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$ctraverse_closure" {
     Data.Traversable.$fTraversable(,)_$ctraverse_closure:
         const Data.Traversable.$fTraversable(,)_$ctraverse_info;
 },
 sat_sbWVi_entry() //  [R1, R2]
         { info_tbl: [(cbYTp,
                       label: sat_sbWVi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYTp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbYTt; else goto cbYTs;
       cbYTt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYTs: // global
           _sbWVf::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbWVf::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$ctraverse_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbYTu,
                       label: Data.Traversable.$fTraversable(,)_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYTu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbYTw; else goto cbYTx;
       cbYTw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYTx: // global
           I64[Sp - 24] = block_cbYTd_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubYTF; else goto cbYTe;
       ubYTF: // global
           call _cbYTd(R1) args: 0, res: 0, upd: 0;
       cbYTe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbYTd() //  [R1]
         { info_tbl: [(cbYTd,
                       label: block_cbYTd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYTd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbYTA; else goto cbYTz;
       cbYTA: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbYTz: // global
           _sbWVf::P64 = P64[R1 + 7];
           _sbWVg::P64 = P64[R1 + 15];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbWVg::P64;
           I64[Hp - 8] = sat_sbWVi_info;
           P64[Hp] = _sbWVf::P64;
           I64[Sp] = block_cbYTv_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 7;
           P64[Sp + 16] = Hp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYTv() //  [R1]
         { info_tbl: [(cbYTv,
                       label: block_cbYTv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYTv: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.492916933 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$csequence_closure" {
     Data.Traversable.$fTraversableProxy_$csequence_closure:
         const Data.Traversable.$fTraversableProxy_$csequence_info;
 },
 Data.Traversable.$fTraversableProxy_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYU5,
                       label: Data.Traversable.$fTraversableProxy_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYU5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYU6; else goto cbYU7;
       cbYU6: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYU7: // global
           I64[Sp - 8] = block_cbYU3_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYU3() //  [R1]
         { info_tbl: [(cbYU3,
                       label: block_cbYU3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYU3: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.498130287 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$cmapM_closure" {
     Data.Traversable.$fTraversableProxy_$cmapM_closure:
         const Data.Traversable.$fTraversableProxy_$cmapM_info;
 },
 Data.Traversable.$fTraversableProxy_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYUp,
                       label: Data.Traversable.$fTraversableProxy_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYUp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYUq; else goto cbYUr;
       cbYUq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYUr: // global
           I64[Sp - 8] = block_cbYUn_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYUn() //  [R1]
         { info_tbl: [(cbYUn,
                       label: block_cbYUn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYUn: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.503155046 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$csequenceA_closure" {
     Data.Traversable.$fTraversableProxy_$csequenceA_closure:
         const Data.Traversable.$fTraversableProxy_$csequenceA_info;
 },
 Data.Traversable.$fTraversableProxy_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbYUH,
                       label: Data.Traversable.$fTraversableProxy_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYUH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYUI; else goto cbYUJ;
       cbYUI: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYUJ: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.507153524 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$ctraverse_closure" {
     Data.Traversable.$fTraversableProxy_$ctraverse_closure:
         const Data.Traversable.$fTraversableProxy_$ctraverse_info;
 },
 Data.Traversable.$fTraversableProxy_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbYUT,
                       label: Data.Traversable.$fTraversableProxy_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYUT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYUU; else goto cbYUV;
       cbYUU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYUV: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.510691701 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_closure" {
     Data.Traversable.$fTraversableProxy_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Proxy.$fFunctorProxy_closure;
         const Data.Foldable.$fFoldableProxy_closure;
         const Data.Traversable.$fTraversableProxy_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableProxy_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableProxy_$cmapM_closure+3;
         const Data.Traversable.$fTraversableProxy_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.512724754 UTC

[section ""data" . Data.Traversable.$fTraversableConst_$ctraverse_closure" {
     Data.Traversable.$fTraversableConst_$ctraverse_closure:
         const Data.Traversable.$fTraversableConst_$ctraverse_info;
 },
 Data.Traversable.$fTraversableConst_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbYV6,
                       label: Data.Traversable.$fTraversableConst_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYV6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYV7; else goto cbYV8;
       cbYV7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableConst_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYV8: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.517061331 UTC

[section ""data" . Data.Traversable.$fTraversableDual1_closure" {
     Data.Traversable.$fTraversableDual1_closure:
         const Data.Traversable.$fTraversableDual1_info;
 },
 Data.Traversable.$fTraversableDual1_entry() //  [R2]
         { info_tbl: [(cbYVi,
                       label: Data.Traversable.$fTraversableDual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYVi: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.520897926 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$ctraverse_closure" {
     Data.Traversable.$fTraversableDual_$ctraverse_closure:
         const Data.Traversable.$fTraversableDual_$ctraverse_info;
 },
 Data.Traversable.$fTraversableDual_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbYVw,
                       label: Data.Traversable.$fTraversableDual_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYVw: // global
           _sbWVC::P64 = R4;
           _sbWVB::P64 = R3;
           _sbWVA::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYVx; else goto cbYVy;
       cbYVy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYVA; else goto cbYVz;
       cbYVA: // global
           HpAlloc = 32;
           goto cbYVx;
       cbYVx: // global
           R4 = _sbWVC::P64;
           R3 = _sbWVB::P64;
           R2 = _sbWVA::P64;
           R1 = Data.Traversable.$fTraversableDual_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYVz: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWVB::P64;
           P64[Hp] = _sbWVC::P64;
           I64[Sp - 16] = block_cbYVu_info;
           R2 = _sbWVA::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYVu() //  [R1]
         { info_tbl: [(cbYVu,
                       label: block_cbYVu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYVu: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.526567934 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$ctraverse_closure" {
     Data.Traversable.$fTraversableSum_$ctraverse_closure:
         const Data.Traversable.$fTraversableSum_$ctraverse_info;
 },
 Data.Traversable.$fTraversableSum_$ctraverse_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbYVU,
                       label: Data.Traversable.$fTraversableSum_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYVU: // global
           _sbWVH::P64 = R4;
           _sbWVG::P64 = R3;
           _sbWVF::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYVV; else goto cbYVW;
       cbYVW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYVY; else goto cbYVX;
       cbYVY: // global
           HpAlloc = 32;
           goto cbYVV;
       cbYVV: // global
           R4 = _sbWVH::P64;
           R3 = _sbWVG::P64;
           R2 = _sbWVF::P64;
           R1 = Data.Traversable.$fTraversableSum_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYVX: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWVG::P64;
           P64[Hp] = _sbWVH::P64;
           I64[Sp - 16] = block_cbYVS_info;
           R2 = _sbWVF::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYVS() //  [R1]
         { info_tbl: [(cbYVS,
                       label: block_cbYVS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYVS: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.53237197 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$ctraverse_closure" {
     Data.Traversable.$fTraversableProduct_$ctraverse_closure:
         const Data.Traversable.$fTraversableProduct_$ctraverse_info;
 },
 Data.Traversable.$fTraversableProduct_$ctraverse_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbYWi,
                       label: Data.Traversable.$fTraversableProduct_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYWi: // global
           _sbWVM::P64 = R4;
           _sbWVL::P64 = R3;
           _sbWVK::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYWj; else goto cbYWk;
       cbYWk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYWm; else goto cbYWl;
       cbYWm: // global
           HpAlloc = 32;
           goto cbYWj;
       cbYWj: // global
           R4 = _sbWVM::P64;
           R3 = _sbWVL::P64;
           R2 = _sbWVK::P64;
           R1 = Data.Traversable.$fTraversableProduct_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYWl: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWVL::P64;
           P64[Hp] = _sbWVM::P64;
           I64[Sp - 16] = block_cbYWg_info;
           R2 = _sbWVK::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYWg() //  [R1]
         { info_tbl: [(cbYWg,
                       label: block_cbYWg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYWg: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.53808997 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$csequence_closure" {
     Data.Traversable.$fTraversableU1_$csequence_closure:
         const Data.Traversable.$fTraversableU1_$csequence_info;
 },
 Data.Traversable.$fTraversableU1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbYWF,
                       label: Data.Traversable.$fTraversableU1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYWF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYWG; else goto cbYWH;
       cbYWG: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYWH: // global
           I64[Sp - 8] = block_cbYWD_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYWD() //  [R1]
         { info_tbl: [(cbYWD,
                       label: block_cbYWD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYWD: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Generics.U1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.543472571 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$cmapM_closure" {
     Data.Traversable.$fTraversableU1_$cmapM_closure:
         const Data.Traversable.$fTraversableU1_$cmapM_info;
 },
 Data.Traversable.$fTraversableU1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbYWZ,
                       label: Data.Traversable.$fTraversableU1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYWZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYX0; else goto cbYX1;
       cbYX0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYX1: // global
           I64[Sp - 8] = block_cbYWX_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYWX() //  [R1]
         { info_tbl: [(cbYWX,
                       label: block_cbYWX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYWX: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Generics.U1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.548618656 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$csequenceA_closure" {
     Data.Traversable.$fTraversableU1_$csequenceA_closure:
         const Data.Traversable.$fTraversableU1_$csequenceA_info;
 },
 Data.Traversable.$fTraversableU1_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbYXh,
                       label: Data.Traversable.$fTraversableU1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYXh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYXi; else goto cbYXj;
       cbYXi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYXj: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Generics.U1_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.552982419 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$ctraverse_closure" {
     Data.Traversable.$fTraversableU1_$ctraverse_closure:
         const Data.Traversable.$fTraversableU1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableU1_$ctraverse_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbYXt,
                       label: Data.Traversable.$fTraversableU1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYXt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYXu; else goto cbYXv;
       cbYXu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYXv: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Generics.U1_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.557099939 UTC

[section ""data" . Data.Traversable.$fTraversableU1_closure" {
     Data.Traversable.$fTraversableU1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorU1_closure;
         const Data.Foldable.$fFoldableU1_closure;
         const Data.Traversable.$fTraversableU1_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableU1_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableU1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableU1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.559254733 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$ctraverse_closure" {
     Data.Traversable.$fTraversableIdentity_$ctraverse_closure:
         const Data.Traversable.$fTraversableIdentity_$ctraverse_info;
 },
 Data.Traversable.$fTraversableIdentity_$ctraverse_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cbYXJ,
                       label: Data.Traversable.$fTraversableIdentity_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYXJ: // global
           _sbWW3::P64 = R4;
           _sbWW2::P64 = R3;
           _sbWW1::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYXK; else goto cbYXL;
       cbYXL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYXN; else goto cbYXM;
       cbYXN: // global
           HpAlloc = 32;
           goto cbYXK;
       cbYXK: // global
           R4 = _sbWW3::P64;
           R3 = _sbWW2::P64;
           R2 = _sbWW1::P64;
           R1 = Data.Traversable.$fTraversableIdentity_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYXM: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWW2::P64;
           P64[Hp] = _sbWW3::P64;
           I64[Sp - 16] = block_cbYXH_info;
           R2 = _sbWW1::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYXH() //  [R1]
         { info_tbl: [(cbYXH,
                       label: block_cbYXH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYXH: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.565378348 UTC

[section ""data" . Data.Traversable.$fTraversableV1_$ctraverse_closure" {
     Data.Traversable.$fTraversableV1_$ctraverse_closure:
         const Data.Traversable.$fTraversableV1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableV1_$ctraverse_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbYY4,
                       label: Data.Traversable.$fTraversableV1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYY4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYY5; else goto cbYY6;
       cbYY5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableV1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYY6: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.569221812 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$ctraverse_closure" {
     Data.Traversable.$fTraversablePar1_$ctraverse_closure:
         const Data.Traversable.$fTraversablePar1_$ctraverse_info;
 },
 Data.Traversable.$fTraversablePar1_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbYYj,
                       label: Data.Traversable.$fTraversablePar1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYYj: // global
           _sbWWb::P64 = R4;
           _sbWWa::P64 = R3;
           _sbWW9::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYYk; else goto cbYYl;
       cbYYl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbYYn; else goto cbYYm;
       cbYYn: // global
           HpAlloc = 32;
           goto cbYYk;
       cbYYk: // global
           R4 = _sbWWb::P64;
           R3 = _sbWWa::P64;
           R2 = _sbWW9::P64;
           R1 = Data.Traversable.$fTraversablePar1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYYm: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbWWa::P64;
           P64[Hp] = _sbWWb::P64;
           I64[Sp - 16] = block_cbYYh_info;
           R2 = _sbWW9::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYYh() //  [R1]
         { info_tbl: [(cbYYh,
                       label: block_cbYYh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYYh: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.574910311 UTC

[section ""data" . Data.Traversable.$fTraversableM2_closure" {
     Data.Traversable.$fTraversableM2_closure:
         const Data.Traversable.$fTraversableM2_info;
 },
 Data.Traversable.$fTraversableM2_entry() //  [R2]
         { info_tbl: [(cbYYE,
                       label: Data.Traversable.$fTraversableM2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYYE: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.578745467 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$ctraverse_closure" {
     Data.Traversable.$fTraversableRec1_$ctraverse_closure:
         const Data.Traversable.$fTraversableRec1_$ctraverse_info;
 },
 sat_sbWWk_entry() //  [R1]
         { info_tbl: [(cbYYT,
                       label: sat_sbWWk_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYYT: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbYYU; else goto cbYYV;
       cbYYU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYYV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$ctraverse_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cbYYY,
                       label: Data.Traversable.$fTraversableRec1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYYY: // global
           _sbWWi::P64 = R5;
           _sbWWh::P64 = R4;
           _sbWWg::P64 = R3;
           _sbWWf::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbYYZ; else goto cbYZ0;
       cbYZ0: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbYZ2; else goto cbYZ1;
       cbYZ2: // global
           HpAlloc = 48;
           goto cbYYZ;
       cbYYZ: // global
           R5 = _sbWWi::P64;
           R4 = _sbWWh::P64;
           R3 = _sbWWg::P64;
           R2 = _sbWWf::P64;
           R1 = Data.Traversable.$fTraversableRec1_$ctraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbYZ1: // global
           I64[Hp - 40] = sat_sbWWk_info;
           P64[Hp - 24] = _sbWWf::P64;
           P64[Hp - 16] = _sbWWg::P64;
           P64[Hp - 8] = _sbWWh::P64;
           P64[Hp] = _sbWWi::P64;
           I64[Sp - 16] = block_cbYYW_info;
           R2 = _sbWWg::P64;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbYYW() //  [R1]
         { info_tbl: [(cbYYW,
                       label: block_cbYYW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYYW: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.58726064 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$cp2Traversable_closure" {
     Data.Traversable.$fTraversableRec1_$cp2Traversable_closure:
         const Data.Traversable.$fTraversableRec1_$cp2Traversable_info;
         const 0;
 },
 sat_sbWWm_entry() //  [R1]
         { info_tbl: [(cbYZu,
                       label: sat_sbWWm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYZu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYZv; else goto cbYZw;
       cbYZv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYZw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$cp2Traversable_entry() //  [R2]
         { info_tbl: [(cbYZx,
                       label: Data.Traversable.$fTraversableRec1_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYZx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbYZB; else goto cbYZA;
       cbYZB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$cp2Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYZA: // global
           I64[Hp - 16] = sat_sbWWm_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldableRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.593306529 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$cp1Traversable_closure" {
     Data.Traversable.$fTraversableRec1_$cp1Traversable_closure:
         const Data.Traversable.$fTraversableRec1_$cp1Traversable_info;
 },
 sat_sbWWo_entry() //  [R1]
         { info_tbl: [(cbYZS,
                       label: sat_sbWWo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYZS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbYZT; else goto cbYZU;
       cbYZT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbYZU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$cp1Traversable_entry() //  [R2]
         { info_tbl: [(cbYZV,
                       label: Data.Traversable.$fTraversableRec1_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbYZV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbYZZ; else goto cbYZY;
       cbYZZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$cp1Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbYZY: // global
           I64[Hp - 16] = sat_sbWWo_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctorRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.598858971 UTC

[section ""data" . Data.Traversable.$fTraversableK1_$ctraverse_closure" {
     Data.Traversable.$fTraversableK1_$ctraverse_closure:
         const Data.Traversable.$fTraversableK1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableK1_$ctraverse_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbZ0c,
                       label: Data.Traversable.$fTraversableK1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ0c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ0d; else goto cbZ0e;
       cbZ0d: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableK1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ0e: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.603178323 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$ctraverse_closure" {
     Data.Traversable.$fTraversableM1_$ctraverse_closure:
         const Data.Traversable.$fTraversableM1_$ctraverse_info;
 },
 sat_sbWWx_entry() //  [R1]
         { info_tbl: [(cbZ0s,
                       label: sat_sbWWx_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ0s: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbZ0t; else goto cbZ0u;
       cbZ0t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ0u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$ctraverse_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cbZ0x,
                       label: Data.Traversable.$fTraversableM1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ0x: // global
           _sbWWv::P64 = R5;
           _sbWWu::P64 = R4;
           _sbWWt::P64 = R3;
           _sbWWs::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbZ0y; else goto cbZ0z;
       cbZ0z: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbZ0B; else goto cbZ0A;
       cbZ0B: // global
           HpAlloc = 48;
           goto cbZ0y;
       cbZ0y: // global
           R5 = _sbWWv::P64;
           R4 = _sbWWu::P64;
           R3 = _sbWWt::P64;
           R2 = _sbWWs::P64;
           R1 = Data.Traversable.$fTraversableM1_$ctraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ0A: // global
           I64[Hp - 40] = sat_sbWWx_info;
           P64[Hp - 24] = _sbWWs::P64;
           P64[Hp - 16] = _sbWWt::P64;
           P64[Hp - 8] = _sbWWu::P64;
           P64[Hp] = _sbWWv::P64;
           I64[Sp - 16] = block_cbZ0v_info;
           R2 = _sbWWt::P64;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZ0v() //  [R1]
         { info_tbl: [(cbZ0v,
                       label: block_cbZ0v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ0v: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.611248315 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$cp2Traversable_closure" {
     Data.Traversable.$fTraversableM1_$cp2Traversable_closure:
         const Data.Traversable.$fTraversableM1_$cp2Traversable_info;
         const 0;
 },
 sat_sbWWz_entry() //  [R1]
         { info_tbl: [(cbZ13,
                       label: sat_sbWWz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ13: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ14; else goto cbZ15;
       cbZ14: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ15: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$cp2Traversable_entry() //  [R2]
         { info_tbl: [(cbZ16,
                       label: Data.Traversable.$fTraversableM1_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ16: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbZ1a; else goto cbZ19;
       cbZ1a: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$cp2Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZ19: // global
           I64[Hp - 16] = sat_sbWWz_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldableM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.617007569 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$cp1Traversable_closure" {
     Data.Traversable.$fTraversableM1_$cp1Traversable_closure:
         const Data.Traversable.$fTraversableM1_$cp1Traversable_info;
 },
 sat_sbWWB_entry() //  [R1]
         { info_tbl: [(cbZ1r,
                       label: sat_sbWWB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ1r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ1s; else goto cbZ1t;
       cbZ1s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ1t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$cp1Traversable_entry() //  [R2]
         { info_tbl: [(cbZ1u,
                       label: Data.Traversable.$fTraversableM1_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ1u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbZ1y; else goto cbZ1x;
       cbZ1y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$cp1Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZ1x: // global
           I64[Hp - 16] = sat_sbWWB_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctorM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.624222604 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$ctraverse_closure" {
     Data.Traversable.$fTraversable:+:_$ctraverse_closure:
         const Data.Traversable.$fTraversable:+:_$ctraverse_info;
 },
 sat_sbWWK_entry() //  [R1]
         { info_tbl: [(cbZ1U,
                       label: sat_sbWWK_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ1U: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbZ1V; else goto cbZ1W;
       cbZ1V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ1W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sbWWN_entry() //  [R1]
         { info_tbl: [(cbZ23,
                       label: sat_sbWWN_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ23: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbZ24; else goto cbZ25;
       cbZ24: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ25: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cbZ2a,
                       label: Data.Traversable.$fTraversable:+:_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ2a: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbZ2b; else goto cbZ2c;
       cbZ2b: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ2c: // global
           I64[Sp - 40] = block_cbZ1L_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubZ2t; else goto cbZ1M;
       ubZ2t: // global
           call _cbZ1L(R1) args: 0, res: 0, upd: 0;
       cbZ1M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZ1L() //  [R1]
         { info_tbl: [(cbZ1L,
                       label: block_cbZ1L_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ1L: // global
           _sbWWE::P64 = P64[Sp + 24];
           _sbWWF::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cbZ27; else goto cbZ28;
       cbZ27: // global
           Hp = Hp + 48;
           _sbWWH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbZ2o; else goto cbZ2f;
       cbZ2f: // global
           _sbWWI::P64 = P64[_sbWWH::P64 + 7];
           I64[Hp - 40] = sat_sbWWK_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sbWWE::P64;
           P64[Hp - 8] = _sbWWF::P64;
           P64[Hp] = _sbWWI::P64;
           I64[Sp + 24] = block_cbZ2d_info;
           R2 = _sbWWE::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
       cbZ28: // global
           Hp = Hp + 48;
           _sbWWH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cbZ2o; else goto cbZ2n;
       cbZ2o: // global
           HpAlloc = 48;
           R1 = _sbWWH::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbZ2n: // global
           _sbWWL::P64 = P64[_sbWWH::P64 + 6];
           I64[Hp - 40] = sat_sbWWN_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbWWE::P64;
           P64[Hp - 8] = _sbWWF::P64;
           P64[Hp] = _sbWWL::P64;
           I64[Sp + 24] = block_cbZ2l_info;
           R2 = _sbWWE::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZ2d() //  [R1]
         { info_tbl: [(cbZ2d,
                       label: block_cbZ2d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ2d: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Generics.L1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cbZ2l() //  [R1]
         { info_tbl: [(cbZ2l,
                       label: block_cbZ2l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ2l: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Generics.R1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.63836487 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$cp2Traversable_closure" {
     Data.Traversable.$fTraversable:+:_$cp2Traversable_closure:
         const Data.Traversable.$fTraversable:+:_$cp2Traversable_info;
         const 0;
 },
 sat_sbWWR_entry() //  [R1]
         { info_tbl: [(cbZ3b,
                       label: sat_sbWWR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ3b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ3c; else goto cbZ3d;
       cbZ3c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ3d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWWQ_entry() //  [R1]
         { info_tbl: [(cbZ3i,
                       label: sat_sbWWQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ3i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ3j; else goto cbZ3k;
       cbZ3j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ3k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbZ3l,
                       label: Data.Traversable.$fTraversable:+:_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ3l: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbZ3p; else goto cbZ3o;
       cbZ3p: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ3o: // global
           I64[Hp - 40] = sat_sbWWR_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWWQ_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldable:+:_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.646113884 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$cp1Traversable_closure" {
     Data.Traversable.$fTraversable:+:_$cp1Traversable_closure:
         const Data.Traversable.$fTraversable:+:_$cp1Traversable_info;
 },
 sat_sbWWV_entry() //  [R1]
         { info_tbl: [(cbZ3K,
                       label: sat_sbWWV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ3K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ3L; else goto cbZ3M;
       cbZ3L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ3M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWWU_entry() //  [R1]
         { info_tbl: [(cbZ3R,
                       label: sat_sbWWU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ3R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ3S; else goto cbZ3T;
       cbZ3S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ3T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbZ3U,
                       label: Data.Traversable.$fTraversable:+:_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ3U: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbZ3Y; else goto cbZ3X;
       cbZ3Y: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ3X: // global
           I64[Hp - 40] = sat_sbWWV_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWWU_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctor:+:_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.657703495 UTC

[section ""data" . Data.Traversable.$w$ctraverse_closure" {
     Data.Traversable.$w$ctraverse_closure:
         const Data.Traversable.$w$ctraverse_info;
 },
 sat_sbWX3_entry() //  [R1]
         { info_tbl: [(cbZ4j,
                       label: sat_sbWX3_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ4j: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbZ4k; else goto cbZ4l;
       cbZ4k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ4l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sbWX2_entry() //  [R1]
         { info_tbl: [(cbZ4q,
                       label: sat_sbWX2_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ4q: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbZ4r; else goto cbZ4s;
       cbZ4r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ4s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$w$ctraverse_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbZ4t,
                       label: Data.Traversable.$w$ctraverse_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ4t: // global
           _sbWX0::P64 = R6;
           _sbWWZ::P64 = R5;
           _sbWWY::P64 = R4;
           _sbWWX::P64 = R3;
           _sbWWW::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbZ4u; else goto cbZ4v;
       cbZ4v: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbZ4x; else goto cbZ4w;
       cbZ4x: // global
           HpAlloc = 96;
           goto cbZ4u;
       cbZ4u: // global
           R6 = _sbWX0::P64;
           R5 = _sbWWZ::P64;
           R4 = _sbWWY::P64;
           R3 = _sbWWX::P64;
           R2 = _sbWWW::P64;
           R1 = Data.Traversable.$w$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbZ4w: // global
           I64[Hp - 88] = sat_sbWX3_info;
           P64[Hp - 72] = _sbWWX::P64;
           P64[Hp - 64] = _sbWWY::P64;
           P64[Hp - 56] = _sbWWZ::P64;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = sat_sbWX2_info;
           P64[Hp - 24] = _sbWWW::P64;
           P64[Hp - 16] = _sbWWY::P64;
           P64[Hp - 8] = _sbWWZ::P64;
           P64[Hp] = _sbWX0::P64;
           R2 = _sbWWY::P64;
           I64[Sp - 24] = stg_ap_ppp_info;
           P64[Sp - 16] = GHC.Generics.:*:_closure+2;
           P64[Sp - 8] = Hp - 40;
           P64[Sp] = Hp - 88;
           Sp = Sp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.66860956 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$ctraverse_closure" {
     Data.Traversable.$fTraversable:*:_$ctraverse_closure:
         const Data.Traversable.$fTraversable:*:_$ctraverse_info;
 },
 Data.Traversable.$fTraversable:*:_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cbZ51,
                       label: Data.Traversable.$fTraversable:*:_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ51: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbZ52; else goto cbZ53;
       cbZ52: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ53: // global
           I64[Sp - 40] = block_cbZ4Y_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubZ57; else goto cbZ4Z;
       ubZ57: // global
           call _cbZ4Y(R1) args: 0, res: 0, upd: 0;
       cbZ4Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZ4Y() //  [R1]
         { info_tbl: [(cbZ4Y,
                       label: block_cbZ4Y_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ4Y: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.6751402 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$cp2Traversable_closure" {
     Data.Traversable.$fTraversable:*:_$cp2Traversable_closure:
         const Data.Traversable.$fTraversable:*:_$cp2Traversable_info;
         const 0;
 },
 sat_sbWXf_entry() //  [R1]
         { info_tbl: [(cbZ5q,
                       label: sat_sbWXf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ5q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ5r; else goto cbZ5s;
       cbZ5r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ5s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWXe_entry() //  [R1]
         { info_tbl: [(cbZ5x,
                       label: sat_sbWXe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ5x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ5y; else goto cbZ5z;
       cbZ5y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ5z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:*:_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbZ5A,
                       label: Data.Traversable.$fTraversable:*:_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ5A: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbZ5E; else goto cbZ5D;
       cbZ5E: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ5D: // global
           I64[Hp - 40] = sat_sbWXf_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWXe_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldable:*:_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.683485495 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$cp1Traversable_closure" {
     Data.Traversable.$fTraversable:*:_$cp1Traversable_closure:
         const Data.Traversable.$fTraversable:*:_$cp1Traversable_info;
 },
 sat_sbWXj_entry() //  [R1]
         { info_tbl: [(cbZ5Z,
                       label: sat_sbWXj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ5Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ60; else goto cbZ61;
       cbZ60: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ61: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWXi_entry() //  [R1]
         { info_tbl: [(cbZ66,
                       label: sat_sbWXi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ66: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ67; else goto cbZ68;
       cbZ67: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ68: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:*:_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbZ69,
                       label: Data.Traversable.$fTraversable:*:_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ69: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbZ6d; else goto cbZ6c;
       cbZ6d: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ6c: // global
           I64[Hp - 40] = sat_sbWXj_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWXi_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctor:*:_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.691792663 UTC

[section ""data" . Data.Traversable.$fTraversable:.:1_closure" {
     Data.Traversable.$fTraversable:.:1_closure:
         const Data.Traversable.$fTraversable:.:1_info;
 },
 Data.Traversable.$fTraversable:.:1_entry() //  [R2]
         { info_tbl: [(cbZ6u,
                       label: Data.Traversable.$fTraversable:.:1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ6u: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.695950491 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$ctraverse_closure" {
     Data.Traversable.$fTraversable:.:_$ctraverse_closure:
         const Data.Traversable.$fTraversable:.:_$ctraverse_info;
 },
 sat_sbWXr_entry() //  [R1]
         { info_tbl: [(cbZ6N,
                       label: sat_sbWXr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ6N: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbZ6O; else goto cbZ6P;
       cbZ6O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ6P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sbWXs_entry() //  [R1]
         { info_tbl: [(cbZ6Q,
                       label: sat_sbWXs_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ6Q: // global
           _sbWXs::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cbZ6R; else goto cbZ6S;
       cbZ6S: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbZ6U; else goto cbZ6T;
       cbZ6U: // global
           HpAlloc = 40;
           goto cbZ6R;
       cbZ6R: // global
           R1 = _sbWXs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ6T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbWXs::P64;
           _sbWXl::P64 = P64[_sbWXs::P64 + 16];
           _sbWXm::P64 = P64[_sbWXs::P64 + 24];
           _sbWXn::P64 = P64[_sbWXs::P64 + 32];
           _sbWXo::P64 = P64[_sbWXs::P64 + 40];
           _sbWXp::P64 = P64[_sbWXs::P64 + 48];
           I64[Hp - 32] = sat_sbWXr_info;
           P64[Hp - 16] = _sbWXm::P64;
           P64[Hp - 8] = _sbWXn::P64;
           P64[Hp] = _sbWXo::P64;
           R2 = _sbWXl::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = _sbWXn::P64;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _sbWXp::P64;
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cbZ6X,
                       label: Data.Traversable.$fTraversable:.:_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ6X: // global
           _sbWXp::P64 = R6;
           _sbWXo::P64 = R5;
           _sbWXn::P64 = R4;
           _sbWXm::P64 = R3;
           _sbWXl::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbZ6Y; else goto cbZ6Z;
       cbZ6Z: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbZ71; else goto cbZ70;
       cbZ71: // global
           HpAlloc = 56;
           goto cbZ6Y;
       cbZ6Y: // global
           R6 = _sbWXp::P64;
           R5 = _sbWXo::P64;
           R4 = _sbWXn::P64;
           R3 = _sbWXm::P64;
           R2 = _sbWXl::P64;
           R1 = Data.Traversable.$fTraversable:.:_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ70: // global
           I64[Hp - 48] = sat_sbWXs_info;
           P64[Hp - 32] = _sbWXl::P64;
           P64[Hp - 24] = _sbWXm::P64;
           P64[Hp - 16] = _sbWXn::P64;
           P64[Hp - 8] = _sbWXo::P64;
           P64[Hp] = _sbWXp::P64;
           I64[Sp - 16] = block_cbZ6V_info;
           R2 = _sbWXn::P64;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZ6V() //  [R1]
         { info_tbl: [(cbZ6V,
                       label: block_cbZ6V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ6V: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversable:.:1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.706339876 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$cp2Traversable_closure" {
     Data.Traversable.$fTraversable:.:_$cp2Traversable_closure:
         const Data.Traversable.$fTraversable:.:_$cp2Traversable_info;
         const 0;
 },
 sat_sbWXw_entry() //  [R1]
         { info_tbl: [(cbZ7x,
                       label: sat_sbWXw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ7x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ7y; else goto cbZ7z;
       cbZ7y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ7z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWXv_entry() //  [R1]
         { info_tbl: [(cbZ7E,
                       label: sat_sbWXv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ7E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ7F; else goto cbZ7G;
       cbZ7F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ7G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbZ7H,
                       label: Data.Traversable.$fTraversable:.:_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ7H: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbZ7L; else goto cbZ7K;
       cbZ7L: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ7K: // global
           I64[Hp - 40] = sat_sbWXw_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWXv_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldable:.:_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.714724376 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$cp1Traversable_closure" {
     Data.Traversable.$fTraversable:.:_$cp1Traversable_closure:
         const Data.Traversable.$fTraversable:.:_$cp1Traversable_info;
 },
 sat_sbWXA_entry() //  [R1]
         { info_tbl: [(cbZ86,
                       label: sat_sbWXA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ86: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ87; else goto cbZ88;
       cbZ87: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ88: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbWXz_entry() //  [R1]
         { info_tbl: [(cbZ8d,
                       label: sat_sbWXz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ8d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ8e; else goto cbZ8f;
       cbZ8e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZ8f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbZ8g,
                       label: Data.Traversable.$fTraversable:.:_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ8g: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbZ8k; else goto cbZ8j;
       cbZ8k: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ8j: // global
           I64[Hp - 40] = sat_sbWXA_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sbWXz_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctor:.:_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.722025931 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec4_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec4_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec4_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbZ8D,
                       label: Data.Traversable.$fTraversableURec4_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ8D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ8E; else goto cbZ8F;
       cbZ8E: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ8F: // global
           I64[Sp - 16] = block_cbZ8B_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZ8B() //  [R1]
         { info_tbl: [(cbZ8B,
                       label: block_cbZ8B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ8B: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.727237678 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec3_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec3_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec3_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbZ8X,
                       label: Data.Traversable.$fTraversableURec3_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ8X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ8Y; else goto cbZ8Z;
       cbZ8Y: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ8Z: // global
           I64[Sp - 16] = block_cbZ8V_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZ8V() //  [R1]
         { info_tbl: [(cbZ8V,
                       label: block_cbZ8V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ8V: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.73238924 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec2_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec2_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec2_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbZ9h,
                       label: Data.Traversable.$fTraversableURec2_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ9h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ9i; else goto cbZ9j;
       cbZ9i: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ9j: // global
           I64[Sp - 16] = block_cbZ9f_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZ9f() //  [R1]
         { info_tbl: [(cbZ9f,
                       label: block_cbZ9f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ9f: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.738017866 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec1_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec1_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbZ9B,
                       label: Data.Traversable.$fTraversableURec1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ9B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ9C; else goto cbZ9D;
       cbZ9C: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ9D: // global
           I64[Sp - 16] = block_cbZ9z_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZ9z() //  [R1]
         { info_tbl: [(cbZ9z,
                       label: block_cbZ9z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ9z: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.743739769 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec0_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec0_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec0_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbZ9V,
                       label: Data.Traversable.$fTraversableURec0_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ9V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZ9W; else goto cbZ9X;
       cbZ9W: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZ9X: // global
           I64[Sp - 16] = block_cbZ9T_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZ9T() //  [R1]
         { info_tbl: [(cbZ9T,
                       label: block_cbZ9T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZ9T: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.748816207 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbZaf,
                       label: Data.Traversable.$fTraversableURec_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZaf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZag; else goto cbZah;
       cbZag: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZah: // global
           I64[Sp - 16] = block_cbZad_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZad() //  [R1]
         { info_tbl: [(cbZad,
                       label: block_cbZad_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZad: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.754401652 UTC

[section ""data" . Data.Traversable.$dmsequence_closure" {
     Data.Traversable.$dmsequence_closure:
         const Data.Traversable.$dmsequence_info;
 },
 sat_sbWYd_entry() //  [R1]
         { info_tbl: [(cbZaB,
                       label: sat_sbWYd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZaB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZaC; else goto cbZaD;
       cbZaC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZaD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$dmsequence_entry() //  [R2, R3]
         { info_tbl: [(cbZaE,
                       label: Data.Traversable.$dmsequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZaE: // global
           _sbWYc::P64 = R3;
           _sbWYb::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbZaF; else goto cbZaG;
       cbZaG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbZaI; else goto cbZaH;
       cbZaI: // global
           HpAlloc = 24;
           goto cbZaF;
       cbZaF: // global
           R3 = _sbWYc::P64;
           R2 = _sbWYb::P64;
           R1 = Data.Traversable.$dmsequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZaH: // global
           I64[Hp - 16] = sat_sbWYd_info;
           P64[Hp] = _sbWYc::P64;
           R2 = _sbWYb::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Traversable.sequenceA_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.760049105 UTC

[section ""data" . Data.Traversable.$dmmapM_closure" {
     Data.Traversable.$dmmapM_closure:
         const Data.Traversable.$dmmapM_info;
 },
 sat_sbWYg_entry() //  [R1]
         { info_tbl: [(cbZb1,
                       label: sat_sbWYg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZb1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZb2; else goto cbZb3;
       cbZb2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZb3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$dmmapM_entry() //  [R2, R3]
         { info_tbl: [(cbZb4,
                       label: Data.Traversable.$dmmapM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZb4: // global
           _sbWYf::P64 = R3;
           _sbWYe::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cbZb5; else goto cbZb6;
       cbZb6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbZb8; else goto cbZb7;
       cbZb8: // global
           HpAlloc = 24;
           goto cbZb5;
       cbZb5: // global
           R3 = _sbWYf::P64;
           R2 = _sbWYe::P64;
           R1 = Data.Traversable.$dmmapM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZb7: // global
           I64[Hp - 16] = sat_sbWYg_info;
           P64[Hp] = _sbWYf::P64;
           R2 = _sbWYe::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Traversable.traverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.765995127 UTC

[section ""data" . Data.Traversable.$dmsequenceA_closure" {
     Data.Traversable.$dmsequenceA_closure:
         const Data.Traversable.$dmsequenceA_info;
 },
 Data.Traversable.$dmsequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbZbn,
                       label: Data.Traversable.$dmsequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZbn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZbo; else goto cbZbp;
       cbZbo: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$dmsequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZbp: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 24;
           call Data.Traversable.traverse_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.769667183 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbZbB,
                       label: Data.Traversable.$fTraversableURec_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZbB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZbC; else goto cbZbD;
       cbZbC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZbD: // global
           I64[Sp - 16] = block_cbZbz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZbz() //  [R1]
         { info_tbl: [(cbZbz,
                       label: block_cbZbz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZbz: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.774839803 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$cmapM_closure" {
     Data.Traversable.$fTraversableURec_$cmapM_closure:
         const Data.Traversable.$fTraversableURec_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZbV,
                       label: Data.Traversable.$fTraversableURec_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZbV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZbZ; else goto cbZc0;
       cbZbZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZc0: // global
           I64[Sp - 16] = block_cbZbT_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZbT() //  [R1]
         { info_tbl: [(cbZbT,
                       label: block_cbZbT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZbT: // global
           I64[Sp] = block_cbZbY_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZbY() //  [R1]
         { info_tbl: [(cbZbY,
                       label: block_cbZbY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZbY: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.78215861 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$csequence_closure" {
     Data.Traversable.$fTraversableURec_$csequence_closure:
         const Data.Traversable.$fTraversableURec_$csequence_info;
 },
 Data.Traversable.$fTraversableURec_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZcn,
                       label: Data.Traversable.$fTraversableURec_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZcn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZcr; else goto cbZcs;
       cbZcr: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZcs: // global
           I64[Sp - 16] = block_cbZcl_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZcl() //  [R1]
         { info_tbl: [(cbZcl,
                       label: block_cbZcl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZcl: // global
           I64[Sp] = block_cbZcq_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZcq() //  [R1]
         { info_tbl: [(cbZcq,
                       label: block_cbZcq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZcq: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.788394194 UTC

[section ""data" . Data.Traversable.$fTraversableURec_closure" {
     Data.Traversable.$fTraversableURec_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec_closure;
         const Data.Foldable.$fFoldableURec_closure;
         const Data.Traversable.$fTraversableURec_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.790811732 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec0_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec0_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec0_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbZcQ,
                       label: Data.Traversable.$fTraversableURec0_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZcQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZcR; else goto cbZcS;
       cbZcR: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZcS: // global
           I64[Sp - 16] = block_cbZcO_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZcO() //  [R1]
         { info_tbl: [(cbZcO,
                       label: block_cbZcO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZcO: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.796016118 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$cmapM_closure" {
     Data.Traversable.$fTraversableURec0_$cmapM_closure:
         const Data.Traversable.$fTraversableURec0_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec0_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZda,
                       label: Data.Traversable.$fTraversableURec0_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZda: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZde; else goto cbZdf;
       cbZde: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZdf: // global
           I64[Sp - 16] = block_cbZd8_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZd8() //  [R1]
         { info_tbl: [(cbZd8,
                       label: block_cbZd8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZd8: // global
           I64[Sp] = block_cbZdd_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZdd() //  [R1]
         { info_tbl: [(cbZdd,
                       label: block_cbZdd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZdd: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.802937421 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$csequence_closure" {
     Data.Traversable.$fTraversableURec0_$csequence_closure:
         const Data.Traversable.$fTraversableURec0_$csequence_info;
 },
 Data.Traversable.$fTraversableURec0_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZdC,
                       label: Data.Traversable.$fTraversableURec0_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZdC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZdG; else goto cbZdH;
       cbZdG: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZdH: // global
           I64[Sp - 16] = block_cbZdA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZdA() //  [R1]
         { info_tbl: [(cbZdA,
                       label: block_cbZdA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZdA: // global
           I64[Sp] = block_cbZdF_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZdF() //  [R1]
         { info_tbl: [(cbZdF,
                       label: block_cbZdF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZdF: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.809859926 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_closure" {
     Data.Traversable.$fTraversableURec0_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec0_closure;
         const Data.Foldable.$fFoldableURec0_closure;
         const Data.Traversable.$fTraversableURec0_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec0_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec0_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec0_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.811901122 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec1_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec1_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec1_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbZe5,
                       label: Data.Traversable.$fTraversableURec1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZe5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZe6; else goto cbZe7;
       cbZe6: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZe7: // global
           I64[Sp - 16] = block_cbZe3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZe3() //  [R1]
         { info_tbl: [(cbZe3,
                       label: block_cbZe3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZe3: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.817007283 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$cmapM_closure" {
     Data.Traversable.$fTraversableURec1_$cmapM_closure:
         const Data.Traversable.$fTraversableURec1_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZep,
                       label: Data.Traversable.$fTraversableURec1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZep: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZet; else goto cbZeu;
       cbZet: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZeu: // global
           I64[Sp - 16] = block_cbZen_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZen() //  [R1]
         { info_tbl: [(cbZen,
                       label: block_cbZen_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZen: // global
           I64[Sp] = block_cbZes_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZes() //  [R1]
         { info_tbl: [(cbZes,
                       label: block_cbZes_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZes: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.823760396 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$csequence_closure" {
     Data.Traversable.$fTraversableURec1_$csequence_closure:
         const Data.Traversable.$fTraversableURec1_$csequence_info;
 },
 Data.Traversable.$fTraversableURec1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZeR,
                       label: Data.Traversable.$fTraversableURec1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZeR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZeV; else goto cbZeW;
       cbZeV: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZeW: // global
           I64[Sp - 16] = block_cbZeP_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZeP() //  [R1]
         { info_tbl: [(cbZeP,
                       label: block_cbZeP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZeP: // global
           I64[Sp] = block_cbZeU_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZeU() //  [R1]
         { info_tbl: [(cbZeU,
                       label: block_cbZeU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZeU: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.830122815 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_closure" {
     Data.Traversable.$fTraversableURec1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec1_closure;
         const Data.Foldable.$fFoldableURec1_closure;
         const Data.Traversable.$fTraversableURec1_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec1_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.832150726 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec2_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec2_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec2_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbZfk,
                       label: Data.Traversable.$fTraversableURec2_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZfk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZfl; else goto cbZfm;
       cbZfl: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZfm: // global
           I64[Sp - 16] = block_cbZfi_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZfi() //  [R1]
         { info_tbl: [(cbZfi,
                       label: block_cbZfi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZfi: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.837724196 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$cmapM_closure" {
     Data.Traversable.$fTraversableURec2_$cmapM_closure:
         const Data.Traversable.$fTraversableURec2_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec2_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZfE,
                       label: Data.Traversable.$fTraversableURec2_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZfE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZfI; else goto cbZfJ;
       cbZfI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZfJ: // global
           I64[Sp - 16] = block_cbZfC_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZfC() //  [R1]
         { info_tbl: [(cbZfC,
                       label: block_cbZfC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZfC: // global
           I64[Sp] = block_cbZfH_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZfH() //  [R1]
         { info_tbl: [(cbZfH,
                       label: block_cbZfH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZfH: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.844877553 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$csequence_closure" {
     Data.Traversable.$fTraversableURec2_$csequence_closure:
         const Data.Traversable.$fTraversableURec2_$csequence_info;
 },
 Data.Traversable.$fTraversableURec2_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZg6,
                       label: Data.Traversable.$fTraversableURec2_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZg6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZga; else goto cbZgb;
       cbZga: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZgb: // global
           I64[Sp - 16] = block_cbZg4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZg4() //  [R1]
         { info_tbl: [(cbZg4,
                       label: block_cbZg4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZg4: // global
           I64[Sp] = block_cbZg9_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZg9() //  [R1]
         { info_tbl: [(cbZg9,
                       label: block_cbZg9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZg9: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.851575195 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_closure" {
     Data.Traversable.$fTraversableURec2_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec2_closure;
         const Data.Foldable.$fFoldableURec2_closure;
         const Data.Traversable.$fTraversableURec2_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec2_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec2_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec2_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.853698332 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec3_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec3_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec3_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbZgz,
                       label: Data.Traversable.$fTraversableURec3_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZgz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZgA; else goto cbZgB;
       cbZgA: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZgB: // global
           I64[Sp - 16] = block_cbZgx_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZgx() //  [R1]
         { info_tbl: [(cbZgx,
                       label: block_cbZgx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZgx: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.858849031 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$cmapM_closure" {
     Data.Traversable.$fTraversableURec3_$cmapM_closure:
         const Data.Traversable.$fTraversableURec3_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec3_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZgT,
                       label: Data.Traversable.$fTraversableURec3_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZgT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZgX; else goto cbZgY;
       cbZgX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZgY: // global
           I64[Sp - 16] = block_cbZgR_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZgR() //  [R1]
         { info_tbl: [(cbZgR,
                       label: block_cbZgR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZgR: // global
           I64[Sp] = block_cbZgW_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZgW() //  [R1]
         { info_tbl: [(cbZgW,
                       label: block_cbZgW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZgW: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.865863825 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$csequence_closure" {
     Data.Traversable.$fTraversableURec3_$csequence_closure:
         const Data.Traversable.$fTraversableURec3_$csequence_info;
 },
 Data.Traversable.$fTraversableURec3_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZhl,
                       label: Data.Traversable.$fTraversableURec3_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZhl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZhp; else goto cbZhq;
       cbZhp: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZhq: // global
           I64[Sp - 16] = block_cbZhj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZhj() //  [R1]
         { info_tbl: [(cbZhj,
                       label: block_cbZhj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZhj: // global
           I64[Sp] = block_cbZho_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZho() //  [R1]
         { info_tbl: [(cbZho,
                       label: block_cbZho_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZho: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.872678131 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_closure" {
     Data.Traversable.$fTraversableURec3_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec3_closure;
         const Data.Foldable.$fFoldableURec3_closure;
         const Data.Traversable.$fTraversableURec3_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec3_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec3_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec3_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.874782702 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec4_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec4_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec4_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbZhO,
                       label: Data.Traversable.$fTraversableURec4_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZhO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZhP; else goto cbZhQ;
       cbZhP: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZhQ: // global
           I64[Sp - 16] = block_cbZhM_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZhM() //  [R1]
         { info_tbl: [(cbZhM,
                       label: block_cbZhM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZhM: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.87997624 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$cmapM_closure" {
     Data.Traversable.$fTraversableURec4_$cmapM_closure:
         const Data.Traversable.$fTraversableURec4_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec4_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZi8,
                       label: Data.Traversable.$fTraversableURec4_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZi8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZic; else goto cbZid;
       cbZic: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZid: // global
           I64[Sp - 16] = block_cbZi6_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZi6() //  [R1]
         { info_tbl: [(cbZi6,
                       label: block_cbZi6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZi6: // global
           I64[Sp] = block_cbZib_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZib() //  [R1]
         { info_tbl: [(cbZib,
                       label: block_cbZib_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZib: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.886724778 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$csequence_closure" {
     Data.Traversable.$fTraversableURec4_$csequence_closure:
         const Data.Traversable.$fTraversableURec4_$csequence_info;
 },
 Data.Traversable.$fTraversableURec4_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZiA,
                       label: Data.Traversable.$fTraversableURec4_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZiA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZiE; else goto cbZiF;
       cbZiE: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZiF: // global
           I64[Sp - 16] = block_cbZiy_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZiy() //  [R1]
         { info_tbl: [(cbZiy,
                       label: block_cbZiy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZiy: // global
           I64[Sp] = block_cbZiD_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZiD() //  [R1]
         { info_tbl: [(cbZiD,
                       label: block_cbZiD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZiD: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.893133182 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_closure" {
     Data.Traversable.$fTraversableURec4_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec4_closure;
         const Data.Foldable.$fFoldableURec4_closure;
         const Data.Traversable.$fTraversableURec4_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec4_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec4_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec4_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.895505984 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$csequenceA_closure" {
     Data.Traversable.$fTraversable:.:_$csequenceA_closure:
         const Data.Traversable.$fTraversable:.:_$csequenceA_info;
 },
 Data.Traversable.$fTraversable:.:_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cbZj1,
                       label: Data.Traversable.$fTraversable:.:_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZj1: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.899013867 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$cmapM_closure" {
     Data.Traversable.$fTraversable:.:_$cmapM_closure:
         const Data.Traversable.$fTraversable:.:_$cmapM_info;
 },
 Data.Traversable.$fTraversable:.:_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cbZje,
                       label: Data.Traversable.$fTraversable:.:_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZje: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbZjf; else goto cbZjg;
       cbZjf: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZjg: // global
           I64[Sp - 40] = block_cbZjc_info;
           _sbX06::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sbX06::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZjc() //  [R1]
         { info_tbl: [(cbZjc,
                       label: block_cbZjc_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZjc: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.905050561 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$csequence_closure" {
     Data.Traversable.$fTraversable:.:_$csequence_closure:
         const Data.Traversable.$fTraversable:.:_$csequence_info;
 },
 Data.Traversable.$fTraversable:.:_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cbZjy,
                       label: Data.Traversable.$fTraversable:.:_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZjy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZjz; else goto cbZjA;
       cbZjz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZjA: // global
           I64[Sp - 32] = block_cbZjw_info;
           _sbX0c::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sbX0c::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZjw() //  [R1]
         { info_tbl: [(cbZjw,
                       label: block_cbZjw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZjw: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.911405168 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_closure" {
     Data.Traversable.$fTraversable:.:_closure:
         const Data.Traversable.$fTraversable:.:_info;
         const 0;
 },
 sat_sbX0o_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZjV,
                       label: sat_sbX0o_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZjV: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:.:_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0n_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbZk3,
                       label: sat_sbX0n_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZk3: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:.:_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0m_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZkb,
                       label: sat_sbX0m_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZkb: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:.:_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0l_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbZkj,
                       label: sat_sbX0l_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZkj: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0k_entry() //  [R1]
         { info_tbl: [(cbZkq,
                       label: sat_sbX0k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZkq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZkr; else goto cbZks;
       cbZkr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZks: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:.:_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX0j_entry() //  [R1]
         { info_tbl: [(cbZkx,
                       label: sat_sbX0j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZkx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZky; else goto cbZkz;
       cbZky: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZkz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:.:_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_entry() //  [R2, R3]
         { info_tbl: [(cbZkB,
                       label: Data.Traversable.$fTraversable:.:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZkB: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cbZkF; else goto cbZkE;
       cbZkF: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZkE: // global
           I64[Hp - 208] = sat_sbX0o_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sbX0n_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sbX0m_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sbX0l_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sbX0k_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sbX0j_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.926296386 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$csequenceA_closure" {
     Data.Traversable.$fTraversable:*:_$csequenceA_closure:
         const Data.Traversable.$fTraversable:*:_$csequenceA_info;
 },
 Data.Traversable.$fTraversable:*:_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cbZli,
                       label: Data.Traversable.$fTraversable:*:_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZli: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZlj; else goto cbZlk;
       cbZlj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$csequenceA_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZlk: // global
           I64[Sp - 32] = block_cbZlf_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubZlo; else goto cbZlg;
       ubZlo: // global
           call _cbZlf(R1) args: 0, res: 0, upd: 0;
       cbZlg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZlf() //  [R1]
         { info_tbl: [(cbZlf,
                       label: block_cbZlf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZlf: // global
           R6 = P64[R1 + 7];
           R5 = GHC.Base.id_closure+1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.932194283 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$cmapM_closure" {
     Data.Traversable.$fTraversable:*:_$cmapM_closure:
         const Data.Traversable.$fTraversable:*:_$cmapM_info;
 },
 Data.Traversable.$fTraversable:*:_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cbZlG,
                       label: Data.Traversable.$fTraversable:*:_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZlG: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbZlK; else goto cbZlL;
       cbZlK: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZlL: // global
           I64[Sp - 40] = block_cbZlD_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubZlR; else goto cbZlE;
       ubZlR: // global
           call _cbZlD(R1) args: 0, res: 0, upd: 0;
       cbZlE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZlD() //  [R1]
         { info_tbl: [(cbZlD,
                       label: block_cbZlD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZlD: // global
           I64[Sp - 8] = block_cbZlJ_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZlJ() //  [R1]
         { info_tbl: [(cbZlJ,
                       label: block_cbZlJ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZlJ: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 40];
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.939912917 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$csequence_closure" {
     Data.Traversable.$fTraversable:*:_$csequence_closure:
         const Data.Traversable.$fTraversable:*:_$csequence_info;
 },
 Data.Traversable.$fTraversable:*:_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cbZme,
                       label: Data.Traversable.$fTraversable:*:_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZme: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbZmi; else goto cbZmj;
       cbZmi: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZmj: // global
           I64[Sp - 32] = block_cbZmb_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubZmp; else goto cbZmc;
       ubZmp: // global
           call _cbZmb(R1) args: 0, res: 0, upd: 0;
       cbZmc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZmb() //  [R1]
         { info_tbl: [(cbZmb,
                       label: block_cbZmb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZmb: // global
           I64[Sp - 8] = block_cbZmh_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZmh() //  [R1]
         { info_tbl: [(cbZmh,
                       label: block_cbZmh_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZmh: // global
           R6 = P64[Sp + 32];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.948582014 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_closure" {
     Data.Traversable.$fTraversable:*:_closure:
         const Data.Traversable.$fTraversable:*:_info;
         const 0;
 },
 sat_sbX0U_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZmO,
                       label: sat_sbX0U_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZmO: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:*:_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0T_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbZmW,
                       label: sat_sbX0T_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZmW: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:*:_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0S_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZn4,
                       label: sat_sbX0S_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZn4: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:*:_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0R_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbZnc,
                       label: sat_sbX0R_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZnc: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:*:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX0Q_entry() //  [R1]
         { info_tbl: [(cbZnj,
                       label: sat_sbX0Q_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZnj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZnk; else goto cbZnl;
       cbZnk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZnl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:*:_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX0P_entry() //  [R1]
         { info_tbl: [(cbZnq,
                       label: sat_sbX0P_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZnq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZnr; else goto cbZns;
       cbZnr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZns: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:*:_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:*:_entry() //  [R2, R3]
         { info_tbl: [(cbZnu,
                       label: Data.Traversable.$fTraversable:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZnu: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cbZny; else goto cbZnx;
       cbZny: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZnx: // global
           I64[Hp - 208] = sat_sbX0U_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sbX0T_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sbX0S_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sbX0R_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sbX0Q_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sbX0P_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.966132801 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$csequenceA_closure" {
     Data.Traversable.$fTraversable:+:_$csequenceA_closure:
         const Data.Traversable.$fTraversable:+:_$csequenceA_info;
 },
 Data.Traversable.$fTraversable:+:_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cbZo8,
                       label: Data.Traversable.$fTraversable:+:_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZo8: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.970657321 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$cmapM_closure" {
     Data.Traversable.$fTraversable:+:_$cmapM_closure:
         const Data.Traversable.$fTraversable:+:_$cmapM_info;
 },
 Data.Traversable.$fTraversable:+:_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cbZol,
                       label: Data.Traversable.$fTraversable:+:_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZol: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbZom; else goto cbZon;
       cbZom: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZon: // global
           I64[Sp - 40] = block_cbZoj_info;
           _sbX0Y::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sbX0Y::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZoj() //  [R1]
         { info_tbl: [(cbZoj,
                       label: block_cbZoj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZoj: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.977533901 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$csequence_closure" {
     Data.Traversable.$fTraversable:+:_$csequence_closure:
         const Data.Traversable.$fTraversable:+:_$csequence_info;
 },
 Data.Traversable.$fTraversable:+:_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cbZoF,
                       label: Data.Traversable.$fTraversable:+:_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZoF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZoG; else goto cbZoH;
       cbZoG: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZoH: // global
           I64[Sp - 32] = block_cbZoD_info;
           _sbX14::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sbX14::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZoD() //  [R1]
         { info_tbl: [(cbZoD,
                       label: block_cbZoD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZoD: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:50.985843562 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_closure" {
     Data.Traversable.$fTraversable:+:_closure:
         const Data.Traversable.$fTraversable:+:_info;
         const 0;
 },
 sat_sbX1g_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZp2,
                       label: sat_sbX1g_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZp2: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:+:_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1f_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbZpa,
                       label: sat_sbX1f_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZpa: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:+:_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1e_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZpi,
                       label: sat_sbX1e_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZpi: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:+:_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1d_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbZpq,
                       label: sat_sbX1d_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZpq: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1c_entry() //  [R1]
         { info_tbl: [(cbZpx,
                       label: sat_sbX1c_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZpx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZpy; else goto cbZpz;
       cbZpy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZpz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:+:_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX1b_entry() //  [R1]
         { info_tbl: [(cbZpE,
                       label: sat_sbX1b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZpE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZpF; else goto cbZpG;
       cbZpF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZpG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:+:_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_entry() //  [R2, R3]
         { info_tbl: [(cbZpI,
                       label: Data.Traversable.$fTraversable:+:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZpI: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cbZpM; else goto cbZpL;
       cbZpM: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZpL: // global
           I64[Hp - 208] = sat_sbX1g_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sbX1f_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sbX1e_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sbX1d_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sbX1c_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sbX1b_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.00299682 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$csequenceA_closure" {
     Data.Traversable.$fTraversableM1_$csequenceA_closure:
         const Data.Traversable.$fTraversableM1_$csequenceA_info;
 },
 sat_sbX1l_entry() //  [R1]
         { info_tbl: [(cbZqq,
                       label: sat_sbX1l_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZqq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbZqr; else goto cbZqs;
       cbZqr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZqs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$csequenceA_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbZqv,
                       label: Data.Traversable.$fTraversableM1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZqv: // global
           _sbX1j::P64 = R4;
           _sbX1i::P64 = R3;
           _sbX1h::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbZqw; else goto cbZqx;
       cbZqx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbZqz; else goto cbZqy;
       cbZqz: // global
           HpAlloc = 40;
           goto cbZqw;
       cbZqw: // global
           R4 = _sbX1j::P64;
           R3 = _sbX1i::P64;
           R2 = _sbX1h::P64;
           R1 = Data.Traversable.$fTraversableM1_$csequenceA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZqy: // global
           I64[Hp - 32] = sat_sbX1l_info;
           P64[Hp - 16] = _sbX1h::P64;
           P64[Hp - 8] = _sbX1i::P64;
           P64[Hp] = _sbX1j::P64;
           I64[Sp - 16] = block_cbZqt_info;
           R2 = _sbX1i::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZqt() //  [R1]
         { info_tbl: [(cbZqt,
                       label: block_cbZqt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZqt: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.010863286 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$cmapM_closure" {
     Data.Traversable.$fTraversableM1_$cmapM_closure:
         const Data.Traversable.$fTraversableM1_$cmapM_info;
 },
 sat_sbX1s_entry() //  [R1]
         { info_tbl: [(cbZr4,
                       label: sat_sbX1s_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZr4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbZr5; else goto cbZr6;
       cbZr5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZr6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$cmapM_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cbZr7,
                       label: Data.Traversable.$fTraversableM1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZr7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZr9; else goto cbZra;
       cbZr9: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$cmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZra: // global
           I64[Sp - 32] = block_cbZqW_info;
           _sbX1m::P64 = R2;
           R2 = R3;
           P64[Sp - 24] = _sbX1m::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZqW() //  [R1]
         { info_tbl: [(cbZqW,
                       label: block_cbZqW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZqW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbZrd; else goto cbZrc;
       cbZrd: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbZrc: // global
           I64[Hp - 40] = sat_sbX1s_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           I64[Sp + 16] = block_cbZr8_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 40;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZr8() //  [R1]
         { info_tbl: [(cbZr8,
                       label: block_cbZr8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZr8: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.020170417 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$csequence_closure" {
     Data.Traversable.$fTraversableM1_$csequence_closure:
         const Data.Traversable.$fTraversableM1_$csequence_info;
 },
 sat_sbX1y_entry() //  [R1]
         { info_tbl: [(cbZrQ,
                       label: sat_sbX1y_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZrQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbZrR; else goto cbZrS;
       cbZrR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZrS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$csequence_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbZrT,
                       label: Data.Traversable.$fTraversableM1_$csequence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZrT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZrV; else goto cbZrW;
       cbZrV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$csequence_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZrW: // global
           I64[Sp - 24] = block_cbZrI_info;
           _sbX1t::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _sbX1t::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZrI() //  [R1]
         { info_tbl: [(cbZrI,
                       label: block_cbZrI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZrI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbZrZ; else goto cbZrY;
       cbZrZ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbZrY: // global
           I64[Hp - 32] = sat_sbX1y_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbZrU_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZrU() //  [R1]
         { info_tbl: [(cbZrU,
                       label: block_cbZrU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZrU: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.030812158 UTC

[section ""data" . Data.Traversable.$fTraversableM1_closure" {
     Data.Traversable.$fTraversableM1_closure:
         const Data.Traversable.$fTraversableM1_info;
         const 0;
 },
 sat_sbX1F_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZsx,
                       label: sat_sbX1F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZsx: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableM1_$csequence_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1E_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbZsF,
                       label: sat_sbX1E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZsF: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableM1_$cmapM_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1D_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZsN,
                       label: sat_sbX1D_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZsN: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableM1_$csequenceA_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1C_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbZsV,
                       label: sat_sbX1C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZsV: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableM1_$ctraverse_entry(R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX1B_entry() //  [R1]
         { info_tbl: [(cbZt2,
                       label: sat_sbX1B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZt2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZt3; else goto cbZt4;
       cbZt3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZt4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableM1_$cp2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX1A_entry() //  [R1]
         { info_tbl: [(cbZt9,
                       label: sat_sbX1A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZt9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZta; else goto cbZtb;
       cbZta: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZtb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableM1_$cp1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_entry() //  [R2]
         { info_tbl: [(cbZtd,
                       label: Data.Traversable.$fTraversableM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZtd: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbZth; else goto cbZtg;
       cbZth: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZtg: // global
           I64[Hp - 160] = sat_sbX1F_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sbX1E_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbX1D_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbX1C_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbX1B_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbX1A_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 96;
           P64[Hp - 24] = Hp - 109;
           P64[Hp - 16] = Hp - 126;
           P64[Hp - 8] = Hp - 141;
           P64[Hp] = Hp - 158;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.044787889 UTC

[section ""data" . Data.Traversable.$fTraversableK1_$cmapM_closure" {
     Data.Traversable.$fTraversableK1_$cmapM_closure:
         const Data.Traversable.$fTraversableK1_$cmapM_info;
 },
 Data.Traversable.$fTraversableK1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZtT,
                       label: Data.Traversable.$fTraversableK1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZtT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZtU; else goto cbZtV;
       cbZtU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableK1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZtV: // global
           I64[Sp - 16] = block_cbZtR_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZtR() //  [R1]
         { info_tbl: [(cbZtR,
                       label: block_cbZtR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZtR: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.049899831 UTC

[section ""data" . Data.Traversable.$fTraversableK1_$csequence_closure" {
     Data.Traversable.$fTraversableK1_$csequence_closure:
         const Data.Traversable.$fTraversableK1_$csequence_info;
 },
 Data.Traversable.$fTraversableK1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZud,
                       label: Data.Traversable.$fTraversableK1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZud: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZue; else goto cbZuf;
       cbZue: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableK1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZuf: // global
           I64[Sp - 16] = block_cbZub_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZub() //  [R1]
         { info_tbl: [(cbZub,
                       label: block_cbZub_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZub: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.054999128 UTC

[section ""data" . $fTraversableK2_rbWTS_closure" {
     $fTraversableK2_rbWTS_closure:
         const $fTraversableK2_rbWTS_info;
 },
 $fTraversableK2_rbWTS_entry() //  [R2, R3]
         { info_tbl: [(cbZuv,
                       label: $fTraversableK2_rbWTS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZuv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZuw; else goto cbZux;
       cbZuw: // global
           R3 = R3;
           R2 = R2;
           R1 = $fTraversableK2_rbWTS_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZux: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.059036448 UTC

[section ""data" . Data.Traversable.$fTraversableK1_closure" {
     Data.Traversable.$fTraversableK1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorK1_closure;
         const Data.Foldable.$fFoldableK1_closure;
         const Data.Traversable.$fTraversableK1_$ctraverse_closure+3;
         const $fTraversableK2_rbWTS_closure+2;
         const Data.Traversable.$fTraversableK1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableK1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.061270379 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$csequenceA_closure" {
     Data.Traversable.$fTraversableRec1_$csequenceA_closure:
         const Data.Traversable.$fTraversableRec1_$csequenceA_info;
 },
 sat_sbX1T_entry() //  [R1]
         { info_tbl: [(cbZuM,
                       label: sat_sbX1T_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZuM: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbZuN; else goto cbZuO;
       cbZuN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZuO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$csequenceA_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbZuR,
                       label: Data.Traversable.$fTraversableRec1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZuR: // global
           _sbX1R::P64 = R4;
           _sbX1Q::P64 = R3;
           _sbX1P::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbZuS; else goto cbZuT;
       cbZuT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbZuV; else goto cbZuU;
       cbZuV: // global
           HpAlloc = 40;
           goto cbZuS;
       cbZuS: // global
           R4 = _sbX1R::P64;
           R3 = _sbX1Q::P64;
           R2 = _sbX1P::P64;
           R1 = Data.Traversable.$fTraversableRec1_$csequenceA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZuU: // global
           I64[Hp - 32] = sat_sbX1T_info;
           P64[Hp - 16] = _sbX1P::P64;
           P64[Hp - 8] = _sbX1Q::P64;
           P64[Hp] = _sbX1R::P64;
           I64[Sp - 16] = block_cbZuP_info;
           R2 = _sbX1Q::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZuP() //  [R1]
         { info_tbl: [(cbZuP,
                       label: block_cbZuP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZuP: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.068885003 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$cmapM_closure" {
     Data.Traversable.$fTraversableRec1_$cmapM_closure:
         const Data.Traversable.$fTraversableRec1_$cmapM_info;
 },
 sat_sbX20_entry() //  [R1]
         { info_tbl: [(cbZvq,
                       label: sat_sbX20_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZvq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbZvr; else goto cbZvs;
       cbZvr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZvs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$cmapM_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cbZvt,
                       label: Data.Traversable.$fTraversableRec1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZvt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZvv; else goto cbZvw;
       cbZvv: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$cmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZvw: // global
           I64[Sp - 32] = block_cbZvi_info;
           _sbX1U::P64 = R2;
           R2 = R3;
           P64[Sp - 24] = _sbX1U::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZvi() //  [R1]
         { info_tbl: [(cbZvi,
                       label: block_cbZvi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZvi: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbZvz; else goto cbZvy;
       cbZvz: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbZvy: // global
           I64[Hp - 40] = sat_sbX20_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           I64[Sp + 16] = block_cbZvu_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 40;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZvu() //  [R1]
         { info_tbl: [(cbZvu,
                       label: block_cbZvu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZvu: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.078608193 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$csequence_closure" {
     Data.Traversable.$fTraversableRec1_$csequence_closure:
         const Data.Traversable.$fTraversableRec1_$csequence_info;
 },
 sat_sbX26_entry() //  [R1]
         { info_tbl: [(cbZwc,
                       label: sat_sbX26_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZwc: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbZwd; else goto cbZwe;
       cbZwd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZwe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$csequence_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbZwf,
                       label: Data.Traversable.$fTraversableRec1_$csequence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZwf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZwh; else goto cbZwi;
       cbZwh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$csequence_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZwi: // global
           I64[Sp - 24] = block_cbZw4_info;
           _sbX21::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _sbX21::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZw4() //  [R1]
         { info_tbl: [(cbZw4,
                       label: block_cbZw4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZw4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbZwl; else goto cbZwk;
       cbZwl: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbZwk: // global
           I64[Hp - 32] = sat_sbX26_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cbZwg_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZwg() //  [R1]
         { info_tbl: [(cbZwg,
                       label: block_cbZwg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZwg: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.088669177 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_closure" {
     Data.Traversable.$fTraversableRec1_closure:
         const Data.Traversable.$fTraversableRec1_info;
         const 0;
 },
 sat_sbX2d_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZwT,
                       label: sat_sbX2d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZwT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableRec1_$csequence_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX2c_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbZx1,
                       label: sat_sbX2c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZx1: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableRec1_$cmapM_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX2b_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZx9,
                       label: sat_sbX2b_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZx9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableRec1_$csequenceA_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX2a_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbZxh,
                       label: sat_sbX2a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZxh: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableRec1_$ctraverse_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX29_entry() //  [R1]
         { info_tbl: [(cbZxo,
                       label: sat_sbX29_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZxo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZxp; else goto cbZxq;
       cbZxp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZxq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableRec1_$cp2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX28_entry() //  [R1]
         { info_tbl: [(cbZxv,
                       label: sat_sbX28_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZxv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZxw; else goto cbZxx;
       cbZxw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZxx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableRec1_$cp1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_entry() //  [R2]
         { info_tbl: [(cbZxz,
                       label: Data.Traversable.$fTraversableRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZxz: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cbZxD; else goto cbZxC;
       cbZxD: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZxC: // global
           I64[Hp - 160] = sat_sbX2d_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sbX2c_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sbX2b_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sbX2a_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbX29_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sbX28_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 96;
           P64[Hp - 24] = Hp - 109;
           P64[Hp - 16] = Hp - 126;
           P64[Hp - 8] = Hp - 141;
           P64[Hp] = Hp - 158;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.10366264 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$csequenceA_closure" {
     Data.Traversable.$fTraversablePar1_$csequenceA_closure:
         const Data.Traversable.$fTraversablePar1_$csequenceA_info;
 },
 Data.Traversable.$fTraversablePar1_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbZyf,
                       label: Data.Traversable.$fTraversablePar1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZyf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZyg; else goto cbZyh;
       cbZyg: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversablePar1_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZyh: // global
           I64[Sp - 16] = block_cbZyd_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZyd() //  [R1]
         { info_tbl: [(cbZyd,
                       label: block_cbZyd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZyd: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.108863191 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$cmapM_closure" {
     Data.Traversable.$fTraversablePar1_$cmapM_closure:
         const Data.Traversable.$fTraversablePar1_$cmapM_info;
 },
 Data.Traversable.$fTraversablePar1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZyA,
                       label: Data.Traversable.$fTraversablePar1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZyA: // global
           _sbX2j::P64 = R4;
           _sbX2i::P64 = R3;
           _sbX2h::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbZyE; else goto cbZyF;
       cbZyF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbZyH; else goto cbZyG;
       cbZyH: // global
           HpAlloc = 32;
           goto cbZyE;
       cbZyE: // global
           R4 = _sbX2j::P64;
           R3 = _sbX2i::P64;
           R2 = _sbX2h::P64;
           R1 = Data.Traversable.$fTraversablePar1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZyG: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX2i::P64;
           P64[Hp] = _sbX2j::P64;
           I64[Sp - 16] = block_cbZyy_info;
           R2 = _sbX2h::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZyy() //  [R1]
         { info_tbl: [(cbZyy,
                       label: block_cbZyy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZyy: // global
           I64[Sp] = block_cbZyD_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZyD() //  [R1]
         { info_tbl: [(cbZyD,
                       label: block_cbZyD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZyD: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.116079756 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$csequence_closure" {
     Data.Traversable.$fTraversablePar1_$csequence_closure:
         const Data.Traversable.$fTraversablePar1_$csequence_info;
 },
 Data.Traversable.$fTraversablePar1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZz5,
                       label: Data.Traversable.$fTraversablePar1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZz5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZz9; else goto cbZza;
       cbZz9: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversablePar1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZza: // global
           I64[Sp - 16] = block_cbZz3_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZz3() //  [R1]
         { info_tbl: [(cbZz3,
                       label: block_cbZz3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZz3: // global
           I64[Sp] = block_cbZz8_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZz8() //  [R1]
         { info_tbl: [(cbZz8,
                       label: block_cbZz8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZz8: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.122738282 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_closure" {
     Data.Traversable.$fTraversablePar1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorPar1_closure;
         const Data.Foldable.$fFoldablePar1_closure;
         const Data.Traversable.$fTraversablePar1_$ctraverse_closure+3;
         const Data.Traversable.$fTraversablePar1_$csequenceA_closure+2;
         const Data.Traversable.$fTraversablePar1_$cmapM_closure+3;
         const Data.Traversable.$fTraversablePar1_$csequence_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.12484157 UTC

[section ""data" . Data.Traversable.$fTraversableV1_$cmapM_closure" {
     Data.Traversable.$fTraversableV1_$cmapM_closure:
         const Data.Traversable.$fTraversableV1_$cmapM_info;
 },
 Data.Traversable.$fTraversableV1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZzy,
                       label: Data.Traversable.$fTraversableV1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZzy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZzz; else goto cbZzA;
       cbZzz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableV1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZzA: // global
           I64[Sp - 16] = block_cbZzw_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZzw() //  [R1]
         { info_tbl: [(cbZzw,
                       label: block_cbZzw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZzw: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.130333369 UTC

[section ""data" . Data.Traversable.$fTraversableV1_$csequence_closure" {
     Data.Traversable.$fTraversableV1_$csequence_closure:
         const Data.Traversable.$fTraversableV1_$csequence_info;
 },
 Data.Traversable.$fTraversableV1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZzS,
                       label: Data.Traversable.$fTraversableV1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZzS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZzT; else goto cbZzU;
       cbZzT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableV1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZzU: // global
           I64[Sp - 16] = block_cbZzQ_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZzQ() //  [R1]
         { info_tbl: [(cbZzQ,
                       label: block_cbZzQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZzQ: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.135582492 UTC

[section ""data" . $fTraversableV2_rbWTT_closure" {
     $fTraversableV2_rbWTT_closure:
         const $fTraversableV2_rbWTT_info;
 },
 $fTraversableV2_rbWTT_entry() //  [R2, R3]
         { info_tbl: [(cbZAa,
                       label: $fTraversableV2_rbWTT_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZAa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZAb; else goto cbZAc;
       cbZAb: // global
           R3 = R3;
           R2 = R2;
           R1 = $fTraversableV2_rbWTT_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZAc: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.138921176 UTC

[section ""data" . Data.Traversable.$fTraversableV1_closure" {
     Data.Traversable.$fTraversableV1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorV1_closure;
         const Data.Foldable.$fFoldableV1_closure;
         const Data.Traversable.$fTraversableV1_$ctraverse_closure+3;
         const $fTraversableV2_rbWTT_closure+2;
         const Data.Traversable.$fTraversableV1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableV1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.140860885 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$csequenceA_closure" {
     Data.Traversable.$fTraversableIdentity_$csequenceA_closure:
         const Data.Traversable.$fTraversableIdentity_$csequenceA_info;
 },
 Data.Traversable.$fTraversableIdentity_$csequenceA_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cbZAp,
                       label: Data.Traversable.$fTraversableIdentity_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZAp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZAq; else goto cbZAr;
       cbZAq: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableIdentity_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZAr: // global
           I64[Sp - 16] = block_cbZAn_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZAn() //  [R1]
         { info_tbl: [(cbZAn,
                       label: block_cbZAn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZAn: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.146286623 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$cmapM_closure" {
     Data.Traversable.$fTraversableIdentity_$cmapM_closure:
         const Data.Traversable.$fTraversableIdentity_$cmapM_info;
 },
 Data.Traversable.$fTraversableIdentity_$cmapM_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbZAK,
                       label: Data.Traversable.$fTraversableIdentity_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZAK: // global
           _sbX2F::P64 = R4;
           _sbX2E::P64 = R3;
           _sbX2D::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbZAO; else goto cbZAP;
       cbZAP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbZAR; else goto cbZAQ;
       cbZAR: // global
           HpAlloc = 32;
           goto cbZAO;
       cbZAO: // global
           R4 = _sbX2F::P64;
           R3 = _sbX2E::P64;
           R2 = _sbX2D::P64;
           R1 = Data.Traversable.$fTraversableIdentity_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZAQ: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX2E::P64;
           P64[Hp] = _sbX2F::P64;
           I64[Sp - 16] = block_cbZAI_info;
           R2 = _sbX2D::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZAI() //  [R1]
         { info_tbl: [(cbZAI,
                       label: block_cbZAI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZAI: // global
           I64[Sp] = block_cbZAN_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZAN() //  [R1]
         { info_tbl: [(cbZAN,
                       label: block_cbZAN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZAN: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.153235985 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$csequence_closure" {
     Data.Traversable.$fTraversableIdentity_$csequence_closure:
         const Data.Traversable.$fTraversableIdentity_$csequence_info;
 },
 Data.Traversable.$fTraversableIdentity_$csequence_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbZBf,
                       label: Data.Traversable.$fTraversableIdentity_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZBf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZBj; else goto cbZBk;
       cbZBj: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableIdentity_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZBk: // global
           I64[Sp - 16] = block_cbZBd_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZBd() //  [R1]
         { info_tbl: [(cbZBd,
                       label: block_cbZBd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZBd: // global
           I64[Sp] = block_cbZBi_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZBi() //  [R1]
         { info_tbl: [(cbZBi,
                       label: block_cbZBi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZBi: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.159906283 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_closure" {
     Data.Traversable.$fTraversableIdentity_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Functor.Identity.$fFunctorIdentity_closure;
         const Data.Functor.Identity.$fFoldableIdentity_closure;
         const Data.Traversable.$fTraversableIdentity_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableIdentity_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableIdentity_$cmapM_closure+3;
         const Data.Traversable.$fTraversableIdentity_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.162596555 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$csequenceA_closure" {
     Data.Traversable.$fTraversableProduct_$csequenceA_closure:
         const Data.Traversable.$fTraversableProduct_$csequenceA_info;
 },
 Data.Traversable.$fTraversableProduct_$csequenceA_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbZBI,
                       label: Data.Traversable.$fTraversableProduct_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZBI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZBJ; else goto cbZBK;
       cbZBJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProduct_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZBK: // global
           I64[Sp - 16] = block_cbZBG_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZBG() //  [R1]
         { info_tbl: [(cbZBG,
                       label: block_cbZBG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZBG: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.167902162 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$cmapM_closure" {
     Data.Traversable.$fTraversableProduct_$cmapM_closure:
         const Data.Traversable.$fTraversableProduct_$cmapM_info;
 },
 Data.Traversable.$fTraversableProduct_$cmapM_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbZC3,
                       label: Data.Traversable.$fTraversableProduct_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZC3: // global
           _sbX2S::P64 = R4;
           _sbX2R::P64 = R3;
           _sbX2Q::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbZC7; else goto cbZC8;
       cbZC8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbZCa; else goto cbZC9;
       cbZCa: // global
           HpAlloc = 32;
           goto cbZC7;
       cbZC7: // global
           R4 = _sbX2S::P64;
           R3 = _sbX2R::P64;
           R2 = _sbX2Q::P64;
           R1 = Data.Traversable.$fTraversableProduct_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZC9: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX2R::P64;
           P64[Hp] = _sbX2S::P64;
           I64[Sp - 16] = block_cbZC1_info;
           R2 = _sbX2Q::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZC1() //  [R1]
         { info_tbl: [(cbZC1,
                       label: block_cbZC1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZC1: // global
           I64[Sp] = block_cbZC6_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZC6() //  [R1]
         { info_tbl: [(cbZC6,
                       label: block_cbZC6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZC6: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.174953321 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$csequence_closure" {
     Data.Traversable.$fTraversableProduct_$csequence_closure:
         const Data.Traversable.$fTraversableProduct_$csequence_info;
 },
 Data.Traversable.$fTraversableProduct_$csequence_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cbZCy,
                       label: Data.Traversable.$fTraversableProduct_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZCy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZCC; else goto cbZCD;
       cbZCC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProduct_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZCD: // global
           I64[Sp - 16] = block_cbZCw_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZCw() //  [R1]
         { info_tbl: [(cbZCw,
                       label: block_cbZCw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZCw: // global
           I64[Sp] = block_cbZCB_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZCB() //  [R1]
         { info_tbl: [(cbZCB,
                       label: block_cbZCB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZCB: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.181556719 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_closure" {
     Data.Traversable.$fTraversableProduct_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Semigroup.Internal.$fFunctorProduct_closure;
         const Data.Foldable.$fFoldableProduct_closure;
         const Data.Traversable.$fTraversableProduct_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableProduct_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableProduct_$cmapM_closure+3;
         const Data.Traversable.$fTraversableProduct_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.183587748 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$csequenceA_closure" {
     Data.Traversable.$fTraversableSum_$csequenceA_closure:
         const Data.Traversable.$fTraversableSum_$csequenceA_info;
 },
 Data.Traversable.$fTraversableSum_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbZD1,
                       label: Data.Traversable.$fTraversableSum_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZD1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZD2; else goto cbZD3;
       cbZD2: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableSum_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZD3: // global
           I64[Sp - 16] = block_cbZCZ_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZCZ() //  [R1]
         { info_tbl: [(cbZCZ,
                       label: block_cbZCZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZCZ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.188818028 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$cmapM_closure" {
     Data.Traversable.$fTraversableSum_$cmapM_closure:
         const Data.Traversable.$fTraversableSum_$cmapM_info;
 },
 Data.Traversable.$fTraversableSum_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZDm,
                       label: Data.Traversable.$fTraversableSum_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZDm: // global
           _sbX35::P64 = R4;
           _sbX34::P64 = R3;
           _sbX33::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbZDq; else goto cbZDr;
       cbZDr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbZDt; else goto cbZDs;
       cbZDt: // global
           HpAlloc = 32;
           goto cbZDq;
       cbZDq: // global
           R4 = _sbX35::P64;
           R3 = _sbX34::P64;
           R2 = _sbX33::P64;
           R1 = Data.Traversable.$fTraversableSum_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZDs: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX34::P64;
           P64[Hp] = _sbX35::P64;
           I64[Sp - 16] = block_cbZDk_info;
           R2 = _sbX33::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZDk() //  [R1]
         { info_tbl: [(cbZDk,
                       label: block_cbZDk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZDk: // global
           I64[Sp] = block_cbZDp_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZDp() //  [R1]
         { info_tbl: [(cbZDp,
                       label: block_cbZDp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZDp: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.196532179 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$csequence_closure" {
     Data.Traversable.$fTraversableSum_$csequence_closure:
         const Data.Traversable.$fTraversableSum_$csequence_info;
 },
 Data.Traversable.$fTraversableSum_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZDR,
                       label: Data.Traversable.$fTraversableSum_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZDR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZDV; else goto cbZDW;
       cbZDV: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableSum_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZDW: // global
           I64[Sp - 16] = block_cbZDP_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZDP() //  [R1]
         { info_tbl: [(cbZDP,
                       label: block_cbZDP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZDP: // global
           I64[Sp] = block_cbZDU_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZDU() //  [R1]
         { info_tbl: [(cbZDU,
                       label: block_cbZDU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZDU: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.202775642 UTC

[section ""data" . Data.Traversable.$fTraversableSum_closure" {
     Data.Traversable.$fTraversableSum_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Semigroup.Internal.$fFunctorSum_closure;
         const Data.Foldable.$fFoldableSum_closure;
         const Data.Traversable.$fTraversableSum_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableSum_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableSum_$cmapM_closure+3;
         const Data.Traversable.$fTraversableSum_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.204784969 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$csequenceA_closure" {
     Data.Traversable.$fTraversableDual_$csequenceA_closure:
         const Data.Traversable.$fTraversableDual_$csequenceA_info;
 },
 Data.Traversable.$fTraversableDual_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbZEk,
                       label: Data.Traversable.$fTraversableDual_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZEk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZEl; else goto cbZEm;
       cbZEl: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableDual_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZEm: // global
           I64[Sp - 16] = block_cbZEi_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZEi() //  [R1]
         { info_tbl: [(cbZEi,
                       label: block_cbZEi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZEi: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.21033674 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$cmapM_closure" {
     Data.Traversable.$fTraversableDual_$cmapM_closure:
         const Data.Traversable.$fTraversableDual_$cmapM_info;
 },
 Data.Traversable.$fTraversableDual_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZEF,
                       label: Data.Traversable.$fTraversableDual_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZEF: // global
           _sbX3i::P64 = R4;
           _sbX3h::P64 = R3;
           _sbX3g::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbZEJ; else goto cbZEK;
       cbZEK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbZEM; else goto cbZEL;
       cbZEM: // global
           HpAlloc = 32;
           goto cbZEJ;
       cbZEJ: // global
           R4 = _sbX3i::P64;
           R3 = _sbX3h::P64;
           R2 = _sbX3g::P64;
           R1 = Data.Traversable.$fTraversableDual_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZEL: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX3h::P64;
           P64[Hp] = _sbX3i::P64;
           I64[Sp - 16] = block_cbZED_info;
           R2 = _sbX3g::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZED() //  [R1]
         { info_tbl: [(cbZED,
                       label: block_cbZED_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZED: // global
           I64[Sp] = block_cbZEI_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZEI() //  [R1]
         { info_tbl: [(cbZEI,
                       label: block_cbZEI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZEI: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.217394588 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$csequence_closure" {
     Data.Traversable.$fTraversableDual_$csequence_closure:
         const Data.Traversable.$fTraversableDual_$csequence_info;
 },
 Data.Traversable.$fTraversableDual_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZFa,
                       label: Data.Traversable.$fTraversableDual_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZFa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZFe; else goto cbZFf;
       cbZFe: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableDual_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZFf: // global
           I64[Sp - 16] = block_cbZF8_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZF8() //  [R1]
         { info_tbl: [(cbZF8,
                       label: block_cbZF8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZF8: // global
           I64[Sp] = block_cbZFd_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZFd() //  [R1]
         { info_tbl: [(cbZFd,
                       label: block_cbZFd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZFd: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.223765963 UTC

[section ""data" . Data.Traversable.$fTraversableDual_closure" {
     Data.Traversable.$fTraversableDual_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Semigroup.Internal.$fFunctorDual_closure;
         const Data.Foldable.$fFoldableDual_closure;
         const Data.Traversable.$fTraversableDual_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableDual_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableDual_$cmapM_closure+3;
         const Data.Traversable.$fTraversableDual_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.226440083 UTC

[section ""data" . Data.Traversable.$fTraversableConst_$cmapM_closure" {
     Data.Traversable.$fTraversableConst_$cmapM_closure:
         const Data.Traversable.$fTraversableConst_$cmapM_info;
 },
 Data.Traversable.$fTraversableConst_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZFD,
                       label: Data.Traversable.$fTraversableConst_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZFD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZFE; else goto cbZFF;
       cbZFE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableConst_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZFF: // global
           I64[Sp - 16] = block_cbZFB_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZFB() //  [R1]
         { info_tbl: [(cbZFB,
                       label: block_cbZFB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZFB: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.231528729 UTC

[section ""data" . Data.Traversable.$fTraversableConst_$csequence_closure" {
     Data.Traversable.$fTraversableConst_$csequence_closure:
         const Data.Traversable.$fTraversableConst_$csequence_info;
 },
 Data.Traversable.$fTraversableConst_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZFX,
                       label: Data.Traversable.$fTraversableConst_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZFX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZFY; else goto cbZFZ;
       cbZFY: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableConst_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZFZ: // global
           I64[Sp - 16] = block_cbZFV_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZFV() //  [R1]
         { info_tbl: [(cbZFV,
                       label: block_cbZFV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZFV: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.236879325 UTC

[section ""data" . $fTraversableConst1_rbWTU_closure" {
     $fTraversableConst1_rbWTU_closure:
         const $fTraversableConst1_rbWTU_info;
 },
 $fTraversableConst1_rbWTU_entry() //  [R2, R3]
         { info_tbl: [(cbZGf,
                       label: $fTraversableConst1_rbWTU_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZGf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZGg; else goto cbZGh;
       cbZGg: // global
           R3 = R3;
           R2 = R2;
           R1 = $fTraversableConst1_rbWTU_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZGh: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.240185214 UTC

[section ""data" . Data.Traversable.$fTraversableConst_closure" {
     Data.Traversable.$fTraversableConst_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Functor.Const.$fFunctorConst_closure;
         const Data.Functor.Const.$fFoldableConst_closure;
         const Data.Traversable.$fTraversableConst_$ctraverse_closure+3;
         const $fTraversableConst1_rbWTU_closure+2;
         const Data.Traversable.$fTraversableConst_$cmapM_closure+3;
         const Data.Traversable.$fTraversableConst_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.242516511 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$csequenceA_closure" {
     Data.Traversable.$fTraversable(,)_$csequenceA_closure:
         const Data.Traversable.$fTraversable(,)_$csequenceA_info;
 },
 sat_sbX3F_entry() //  [R1, R2]
         { info_tbl: [(cbZGD,
                       label: sat_sbX3F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZGD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbZGH; else goto cbZGG;
       cbZGH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZGG: // global
           _sbX3C::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbX3C::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cbZGI,
                       label: Data.Traversable.$fTraversable(,)_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZGI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZGK; else goto cbZGL;
       cbZGK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZGL: // global
           I64[Sp - 16] = block_cbZGs_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubZGT; else goto cbZGt;
       ubZGT: // global
           call _cbZGs(R1) args: 0, res: 0, upd: 0;
       cbZGt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZGs() //  [R1]
         { info_tbl: [(cbZGs,
                       label: block_cbZGs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZGs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbZGO; else goto cbZGN;
       cbZGO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbZGN: // global
           _sbX3C::P64 = P64[R1 + 7];
           _sbX3D::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sbX3F_info;
           P64[Hp] = _sbX3C::P64;
           I64[Sp - 8] = block_cbZGJ_info;
           R2 = P64[Sp + 8];
           P64[Sp] = _sbX3D::P64;
           P64[Sp + 8] = Hp - 7;
           Sp = Sp - 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZGJ() //  [R1]
         { info_tbl: [(cbZGJ,
                       label: block_cbZGJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZGJ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _sbX3D::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sbX3D::P64;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.251902293 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$cmapM_closure" {
     Data.Traversable.$fTraversable(,)_$cmapM_closure:
         const Data.Traversable.$fTraversable(,)_$cmapM_info;
 },
 sat_sbX3O_entry() //  [R1, R2]
         { info_tbl: [(cbZHs,
                       label: sat_sbX3O_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZHs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbZHw; else goto cbZHv;
       cbZHw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZHv: // global
           _sbX3K::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbX3K::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZHx,
                       label: Data.Traversable.$fTraversable(,)_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZHx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZHD; else goto cbZHE;
       cbZHD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZHE: // global
           I64[Sp - 24] = block_cbZHg_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubZHN; else goto cbZHh;
       ubZHN: // global
           call _cbZHg(R1) args: 0, res: 0, upd: 0;
       cbZHh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZHg() //  [R1]
         { info_tbl: [(cbZHg,
                       label: block_cbZHg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZHg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbZHH; else goto cbZHG;
       cbZHH: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbZHG: // global
           _sbX3K::P64 = P64[R1 + 7];
           _sbX3L::P64 = P64[R1 + 15];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbX3L::P64;
           I64[Hp - 8] = sat_sbX3O_info;
           P64[Hp] = _sbX3K::P64;
           I64[Sp] = block_cbZHy_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 7;
           P64[Sp + 16] = Hp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZHy() //  [R1]
         { info_tbl: [(cbZHy,
                       label: block_cbZHy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZHy: // global
           I64[Sp] = block_cbZHC_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZHC() //  [R1]
         { info_tbl: [(cbZHC,
                       label: block_cbZHC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZHC: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.264027506 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$csequence_closure" {
     Data.Traversable.$fTraversable(,)_$csequence_closure:
         const Data.Traversable.$fTraversable(,)_$csequence_info;
 },
 sat_sbX3X_entry() //  [R1, R2]
         { info_tbl: [(cbZIp,
                       label: sat_sbX3X_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZIp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbZIt; else goto cbZIs;
       cbZIt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZIs: // global
           _sbX3T::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sbX3T::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZIu,
                       label: Data.Traversable.$fTraversable(,)_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZIu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZIA; else goto cbZIB;
       cbZIA: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZIB: // global
           I64[Sp - 16] = block_cbZIe_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubZIK; else goto cbZIf;
       ubZIK: // global
           call _cbZIe(R1) args: 0, res: 0, upd: 0;
       cbZIf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZIe() //  [R1]
         { info_tbl: [(cbZIe,
                       label: block_cbZIe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZIe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbZIE; else goto cbZID;
       cbZIE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbZID: // global
           _sbX3T::P64 = P64[R1 + 7];
           _sbX3U::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sbX3X_info;
           P64[Hp] = _sbX3T::P64;
           I64[Sp - 8] = block_cbZIv_info;
           R2 = P64[Sp + 8];
           P64[Sp] = _sbX3U::P64;
           P64[Sp + 8] = Hp - 7;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZIv() //  [R1]
         { info_tbl: [(cbZIv,
                       label: block_cbZIv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZIv: // global
           I64[Sp] = block_cbZIz_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZIz() //  [R1]
         { info_tbl: [(cbZIz,
                       label: block_cbZIz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZIz: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _sbX3U::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sbX3U::P64;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.276417972 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_closure" {
     Data.Traversable.$fTraversable(,)_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctor(,)_closure;
         const Data.Foldable.$fFoldable(,)_closure;
         const Data.Traversable.$fTraversable(,)_$ctraverse_closure+3;
         const Data.Traversable.$fTraversable(,)_$csequenceA_closure+2;
         const Data.Traversable.$fTraversable(,)_$cmapM_closure+3;
         const Data.Traversable.$fTraversable(,)_$csequence_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.278909567 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$csequenceA_closure" {
     Data.Traversable.$fTraversableEither_$csequenceA_closure:
         const Data.Traversable.$fTraversableEither_$csequenceA_info;
 },
 Data.Traversable.$fTraversableEither_$csequenceA_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cbZJi,
                       label: Data.Traversable.$fTraversableEither_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZJi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZJj; else goto cbZJk;
       cbZJj: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZJk: // global
           I64[Sp - 16] = block_cbZJb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubZJw; else goto cbZJc;
       ubZJw: // global
           call _cbZJb(R1) args: 0, res: 0, upd: 0;
       cbZJc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZJb() //  [R1]
         { info_tbl: [(cbZJb,
                       label: block_cbZJb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZJb: // global
           _sbX3Y::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbZJf; else goto cbZJg;
       cbZJf: // global
           R2 = _sbX3Y::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cbZJg: // global
           I64[Sp] = block_cbZJq_info;
           R2 = _sbX3Y::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZJq() //  [R1]
         { info_tbl: [(cbZJq,
                       label: block_cbZJq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZJq: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.287237529 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$cmapM_closure" {
     Data.Traversable.$fTraversableEither_$cmapM_closure:
         const Data.Traversable.$fTraversableEither_$cmapM_info;
 },
 Data.Traversable.$fTraversableEither_$cmapM_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cbZJS,
                       label: Data.Traversable.$fTraversableEither_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZJS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZJT; else goto cbZJU;
       cbZJT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZJU: // global
           I64[Sp - 24] = block_cbZJQ_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZJQ() //  [R1]
         { info_tbl: [(cbZJQ,
                       label: block_cbZJQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZJQ: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableEither_$ctraverse_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.293433373 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$csequence_closure" {
     Data.Traversable.$fTraversableEither_$csequence_closure:
         const Data.Traversable.$fTraversableEither_$csequence_info;
 },
 Data.Traversable.$fTraversableEither_$csequence_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbZKh,
                       label: Data.Traversable.$fTraversableEither_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZKh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZKi; else goto cbZKj;
       cbZKi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZKj: // global
           I64[Sp - 16] = block_cbZKa_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubZKF; else goto cbZKb;
       ubZKF: // global
           call _cbZKa(R1) args: 0, res: 0, upd: 0;
       cbZKb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZKa() //  [R1]
         { info_tbl: [(cbZKa,
                       label: block_cbZKa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZKa: // global
           _sbX49::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbZKe; else goto cbZKf;
       cbZKe: // global
           I64[Sp] = block_cbZKm_info;
           R2 = _sbX49::P64;
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
       cbZKf: // global
           I64[Sp] = block_cbZKu_info;
           R2 = _sbX49::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZKm() //  [R1]
         { info_tbl: [(cbZKm,
                       label: block_cbZKm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZKm: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 _cbZKu() //  [R1]
         { info_tbl: [(cbZKu,
                       label: block_cbZKu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZKu: // global
           I64[Sp] = block_cbZKy_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZKy() //  [R1]
         { info_tbl: [(cbZKy,
                       label: block_cbZKy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZKy: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.304659477 UTC

[section ""data" . Data.Traversable.$fTraversableEither_closure" {
     Data.Traversable.$fTraversableEither_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Either.$fFunctorEither_closure;
         const Data.Foldable.$fFoldableEither_closure;
         const Data.Traversable.$fTraversableEither_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableEither_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableEither_$cmapM_closure+3;
         const Data.Traversable.$fTraversableEither_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.30762946 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$csequenceA_closure" {
     Data.Traversable.$fTraversable[]_$csequenceA_closure:
         const Data.Traversable.$fTraversable[]_$csequenceA_info;
 },
 z_sbX4j_entry() //  [R1]
         { info_tbl: [(cbZLa,
                       label: z_sbX4j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZLa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZLb; else goto cbZLc;
       cbZLb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZLc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX4k_entry() //  [R1, R2]
         { info_tbl: [(cbZLp,
                       label: go_sbX4k_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZLp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZLq; else goto cbZLr;
       cbZLq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZLr: // global
           I64[Sp - 32] = block_cbZLi_info;
           _sbX4k::P64 = R1;
           _sbX4i::P64 = P64[R1 + 7];
           _sbX4j::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sbX4i::P64;
           P64[Sp - 16] = _sbX4j::P64;
           P64[Sp - 8] = _sbX4k::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubZLB; else goto cbZLj;
       ubZLB: // global
           call _cbZLi(R1) args: 0, res: 0, upd: 0;
       cbZLj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZLi() //  [R1]
         { info_tbl: [(cbZLi,
                       label: block_cbZLi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZLi: // global
           if (R1 & 7 == 1) goto cbZLm; else goto cbZLn;
       cbZLm: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbZLn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbZLz; else goto cbZLy;
       cbZLz: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbZLy: // global
           _sbX4n::P64 = P64[R1 + 6];
           _sbX4o::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sbX4o::P64;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 16] = _sbX4n::P64;
           P64[Sp + 24] = Hp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$csequenceA_entry() //  [R2]
         { info_tbl: [(cbZLC,
                       label: Data.Traversable.$fTraversable[]_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZLC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbZLG; else goto cbZLF;
       cbZLG: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$csequenceA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZLF: // global
           I64[Hp - 40] = z_sbX4j_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_sbX4k_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.318188807 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$cmapM_closure" {
     Data.Traversable.$fTraversable[]_$cmapM_closure:
         const Data.Traversable.$fTraversable[]_$cmapM_info;
 },
 $dApplicative_sbX4s_entry() //  [R1]
         { info_tbl: [(cbZMb,
                       label: $dApplicative_sbX4s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZMb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZMc; else goto cbZMd;
       cbZMc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZMd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_sbX4t_entry() //  [R1]
         { info_tbl: [(cbZMi,
                       label: z_sbX4t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZMi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZMj; else goto cbZMk;
       cbZMj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZMk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX4u_entry() //  [R1, R2]
         { info_tbl: [(cbZMx,
                       label: go_sbX4u_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZMx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbZMy; else goto cbZMz;
       cbZMy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZMz: // global
           I64[Sp - 40] = block_cbZMq_info;
           _sbX4u::P64 = R1;
           _sbX4r::P64 = P64[R1 + 7];
           _sbX4s::P64 = P64[R1 + 15];
           _sbX4t::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sbX4r::P64;
           P64[Sp - 24] = _sbX4s::P64;
           P64[Sp - 16] = _sbX4t::P64;
           P64[Sp - 8] = _sbX4u::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubZMK; else goto cbZMr;
       ubZMK: // global
           call _cbZMq(R1) args: 0, res: 0, upd: 0;
       cbZMr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZMq() //  [R1]
         { info_tbl: [(cbZMq,
                       label: block_cbZMq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZMq: // global
           if (R1 & 7 == 1) goto cbZMu; else goto cbZMv;
       cbZMu: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbZMv: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbZMH; else goto cbZMG;
       cbZMH: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbZMG: // global
           _sbX4x::P64 = P64[R1 + 6];
           _sbX4y::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sbX4y::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sbX4x::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$cmapM_entry() //  [R2, R3]
         { info_tbl: [(cbZML,
                       label: Data.Traversable.$fTraversable[]_$cmapM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZML: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cbZMP; else goto cbZMO;
       cbZMP: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$cmapM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZMO: // global
           I64[Hp - 72] = $dApplicative_sbX4s_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = z_sbX4t_info;
           _cbZM7::P64 = Hp - 72;
           P64[Hp - 32] = _cbZM7::P64;
           I64[Hp - 24] = go_sbX4u_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cbZM7::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.331000902 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$csequence_closure" {
     Data.Traversable.$fTraversable[]_$csequence_closure:
         const Data.Traversable.$fTraversable[]_$csequence_info;
 },
 $dApplicative_sbX4C_entry() //  [R1]
         { info_tbl: [(cbZNq,
                       label: $dApplicative_sbX4C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZNq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZNr; else goto cbZNs;
       cbZNr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZNs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_sbX4D_entry() //  [R1]
         { info_tbl: [(cbZNx,
                       label: z_sbX4D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZNx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZNy; else goto cbZNz;
       cbZNy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZNz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX4E_entry() //  [R1, R2]
         { info_tbl: [(cbZNM,
                       label: go_sbX4E_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZNM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZNN; else goto cbZNO;
       cbZNN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZNO: // global
           I64[Sp - 32] = block_cbZNF_info;
           _sbX4E::P64 = R1;
           _sbX4C::P64 = P64[R1 + 7];
           _sbX4D::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sbX4C::P64;
           P64[Sp - 16] = _sbX4D::P64;
           P64[Sp - 8] = _sbX4E::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubZNY; else goto cbZNG;
       ubZNY: // global
           call _cbZNF(R1) args: 0, res: 0, upd: 0;
       cbZNG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZNF() //  [R1]
         { info_tbl: [(cbZNF,
                       label: block_cbZNF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZNF: // global
           if (R1 & 7 == 1) goto cbZNJ; else goto cbZNK;
       cbZNJ: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbZNK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbZNW; else goto cbZNV;
       cbZNW: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbZNV: // global
           _sbX4H::P64 = P64[R1 + 6];
           _sbX4I::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sbX4I::P64;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 16] = _sbX4H::P64;
           P64[Sp + 24] = Hp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$csequence_entry() //  [R2]
         { info_tbl: [(cbZNZ,
                       label: Data.Traversable.$fTraversable[]_$csequence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZNZ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbZO3; else goto cbZO2;
       cbZO3: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$csequence_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZO2: // global
           I64[Hp - 64] = $dApplicative_sbX4C_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = z_sbX4D_info;
           _cbZNm::P64 = Hp - 64;
           P64[Hp - 24] = _cbZNm::P64;
           I64[Hp - 16] = go_sbX4E_info;
           P64[Hp - 8] = _cbZNm::P64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.343569388 UTC

[section ""data" . Data.Traversable.$fTraversable[]_closure" {
     Data.Traversable.$fTraversable[]_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctor[]_closure;
         const Data.Foldable.$fFoldable[]_closure;
         const Data.Traversable.$fTraversable[]_$ctraverse_closure+2;
         const Data.Traversable.$fTraversable[]_$csequenceA_closure+1;
         const Data.Traversable.$fTraversable[]_$cmapM_closure+2;
         const Data.Traversable.$fTraversable[]_$csequence_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.345507433 UTC

[section ""data" . Data.Traversable.$fTraversableZipList1_closure" {
     Data.Traversable.$fTraversableZipList1_closure:
         const Data.Traversable.$fTraversableZipList1_info;
 },
 Data.Traversable.$fTraversableZipList1_entry() //  [R2]
         { info_tbl: [(cbZOz,
                       label: Data.Traversable.$fTraversableZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZOz: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.349699125 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$ctraverse_closure" {
     Data.Traversable.$fTraversableZipList_$ctraverse_closure:
         const Data.Traversable.$fTraversableZipList_$ctraverse_info;
 },
 z_sbX4P_entry() //  [R1]
         { info_tbl: [(cbZOU,
                       label: z_sbX4P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZOU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZOV; else goto cbZOW;
       cbZOV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZOW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX4Q_entry() //  [R1, R2]
         { info_tbl: [(cbZP9,
                       label: go_sbX4Q_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZP9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbZPa; else goto cbZPb;
       cbZPa: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZPb: // global
           I64[Sp - 40] = block_cbZP2_info;
           _sbX4Q::P64 = R1;
           _sbX4L::P64 = P64[R1 + 7];
           _sbX4M::P64 = P64[R1 + 15];
           _sbX4P::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sbX4L::P64;
           P64[Sp - 24] = _sbX4M::P64;
           P64[Sp - 16] = _sbX4P::P64;
           P64[Sp - 8] = _sbX4Q::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubZPm; else goto cbZP3;
       ubZPm: // global
           call _cbZP2(R1) args: 0, res: 0, upd: 0;
       cbZP3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZP2() //  [R1]
         { info_tbl: [(cbZP2,
                       label: block_cbZP2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZP2: // global
           if (R1 & 7 == 1) goto cbZP6; else goto cbZP7;
       cbZP6: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbZP7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbZPj; else goto cbZPi;
       cbZPj: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbZPi: // global
           _sbX4T::P64 = P64[R1 + 6];
           _sbX4U::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sbX4U::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbX4T::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sbX4X_entry() //  [R1]
         { info_tbl: [(cbZPn,
                       label: sat_sbX4X_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZPn: // global
           _sbX4X::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbZPo; else goto cbZPp;
       cbZPp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbZPr; else goto cbZPq;
       cbZPr: // global
           HpAlloc = 56;
           goto cbZPo;
       cbZPo: // global
           R1 = _sbX4X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZPq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbX4X::P64;
           _sbX4L::P64 = P64[_sbX4X::P64 + 16];
           _sbX4M::P64 = P64[_sbX4X::P64 + 24];
           _sbX4N::P64 = P64[_sbX4X::P64 + 32];
           I64[Hp - 48] = z_sbX4P_info;
           P64[Hp - 32] = _sbX4L::P64;
           I64[Hp - 24] = go_sbX4Q_info;
           P64[Hp - 16] = _sbX4L::P64;
           P64[Hp - 8] = _sbX4M::P64;
           P64[Hp] = Hp - 48;
           R2 = _sbX4N::P64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call go_sbX4Q_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableZipList_$ctraverse_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cbZPu,
                       label: Data.Traversable.$fTraversableZipList_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZPu: // global
           _sbX4N::P64 = R4;
           _sbX4M::P64 = R3;
           _sbX4L::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbZPv; else goto cbZPw;
       cbZPw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbZPy; else goto cbZPx;
       cbZPy: // global
           HpAlloc = 40;
           goto cbZPv;
       cbZPv: // global
           R4 = _sbX4N::P64;
           R3 = _sbX4M::P64;
           R2 = _sbX4L::P64;
           R1 = Data.Traversable.$fTraversableZipList_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZPx: // global
           I64[Hp - 32] = sat_sbX4X_info;
           P64[Hp - 16] = _sbX4L::P64;
           P64[Hp - 8] = _sbX4M::P64;
           P64[Hp] = _sbX4N::P64;
           I64[Sp - 16] = block_cbZPs_info;
           R2 = _sbX4L::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZPs() //  [R1]
         { info_tbl: [(cbZPs,
                       label: block_cbZPs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZPs: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableZipList1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.363941284 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$csequenceA_closure" {
     Data.Traversable.$fTraversableZipList_$csequenceA_closure:
         const Data.Traversable.$fTraversableZipList_$csequenceA_info;
 },
 Data.Traversable.$fTraversableZipList_$csequenceA_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbZQc,
                       label: Data.Traversable.$fTraversableZipList_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZQc: // global
           R4 = R3;
           R3 = GHC.Base.id_closure+1;
           R2 = R2;
           call Data.Traversable.$fTraversableZipList_$ctraverse_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.367402032 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$cmapM_closure" {
     Data.Traversable.$fTraversableZipList_$cmapM_closure:
         const Data.Traversable.$fTraversableZipList_$cmapM_info;
 },
 Data.Traversable.$fTraversableZipList_$cmapM_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cbZQp,
                       label: Data.Traversable.$fTraversableZipList_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZQp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZQq; else goto cbZQr;
       cbZQq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableZipList_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZQr: // global
           I64[Sp - 24] = block_cbZQn_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZQn() //  [R1]
         { info_tbl: [(cbZQn,
                       label: block_cbZQn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZQn: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableZipList_$ctraverse_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.372608631 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$csequence_closure" {
     Data.Traversable.$fTraversableZipList_$csequence_closure:
         const Data.Traversable.$fTraversableZipList_$csequence_info;
 },
 Data.Traversable.$fTraversableZipList_$csequence_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cbZQJ,
                       label: Data.Traversable.$fTraversableZipList_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZQJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZQK; else goto cbZQL;
       cbZQK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableZipList_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZQL: // global
           I64[Sp - 16] = block_cbZQH_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZQH() //  [R1]
         { info_tbl: [(cbZQH,
                       label: block_cbZQH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZQH: // global
           R4 = P64[Sp + 8];
           R3 = GHC.Base.id_closure+1;
           R2 = R1;
           Sp = Sp + 16;
           call Data.Traversable.$fTraversableZipList_$ctraverse_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.378533117 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_closure" {
     Data.Traversable.$fTraversableZipList_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Control.Applicative.$fFunctorZipList_closure;
         const Control.Applicative.$fFoldableZipList_closure;
         const Data.Traversable.$fTraversableZipList_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableZipList_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableZipList_$cmapM_closure+3;
         const Data.Traversable.$fTraversableZipList_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.382216421 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$ctraverse_closure" {
     Data.Traversable.$fTraversableArray_$ctraverse_closure:
         const Data.Traversable.$fTraversableArray_$ctraverse_info;
         const 0;
 },
 n_sbX5j_entry() //  [R1]
         { info_tbl: [(cbZRi,
                       label: n_sbX5j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZRi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZRj; else goto cbZRk;
       cbZRj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZRk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbX5t_entry() //  [R1]
         { info_tbl: [(cbZRC,
                       label: sat_sbX5t_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZRC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZRD; else goto cbZRE;
       cbZRD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZRE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _sbX5m::I64 = I64[R1 + 40];
           if (_sbX5m::I64 == I64[R1 + 32]) goto cbZRB; else goto cbZRA;
       cbZRB: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cbZRA: // global
           R2 = _sbX5m::I64 + 1;
           R1 = P64[R1 + 24];
           Sp = Sp - 16;
           call go_sbX5l_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5p_entry() //  [R1]
         { info_tbl: [(cbZRP,
                       label: sat_sbX5p_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZRP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZRQ; else goto cbZRR;
       cbZRQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZRR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = P64[P64[R1 + 16] + ((I64[R1 + 24] << 3) + 24)];
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5q_entry() //  [R1]
         { info_tbl: [(cbZRS,
                       label: sat_sbX5q_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZRS: // global
           _sbX5q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbZRT; else goto cbZRU;
       cbZRU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbZRW; else goto cbZRV;
       cbZRW: // global
           HpAlloc = 32;
           goto cbZRT;
       cbZRT: // global
           R1 = _sbX5q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZRV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbX5q::P64;
           _sbX58::P64 = P64[_sbX5q::P64 + 16];
           _sbX5h::P64 = P64[_sbX5q::P64 + 24];
           _sbX5m::I64 = I64[_sbX5q::P64 + 32];
           I64[Hp - 24] = sat_sbX5p_info;
           P64[Hp - 8] = _sbX5h::P64;
           I64[Hp] = _sbX5m::I64;
           R2 = Hp - 24;
           R1 = _sbX58::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sbX5l_entry() //  [R1, R2]
         { info_tbl: [(cbZRX,
                       label: go_sbX5l_info
                       rep:HeapRep 4 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZRX: // global
           _sbX5m::I64 = R2;
           _sbX5l::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cbZRY; else goto cbZRZ;
       cbZRZ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbZS1; else goto cbZS0;
       cbZS1: // global
           HpAlloc = 88;
           goto cbZRY;
       cbZRY: // global
           R2 = _sbX5m::I64;
           R1 = _sbX5l::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZS0: // global
           _sbX57::P64 = P64[_sbX5l::P64 + 7];
           _sbX58::P64 = P64[_sbX5l::P64 + 15];
           _sbX5h::P64 = P64[_sbX5l::P64 + 23];
           _sbX5j::P64 = P64[_sbX5l::P64 + 31];
           _sbX5i::I64 = I64[_sbX5l::P64 + 39];
           I64[Hp - 80] = sat_sbX5t_info;
           P64[Hp - 64] = _sbX5j::P64;
           P64[Hp - 56] = _sbX5l::P64;
           I64[Hp - 48] = _sbX5i::I64;
           I64[Hp - 40] = _sbX5m::I64;
           I64[Hp - 32] = sat_sbX5q_info;
           P64[Hp - 16] = _sbX58::P64;
           P64[Hp - 8] = _sbX5h::P64;
           I64[Hp] = _sbX5m::I64;
           R2 = _sbX57::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = Hp - 80;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sbX5u_entry() //  [R1]
         { info_tbl: [(cbZS2,
                       label: sat_sbX5u_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZS2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbZS3; else goto cbZS4;
       cbZS3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZS4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbZR6_info;
           _sbX57::P64 = P64[R1 + 16];
           _sbX58::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sbX57::P64;
           P64[Sp - 24] = _sbX58::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubZSb; else goto cbZR7;
       ubZSb: // global
           call _cbZR6(R1) args: 0, res: 0, upd: 0;
       cbZR7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbZR6() //  [R1]
         { info_tbl: [(cbZR6,
                       label: block_cbZR6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZR6: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbZS7; else goto cbZS6;
       cbZS7: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbZS6: // global
           _sbX5h::P64 = P64[R1 + 23];
           _sbX5i::I64 = I64[R1 + 31] - 1;
           I64[Hp - 64] = n_sbX5j_info;
           _sbX57::P64 = P64[Sp + 8];
           P64[Hp - 48] = _sbX57::P64;
           _cbZRe::P64 = Hp - 64;
           if (%MO_S_Le_W64(0, _sbX5i::I64)) goto cbZS9; else goto cbZSa;
       cbZS9: // global
           I64[Hp - 40] = go_sbX5l_info;
           P64[Hp - 32] = _sbX57::P64;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sbX5h::P64;
           P64[Hp - 8] = _cbZRe::P64;
           I64[Hp] = _sbX5i::I64;
           R2 = 0;
           R1 = Hp - 39;
           Sp = Sp + 24;
           call go_sbX5l_entry(R2, R1) args: 24, res: 0, upd: 24;
       cbZSa: // global
           Hp = Hp - 48;
           R1 = _cbZRe::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5b_entry() //  [R1]
         { info_tbl: [(cbZSg,
                       label: sat_sbX5b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZSg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZSh; else goto cbZSi;
       cbZSh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZSi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.bounds_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5c_entry() //  [R1, R2]
         { info_tbl: [(cbZSo,
                       label: sat_sbX5c_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZSo: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Arr.listArray_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversableArray_$ctraverse_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cbZSt,
                       label: Data.Traversable.$fTraversableArray_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZSt: // global
           _sbX59::P64 = R5;
           _sbX58::P64 = R4;
           _sbX57::P64 = R3;
           _sbX56::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cbZSu; else goto cbZSv;
       cbZSv: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cbZSx; else goto cbZSw;
       cbZSx: // global
           HpAlloc = 88;
           goto cbZSu;
       cbZSu: // global
           R5 = _sbX59::P64;
           R4 = _sbX58::P64;
           R3 = _sbX57::P64;
           R2 = _sbX56::P64;
           R1 = Data.Traversable.$fTraversableArray_$ctraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZSw: // global
           I64[Hp - 80] = sat_sbX5u_info;
           P64[Hp - 64] = _sbX57::P64;
           P64[Hp - 56] = _sbX58::P64;
           P64[Hp - 48] = _sbX59::P64;
           I64[Hp - 40] = sat_sbX5b_info;
           P64[Hp - 24] = _sbX59::P64;
           I64[Hp - 16] = sat_sbX5c_info;
           P64[Hp - 8] = _sbX56::P64;
           P64[Hp] = Hp - 40;
           I64[Sp - 24] = block_cbZSr_info;
           R2 = _sbX57::P64;
           P64[Sp - 16] = Hp - 80;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZSr() //  [R1]
         { info_tbl: [(cbZSr,
                       label: block_cbZSr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZSr: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cbZR2::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cbZR2::P64;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.406074595 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$csequenceA_closure" {
     Data.Traversable.$fTraversableArray_$csequenceA_closure:
         const Data.Traversable.$fTraversableArray_$csequenceA_info;
         const 0;
 },
 Data.Traversable.$fTraversableArray_$csequenceA_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cbZTw,
                       label: Data.Traversable.$fTraversableArray_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZTw: // global
           R5 = R4;
           R4 = GHC.Base.id_closure+1;
           R3 = R3;
           R2 = R2;
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.409613271 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$cmapM_closure" {
     Data.Traversable.$fTraversableArray_$cmapM_closure:
         const Data.Traversable.$fTraversableArray_$cmapM_info;
         const 0;
 },
 Data.Traversable.$fTraversableArray_$cmapM_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cbZTJ,
                       label: Data.Traversable.$fTraversableArray_$cmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZTJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZTK; else goto cbZTL;
       cbZTK: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableArray_$cmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZTL: // global
           I64[Sp - 32] = block_cbZTH_info;
           _sbX5x::P64 = R2;
           R2 = R3;
           P64[Sp - 24] = _sbX5x::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZTH() //  [R1]
         { info_tbl: [(cbZTH,
                       label: block_cbZTH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZTH: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.415072185 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$csequence_closure" {
     Data.Traversable.$fTraversableArray_$csequence_closure:
         const Data.Traversable.$fTraversableArray_$csequence_info;
         const 0;
 },
 Data.Traversable.$fTraversableArray_$csequence_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cbZU3,
                       label: Data.Traversable.$fTraversableArray_$csequence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZU3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZU4; else goto cbZU5;
       cbZU4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableArray_$csequence_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZU5: // global
           I64[Sp - 24] = block_cbZU1_info;
           _sbX5C::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _sbX5C::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZU1() //  [R1]
         { info_tbl: [(cbZU1,
                       label: block_cbZU1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZU1: // global
           R5 = P64[Sp + 16];
           R4 = GHC.Base.id_closure+1;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.421850047 UTC

[section ""data" . Data.Traversable.$fTraversableArray_closure" {
     Data.Traversable.$fTraversableArray_closure:
         const Data.Traversable.$fTraversableArray_info;
         const 0;
 },
 sat_sbX5K_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZUq,
                       label: sat_sbX5K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZUq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableArray_$csequence_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX5J_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbZUy,
                       label: sat_sbX5J_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZUy: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableArray_$cmapM_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX5I_entry() //  [R1, R2, R3]
         { info_tbl: [(cbZUG,
                       label: sat_sbX5I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZUG: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableArray_$csequenceA_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbX5H_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cbZUO,
                       label: sat_sbX5H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZUO: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversableArray_entry() //  [R2]
         { info_tbl: [(cbZUS,
                       label: Data.Traversable.$fTraversableArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZUS: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cbZUW; else goto cbZUV;
       cbZUW: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZUV: // global
           I64[Hp - 112] = sat_sbX5K_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sbX5J_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sbX5I_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sbX5H_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = GHC.Arr.$fFunctorArray_closure;
           P64[Hp - 32] = Data.Foldable.$fFoldableArray_closure;
           P64[Hp - 24] = Hp - 61;
           P64[Hp - 16] = Hp - 78;
           P64[Hp - 8] = Hp - 93;
           P64[Hp] = Hp - 110;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.433079809 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure" {
     Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure:
         const Data.Traversable.$fTraversableNonEmpty_$ctraverse_info;
 },
 z_sbX5W_entry() //  [R1]
         { info_tbl: [(cbZVz,
                       label: z_sbX5W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZVz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbZVA; else goto cbZVB;
       cbZVA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZVB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sbX5X_entry() //  [R1, R2]
         { info_tbl: [(cbZVO,
                       label: go_sbX5X_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZVO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbZVP; else goto cbZVQ;
       cbZVP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbZVQ: // global
           I64[Sp - 40] = block_cbZVH_info;
           _sbX5X::P64 = R1;
           _sbX5L::P64 = P64[R1 + 7];
           _sbX5M::P64 = P64[R1 + 15];
           _sbX5W::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sbX5L::P64;
           P64[Sp - 24] = _sbX5M::P64;
           P64[Sp - 16] = _sbX5W::P64;
           P64[Sp - 8] = _sbX5X::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubZW1; else goto cbZVI;
       ubZW1: // global
           call _cbZVH(R1) args: 0, res: 0, upd: 0;
       cbZVI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZVH() //  [R1]
         { info_tbl: [(cbZVH,
                       label: block_cbZVH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZVH: // global
           if (R1 & 7 == 1) goto cbZVL; else goto cbZVM;
       cbZVL: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbZVM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbZVY; else goto cbZVX;
       cbZVY: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbZVX: // global
           _sbX60::P64 = P64[R1 + 6];
           _sbX61::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sbX61::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sbX60::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sbX64_entry() //  [R1]
         { info_tbl: [(cbZW2,
                       label: sat_sbX64_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZW2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbZW3; else goto cbZW4;
       cbZW3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZW4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cbZVq_info;
           _sbX5L::P64 = P64[R1 + 16];
           _sbX5M::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sbX5L::P64;
           P64[Sp - 24] = _sbX5M::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ubZW8; else goto cbZVr;
       ubZW8: // global
           call _cbZVq(R1) args: 0, res: 0, upd: 0;
       cbZVr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbZVq() //  [R1]
         { info_tbl: [(cbZVq,
                       label: block_cbZVq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZVq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbZW7; else goto cbZW6;
       cbZW7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbZW6: // global
           _sbX5V::P64 = P64[R1 + 15];
           I64[Hp - 48] = z_sbX5W_info;
           _sbX5L::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sbX5L::P64;
           I64[Hp - 24] = go_sbX5X_info;
           P64[Hp - 16] = _sbX5L::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R2 = _sbX5V::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call go_sbX5X_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbX5S_entry() //  [R1]
         { info_tbl: [(cbZWe,
                       label: sat_sbX5S_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZWe: // global
           _sbX5S::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbZWf; else goto cbZWg;
       cbZWg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbZWi; else goto cbZWh;
       cbZWi: // global
           HpAlloc = 24;
           goto cbZWf;
       cbZWf: // global
           R1 = _sbX5S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbZWh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbX5S::P64;
           _sbX5M::P64 = P64[_sbX5S::P64 + 16];
           _sbX5N::P64 = P64[_sbX5S::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sbX5N::P64;
           R2 = Hp - 16;
           R1 = _sbX5M::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cbZWj,
                       label: Data.Traversable.$fTraversableNonEmpty_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZWj: // global
           _sbX5N::P64 = R4;
           _sbX5M::P64 = R3;
           _sbX5L::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cbZWk; else goto cbZWl;
       cbZWl: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbZWn; else goto cbZWm;
       cbZWn: // global
           HpAlloc = 72;
           goto cbZWk;
       cbZWk: // global
           R4 = _sbX5N::P64;
           R3 = _sbX5M::P64;
           R2 = _sbX5L::P64;
           R1 = Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZWm: // global
           I64[Hp - 64] = sat_sbX64_info;
           P64[Hp - 48] = _sbX5L::P64;
           P64[Hp - 40] = _sbX5M::P64;
           P64[Hp - 32] = _sbX5N::P64;
           I64[Hp - 24] = sat_sbX5S_info;
           P64[Hp - 8] = _sbX5M::P64;
           P64[Hp] = _sbX5N::P64;
           R2 = _sbX5L::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Base.:|_closure+2;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.450094878 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$csequenceA_closure" {
     Data.Traversable.$fTraversableNonEmpty_$csequenceA_closure:
         const Data.Traversable.$fTraversableNonEmpty_$csequenceA_info;
 },
 Data.Traversable.$fTraversableNonEmpty_$csequenceA_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cbZX5,
                       label: Data.Traversable.$fTraversableNonEmpty_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZX5: // global
           R4 = R3;
           R3 = GHC.Base.id_closure+1;
           R2 = R2;
           call Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.453532674 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$cmapM_closure" {
     Data.Traversable.$fTraversableNonEmpty_$cmapM_closure:
         const Data.Traversable.$fTraversableNonEmpty_$cmapM_info;
 },
 Data.Traversable.$fTraversableNonEmpty_$cmapM_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cbZXi,
                       label: Data.Traversable.$fTraversableNonEmpty_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZXi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZXj; else goto cbZXk;
       cbZXj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableNonEmpty_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZXk: // global
           I64[Sp - 24] = block_cbZXg_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZXg() //  [R1]
         { info_tbl: [(cbZXg,
                       label: block_cbZXg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZXg: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.459216339 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$csequence_closure" {
     Data.Traversable.$fTraversableNonEmpty_$csequence_closure:
         const Data.Traversable.$fTraversableNonEmpty_$csequence_info;
 },
 Data.Traversable.$fTraversableNonEmpty_$csequence_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cbZXC,
                       label: Data.Traversable.$fTraversableNonEmpty_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZXC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbZXD; else goto cbZXE;
       cbZXD: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableNonEmpty_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZXE: // global
           I64[Sp - 16] = block_cbZXA_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZXA() //  [R1]
         { info_tbl: [(cbZXA,
                       label: block_cbZXA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZXA: // global
           R4 = P64[Sp + 8];
           R3 = GHC.Base.id_closure+1;
           R2 = R1;
           Sp = Sp + 16;
           call Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.464123633 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_closure" {
     Data.Traversable.$fTraversableNonEmpty_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctorNonEmpty_closure;
         const Data.Foldable.$fFoldableNonEmpty_closure;
         const Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableNonEmpty_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableNonEmpty_$cmapM_closure+3;
         const Data.Traversable.$fTraversableNonEmpty_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.466526098 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_$csequenceA_closure" {
     Data.Traversable.$fTraversableMaybe_$csequenceA_closure:
         const Data.Traversable.$fTraversableMaybe_$csequenceA_info;
 },
 Data.Traversable.$fTraversableMaybe_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cbZY2,
                       label: Data.Traversable.$fTraversableMaybe_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZY2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZY3; else goto cbZY4;
       cbZY3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableMaybe_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZY4: // global
           I64[Sp - 16] = block_cbZXV_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubZYg; else goto cbZXW;
       ubZYg: // global
           call _cbZXV(R1) args: 0, res: 0, upd: 0;
       cbZXW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZXV() //  [R1]
         { info_tbl: [(cbZXV,
                       label: block_cbZXV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZXV: // global
           _sbX6d::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbZXZ; else goto cbZY0;
       cbZXZ: // global
           R2 = _sbX6d::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cbZY0: // global
           I64[Sp] = block_cbZYa_info;
           R2 = _sbX6d::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZYa() //  [R1]
         { info_tbl: [(cbZYa,
                       label: block_cbZYa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZYa: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.473492388 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_$cmapM_closure" {
     Data.Traversable.$fTraversableMaybe_$cmapM_closure:
         const Data.Traversable.$fTraversableMaybe_$cmapM_info;
 },
 Data.Traversable.$fTraversableMaybe_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cbZYC,
                       label: Data.Traversable.$fTraversableMaybe_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZYC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZYD; else goto cbZYE;
       cbZYD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableMaybe_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZYE: // global
           I64[Sp - 24] = block_cbZYA_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZYA() //  [R1]
         { info_tbl: [(cbZYA,
                       label: block_cbZYA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZYA: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.478870809 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_$csequence_closure" {
     Data.Traversable.$fTraversableMaybe_$csequence_closure:
         const Data.Traversable.$fTraversableMaybe_$csequence_info;
 },
 Data.Traversable.$fTraversableMaybe_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cbZZ1,
                       label: Data.Traversable.$fTraversableMaybe_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZZ1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbZZ2; else goto cbZZ3;
       cbZZ2: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableMaybe_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbZZ3: // global
           I64[Sp - 16] = block_cbZYU_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubZZp; else goto cbZYV;
       ubZZp: // global
           call _cbZYU(R1) args: 0, res: 0, upd: 0;
       cbZYV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbZYU() //  [R1]
         { info_tbl: [(cbZYU,
                       label: block_cbZYU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZYU: // global
           _sbX6m::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbZYY; else goto cbZYZ;
       cbZYY: // global
           I64[Sp + 8] = block_cbZZ6_info;
           R2 = _sbX6m::P64;
           Sp = Sp + 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
       cbZYZ: // global
           I64[Sp] = block_cbZZe_info;
           R2 = _sbX6m::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZZ6() //  [R1]
         { info_tbl: [(cbZZ6,
                       label: block_cbZZ6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZZ6: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 _cbZZe() //  [R1]
         { info_tbl: [(cbZZe,
                       label: block_cbZZe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZZe: // global
           I64[Sp] = block_cbZZi_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbZZi() //  [R1]
         { info_tbl: [(cbZZi,
                       label: block_cbZZi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZZi: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.489485887 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_closure" {
     Data.Traversable.$fTraversableMaybe_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctorMaybe_closure;
         const Data.Foldable.$fFoldableMaybe_closure;
         const Data.Traversable.$fTraversableFirst_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableMaybe_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableMaybe_$cmapM_closure+3;
         const Data.Traversable.$fTraversableMaybe_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.491485176 UTC

[section ""data" . Data.Traversable.$fTraversableFirst1_closure" {
     Data.Traversable.$fTraversableFirst1_closure:
         const Data.Traversable.$fTraversableFirst1_info;
 },
 Data.Traversable.$fTraversableFirst1_entry() //  [R2]
         { info_tbl: [(cbZZQ,
                       label: Data.Traversable.$fTraversableFirst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbZZQ: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.495058661 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$ctraverse_closure" {
     Data.Traversable.$fTraversableLast_$ctraverse_closure:
         const Data.Traversable.$fTraversableLast_$ctraverse_info;
 },
 sat_sbX6y_entry() //  [R1]
         { info_tbl: [(cc007,
                       label: sat_sbX6y_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc007: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc008; else goto cc009;
       cc008: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc009: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cc00c,
                       label: Data.Traversable.$fTraversableLast_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc00c: // global
           _sbX6w::P64 = R4;
           _sbX6v::P64 = R3;
           _sbX6u::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc00d; else goto cc00e;
       cc00e: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc00g; else goto cc00f;
       cc00g: // global
           HpAlloc = 40;
           goto cc00d;
       cc00d: // global
           R4 = _sbX6w::P64;
           R3 = _sbX6v::P64;
           R2 = _sbX6u::P64;
           R1 = Data.Traversable.$fTraversableLast_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc00f: // global
           I64[Hp - 32] = sat_sbX6y_info;
           P64[Hp - 16] = _sbX6u::P64;
           P64[Hp - 8] = _sbX6v::P64;
           P64[Hp] = _sbX6w::P64;
           I64[Sp - 16] = block_cc00a_info;
           R2 = _sbX6u::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc00a() //  [R1]
         { info_tbl: [(cc00a,
                       label: block_cc00a_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc00a: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.502902148 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$csequenceA_closure" {
     Data.Traversable.$fTraversableLast_$csequenceA_closure:
         const Data.Traversable.$fTraversableLast_$csequenceA_info;
 },
 sat_sbX6F_entry() //  [R1]
         { info_tbl: [(cc00M,
                       label: sat_sbX6F_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc00M: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc00N; else goto cc00O;
       cc00N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc00O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cc00F_info;
           _sbX6z::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbX6z::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc010; else goto cc00G;
       uc010: // global
           call _cc00F(R1) args: 0, res: 0, upd: 0;
       cc00G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc00F() //  [R1]
         { info_tbl: [(cc00F,
                       label: block_cc00F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc00F: // global
           _sbX6z::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc00J; else goto cc00K;
       cc00J: // global
           R2 = _sbX6z::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cc00K: // global
           I64[Sp] = block_cc00U_info;
           R2 = _sbX6z::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc00U() //  [R1]
         { info_tbl: [(cc00U,
                       label: block_cc00U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc00U: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cc013,
                       label: Data.Traversable.$fTraversableLast_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc013: // global
           _sbX6A::P64 = R3;
           _sbX6z::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc014; else goto cc015;
       cc015: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc017; else goto cc016;
       cc017: // global
           HpAlloc = 32;
           goto cc014;
       cc014: // global
           R3 = _sbX6A::P64;
           R2 = _sbX6z::P64;
           R1 = Data.Traversable.$fTraversableLast_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc016: // global
           I64[Hp - 24] = sat_sbX6F_info;
           P64[Hp - 8] = _sbX6z::P64;
           P64[Hp] = _sbX6A::P64;
           I64[Sp - 16] = block_cc011_info;
           R2 = _sbX6z::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc011() //  [R1]
         { info_tbl: [(cc011,
                       label: block_cc011_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc011: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.513993465 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$cmapM_closure" {
     Data.Traversable.$fTraversableLast_$cmapM_closure:
         const Data.Traversable.$fTraversableLast_$cmapM_info;
 },
 sat_sbX6L_entry() //  [R1]
         { info_tbl: [(cc01K,
                       label: sat_sbX6L_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc01K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc01L; else goto cc01M;
       cc01L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc01M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc01N,
                       label: Data.Traversable.$fTraversableLast_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc01N: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc01P; else goto cc01Q;
       cc01P: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableLast_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc01Q: // global
           I64[Sp - 24] = block_cc01C_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc01C() //  [R1]
         { info_tbl: [(cc01C,
                       label: block_cc01C_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc01C: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc01T; else goto cc01S;
       cc01T: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc01S: // global
           I64[Hp - 32] = sat_sbX6L_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc01O_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc01O() //  [R1]
         { info_tbl: [(cc01O,
                       label: block_cc01O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc01O: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.52373525 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$csequence_closure" {
     Data.Traversable.$fTraversableLast_$csequence_closure:
         const Data.Traversable.$fTraversableLast_$csequence_info;
 },
 sat_sbX6T_entry() //  [R1]
         { info_tbl: [(cc02z,
                       label: sat_sbX6T_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc02z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc02A; else goto cc02B;
       cc02A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc02B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cc02s_info;
           _sbX6O::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbX6O::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc02N; else goto cc02t;
       uc02N: // global
           call _cc02s(R1) args: 0, res: 0, upd: 0;
       cc02t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc02s() //  [R1]
         { info_tbl: [(cc02s,
                       label: block_cc02s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc02s: // global
           _sbX6O::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc02w; else goto cc02x;
       cc02w: // global
           R2 = _sbX6O::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cc02x: // global
           I64[Sp] = block_cc02H_info;
           R2 = _sbX6O::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc02H() //  [R1]
         { info_tbl: [(cc02H,
                       label: block_cc02H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc02H: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc02O,
                       label: Data.Traversable.$fTraversableLast_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc02O: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc02Q; else goto cc02R;
       cc02Q: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableLast_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc02R: // global
           I64[Sp - 16] = block_cc02k_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc02k() //  [R1]
         { info_tbl: [(cc02k,
                       label: block_cc02k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc02k: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc02U; else goto cc02T;
       cc02U: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc02T: // global
           I64[Hp - 24] = sat_sbX6T_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_cc02P_info;
           R2 = R1;
           P64[Sp + 8] = Hp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc02P() //  [R1]
         { info_tbl: [(cc02P,
                       label: block_cc02P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc02P: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.535718149 UTC

[section ""data" . Data.Traversable.$fTraversableLast_closure" {
     Data.Traversable.$fTraversableLast_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Monoid.$fFunctorLast_closure;
         const Data.Foldable.$fFoldableLast_closure;
         const Data.Traversable.$fTraversableLast_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableLast_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableLast_$cmapM_closure+3;
         const Data.Traversable.$fTraversableLast_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.538024065 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$ctraverse1_closure" {
     Data.Traversable.$fTraversableFirst_$ctraverse1_closure:
         const Data.Traversable.$fTraversableFirst_$ctraverse1_info;
 },
 sat_sbX6Y_entry() //  [R1]
         { info_tbl: [(cc03z,
                       label: sat_sbX6Y_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc03z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc03A; else goto cc03B;
       cc03A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc03B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$ctraverse1_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cc03E,
                       label: Data.Traversable.$fTraversableFirst_$ctraverse1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc03E: // global
           _sbX6W::P64 = R4;
           _sbX6V::P64 = R3;
           _sbX6U::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc03F; else goto cc03G;
       cc03G: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc03I; else goto cc03H;
       cc03I: // global
           HpAlloc = 40;
           goto cc03F;
       cc03F: // global
           R4 = _sbX6W::P64;
           R3 = _sbX6V::P64;
           R2 = _sbX6U::P64;
           R1 = Data.Traversable.$fTraversableFirst_$ctraverse1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc03H: // global
           I64[Hp - 32] = sat_sbX6Y_info;
           P64[Hp - 16] = _sbX6U::P64;
           P64[Hp - 8] = _sbX6V::P64;
           P64[Hp] = _sbX6W::P64;
           I64[Sp - 16] = block_cc03C_info;
           R2 = _sbX6U::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc03C() //  [R1]
         { info_tbl: [(cc03C,
                       label: block_cc03C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc03C: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.546195949 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$csequenceA_closure" {
     Data.Traversable.$fTraversableFirst_$csequenceA_closure:
         const Data.Traversable.$fTraversableFirst_$csequenceA_info;
 },
 sat_sbX75_entry() //  [R1]
         { info_tbl: [(cc04e,
                       label: sat_sbX75_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc04e: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc04f; else goto cc04g;
       cc04f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc04g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cc047_info;
           _sbX6Z::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sbX6Z::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc04s; else goto cc048;
       uc04s: // global
           call _cc047(R1) args: 0, res: 0, upd: 0;
       cc048: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc047() //  [R1]
         { info_tbl: [(cc047,
                       label: block_cc047_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc047: // global
           _sbX6Z::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc04b; else goto cc04c;
       cc04b: // global
           R2 = _sbX6Z::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cc04c: // global
           I64[Sp] = block_cc04m_info;
           R2 = _sbX6Z::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc04m() //  [R1]
         { info_tbl: [(cc04m,
                       label: block_cc04m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc04m: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cc04v,
                       label: Data.Traversable.$fTraversableFirst_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc04v: // global
           _sbX70::P64 = R3;
           _sbX6Z::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc04w; else goto cc04x;
       cc04x: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc04z; else goto cc04y;
       cc04z: // global
           HpAlloc = 32;
           goto cc04w;
       cc04w: // global
           R3 = _sbX70::P64;
           R2 = _sbX6Z::P64;
           R1 = Data.Traversable.$fTraversableFirst_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc04y: // global
           I64[Hp - 24] = sat_sbX75_info;
           P64[Hp - 8] = _sbX6Z::P64;
           P64[Hp] = _sbX70::P64;
           I64[Sp - 16] = block_cc04t_info;
           R2 = _sbX6Z::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc04t() //  [R1]
         { info_tbl: [(cc04t,
                       label: block_cc04t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc04t: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.557165682 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$cmapM_closure" {
     Data.Traversable.$fTraversableFirst_$cmapM_closure:
         const Data.Traversable.$fTraversableFirst_$cmapM_info;
 },
 sat_sbX7b_entry() //  [R1]
         { info_tbl: [(cc05c,
                       label: sat_sbX7b_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc05c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc05d; else goto cc05e;
       cc05d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc05e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc05f,
                       label: Data.Traversable.$fTraversableFirst_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc05f: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc05h; else goto cc05i;
       cc05h: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableFirst_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc05i: // global
           I64[Sp - 24] = block_cc054_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc054() //  [R1]
         { info_tbl: [(cc054,
                       label: block_cc054_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc054: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc05l; else goto cc05k;
       cc05l: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc05k: // global
           I64[Hp - 32] = sat_sbX7b_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc05g_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc05g() //  [R1]
         { info_tbl: [(cc05g,
                       label: block_cc05g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc05g: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.567313167 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$csequence_closure" {
     Data.Traversable.$fTraversableFirst_$csequence_closure:
         const Data.Traversable.$fTraversableFirst_$csequence_info;
 },
 sat_sbX7j_entry() //  [R1]
         { info_tbl: [(cc061,
                       label: sat_sbX7j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc061: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc062; else goto cc063;
       cc062: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc063: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cc05U_info;
           _sbX7e::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbX7e::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc06f; else goto cc05V;
       uc06f: // global
           call _cc05U(R1) args: 0, res: 0, upd: 0;
       cc05V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc05U() //  [R1]
         { info_tbl: [(cc05U,
                       label: block_cc05U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc05U: // global
           _sbX7e::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc05Y; else goto cc05Z;
       cc05Y: // global
           R2 = _sbX7e::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cc05Z: // global
           I64[Sp] = block_cc069_info;
           R2 = _sbX7e::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc069() //  [R1]
         { info_tbl: [(cc069,
                       label: block_cc069_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc069: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc06g,
                       label: Data.Traversable.$fTraversableFirst_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc06g: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc06i; else goto cc06j;
       cc06i: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableFirst_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc06j: // global
           I64[Sp - 16] = block_cc05M_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc05M() //  [R1]
         { info_tbl: [(cc05M,
                       label: block_cc05M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc05M: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc06m; else goto cc06l;
       cc06m: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc06l: // global
           I64[Hp - 24] = sat_sbX7j_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_cc06h_info;
           R2 = R1;
           P64[Sp + 8] = Hp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc06h() //  [R1]
         { info_tbl: [(cc06h,
                       label: block_cc06h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc06h: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.58096312 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_closure" {
     Data.Traversable.$fTraversableFirst_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Monoid.$fFunctorFirst_closure;
         const Data.Foldable.$fFoldableFirst_closure;
         const Data.Traversable.$fTraversableFirst_$ctraverse1_closure+3;
         const Data.Traversable.$fTraversableFirst_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableFirst_$cmapM_closure+3;
         const Data.Traversable.$fTraversableFirst_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.583720729 UTC

[section ""data" . Data.Traversable.$dmtraverse_closure" {
     Data.Traversable.$dmtraverse_closure:
         const Data.Traversable.$dmtraverse_info;
 },
 f1_sbX7n_entry() //  [R1]
         { info_tbl: [(cc071,
                       label: f1_sbX7n_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc071: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc072; else goto cc073;
       cc072: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc073: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.sequenceA_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 g_sbX7o_entry() //  [R1]
         { info_tbl: [(cc07a,
                       label: g_sbX7o_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc07a: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc07b; else goto cc07c;
       cc07b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc07c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cc078_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.$p1Traversable_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc078() //  [R1]
         { info_tbl: [(cc078,
                       label: block_cc078_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc078: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbX7s_entry() //  [R1, R2]
         { info_tbl: [(cc07m,
                       label: sat_sbX7s_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc07m: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc07q; else goto cc07p;
       cc07q: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc07p: // global
           _sbX7n::P64 = P64[R1 + 7];
           _sbX7o::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sbX7o::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sbX7n::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$dmtraverse_entry() //  [R2, R3, R4]
         { info_tbl: [(cc07r,
                       label: Data.Traversable.$dmtraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc07r: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cc07v; else goto cc07u;
       cc07v: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$dmtraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc07u: // global
           I64[Hp - 80] = f1_sbX7n_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = g_sbX7o_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sbX7s_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.595386542 UTC

[section ""data" . Data.Traversable.for_closure" {
     Data.Traversable.for_closure:
         const Data.Traversable.for_info;
 },
 f1_sbX7v_entry() //  [R1]
         { info_tbl: [(cc081,
                       label: f1_sbX7v_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc081: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc082; else goto cc083;
       cc082: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc083: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.traverse_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbX7y_entry() //  [R1, R2, R3]
         { info_tbl: [(cc089,
                       label: sat_sbX7y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc089: // global
           _sbX7x::P64 = R3;
           R3 = R2;
           R2 = _sbX7x::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.for_entry() //  [R2, R3]
         { info_tbl: [(cc08c,
                       label: Data.Traversable.for_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc08c: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc08g; else goto cc08f;
       cc08g: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.for_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc08f: // global
           I64[Hp - 40] = f1_sbX7v_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sbX7y_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.604122538 UTC

[section ""data" . Data.Traversable.forM_closure" {
     Data.Traversable.forM_closure:
         const Data.Traversable.forM_info;
 },
 f_sbX7B_entry() //  [R1]
         { info_tbl: [(cc08D,
                       label: f_sbX7B_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc08D: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc08E; else goto cc08F;
       cc08E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc08F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.mapM_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sbX7E_entry() //  [R1, R2, R3]
         { info_tbl: [(cc08L,
                       label: sat_sbX7E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc08L: // global
           _sbX7D::P64 = R3;
           R3 = R2;
           R2 = _sbX7D::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.forM_entry() //  [R2, R3]
         { info_tbl: [(cc08O,
                       label: Data.Traversable.forM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc08O: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc08S; else goto cc08R;
       cc08S: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.forM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc08R: // global
           I64[Hp - 40] = f_sbX7B_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sbX7E_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.611847535 UTC

[section ""data" . Data.Traversable.mapAccumL_closure" {
     Data.Traversable.mapAccumL_closure:
         const Data.Traversable.mapAccumL_info;
         const 0;
 },
 sat_sbX7L_entry() //  [R1, R2, R3]
         { info_tbl: [(cc09g,
                       label: sat_sbX7L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc09g: // global
           _sbX7K::P64 = R3;
           R3 = R2;
           R2 = _sbX7K::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.mapAccumL_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc09j,
                       label: Data.Traversable.mapAccumL_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc09j: // global
           _sbX7I::P64 = R5;
           _sbX7H::P64 = R4;
           _sbX7G::P64 = R3;
           _sbX7F::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cc09k; else goto cc09l;
       cc09l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc09n; else goto cc09m;
       cc09n: // global
           HpAlloc = 16;
           goto cc09k;
       cc09k: // global
           R5 = _sbX7I::P64;
           R4 = _sbX7H::P64;
           R3 = _sbX7G::P64;
           R2 = _sbX7F::P64;
           R1 = Data.Traversable.mapAccumL_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc09m: // global
           I64[Hp - 8] = sat_sbX7L_info;
           P64[Hp] = _sbX7G::P64;
           R2 = _sbX7F::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Functor.Utils.$fApplicativeStateL_closure;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = _sbX7I::P64;
           P64[Sp - 8] = _sbX7H::P64;
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.618046032 UTC

[section ""data" . Data.Traversable.mapAccumR_closure" {
     Data.Traversable.mapAccumR_closure:
         const Data.Traversable.mapAccumR_info;
         const 0;
 },
 sat_sbX7S_entry() //  [R1, R2, R3]
         { info_tbl: [(cc09G,
                       label: sat_sbX7S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc09G: // global
           _sbX7R::P64 = R3;
           R3 = R2;
           R2 = _sbX7R::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.mapAccumR_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc09J,
                       label: Data.Traversable.mapAccumR_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc09J: // global
           _sbX7P::P64 = R5;
           _sbX7O::P64 = R4;
           _sbX7N::P64 = R3;
           _sbX7M::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cc09K; else goto cc09L;
       cc09L: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc09N; else goto cc09M;
       cc09N: // global
           HpAlloc = 16;
           goto cc09K;
       cc09K: // global
           R5 = _sbX7P::P64;
           R4 = _sbX7O::P64;
           R3 = _sbX7N::P64;
           R2 = _sbX7M::P64;
           R1 = Data.Traversable.mapAccumR_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc09M: // global
           I64[Hp - 8] = sat_sbX7S_info;
           P64[Hp] = _sbX7N::P64;
           R2 = _sbX7M::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Functor.Utils.$fApplicativeStateR_closure;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = _sbX7P::P64;
           P64[Sp - 8] = _sbX7O::P64;
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.623766842 UTC

[section ""data" . fmapDefault1_rbWTV_closure" {
     fmapDefault1_rbWTV_closure:
         const fmapDefault1_rbWTV_info;
         const 0;
 },
 fmapDefault1_rbWTV_entry() //  [R2]
         { info_tbl: [(cc0a1,
                       label: fmapDefault1_rbWTV_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0a1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0a2; else goto cc0a3;
       cc0a2: // global
           R2 = R2;
           R1 = fmapDefault1_rbWTV_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc0a3: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Functor.Identity.$fApplicativeIdentity_closure;
           Sp = Sp - 16;
           call Data.Traversable.traverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.62729529 UTC

[section ""data" . Data.Traversable.fmapDefault_closure" {
     Data.Traversable.fmapDefault_closure:
         const Data.Traversable.fmapDefault_info;
         const 0;
 },
 Data.Traversable.fmapDefault_entry() //  [R2]
         { info_tbl: [(cc0ad,
                       label: Data.Traversable.fmapDefault_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0ad: // global
           R2 = R2;
           call fmapDefault1_rbWTV_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.63097083 UTC

[section ""data" . foldMapDefault1_rbWTW_closure" {
     foldMapDefault1_rbWTW_closure:
         const foldMapDefault1_rbWTW_info;
         const 0;
 },
 sat_sbX7W_entry() //  [R1]
         { info_tbl: [(cc0as,
                       label: sat_sbX7W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0as: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0at; else goto cc0au;
       cc0at: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0au: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fApplicativeConst_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 foldMapDefault1_rbWTW_entry() //  [R2, R3]
         { info_tbl: [(cc0av,
                       label: foldMapDefault1_rbWTW_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0av: // global
           _sbX7V::P64 = R3;
           _sbX7U::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cc0aw; else goto cc0ax;
       cc0ax: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc0az; else goto cc0ay;
       cc0az: // global
           HpAlloc = 24;
           goto cc0aw;
       cc0aw: // global
           R3 = _sbX7V::P64;
           R2 = _sbX7U::P64;
           R1 = foldMapDefault1_rbWTW_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0ay: // global
           I64[Hp - 16] = sat_sbX7W_info;
           P64[Hp] = _sbX7V::P64;
           R2 = _sbX7U::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Traversable.traverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.637368366 UTC

[section ""data" . Data.Traversable.foldMapDefault_closure" {
     Data.Traversable.foldMapDefault_closure:
         const Data.Traversable.foldMapDefault_info;
         const 0;
 },
 Data.Traversable.foldMapDefault_entry() //  [R2, R3]
         { info_tbl: [(cc0aO,
                       label: Data.Traversable.foldMapDefault_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0aO: // global
           R3 = R3;
           R2 = R2;
           call foldMapDefault1_rbWTW_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.640500055 UTC

[section ""cstring" . Data.Traversable.$trModule4_bytes" {
     Data.Traversable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.642244069 UTC

[section ""data" . Data.Traversable.$trModule3_closure" {
     Data.Traversable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Traversable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.643901608 UTC

[section ""cstring" . Data.Traversable.$trModule2_bytes" {
     Data.Traversable.$trModule2_bytes:
         I8[] [68,97,116,97,46,84,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.645957816 UTC

[section ""data" . Data.Traversable.$trModule1_closure" {
     Data.Traversable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Traversable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.647574648 UTC

[section ""data" . Data.Traversable.$trModule_closure" {
     Data.Traversable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Traversable.$trModule3_closure+1;
         const Data.Traversable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.649338273 UTC

[section ""data" . $krep_rbWTX_closure" {
     $krep_rbWTX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.651036186 UTC

[section ""data" . Data.Traversable.$tcTraversable1_closure" {
     Data.Traversable.$tcTraversable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rbWTX_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.652685171 UTC

[section ""cstring" . Data.Traversable.$tcTraversable3_bytes" {
     Data.Traversable.$tcTraversable3_bytes:
         I8[] [84,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.655177391 UTC

[section ""data" . Data.Traversable.$tcTraversable2_closure" {
     Data.Traversable.$tcTraversable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Traversable.$tcTraversable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.657578166 UTC

[section ""data" . Data.Traversable.$tcTraversable_closure" {
     Data.Traversable.$tcTraversable_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Traversable.$trModule_closure+1;
         const Data.Traversable.$tcTraversable2_closure+1;
         const Data.Traversable.$tcTraversable1_closure+4;
         const 9002450311536760373;
         const 4172295783860716183;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.660425905 UTC

[section ""data" . Data.Traversable.C:Traversable_closure" {
     Data.Traversable.C:Traversable_closure:
         const Data.Traversable.C:Traversable_info;
 },
 Data.Traversable.C:Traversable_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc0ba,
                       label: Data.Traversable.C:Traversable_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0ba: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc0be; else goto cc0bd;
       cc0be: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.C:Traversable_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cc0bd: // global
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.66547746 UTC

[Data.Traversable.C:Traversable_con_entry() //  [R1]
         { info_tbl: [(cc0bl,
                       label: Data.Traversable.C:Traversable_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,114,97,118,101,114,115,97,98,108,101,46,67,58,84,114,97,118,101,114,115,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0bl: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:51.668464621 UTC

[section ""relreadonly" . SbXeW_srt" {
     SbXeW_srt:
         const Data.Foldable.$fFoldableRec1_closure;
         const Data.Traversable.$fTraversableRec1_$cp2Traversable_closure;
         const Data.Foldable.$fFoldableM1_closure;
         const Data.Traversable.$fTraversableM1_$cp2Traversable_closure;
         const Data.Foldable.$fFoldable:+:_closure;
         const Data.Traversable.$fTraversable:+:_$cp2Traversable_closure;
         const Data.Foldable.$fFoldable:*:_closure;
         const Data.Traversable.$fTraversable:*:_$cp2Traversable_closure;
         const Data.Foldable.$fFoldable:.:_closure;
         const Data.Traversable.$fTraversable:.:_$cp2Traversable_closure;
         const Data.Traversable.$fTraversable:.:_closure;
         const Data.Traversable.$fTraversable:*:_closure;
         const Data.Traversable.$fTraversable:+:_closure;
         const Data.Traversable.$fTraversableM1_closure;
         const Data.Traversable.$fTraversableRec1_closure;
         const GHC.Arr.listArray_closure;
         const Data.Traversable.$fTraversableArray_$ctraverse_closure;
         const Data.Traversable.$fTraversableArray_$cmapM_closure;
         const Data.Traversable.$fTraversableArray_$csequence_closure;
         const Data.Traversable.$fTraversableArray_$csequenceA_closure;
         const GHC.Arr.$fFunctorArray_closure;
         const Data.Foldable.$fFoldableArray_closure;
         const Data.Traversable.$fTraversableArray_closure;
         const Data.Functor.Utils.$fApplicativeStateL_closure;
         const Data.Traversable.mapAccumL_closure;
         const Data.Functor.Utils.$fApplicativeStateR_closure;
         const Data.Traversable.mapAccumR_closure;
         const Data.Functor.Identity.$fApplicativeIdentity_closure;
         const fmapDefault1_rbWTV_closure;
         const Data.Functor.Const.$fApplicativeConst_closure;
         const foldMapDefault1_rbWTW_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.827293221 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:54.828716289 UTC

[section ""data" . Data.Traversable.$p1Traversable_closure" {
     Data.Traversable.$p1Traversable_closure:
         const Data.Traversable.$p1Traversable_info;
 },
 Data.Traversable.$p1Traversable_entry() //  [R2]
         { info_tbl: [(cc0px,
                       label: Data.Traversable.$p1Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0px: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc0py; else goto cc0pz;
       cc0py: // global
           R2 = R2;
           R1 = Data.Traversable.$p1Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc0pz: // global
           I64[Sp - 8] = block_cc0pu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc0pD; else goto cc0pv;
       uc0pD: // global
           call _cc0pu(R1) args: 0, res: 0, upd: 0;
       cc0pv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0pu() //  [R1]
         { info_tbl: [(cc0pu,
                       label: block_cc0pu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0pu: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.83453678 UTC

[section ""data" . Data.Traversable.$p2Traversable_closure" {
     Data.Traversable.$p2Traversable_closure:
         const Data.Traversable.$p2Traversable_info;
 },
 Data.Traversable.$p2Traversable_entry() //  [R2]
         { info_tbl: [(cc0pX,
                       label: Data.Traversable.$p2Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0pX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc0pY; else goto cc0pZ;
       cc0pY: // global
           R2 = R2;
           R1 = Data.Traversable.$p2Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc0pZ: // global
           I64[Sp - 8] = block_cc0pU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc0q3; else goto cc0pV;
       uc0q3: // global
           call _cc0pU(R1) args: 0, res: 0, upd: 0;
       cc0pV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0pU() //  [R1]
         { info_tbl: [(cc0pU,
                       label: block_cc0pU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0pU: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.842733707 UTC

[section ""data" . Data.Traversable.traverse_closure" {
     Data.Traversable.traverse_closure:
         const Data.Traversable.traverse_info;
 },
 Data.Traversable.traverse_entry() //  [R2]
         { info_tbl: [(cc0qn,
                       label: Data.Traversable.traverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0qn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc0qo; else goto cc0qp;
       cc0qo: // global
           R2 = R2;
           R1 = Data.Traversable.traverse_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc0qp: // global
           I64[Sp - 8] = block_cc0qk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc0qt; else goto cc0ql;
       uc0qt: // global
           call _cc0qk(R1) args: 0, res: 0, upd: 0;
       cc0ql: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0qk() //  [R1]
         { info_tbl: [(cc0qk,
                       label: block_cc0qk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0qk: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.848308243 UTC

[section ""data" . Data.Traversable.sequenceA_closure" {
     Data.Traversable.sequenceA_closure:
         const Data.Traversable.sequenceA_info;
 },
 Data.Traversable.sequenceA_entry() //  [R2]
         { info_tbl: [(cc0qL,
                       label: Data.Traversable.sequenceA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0qL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc0qM; else goto cc0qN;
       cc0qM: // global
           R2 = R2;
           R1 = Data.Traversable.sequenceA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc0qN: // global
           I64[Sp - 8] = block_cc0qI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc0qR; else goto cc0qJ;
       uc0qR: // global
           call _cc0qI(R1) args: 0, res: 0, upd: 0;
       cc0qJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0qI() //  [R1]
         { info_tbl: [(cc0qI,
                       label: block_cc0qI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0qI: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.854361367 UTC

[section ""data" . Data.Traversable.mapM_closure" {
     Data.Traversable.mapM_closure:
         const Data.Traversable.mapM_info;
 },
 Data.Traversable.mapM_entry() //  [R2]
         { info_tbl: [(cc0r9,
                       label: Data.Traversable.mapM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0r9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc0ra; else goto cc0rb;
       cc0ra: // global
           R2 = R2;
           R1 = Data.Traversable.mapM_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc0rb: // global
           I64[Sp - 8] = block_cc0r6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc0rf; else goto cc0r7;
       uc0rf: // global
           call _cc0r6(R1) args: 0, res: 0, upd: 0;
       cc0r7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0r6() //  [R1]
         { info_tbl: [(cc0r6,
                       label: block_cc0r6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0r6: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.859703709 UTC

[section ""data" . Data.Traversable.sequence_closure" {
     Data.Traversable.sequence_closure:
         const Data.Traversable.sequence_info;
 },
 Data.Traversable.sequence_entry() //  [R2]
         { info_tbl: [(cc0rx,
                       label: Data.Traversable.sequence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0rx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc0ry; else goto cc0rz;
       cc0ry: // global
           R2 = R2;
           R1 = Data.Traversable.sequence_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc0rz: // global
           I64[Sp - 8] = block_cc0ru_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc0rD; else goto cc0rv;
       uc0rD: // global
           call _cc0ru(R1) args: 0, res: 0, upd: 0;
       cc0rv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0ru() //  [R1]
         { info_tbl: [(cc0ru,
                       label: block_cc0ru_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0ru: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.866107527 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$ctraverse_closure" {
     Data.Traversable.$fTraversableFirst_$ctraverse_closure:
         const Data.Traversable.$fTraversableFirst_$ctraverse_info;
 },
 Data.Traversable.$fTraversableFirst_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cc0rZ,
                       label: Data.Traversable.$fTraversableFirst_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0rZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc0s0; else goto cc0s1;
       cc0s0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableFirst_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0s1: // global
           I64[Sp - 24] = block_cc0rS_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc0sg; else goto cc0rT;
       uc0sg: // global
           call _cc0rS(R1) args: 0, res: 0, upd: 0;
       cc0rT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0rS() //  [R1]
         { info_tbl: [(cc0rS,
                       label: block_cc0rS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0rS: // global
           _sc0ce::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc0rW; else goto cc0rX;
       cc0rW: // global
           R2 = _sc0ce::P64;
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cc0rX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc0sb; else goto cc0sa;
       cc0sb: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc0sa: // global
           _sc0ci::P64 = P64[R1 + 6];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc0ci::P64;
           I64[Sp + 8] = block_cc0s8_info;
           R2 = _sc0ce::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0s8() //  [R1]
         { info_tbl: [(cc0s8,
                       label: block_cc0s8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0s8: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.87472057 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$ctraverse_closure" {
     Data.Traversable.$fTraversable[]_$ctraverse_closure:
         const Data.Traversable.$fTraversable[]_$ctraverse_info;
 },
 z_sc0cn_entry() //  [R1]
         { info_tbl: [(cc0sO,
                       label: z_sc0cn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0sO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc0sP; else goto cc0sQ;
       cc0sP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0sQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sc0co_entry() //  [R1, R2]
         { info_tbl: [(cc0t3,
                       label: go_sc0co_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0t3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc0t4; else goto cc0t5;
       cc0t4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc0t5: // global
           I64[Sp - 40] = block_cc0sW_info;
           _sc0co::P64 = R1;
           _sc0cl::P64 = P64[R1 + 7];
           _sc0cm::P64 = P64[R1 + 15];
           _sc0cn::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc0cl::P64;
           P64[Sp - 24] = _sc0cm::P64;
           P64[Sp - 16] = _sc0cn::P64;
           P64[Sp - 8] = _sc0co::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc0tg; else goto cc0sX;
       uc0tg: // global
           call _cc0sW(R1) args: 0, res: 0, upd: 0;
       cc0sX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0sW() //  [R1]
         { info_tbl: [(cc0sW,
                       label: block_cc0sW_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0sW: // global
           if (R1 & 7 == 1) goto cc0t0; else goto cc0t1;
       cc0t0: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc0t1: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc0td; else goto cc0tc;
       cc0td: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc0tc: // global
           _sc0cr::P64 = P64[R1 + 6];
           _sc0cs::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sc0cs::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc0cr::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$ctraverse_entry() //  [R2, R3]
         { info_tbl: [(cc0th,
                       label: Data.Traversable.$fTraversable[]_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0th: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc0tl; else goto cc0tk;
       cc0tl: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$ctraverse_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0tk: // global
           I64[Hp - 48] = z_sc0cn_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_sc0co_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.886434984 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$ctraverse_closure" {
     Data.Traversable.$fTraversableEither_$ctraverse_closure:
         const Data.Traversable.$fTraversableEither_$ctraverse_info;
 },
 Data.Traversable.$fTraversableEither_$ctraverse_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cc0u7,
                       label: Data.Traversable.$fTraversableEither_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0u7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc0u8; else goto cc0u9;
       cc0u8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0u9: // global
           I64[Sp - 24] = block_cc0u0_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc0uo; else goto cc0u1;
       uc0uo: // global
           call _cc0u0(R1) args: 0, res: 0, upd: 0;
       cc0u1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0u0() //  [R1]
         { info_tbl: [(cc0u0,
                       label: block_cc0u0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0u0: // global
           _sc0cv::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc0u4; else goto cc0u5;
       cc0u4: // global
           R2 = _sc0cv::P64;
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cc0u5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc0uj; else goto cc0ui;
       cc0uj: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc0ui: // global
           _sc0cB::P64 = P64[R1 + 6];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc0cB::P64;
           I64[Sp + 8] = block_cc0ug_info;
           R2 = _sc0cv::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0ug() //  [R1]
         { info_tbl: [(cc0ug,
                       label: block_cc0ug_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0ug: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.895238033 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$ctraverse_closure" {
     Data.Traversable.$fTraversable(,)_$ctraverse_closure:
         const Data.Traversable.$fTraversable(,)_$ctraverse_info;
 },
 sat_sc0cL_entry() //  [R1, R2]
         { info_tbl: [(cc0v2,
                       label: sat_sc0cL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0v2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc0v6; else goto cc0v5;
       cc0v6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc0v5: // global
           _sc0cI::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sc0cI::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$ctraverse_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cc0v7,
                       label: Data.Traversable.$fTraversable(,)_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0v7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc0v9; else goto cc0va;
       cc0v9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0va: // global
           I64[Sp - 24] = block_cc0uQ_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc0vi; else goto cc0uR;
       uc0vi: // global
           call _cc0uQ(R1) args: 0, res: 0, upd: 0;
       cc0uR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0uQ() //  [R1]
         { info_tbl: [(cc0uQ,
                       label: block_cc0uQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0uQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc0vd; else goto cc0vc;
       cc0vd: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc0vc: // global
           _sc0cI::P64 = P64[R1 + 7];
           _sc0cJ::P64 = P64[R1 + 15];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sc0cJ::P64;
           I64[Hp - 8] = sat_sc0cL_info;
           P64[Hp] = _sc0cI::P64;
           I64[Sp] = block_cc0v8_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 7;
           P64[Sp + 16] = Hp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0v8() //  [R1]
         { info_tbl: [(cc0v8,
                       label: block_cc0v8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0v8: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.90490871 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$csequence_closure" {
     Data.Traversable.$fTraversableProxy_$csequence_closure:
         const Data.Traversable.$fTraversableProxy_$csequence_info;
 },
 Data.Traversable.$fTraversableProxy_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc0vO,
                       label: Data.Traversable.$fTraversableProxy_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0vO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0vP; else goto cc0vQ;
       cc0vP: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0vQ: // global
           I64[Sp - 8] = block_cc0vM_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0vM() //  [R1]
         { info_tbl: [(cc0vM,
                       label: block_cc0vM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0vM: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.910673453 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$cmapM_closure" {
     Data.Traversable.$fTraversableProxy_$cmapM_closure:
         const Data.Traversable.$fTraversableProxy_$cmapM_info;
 },
 Data.Traversable.$fTraversableProxy_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc0wc,
                       label: Data.Traversable.$fTraversableProxy_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0wc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0wd; else goto cc0we;
       cc0wd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0we: // global
           I64[Sp - 8] = block_cc0wa_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0wa() //  [R1]
         { info_tbl: [(cc0wa,
                       label: block_cc0wa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0wa: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.915901529 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$csequenceA_closure" {
     Data.Traversable.$fTraversableProxy_$csequenceA_closure:
         const Data.Traversable.$fTraversableProxy_$csequenceA_info;
 },
 Data.Traversable.$fTraversableProxy_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cc0wy,
                       label: Data.Traversable.$fTraversableProxy_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0wy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0wz; else goto cc0wA;
       cc0wz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0wA: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.920713667 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_$ctraverse_closure" {
     Data.Traversable.$fTraversableProxy_$ctraverse_closure:
         const Data.Traversable.$fTraversableProxy_$ctraverse_info;
 },
 Data.Traversable.$fTraversableProxy_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cc0wN,
                       label: Data.Traversable.$fTraversableProxy_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0wN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0wO; else goto cc0wP;
       cc0wO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProxy_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0wP: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Proxy.Proxy_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.924274724 UTC

[section ""data" . Data.Traversable.$fTraversableProxy_closure" {
     Data.Traversable.$fTraversableProxy_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Proxy.$fFunctorProxy_closure;
         const Data.Foldable.$fFoldableProxy_closure;
         const Data.Traversable.$fTraversableProxy_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableProxy_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableProxy_$cmapM_closure+3;
         const Data.Traversable.$fTraversableProxy_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.927046563 UTC

[section ""data" . Data.Traversable.$fTraversableConst_$ctraverse_closure" {
     Data.Traversable.$fTraversableConst_$ctraverse_closure:
         const Data.Traversable.$fTraversableConst_$ctraverse_info;
 },
 Data.Traversable.$fTraversableConst_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cc0x3,
                       label: Data.Traversable.$fTraversableConst_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0x3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0x4; else goto cc0x5;
       cc0x4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableConst_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0x5: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.930851173 UTC

[section ""data" . Data.Traversable.$fTraversableDual1_closure" {
     Data.Traversable.$fTraversableDual1_closure:
         const Data.Traversable.$fTraversableDual1_info;
 },
 Data.Traversable.$fTraversableDual1_entry() //  [R2]
         { info_tbl: [(cc0xg,
                       label: Data.Traversable.$fTraversableDual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0xg: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.934393627 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$ctraverse_closure" {
     Data.Traversable.$fTraversableDual_$ctraverse_closure:
         const Data.Traversable.$fTraversableDual_$ctraverse_info;
 },
 Data.Traversable.$fTraversableDual_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cc0xu,
                       label: Data.Traversable.$fTraversableDual_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0xu: // global
           _sc0d5::P64 = R4;
           _sc0d4::P64 = R3;
           _sc0d3::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc0xv; else goto cc0xw;
       cc0xw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc0xy; else goto cc0xx;
       cc0xy: // global
           HpAlloc = 32;
           goto cc0xv;
       cc0xv: // global
           R4 = _sc0d5::P64;
           R3 = _sc0d4::P64;
           R2 = _sc0d3::P64;
           R1 = Data.Traversable.$fTraversableDual_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0xx: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc0d4::P64;
           P64[Hp] = _sc0d5::P64;
           I64[Sp - 16] = block_cc0xs_info;
           R2 = _sc0d3::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0xs() //  [R1]
         { info_tbl: [(cc0xs,
                       label: block_cc0xs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0xs: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.940547519 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$ctraverse_closure" {
     Data.Traversable.$fTraversableSum_$ctraverse_closure:
         const Data.Traversable.$fTraversableSum_$ctraverse_info;
 },
 Data.Traversable.$fTraversableSum_$ctraverse_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cc0xW,
                       label: Data.Traversable.$fTraversableSum_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0xW: // global
           _sc0da::P64 = R4;
           _sc0d9::P64 = R3;
           _sc0d8::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc0xX; else goto cc0xY;
       cc0xY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc0y0; else goto cc0xZ;
       cc0y0: // global
           HpAlloc = 32;
           goto cc0xX;
       cc0xX: // global
           R4 = _sc0da::P64;
           R3 = _sc0d9::P64;
           R2 = _sc0d8::P64;
           R1 = Data.Traversable.$fTraversableSum_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0xZ: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc0d9::P64;
           P64[Hp] = _sc0da::P64;
           I64[Sp - 16] = block_cc0xU_info;
           R2 = _sc0d8::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0xU() //  [R1]
         { info_tbl: [(cc0xU,
                       label: block_cc0xU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0xU: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.94680636 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$ctraverse_closure" {
     Data.Traversable.$fTraversableProduct_$ctraverse_closure:
         const Data.Traversable.$fTraversableProduct_$ctraverse_info;
 },
 Data.Traversable.$fTraversableProduct_$ctraverse_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cc0yo,
                       label: Data.Traversable.$fTraversableProduct_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0yo: // global
           _sc0df::P64 = R4;
           _sc0de::P64 = R3;
           _sc0dd::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc0yp; else goto cc0yq;
       cc0yq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc0ys; else goto cc0yr;
       cc0ys: // global
           HpAlloc = 32;
           goto cc0yp;
       cc0yp: // global
           R4 = _sc0df::P64;
           R3 = _sc0de::P64;
           R2 = _sc0dd::P64;
           R1 = Data.Traversable.$fTraversableProduct_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0yr: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc0de::P64;
           P64[Hp] = _sc0df::P64;
           I64[Sp - 16] = block_cc0ym_info;
           R2 = _sc0dd::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0ym() //  [R1]
         { info_tbl: [(cc0ym,
                       label: block_cc0ym_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0ym: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.952917804 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$csequence_closure" {
     Data.Traversable.$fTraversableU1_$csequence_closure:
         const Data.Traversable.$fTraversableU1_$csequence_info;
 },
 Data.Traversable.$fTraversableU1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc0yP,
                       label: Data.Traversable.$fTraversableU1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0yP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0yQ; else goto cc0yR;
       cc0yQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0yR: // global
           I64[Sp - 8] = block_cc0yN_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0yN() //  [R1]
         { info_tbl: [(cc0yN,
                       label: block_cc0yN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0yN: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Generics.U1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.958505719 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$cmapM_closure" {
     Data.Traversable.$fTraversableU1_$cmapM_closure:
         const Data.Traversable.$fTraversableU1_$cmapM_info;
 },
 Data.Traversable.$fTraversableU1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc0zd,
                       label: Data.Traversable.$fTraversableU1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0zd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0ze; else goto cc0zf;
       cc0ze: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0zf: // global
           I64[Sp - 8] = block_cc0zb_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0zb() //  [R1]
         { info_tbl: [(cc0zb,
                       label: block_cc0zb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0zb: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Generics.U1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.964159499 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$csequenceA_closure" {
     Data.Traversable.$fTraversableU1_$csequenceA_closure:
         const Data.Traversable.$fTraversableU1_$csequenceA_info;
 },
 Data.Traversable.$fTraversableU1_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cc0zz,
                       label: Data.Traversable.$fTraversableU1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0zz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0zA; else goto cc0zB;
       cc0zA: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0zB: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Generics.U1_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.967918445 UTC

[section ""data" . Data.Traversable.$fTraversableU1_$ctraverse_closure" {
     Data.Traversable.$fTraversableU1_$ctraverse_closure:
         const Data.Traversable.$fTraversableU1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableU1_$ctraverse_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cc0zO,
                       label: Data.Traversable.$fTraversableU1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0zO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0zP; else goto cc0zQ;
       cc0zP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableU1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0zQ: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Generics.U1_closure+1;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.971480708 UTC

[section ""data" . Data.Traversable.$fTraversableU1_closure" {
     Data.Traversable.$fTraversableU1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorU1_closure;
         const Data.Foldable.$fFoldableU1_closure;
         const Data.Traversable.$fTraversableU1_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableU1_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableU1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableU1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.973602412 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$ctraverse_closure" {
     Data.Traversable.$fTraversableIdentity_$ctraverse_closure:
         const Data.Traversable.$fTraversableIdentity_$ctraverse_info;
 },
 Data.Traversable.$fTraversableIdentity_$ctraverse_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cc0A7,
                       label: Data.Traversable.$fTraversableIdentity_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0A7: // global
           _sc0dw::P64 = R4;
           _sc0dv::P64 = R3;
           _sc0du::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc0A8; else goto cc0A9;
       cc0A9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc0Ab; else goto cc0Aa;
       cc0Ab: // global
           HpAlloc = 32;
           goto cc0A8;
       cc0A8: // global
           R4 = _sc0dw::P64;
           R3 = _sc0dv::P64;
           R2 = _sc0du::P64;
           R1 = Data.Traversable.$fTraversableIdentity_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Aa: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc0dv::P64;
           P64[Hp] = _sc0dw::P64;
           I64[Sp - 16] = block_cc0A5_info;
           R2 = _sc0du::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0A5() //  [R1]
         { info_tbl: [(cc0A5,
                       label: block_cc0A5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0A5: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.979942859 UTC

[section ""data" . Data.Traversable.$fTraversableV1_$ctraverse_closure" {
     Data.Traversable.$fTraversableV1_$ctraverse_closure:
         const Data.Traversable.$fTraversableV1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableV1_$ctraverse_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cc0Aw,
                       label: Data.Traversable.$fTraversableV1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Aw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Ax; else goto cc0Ay;
       cc0Ax: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableV1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Ay: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.983702703 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$ctraverse_closure" {
     Data.Traversable.$fTraversablePar1_$ctraverse_closure:
         const Data.Traversable.$fTraversablePar1_$ctraverse_info;
 },
 Data.Traversable.$fTraversablePar1_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cc0AM,
                       label: Data.Traversable.$fTraversablePar1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0AM: // global
           _sc0dE::P64 = R4;
           _sc0dD::P64 = R3;
           _sc0dC::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc0AN; else goto cc0AO;
       cc0AO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc0AQ; else goto cc0AP;
       cc0AQ: // global
           HpAlloc = 32;
           goto cc0AN;
       cc0AN: // global
           R4 = _sc0dE::P64;
           R3 = _sc0dD::P64;
           R2 = _sc0dC::P64;
           R1 = Data.Traversable.$fTraversablePar1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0AP: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc0dD::P64;
           P64[Hp] = _sc0dE::P64;
           I64[Sp - 16] = block_cc0AK_info;
           R2 = _sc0dC::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0AK() //  [R1]
         { info_tbl: [(cc0AK,
                       label: block_cc0AK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0AK: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.989355918 UTC

[section ""data" . Data.Traversable.$fTraversableM2_closure" {
     Data.Traversable.$fTraversableM2_closure:
         const Data.Traversable.$fTraversableM2_info;
 },
 Data.Traversable.$fTraversableM2_entry() //  [R2]
         { info_tbl: [(cc0Bb,
                       label: Data.Traversable.$fTraversableM2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Bb: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:54.993782251 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$ctraverse_closure" {
     Data.Traversable.$fTraversableRec1_$ctraverse_closure:
         const Data.Traversable.$fTraversableRec1_$ctraverse_info;
 },
 sat_sc0dN_entry() //  [R1]
         { info_tbl: [(cc0Bq,
                       label: sat_sc0dN_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Bq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cc0Br; else goto cc0Bs;
       cc0Br: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0Bs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$ctraverse_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cc0Bv,
                       label: Data.Traversable.$fTraversableRec1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Bv: // global
           _sc0dL::P64 = R5;
           _sc0dK::P64 = R4;
           _sc0dJ::P64 = R3;
           _sc0dI::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc0Bw; else goto cc0Bx;
       cc0Bx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc0Bz; else goto cc0By;
       cc0Bz: // global
           HpAlloc = 48;
           goto cc0Bw;
       cc0Bw: // global
           R5 = _sc0dL::P64;
           R4 = _sc0dK::P64;
           R3 = _sc0dJ::P64;
           R2 = _sc0dI::P64;
           R1 = Data.Traversable.$fTraversableRec1_$ctraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0By: // global
           I64[Hp - 40] = sat_sc0dN_info;
           P64[Hp - 24] = _sc0dI::P64;
           P64[Hp - 16] = _sc0dJ::P64;
           P64[Hp - 8] = _sc0dK::P64;
           P64[Hp] = _sc0dL::P64;
           I64[Sp - 16] = block_cc0Bt_info;
           R2 = _sc0dJ::P64;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Bt() //  [R1]
         { info_tbl: [(cc0Bt,
                       label: block_cc0Bt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Bt: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.00136618 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$cp2Traversable_closure" {
     Data.Traversable.$fTraversableRec1_$cp2Traversable_closure:
         const Data.Traversable.$fTraversableRec1_$cp2Traversable_info;
         const 0;
 },
 sat_sc0dP_entry() //  [R1]
         { info_tbl: [(cc0C7,
                       label: sat_sc0dP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0C7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0C8; else goto cc0C9;
       cc0C8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0C9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$cp2Traversable_entry() //  [R2]
         { info_tbl: [(cc0Ca,
                       label: Data.Traversable.$fTraversableRec1_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Ca: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc0Ce; else goto cc0Cd;
       cc0Ce: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$cp2Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc0Cd: // global
           I64[Hp - 16] = sat_sc0dP_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldableRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.007251483 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$cp1Traversable_closure" {
     Data.Traversable.$fTraversableRec1_$cp1Traversable_closure:
         const Data.Traversable.$fTraversableRec1_$cp1Traversable_info;
 },
 sat_sc0dR_entry() //  [R1]
         { info_tbl: [(cc0Cy,
                       label: sat_sc0dR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Cy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Cz; else goto cc0CA;
       cc0Cz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0CA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$cp1Traversable_entry() //  [R2]
         { info_tbl: [(cc0CB,
                       label: Data.Traversable.$fTraversableRec1_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0CB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc0CF; else goto cc0CE;
       cc0CF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$cp1Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc0CE: // global
           I64[Hp - 16] = sat_sc0dR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctorRec1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.012828866 UTC

[section ""data" . Data.Traversable.$fTraversableK1_$ctraverse_closure" {
     Data.Traversable.$fTraversableK1_$ctraverse_closure:
         const Data.Traversable.$fTraversableK1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableK1_$ctraverse_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cc0CU,
                       label: Data.Traversable.$fTraversableK1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0CU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0CV; else goto cc0CW;
       cc0CV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableK1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0CW: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.016789987 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$ctraverse_closure" {
     Data.Traversable.$fTraversableM1_$ctraverse_closure:
         const Data.Traversable.$fTraversableM1_$ctraverse_info;
 },
 sat_sc0e0_entry() //  [R1]
         { info_tbl: [(cc0Db,
                       label: sat_sc0e0_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Db: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cc0Dc; else goto cc0Dd;
       cc0Dc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0Dd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$ctraverse_entry() //  [R2, R3,
                                                          R4, R5]
         { info_tbl: [(cc0Dg,
                       label: Data.Traversable.$fTraversableM1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Dg: // global
           _sc0dY::P64 = R5;
           _sc0dX::P64 = R4;
           _sc0dW::P64 = R3;
           _sc0dV::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc0Dh; else goto cc0Di;
       cc0Di: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc0Dk; else goto cc0Dj;
       cc0Dk: // global
           HpAlloc = 48;
           goto cc0Dh;
       cc0Dh: // global
           R5 = _sc0dY::P64;
           R4 = _sc0dX::P64;
           R3 = _sc0dW::P64;
           R2 = _sc0dV::P64;
           R1 = Data.Traversable.$fTraversableM1_$ctraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Dj: // global
           I64[Hp - 40] = sat_sc0e0_info;
           P64[Hp - 24] = _sc0dV::P64;
           P64[Hp - 16] = _sc0dW::P64;
           P64[Hp - 8] = _sc0dX::P64;
           P64[Hp] = _sc0dY::P64;
           I64[Sp - 16] = block_cc0De_info;
           R2 = _sc0dW::P64;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0De() //  [R1]
         { info_tbl: [(cc0De,
                       label: block_cc0De_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0De: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.025184462 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$cp2Traversable_closure" {
     Data.Traversable.$fTraversableM1_$cp2Traversable_closure:
         const Data.Traversable.$fTraversableM1_$cp2Traversable_info;
         const 0;
 },
 sat_sc0e2_entry() //  [R1]
         { info_tbl: [(cc0DS,
                       label: sat_sc0e2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0DS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0DT; else goto cc0DU;
       cc0DT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0DU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$cp2Traversable_entry() //  [R2]
         { info_tbl: [(cc0DV,
                       label: Data.Traversable.$fTraversableM1_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0DV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc0DZ; else goto cc0DY;
       cc0DZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$cp2Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc0DY: // global
           I64[Hp - 16] = sat_sc0e2_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldableM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.030845313 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$cp1Traversable_closure" {
     Data.Traversable.$fTraversableM1_$cp1Traversable_closure:
         const Data.Traversable.$fTraversableM1_$cp1Traversable_info;
 },
 sat_sc0e4_entry() //  [R1]
         { info_tbl: [(cc0Ei,
                       label: sat_sc0e4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Ei: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Ej; else goto cc0Ek;
       cc0Ej: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0Ek: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$cp1Traversable_entry() //  [R2]
         { info_tbl: [(cc0El,
                       label: Data.Traversable.$fTraversableM1_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0El: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc0Ep; else goto cc0Eo;
       cc0Ep: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$cp1Traversable_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc0Eo: // global
           I64[Hp - 16] = sat_sc0e4_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctorM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.037630682 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$ctraverse_closure" {
     Data.Traversable.$fTraversable:+:_$ctraverse_closure:
         const Data.Traversable.$fTraversable:+:_$ctraverse_info;
 },
 sat_sc0ed_entry() //  [R1]
         { info_tbl: [(cc0EN,
                       label: sat_sc0ed_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0EN: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cc0EO; else goto cc0EP;
       cc0EO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0EP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sc0eg_entry() //  [R1]
         { info_tbl: [(cc0EW,
                       label: sat_sc0eg_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0EW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cc0EX; else goto cc0EY;
       cc0EX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0EY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cc0F3,
                       label: Data.Traversable.$fTraversable:+:_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0F3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc0F4; else goto cc0F5;
       cc0F4: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0F5: // global
           I64[Sp - 40] = block_cc0EE_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc0Fm; else goto cc0EF;
       uc0Fm: // global
           call _cc0EE(R1) args: 0, res: 0, upd: 0;
       cc0EF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0EE() //  [R1]
         { info_tbl: [(cc0EE,
                       label: block_cc0EE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0EE: // global
           _sc0e7::P64 = P64[Sp + 24];
           _sc0e8::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto cc0F0; else goto cc0F1;
       cc0F0: // global
           Hp = Hp + 48;
           _sc0ea::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cc0Fh; else goto cc0F8;
       cc0F8: // global
           _sc0eb::P64 = P64[_sc0ea::P64 + 7];
           I64[Hp - 40] = sat_sc0ed_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sc0e7::P64;
           P64[Hp - 8] = _sc0e8::P64;
           P64[Hp] = _sc0eb::P64;
           I64[Sp + 24] = block_cc0F6_info;
           R2 = _sc0e7::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
       cc0F1: // global
           Hp = Hp + 48;
           _sc0ea::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cc0Fh; else goto cc0Fg;
       cc0Fh: // global
           HpAlloc = 48;
           R1 = _sc0ea::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc0Fg: // global
           _sc0ee::P64 = P64[_sc0ea::P64 + 6];
           I64[Hp - 40] = sat_sc0eg_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sc0e7::P64;
           P64[Hp - 8] = _sc0e8::P64;
           P64[Hp] = _sc0ee::P64;
           I64[Sp + 24] = block_cc0Fe_info;
           R2 = _sc0e7::P64;
           P64[Sp + 32] = Hp - 40;
           Sp = Sp + 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0F6() //  [R1]
         { info_tbl: [(cc0F6,
                       label: block_cc0F6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0F6: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Generics.L1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 _cc0Fe() //  [R1]
         { info_tbl: [(cc0Fe,
                       label: block_cc0Fe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Fe: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Generics.R1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.052501012 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$cp2Traversable_closure" {
     Data.Traversable.$fTraversable:+:_$cp2Traversable_closure:
         const Data.Traversable.$fTraversable:+:_$cp2Traversable_info;
         const 0;
 },
 sat_sc0ek_entry() //  [R1]
         { info_tbl: [(cc0Gj,
                       label: sat_sc0ek_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Gj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Gk; else goto cc0Gl;
       cc0Gk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0Gl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0ej_entry() //  [R1]
         { info_tbl: [(cc0Gq,
                       label: sat_sc0ej_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Gq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Gr; else goto cc0Gs;
       cc0Gr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0Gs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cc0Gt,
                       label: Data.Traversable.$fTraversable:+:_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Gt: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc0Gx; else goto cc0Gw;
       cc0Gx: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Gw: // global
           I64[Hp - 40] = sat_sc0ek_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sc0ej_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldable:+:_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.060311497 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$cp1Traversable_closure" {
     Data.Traversable.$fTraversable:+:_$cp1Traversable_closure:
         const Data.Traversable.$fTraversable:+:_$cp1Traversable_info;
 },
 sat_sc0eo_entry() //  [R1]
         { info_tbl: [(cc0GW,
                       label: sat_sc0eo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0GW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0GX; else goto cc0GY;
       cc0GX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0GY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0en_entry() //  [R1]
         { info_tbl: [(cc0H3,
                       label: sat_sc0en_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0H3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0H4; else goto cc0H5;
       cc0H4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0H5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cc0H6,
                       label: Data.Traversable.$fTraversable:+:_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0H6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc0Ha; else goto cc0H9;
       cc0Ha: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0H9: // global
           I64[Hp - 40] = sat_sc0eo_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sc0en_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctor:+:_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.068586937 UTC

[section ""data" . Data.Traversable.$w$ctraverse_closure" {
     Data.Traversable.$w$ctraverse_closure:
         const Data.Traversable.$w$ctraverse_info;
 },
 sat_sc0ew_entry() //  [R1]
         { info_tbl: [(cc0Hz,
                       label: sat_sc0ew_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Hz: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cc0HA; else goto cc0HB;
       cc0HA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0HB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_sc0ev_entry() //  [R1]
         { info_tbl: [(cc0HG,
                       label: sat_sc0ev_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0HG: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cc0HH; else goto cc0HI;
       cc0HH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0HI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$w$ctraverse_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc0HJ,
                       label: Data.Traversable.$w$ctraverse_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0HJ: // global
           _sc0et::P64 = R6;
           _sc0es::P64 = R5;
           _sc0er::P64 = R4;
           _sc0eq::P64 = R3;
           _sc0ep::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc0HK; else goto cc0HL;
       cc0HL: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cc0HN; else goto cc0HM;
       cc0HN: // global
           HpAlloc = 96;
           goto cc0HK;
       cc0HK: // global
           R6 = _sc0et::P64;
           R5 = _sc0es::P64;
           R4 = _sc0er::P64;
           R3 = _sc0eq::P64;
           R2 = _sc0ep::P64;
           R1 = Data.Traversable.$w$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cc0HM: // global
           I64[Hp - 88] = sat_sc0ew_info;
           P64[Hp - 72] = _sc0eq::P64;
           P64[Hp - 64] = _sc0er::P64;
           P64[Hp - 56] = _sc0es::P64;
           P64[Hp - 48] = P64[Sp];
           I64[Hp - 40] = sat_sc0ev_info;
           P64[Hp - 24] = _sc0ep::P64;
           P64[Hp - 16] = _sc0er::P64;
           P64[Hp - 8] = _sc0es::P64;
           P64[Hp] = _sc0et::P64;
           R2 = _sc0er::P64;
           I64[Sp - 24] = stg_ap_ppp_info;
           P64[Sp - 16] = GHC.Generics.:*:_closure+2;
           P64[Sp - 8] = Hp - 40;
           P64[Sp] = Hp - 88;
           Sp = Sp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.078044087 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$ctraverse_closure" {
     Data.Traversable.$fTraversable:*:_$ctraverse_closure:
         const Data.Traversable.$fTraversable:*:_$ctraverse_info;
 },
 Data.Traversable.$fTraversable:*:_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cc0Iq,
                       label: Data.Traversable.$fTraversable:*:_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Iq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc0Ir; else goto cc0Is;
       cc0Ir: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Is: // global
           I64[Sp - 40] = block_cc0In_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc0Iw; else goto cc0Io;
       uc0Iw: // global
           call _cc0In(R1) args: 0, res: 0, upd: 0;
       cc0Io: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0In() //  [R1]
         { info_tbl: [(cc0In,
                       label: block_cc0In_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0In: // global
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 32] = P64[R1 + 15];
           Sp = Sp + 32;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.08396762 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$cp2Traversable_closure" {
     Data.Traversable.$fTraversable:*:_$cp2Traversable_closure:
         const Data.Traversable.$fTraversable:*:_$cp2Traversable_info;
         const 0;
 },
 sat_sc0eI_entry() //  [R1]
         { info_tbl: [(cc0IQ,
                       label: sat_sc0eI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0IQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0IR; else goto cc0IS;
       cc0IR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0IS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0eH_entry() //  [R1]
         { info_tbl: [(cc0IX,
                       label: sat_sc0eH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0IX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0IY; else goto cc0IZ;
       cc0IY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0IZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:*:_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cc0J0,
                       label: Data.Traversable.$fTraversable:*:_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0J0: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc0J4; else goto cc0J3;
       cc0J4: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0J3: // global
           I64[Hp - 40] = sat_sc0eI_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sc0eH_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldable:*:_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.092100976 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$cp1Traversable_closure" {
     Data.Traversable.$fTraversable:*:_$cp1Traversable_closure:
         const Data.Traversable.$fTraversable:*:_$cp1Traversable_info;
 },
 sat_sc0eM_entry() //  [R1]
         { info_tbl: [(cc0Jt,
                       label: sat_sc0eM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Jt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Ju; else goto cc0Jv;
       cc0Ju: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0Jv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0eL_entry() //  [R1]
         { info_tbl: [(cc0JA,
                       label: sat_sc0eL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0JA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0JB; else goto cc0JC;
       cc0JB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0JC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:*:_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cc0JD,
                       label: Data.Traversable.$fTraversable:*:_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0JD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc0JH; else goto cc0JG;
       cc0JH: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0JG: // global
           I64[Hp - 40] = sat_sc0eM_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sc0eL_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctor:*:_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.099406871 UTC

[section ""data" . Data.Traversable.$fTraversable:.:1_closure" {
     Data.Traversable.$fTraversable:.:1_closure:
         const Data.Traversable.$fTraversable:.:1_info;
 },
 Data.Traversable.$fTraversable:.:1_entry() //  [R2]
         { info_tbl: [(cc0K2,
                       label: Data.Traversable.$fTraversable:.:1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0K2: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.103210175 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$ctraverse_closure" {
     Data.Traversable.$fTraversable:.:_$ctraverse_closure:
         const Data.Traversable.$fTraversable:.:_$ctraverse_info;
 },
 sat_sc0eU_entry() //  [R1]
         { info_tbl: [(cc0Kl,
                       label: sat_sc0eU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Kl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc0Km; else goto cc0Kn;
       cc0Km: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0Kn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sc0eV_entry() //  [R1]
         { info_tbl: [(cc0Ko,
                       label: sat_sc0eV_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Ko: // global
           _sc0eV::P64 = R1;
           if ((Sp + -48) < SpLim) (likely: False) goto cc0Kp; else goto cc0Kq;
       cc0Kq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc0Ks; else goto cc0Kr;
       cc0Ks: // global
           HpAlloc = 40;
           goto cc0Kp;
       cc0Kp: // global
           R1 = _sc0eV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0Kr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc0eV::P64;
           _sc0eO::P64 = P64[_sc0eV::P64 + 16];
           _sc0eP::P64 = P64[_sc0eV::P64 + 24];
           _sc0eQ::P64 = P64[_sc0eV::P64 + 32];
           _sc0eR::P64 = P64[_sc0eV::P64 + 40];
           _sc0eS::P64 = P64[_sc0eV::P64 + 48];
           I64[Hp - 32] = sat_sc0eU_info;
           P64[Hp - 16] = _sc0eP::P64;
           P64[Hp - 8] = _sc0eQ::P64;
           P64[Hp] = _sc0eR::P64;
           R2 = _sc0eO::P64;
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = _sc0eQ::P64;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = _sc0eS::P64;
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_$ctraverse_entry() //  [R2, R3,
                                                           R4, R5, R6]
         { info_tbl: [(cc0Kv,
                       label: Data.Traversable.$fTraversable:.:_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Kv: // global
           _sc0eS::P64 = R6;
           _sc0eR::P64 = R5;
           _sc0eQ::P64 = R4;
           _sc0eP::P64 = R3;
           _sc0eO::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc0Kw; else goto cc0Kx;
       cc0Kx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc0Kz; else goto cc0Ky;
       cc0Kz: // global
           HpAlloc = 56;
           goto cc0Kw;
       cc0Kw: // global
           R6 = _sc0eS::P64;
           R5 = _sc0eR::P64;
           R4 = _sc0eQ::P64;
           R3 = _sc0eP::P64;
           R2 = _sc0eO::P64;
           R1 = Data.Traversable.$fTraversable:.:_$ctraverse_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Ky: // global
           I64[Hp - 48] = sat_sc0eV_info;
           P64[Hp - 32] = _sc0eO::P64;
           P64[Hp - 24] = _sc0eP::P64;
           P64[Hp - 16] = _sc0eQ::P64;
           P64[Hp - 8] = _sc0eR::P64;
           P64[Hp] = _sc0eS::P64;
           I64[Sp - 16] = block_cc0Kt_info;
           R2 = _sc0eQ::P64;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Kt() //  [R1]
         { info_tbl: [(cc0Kt,
                       label: block_cc0Kt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Kt: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversable:.:1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.11454845 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$cp2Traversable_closure" {
     Data.Traversable.$fTraversable:.:_$cp2Traversable_closure:
         const Data.Traversable.$fTraversable:.:_$cp2Traversable_info;
         const 0;
 },
 sat_sc0eZ_entry() //  [R1]
         { info_tbl: [(cc0Le,
                       label: sat_sc0eZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Le: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Lf; else goto cc0Lg;
       cc0Lf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0Lg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0eY_entry() //  [R1]
         { info_tbl: [(cc0Ll,
                       label: sat_sc0eY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Ll: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Lm; else goto cc0Ln;
       cc0Lm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0Ln: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_$cp2Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cc0Lo,
                       label: Data.Traversable.$fTraversable:.:_$cp2Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Lo: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc0Ls; else goto cc0Lr;
       cc0Ls: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$cp2Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Lr: // global
           I64[Hp - 40] = sat_sc0eZ_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sc0eY_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call Data.Foldable.$fFoldable:.:_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.123002735 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$cp1Traversable_closure" {
     Data.Traversable.$fTraversable:.:_$cp1Traversable_closure:
         const Data.Traversable.$fTraversable:.:_$cp1Traversable_info;
 },
 sat_sc0f3_entry() //  [R1]
         { info_tbl: [(cc0LR,
                       label: sat_sc0f3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0LR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0LS; else goto cc0LT;
       cc0LS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0LT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0f2_entry() //  [R1]
         { info_tbl: [(cc0LY,
                       label: sat_sc0f2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0LY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0LZ; else goto cc0M0;
       cc0LZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0M0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$p1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_$cp1Traversable_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cc0M1,
                       label: Data.Traversable.$fTraversable:.:_$cp1Traversable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0M1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc0M5; else goto cc0M4;
       cc0M5: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$cp1Traversable_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0M4: // global
           I64[Hp - 40] = sat_sc0f3_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_sc0f2_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Generics.$fFunctor:.:_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.130440721 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec4_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec4_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec4_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cc0Ms,
                       label: Data.Traversable.$fTraversableURec4_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Ms: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Mt; else goto cc0Mu;
       cc0Mt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Mu: // global
           I64[Sp - 16] = block_cc0Mq_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Mq() //  [R1]
         { info_tbl: [(cc0Mq,
                       label: block_cc0Mq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Mq: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.136183076 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec3_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec3_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec3_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cc0MO,
                       label: Data.Traversable.$fTraversableURec3_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0MO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0MP; else goto cc0MQ;
       cc0MP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0MQ: // global
           I64[Sp - 16] = block_cc0MM_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0MM() //  [R1]
         { info_tbl: [(cc0MM,
                       label: block_cc0MM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0MM: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.141784509 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec2_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec2_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec2_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cc0Na,
                       label: Data.Traversable.$fTraversableURec2_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Na: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Nb; else goto cc0Nc;
       cc0Nb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Nc: // global
           I64[Sp - 16] = block_cc0N8_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0N8() //  [R1]
         { info_tbl: [(cc0N8,
                       label: block_cc0N8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0N8: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.147612013 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec1_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec1_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec1_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cc0Nw,
                       label: Data.Traversable.$fTraversableURec1_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Nw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Nx; else goto cc0Ny;
       cc0Nx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Ny: // global
           I64[Sp - 16] = block_cc0Nu_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Nu() //  [R1]
         { info_tbl: [(cc0Nu,
                       label: block_cc0Nu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Nu: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.153381989 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec0_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec0_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec0_$ctraverse_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cc0NS,
                       label: Data.Traversable.$fTraversableURec0_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0NS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0NT; else goto cc0NU;
       cc0NT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0NU: // global
           I64[Sp - 16] = block_cc0NQ_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0NQ() //  [R1]
         { info_tbl: [(cc0NQ,
                       label: block_cc0NQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0NQ: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.158854472 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$ctraverse_closure" {
     Data.Traversable.$fTraversableURec_$ctraverse_closure:
         const Data.Traversable.$fTraversableURec_$ctraverse_info;
 },
 Data.Traversable.$fTraversableURec_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cc0Oe,
                       label: Data.Traversable.$fTraversableURec_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Oe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Of; else goto cc0Og;
       cc0Of: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Og: // global
           I64[Sp - 16] = block_cc0Oc_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Oc() //  [R1]
         { info_tbl: [(cc0Oc,
                       label: block_cc0Oc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Oc: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.164626768 UTC

[section ""data" . Data.Traversable.$dmsequence_closure" {
     Data.Traversable.$dmsequence_closure:
         const Data.Traversable.$dmsequence_info;
 },
 sat_sc0fG_entry() //  [R1]
         { info_tbl: [(cc0OC,
                       label: sat_sc0fG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0OC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0OD; else goto cc0OE;
       cc0OD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0OE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$dmsequence_entry() //  [R2, R3]
         { info_tbl: [(cc0OF,
                       label: Data.Traversable.$dmsequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0OF: // global
           _sc0fF::P64 = R3;
           _sc0fE::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cc0OG; else goto cc0OH;
       cc0OH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc0OJ; else goto cc0OI;
       cc0OJ: // global
           HpAlloc = 24;
           goto cc0OG;
       cc0OG: // global
           R3 = _sc0fF::P64;
           R2 = _sc0fE::P64;
           R1 = Data.Traversable.$dmsequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0OI: // global
           I64[Hp - 16] = sat_sc0fG_info;
           P64[Hp] = _sc0fF::P64;
           R2 = _sc0fE::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Traversable.sequenceA_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.170833253 UTC

[section ""data" . Data.Traversable.$dmmapM_closure" {
     Data.Traversable.$dmmapM_closure:
         const Data.Traversable.$dmmapM_info;
 },
 sat_sc0fJ_entry() //  [R1]
         { info_tbl: [(cc0P5,
                       label: sat_sc0fJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0P5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0P6; else goto cc0P7;
       cc0P6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0P7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$dmmapM_entry() //  [R2, R3]
         { info_tbl: [(cc0P8,
                       label: Data.Traversable.$dmmapM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0P8: // global
           _sc0fI::P64 = R3;
           _sc0fH::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cc0P9; else goto cc0Pa;
       cc0Pa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc0Pc; else goto cc0Pb;
       cc0Pc: // global
           HpAlloc = 24;
           goto cc0P9;
       cc0P9: // global
           R3 = _sc0fI::P64;
           R2 = _sc0fH::P64;
           R1 = Data.Traversable.$dmmapM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Pb: // global
           I64[Hp - 16] = sat_sc0fJ_info;
           P64[Hp] = _sc0fI::P64;
           R2 = _sc0fH::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Traversable.traverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.177058678 UTC

[section ""data" . Data.Traversable.$dmsequenceA_closure" {
     Data.Traversable.$dmsequenceA_closure:
         const Data.Traversable.$dmsequenceA_info;
 },
 Data.Traversable.$dmsequenceA_entry() //  [R2, R3]
         { info_tbl: [(cc0Pu,
                       label: Data.Traversable.$dmsequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Pu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc0Pv; else goto cc0Pw;
       cc0Pv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$dmsequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Pw: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = GHC.Base.id_closure+1;
           Sp = Sp - 24;
           call Data.Traversable.traverse_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.181225026 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cc0PL,
                       label: Data.Traversable.$fTraversableURec_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0PL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0PM; else goto cc0PN;
       cc0PM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0PN: // global
           I64[Sp - 16] = block_cc0PJ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0PJ() //  [R1]
         { info_tbl: [(cc0PJ,
                       label: block_cc0PJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0PJ: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.186723988 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$cmapM_closure" {
     Data.Traversable.$fTraversableURec_$cmapM_closure:
         const Data.Traversable.$fTraversableURec_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc0Q7,
                       label: Data.Traversable.$fTraversableURec_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Q7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Qb; else goto cc0Qc;
       cc0Qb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Qc: // global
           I64[Sp - 16] = block_cc0Q5_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Q5() //  [R1]
         { info_tbl: [(cc0Q5,
                       label: block_cc0Q5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Q5: // global
           I64[Sp] = block_cc0Qa_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Qa() //  [R1]
         { info_tbl: [(cc0Qa,
                       label: block_cc0Qa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Qa: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.193927706 UTC

[section ""data" . Data.Traversable.$fTraversableURec_$csequence_closure" {
     Data.Traversable.$fTraversableURec_$csequence_closure:
         const Data.Traversable.$fTraversableURec_$csequence_info;
 },
 Data.Traversable.$fTraversableURec_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc0QC,
                       label: Data.Traversable.$fTraversableURec_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0QC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0QG; else goto cc0QH;
       cc0QG: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0QH: // global
           I64[Sp - 16] = block_cc0QA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0QA() //  [R1]
         { info_tbl: [(cc0QA,
                       label: block_cc0QA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0QA: // global
           I64[Sp] = block_cc0QF_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0QF() //  [R1]
         { info_tbl: [(cc0QF,
                       label: block_cc0QF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0QF: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.200315522 UTC

[section ""data" . Data.Traversable.$fTraversableURec_closure" {
     Data.Traversable.$fTraversableURec_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec_closure;
         const Data.Foldable.$fFoldableURec_closure;
         const Data.Traversable.$fTraversableURec_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.202755213 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec0_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec0_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec0_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cc0R8,
                       label: Data.Traversable.$fTraversableURec0_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0R8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0R9; else goto cc0Ra;
       cc0R9: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Ra: // global
           I64[Sp - 16] = block_cc0R6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0R6() //  [R1]
         { info_tbl: [(cc0R6,
                       label: block_cc0R6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0R6: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.208214116 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$cmapM_closure" {
     Data.Traversable.$fTraversableURec0_$cmapM_closure:
         const Data.Traversable.$fTraversableURec0_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec0_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc0Ru,
                       label: Data.Traversable.$fTraversableURec0_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Ru: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Ry; else goto cc0Rz;
       cc0Ry: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Rz: // global
           I64[Sp - 16] = block_cc0Rs_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Rs() //  [R1]
         { info_tbl: [(cc0Rs,
                       label: block_cc0Rs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Rs: // global
           I64[Sp] = block_cc0Rx_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Rx() //  [R1]
         { info_tbl: [(cc0Rx,
                       label: block_cc0Rx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Rx: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.215699059 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_$csequence_closure" {
     Data.Traversable.$fTraversableURec0_$csequence_closure:
         const Data.Traversable.$fTraversableURec0_$csequence_info;
 },
 Data.Traversable.$fTraversableURec0_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc0RZ,
                       label: Data.Traversable.$fTraversableURec0_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0RZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0S3; else goto cc0S4;
       cc0S3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec0_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0S4: // global
           I64[Sp - 16] = block_cc0RX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0RX() //  [R1]
         { info_tbl: [(cc0RX,
                       label: block_cc0RX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0RX: // global
           I64[Sp] = block_cc0S2_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0S2() //  [R1]
         { info_tbl: [(cc0S2,
                       label: block_cc0S2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0S2: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.222917554 UTC

[section ""data" . Data.Traversable.$fTraversableURec0_closure" {
     Data.Traversable.$fTraversableURec0_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec0_closure;
         const Data.Foldable.$fFoldableURec0_closure;
         const Data.Traversable.$fTraversableURec0_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec0_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec0_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec0_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.225042933 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec1_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec1_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec1_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cc0Sv,
                       label: Data.Traversable.$fTraversableURec1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Sv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Sw; else goto cc0Sx;
       cc0Sw: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Sx: // global
           I64[Sp - 16] = block_cc0St_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0St() //  [R1]
         { info_tbl: [(cc0St,
                       label: block_cc0St_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0St: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.23102613 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$cmapM_closure" {
     Data.Traversable.$fTraversableURec1_$cmapM_closure:
         const Data.Traversable.$fTraversableURec1_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc0SR,
                       label: Data.Traversable.$fTraversableURec1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0SR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0SV; else goto cc0SW;
       cc0SV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0SW: // global
           I64[Sp - 16] = block_cc0SP_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0SP() //  [R1]
         { info_tbl: [(cc0SP,
                       label: block_cc0SP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0SP: // global
           I64[Sp] = block_cc0SU_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0SU() //  [R1]
         { info_tbl: [(cc0SU,
                       label: block_cc0SU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0SU: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.238152203 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_$csequence_closure" {
     Data.Traversable.$fTraversableURec1_$csequence_closure:
         const Data.Traversable.$fTraversableURec1_$csequence_info;
 },
 Data.Traversable.$fTraversableURec1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc0Tm,
                       label: Data.Traversable.$fTraversableURec1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Tm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Tq; else goto cc0Tr;
       cc0Tq: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Tr: // global
           I64[Sp - 16] = block_cc0Tk_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Tk() //  [R1]
         { info_tbl: [(cc0Tk,
                       label: block_cc0Tk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Tk: // global
           I64[Sp] = block_cc0Tp_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Tp() //  [R1]
         { info_tbl: [(cc0Tp,
                       label: block_cc0Tp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Tp: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.245165538 UTC

[section ""data" . Data.Traversable.$fTraversableURec1_closure" {
     Data.Traversable.$fTraversableURec1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec1_closure;
         const Data.Foldable.$fFoldableURec1_closure;
         const Data.Traversable.$fTraversableURec1_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec1_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.24744441 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec2_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec2_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec2_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cc0TS,
                       label: Data.Traversable.$fTraversableURec2_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0TS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0TT; else goto cc0TU;
       cc0TT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0TU: // global
           I64[Sp - 16] = block_cc0TQ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0TQ() //  [R1]
         { info_tbl: [(cc0TQ,
                       label: block_cc0TQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0TQ: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.252779228 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$cmapM_closure" {
     Data.Traversable.$fTraversableURec2_$cmapM_closure:
         const Data.Traversable.$fTraversableURec2_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec2_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc0Ue,
                       label: Data.Traversable.$fTraversableURec2_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Ue: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Ui; else goto cc0Uj;
       cc0Ui: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Uj: // global
           I64[Sp - 16] = block_cc0Uc_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Uc() //  [R1]
         { info_tbl: [(cc0Uc,
                       label: block_cc0Uc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Uc: // global
           I64[Sp] = block_cc0Uh_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Uh() //  [R1]
         { info_tbl: [(cc0Uh,
                       label: block_cc0Uh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Uh: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.260167029 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_$csequence_closure" {
     Data.Traversable.$fTraversableURec2_$csequence_closure:
         const Data.Traversable.$fTraversableURec2_$csequence_info;
 },
 Data.Traversable.$fTraversableURec2_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc0UJ,
                       label: Data.Traversable.$fTraversableURec2_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0UJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0UN; else goto cc0UO;
       cc0UN: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec2_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0UO: // global
           I64[Sp - 16] = block_cc0UH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0UH() //  [R1]
         { info_tbl: [(cc0UH,
                       label: block_cc0UH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0UH: // global
           I64[Sp] = block_cc0UM_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0UM() //  [R1]
         { info_tbl: [(cc0UM,
                       label: block_cc0UM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0UM: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.267119306 UTC

[section ""data" . Data.Traversable.$fTraversableURec2_closure" {
     Data.Traversable.$fTraversableURec2_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec2_closure;
         const Data.Foldable.$fFoldableURec2_closure;
         const Data.Traversable.$fTraversableURec2_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec2_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec2_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec2_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.269375758 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec3_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec3_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec3_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cc0Vf,
                       label: Data.Traversable.$fTraversableURec3_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Vf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Vg; else goto cc0Vh;
       cc0Vg: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Vh: // global
           I64[Sp - 16] = block_cc0Vd_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Vd() //  [R1]
         { info_tbl: [(cc0Vd,
                       label: block_cc0Vd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Vd: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.275158632 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$cmapM_closure" {
     Data.Traversable.$fTraversableURec3_$cmapM_closure:
         const Data.Traversable.$fTraversableURec3_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec3_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc0VB,
                       label: Data.Traversable.$fTraversableURec3_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0VB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0VF; else goto cc0VG;
       cc0VF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0VG: // global
           I64[Sp - 16] = block_cc0Vz_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Vz() //  [R1]
         { info_tbl: [(cc0Vz,
                       label: block_cc0Vz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Vz: // global
           I64[Sp] = block_cc0VE_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0VE() //  [R1]
         { info_tbl: [(cc0VE,
                       label: block_cc0VE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0VE: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.282368959 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_$csequence_closure" {
     Data.Traversable.$fTraversableURec3_$csequence_closure:
         const Data.Traversable.$fTraversableURec3_$csequence_info;
 },
 Data.Traversable.$fTraversableURec3_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc0W6,
                       label: Data.Traversable.$fTraversableURec3_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0W6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Wa; else goto cc0Wb;
       cc0Wa: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec3_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Wb: // global
           I64[Sp - 16] = block_cc0W4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0W4() //  [R1]
         { info_tbl: [(cc0W4,
                       label: block_cc0W4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0W4: // global
           I64[Sp] = block_cc0W9_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0W9() //  [R1]
         { info_tbl: [(cc0W9,
                       label: block_cc0W9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0W9: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.289469018 UTC

[section ""data" . Data.Traversable.$fTraversableURec3_closure" {
     Data.Traversable.$fTraversableURec3_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec3_closure;
         const Data.Foldable.$fFoldableURec3_closure;
         const Data.Traversable.$fTraversableURec3_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec3_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec3_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec3_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.291539747 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$csequenceA_closure" {
     Data.Traversable.$fTraversableURec4_$csequenceA_closure:
         const Data.Traversable.$fTraversableURec4_$csequenceA_info;
 },
 Data.Traversable.$fTraversableURec4_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cc0WC,
                       label: Data.Traversable.$fTraversableURec4_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0WC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0WD; else goto cc0WE;
       cc0WD: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0WE: // global
           I64[Sp - 16] = block_cc0WA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0WA() //  [R1]
         { info_tbl: [(cc0WA,
                       label: block_cc0WA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0WA: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.297812322 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$cmapM_closure" {
     Data.Traversable.$fTraversableURec4_$cmapM_closure:
         const Data.Traversable.$fTraversableURec4_$cmapM_info;
 },
 Data.Traversable.$fTraversableURec4_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc0WY,
                       label: Data.Traversable.$fTraversableURec4_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0WY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0X2; else goto cc0X3;
       cc0X2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0X3: // global
           I64[Sp - 16] = block_cc0WW_info;
           R1 = R4;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0WW() //  [R1]
         { info_tbl: [(cc0WW,
                       label: block_cc0WW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0WW: // global
           I64[Sp] = block_cc0X1_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0X1() //  [R1]
         { info_tbl: [(cc0X1,
                       label: block_cc0X1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0X1: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.304945377 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_$csequence_closure" {
     Data.Traversable.$fTraversableURec4_$csequence_closure:
         const Data.Traversable.$fTraversableURec4_$csequence_info;
 },
 Data.Traversable.$fTraversableURec4_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc0Xt,
                       label: Data.Traversable.$fTraversableURec4_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Xt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Xx; else goto cc0Xy;
       cc0Xx: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableURec4_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Xy: // global
           I64[Sp - 16] = block_cc0Xr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Xr() //  [R1]
         { info_tbl: [(cc0Xr,
                       label: block_cc0Xr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Xr: // global
           I64[Sp] = block_cc0Xw_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Xw() //  [R1]
         { info_tbl: [(cc0Xw,
                       label: block_cc0Xw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Xw: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.312435856 UTC

[section ""data" . Data.Traversable.$fTraversableURec4_closure" {
     Data.Traversable.$fTraversableURec4_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorURec4_closure;
         const Data.Foldable.$fFoldableURec4_closure;
         const Data.Traversable.$fTraversableURec4_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableURec4_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableURec4_$cmapM_closure+3;
         const Data.Traversable.$fTraversableURec4_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.314431137 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$csequenceA_closure" {
     Data.Traversable.$fTraversable:.:_$csequenceA_closure:
         const Data.Traversable.$fTraversable:.:_$csequenceA_info;
 },
 Data.Traversable.$fTraversable:.:_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cc0XX,
                       label: Data.Traversable.$fTraversable:.:_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0XX: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.320015979 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$cmapM_closure" {
     Data.Traversable.$fTraversable:.:_$cmapM_closure:
         const Data.Traversable.$fTraversable:.:_$cmapM_info;
 },
 Data.Traversable.$fTraversable:.:_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cc0Yb,
                       label: Data.Traversable.$fTraversable:.:_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Yb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc0Yc; else goto cc0Yd;
       cc0Yc: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Yd: // global
           I64[Sp - 40] = block_cc0Y9_info;
           _sc0hz::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sc0hz::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Y9() //  [R1]
         { info_tbl: [(cc0Y9,
                       label: block_cc0Y9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Y9: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.327780937 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_$csequence_closure" {
     Data.Traversable.$fTraversable:.:_$csequence_closure:
         const Data.Traversable.$fTraversable:.:_$csequence_info;
 },
 Data.Traversable.$fTraversable:.:_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cc0Yw,
                       label: Data.Traversable.$fTraversable:.:_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Yw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc0Yx; else goto cc0Yy;
       cc0Yx: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0Yy: // global
           I64[Sp - 32] = block_cc0Yu_info;
           _sc0hF::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sc0hF::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc0Yu() //  [R1]
         { info_tbl: [(cc0Yu,
                       label: block_cc0Yu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Yu: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.334769484 UTC

[section ""data" . Data.Traversable.$fTraversable:.:_closure" {
     Data.Traversable.$fTraversable:.:_closure:
         const Data.Traversable.$fTraversable:.:_info;
         const 0;
 },
 sat_sc0hR_entry() //  [R1, R2, R3]
         { info_tbl: [(cc0YV,
                       label: sat_sc0hR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0YV: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:.:_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0hQ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cc0Z3,
                       label: sat_sc0hQ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Z3: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:.:_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0hP_entry() //  [R1, R2, R3]
         { info_tbl: [(cc0Zb,
                       label: sat_sc0hP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Zb: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:.:_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0hO_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cc0Zj,
                       label: sat_sc0hO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Zj: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:.:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0hN_entry() //  [R1]
         { info_tbl: [(cc0Zq,
                       label: sat_sc0hN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Zq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Zr; else goto cc0Zs;
       cc0Zr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0Zs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:.:_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0hM_entry() //  [R1]
         { info_tbl: [(cc0Zx,
                       label: sat_sc0hM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0Zx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc0Zy; else goto cc0Zz;
       cc0Zy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc0Zz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:.:_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:.:_entry() //  [R2, R3]
         { info_tbl: [(cc0ZB,
                       label: Data.Traversable.$fTraversable:.:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc0ZB: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cc0ZF; else goto cc0ZE;
       cc0ZF: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:.:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc0ZE: // global
           I64[Hp - 208] = sat_sc0hR_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sc0hQ_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sc0hP_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sc0hO_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sc0hN_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sc0hM_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.350740044 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$csequenceA_closure" {
     Data.Traversable.$fTraversable:*:_$csequenceA_closure:
         const Data.Traversable.$fTraversable:*:_$csequenceA_info;
 },
 Data.Traversable.$fTraversable:*:_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cc10r,
                       label: Data.Traversable.$fTraversable:*:_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc10r: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc10s; else goto cc10t;
       cc10s: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$csequenceA_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc10t: // global
           I64[Sp - 32] = block_cc10o_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc10x; else goto cc10p;
       uc10x: // global
           call _cc10o(R1) args: 0, res: 0, upd: 0;
       cc10p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc10o() //  [R1]
         { info_tbl: [(cc10o,
                       label: block_cc10o_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc10o: // global
           R6 = P64[R1 + 7];
           R5 = GHC.Base.id_closure+1;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp + 24;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.357706759 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$cmapM_closure" {
     Data.Traversable.$fTraversable:*:_$cmapM_closure:
         const Data.Traversable.$fTraversable:*:_$cmapM_info;
 },
 Data.Traversable.$fTraversable:*:_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cc10R,
                       label: Data.Traversable.$fTraversable:*:_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc10R: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cc10V; else goto cc10W;
       cc10V: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc10W: // global
           I64[Sp - 40] = block_cc10O_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc112; else goto cc10P;
       uc112: // global
           call _cc10O(R1) args: 0, res: 0, upd: 0;
       cc10P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc10O() //  [R1]
         { info_tbl: [(cc10O,
                       label: block_cc10O_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc10O: // global
           I64[Sp - 8] = block_cc10U_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc10U() //  [R1]
         { info_tbl: [(cc10U,
                       label: block_cc10U_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc10U: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 40];
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.365288484 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_$csequence_closure" {
     Data.Traversable.$fTraversable:*:_$csequence_closure:
         const Data.Traversable.$fTraversable:*:_$csequence_info;
 },
 Data.Traversable.$fTraversable:*:_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cc11r,
                       label: Data.Traversable.$fTraversable:*:_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc11r: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc11v; else goto cc11w;
       cc11v: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc11w: // global
           I64[Sp - 32] = block_cc11o_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc11C; else goto cc11p;
       uc11C: // global
           call _cc11o(R1) args: 0, res: 0, upd: 0;
       cc11p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc11o() //  [R1]
         { info_tbl: [(cc11o,
                       label: block_cc11o_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc11o: // global
           I64[Sp - 8] = block_cc11u_info;
           R2 = P64[Sp + 24];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 24] = P64[R1 + 7];
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc11u() //  [R1]
         { info_tbl: [(cc11u,
                       label: block_cc11u_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc11u: // global
           R6 = P64[Sp + 32];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 32] = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$w$ctraverse_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.373990845 UTC

[section ""data" . Data.Traversable.$fTraversable:*:_closure" {
     Data.Traversable.$fTraversable:*:_closure:
         const Data.Traversable.$fTraversable:*:_info;
         const 0;
 },
 sat_sc0in_entry() //  [R1, R2, R3]
         { info_tbl: [(cc124,
                       label: sat_sc0in_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc124: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:*:_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0im_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cc12c,
                       label: sat_sc0im_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc12c: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:*:_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0il_entry() //  [R1, R2, R3]
         { info_tbl: [(cc12k,
                       label: sat_sc0il_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc12k: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:*:_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0ik_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cc12s,
                       label: sat_sc0ik_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc12s: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:*:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0ij_entry() //  [R1]
         { info_tbl: [(cc12z,
                       label: sat_sc0ij_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc12z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc12A; else goto cc12B;
       cc12A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc12B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:*:_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0ii_entry() //  [R1]
         { info_tbl: [(cc12G,
                       label: sat_sc0ii_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc12G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc12H; else goto cc12I;
       cc12H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc12I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:*:_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:*:_entry() //  [R2, R3]
         { info_tbl: [(cc12K,
                       label: Data.Traversable.$fTraversable:*:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc12K: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cc12O; else goto cc12N;
       cc12O: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:*:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc12N: // global
           I64[Hp - 208] = sat_sc0in_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sc0im_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sc0il_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sc0ik_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sc0ij_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sc0ii_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.389357836 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$csequenceA_closure" {
     Data.Traversable.$fTraversable:+:_$csequenceA_closure:
         const Data.Traversable.$fTraversable:+:_$csequenceA_info;
 },
 Data.Traversable.$fTraversable:+:_$csequenceA_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(cc13x,
                       label: Data.Traversable.$fTraversable:+:_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc13x: // global
           R6 = R5;
           R5 = GHC.Base.id_closure+1;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.393045901 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$cmapM_closure" {
     Data.Traversable.$fTraversable:+:_$cmapM_closure:
         const Data.Traversable.$fTraversable:+:_$cmapM_info;
 },
 Data.Traversable.$fTraversable:+:_$cmapM_entry() //  [R2, R3, R4,
                                                       R5, R6]
         { info_tbl: [(cc13L,
                       label: Data.Traversable.$fTraversable:+:_$cmapM_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc13L: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc13M; else goto cc13N;
       cc13M: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$cmapM_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc13N: // global
           I64[Sp - 40] = block_cc13J_info;
           _sc0ir::P64 = R2;
           R2 = R4;
           P64[Sp - 32] = _sc0ir::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc13J() //  [R1]
         { info_tbl: [(cc13J,
                       label: block_cc13J_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc13J: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.399694989 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_$csequence_closure" {
     Data.Traversable.$fTraversable:+:_$csequence_closure:
         const Data.Traversable.$fTraversable:+:_$csequence_info;
 },
 Data.Traversable.$fTraversable:+:_$csequence_entry() //  [R2, R3,
                                                           R4, R5]
         { info_tbl: [(cc146,
                       label: Data.Traversable.$fTraversable:+:_$csequence_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc146: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc147; else goto cc148;
       cc147: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_$csequence_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc148: // global
           I64[Sp - 32] = block_cc144_info;
           _sc0ix::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _sc0ix::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc144() //  [R1]
         { info_tbl: [(cc144,
                       label: block_cc144_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc144: // global
           R6 = P64[Sp + 24];
           R5 = GHC.Base.id_closure+1;
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.40643853 UTC

[section ""data" . Data.Traversable.$fTraversable:+:_closure" {
     Data.Traversable.$fTraversable:+:_closure:
         const Data.Traversable.$fTraversable:+:_info;
         const 0;
 },
 sat_sc0iJ_entry() //  [R1, R2, R3]
         { info_tbl: [(cc14v,
                       label: sat_sc0iJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc14v: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:+:_$csequence_entry(R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0iI_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cc14D,
                       label: sat_sc0iI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc14D: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:+:_$cmapM_entry(R6,
                                                               R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0iH_entry() //  [R1, R2, R3]
         { info_tbl: [(cc14L,
                       label: sat_sc0iH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc14L: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversable:+:_$csequenceA_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0iG_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cc14T,
                       label: sat_sc0iG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc14T: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversable:+:_$ctraverse_entry(R6,
                                                                   R5,
                                                                   R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0iF_entry() //  [R1]
         { info_tbl: [(cc150,
                       label: sat_sc0iF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc150: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc151; else goto cc152;
       cc151: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc152: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:+:_$cp2Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0iE_entry() //  [R1]
         { info_tbl: [(cc157,
                       label: sat_sc0iE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc157: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc158; else goto cc159;
       cc158: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc159: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversable:+:_$cp1Traversable_entry(R3,
                                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversable:+:_entry() //  [R2, R3]
         { info_tbl: [(cc15b,
                       label: Data.Traversable.$fTraversable:+:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc15b: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cc15f; else goto cc15e;
       cc15f: // global
           HpAlloc = 216;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable:+:_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc15e: // global
           I64[Hp - 208] = sat_sc0iJ_info;
           P64[Hp - 200] = R2;
           P64[Hp - 192] = R3;
           I64[Hp - 184] = sat_sc0iI_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = sat_sc0iH_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = sat_sc0iG_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = sat_sc0iF_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           I64[Hp - 80] = sat_sc0iE_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 133;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 181;
           P64[Hp] = Hp - 206;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.422019602 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$csequenceA_closure" {
     Data.Traversable.$fTraversableM1_$csequenceA_closure:
         const Data.Traversable.$fTraversableM1_$csequenceA_info;
 },
 sat_sc0iO_entry() //  [R1]
         { info_tbl: [(cc162,
                       label: sat_sc0iO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc162: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cc163; else goto cc164;
       cc163: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc164: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$csequenceA_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cc167,
                       label: Data.Traversable.$fTraversableM1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc167: // global
           _sc0iM::P64 = R4;
           _sc0iL::P64 = R3;
           _sc0iK::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc168; else goto cc169;
       cc169: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc16b; else goto cc16a;
       cc16b: // global
           HpAlloc = 40;
           goto cc168;
       cc168: // global
           R4 = _sc0iM::P64;
           R3 = _sc0iL::P64;
           R2 = _sc0iK::P64;
           R1 = Data.Traversable.$fTraversableM1_$csequenceA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc16a: // global
           I64[Hp - 32] = sat_sc0iO_info;
           P64[Hp - 16] = _sc0iK::P64;
           P64[Hp - 8] = _sc0iL::P64;
           P64[Hp] = _sc0iM::P64;
           I64[Sp - 16] = block_cc165_info;
           R2 = _sc0iL::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc165() //  [R1]
         { info_tbl: [(cc165,
                       label: block_cc165_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc165: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.430756277 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$cmapM_closure" {
     Data.Traversable.$fTraversableM1_$cmapM_closure:
         const Data.Traversable.$fTraversableM1_$cmapM_info;
 },
 sat_sc0iV_entry() //  [R1]
         { info_tbl: [(cc16O,
                       label: sat_sc0iV_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc16O: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cc16P; else goto cc16Q;
       cc16P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc16Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$cmapM_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(cc16R,
                       label: Data.Traversable.$fTraversableM1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc16R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc16T; else goto cc16U;
       cc16T: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$cmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc16U: // global
           I64[Sp - 32] = block_cc16G_info;
           _sc0iP::P64 = R2;
           R2 = R3;
           P64[Sp - 24] = _sc0iP::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc16G() //  [R1]
         { info_tbl: [(cc16G,
                       label: block_cc16G_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc16G: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc16X; else goto cc16W;
       cc16X: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc16W: // global
           I64[Hp - 40] = sat_sc0iV_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           I64[Sp + 16] = block_cc16S_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 40;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc16S() //  [R1]
         { info_tbl: [(cc16S,
                       label: block_cc16S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc16S: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.44113995 UTC

[section ""data" . Data.Traversable.$fTraversableM1_$csequence_closure" {
     Data.Traversable.$fTraversableM1_$csequence_closure:
         const Data.Traversable.$fTraversableM1_$csequence_info;
 },
 sat_sc0j1_entry() //  [R1]
         { info_tbl: [(cc17H,
                       label: sat_sc0j1_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc17H: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cc17I; else goto cc17J;
       cc17I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc17J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_$csequence_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cc17K,
                       label: Data.Traversable.$fTraversableM1_$csequence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc17K: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc17M; else goto cc17N;
       cc17M: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_$csequence_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc17N: // global
           I64[Sp - 24] = block_cc17z_info;
           _sc0iW::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _sc0iW::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc17z() //  [R1]
         { info_tbl: [(cc17z,
                       label: block_cc17z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc17z: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc17Q; else goto cc17P;
       cc17Q: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc17P: // global
           I64[Hp - 32] = sat_sc0j1_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc17L_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc17L() //  [R1]
         { info_tbl: [(cc17L,
                       label: block_cc17L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc17L: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.451541369 UTC

[section ""data" . Data.Traversable.$fTraversableM1_closure" {
     Data.Traversable.$fTraversableM1_closure:
         const Data.Traversable.$fTraversableM1_info;
         const 0;
 },
 sat_sc0j8_entry() //  [R1, R2, R3]
         { info_tbl: [(cc18x,
                       label: sat_sc0j8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc18x: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableM1_$csequence_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0j7_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cc18F,
                       label: sat_sc0j7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc18F: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableM1_$cmapM_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0j6_entry() //  [R1, R2, R3]
         { info_tbl: [(cc18N,
                       label: sat_sc0j6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc18N: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableM1_$csequenceA_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0j5_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cc18V,
                       label: sat_sc0j5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc18V: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableM1_$ctraverse_entry(R5,
                                                                  R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0j4_entry() //  [R1]
         { info_tbl: [(cc192,
                       label: sat_sc0j4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc192: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc193; else goto cc194;
       cc193: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc194: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableM1_$cp2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0j3_entry() //  [R1]
         { info_tbl: [(cc199,
                       label: sat_sc0j3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc199: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc19a; else goto cc19b;
       cc19a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc19b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableM1_$cp1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableM1_entry() //  [R2]
         { info_tbl: [(cc19d,
                       label: Data.Traversable.$fTraversableM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc19d: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cc19h; else goto cc19g;
       cc19h: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc19g: // global
           I64[Hp - 160] = sat_sc0j8_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sc0j7_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sc0j6_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sc0j5_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sc0j4_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sc0j3_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 96;
           P64[Hp - 24] = Hp - 109;
           P64[Hp - 16] = Hp - 126;
           P64[Hp - 8] = Hp - 141;
           P64[Hp] = Hp - 158;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.466743991 UTC

[section ""data" . Data.Traversable.$fTraversableK1_$cmapM_closure" {
     Data.Traversable.$fTraversableK1_$cmapM_closure:
         const Data.Traversable.$fTraversableK1_$cmapM_info;
 },
 Data.Traversable.$fTraversableK1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc1a2,
                       label: Data.Traversable.$fTraversableK1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1a2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1a3; else goto cc1a4;
       cc1a3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableK1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1a4: // global
           I64[Sp - 16] = block_cc1a0_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1a0() //  [R1]
         { info_tbl: [(cc1a0,
                       label: block_cc1a0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1a0: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.472332961 UTC

[section ""data" . Data.Traversable.$fTraversableK1_$csequence_closure" {
     Data.Traversable.$fTraversableK1_$csequence_closure:
         const Data.Traversable.$fTraversableK1_$csequence_info;
 },
 Data.Traversable.$fTraversableK1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc1ao,
                       label: Data.Traversable.$fTraversableK1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1ao: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1ap; else goto cc1aq;
       cc1ap: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableK1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1aq: // global
           I64[Sp - 16] = block_cc1am_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1am() //  [R1]
         { info_tbl: [(cc1am,
                       label: block_cc1am_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1am: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.4777922 UTC

[section ""data" . $fTraversableK2_rbWTS_closure" {
     $fTraversableK2_rbWTS_closure:
         const $fTraversableK2_rbWTS_info;
 },
 $fTraversableK2_rbWTS_entry() //  [R2, R3]
         { info_tbl: [(cc1aI,
                       label: $fTraversableK2_rbWTS_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1aI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1aJ; else goto cc1aK;
       cc1aJ: // global
           R3 = R3;
           R2 = R2;
           R1 = $fTraversableK2_rbWTS_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1aK: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.481873652 UTC

[section ""data" . Data.Traversable.$fTraversableK1_closure" {
     Data.Traversable.$fTraversableK1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorK1_closure;
         const Data.Foldable.$fFoldableK1_closure;
         const Data.Traversable.$fTraversableK1_$ctraverse_closure+3;
         const $fTraversableK2_rbWTS_closure+2;
         const Data.Traversable.$fTraversableK1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableK1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.484210985 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$csequenceA_closure" {
     Data.Traversable.$fTraversableRec1_$csequenceA_closure:
         const Data.Traversable.$fTraversableRec1_$csequenceA_info;
 },
 sat_sc0jm_entry() //  [R1]
         { info_tbl: [(cc1b0,
                       label: sat_sc0jm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1b0: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cc1b1; else goto cc1b2;
       cc1b1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1b2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$csequenceA_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cc1b5,
                       label: Data.Traversable.$fTraversableRec1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1b5: // global
           _sc0jk::P64 = R4;
           _sc0jj::P64 = R3;
           _sc0ji::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc1b6; else goto cc1b7;
       cc1b7: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc1b9; else goto cc1b8;
       cc1b9: // global
           HpAlloc = 40;
           goto cc1b6;
       cc1b6: // global
           R4 = _sc0jk::P64;
           R3 = _sc0jj::P64;
           R2 = _sc0ji::P64;
           R1 = Data.Traversable.$fTraversableRec1_$csequenceA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1b8: // global
           I64[Hp - 32] = sat_sc0jm_info;
           P64[Hp - 16] = _sc0ji::P64;
           P64[Hp - 8] = _sc0jj::P64;
           P64[Hp] = _sc0jk::P64;
           I64[Sp - 16] = block_cc1b3_info;
           R2 = _sc0jj::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1b3() //  [R1]
         { info_tbl: [(cc1b3,
                       label: block_cc1b3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1b3: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.492469804 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$cmapM_closure" {
     Data.Traversable.$fTraversableRec1_$cmapM_closure:
         const Data.Traversable.$fTraversableRec1_$cmapM_info;
 },
 sat_sc0jt_entry() //  [R1]
         { info_tbl: [(cc1bM,
                       label: sat_sc0jt_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1bM: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cc1bN; else goto cc1bO;
       cc1bN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1bO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 40];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$cmapM_entry() //  [R2, R3, R4,
                                                        R5]
         { info_tbl: [(cc1bP,
                       label: Data.Traversable.$fTraversableRec1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1bP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1bR; else goto cc1bS;
       cc1bR: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$cmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1bS: // global
           I64[Sp - 32] = block_cc1bE_info;
           _sc0jn::P64 = R2;
           R2 = R3;
           P64[Sp - 24] = _sc0jn::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1bE() //  [R1]
         { info_tbl: [(cc1bE,
                       label: block_cc1bE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1bE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc1bV; else goto cc1bU;
       cc1bV: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1bU: // global
           I64[Hp - 40] = sat_sc0jt_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           I64[Sp + 16] = block_cc1bQ_info;
           R2 = R1;
           P64[Sp + 24] = Hp - 40;
           Sp = Sp + 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1bQ() //  [R1]
         { info_tbl: [(cc1bQ,
                       label: block_cc1bQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1bQ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.502604665 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_$csequence_closure" {
     Data.Traversable.$fTraversableRec1_$csequence_closure:
         const Data.Traversable.$fTraversableRec1_$csequence_info;
 },
 sat_sc0jz_entry() //  [R1]
         { info_tbl: [(cc1cF,
                       label: sat_sc0jz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1cF: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cc1cG; else goto cc1cH;
       cc1cG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1cH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 32];
           P64[Sp - 32] = GHC.Base.id_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call Data.Traversable.traverse_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_$csequence_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cc1cI,
                       label: Data.Traversable.$fTraversableRec1_$csequence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1cI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1cK; else goto cc1cL;
       cc1cK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_$csequence_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1cL: // global
           I64[Sp - 24] = block_cc1cx_info;
           _sc0ju::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _sc0ju::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1cx() //  [R1]
         { info_tbl: [(cc1cx,
                       label: block_cc1cx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1cx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc1cO; else goto cc1cN;
       cc1cO: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1cN: // global
           I64[Hp - 32] = sat_sc0jz_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc1cJ_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1cJ() //  [R1]
         { info_tbl: [(cc1cJ,
                       label: block_cc1cJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1cJ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableM2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.513173702 UTC

[section ""data" . Data.Traversable.$fTraversableRec1_closure" {
     Data.Traversable.$fTraversableRec1_closure:
         const Data.Traversable.$fTraversableRec1_info;
         const 0;
 },
 sat_sc0jG_entry() //  [R1, R2, R3]
         { info_tbl: [(cc1dv,
                       label: sat_sc0jG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1dv: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableRec1_$csequence_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0jF_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cc1dD,
                       label: sat_sc0jF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1dD: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableRec1_$cmapM_entry(R5,
                                                                R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0jE_entry() //  [R1, R2, R3]
         { info_tbl: [(cc1dL,
                       label: sat_sc0jE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1dL: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableRec1_$csequenceA_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0jD_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cc1dT,
                       label: sat_sc0jD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1dT: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableRec1_$ctraverse_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0jC_entry() //  [R1]
         { info_tbl: [(cc1e0,
                       label: sat_sc0jC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1e0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1e1; else goto cc1e2;
       cc1e1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1e2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableRec1_$cp2Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0jB_entry() //  [R1]
         { info_tbl: [(cc1e7,
                       label: sat_sc0jB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1e7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1e8; else goto cc1e9;
       cc1e8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1e9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableRec1_$cp1Traversable_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableRec1_entry() //  [R2]
         { info_tbl: [(cc1eb,
                       label: Data.Traversable.$fTraversableRec1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1eb: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cc1ef; else goto cc1ee;
       cc1ef: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableRec1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1ee: // global
           I64[Hp - 160] = sat_sc0jG_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_sc0jF_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_sc0jE_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_sc0jD_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sc0jC_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sc0jB_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 96;
           P64[Hp - 24] = Hp - 109;
           P64[Hp - 16] = Hp - 126;
           P64[Hp - 8] = Hp - 141;
           P64[Hp] = Hp - 158;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.528098179 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$csequenceA_closure" {
     Data.Traversable.$fTraversablePar1_$csequenceA_closure:
         const Data.Traversable.$fTraversablePar1_$csequenceA_info;
 },
 Data.Traversable.$fTraversablePar1_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cc1f0,
                       label: Data.Traversable.$fTraversablePar1_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1f0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1f1; else goto cc1f2;
       cc1f1: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversablePar1_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1f2: // global
           I64[Sp - 16] = block_cc1eY_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1eY() //  [R1]
         { info_tbl: [(cc1eY,
                       label: block_cc1eY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1eY: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.533929638 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$cmapM_closure" {
     Data.Traversable.$fTraversablePar1_$cmapM_closure:
         const Data.Traversable.$fTraversablePar1_$cmapM_info;
 },
 Data.Traversable.$fTraversablePar1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc1fo,
                       label: Data.Traversable.$fTraversablePar1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1fo: // global
           _sc0jM::P64 = R4;
           _sc0jL::P64 = R3;
           _sc0jK::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc1fs; else goto cc1ft;
       cc1ft: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc1fv; else goto cc1fu;
       cc1fv: // global
           HpAlloc = 32;
           goto cc1fs;
       cc1fs: // global
           R4 = _sc0jM::P64;
           R3 = _sc0jL::P64;
           R2 = _sc0jK::P64;
           R1 = Data.Traversable.$fTraversablePar1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1fu: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc0jL::P64;
           P64[Hp] = _sc0jM::P64;
           I64[Sp - 16] = block_cc1fm_info;
           R2 = _sc0jK::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1fm() //  [R1]
         { info_tbl: [(cc1fm,
                       label: block_cc1fm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1fm: // global
           I64[Sp] = block_cc1fr_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1fr() //  [R1]
         { info_tbl: [(cc1fr,
                       label: block_cc1fr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1fr: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.541602038 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_$csequence_closure" {
     Data.Traversable.$fTraversablePar1_$csequence_closure:
         const Data.Traversable.$fTraversablePar1_$csequence_info;
 },
 Data.Traversable.$fTraversablePar1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc1fY,
                       label: Data.Traversable.$fTraversablePar1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1fY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1g2; else goto cc1g3;
       cc1g2: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversablePar1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1g3: // global
           I64[Sp - 16] = block_cc1fW_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1fW() //  [R1]
         { info_tbl: [(cc1fW,
                       label: block_cc1fW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1fW: // global
           I64[Sp] = block_cc1g1_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1g1() //  [R1]
         { info_tbl: [(cc1g1,
                       label: block_cc1g1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1g1: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.548407076 UTC

[section ""data" . Data.Traversable.$fTraversablePar1_closure" {
     Data.Traversable.$fTraversablePar1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorPar1_closure;
         const Data.Foldable.$fFoldablePar1_closure;
         const Data.Traversable.$fTraversablePar1_$ctraverse_closure+3;
         const Data.Traversable.$fTraversablePar1_$csequenceA_closure+2;
         const Data.Traversable.$fTraversablePar1_$cmapM_closure+3;
         const Data.Traversable.$fTraversablePar1_$csequence_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.551243059 UTC

[section ""data" . Data.Traversable.$fTraversableV1_$cmapM_closure" {
     Data.Traversable.$fTraversableV1_$cmapM_closure:
         const Data.Traversable.$fTraversableV1_$cmapM_info;
 },
 Data.Traversable.$fTraversableV1_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc1gv,
                       label: Data.Traversable.$fTraversableV1_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1gv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1gw; else goto cc1gx;
       cc1gw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableV1_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1gx: // global
           I64[Sp - 16] = block_cc1gt_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1gt() //  [R1]
         { info_tbl: [(cc1gt,
                       label: block_cc1gt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1gt: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.556464978 UTC

[section ""data" . Data.Traversable.$fTraversableV1_$csequence_closure" {
     Data.Traversable.$fTraversableV1_$csequence_closure:
         const Data.Traversable.$fTraversableV1_$csequence_info;
 },
 Data.Traversable.$fTraversableV1_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc1gR,
                       label: Data.Traversable.$fTraversableV1_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1gR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1gS; else goto cc1gT;
       cc1gS: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableV1_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1gT: // global
           I64[Sp - 16] = block_cc1gP_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1gP() //  [R1]
         { info_tbl: [(cc1gP,
                       label: block_cc1gP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1gP: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.561984219 UTC

[section ""data" . $fTraversableV2_rbWTT_closure" {
     $fTraversableV2_rbWTT_closure:
         const $fTraversableV2_rbWTT_info;
 },
 $fTraversableV2_rbWTT_entry() //  [R2, R3]
         { info_tbl: [(cc1hb,
                       label: $fTraversableV2_rbWTT_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1hb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1hc; else goto cc1hd;
       cc1hc: // global
           R3 = R3;
           R2 = R2;
           R1 = $fTraversableV2_rbWTT_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1hd: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.566240565 UTC

[section ""data" . Data.Traversable.$fTraversableV1_closure" {
     Data.Traversable.$fTraversableV1_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Generics.$fFunctorV1_closure;
         const Data.Foldable.$fFoldableV1_closure;
         const Data.Traversable.$fTraversableV1_$ctraverse_closure+3;
         const $fTraversableV2_rbWTT_closure+2;
         const Data.Traversable.$fTraversableV1_$cmapM_closure+3;
         const Data.Traversable.$fTraversableV1_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.568373396 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$csequenceA_closure" {
     Data.Traversable.$fTraversableIdentity_$csequenceA_closure:
         const Data.Traversable.$fTraversableIdentity_$csequenceA_info;
 },
 Data.Traversable.$fTraversableIdentity_$csequenceA_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cc1hr,
                       label: Data.Traversable.$fTraversableIdentity_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1hr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1hs; else goto cc1ht;
       cc1hs: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableIdentity_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1ht: // global
           I64[Sp - 16] = block_cc1hp_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1hp() //  [R1]
         { info_tbl: [(cc1hp,
                       label: block_cc1hp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1hp: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.574531454 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$cmapM_closure" {
     Data.Traversable.$fTraversableIdentity_$cmapM_closure:
         const Data.Traversable.$fTraversableIdentity_$cmapM_info;
 },
 Data.Traversable.$fTraversableIdentity_$cmapM_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cc1hP,
                       label: Data.Traversable.$fTraversableIdentity_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1hP: // global
           _sc0k8::P64 = R4;
           _sc0k7::P64 = R3;
           _sc0k6::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc1hT; else goto cc1hU;
       cc1hU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc1hW; else goto cc1hV;
       cc1hW: // global
           HpAlloc = 32;
           goto cc1hT;
       cc1hT: // global
           R4 = _sc0k8::P64;
           R3 = _sc0k7::P64;
           R2 = _sc0k6::P64;
           R1 = Data.Traversable.$fTraversableIdentity_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1hV: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc0k7::P64;
           P64[Hp] = _sc0k8::P64;
           I64[Sp - 16] = block_cc1hN_info;
           R2 = _sc0k6::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1hN() //  [R1]
         { info_tbl: [(cc1hN,
                       label: block_cc1hN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1hN: // global
           I64[Sp] = block_cc1hS_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1hS() //  [R1]
         { info_tbl: [(cc1hS,
                       label: block_cc1hS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1hS: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.582940746 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_$csequence_closure" {
     Data.Traversable.$fTraversableIdentity_$csequence_closure:
         const Data.Traversable.$fTraversableIdentity_$csequence_info;
 },
 Data.Traversable.$fTraversableIdentity_$csequence_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cc1ip,
                       label: Data.Traversable.$fTraversableIdentity_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1ip: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1it; else goto cc1iu;
       cc1it: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableIdentity_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1iu: // global
           I64[Sp - 16] = block_cc1in_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1in() //  [R1]
         { info_tbl: [(cc1in,
                       label: block_cc1in_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1in: // global
           I64[Sp] = block_cc1is_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1is() //  [R1]
         { info_tbl: [(cc1is,
                       label: block_cc1is_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1is: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.590049611 UTC

[section ""data" . Data.Traversable.$fTraversableIdentity_closure" {
     Data.Traversable.$fTraversableIdentity_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Functor.Identity.$fFunctorIdentity_closure;
         const Data.Functor.Identity.$fFoldableIdentity_closure;
         const Data.Traversable.$fTraversableIdentity_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableIdentity_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableIdentity_$cmapM_closure+3;
         const Data.Traversable.$fTraversableIdentity_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.592820687 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$csequenceA_closure" {
     Data.Traversable.$fTraversableProduct_$csequenceA_closure:
         const Data.Traversable.$fTraversableProduct_$csequenceA_info;
 },
 Data.Traversable.$fTraversableProduct_$csequenceA_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cc1iW,
                       label: Data.Traversable.$fTraversableProduct_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1iW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1iX; else goto cc1iY;
       cc1iX: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProduct_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1iY: // global
           I64[Sp - 16] = block_cc1iU_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1iU() //  [R1]
         { info_tbl: [(cc1iU,
                       label: block_cc1iU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1iU: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.598896139 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$cmapM_closure" {
     Data.Traversable.$fTraversableProduct_$cmapM_closure:
         const Data.Traversable.$fTraversableProduct_$cmapM_info;
 },
 Data.Traversable.$fTraversableProduct_$cmapM_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cc1jk,
                       label: Data.Traversable.$fTraversableProduct_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1jk: // global
           _sc0kl::P64 = R4;
           _sc0kk::P64 = R3;
           _sc0kj::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc1jo; else goto cc1jp;
       cc1jp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc1jr; else goto cc1jq;
       cc1jr: // global
           HpAlloc = 32;
           goto cc1jo;
       cc1jo: // global
           R4 = _sc0kl::P64;
           R3 = _sc0kk::P64;
           R2 = _sc0kj::P64;
           R1 = Data.Traversable.$fTraversableProduct_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1jq: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc0kk::P64;
           P64[Hp] = _sc0kl::P64;
           I64[Sp - 16] = block_cc1ji_info;
           R2 = _sc0kj::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1ji() //  [R1]
         { info_tbl: [(cc1ji,
                       label: block_cc1ji_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1ji: // global
           I64[Sp] = block_cc1jn_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1jn() //  [R1]
         { info_tbl: [(cc1jn,
                       label: block_cc1jn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1jn: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.607390848 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_$csequence_closure" {
     Data.Traversable.$fTraversableProduct_$csequence_closure:
         const Data.Traversable.$fTraversableProduct_$csequence_info;
 },
 Data.Traversable.$fTraversableProduct_$csequence_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cc1jU,
                       label: Data.Traversable.$fTraversableProduct_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1jU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1jY; else goto cc1jZ;
       cc1jY: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableProduct_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1jZ: // global
           I64[Sp - 16] = block_cc1jS_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1jS() //  [R1]
         { info_tbl: [(cc1jS,
                       label: block_cc1jS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1jS: // global
           I64[Sp] = block_cc1jX_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1jX() //  [R1]
         { info_tbl: [(cc1jX,
                       label: block_cc1jX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1jX: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.614443806 UTC

[section ""data" . Data.Traversable.$fTraversableProduct_closure" {
     Data.Traversable.$fTraversableProduct_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Semigroup.Internal.$fFunctorProduct_closure;
         const Data.Foldable.$fFoldableProduct_closure;
         const Data.Traversable.$fTraversableProduct_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableProduct_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableProduct_$cmapM_closure+3;
         const Data.Traversable.$fTraversableProduct_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.616694115 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$csequenceA_closure" {
     Data.Traversable.$fTraversableSum_$csequenceA_closure:
         const Data.Traversable.$fTraversableSum_$csequenceA_info;
 },
 Data.Traversable.$fTraversableSum_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cc1kr,
                       label: Data.Traversable.$fTraversableSum_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1kr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1ks; else goto cc1kt;
       cc1ks: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableSum_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1kt: // global
           I64[Sp - 16] = block_cc1kp_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1kp() //  [R1]
         { info_tbl: [(cc1kp,
                       label: block_cc1kp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1kp: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.623237086 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$cmapM_closure" {
     Data.Traversable.$fTraversableSum_$cmapM_closure:
         const Data.Traversable.$fTraversableSum_$cmapM_info;
 },
 Data.Traversable.$fTraversableSum_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc1kP,
                       label: Data.Traversable.$fTraversableSum_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1kP: // global
           _sc0ky::P64 = R4;
           _sc0kx::P64 = R3;
           _sc0kw::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc1kT; else goto cc1kU;
       cc1kU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc1kW; else goto cc1kV;
       cc1kW: // global
           HpAlloc = 32;
           goto cc1kT;
       cc1kT: // global
           R4 = _sc0ky::P64;
           R3 = _sc0kx::P64;
           R2 = _sc0kw::P64;
           R1 = Data.Traversable.$fTraversableSum_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1kV: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc0kx::P64;
           P64[Hp] = _sc0ky::P64;
           I64[Sp - 16] = block_cc1kN_info;
           R2 = _sc0kw::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1kN() //  [R1]
         { info_tbl: [(cc1kN,
                       label: block_cc1kN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1kN: // global
           I64[Sp] = block_cc1kS_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1kS() //  [R1]
         { info_tbl: [(cc1kS,
                       label: block_cc1kS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1kS: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.630747284 UTC

[section ""data" . Data.Traversable.$fTraversableSum_$csequence_closure" {
     Data.Traversable.$fTraversableSum_$csequence_closure:
         const Data.Traversable.$fTraversableSum_$csequence_info;
 },
 Data.Traversable.$fTraversableSum_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc1lp,
                       label: Data.Traversable.$fTraversableSum_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1lp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1lt; else goto cc1lu;
       cc1lt: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableSum_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1lu: // global
           I64[Sp - 16] = block_cc1ln_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1ln() //  [R1]
         { info_tbl: [(cc1ln,
                       label: block_cc1ln_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1ln: // global
           I64[Sp] = block_cc1ls_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1ls() //  [R1]
         { info_tbl: [(cc1ls,
                       label: block_cc1ls_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1ls: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.638454653 UTC

[section ""data" . Data.Traversable.$fTraversableSum_closure" {
     Data.Traversable.$fTraversableSum_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Semigroup.Internal.$fFunctorSum_closure;
         const Data.Foldable.$fFoldableSum_closure;
         const Data.Traversable.$fTraversableSum_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableSum_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableSum_$cmapM_closure+3;
         const Data.Traversable.$fTraversableSum_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.640595929 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$csequenceA_closure" {
     Data.Traversable.$fTraversableDual_$csequenceA_closure:
         const Data.Traversable.$fTraversableDual_$csequenceA_info;
 },
 Data.Traversable.$fTraversableDual_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cc1lW,
                       label: Data.Traversable.$fTraversableDual_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1lW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1lX; else goto cc1lY;
       cc1lX: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableDual_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1lY: // global
           I64[Sp - 16] = block_cc1lU_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1lU() //  [R1]
         { info_tbl: [(cc1lU,
                       label: block_cc1lU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1lU: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.646580877 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$cmapM_closure" {
     Data.Traversable.$fTraversableDual_$cmapM_closure:
         const Data.Traversable.$fTraversableDual_$cmapM_info;
 },
 Data.Traversable.$fTraversableDual_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc1mk,
                       label: Data.Traversable.$fTraversableDual_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1mk: // global
           _sc0kL::P64 = R4;
           _sc0kK::P64 = R3;
           _sc0kJ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc1mo; else goto cc1mp;
       cc1mp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc1mr; else goto cc1mq;
       cc1mr: // global
           HpAlloc = 32;
           goto cc1mo;
       cc1mo: // global
           R4 = _sc0kL::P64;
           R3 = _sc0kK::P64;
           R2 = _sc0kJ::P64;
           R1 = Data.Traversable.$fTraversableDual_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1mq: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc0kK::P64;
           P64[Hp] = _sc0kL::P64;
           I64[Sp - 16] = block_cc1mi_info;
           R2 = _sc0kJ::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1mi() //  [R1]
         { info_tbl: [(cc1mi,
                       label: block_cc1mi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1mi: // global
           I64[Sp] = block_cc1mn_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1mn() //  [R1]
         { info_tbl: [(cc1mn,
                       label: block_cc1mn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1mn: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.6544341 UTC

[section ""data" . Data.Traversable.$fTraversableDual_$csequence_closure" {
     Data.Traversable.$fTraversableDual_$csequence_closure:
         const Data.Traversable.$fTraversableDual_$csequence_info;
 },
 Data.Traversable.$fTraversableDual_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc1mU,
                       label: Data.Traversable.$fTraversableDual_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1mU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1mY; else goto cc1mZ;
       cc1mY: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableDual_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1mZ: // global
           I64[Sp - 16] = block_cc1mS_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1mS() //  [R1]
         { info_tbl: [(cc1mS,
                       label: block_cc1mS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1mS: // global
           I64[Sp] = block_cc1mX_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1mX() //  [R1]
         { info_tbl: [(cc1mX,
                       label: block_cc1mX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1mX: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableDual1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.661856499 UTC

[section ""data" . Data.Traversable.$fTraversableDual_closure" {
     Data.Traversable.$fTraversableDual_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Semigroup.Internal.$fFunctorDual_closure;
         const Data.Foldable.$fFoldableDual_closure;
         const Data.Traversable.$fTraversableDual_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableDual_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableDual_$cmapM_closure+3;
         const Data.Traversable.$fTraversableDual_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.663959418 UTC

[section ""data" . Data.Traversable.$fTraversableConst_$cmapM_closure" {
     Data.Traversable.$fTraversableConst_$cmapM_closure:
         const Data.Traversable.$fTraversableConst_$cmapM_info;
 },
 Data.Traversable.$fTraversableConst_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc1nr,
                       label: Data.Traversable.$fTraversableConst_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1nr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1ns; else goto cc1nt;
       cc1ns: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableConst_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1nt: // global
           I64[Sp - 16] = block_cc1np_info;
           R2 = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1np() //  [R1]
         { info_tbl: [(cc1np,
                       label: block_cc1np_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1np: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.669615208 UTC

[section ""data" . Data.Traversable.$fTraversableConst_$csequence_closure" {
     Data.Traversable.$fTraversableConst_$csequence_closure:
         const Data.Traversable.$fTraversableConst_$csequence_info;
 },
 Data.Traversable.$fTraversableConst_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc1nN,
                       label: Data.Traversable.$fTraversableConst_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1nN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1nO; else goto cc1nP;
       cc1nO: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableConst_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1nP: // global
           I64[Sp - 16] = block_cc1nL_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1nL() //  [R1]
         { info_tbl: [(cc1nL,
                       label: block_cc1nL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1nL: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.675436112 UTC

[section ""data" . $fTraversableConst1_rbWTU_closure" {
     $fTraversableConst1_rbWTU_closure:
         const $fTraversableConst1_rbWTU_info;
 },
 $fTraversableConst1_rbWTU_entry() //  [R2, R3]
         { info_tbl: [(cc1o7,
                       label: $fTraversableConst1_rbWTU_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1o7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1o8; else goto cc1o9;
       cc1o8: // global
           R3 = R3;
           R2 = R2;
           R1 = $fTraversableConst1_rbWTU_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1o9: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.679242728 UTC

[section ""data" . Data.Traversable.$fTraversableConst_closure" {
     Data.Traversable.$fTraversableConst_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Functor.Const.$fFunctorConst_closure;
         const Data.Functor.Const.$fFoldableConst_closure;
         const Data.Traversable.$fTraversableConst_$ctraverse_closure+3;
         const $fTraversableConst1_rbWTU_closure+2;
         const Data.Traversable.$fTraversableConst_$cmapM_closure+3;
         const Data.Traversable.$fTraversableConst_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.681654931 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$csequenceA_closure" {
     Data.Traversable.$fTraversable(,)_$csequenceA_closure:
         const Data.Traversable.$fTraversable(,)_$csequenceA_info;
 },
 sat_sc0l8_entry() //  [R1, R2]
         { info_tbl: [(cc1ow,
                       label: sat_sc0l8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1ow: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc1oA; else goto cc1oz;
       cc1oA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1oz: // global
           _sc0l5::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sc0l5::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cc1oB,
                       label: Data.Traversable.$fTraversable(,)_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1oB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1oD; else goto cc1oE;
       cc1oD: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1oE: // global
           I64[Sp - 16] = block_cc1ol_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc1oM; else goto cc1om;
       uc1oM: // global
           call _cc1ol(R1) args: 0, res: 0, upd: 0;
       cc1om: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc1ol() //  [R1]
         { info_tbl: [(cc1ol,
                       label: block_cc1ol_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1ol: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc1oH; else goto cc1oG;
       cc1oH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1oG: // global
           _sc0l5::P64 = P64[R1 + 7];
           _sc0l6::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sc0l8_info;
           P64[Hp] = _sc0l5::P64;
           I64[Sp - 8] = block_cc1oC_info;
           R2 = P64[Sp + 8];
           P64[Sp] = _sc0l6::P64;
           P64[Sp + 8] = Hp - 7;
           Sp = Sp - 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1oC() //  [R1]
         { info_tbl: [(cc1oC,
                       label: block_cc1oC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1oC: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _sc0l6::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sc0l6::P64;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.692380106 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$cmapM_closure" {
     Data.Traversable.$fTraversable(,)_$cmapM_closure:
         const Data.Traversable.$fTraversable(,)_$cmapM_info;
 },
 sat_sc0lh_entry() //  [R1, R2]
         { info_tbl: [(cc1pq,
                       label: sat_sc0lh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1pq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc1pu; else goto cc1pt;
       cc1pu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1pt: // global
           _sc0ld::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sc0ld::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc1pv,
                       label: Data.Traversable.$fTraversable(,)_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1pv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1pB; else goto cc1pC;
       cc1pB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1pC: // global
           I64[Sp - 24] = block_cc1pe_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc1pL; else goto cc1pf;
       uc1pL: // global
           call _cc1pe(R1) args: 0, res: 0, upd: 0;
       cc1pf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc1pe() //  [R1]
         { info_tbl: [(cc1pe,
                       label: block_cc1pe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1pe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc1pF; else goto cc1pE;
       cc1pF: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1pE: // global
           _sc0ld::P64 = P64[R1 + 7];
           _sc0le::P64 = P64[R1 + 15];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sc0le::P64;
           I64[Hp - 8] = sat_sc0lh_info;
           P64[Hp] = _sc0ld::P64;
           I64[Sp] = block_cc1pw_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = Hp - 7;
           P64[Sp + 16] = Hp - 40;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1pw() //  [R1]
         { info_tbl: [(cc1pw,
                       label: block_cc1pw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1pw: // global
           I64[Sp] = block_cc1pA_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1pA() //  [R1]
         { info_tbl: [(cc1pA,
                       label: block_cc1pA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1pA: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.704899223 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_$csequence_closure" {
     Data.Traversable.$fTraversable(,)_$csequence_closure:
         const Data.Traversable.$fTraversable(,)_$csequence_info;
 },
 sat_sc0lq_entry() //  [R1, R2]
         { info_tbl: [(cc1qu,
                       label: sat_sc0lq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1qu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc1qy; else goto cc1qx;
       cc1qy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1qx: // global
           _sc0lm::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sc0lm::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable(,)_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc1qz,
                       label: Data.Traversable.$fTraversable(,)_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1qz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1qF; else goto cc1qG;
       cc1qF: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable(,)_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1qG: // global
           I64[Sp - 16] = block_cc1qj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc1qP; else goto cc1qk;
       uc1qP: // global
           call _cc1qj(R1) args: 0, res: 0, upd: 0;
       cc1qk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc1qj() //  [R1]
         { info_tbl: [(cc1qj,
                       label: block_cc1qj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1qj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc1qJ; else goto cc1qI;
       cc1qJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1qI: // global
           _sc0lm::P64 = P64[R1 + 7];
           _sc0ln::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sc0lq_info;
           P64[Hp] = _sc0lm::P64;
           I64[Sp - 8] = block_cc1qA_info;
           R2 = P64[Sp + 8];
           P64[Sp] = _sc0ln::P64;
           P64[Sp + 8] = Hp - 7;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1qA() //  [R1]
         { info_tbl: [(cc1qA,
                       label: block_cc1qA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1qA: // global
           I64[Sp] = block_cc1qE_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1qE() //  [R1]
         { info_tbl: [(cc1qE,
                       label: block_cc1qE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1qE: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _sc0ln::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sc0ln::P64;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.71601841 UTC

[section ""data" . Data.Traversable.$fTraversable(,)_closure" {
     Data.Traversable.$fTraversable(,)_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctor(,)_closure;
         const Data.Foldable.$fFoldable(,)_closure;
         const Data.Traversable.$fTraversable(,)_$ctraverse_closure+3;
         const Data.Traversable.$fTraversable(,)_$csequenceA_closure+2;
         const Data.Traversable.$fTraversable(,)_$cmapM_closure+3;
         const Data.Traversable.$fTraversable(,)_$csequence_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.718772998 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$csequenceA_closure" {
     Data.Traversable.$fTraversableEither_$csequenceA_closure:
         const Data.Traversable.$fTraversableEither_$csequenceA_info;
 },
 Data.Traversable.$fTraversableEither_$csequenceA_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cc1rt,
                       label: Data.Traversable.$fTraversableEither_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1rt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1ru; else goto cc1rv;
       cc1ru: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1rv: // global
           I64[Sp - 16] = block_cc1rm_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc1rH; else goto cc1rn;
       uc1rH: // global
           call _cc1rm(R1) args: 0, res: 0, upd: 0;
       cc1rn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc1rm() //  [R1]
         { info_tbl: [(cc1rm,
                       label: block_cc1rm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1rm: // global
           _sc0lr::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc1rq; else goto cc1rr;
       cc1rq: // global
           R2 = _sc0lr::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = R1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cc1rr: // global
           I64[Sp] = block_cc1rB_info;
           R2 = _sc0lr::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1rB() //  [R1]
         { info_tbl: [(cc1rB,
                       label: block_cc1rB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1rB: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.726610119 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$cmapM_closure" {
     Data.Traversable.$fTraversableEither_$cmapM_closure:
         const Data.Traversable.$fTraversableEither_$cmapM_info;
 },
 Data.Traversable.$fTraversableEither_$cmapM_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(cc1s9,
                       label: Data.Traversable.$fTraversableEither_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1s9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1sa; else goto cc1sb;
       cc1sa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1sb: // global
           I64[Sp - 24] = block_cc1s7_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1s7() //  [R1]
         { info_tbl: [(cc1s7,
                       label: block_cc1s7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1s7: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableEither_$ctraverse_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.732854699 UTC

[section ""data" . Data.Traversable.$fTraversableEither_$csequence_closure" {
     Data.Traversable.$fTraversableEither_$csequence_closure:
         const Data.Traversable.$fTraversableEither_$csequence_info;
 },
 Data.Traversable.$fTraversableEither_$csequence_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cc1sz,
                       label: Data.Traversable.$fTraversableEither_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1sz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1sA; else goto cc1sB;
       cc1sA: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableEither_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1sB: // global
           I64[Sp - 16] = block_cc1ss_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc1sX; else goto cc1st;
       uc1sX: // global
           call _cc1ss(R1) args: 0, res: 0, upd: 0;
       cc1st: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc1ss() //  [R1]
         { info_tbl: [(cc1ss,
                       label: block_cc1ss_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1ss: // global
           _sc0lC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc1sw; else goto cc1sx;
       cc1sw: // global
           I64[Sp] = block_cc1sE_info;
           R2 = _sc0lC::P64;
           P64[Sp + 8] = R1;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
       cc1sx: // global
           I64[Sp] = block_cc1sM_info;
           R2 = _sc0lC::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1sE() //  [R1]
         { info_tbl: [(cc1sE,
                       label: block_cc1sE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1sE: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 _cc1sM() //  [R1]
         { info_tbl: [(cc1sM,
                       label: block_cc1sM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1sM: // global
           I64[Sp] = block_cc1sQ_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1sQ() //  [R1]
         { info_tbl: [(cc1sQ,
                       label: block_cc1sQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1sQ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Either.Right_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.743942268 UTC

[section ""data" . Data.Traversable.$fTraversableEither_closure" {
     Data.Traversable.$fTraversableEither_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Either.$fFunctorEither_closure;
         const Data.Foldable.$fFoldableEither_closure;
         const Data.Traversable.$fTraversableEither_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableEither_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableEither_$cmapM_closure+3;
         const Data.Traversable.$fTraversableEither_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.747346848 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$csequenceA_closure" {
     Data.Traversable.$fTraversable[]_$csequenceA_closure:
         const Data.Traversable.$fTraversable[]_$csequenceA_info;
 },
 z_sc0lM_entry() //  [R1]
         { info_tbl: [(cc1tA,
                       label: z_sc0lM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1tA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1tB; else goto cc1tC;
       cc1tB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1tC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sc0lN_entry() //  [R1, R2]
         { info_tbl: [(cc1tP,
                       label: go_sc0lN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1tP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1tQ; else goto cc1tR;
       cc1tQ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1tR: // global
           I64[Sp - 32] = block_cc1tI_info;
           _sc0lN::P64 = R1;
           _sc0lL::P64 = P64[R1 + 7];
           _sc0lM::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sc0lL::P64;
           P64[Sp - 16] = _sc0lM::P64;
           P64[Sp - 8] = _sc0lN::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc1u1; else goto cc1tJ;
       uc1u1: // global
           call _cc1tI(R1) args: 0, res: 0, upd: 0;
       cc1tJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc1tI() //  [R1]
         { info_tbl: [(cc1tI,
                       label: block_cc1tI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1tI: // global
           if (R1 & 7 == 1) goto cc1tM; else goto cc1tN;
       cc1tM: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc1tN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc1tZ; else goto cc1tY;
       cc1tZ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1tY: // global
           _sc0lQ::P64 = P64[R1 + 6];
           _sc0lR::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sc0lR::P64;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 16] = _sc0lQ::P64;
           P64[Sp + 24] = Hp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$csequenceA_entry() //  [R2]
         { info_tbl: [(cc1u2,
                       label: Data.Traversable.$fTraversable[]_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1u2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc1u6; else goto cc1u5;
       cc1u6: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$csequenceA_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1u5: // global
           I64[Hp - 40] = z_sc0lM_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_sc0lN_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.758206186 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$cmapM_closure" {
     Data.Traversable.$fTraversable[]_$cmapM_closure:
         const Data.Traversable.$fTraversable[]_$cmapM_info;
 },
 $dApplicative_sc0lV_entry() //  [R1]
         { info_tbl: [(cc1uM,
                       label: $dApplicative_sc0lV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1uM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1uN; else goto cc1uO;
       cc1uN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1uO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_sc0lW_entry() //  [R1]
         { info_tbl: [(cc1uT,
                       label: z_sc0lW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1uT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1uU; else goto cc1uV;
       cc1uU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1uV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sc0lX_entry() //  [R1, R2]
         { info_tbl: [(cc1v8,
                       label: go_sc0lX_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1v8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc1v9; else goto cc1va;
       cc1v9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1va: // global
           I64[Sp - 40] = block_cc1v1_info;
           _sc0lX::P64 = R1;
           _sc0lU::P64 = P64[R1 + 7];
           _sc0lV::P64 = P64[R1 + 15];
           _sc0lW::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc0lU::P64;
           P64[Sp - 24] = _sc0lV::P64;
           P64[Sp - 16] = _sc0lW::P64;
           P64[Sp - 8] = _sc0lX::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc1vl; else goto cc1v2;
       uc1vl: // global
           call _cc1v1(R1) args: 0, res: 0, upd: 0;
       cc1v2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc1v1() //  [R1]
         { info_tbl: [(cc1v1,
                       label: block_cc1v1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1v1: // global
           if (R1 & 7 == 1) goto cc1v5; else goto cc1v6;
       cc1v5: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc1v6: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc1vi; else goto cc1vh;
       cc1vi: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1vh: // global
           _sc0m0::P64 = P64[R1 + 6];
           _sc0m1::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sc0m1::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sc0m0::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$cmapM_entry() //  [R2, R3]
         { info_tbl: [(cc1vm,
                       label: Data.Traversable.$fTraversable[]_$cmapM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1vm: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc1vq; else goto cc1vp;
       cc1vq: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$cmapM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1vp: // global
           I64[Hp - 72] = $dApplicative_sc0lV_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = z_sc0lW_info;
           _cc1uI::P64 = Hp - 72;
           P64[Hp - 32] = _cc1uI::P64;
           I64[Hp - 24] = go_sc0lX_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = _cc1uI::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.772228299 UTC

[section ""data" . Data.Traversable.$fTraversable[]_$csequence_closure" {
     Data.Traversable.$fTraversable[]_$csequence_closure:
         const Data.Traversable.$fTraversable[]_$csequence_info;
 },
 $dApplicative_sc0m5_entry() //  [R1]
         { info_tbl: [(cc1wf,
                       label: $dApplicative_sc0m5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1wf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1wg; else goto cc1wh;
       cc1wg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1wh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_sc0m6_entry() //  [R1]
         { info_tbl: [(cc1wm,
                       label: z_sc0m6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1wm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1wn; else goto cc1wo;
       cc1wn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1wo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sc0m7_entry() //  [R1, R2]
         { info_tbl: [(cc1wB,
                       label: go_sc0m7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1wB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1wC; else goto cc1wD;
       cc1wC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1wD: // global
           I64[Sp - 32] = block_cc1wu_info;
           _sc0m7::P64 = R1;
           _sc0m5::P64 = P64[R1 + 7];
           _sc0m6::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sc0m5::P64;
           P64[Sp - 16] = _sc0m6::P64;
           P64[Sp - 8] = _sc0m7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc1wN; else goto cc1wv;
       uc1wN: // global
           call _cc1wu(R1) args: 0, res: 0, upd: 0;
       cc1wv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc1wu() //  [R1]
         { info_tbl: [(cc1wu,
                       label: block_cc1wu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1wu: // global
           if (R1 & 7 == 1) goto cc1wy; else goto cc1wz;
       cc1wy: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc1wz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc1wL; else goto cc1wK;
       cc1wL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1wK: // global
           _sc0ma::P64 = P64[R1 + 6];
           _sc0mb::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sc0mb::P64;
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 16] = _sc0ma::P64;
           P64[Sp + 24] = Hp - 24;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversable[]_$csequence_entry() //  [R2]
         { info_tbl: [(cc1wO,
                       label: Data.Traversable.$fTraversable[]_$csequence_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1wO: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cc1wS; else goto cc1wR;
       cc1wS: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Traversable.$fTraversable[]_$csequence_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1wR: // global
           I64[Hp - 64] = $dApplicative_sc0m5_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = z_sc0m6_info;
           _cc1wb::P64 = Hp - 64;
           P64[Hp - 24] = _cc1wb::P64;
           I64[Hp - 16] = go_sc0m7_info;
           P64[Hp - 8] = _cc1wb::P64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.784648967 UTC

[section ""data" . Data.Traversable.$fTraversable[]_closure" {
     Data.Traversable.$fTraversable[]_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctor[]_closure;
         const Data.Foldable.$fFoldable[]_closure;
         const Data.Traversable.$fTraversable[]_$ctraverse_closure+2;
         const Data.Traversable.$fTraversable[]_$csequenceA_closure+1;
         const Data.Traversable.$fTraversable[]_$cmapM_closure+2;
         const Data.Traversable.$fTraversable[]_$csequence_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.786915031 UTC

[section ""data" . Data.Traversable.$fTraversableZipList1_closure" {
     Data.Traversable.$fTraversableZipList1_closure:
         const Data.Traversable.$fTraversableZipList1_info;
 },
 Data.Traversable.$fTraversableZipList1_entry() //  [R2]
         { info_tbl: [(cc1xB,
                       label: Data.Traversable.$fTraversableZipList1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1xB: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.791546309 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$ctraverse_closure" {
     Data.Traversable.$fTraversableZipList_$ctraverse_closure:
         const Data.Traversable.$fTraversableZipList_$ctraverse_info;
 },
 z_sc0mi_entry() //  [R1]
         { info_tbl: [(cc1xW,
                       label: z_sc0mi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1xW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1xX; else goto cc1xY;
       cc1xX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1xY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sc0mj_entry() //  [R1, R2]
         { info_tbl: [(cc1yb,
                       label: go_sc0mj_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1yb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc1yc; else goto cc1yd;
       cc1yc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1yd: // global
           I64[Sp - 40] = block_cc1y4_info;
           _sc0mj::P64 = R1;
           _sc0me::P64 = P64[R1 + 7];
           _sc0mf::P64 = P64[R1 + 15];
           _sc0mi::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc0me::P64;
           P64[Sp - 24] = _sc0mf::P64;
           P64[Sp - 16] = _sc0mi::P64;
           P64[Sp - 8] = _sc0mj::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc1yo; else goto cc1y5;
       uc1yo: // global
           call _cc1y4(R1) args: 0, res: 0, upd: 0;
       cc1y5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc1y4() //  [R1]
         { info_tbl: [(cc1y4,
                       label: block_cc1y4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1y4: // global
           if (R1 & 7 == 1) goto cc1y8; else goto cc1y9;
       cc1y8: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc1y9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc1yl; else goto cc1yk;
       cc1yl: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1yk: // global
           _sc0mm::P64 = P64[R1 + 6];
           _sc0mn::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sc0mn::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc0mm::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sc0mq_entry() //  [R1]
         { info_tbl: [(cc1yp,
                       label: sat_sc0mq_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1yp: // global
           _sc0mq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc1yq; else goto cc1yr;
       cc1yr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc1yt; else goto cc1ys;
       cc1yt: // global
           HpAlloc = 56;
           goto cc1yq;
       cc1yq: // global
           R1 = _sc0mq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1ys: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc0mq::P64;
           _sc0me::P64 = P64[_sc0mq::P64 + 16];
           _sc0mf::P64 = P64[_sc0mq::P64 + 24];
           _sc0mg::P64 = P64[_sc0mq::P64 + 32];
           I64[Hp - 48] = z_sc0mi_info;
           P64[Hp - 32] = _sc0me::P64;
           I64[Hp - 24] = go_sc0mj_info;
           P64[Hp - 16] = _sc0me::P64;
           P64[Hp - 8] = _sc0mf::P64;
           P64[Hp] = Hp - 48;
           R2 = _sc0mg::P64;
           R1 = Hp - 23;
           Sp = Sp - 16;
           call go_sc0mj_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableZipList_$ctraverse_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(cc1yw,
                       label: Data.Traversable.$fTraversableZipList_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1yw: // global
           _sc0mg::P64 = R4;
           _sc0mf::P64 = R3;
           _sc0me::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc1yx; else goto cc1yy;
       cc1yy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc1yA; else goto cc1yz;
       cc1yA: // global
           HpAlloc = 40;
           goto cc1yx;
       cc1yx: // global
           R4 = _sc0mg::P64;
           R3 = _sc0mf::P64;
           R2 = _sc0me::P64;
           R1 = Data.Traversable.$fTraversableZipList_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1yz: // global
           I64[Hp - 32] = sat_sc0mq_info;
           P64[Hp - 16] = _sc0me::P64;
           P64[Hp - 8] = _sc0mf::P64;
           P64[Hp] = _sc0mg::P64;
           I64[Sp - 16] = block_cc1yu_info;
           R2 = _sc0me::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1yu() //  [R1]
         { info_tbl: [(cc1yu,
                       label: block_cc1yu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1yu: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableZipList1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.806770304 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$csequenceA_closure" {
     Data.Traversable.$fTraversableZipList_$csequenceA_closure:
         const Data.Traversable.$fTraversableZipList_$csequenceA_info;
 },
 Data.Traversable.$fTraversableZipList_$csequenceA_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cc1zv,
                       label: Data.Traversable.$fTraversableZipList_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1zv: // global
           R4 = R3;
           R3 = GHC.Base.id_closure+1;
           R2 = R2;
           call Data.Traversable.$fTraversableZipList_$ctraverse_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.810243541 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$cmapM_closure" {
     Data.Traversable.$fTraversableZipList_$cmapM_closure:
         const Data.Traversable.$fTraversableZipList_$cmapM_info;
 },
 Data.Traversable.$fTraversableZipList_$cmapM_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(cc1zJ,
                       label: Data.Traversable.$fTraversableZipList_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1zJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1zK; else goto cc1zL;
       cc1zK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableZipList_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1zL: // global
           I64[Sp - 24] = block_cc1zH_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1zH() //  [R1]
         { info_tbl: [(cc1zH,
                       label: block_cc1zH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1zH: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableZipList_$ctraverse_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.816134999 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_$csequence_closure" {
     Data.Traversable.$fTraversableZipList_$csequence_closure:
         const Data.Traversable.$fTraversableZipList_$csequence_info;
 },
 Data.Traversable.$fTraversableZipList_$csequence_entry() //  [R2,
                                                               R3]
         { info_tbl: [(cc1A4,
                       label: Data.Traversable.$fTraversableZipList_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1A4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1A5; else goto cc1A6;
       cc1A5: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableZipList_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1A6: // global
           I64[Sp - 16] = block_cc1A2_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1A2() //  [R1]
         { info_tbl: [(cc1A2,
                       label: block_cc1A2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1A2: // global
           R4 = P64[Sp + 8];
           R3 = GHC.Base.id_closure+1;
           R2 = R1;
           Sp = Sp + 16;
           call Data.Traversable.$fTraversableZipList_$ctraverse_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.821810787 UTC

[section ""data" . Data.Traversable.$fTraversableZipList_closure" {
     Data.Traversable.$fTraversableZipList_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Control.Applicative.$fFunctorZipList_closure;
         const Control.Applicative.$fFoldableZipList_closure;
         const Data.Traversable.$fTraversableZipList_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableZipList_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableZipList_$cmapM_closure+3;
         const Data.Traversable.$fTraversableZipList_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.825563268 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$ctraverse_closure" {
     Data.Traversable.$fTraversableArray_$ctraverse_closure:
         const Data.Traversable.$fTraversableArray_$ctraverse_info;
         const 0;
 },
 n_sc0mM_entry() //  [R1]
         { info_tbl: [(cc1AF,
                       label: n_sc0mM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1AF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1AG; else goto cc1AH;
       cc1AG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1AH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc0mW_entry() //  [R1]
         { info_tbl: [(cc1AZ,
                       label: sat_sc0mW_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1AZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1B0; else goto cc1B1;
       cc1B0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1B1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _sc0mP::I64 = I64[R1 + 40];
           if (_sc0mP::I64 == I64[R1 + 32]) goto cc1AY; else goto cc1AX;
       cc1AY: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       cc1AX: // global
           R2 = _sc0mP::I64 + 1;
           R1 = P64[R1 + 24];
           Sp = Sp - 16;
           call go_sc0mO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0mS_entry() //  [R1]
         { info_tbl: [(cc1Bc,
                       label: sat_sc0mS_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Bc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1Bd; else goto cc1Be;
       cc1Bd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1Be: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = P64[P64[R1 + 16] + ((I64[R1 + 24] << 3) + 24)];
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0mT_entry() //  [R1]
         { info_tbl: [(cc1Bf,
                       label: sat_sc0mT_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Bf: // global
           _sc0mT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc1Bg; else goto cc1Bh;
       cc1Bh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc1Bj; else goto cc1Bi;
       cc1Bj: // global
           HpAlloc = 32;
           goto cc1Bg;
       cc1Bg: // global
           R1 = _sc0mT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1Bi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc0mT::P64;
           _sc0mB::P64 = P64[_sc0mT::P64 + 16];
           _sc0mK::P64 = P64[_sc0mT::P64 + 24];
           _sc0mP::I64 = I64[_sc0mT::P64 + 32];
           I64[Hp - 24] = sat_sc0mS_info;
           P64[Hp - 8] = _sc0mK::P64;
           I64[Hp] = _sc0mP::I64;
           R2 = Hp - 24;
           R1 = _sc0mB::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sc0mO_entry() //  [R1, R2]
         { info_tbl: [(cc1Bk,
                       label: go_sc0mO_info
                       rep:HeapRep 4 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Bk: // global
           _sc0mP::I64 = R2;
           _sc0mO::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc1Bl; else goto cc1Bm;
       cc1Bm: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cc1Bo; else goto cc1Bn;
       cc1Bo: // global
           HpAlloc = 88;
           goto cc1Bl;
       cc1Bl: // global
           R2 = _sc0mP::I64;
           R1 = _sc0mO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1Bn: // global
           _sc0mA::P64 = P64[_sc0mO::P64 + 7];
           _sc0mB::P64 = P64[_sc0mO::P64 + 15];
           _sc0mK::P64 = P64[_sc0mO::P64 + 23];
           _sc0mM::P64 = P64[_sc0mO::P64 + 31];
           _sc0mL::I64 = I64[_sc0mO::P64 + 39];
           I64[Hp - 80] = sat_sc0mW_info;
           P64[Hp - 64] = _sc0mM::P64;
           P64[Hp - 56] = _sc0mO::P64;
           I64[Hp - 48] = _sc0mL::I64;
           I64[Hp - 40] = _sc0mP::I64;
           I64[Hp - 32] = sat_sc0mT_info;
           P64[Hp - 16] = _sc0mB::P64;
           P64[Hp - 8] = _sc0mK::P64;
           I64[Hp] = _sc0mP::I64;
           R2 = _sc0mA::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Types.:_closure+2;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = Hp - 80;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sc0mX_entry() //  [R1]
         { info_tbl: [(cc1Bp,
                       label: sat_sc0mX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Bp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc1Bq; else goto cc1Br;
       cc1Bq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1Br: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cc1At_info;
           _sc0mA::P64 = P64[R1 + 16];
           _sc0mB::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sc0mA::P64;
           P64[Sp - 24] = _sc0mB::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc1By; else goto cc1Au;
       uc1By: // global
           call _cc1At(R1) args: 0, res: 0, upd: 0;
       cc1Au: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc1At() //  [R1]
         { info_tbl: [(cc1At,
                       label: block_cc1At_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1At: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cc1Bu; else goto cc1Bt;
       cc1Bu: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc1Bt: // global
           _sc0mK::P64 = P64[R1 + 23];
           _sc0mL::I64 = I64[R1 + 31] - 1;
           I64[Hp - 64] = n_sc0mM_info;
           _sc0mA::P64 = P64[Sp + 8];
           P64[Hp - 48] = _sc0mA::P64;
           _cc1AB::P64 = Hp - 64;
           if (%MO_S_Le_W64(0, _sc0mL::I64)) goto cc1Bw; else goto cc1Bx;
       cc1Bw: // global
           I64[Hp - 40] = go_sc0mO_info;
           P64[Hp - 32] = _sc0mA::P64;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sc0mK::P64;
           P64[Hp - 8] = _cc1AB::P64;
           I64[Hp] = _sc0mL::I64;
           R2 = 0;
           R1 = Hp - 39;
           Sp = Sp + 24;
           call go_sc0mO_entry(R2, R1) args: 24, res: 0, upd: 24;
       cc1Bx: // global
           Hp = Hp - 48;
           R1 = _cc1AB::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0mE_entry() //  [R1]
         { info_tbl: [(cc1BD,
                       label: sat_sc0mE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1BD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1BE; else goto cc1BF;
       cc1BE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1BF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Arr.bounds_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0mF_entry() //  [R1, R2]
         { info_tbl: [(cc1BL,
                       label: sat_sc0mF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1BL: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Arr.listArray_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversableArray_$ctraverse_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(cc1BQ,
                       label: Data.Traversable.$fTraversableArray_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1BQ: // global
           _sc0mC::P64 = R5;
           _sc0mB::P64 = R4;
           _sc0mA::P64 = R3;
           _sc0mz::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc1BR; else goto cc1BS;
       cc1BS: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cc1BU; else goto cc1BT;
       cc1BU: // global
           HpAlloc = 88;
           goto cc1BR;
       cc1BR: // global
           R5 = _sc0mC::P64;
           R4 = _sc0mB::P64;
           R3 = _sc0mA::P64;
           R2 = _sc0mz::P64;
           R1 = Data.Traversable.$fTraversableArray_$ctraverse_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1BT: // global
           I64[Hp - 80] = sat_sc0mX_info;
           P64[Hp - 64] = _sc0mA::P64;
           P64[Hp - 56] = _sc0mB::P64;
           P64[Hp - 48] = _sc0mC::P64;
           I64[Hp - 40] = sat_sc0mE_info;
           P64[Hp - 24] = _sc0mC::P64;
           I64[Hp - 16] = sat_sc0mF_info;
           P64[Hp - 8] = _sc0mz::P64;
           P64[Hp] = Hp - 40;
           I64[Sp - 24] = block_cc1BO_info;
           R2 = _sc0mA::P64;
           P64[Sp - 16] = Hp - 80;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1BO() //  [R1]
         { info_tbl: [(cc1BO,
                       label: block_cc1BO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1BO: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cc1Ap::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cc1Ap::P64;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.859682012 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$csequenceA_closure" {
     Data.Traversable.$fTraversableArray_$csequenceA_closure:
         const Data.Traversable.$fTraversableArray_$csequenceA_info;
         const 0;
 },
 Data.Traversable.$fTraversableArray_$csequenceA_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cc1Dg,
                       label: Data.Traversable.$fTraversableArray_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Dg: // global
           R5 = R4;
           R4 = GHC.Base.id_closure+1;
           R3 = R3;
           R2 = R2;
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.863509167 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$cmapM_closure" {
     Data.Traversable.$fTraversableArray_$cmapM_closure:
         const Data.Traversable.$fTraversableArray_$cmapM_info;
         const 0;
 },
 Data.Traversable.$fTraversableArray_$cmapM_entry() //  [R2, R3, R4,
                                                         R5]
         { info_tbl: [(cc1Du,
                       label: Data.Traversable.$fTraversableArray_$cmapM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Du: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1Dv; else goto cc1Dw;
       cc1Dv: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableArray_$cmapM_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1Dw: // global
           I64[Sp - 32] = block_cc1Ds_info;
           _sc0n0::P64 = R2;
           R2 = R3;
           P64[Sp - 24] = _sc0n0::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1Ds() //  [R1]
         { info_tbl: [(cc1Ds,
                       label: block_cc1Ds_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Ds: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.86967397 UTC

[section ""data" . Data.Traversable.$fTraversableArray_$csequence_closure" {
     Data.Traversable.$fTraversableArray_$csequence_closure:
         const Data.Traversable.$fTraversableArray_$csequence_info;
         const 0;
 },
 Data.Traversable.$fTraversableArray_$csequence_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cc1DP,
                       label: Data.Traversable.$fTraversableArray_$csequence_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1DP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1DQ; else goto cc1DR;
       cc1DQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableArray_$csequence_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1DR: // global
           I64[Sp - 24] = block_cc1DN_info;
           _sc0n5::P64 = R2;
           R2 = R3;
           P64[Sp - 16] = _sc0n5::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1DN() //  [R1]
         { info_tbl: [(cc1DN,
                       label: block_cc1DN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1DN: // global
           R5 = P64[Sp + 16];
           R4 = GHC.Base.id_closure+1;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.875759627 UTC

[section ""data" . Data.Traversable.$fTraversableArray_closure" {
     Data.Traversable.$fTraversableArray_closure:
         const Data.Traversable.$fTraversableArray_info;
         const 0;
 },
 sat_sc0nd_entry() //  [R1, R2, R3]
         { info_tbl: [(cc1Ee,
                       label: sat_sc0nd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Ee: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableArray_$csequence_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0nc_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cc1Em,
                       label: sat_sc0nc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Em: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableArray_$cmapM_entry(R5,
                                                                 R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0nb_entry() //  [R1, R2, R3]
         { info_tbl: [(cc1Eu,
                       label: sat_sc0nb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Eu: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Traversable.$fTraversableArray_$csequenceA_entry(R4,
                                                                      R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc0na_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cc1EC,
                       label: sat_sc0na_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1EC: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Traversable.$fTraversableArray_$ctraverse_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$fTraversableArray_entry() //  [R2]
         { info_tbl: [(cc1EG,
                       label: Data.Traversable.$fTraversableArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1EG: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cc1EK; else goto cc1EJ;
       cc1EK: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1EJ: // global
           I64[Hp - 112] = sat_sc0nd_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_sc0nc_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_sc0nb_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_sc0na_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = GHC.Arr.$fFunctorArray_closure;
           P64[Hp - 32] = Data.Foldable.$fFoldableArray_closure;
           P64[Hp - 24] = Hp - 61;
           P64[Hp - 16] = Hp - 78;
           P64[Hp - 8] = Hp - 93;
           P64[Hp] = Hp - 110;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.88832448 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure" {
     Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure:
         const Data.Traversable.$fTraversableNonEmpty_$ctraverse_info;
 },
 z_sc0np_entry() //  [R1]
         { info_tbl: [(cc1Fu,
                       label: z_sc0np_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Fu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1Fv; else goto cc1Fw;
       cc1Fv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1Fw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_sc0nq_entry() //  [R1, R2]
         { info_tbl: [(cc1FJ,
                       label: go_sc0nq_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1FJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc1FK; else goto cc1FL;
       cc1FK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1FL: // global
           I64[Sp - 40] = block_cc1FC_info;
           _sc0nq::P64 = R1;
           _sc0ne::P64 = P64[R1 + 7];
           _sc0nf::P64 = P64[R1 + 15];
           _sc0np::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sc0ne::P64;
           P64[Sp - 24] = _sc0nf::P64;
           P64[Sp - 16] = _sc0np::P64;
           P64[Sp - 8] = _sc0nq::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc1FW; else goto cc1FD;
       uc1FW: // global
           call _cc1FC(R1) args: 0, res: 0, upd: 0;
       cc1FD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc1FC() //  [R1]
         { info_tbl: [(cc1FC,
                       label: block_cc1FC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1FC: // global
           if (R1 & 7 == 1) goto cc1FG; else goto cc1FH;
       cc1FG: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cc1FH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc1FT; else goto cc1FS;
       cc1FT: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1FS: // global
           _sc0nt::P64 = P64[R1 + 6];
           _sc0nu::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 32];
           P64[Hp - 32] = _sc0nu::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc0nt::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_ppp_info;
           P64[Sp + 16] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 56;
           Sp = Sp + 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_sc0nx_entry() //  [R1]
         { info_tbl: [(cc1FX,
                       label: sat_sc0nx_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1FX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc1FY; else goto cc1FZ;
       cc1FY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1FZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cc1Fl_info;
           _sc0ne::P64 = P64[R1 + 16];
           _sc0nf::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sc0ne::P64;
           P64[Sp - 24] = _sc0nf::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc1G3; else goto cc1Fm;
       uc1G3: // global
           call _cc1Fl(R1) args: 0, res: 0, upd: 0;
       cc1Fm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc1Fl() //  [R1]
         { info_tbl: [(cc1Fl,
                       label: block_cc1Fl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Fl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc1G2; else goto cc1G1;
       cc1G2: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc1G1: // global
           _sc0no::P64 = P64[R1 + 15];
           I64[Hp - 48] = z_sc0np_info;
           _sc0ne::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sc0ne::P64;
           I64[Hp - 24] = go_sc0nq_info;
           P64[Hp - 16] = _sc0ne::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R2 = _sc0no::P64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call go_sc0nq_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc0nl_entry() //  [R1]
         { info_tbl: [(cc1G9,
                       label: sat_sc0nl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1G9: // global
           _sc0nl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc1Ga; else goto cc1Gb;
       cc1Gb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc1Gd; else goto cc1Gc;
       cc1Gd: // global
           HpAlloc = 24;
           goto cc1Ga;
       cc1Ga: // global
           R1 = _sc0nl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1Gc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc0nl::P64;
           _sc0nf::P64 = P64[_sc0nl::P64 + 16];
           _sc0ng::P64 = P64[_sc0nl::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sc0ng::P64;
           R2 = Hp - 16;
           R1 = _sc0nf::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(cc1Ge,
                       label: Data.Traversable.$fTraversableNonEmpty_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Ge: // global
           _sc0ng::P64 = R4;
           _sc0nf::P64 = R3;
           _sc0ne::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cc1Gf; else goto cc1Gg;
       cc1Gg: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cc1Gi; else goto cc1Gh;
       cc1Gi: // global
           HpAlloc = 72;
           goto cc1Gf;
       cc1Gf: // global
           R4 = _sc0ng::P64;
           R3 = _sc0nf::P64;
           R2 = _sc0ne::P64;
           R1 = Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1Gh: // global
           I64[Hp - 64] = sat_sc0nx_info;
           P64[Hp - 48] = _sc0ne::P64;
           P64[Hp - 40] = _sc0nf::P64;
           P64[Hp - 32] = _sc0ng::P64;
           I64[Hp - 24] = sat_sc0nl_info;
           P64[Hp - 8] = _sc0nf::P64;
           P64[Hp] = _sc0ng::P64;
           R2 = _sc0ne::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Base.:|_closure+2;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 64;
           Sp = Sp - 32;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.907052278 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$csequenceA_closure" {
     Data.Traversable.$fTraversableNonEmpty_$csequenceA_closure:
         const Data.Traversable.$fTraversableNonEmpty_$csequenceA_info;
 },
 Data.Traversable.$fTraversableNonEmpty_$csequenceA_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cc1Hl,
                       label: Data.Traversable.$fTraversableNonEmpty_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Hl: // global
           R4 = R3;
           R3 = GHC.Base.id_closure+1;
           R2 = R2;
           call Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.910595806 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$cmapM_closure" {
     Data.Traversable.$fTraversableNonEmpty_$cmapM_closure:
         const Data.Traversable.$fTraversableNonEmpty_$cmapM_info;
 },
 Data.Traversable.$fTraversableNonEmpty_$cmapM_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cc1Hz,
                       label: Data.Traversable.$fTraversableNonEmpty_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Hz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1HA; else goto cc1HB;
       cc1HA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableNonEmpty_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1HB: // global
           I64[Sp - 24] = block_cc1Hx_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1Hx() //  [R1]
         { info_tbl: [(cc1Hx,
                       label: block_cc1Hx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Hx: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.916122466 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_$csequence_closure" {
     Data.Traversable.$fTraversableNonEmpty_$csequence_closure:
         const Data.Traversable.$fTraversableNonEmpty_$csequence_info;
 },
 Data.Traversable.$fTraversableNonEmpty_$csequence_entry() //  [R2,
                                                                R3]
         { info_tbl: [(cc1HU,
                       label: Data.Traversable.$fTraversableNonEmpty_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1HU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1HV; else goto cc1HW;
       cc1HV: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableNonEmpty_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1HW: // global
           I64[Sp - 16] = block_cc1HS_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1HS() //  [R1]
         { info_tbl: [(cc1HS,
                       label: block_cc1HS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1HS: // global
           R4 = P64[Sp + 8];
           R3 = GHC.Base.id_closure+1;
           R2 = R1;
           Sp = Sp + 16;
           call Data.Traversable.$fTraversableNonEmpty_$ctraverse_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.921813652 UTC

[section ""data" . Data.Traversable.$fTraversableNonEmpty_closure" {
     Data.Traversable.$fTraversableNonEmpty_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctorNonEmpty_closure;
         const Data.Foldable.$fFoldableNonEmpty_closure;
         const Data.Traversable.$fTraversableNonEmpty_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableNonEmpty_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableNonEmpty_$cmapM_closure+3;
         const Data.Traversable.$fTraversableNonEmpty_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.924025224 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_$csequenceA_closure" {
     Data.Traversable.$fTraversableMaybe_$csequenceA_closure:
         const Data.Traversable.$fTraversableMaybe_$csequenceA_info;
 },
 Data.Traversable.$fTraversableMaybe_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cc1Im,
                       label: Data.Traversable.$fTraversableMaybe_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Im: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1In; else goto cc1Io;
       cc1In: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableMaybe_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1Io: // global
           I64[Sp - 16] = block_cc1If_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc1IA; else goto cc1Ig;
       uc1IA: // global
           call _cc1If(R1) args: 0, res: 0, upd: 0;
       cc1Ig: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc1If() //  [R1]
         { info_tbl: [(cc1If,
                       label: block_cc1If_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1If: // global
           _sc0nG::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc1Ij; else goto cc1Ik;
       cc1Ij: // global
           R2 = _sc0nG::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cc1Ik: // global
           I64[Sp] = block_cc1Iu_info;
           R2 = _sc0nG::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1Iu() //  [R1]
         { info_tbl: [(cc1Iu,
                       label: block_cc1Iu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Iu: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.931838174 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_$cmapM_closure" {
     Data.Traversable.$fTraversableMaybe_$cmapM_closure:
         const Data.Traversable.$fTraversableMaybe_$cmapM_info;
 },
 Data.Traversable.$fTraversableMaybe_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc1J4,
                       label: Data.Traversable.$fTraversableMaybe_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1J4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1J5; else goto cc1J6;
       cc1J5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableMaybe_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1J6: // global
           I64[Sp - 24] = block_cc1J2_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1J2() //  [R1]
         { info_tbl: [(cc1J2,
                       label: block_cc1J2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1J2: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.937920505 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_$csequence_closure" {
     Data.Traversable.$fTraversableMaybe_$csequence_closure:
         const Data.Traversable.$fTraversableMaybe_$csequence_info;
 },
 Data.Traversable.$fTraversableMaybe_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc1Ju,
                       label: Data.Traversable.$fTraversableMaybe_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Ju: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1Jv; else goto cc1Jw;
       cc1Jv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableMaybe_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1Jw: // global
           I64[Sp - 16] = block_cc1Jn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc1JS; else goto cc1Jo;
       uc1JS: // global
           call _cc1Jn(R1) args: 0, res: 0, upd: 0;
       cc1Jo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc1Jn() //  [R1]
         { info_tbl: [(cc1Jn,
                       label: block_cc1Jn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Jn: // global
           _sc0nP::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc1Jr; else goto cc1Js;
       cc1Jr: // global
           I64[Sp + 8] = block_cc1Jz_info;
           R2 = _sc0nP::P64;
           Sp = Sp + 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
       cc1Js: // global
           I64[Sp] = block_cc1JH_info;
           R2 = _sc0nP::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1Jz() //  [R1]
         { info_tbl: [(cc1Jz,
                       label: block_cc1Jz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Jz: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 _cc1JH() //  [R1]
         { info_tbl: [(cc1JH,
                       label: block_cc1JH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1JH: // global
           I64[Sp] = block_cc1JL_info;
           R2 = R1;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1JL() //  [R1]
         { info_tbl: [(cc1JL,
                       label: block_cc1JL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1JL: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.94914819 UTC

[section ""data" . Data.Traversable.$fTraversableMaybe_closure" {
     Data.Traversable.$fTraversableMaybe_closure:
         const Data.Traversable.C:Traversable_con_info;
         const GHC.Base.$fFunctorMaybe_closure;
         const Data.Foldable.$fFoldableMaybe_closure;
         const Data.Traversable.$fTraversableFirst_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableMaybe_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableMaybe_$cmapM_closure+3;
         const Data.Traversable.$fTraversableMaybe_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.951227842 UTC

[section ""data" . Data.Traversable.$fTraversableFirst1_closure" {
     Data.Traversable.$fTraversableFirst1_closure:
         const Data.Traversable.$fTraversableFirst1_info;
 },
 Data.Traversable.$fTraversableFirst1_entry() //  [R2]
         { info_tbl: [(cc1Kt,
                       label: Data.Traversable.$fTraversableFirst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Kt: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.955016445 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$ctraverse_closure" {
     Data.Traversable.$fTraversableLast_$ctraverse_closure:
         const Data.Traversable.$fTraversableLast_$ctraverse_info;
 },
 sat_sc0o1_entry() //  [R1]
         { info_tbl: [(cc1KK,
                       label: sat_sc0o1_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1KK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1KL; else goto cc1KM;
       cc1KL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1KM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$ctraverse_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(cc1KP,
                       label: Data.Traversable.$fTraversableLast_$ctraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1KP: // global
           _sc0nZ::P64 = R4;
           _sc0nY::P64 = R3;
           _sc0nX::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc1KQ; else goto cc1KR;
       cc1KR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc1KT; else goto cc1KS;
       cc1KT: // global
           HpAlloc = 40;
           goto cc1KQ;
       cc1KQ: // global
           R4 = _sc0nZ::P64;
           R3 = _sc0nY::P64;
           R2 = _sc0nX::P64;
           R1 = Data.Traversable.$fTraversableLast_$ctraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1KS: // global
           I64[Hp - 32] = sat_sc0o1_info;
           P64[Hp - 16] = _sc0nX::P64;
           P64[Hp - 8] = _sc0nY::P64;
           P64[Hp] = _sc0nZ::P64;
           I64[Sp - 16] = block_cc1KN_info;
           R2 = _sc0nX::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1KN() //  [R1]
         { info_tbl: [(cc1KN,
                       label: block_cc1KN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1KN: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.963970364 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$csequenceA_closure" {
     Data.Traversable.$fTraversableLast_$csequenceA_closure:
         const Data.Traversable.$fTraversableLast_$csequenceA_info;
 },
 sat_sc0o8_entry() //  [R1]
         { info_tbl: [(cc1Lu,
                       label: sat_sc0o8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Lu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc1Lv; else goto cc1Lw;
       cc1Lv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1Lw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cc1Ln_info;
           _sc0o2::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sc0o2::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc1LI; else goto cc1Lo;
       uc1LI: // global
           call _cc1Ln(R1) args: 0, res: 0, upd: 0;
       cc1Lo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc1Ln() //  [R1]
         { info_tbl: [(cc1Ln,
                       label: block_cc1Ln_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Ln: // global
           _sc0o2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc1Lr; else goto cc1Ls;
       cc1Lr: // global
           R2 = _sc0o2::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cc1Ls: // global
           I64[Sp] = block_cc1LC_info;
           R2 = _sc0o2::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc1LC() //  [R1]
         { info_tbl: [(cc1LC,
                       label: block_cc1LC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1LC: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$csequenceA_entry() //  [R2, R3]
         { info_tbl: [(cc1LL,
                       label: Data.Traversable.$fTraversableLast_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1LL: // global
           _sc0o3::P64 = R3;
           _sc0o2::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc1LM; else goto cc1LN;
       cc1LN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc1LP; else goto cc1LO;
       cc1LP: // global
           HpAlloc = 32;
           goto cc1LM;
       cc1LM: // global
           R3 = _sc0o3::P64;
           R2 = _sc0o2::P64;
           R1 = Data.Traversable.$fTraversableLast_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1LO: // global
           I64[Hp - 24] = sat_sc0o8_info;
           P64[Hp - 8] = _sc0o2::P64;
           P64[Hp] = _sc0o3::P64;
           I64[Sp - 16] = block_cc1LJ_info;
           R2 = _sc0o2::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1LJ() //  [R1]
         { info_tbl: [(cc1LJ,
                       label: block_cc1LJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1LJ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.97600112 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$cmapM_closure" {
     Data.Traversable.$fTraversableLast_$cmapM_closure:
         const Data.Traversable.$fTraversableLast_$cmapM_info;
 },
 sat_sc0oe_entry() //  [R1]
         { info_tbl: [(cc1MF,
                       label: sat_sc0oe_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1MF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1MG; else goto cc1MH;
       cc1MG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1MH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc1MI,
                       label: Data.Traversable.$fTraversableLast_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1MI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1MK; else goto cc1ML;
       cc1MK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableLast_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1ML: // global
           I64[Sp - 24] = block_cc1Mx_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1Mx() //  [R1]
         { info_tbl: [(cc1Mx,
                       label: block_cc1Mx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Mx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc1MO; else goto cc1MN;
       cc1MO: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1MN: // global
           I64[Hp - 32] = sat_sc0oe_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc1MJ_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1MJ() //  [R1]
         { info_tbl: [(cc1MJ,
                       label: block_cc1MJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1MJ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.985860267 UTC

[section ""data" . Data.Traversable.$fTraversableLast_$csequence_closure" {
     Data.Traversable.$fTraversableLast_$csequence_closure:
         const Data.Traversable.$fTraversableLast_$csequence_info;
 },
 sat_sc0om_entry() //  [R1]
         { info_tbl: [(cc1NA,
                       label: sat_sc0om_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1NA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc1NB; else goto cc1NC;
       cc1NB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1NC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cc1Nt_info;
           _sc0oh::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sc0oh::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc1NO; else goto cc1Nu;
       uc1NO: // global
           call _cc1Nt(R1) args: 0, res: 0, upd: 0;
       cc1Nu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc1Nt() //  [R1]
         { info_tbl: [(cc1Nt,
                       label: block_cc1Nt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Nt: // global
           _sc0oh::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc1Nx; else goto cc1Ny;
       cc1Nx: // global
           R2 = _sc0oh::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cc1Ny: // global
           I64[Sp] = block_cc1NI_info;
           R2 = _sc0oh::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc1NI() //  [R1]
         { info_tbl: [(cc1NI,
                       label: block_cc1NI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1NI: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableLast_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc1NP,
                       label: Data.Traversable.$fTraversableLast_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1NP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1NR; else goto cc1NS;
       cc1NR: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableLast_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1NS: // global
           I64[Sp - 16] = block_cc1Nl_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1Nl() //  [R1]
         { info_tbl: [(cc1Nl,
                       label: block_cc1Nl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Nl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc1NV; else goto cc1NU;
       cc1NV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1NU: // global
           I64[Hp - 24] = sat_sc0om_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_cc1NQ_info;
           R2 = R1;
           P64[Sp + 8] = Hp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1NQ() //  [R1]
         { info_tbl: [(cc1NQ,
                       label: block_cc1NQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1NQ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:55.999007488 UTC

[section ""data" . Data.Traversable.$fTraversableLast_closure" {
     Data.Traversable.$fTraversableLast_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Monoid.$fFunctorLast_closure;
         const Data.Foldable.$fFoldableLast_closure;
         const Data.Traversable.$fTraversableLast_$ctraverse_closure+3;
         const Data.Traversable.$fTraversableLast_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableLast_$cmapM_closure+3;
         const Data.Traversable.$fTraversableLast_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.001302241 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$ctraverse1_closure" {
     Data.Traversable.$fTraversableFirst_$ctraverse1_closure:
         const Data.Traversable.$fTraversableFirst_$ctraverse1_info;
 },
 sat_sc0or_entry() //  [R1]
         { info_tbl: [(cc1OO,
                       label: sat_sc0or_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1OO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1OP; else goto cc1OQ;
       cc1OP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1OQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$ctraverse1_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(cc1OT,
                       label: Data.Traversable.$fTraversableFirst_$ctraverse1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1OT: // global
           _sc0op::P64 = R4;
           _sc0oo::P64 = R3;
           _sc0on::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc1OU; else goto cc1OV;
       cc1OV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc1OX; else goto cc1OW;
       cc1OX: // global
           HpAlloc = 40;
           goto cc1OU;
       cc1OU: // global
           R4 = _sc0op::P64;
           R3 = _sc0oo::P64;
           R2 = _sc0on::P64;
           R1 = Data.Traversable.$fTraversableFirst_$ctraverse1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1OW: // global
           I64[Hp - 32] = sat_sc0or_info;
           P64[Hp - 16] = _sc0on::P64;
           P64[Hp - 8] = _sc0oo::P64;
           P64[Hp] = _sc0op::P64;
           I64[Sp - 16] = block_cc1OR_info;
           R2 = _sc0on::P64;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1OR() //  [R1]
         { info_tbl: [(cc1OR,
                       label: block_cc1OR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1OR: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.009424484 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$csequenceA_closure" {
     Data.Traversable.$fTraversableFirst_$csequenceA_closure:
         const Data.Traversable.$fTraversableFirst_$csequenceA_info;
 },
 sat_sc0oy_entry() //  [R1]
         { info_tbl: [(cc1Py,
                       label: sat_sc0oy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Py: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc1Pz; else goto cc1PA;
       cc1Pz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1PA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cc1Pr_info;
           _sc0os::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sc0os::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc1PM; else goto cc1Ps;
       uc1PM: // global
           call _cc1Pr(R1) args: 0, res: 0, upd: 0;
       cc1Ps: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc1Pr() //  [R1]
         { info_tbl: [(cc1Pr,
                       label: block_cc1Pr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Pr: // global
           _sc0os::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc1Pv; else goto cc1Pw;
       cc1Pv: // global
           R2 = _sc0os::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cc1Pw: // global
           I64[Sp] = block_cc1PG_info;
           R2 = _sc0os::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc1PG() //  [R1]
         { info_tbl: [(cc1PG,
                       label: block_cc1PG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1PG: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$csequenceA_entry() //  [R2,
                                                              R3]
         { info_tbl: [(cc1PP,
                       label: Data.Traversable.$fTraversableFirst_$csequenceA_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1PP: // global
           _sc0ot::P64 = R3;
           _sc0os::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cc1PQ; else goto cc1PR;
       cc1PR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc1PT; else goto cc1PS;
       cc1PT: // global
           HpAlloc = 32;
           goto cc1PQ;
       cc1PQ: // global
           R3 = _sc0ot::P64;
           R2 = _sc0os::P64;
           R1 = Data.Traversable.$fTraversableFirst_$csequenceA_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1PS: // global
           I64[Hp - 24] = sat_sc0oy_info;
           P64[Hp - 8] = _sc0os::P64;
           P64[Hp] = _sc0ot::P64;
           I64[Sp - 16] = block_cc1PN_info;
           R2 = _sc0os::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1PN() //  [R1]
         { info_tbl: [(cc1PN,
                       label: block_cc1PN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1PN: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.021332025 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$cmapM_closure" {
     Data.Traversable.$fTraversableFirst_$cmapM_closure:
         const Data.Traversable.$fTraversableFirst_$cmapM_info;
 },
 sat_sc0oE_entry() //  [R1]
         { info_tbl: [(cc1QJ,
                       label: sat_sc0oE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1QJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1QK; else goto cc1QL;
       cc1QK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1QL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 32];
           Sp = Sp - 16;
           call Data.Traversable.$fTraversableFirst_$ctraverse_entry(R4,
                                                                     R3,
                                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$cmapM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc1QM,
                       label: Data.Traversable.$fTraversableFirst_$cmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1QM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1QO; else goto cc1QP;
       cc1QO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableFirst_$cmapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1QP: // global
           I64[Sp - 24] = block_cc1QB_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1QB() //  [R1]
         { info_tbl: [(cc1QB,
                       label: block_cc1QB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1QB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc1QS; else goto cc1QR;
       cc1QS: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1QR: // global
           I64[Hp - 32] = sat_sc0oE_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc1QN_info;
           R2 = R1;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1QN() //  [R1]
         { info_tbl: [(cc1QN,
                       label: block_cc1QN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1QN: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.03121637 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_$csequence_closure" {
     Data.Traversable.$fTraversableFirst_$csequence_closure:
         const Data.Traversable.$fTraversableFirst_$csequence_info;
 },
 sat_sc0oM_entry() //  [R1]
         { info_tbl: [(cc1RE,
                       label: sat_sc0oM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1RE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc1RF; else goto cc1RG;
       cc1RF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1RG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cc1Rx_info;
           _sc0oH::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sc0oH::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc1RS; else goto cc1Ry;
       uc1RS: // global
           call _cc1Rx(R1) args: 0, res: 0, upd: 0;
       cc1Ry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc1Rx() //  [R1]
         { info_tbl: [(cc1Rx,
                       label: block_cc1Rx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Rx: // global
           _sc0oH::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc1RB; else goto cc1RC;
       cc1RB: // global
           R2 = _sc0oH::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = GHC.Base.Nothing_closure+1;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
       cc1RC: // global
           I64[Sp] = block_cc1RM_info;
           R2 = _sc0oH::P64;
           P64[Sp + 8] = P64[R1 + 6];
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc1RM() //  [R1]
         { info_tbl: [(cc1RM,
                       label: block_cc1RM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1RM: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.Just_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Traversable.$fTraversableFirst_$csequence_entry() //  [R2, R3]
         { info_tbl: [(cc1RT,
                       label: Data.Traversable.$fTraversableFirst_$csequence_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1RT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc1RV; else goto cc1RW;
       cc1RV: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$fTraversableFirst_$csequence_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1RW: // global
           I64[Sp - 16] = block_cc1Rp_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1Rp() //  [R1]
         { info_tbl: [(cc1Rp,
                       label: block_cc1Rp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Rp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc1RZ; else goto cc1RY;
       cc1RZ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc1RY: // global
           I64[Hp - 24] = sat_sc0oM_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_cc1RU_info;
           R2 = R1;
           P64[Sp + 8] = Hp - 24;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc1RU() //  [R1]
         { info_tbl: [(cc1RU,
                       label: block_cc1RU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1RU: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = Data.Traversable.$fTraversableFirst1_closure+1;
           Sp = Sp - 8;
           call GHC.Base.fmap_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.044024866 UTC

[section ""data" . Data.Traversable.$fTraversableFirst_closure" {
     Data.Traversable.$fTraversableFirst_closure:
         const Data.Traversable.C:Traversable_con_info;
         const Data.Monoid.$fFunctorFirst_closure;
         const Data.Foldable.$fFoldableFirst_closure;
         const Data.Traversable.$fTraversableFirst_$ctraverse1_closure+3;
         const Data.Traversable.$fTraversableFirst_$csequenceA_closure+2;
         const Data.Traversable.$fTraversableFirst_$cmapM_closure+3;
         const Data.Traversable.$fTraversableFirst_$csequence_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.047443145 UTC

[section ""data" . Data.Traversable.$dmtraverse_closure" {
     Data.Traversable.$dmtraverse_closure:
         const Data.Traversable.$dmtraverse_info;
 },
 f1_sc0oQ_entry() //  [R1]
         { info_tbl: [(cc1SS,
                       label: f1_sc0oQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1SS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1ST; else goto cc1SU;
       cc1ST: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1SU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.sequenceA_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 g_sc0oR_entry() //  [R1]
         { info_tbl: [(cc1T1,
                       label: g_sc0oR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1T1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1T2; else goto cc1T3;
       cc1T2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1T3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cc1SZ_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.$p1Traversable_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc1SZ() //  [R1]
         { info_tbl: [(cc1SZ,
                       label: block_cc1SZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1SZ: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Base.fmap_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc0oV_entry() //  [R1, R2]
         { info_tbl: [(cc1Td,
                       label: sat_sc0oV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Td: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc1Th; else goto cc1Tg;
       cc1Th: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1Tg: // global
           _sc0oQ::P64 = P64[R1 + 7];
           _sc0oR::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sc0oR::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sc0oQ::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.$dmtraverse_entry() //  [R2, R3, R4]
         { info_tbl: [(cc1Ti,
                       label: Data.Traversable.$dmtraverse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Ti: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cc1Tm; else goto cc1Tl;
       cc1Tm: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.$dmtraverse_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1Tl: // global
           I64[Hp - 80] = f1_sc0oQ_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = g_sc0oR_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sc0oV_info;
           P64[Hp - 8] = Hp - 80;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.059319308 UTC

[section ""data" . Data.Traversable.for_closure" {
     Data.Traversable.for_closure:
         const Data.Traversable.for_info;
 },
 f1_sc0oY_entry() //  [R1]
         { info_tbl: [(cc1U1,
                       label: f1_sc0oY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1U1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1U2; else goto cc1U3;
       cc1U2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1U3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.traverse_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc0p1_entry() //  [R1, R2, R3]
         { info_tbl: [(cc1U9,
                       label: sat_sc0p1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1U9: // global
           _sc0p0::P64 = R3;
           R3 = R2;
           R2 = _sc0p0::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.for_entry() //  [R2, R3]
         { info_tbl: [(cc1Uc,
                       label: Data.Traversable.for_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Uc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc1Ug; else goto cc1Uf;
       cc1Ug: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.for_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1Uf: // global
           I64[Hp - 40] = f1_sc0oY_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sc0p1_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.067140551 UTC

[section ""data" . Data.Traversable.forM_closure" {
     Data.Traversable.forM_closure:
         const Data.Traversable.forM_info;
 },
 f_sc0p4_entry() //  [R1]
         { info_tbl: [(cc1UH,
                       label: f_sc0p4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1UH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc1UI; else goto cc1UJ;
       cc1UI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1UJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Traversable.mapM_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc0p7_entry() //  [R1, R2, R3]
         { info_tbl: [(cc1UP,
                       label: sat_sc0p7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1UP: // global
           _sc0p6::P64 = R3;
           R3 = R2;
           R2 = _sc0p6::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.forM_entry() //  [R2, R3]
         { info_tbl: [(cc1US,
                       label: Data.Traversable.forM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1US: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc1UW; else goto cc1UV;
       cc1UW: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.forM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1UV: // global
           I64[Hp - 40] = f_sc0p4_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           I64[Hp - 8] = sat_sc0p7_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.075401403 UTC

[section ""data" . Data.Traversable.mapAccumL_closure" {
     Data.Traversable.mapAccumL_closure:
         const Data.Traversable.mapAccumL_info;
         const 0;
 },
 sat_sc0pe_entry() //  [R1, R2, R3]
         { info_tbl: [(cc1Vo,
                       label: sat_sc0pe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Vo: // global
           _sc0pd::P64 = R3;
           R3 = R2;
           R2 = _sc0pd::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.mapAccumL_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc1Vr,
                       label: Data.Traversable.mapAccumL_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Vr: // global
           _sc0pb::P64 = R5;
           _sc0pa::P64 = R4;
           _sc0p9::P64 = R3;
           _sc0p8::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cc1Vs; else goto cc1Vt;
       cc1Vt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc1Vv; else goto cc1Vu;
       cc1Vv: // global
           HpAlloc = 16;
           goto cc1Vs;
       cc1Vs: // global
           R5 = _sc0pb::P64;
           R4 = _sc0pa::P64;
           R3 = _sc0p9::P64;
           R2 = _sc0p8::P64;
           R1 = Data.Traversable.mapAccumL_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1Vu: // global
           I64[Hp - 8] = sat_sc0pe_info;
           P64[Hp] = _sc0p9::P64;
           R2 = _sc0p8::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Functor.Utils.$fApplicativeStateL_closure;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = _sc0pb::P64;
           P64[Sp - 8] = _sc0pa::P64;
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.081279766 UTC

[section ""data" . Data.Traversable.mapAccumR_closure" {
     Data.Traversable.mapAccumR_closure:
         const Data.Traversable.mapAccumR_info;
         const 0;
 },
 sat_sc0pl_entry() //  [R1, R2, R3]
         { info_tbl: [(cc1VR,
                       label: sat_sc0pl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1VR: // global
           _sc0pk::P64 = R3;
           R3 = R2;
           R2 = _sc0pk::P64;
           R1 = P64[R1 + 6];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Traversable.mapAccumR_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc1VU,
                       label: Data.Traversable.mapAccumR_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1VU: // global
           _sc0pi::P64 = R5;
           _sc0ph::P64 = R4;
           _sc0pg::P64 = R3;
           _sc0pf::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto cc1VV; else goto cc1VW;
       cc1VW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc1VY; else goto cc1VX;
       cc1VY: // global
           HpAlloc = 16;
           goto cc1VV;
       cc1VV: // global
           R5 = _sc0pi::P64;
           R4 = _sc0ph::P64;
           R3 = _sc0pg::P64;
           R2 = _sc0pf::P64;
           R1 = Data.Traversable.mapAccumR_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1VX: // global
           I64[Hp - 8] = sat_sc0pl_info;
           P64[Hp] = _sc0pg::P64;
           R2 = _sc0pf::P64;
           I64[Sp - 40] = stg_ap_pppp_info;
           P64[Sp - 32] = Data.Functor.Utils.$fApplicativeStateR_closure;
           P64[Sp - 24] = Hp - 6;
           P64[Sp - 16] = _sc0pi::P64;
           P64[Sp - 8] = _sc0ph::P64;
           Sp = Sp - 40;
           call Data.Traversable.traverse_entry(R2) args: 48, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.087401271 UTC

[section ""data" . fmapDefault1_rbWTV_closure" {
     fmapDefault1_rbWTV_closure:
         const fmapDefault1_rbWTV_info;
         const 0;
 },
 fmapDefault1_rbWTV_entry() //  [R2]
         { info_tbl: [(cc1Wf,
                       label: fmapDefault1_rbWTV_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Wf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1Wg; else goto cc1Wh;
       cc1Wg: // global
           R2 = R2;
           R1 = fmapDefault1_rbWTV_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc1Wh: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Functor.Identity.$fApplicativeIdentity_closure;
           Sp = Sp - 16;
           call Data.Traversable.traverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.091360135 UTC

[section ""data" . Data.Traversable.fmapDefault_closure" {
     Data.Traversable.fmapDefault_closure:
         const Data.Traversable.fmapDefault_info;
         const 0;
 },
 Data.Traversable.fmapDefault_entry() //  [R2]
         { info_tbl: [(cc1Wt,
                       label: Data.Traversable.fmapDefault_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Wt: // global
           R2 = R2;
           call fmapDefault1_rbWTV_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.09482509 UTC

[section ""data" . foldMapDefault1_rbWTW_closure" {
     foldMapDefault1_rbWTW_closure:
         const foldMapDefault1_rbWTW_info;
         const 0;
 },
 sat_sc0pp_entry() //  [R1]
         { info_tbl: [(cc1WI,
                       label: sat_sc0pp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1WI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc1WJ; else goto cc1WK;
       cc1WJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc1WK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Functor.Const.$fApplicativeConst_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 foldMapDefault1_rbWTW_entry() //  [R2, R3]
         { info_tbl: [(cc1WL,
                       label: foldMapDefault1_rbWTW_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1WL: // global
           _sc0po::P64 = R3;
           _sc0pn::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cc1WM; else goto cc1WN;
       cc1WN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc1WP; else goto cc1WO;
       cc1WP: // global
           HpAlloc = 24;
           goto cc1WM;
       cc1WM: // global
           R3 = _sc0po::P64;
           R2 = _sc0pn::P64;
           R1 = foldMapDefault1_rbWTW_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc1WO: // global
           I64[Hp - 16] = sat_sc0pp_info;
           P64[Hp] = _sc0po::P64;
           R2 = _sc0pn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Data.Traversable.traverse_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.100865518 UTC

[section ""data" . Data.Traversable.foldMapDefault_closure" {
     Data.Traversable.foldMapDefault_closure:
         const Data.Traversable.foldMapDefault_info;
         const 0;
 },
 Data.Traversable.foldMapDefault_entry() //  [R2, R3]
         { info_tbl: [(cc1X7,
                       label: Data.Traversable.foldMapDefault_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1X7: // global
           R3 = R3;
           R2 = R2;
           call foldMapDefault1_rbWTW_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.104496138 UTC

[section ""cstring" . Data.Traversable.$trModule4_bytes" {
     Data.Traversable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.106077131 UTC

[section ""data" . Data.Traversable.$trModule3_closure" {
     Data.Traversable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Traversable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.107776161 UTC

[section ""cstring" . Data.Traversable.$trModule2_bytes" {
     Data.Traversable.$trModule2_bytes:
         I8[] [68,97,116,97,46,84,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.109443633 UTC

[section ""data" . Data.Traversable.$trModule1_closure" {
     Data.Traversable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Traversable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.111155367 UTC

[section ""data" . Data.Traversable.$trModule_closure" {
     Data.Traversable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Traversable.$trModule3_closure+1;
         const Data.Traversable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.112886243 UTC

[section ""data" . $krep_rbWTX_closure" {
     $krep_rbWTX_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.115342004 UTC

[section ""data" . Data.Traversable.$tcTraversable1_closure" {
     Data.Traversable.$tcTraversable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep_rbWTX_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.117029566 UTC

[section ""cstring" . Data.Traversable.$tcTraversable3_bytes" {
     Data.Traversable.$tcTraversable3_bytes:
         I8[] [84,114,97,118,101,114,115,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.118712201 UTC

[section ""data" . Data.Traversable.$tcTraversable2_closure" {
     Data.Traversable.$tcTraversable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Traversable.$tcTraversable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.120408476 UTC

[section ""data" . Data.Traversable.$tcTraversable_closure" {
     Data.Traversable.$tcTraversable_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Traversable.$trModule_closure+1;
         const Data.Traversable.$tcTraversable2_closure+1;
         const Data.Traversable.$tcTraversable1_closure+4;
         const 9002450311536760373;
         const 4172295783860716183;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.122577333 UTC

[section ""data" . Data.Traversable.C:Traversable_closure" {
     Data.Traversable.C:Traversable_closure:
         const Data.Traversable.C:Traversable_info;
 },
 Data.Traversable.C:Traversable_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cc1Xt,
                       label: Data.Traversable.C:Traversable_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1Xt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc1Xx; else goto cc1Xw;
       cc1Xx: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Traversable.C:Traversable_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cc1Xw: // global
           I64[Hp - 48] = Data.Traversable.C:Traversable_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.126959546 UTC

[Data.Traversable.C:Traversable_con_entry() //  [R1]
         { info_tbl: [(cc1XF,
                       label: Data.Traversable.C:Traversable_con_info
                       rep:HeapRep 6 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,114,97,118,101,114,115,97,98,108,101,46,67,58,84,114,97,118,101,114,115,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc1XF: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.130506176 UTC

[section ""relreadonly" . Sc0Cf_srt" {
     Sc0Cf_srt:
         const Data.Foldable.$fFoldableRec1_closure;
         const Data.Traversable.$fTraversableRec1_$cp2Traversable_closure;
         const Data.Foldable.$fFoldableM1_closure;
         const Data.Traversable.$fTraversableM1_$cp2Traversable_closure;
         const Data.Foldable.$fFoldable:+:_closure;
         const Data.Traversable.$fTraversable:+:_$cp2Traversable_closure;
         const Data.Foldable.$fFoldable:*:_closure;
         const Data.Traversable.$fTraversable:*:_$cp2Traversable_closure;
         const Data.Foldable.$fFoldable:.:_closure;
         const Data.Traversable.$fTraversable:.:_$cp2Traversable_closure;
         const Data.Traversable.$fTraversable:.:_closure;
         const Data.Traversable.$fTraversable:*:_closure;
         const Data.Traversable.$fTraversable:+:_closure;
         const Data.Traversable.$fTraversableM1_closure;
         const Data.Traversable.$fTraversableRec1_closure;
         const GHC.Arr.listArray_closure;
         const Data.Traversable.$fTraversableArray_$ctraverse_closure;
         const Data.Traversable.$fTraversableArray_$cmapM_closure;
         const Data.Traversable.$fTraversableArray_$csequence_closure;
         const Data.Traversable.$fTraversableArray_$csequenceA_closure;
         const GHC.Arr.$fFunctorArray_closure;
         const Data.Foldable.$fFoldableArray_closure;
         const Data.Traversable.$fTraversableArray_closure;
         const Data.Functor.Utils.$fApplicativeStateL_closure;
         const Data.Traversable.mapAccumL_closure;
         const Data.Functor.Utils.$fApplicativeStateR_closure;
         const Data.Traversable.mapAccumR_closure;
         const Data.Functor.Identity.$fApplicativeIdentity_closure;
         const fmapDefault1_rbWTV_closure;
         const Data.Functor.Const.$fApplicativeConst_closure;
         const foldMapDefault1_rbWTW_closure;
 }]

