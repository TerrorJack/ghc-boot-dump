
==================== Pre unarise: ====================
2018-03-16 16:00:12.915383669 UTC

Data.Either.$fApplicativeEither_$cfmap
  :: forall a1 a2 b.
     (a2 -> b) -> Data.Either.Either a1 a2 -> Data.Either.Either a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5exl ds1_s5exm]
        case ds1_s5exm of {
          Data.Either.Left x_s5exo [Occ=Once] -> wild_s5exn;
          Data.Either.Right y_s5exp [Occ=Once] ->
              let {
                sat_s5exq [Occ=Once] :: b_a5e0k
                [LclId] =
                    [ds_s5exl y_s5exp] \u [] ds_s5exl y_s5exp;
              } in  Data.Either.Right [sat_s5exq];
        };

Data.Either.$fFunctorEither_$c<$
  :: forall a1 a2 b.
     a2 -> Data.Either.Either a1 b -> Data.Either.Either a1 a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_s5exr ds_s5exs]
        case ds_s5exs of {
          Data.Either.Left x1_s5exu [Occ=Once] -> wild_s5ext;
          Data.Either.Right _ [Occ=Dead] -> Data.Either.Right [x_s5exr];
        };

Data.Either.$fFunctorEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Functor (Data.Either.Either a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Either.$fApplicativeEither_$cfmap
                                       Data.Either.$fFunctorEither_$c<$];

lvl_r5exb :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: positive multiplier expected"#;

Data.Either.$fSemigroupEither1
  :: forall a b. Data.Either.Either a b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r5exb of sat_s5exw {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s5exw;
        };

Data.Either.$fSemigroupEither2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Either.$fSemigroupEither_$cstimes
  :: forall a b1 b2.
     GHC.Real.Integral b2 =>
     b2 -> Data.Either.Either a b1 -> Data.Either.Either a b1
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s5exx eta_s5exy eta1_s5exz]
        case
            GHC.Real.$p1Integral $dIntegral_s5exx
        of
        $dReal_s5exA [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s5exD [Occ=Once] :: b1_a5e03
                [LclId] =
                    [$dReal_s5exA] \u []
                        case GHC.Real.$p1Real $dReal_s5exA of sat_s5exC {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s5exC Data.Either.$fSemigroupEither2;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s5exA of sat_s5exB {
                  __DEFAULT ->
                      case GHC.Classes.<= sat_s5exB eta_s5exy sat_s5exD of {
                        GHC.Types.False -> eta1_s5exz;
                        GHC.Types.True -> Data.Either.$fSemigroupEither1;
                      };
                };
        };

Data.Either.$fSemigroupEither_$c<>
  :: forall a b.
     Data.Either.Either a b
     -> Data.Either.Either a b -> Data.Either.Either a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5exF b1_s5exG]
        case ds_s5exF of wild_s5exH {
          Data.Either.Left _ [Occ=Dead] -> b1_s5exG;
          Data.Either.Right _ [Occ=Dead] -> wild_s5exH;
        };

Data.Either.$fSemigroupEither3 [Occ=LoopBreaker]
  :: forall a b.
     Data.Either.Either a b
     -> [Data.Either.Either a b] -> Data.Either.Either a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b1_s5exK ds1_s5exL]
        case ds1_s5exL of {
          [] -> b1_s5exK;
          : c_s5exN [Occ=Once] cs_s5exO [Occ=Once] ->
              case b1_s5exK of wild_s5exP {
                Data.Either.Left _ [Occ=Dead] ->
                    Data.Either.$fSemigroupEither3 c_s5exN cs_s5exO;
                Data.Either.Right _ [Occ=Dead] -> wild_s5exP;
              };
        };

Data.Either.$fSemigroupEither_$csconcat
  :: forall a b.
     GHC.Base.NonEmpty (Data.Either.Either a b)
     -> Data.Either.Either a b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s5exS]
        case ds_s5exS of {
          GHC.Base.:| a1_s5exU [Occ=Once] as_s5exV [Occ=Once] ->
              Data.Either.$fSemigroupEither3 a1_s5exU as_s5exV;
        };

Data.Either.$fSemigroupEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. GHC.Base.Semigroup (Data.Either.Either a b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Either.$fSemigroupEither_$c<>
                                         Data.Either.$fSemigroupEither_$csconcat
                                         Data.Either.$fSemigroupEither_$cstimes];

Data.Either.$fApplicativeEither_$c<*>
  :: forall e a b.
     Data.Either.Either e (a -> b)
     -> Data.Either.Either e a -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5exW ds1_s5exX]
        case ds_s5exW of {
          Data.Either.Left e1_s5exZ [Occ=Once] -> wild_s5exY;
          Data.Either.Right f_s5ey0 [Occ=Once] ->
              Data.Either.$fApplicativeEither_$cfmap f_s5ey0 ds1_s5exX;
        };

Data.Either.$fApplicativeEither_$cliftA2
  :: forall e a b c.
     (a -> b -> c)
     -> Data.Either.Either e a
     -> Data.Either.Either e b
     -> Data.Either.Either e c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f1_s5ey1 x_s5ey2]
        let {
          ds_s5ey3 [Occ=OnceL!]
            :: Data.Either.Either e_a5dYS (b_a5dZl -> c_a5dZm)
          [LclId] =
              [f1_s5ey1 x_s5ey2] \u []
                  case x_s5ey2 of {
                    Data.Either.Left x1_s5ey5 [Occ=Once] -> wild_s5ey4;
                    Data.Either.Right y_s5ey6 [Occ=Once] ->
                        let {
                          sat_s5ey7 [Occ=Once] :: b_a5dZl -> c_a5dZm
                          [LclId] =
                              [f1_s5ey1 y_s5ey6] \u [] f1_s5ey1 y_s5ey6;
                        } in  Data.Either.Right [sat_s5ey7];
                  }; } in
        let {
          sat_s5eyc [Occ=OnceT[0]]
            :: Data.Either.Either e_a5dYS b_a5dZl
               -> Data.Either.Either e_a5dYS c_a5dZm
          [LclId] =
              [ds_s5ey3] \r [ds1_s5ey8]
                  case ds_s5ey3 of {
                    Data.Either.Left e1_s5eya [Occ=Once] -> wild_s5ey9;
                    Data.Either.Right f_s5eyb [Occ=Once] ->
                        Data.Either.$fApplicativeEither_$cfmap f_s5eyb ds1_s5ey8;
                  };
        } in  sat_s5eyc;

Data.Either.$fApplicativeEither_$c*>
  :: forall e a b.
     Data.Either.Either e a
     -> Data.Either.Either e b -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s5eyd a2_s5eye]
        case a1_s5eyd of {
          Data.Either.Left x_s5eyg [Occ=Once] -> wild_s5eyf;
          Data.Either.Right _ [Occ=Dead] -> a2_s5eye;
        };

Data.Either.$fApplicativeEither_$c<*
  :: forall e a b.
     Data.Either.Either e a
     -> Data.Either.Either e b -> Data.Either.Either e a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [x_s5eyi ds_s5eyj]
        case x_s5eyi of wild_s5eyk {
          Data.Either.Left _ [Occ=Dead] -> wild_s5eyk;
          Data.Either.Right _ [Occ=Dead] ->
              case ds_s5eyj of {
                Data.Either.Left x1_s5eyo [Occ=Once] -> wild1_s5eyn;
                Data.Either.Right _ [Occ=Dead] -> wild_s5eyk;
              };
        };

Data.Either.$fApplicativeEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall e. GHC.Base.Applicative (Data.Either.Either e)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Either.$fFunctorEither
                                           Data.Either.Right
                                           Data.Either.$fApplicativeEither_$c<*>
                                           Data.Either.$fApplicativeEither_$cliftA2
                                           Data.Either.$fApplicativeEither_$c*>
                                           Data.Either.$fApplicativeEither_$c<*];

Data.Either.$fMonadEither_$c>>=
  :: forall e a b.
     Data.Either.Either e a
     -> (a -> Data.Either.Either e b) -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s5eyq ds1_s5eyr]
        case ds_s5eyq of {
          Data.Either.Left l_s5eyt [Occ=Once] -> wild_s5eys;
          Data.Either.Right r_s5eyu [Occ=Once] -> ds1_s5eyr r_s5eyu;
        };

Data.Either.$fMonadEither_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall e a b.
     Data.Either.Either e a
     -> Data.Either.Either e b -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Either.$fApplicativeEither_$c*> eta_B2 eta_B1;

lvl1_r5exc
  :: forall e a. [GHC.Types.Char] -> Data.Either.Either e a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s5eyv] GHC.Err.errorWithoutStackTrace eta_s5eyv;

Data.Either.$fMonadEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall e. GHC.Base.Monad (Data.Either.Either e)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Either.$fApplicativeEither
                                     Data.Either.$fMonadEither_$c>>=
                                     Data.Either.$fMonadEither_$c>>
                                     Data.Either.Right
                                     lvl1_r5exc];

Data.Either.$fShowEither5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Left "#;

Data.Either.$fShowEither4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fShowEither5;

Data.Either.$fReadEither4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Either.$fShowEither3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Right "#;

Data.Either.$fShowEither2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fShowEither3;

Data.Either.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Prim.Int# -> Data.Either.Either a b -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s5eyw w1_s5eyx ww_s5eyy w2_s5eyz]
        case w2_s5eyz of {
          Data.Either.Left b1_s5eyB [Occ=Once] ->
              let {
                g_s5eyC [Occ=OnceL*!, Dmd=<L,C(U)>]
                  :: GHC.Base.String -> GHC.Base.String
                [LclId] =
                    [w_s5eyw b1_s5eyB] \u []
                        GHC.Show.showsPrec w_s5eyw Data.Either.$fReadEither4 b1_s5eyB;
              } in 
                case >=# [ww_s5eyy 11#] of {
                  __DEFAULT ->
                      let {
                        sat_s5eyG [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5eyC] \r [x_s5eyE]
                                let {
                                  sat_s5eyF [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5eyC x_s5eyE] \s [] g_s5eyC x_s5eyE;
                                } in  GHC.Base.++ Data.Either.$fShowEither4 sat_s5eyF;
                      } in  sat_s5eyG;
                  1# ->
                      let {
                        sat_s5eyL [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5eyC] \r [x_s5eyH]
                                let {
                                  sat_s5eyK [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5eyC x_s5eyH] \u []
                                          let {
                                            sat_s5eyJ [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                            [LclId] =
                                                [g_s5eyC x_s5eyH] \s []
                                                    let {
                                                      sat_s5eyI [Occ=Once] :: GHC.Base.String
                                                      [LclId] =
                                                          CCCS :! [GHC.Show.$fShow(,)2 x_s5eyH];
                                                    } in  g_s5eyC sat_s5eyI;
                                          } in  GHC.Base.++ Data.Either.$fShowEither4 sat_s5eyJ;
                                } in  : [GHC.Show.$fShow(,)4 sat_s5eyK];
                      } in  sat_s5eyL;
                };
          Data.Either.Right b1_s5eyM [Occ=Once] ->
              let {
                g_s5eyN [Occ=OnceL*!, Dmd=<L,C(U)>]
                  :: GHC.Base.String -> GHC.Base.String
                [LclId] =
                    [w1_s5eyx b1_s5eyM] \u []
                        GHC.Show.showsPrec w1_s5eyx Data.Either.$fReadEither4 b1_s5eyM;
              } in 
                case >=# [ww_s5eyy 11#] of {
                  __DEFAULT ->
                      let {
                        sat_s5eyR [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5eyN] \r [x_s5eyP]
                                let {
                                  sat_s5eyQ [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5eyN x_s5eyP] \s [] g_s5eyN x_s5eyP;
                                } in  GHC.Base.++ Data.Either.$fShowEither2 sat_s5eyQ;
                      } in  sat_s5eyR;
                  1# ->
                      let {
                        sat_s5eyW [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5eyN] \r [x_s5eyS]
                                let {
                                  sat_s5eyV [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5eyN x_s5eyS] \u []
                                          let {
                                            sat_s5eyU [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                            [LclId] =
                                                [g_s5eyN x_s5eyS] \s []
                                                    let {
                                                      sat_s5eyT [Occ=Once] :: GHC.Base.String
                                                      [LclId] =
                                                          CCCS :! [GHC.Show.$fShow(,)2 x_s5eyS];
                                                    } in  g_s5eyN sat_s5eyT;
                                          } in  GHC.Base.++ Data.Either.$fShowEither2 sat_s5eyU;
                                } in  : [GHC.Show.$fShow(,)4 sat_s5eyV];
                      } in  sat_s5eyW;
                };
        };

Data.Either.$fShowEither_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Types.Int -> Data.Either.Either a b -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s5eyX w1_s5eyY w2_s5eyZ w3_s5ez0]
        case w2_s5eyZ of {
          GHC.Types.I# ww1_s5ez2 [Occ=Once] ->
              Data.Either.$w$cshowsPrec w_s5eyX w1_s5eyY ww1_s5ez2 w3_s5ez0;
        };

Data.Either.$fShowEither_$cshow
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     Data.Either.Either a b -> GHC.Base.String
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s5ez3 $dShow1_s5ez4 x_s5ez5]
        case x_s5ez5 of {
          Data.Either.Left b1_s5ez7 [Occ=Once] ->
              let {
                sat_s5ez8 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow_s5ez3 b1_s5ez7] \s []
                        GHC.Show.showsPrec
                            $dShow_s5ez3 Data.Either.$fReadEither4 b1_s5ez7 GHC.Types.[];
              } in  GHC.Base.++ Data.Either.$fShowEither4 sat_s5ez8;
          Data.Either.Right b1_s5ez9 [Occ=Once] ->
              let {
                sat_s5eza [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow1_s5ez4 b1_s5ez9] \s []
                        GHC.Show.showsPrec
                            $dShow1_s5ez4 Data.Either.$fReadEither4 b1_s5ez9 GHC.Types.[];
              } in  GHC.Base.++ Data.Either.$fShowEither2 sat_s5eza;
        };

Data.Either.$fShowEither1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Either.$fShowEither_$cshowList
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     [Data.Either.Either a b] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s5ezb $dShow1_s5ezc ls_s5ezd s_s5eze]
        let {
          sat_s5ezg [Occ=Once]
            :: Data.Either.Either a_a5dXF b_a5dXG -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s5ezb $dShow1_s5ezc] \r [w_s5ezf]
                  Data.Either.$w$cshowsPrec $dShow_s5ezb $dShow1_s5ezc 0# w_s5ezf;
        } in  GHC.Show.showList__ sat_s5ezg ls_s5ezd s_s5eze;

Data.Either.$fShowEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Show.Show (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s5ezh $dShow1_s5ezi]
        let {
          sat_s5ezl [Occ=Once]
            :: [Data.Either.Either a_a5dXF b_a5dXG] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s5ezh $dShow1_s5ezi] \r [eta_B2 eta_B1]
                  Data.Either.$fShowEither_$cshowList
                      $dShow_s5ezh $dShow1_s5ezi eta_B2 eta_B1; } in
        let {
          sat_s5ezk [Occ=Once]
            :: Data.Either.Either a_a5dXF b_a5dXG -> GHC.Base.String
          [LclId] =
              [$dShow_s5ezh $dShow1_s5ezi] \r [eta_B1]
                  Data.Either.$fShowEither_$cshow
                      $dShow_s5ezh $dShow1_s5ezi eta_B1; } in
        let {
          sat_s5ezj [Occ=Once]
            :: GHC.Types.Int
               -> Data.Either.Either a_a5dXF b_a5dXG -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s5ezh $dShow1_s5ezi] \r [eta_B2 eta_B1]
                  Data.Either.$fShowEither_$cshowsPrec
                      $dShow_s5ezh $dShow1_s5ezi eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s5ezj sat_s5ezk sat_s5ezl];

Data.Either.$fReadEither3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Left"#;

Data.Either.$fReadEither2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fReadEither3;

Data.Either.$fReadEither_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Either.$fReadEither2];

Data.Either.$fReadEither6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Right"#;

Data.Either.$fReadEither5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fReadEither6;

Data.Either.$fReadEither_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Either.$fReadEither5];

Data.Either.$fReadEither1
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Either.Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5ezm $dRead1_s5ezn eta_s5ezo eta1_s5ezp]
        let {
          sat_s5ezM [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_a5dWE b_a5dWF)
          [LclId] =
              [$dRead_s5ezm $dRead1_s5ezn] \r [n_s5ezq eta2_s5ezr]
                  case n_s5ezq of {
                    GHC.Types.I# x_s5ezt ->
                        let {
                          karg_s5ezu [Occ=Once*] :: Text.ParserCombinators.ReadP.P b2_X3ngu
                          [LclId] =
                              [$dRead1_s5ezn eta2_s5ezr x_s5ezt] \u []
                                  case <=# [x_s5ezt 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_s5ezA [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                          [LclId] =
                                              [$dRead1_s5ezn eta2_s5ezr] \r [a1_s5ezw]
                                                  let {
                                                    sat_s5ezz [Occ=Once]
                                                      :: b_a5dWF
                                                         -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                                    [LclId] =
                                                        [eta2_s5ezr] \r [a2_s5ezx]
                                                            let {
                                                              sat_s5ezy [Occ=Once]
                                                                :: Data.Either.Either
                                                                     a_a5dWE b_a5dWF
                                                              [LclId] =
                                                                  CCCS Data.Either.Right! [a2_s5ezx];
                                                            } in  eta2_s5ezr sat_s5ezy;
                                                  } in 
                                                    GHC.Read.readPrec
                                                        $dRead1_s5ezn
                                                        Data.Either.$fReadEither4
                                                        sat_s5ezz;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Either.$fReadEither_lexeme1 sat_s5ezA
                                          of
                                          { Unit# ww1_s5ezC [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s5ezC];
                                          };
                                  };
                        } in 
                          case <=# [x_s5ezt 10#] of {
                            __DEFAULT ->
                                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                    Text.ParserCombinators.ReadP.Fail karg_s5ezu;
                            1# ->
                                let {
                                  sat_s5ezI [Occ=Once]
                                    :: () -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                  [LclId] =
                                      [$dRead_s5ezm eta2_s5ezr] \r [a1_s5ezE]
                                          let {
                                            sat_s5ezH [Occ=Once]
                                              :: a_a5dWE -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                            [LclId] =
                                                [eta2_s5ezr] \r [a2_s5ezF]
                                                    let {
                                                      sat_s5ezG [Occ=Once]
                                                        :: Data.Either.Either a_a5dWE b_a5dWF
                                                      [LclId] =
                                                          CCCS Data.Either.Left! [a2_s5ezF];
                                                    } in  eta2_s5ezr sat_s5ezG;
                                          } in 
                                            GHC.Read.readPrec
                                                $dRead_s5ezm Data.Either.$fReadEither4 sat_s5ezH;
                                } in 
                                  case
                                      Text.Read.Lex.$wexpect
                                          Data.Either.$fReadEither_lexeme sat_s5ezI
                                  of
                                  { Unit# ww1_s5ezK [Occ=Once] ->
                                        let {
                                          sat_s5ezL [Occ=Once]
                                            :: Text.ParserCombinators.ReadP.P b2_X3ngu
                                          [LclId] =
                                              CCCS Text.ParserCombinators.ReadP.Look! [ww1_s5ezK];
                                        } in 
                                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                              sat_s5ezL karg_s5ezu;
                                  };
                          };
                  };
        } in  GHC.Read.list3 sat_s5ezM eta_s5ezo eta1_s5ezp;

Data.Either.$fReadEither_$creadsPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a b)
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5ezN $dRead1_s5ezO n_s5ezP]
        let {
          sat_s5ezQ [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Either.Either a_X5dY2 b_X5dY4)
          [LclId] =
              [$dRead_s5ezN $dRead1_s5ezO n_s5ezP] \u []
                  Data.Either.$fReadEither1
                      $dRead_s5ezN
                      $dRead1_s5ezO
                      n_s5ezP
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s5ezQ;

Data.Either.$fReadEither_$creadListPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Either.Either a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5ezR $dRead1_s5ezS]
        let {
          sat_s5ezT [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_X5dY0 b_X5dY2)
          [LclId] =
              [$dRead_s5ezR $dRead1_s5ezS] \r [eta_B2 eta_B1]
                  Data.Either.$fReadEither1 $dRead_s5ezR $dRead1_s5ezS eta_B2 eta_B1;
        } in  GHC.Read.list sat_s5ezT;

Data.Either.$fReadEither_$creadList
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadP.ReadS [Data.Either.Either a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5ezU $dRead1_s5ezV]
        let {
          sat_s5ezX [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Either.Either a_X5dY1 b_X5dY3]
          [LclId] =
              [$dRead_s5ezU $dRead1_s5ezV] \u []
                  let {
                    sat_s5ezW [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Either.Either a_X5dY1 b_X5dY3)
                    [LclId] =
                        [$dRead_s5ezU $dRead1_s5ezV] \r [eta_B2 eta_B1]
                            Data.Either.$fReadEither1 $dRead_s5ezU $dRead1_s5ezV eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s5ezW
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s5ezX;

Data.Either.$fReadEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Read.Read (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_s5ezY $dRead1_s5ezZ]
        let {
          sat_s5eA3 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Either.Either a_X5dXZ b_X5dY1]
          [LclId] =
              [$dRead_s5ezY $dRead1_s5ezZ] \u []
                  Data.Either.$fReadEither_$creadListPrec
                      $dRead_s5ezY $dRead1_s5ezZ; } in
        let {
          sat_s5eA2 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_X5dXZ b_X5dY1)
          [LclId] =
              [$dRead_s5ezY $dRead1_s5ezZ] \r [eta_B2 eta_B1]
                  Data.Either.$fReadEither1
                      $dRead_s5ezY $dRead1_s5ezZ eta_B2 eta_B1; } in
        let {
          sat_s5eA1 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Either.Either a_X5dXZ b_X5dY1]
          [LclId] =
              [$dRead_s5ezY $dRead1_s5ezZ] \u []
                  Data.Either.$fReadEither_$creadList
                      $dRead_s5ezY $dRead1_s5ezZ; } in
        let {
          sat_s5eA0 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Either.Either a_X5dXZ b_X5dY1)
          [LclId] =
              [$dRead_s5ezY $dRead1_s5ezZ] \r [eta_B1]
                  Data.Either.$fReadEither_$creadsPrec
                      $dRead_s5ezY $dRead1_s5ezZ eta_B1;
        } in  GHC.Read.C:Read [sat_s5eA0 sat_s5eA1 sat_s5eA2 sat_s5eA3];

Data.Either.$fOrdEither_$c<
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eA4 $dOrd1_s5eA5 a1_s5eA6 b1_s5eA7]
        case a1_s5eA6 of {
          Data.Either.Left a2_s5eA9 [Occ=Once] ->
              case b1_s5eA7 of {
                Data.Either.Left b2_s5eAb [Occ=Once] ->
                    GHC.Classes.< $dOrd_s5eA4 a2_s5eA9 b2_s5eAb;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Either.Right a2_s5eAd [Occ=Once] ->
              case b1_s5eA7 of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right b2_s5eAg [Occ=Once] ->
                    GHC.Classes.< $dOrd1_s5eA5 a2_s5eAd b2_s5eAg;
              };
        };

Data.Either.$fOrdEither_$ccompare
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b
     -> Data.Either.Either a b -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eAh $dOrd1_s5eAi a1_s5eAj b1_s5eAk]
        case a1_s5eAj of {
          Data.Either.Left a2_s5eAm [Occ=Once] ->
              case b1_s5eAk of {
                Data.Either.Left b2_s5eAo [Occ=Once] ->
                    GHC.Classes.compare $dOrd_s5eAh a2_s5eAm b2_s5eAo;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Either.Right a2_s5eAq [Occ=Once] ->
              case b1_s5eAk of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Either.Right b2_s5eAt [Occ=Once] ->
                    GHC.Classes.compare $dOrd1_s5eAi a2_s5eAq b2_s5eAt;
              };
        };

Data.Either.$fEqEither_$c==
  :: forall a b.
     (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s5eAu $dEq1_s5eAv ds_s5eAw ds1_s5eAx]
        case ds_s5eAw of {
          Data.Either.Left a1_s5eAz [Occ=Once] ->
              case ds1_s5eAx of {
                Data.Either.Left b1_s5eAB [Occ=Once] ->
                    GHC.Classes.== $dEq_s5eAu a1_s5eAz b1_s5eAB;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right a1_s5eAD [Occ=Once] ->
              case ds1_s5eAx of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right b1_s5eAG [Occ=Once] ->
                    GHC.Classes.== $dEq1_s5eAv a1_s5eAD b1_s5eAG;
              };
        };

Data.Either.$fEqEither_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s5eAH $dEq1_s5eAI eta_s5eAJ eta1_s5eAK]
        case eta_s5eAJ of {
          Data.Either.Left a1_s5eAM [Occ=Once] ->
              case eta1_s5eAK of {
                Data.Either.Left b1_s5eAO [Occ=Once] ->
                    case GHC.Classes.== $dEq_s5eAH a1_s5eAM b1_s5eAO of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Either.Right a1_s5eAR [Occ=Once] ->
              case eta1_s5eAK of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
                Data.Either.Right b1_s5eAU [Occ=Once] ->
                    case GHC.Classes.== $dEq1_s5eAI a1_s5eAR b1_s5eAU of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Either.$fEqEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     GHC.Classes.Eq (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s5eAW $dEq1_s5eAX]
        let {
          sat_s5eAZ [Occ=Once]
            :: Data.Either.Either a_a5dVh b_a5dVi
               -> Data.Either.Either a_a5dVh b_a5dVi -> GHC.Types.Bool
          [LclId] =
              [$dEq_s5eAW $dEq1_s5eAX] \r [eta_B2 eta_B1]
                  Data.Either.$fEqEither_$c/=
                      $dEq_s5eAW $dEq1_s5eAX eta_B2 eta_B1; } in
        let {
          sat_s5eAY [Occ=Once]
            :: Data.Either.Either a_a5dVh b_a5dVi
               -> Data.Either.Either a_a5dVh b_a5dVi -> GHC.Types.Bool
          [LclId] =
              [$dEq_s5eAW $dEq1_s5eAX] \r [eta_B2 eta_B1]
                  Data.Either.$fEqEither_$c== $dEq_s5eAW $dEq1_s5eAX eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s5eAY sat_s5eAZ];

Data.Either.$fOrdEither_$cp1Ord
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     GHC.Classes.Eq (Data.Either.Either a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eB0 $dOrd1_s5eB1]
        let {
          sat_s5eB3 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq b_a5dVB
          [LclId] =
              [$dOrd1_s5eB1] \u [] GHC.Classes.$p1Ord $dOrd1_s5eB1; } in
        let {
          sat_s5eB2 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_a5dVA
          [LclId] =
              [$dOrd_s5eB0] \u [] GHC.Classes.$p1Ord $dOrd_s5eB0;
        } in  Data.Either.$fEqEither sat_s5eB2 sat_s5eB3;

Data.Either.$fOrdEither_$c<=
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eB4 $dOrd1_s5eB5 a1_s5eB6 b1_s5eB7]
        case b1_s5eB7 of {
          Data.Either.Left a2_s5eB9 [Occ=Once] ->
              case a1_s5eB6 of {
                Data.Either.Left b2_s5eBb [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5eB4 a2_s5eB9 b2_s5eBb of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right a2_s5eBe [Occ=Once] ->
              case a1_s5eB6 of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
                Data.Either.Right b2_s5eBh [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5eB5 a2_s5eBe b2_s5eBh of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Either.$fOrdEither_$cmax
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b
     -> Data.Either.Either a b -> Data.Either.Either a b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eBj $dOrd1_s5eBk x_s5eBl y_s5eBm]
        case y_s5eBm of wild_s5eBn {
          Data.Either.Left a1_s5eBo [Occ=Once] ->
              case x_s5eBl of wild1_s5eBp {
                Data.Either.Left b1_s5eBq [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5eBj a1_s5eBo b1_s5eBq of {
                      GHC.Types.False -> wild_s5eBn;
                      GHC.Types.True -> wild1_s5eBp;
                    };
                Data.Either.Right _ [Occ=Dead] -> wild1_s5eBp;
              };
          Data.Either.Right a1_s5eBt [Occ=Once] ->
              case x_s5eBl of wild1_s5eBu {
                Data.Either.Left _ [Occ=Dead] -> wild_s5eBn;
                Data.Either.Right b1_s5eBw [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5eBk a1_s5eBt b1_s5eBw of {
                      GHC.Types.False -> wild_s5eBn;
                      GHC.Types.True -> wild1_s5eBu;
                    };
              };
        };

Data.Either.$fOrdEither_$c>=
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eBy $dOrd1_s5eBz a1_s5eBA b1_s5eBB]
        case a1_s5eBA of {
          Data.Either.Left a2_s5eBD [Occ=Once] ->
              case b1_s5eBB of {
                Data.Either.Left b2_s5eBF [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5eBy a2_s5eBD b2_s5eBF of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right a2_s5eBI [Occ=Once] ->
              case b1_s5eBB of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
                Data.Either.Right b2_s5eBL [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5eBz a2_s5eBI b2_s5eBL of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Either.$fOrdEither_$cmin
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b
     -> Data.Either.Either a b -> Data.Either.Either a b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eBN $dOrd1_s5eBO x_s5eBP y_s5eBQ]
        case y_s5eBQ of wild_s5eBR {
          Data.Either.Left a1_s5eBS [Occ=Once] ->
              case x_s5eBP of wild1_s5eBT {
                Data.Either.Left b1_s5eBU [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5eBN a1_s5eBS b1_s5eBU of {
                      GHC.Types.False -> wild1_s5eBT;
                      GHC.Types.True -> wild_s5eBR;
                    };
                Data.Either.Right _ [Occ=Dead] -> wild_s5eBR;
              };
          Data.Either.Right a1_s5eBX [Occ=Once] ->
              case x_s5eBP of wild1_s5eBY {
                Data.Either.Left _ [Occ=Dead] -> wild1_s5eBY;
                Data.Either.Right b1_s5eC0 [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5eBO a1_s5eBX b1_s5eC0 of {
                      GHC.Types.False -> wild1_s5eBY;
                      GHC.Types.True -> wild_s5eBR;
                    };
              };
        };

Data.Either.$fOrdEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     GHC.Classes.Ord (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s5eC2 $dOrd1_s5eC3]
        let {
          sat_s5eCd [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$cmin
                      $dOrd_s5eC2 $dOrd1_s5eC3 eta_B2 eta_B1; } in
        let {
          sat_s5eCc [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$cmax
                      $dOrd_s5eC2 $dOrd1_s5eC3 eta_B2 eta_B1; } in
        let {
          sat_s5eCb [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$c>=
                      $dOrd_s5eC2 $dOrd1_s5eC3 eta_B2 eta_B1; } in
        let {
          sat_s5eCa [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [a1_s5eC8 b1_s5eC9]
                  Data.Either.$fOrdEither_$c<
                      $dOrd_s5eC2 $dOrd1_s5eC3 b1_s5eC9 a1_s5eC8; } in
        let {
          sat_s5eC7 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$c<=
                      $dOrd_s5eC2 $dOrd1_s5eC3 eta_B2 eta_B1; } in
        let {
          sat_s5eC6 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$c<
                      $dOrd_s5eC2 $dOrd1_s5eC3 eta_B2 eta_B1; } in
        let {
          sat_s5eC5 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$ccompare
                      $dOrd_s5eC2 $dOrd1_s5eC3 eta_B2 eta_B1; } in
        let {
          sat_s5eC4 [Occ=Once]
            :: GHC.Classes.Eq (Data.Either.Either a_a5dVA b_a5dVB)
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \u []
                  Data.Either.$fOrdEither_$cp1Ord $dOrd_s5eC2 $dOrd1_s5eC3;
        } in 
          GHC.Classes.C:Ord [sat_s5eC4
                             sat_s5eC5
                             sat_s5eC6
                             sat_s5eC7
                             sat_s5eCa
                             sat_s5eCb
                             sat_s5eCc
                             sat_s5eCd];

Data.Either.either
  :: forall a c b.
     (a -> c) -> (b -> c) -> Data.Either.Either a b -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s5eCe ds_s5eCf ds1_s5eCg]
        case ds1_s5eCg of {
          Data.Either.Left x_s5eCi [Occ=Once] -> f_s5eCe x_s5eCi;
          Data.Either.Right y_s5eCj [Occ=Once] -> ds_s5eCf y_s5eCj;
        };

Data.Either.$wpartitionEithers [InlPrag=NOUSERINLINE[0],
                                Occ=LoopBreaker]
  :: forall a b. [Data.Either.Either a b] -> (# [a], [b] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [w_s5eCk]
        case w_s5eCk of {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : y_s5eCm [Occ=Once!] ys_s5eCn [Occ=Once] ->
              let {
                eta_s5eCo [Dmd=<L,U(1*U,1*U)>] :: ([a_s5enu], [b_s5env])
                [LclId] =
                    [ys_s5eCn] \u []
                        case Data.Either.$wpartitionEithers ys_s5eCn of {
                          (#,#) ww1_s5eCq [Occ=Once] ww2_s5eCr [Occ=Once] ->
                              (,) [ww1_s5eCq ww2_s5eCr];
                        };
              } in 
                case y_s5eCm of {
                  Data.Either.Left x_s5eCt [Occ=Once] ->
                      let {
                        sat_s5eCC [Occ=Once] :: [b_s5env]
                        [LclId] =
                            [eta_s5eCo] \u []
                                case eta_s5eCo of {
                                  (,) _ [Occ=Dead] r_s5eCB [Occ=Once] -> r_s5eCB;
                                }; } in
                      let {
                        sat_s5eCx [Occ=Once] :: [a_s5enu]
                        [LclId] =
                            [eta_s5eCo] \u []
                                case eta_s5eCo of {
                                  (,) l_s5eCv [Occ=Once] _ [Occ=Dead] -> l_s5eCv;
                                }; } in
                      let {
                        sat_s5eCy [Occ=Once] :: [a_s5enu]
                        [LclId] =
                            CCCS :! [x_s5eCt sat_s5eCx];
                      } in  (#,#) [sat_s5eCy sat_s5eCC];
                  Data.Either.Right y1_s5eCD [Occ=Once] ->
                      let {
                        sat_s5eCL [Occ=Once] :: [b_s5env]
                        [LclId] =
                            [eta_s5eCo] \u []
                                case eta_s5eCo of {
                                  (,) _ [Occ=Dead] r_s5eCK [Occ=Once] -> r_s5eCK;
                                }; } in
                      let {
                        sat_s5eCM [Occ=Once] :: [b_s5env]
                        [LclId] =
                            CCCS :! [y1_s5eCD sat_s5eCL]; } in
                      let {
                        sat_s5eCH [Occ=Once] :: [a_s5enu]
                        [LclId] =
                            [eta_s5eCo] \u []
                                case eta_s5eCo of {
                                  (,) l_s5eCF [Occ=Once] _ [Occ=Dead] -> l_s5eCF;
                                };
                      } in  (#,#) [sat_s5eCH sat_s5eCM];
                };
        };

Data.Either.partitionEithers [InlPrag=NOUSERINLINE[0]]
  :: forall a b. [Data.Either.Either a b] -> ([a], [b])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_s5eCN]
        case Data.Either.$wpartitionEithers w_s5eCN of {
          (#,#) ww1_s5eCP [Occ=Once] ww2_s5eCQ [Occ=Once] ->
              (,) [ww1_s5eCP ww2_s5eCQ];
        };

poly_go_r5exd :: forall a b. [Data.Either.Either a b] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds_s5eCR]
        case ds_s5eCR of {
          [] -> [] [];
          : y_s5eCT [Occ=Once!] ys_s5eCU [Occ=Once*] ->
              case y_s5eCT of {
                Data.Either.Left a1_s5eCW [Occ=Once] ->
                    let {
                      sat_s5eCX [Occ=Once] :: [a_a5dTY]
                      [LclId] =
                          [ys_s5eCU] \u [] poly_go_r5exd ys_s5eCU;
                    } in  : [a1_s5eCW sat_s5eCX];
                Data.Either.Right _ [Occ=Dead] -> poly_go_r5exd ys_s5eCU;
              };
        };

Data.Either.lefts [InlPrag=INLINABLE]
  :: forall a b. [Data.Either.Either a b] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s5eCZ] poly_go_r5exd x_s5eCZ;

poly_go1_r5exe :: forall a b. [Data.Either.Either a b] -> [b]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds_s5eD0]
        case ds_s5eD0 of {
          [] -> [] [];
          : y_s5eD2 [Occ=Once!] ys_s5eD3 [Occ=Once*] ->
              case y_s5eD2 of {
                Data.Either.Left _ [Occ=Dead] -> poly_go1_r5exe ys_s5eD3;
                Data.Either.Right a1_s5eD6 [Occ=Once] ->
                    let {
                      sat_s5eD7 [Occ=Once] :: [b_a5dTV]
                      [LclId] =
                          [ys_s5eD3] \u [] poly_go1_r5exe ys_s5eD3;
                    } in  : [a1_s5eD6 sat_s5eD7];
              };
        };

Data.Either.rights [InlPrag=INLINABLE]
  :: forall a b. [Data.Either.Either a b] -> [b]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s5eD8] poly_go1_r5exe x_s5eD8;

Data.Either.isLeft
  :: forall a b. Data.Either.Either a b -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5eD9]
        case ds_s5eD9 of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
          Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Either.isRight
  :: forall a b. Data.Either.Either a b -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5eDd]
        case ds_s5eDd of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
          Data.Either.Right _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Either.fromLeft
  :: forall a b. a -> Data.Either.Either a b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5eDh ds1_s5eDi]
        case ds1_s5eDi of {
          Data.Either.Left a1_s5eDk [Occ=Once] -> a1_s5eDk;
          Data.Either.Right _ [Occ=Dead] -> ds_s5eDh;
        };

Data.Either.fromRight
  :: forall b a. b -> Data.Either.Either a b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5eDm ds1_s5eDn]
        case ds1_s5eDn of {
          Data.Either.Left _ [Occ=Dead] -> ds_s5eDm;
          Data.Either.Right b1_s5eDq [Occ=Once] -> b1_s5eDq;
        };

Data.Either.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Either.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$trModule4];

Data.Either.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Either"#;

Data.Either.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$trModule2];

Data.Either.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Either.$trModule3
                                     Data.Either.$trModule1];

$krep_r5exf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_r5exg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Either.$tcEither2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Either"#;

Data.Either.$tcEither1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$tcEither2];

Data.Either.$tcEither :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16074290893719807138##
                                    14958199358864670905##
                                    Data.Either.$trModule
                                    Data.Either.$tcEither1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep2_r5exh :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r5exf GHC.Types.[]];

$krep3_r5exi :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r5exg $krep2_r5exh];

$krep4_r5exj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Either.$tcEither
                                              $krep3_r5exi];

Data.Either.$tc'Left1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r5exg $krep4_r5exj];

Data.Either.$tc'Left3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Left"#;

Data.Either.$tc'Left2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$tc'Left3];

Data.Either.$tc'Left :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14915236324383360020##
                                    11027491440201056612##
                                    Data.Either.$trModule
                                    Data.Either.$tc'Left2
                                    2#
                                    Data.Either.$tc'Left1];

Data.Either.$tc'Right1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r5exf $krep4_r5exj];

Data.Either.$tc'Right3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Right"#;

Data.Either.$tc'Right2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$tc'Right3];

Data.Either.$tc'Right :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10395468319011834275##
                                    16371021254350888909##
                                    Data.Either.$trModule
                                    Data.Either.$tc'Right2
                                    2#
                                    Data.Either.$tc'Right1];

Data.Either.Left :: forall a b. a -> Data.Either.Either a b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Either.Left [eta_B1];

Data.Either.Right :: forall a b. b -> Data.Either.Either a b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Either.Right [eta_B1];


==================== STG syntax: ====================
2018-03-16 16:00:12.941588566 UTC

Data.Either.$fApplicativeEither_$cfmap
  :: forall a1 a2 b.
     (a2 -> b) -> Data.Either.Either a1 a2 -> Data.Either.Either a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5exl ds1_s5exm]
        case ds1_s5exm of {
          Data.Either.Left x_s5exo [Occ=Once] -> wild_s5exn;
          Data.Either.Right y_s5exp [Occ=Once] ->
              let {
                sat_s5exq [Occ=Once] :: b_a5e0k
                [LclId] =
                    [ds_s5exl y_s5exp] \u [] ds_s5exl y_s5exp;
              } in  Data.Either.Right [sat_s5exq];
        };

Data.Either.$fFunctorEither_$c<$
  :: forall a1 a2 b.
     a2 -> Data.Either.Either a1 b -> Data.Either.Either a1 a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_s5exr ds_s5exs]
        case ds_s5exs of {
          Data.Either.Left x1_s5exu [Occ=Once] -> wild_s5ext;
          Data.Either.Right _ [Occ=Dead] -> Data.Either.Right [x_s5exr];
        };

Data.Either.$fFunctorEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Functor (Data.Either.Either a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Either.$fApplicativeEither_$cfmap
                                       Data.Either.$fFunctorEither_$c<$];

lvl_r5exb :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: positive multiplier expected"#;

Data.Either.$fSemigroupEither1
  :: forall a b. Data.Either.Either a b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r5exb of sat_s5exw {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s5exw;
        };

Data.Either.$fSemigroupEither2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Either.$fSemigroupEither_$cstimes
  :: forall a b1 b2.
     GHC.Real.Integral b2 =>
     b2 -> Data.Either.Either a b1 -> Data.Either.Either a b1
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s5exx eta_s5exy eta1_s5exz]
        case
            GHC.Real.$p1Integral $dIntegral_s5exx
        of
        $dReal_s5exA [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s5exD [Occ=Once] :: b1_a5e03
                [LclId] =
                    [$dReal_s5exA] \u []
                        case GHC.Real.$p1Real $dReal_s5exA of sat_s5exC {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s5exC Data.Either.$fSemigroupEither2;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s5exA of sat_s5exB {
                  __DEFAULT ->
                      case GHC.Classes.<= sat_s5exB eta_s5exy sat_s5exD of {
                        GHC.Types.False -> eta1_s5exz;
                        GHC.Types.True -> Data.Either.$fSemigroupEither1;
                      };
                };
        };

Data.Either.$fSemigroupEither_$c<>
  :: forall a b.
     Data.Either.Either a b
     -> Data.Either.Either a b -> Data.Either.Either a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5exF b1_s5exG]
        case ds_s5exF of wild_s5exH {
          Data.Either.Left _ [Occ=Dead] -> b1_s5exG;
          Data.Either.Right _ [Occ=Dead] -> wild_s5exH;
        };

Data.Either.$fSemigroupEither3 [Occ=LoopBreaker]
  :: forall a b.
     Data.Either.Either a b
     -> [Data.Either.Either a b] -> Data.Either.Either a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b1_s5exK ds1_s5exL]
        case ds1_s5exL of {
          [] -> b1_s5exK;
          : c_s5exN [Occ=Once] cs_s5exO [Occ=Once] ->
              case b1_s5exK of wild_s5exP {
                Data.Either.Left _ [Occ=Dead] ->
                    Data.Either.$fSemigroupEither3 c_s5exN cs_s5exO;
                Data.Either.Right _ [Occ=Dead] -> wild_s5exP;
              };
        };

Data.Either.$fSemigroupEither_$csconcat
  :: forall a b.
     GHC.Base.NonEmpty (Data.Either.Either a b)
     -> Data.Either.Either a b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s5exS]
        case ds_s5exS of {
          GHC.Base.:| a1_s5exU [Occ=Once] as_s5exV [Occ=Once] ->
              Data.Either.$fSemigroupEither3 a1_s5exU as_s5exV;
        };

Data.Either.$fSemigroupEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. GHC.Base.Semigroup (Data.Either.Either a b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Either.$fSemigroupEither_$c<>
                                         Data.Either.$fSemigroupEither_$csconcat
                                         Data.Either.$fSemigroupEither_$cstimes];

Data.Either.$fApplicativeEither_$c<*>
  :: forall e a b.
     Data.Either.Either e (a -> b)
     -> Data.Either.Either e a -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5exW ds1_s5exX]
        case ds_s5exW of {
          Data.Either.Left e1_s5exZ [Occ=Once] -> wild_s5exY;
          Data.Either.Right f_s5ey0 [Occ=Once] ->
              Data.Either.$fApplicativeEither_$cfmap f_s5ey0 ds1_s5exX;
        };

Data.Either.$fApplicativeEither_$cliftA2
  :: forall e a b c.
     (a -> b -> c)
     -> Data.Either.Either e a
     -> Data.Either.Either e b
     -> Data.Either.Either e c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f1_s5ey1 x_s5ey2]
        let {
          ds_s5ey3 [Occ=OnceL!]
            :: Data.Either.Either e_a5dYS (b_a5dZl -> c_a5dZm)
          [LclId] =
              [f1_s5ey1 x_s5ey2] \u []
                  case x_s5ey2 of {
                    Data.Either.Left x1_s5ey5 [Occ=Once] -> wild_s5ey4;
                    Data.Either.Right y_s5ey6 [Occ=Once] ->
                        let {
                          sat_s5ey7 [Occ=Once] :: b_a5dZl -> c_a5dZm
                          [LclId] =
                              [f1_s5ey1 y_s5ey6] \u [] f1_s5ey1 y_s5ey6;
                        } in  Data.Either.Right [sat_s5ey7];
                  }; } in
        let {
          sat_s5eyc [Occ=OnceT[0]]
            :: Data.Either.Either e_a5dYS b_a5dZl
               -> Data.Either.Either e_a5dYS c_a5dZm
          [LclId] =
              [ds_s5ey3] \r [ds1_s5ey8]
                  case ds_s5ey3 of {
                    Data.Either.Left e1_s5eya [Occ=Once] -> wild_s5ey9;
                    Data.Either.Right f_s5eyb [Occ=Once] ->
                        Data.Either.$fApplicativeEither_$cfmap f_s5eyb ds1_s5ey8;
                  };
        } in  sat_s5eyc;

Data.Either.$fApplicativeEither_$c*>
  :: forall e a b.
     Data.Either.Either e a
     -> Data.Either.Either e b -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s5eyd a2_s5eye]
        case a1_s5eyd of {
          Data.Either.Left x_s5eyg [Occ=Once] -> wild_s5eyf;
          Data.Either.Right _ [Occ=Dead] -> a2_s5eye;
        };

Data.Either.$fApplicativeEither_$c<*
  :: forall e a b.
     Data.Either.Either e a
     -> Data.Either.Either e b -> Data.Either.Either e a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [x_s5eyi ds_s5eyj]
        case x_s5eyi of wild_s5eyk {
          Data.Either.Left _ [Occ=Dead] -> wild_s5eyk;
          Data.Either.Right _ [Occ=Dead] ->
              case ds_s5eyj of {
                Data.Either.Left x1_s5eyo [Occ=Once] -> wild1_s5eyn;
                Data.Either.Right _ [Occ=Dead] -> wild_s5eyk;
              };
        };

Data.Either.$fApplicativeEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall e. GHC.Base.Applicative (Data.Either.Either e)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Either.$fFunctorEither
                                           Data.Either.Right
                                           Data.Either.$fApplicativeEither_$c<*>
                                           Data.Either.$fApplicativeEither_$cliftA2
                                           Data.Either.$fApplicativeEither_$c*>
                                           Data.Either.$fApplicativeEither_$c<*];

Data.Either.$fMonadEither_$c>>=
  :: forall e a b.
     Data.Either.Either e a
     -> (a -> Data.Either.Either e b) -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s5eyq ds1_s5eyr]
        case ds_s5eyq of {
          Data.Either.Left l_s5eyt [Occ=Once] -> wild_s5eys;
          Data.Either.Right r_s5eyu [Occ=Once] -> ds1_s5eyr r_s5eyu;
        };

Data.Either.$fMonadEither_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall e a b.
     Data.Either.Either e a
     -> Data.Either.Either e b -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Either.$fApplicativeEither_$c*> eta_B2 eta_B1;

lvl1_r5exc
  :: forall e a. [GHC.Types.Char] -> Data.Either.Either e a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s5eyv] GHC.Err.errorWithoutStackTrace eta_s5eyv;

Data.Either.$fMonadEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall e. GHC.Base.Monad (Data.Either.Either e)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Either.$fApplicativeEither
                                     Data.Either.$fMonadEither_$c>>=
                                     Data.Either.$fMonadEither_$c>>
                                     Data.Either.Right
                                     lvl1_r5exc];

Data.Either.$fShowEither5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Left "#;

Data.Either.$fShowEither4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fShowEither5;

Data.Either.$fReadEither4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Either.$fShowEither3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Right "#;

Data.Either.$fShowEither2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fShowEither3;

Data.Either.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Prim.Int# -> Data.Either.Either a b -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s5eyw w1_s5eyx ww_s5eyy w2_s5eyz]
        case w2_s5eyz of {
          Data.Either.Left b1_s5eyB [Occ=Once] ->
              let {
                g_s5eyC [Occ=OnceL*!, Dmd=<L,C(U)>]
                  :: GHC.Base.String -> GHC.Base.String
                [LclId] =
                    [w_s5eyw b1_s5eyB] \u []
                        GHC.Show.showsPrec w_s5eyw Data.Either.$fReadEither4 b1_s5eyB;
              } in 
                case >=# [ww_s5eyy 11#] of {
                  __DEFAULT ->
                      let {
                        sat_s5eyG [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5eyC] \r [x_s5eyE]
                                let {
                                  sat_s5eyF [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5eyC x_s5eyE] \s [] g_s5eyC x_s5eyE;
                                } in  GHC.Base.++ Data.Either.$fShowEither4 sat_s5eyF;
                      } in  sat_s5eyG;
                  1# ->
                      let {
                        sat_s5eyL [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5eyC] \r [x_s5eyH]
                                let {
                                  sat_s5eyK [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5eyC x_s5eyH] \u []
                                          let {
                                            sat_s5eyJ [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                            [LclId] =
                                                [g_s5eyC x_s5eyH] \s []
                                                    let {
                                                      sat_s5eyI [Occ=Once] :: GHC.Base.String
                                                      [LclId] =
                                                          CCCS :! [GHC.Show.$fShow(,)2 x_s5eyH];
                                                    } in  g_s5eyC sat_s5eyI;
                                          } in  GHC.Base.++ Data.Either.$fShowEither4 sat_s5eyJ;
                                } in  : [GHC.Show.$fShow(,)4 sat_s5eyK];
                      } in  sat_s5eyL;
                };
          Data.Either.Right b1_s5eyM [Occ=Once] ->
              let {
                g_s5eyN [Occ=OnceL*!, Dmd=<L,C(U)>]
                  :: GHC.Base.String -> GHC.Base.String
                [LclId] =
                    [w1_s5eyx b1_s5eyM] \u []
                        GHC.Show.showsPrec w1_s5eyx Data.Either.$fReadEither4 b1_s5eyM;
              } in 
                case >=# [ww_s5eyy 11#] of {
                  __DEFAULT ->
                      let {
                        sat_s5eyR [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5eyN] \r [x_s5eyP]
                                let {
                                  sat_s5eyQ [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5eyN x_s5eyP] \s [] g_s5eyN x_s5eyP;
                                } in  GHC.Base.++ Data.Either.$fShowEither2 sat_s5eyQ;
                      } in  sat_s5eyR;
                  1# ->
                      let {
                        sat_s5eyW [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5eyN] \r [x_s5eyS]
                                let {
                                  sat_s5eyV [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5eyN x_s5eyS] \u []
                                          let {
                                            sat_s5eyU [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                            [LclId] =
                                                [g_s5eyN x_s5eyS] \s []
                                                    let {
                                                      sat_s5eyT [Occ=Once] :: GHC.Base.String
                                                      [LclId] =
                                                          CCCS :! [GHC.Show.$fShow(,)2 x_s5eyS];
                                                    } in  g_s5eyN sat_s5eyT;
                                          } in  GHC.Base.++ Data.Either.$fShowEither2 sat_s5eyU;
                                } in  : [GHC.Show.$fShow(,)4 sat_s5eyV];
                      } in  sat_s5eyW;
                };
        };

Data.Either.$fShowEither_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Types.Int -> Data.Either.Either a b -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s5eyX w1_s5eyY w2_s5eyZ w3_s5ez0]
        case w2_s5eyZ of {
          GHC.Types.I# ww1_s5ez2 [Occ=Once] ->
              Data.Either.$w$cshowsPrec w_s5eyX w1_s5eyY ww1_s5ez2 w3_s5ez0;
        };

Data.Either.$fShowEither_$cshow
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     Data.Either.Either a b -> GHC.Base.String
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s5ez3 $dShow1_s5ez4 x_s5ez5]
        case x_s5ez5 of {
          Data.Either.Left b1_s5ez7 [Occ=Once] ->
              let {
                sat_s5ez8 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow_s5ez3 b1_s5ez7] \s []
                        GHC.Show.showsPrec
                            $dShow_s5ez3 Data.Either.$fReadEither4 b1_s5ez7 GHC.Types.[];
              } in  GHC.Base.++ Data.Either.$fShowEither4 sat_s5ez8;
          Data.Either.Right b1_s5ez9 [Occ=Once] ->
              let {
                sat_s5eza [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow1_s5ez4 b1_s5ez9] \s []
                        GHC.Show.showsPrec
                            $dShow1_s5ez4 Data.Either.$fReadEither4 b1_s5ez9 GHC.Types.[];
              } in  GHC.Base.++ Data.Either.$fShowEither2 sat_s5eza;
        };

Data.Either.$fShowEither1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Either.$fShowEither_$cshowList
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     [Data.Either.Either a b] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s5ezb $dShow1_s5ezc ls_s5ezd s_s5eze]
        let {
          sat_s5ezg [Occ=Once]
            :: Data.Either.Either a_a5dXF b_a5dXG -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s5ezb $dShow1_s5ezc] \r [w_s5ezf]
                  Data.Either.$w$cshowsPrec $dShow_s5ezb $dShow1_s5ezc 0# w_s5ezf;
        } in  GHC.Show.showList__ sat_s5ezg ls_s5ezd s_s5eze;

Data.Either.$fShowEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Show.Show (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s5ezh $dShow1_s5ezi]
        let {
          sat_s5ezl [Occ=Once]
            :: [Data.Either.Either a_a5dXF b_a5dXG] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s5ezh $dShow1_s5ezi] \r [eta_B2 eta_B1]
                  Data.Either.$fShowEither_$cshowList
                      $dShow_s5ezh $dShow1_s5ezi eta_B2 eta_B1; } in
        let {
          sat_s5ezk [Occ=Once]
            :: Data.Either.Either a_a5dXF b_a5dXG -> GHC.Base.String
          [LclId] =
              [$dShow_s5ezh $dShow1_s5ezi] \r [eta_B1]
                  Data.Either.$fShowEither_$cshow
                      $dShow_s5ezh $dShow1_s5ezi eta_B1; } in
        let {
          sat_s5ezj [Occ=Once]
            :: GHC.Types.Int
               -> Data.Either.Either a_a5dXF b_a5dXG -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s5ezh $dShow1_s5ezi] \r [eta_B2 eta_B1]
                  Data.Either.$fShowEither_$cshowsPrec
                      $dShow_s5ezh $dShow1_s5ezi eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s5ezj sat_s5ezk sat_s5ezl];

Data.Either.$fReadEither3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Left"#;

Data.Either.$fReadEither2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fReadEither3;

Data.Either.$fReadEither_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Either.$fReadEither2];

Data.Either.$fReadEither6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Right"#;

Data.Either.$fReadEither5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fReadEither6;

Data.Either.$fReadEither_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Either.$fReadEither5];

Data.Either.$fReadEither1
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Either.Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5ezm $dRead1_s5ezn eta_s5ezo eta1_s5ezp]
        let {
          sat_s5ezM [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_a5dWE b_a5dWF)
          [LclId] =
              [$dRead_s5ezm $dRead1_s5ezn] \r [n_s5ezq eta2_s5ezr]
                  case n_s5ezq of {
                    GHC.Types.I# x_s5ezt ->
                        let {
                          karg_s5ezu [Occ=Once*] :: Text.ParserCombinators.ReadP.P b2_X3ngu
                          [LclId] =
                              [$dRead1_s5ezn eta2_s5ezr x_s5ezt] \u []
                                  case <=# [x_s5ezt 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_s5ezA [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                          [LclId] =
                                              [$dRead1_s5ezn eta2_s5ezr] \r [a1_s5ezw]
                                                  let {
                                                    sat_s5ezz [Occ=Once]
                                                      :: b_a5dWF
                                                         -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                                    [LclId] =
                                                        [eta2_s5ezr] \r [a2_s5ezx]
                                                            let {
                                                              sat_s5ezy [Occ=Once]
                                                                :: Data.Either.Either
                                                                     a_a5dWE b_a5dWF
                                                              [LclId] =
                                                                  CCCS Data.Either.Right! [a2_s5ezx];
                                                            } in  eta2_s5ezr sat_s5ezy;
                                                  } in 
                                                    GHC.Read.readPrec
                                                        $dRead1_s5ezn
                                                        Data.Either.$fReadEither4
                                                        sat_s5ezz;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Either.$fReadEither_lexeme1 sat_s5ezA
                                          of
                                          { Unit# ww1_s5ezC [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s5ezC];
                                          };
                                  };
                        } in 
                          case <=# [x_s5ezt 10#] of {
                            __DEFAULT ->
                                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                    Text.ParserCombinators.ReadP.Fail karg_s5ezu;
                            1# ->
                                let {
                                  sat_s5ezI [Occ=Once]
                                    :: () -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                  [LclId] =
                                      [$dRead_s5ezm eta2_s5ezr] \r [a1_s5ezE]
                                          let {
                                            sat_s5ezH [Occ=Once]
                                              :: a_a5dWE -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                            [LclId] =
                                                [eta2_s5ezr] \r [a2_s5ezF]
                                                    let {
                                                      sat_s5ezG [Occ=Once]
                                                        :: Data.Either.Either a_a5dWE b_a5dWF
                                                      [LclId] =
                                                          CCCS Data.Either.Left! [a2_s5ezF];
                                                    } in  eta2_s5ezr sat_s5ezG;
                                          } in 
                                            GHC.Read.readPrec
                                                $dRead_s5ezm Data.Either.$fReadEither4 sat_s5ezH;
                                } in 
                                  case
                                      Text.Read.Lex.$wexpect
                                          Data.Either.$fReadEither_lexeme sat_s5ezI
                                  of
                                  { Unit# ww1_s5ezK [Occ=Once] ->
                                        let {
                                          sat_s5ezL [Occ=Once]
                                            :: Text.ParserCombinators.ReadP.P b2_X3ngu
                                          [LclId] =
                                              CCCS Text.ParserCombinators.ReadP.Look! [ww1_s5ezK];
                                        } in 
                                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                              sat_s5ezL karg_s5ezu;
                                  };
                          };
                  };
        } in  GHC.Read.list3 sat_s5ezM eta_s5ezo eta1_s5ezp;

Data.Either.$fReadEither_$creadsPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a b)
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5ezN $dRead1_s5ezO n_s5ezP]
        let {
          sat_s5ezQ [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Either.Either a_X5dY2 b_X5dY4)
          [LclId] =
              [$dRead_s5ezN $dRead1_s5ezO n_s5ezP] \u []
                  Data.Either.$fReadEither1
                      $dRead_s5ezN
                      $dRead1_s5ezO
                      n_s5ezP
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s5ezQ;

Data.Either.$fReadEither_$creadListPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Either.Either a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5ezR $dRead1_s5ezS]
        let {
          sat_s5ezT [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_X5dY0 b_X5dY2)
          [LclId] =
              [$dRead_s5ezR $dRead1_s5ezS] \r [eta_B2 eta_B1]
                  Data.Either.$fReadEither1 $dRead_s5ezR $dRead1_s5ezS eta_B2 eta_B1;
        } in  GHC.Read.list sat_s5ezT;

Data.Either.$fReadEither_$creadList
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadP.ReadS [Data.Either.Either a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5ezU $dRead1_s5ezV]
        let {
          sat_s5ezX [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Either.Either a_X5dY1 b_X5dY3]
          [LclId] =
              [$dRead_s5ezU $dRead1_s5ezV] \u []
                  let {
                    sat_s5ezW [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Either.Either a_X5dY1 b_X5dY3)
                    [LclId] =
                        [$dRead_s5ezU $dRead1_s5ezV] \r [eta_B2 eta_B1]
                            Data.Either.$fReadEither1 $dRead_s5ezU $dRead1_s5ezV eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s5ezW
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s5ezX;

Data.Either.$fReadEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Read.Read (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_s5ezY $dRead1_s5ezZ]
        let {
          sat_s5eA3 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Either.Either a_X5dXZ b_X5dY1]
          [LclId] =
              [$dRead_s5ezY $dRead1_s5ezZ] \u []
                  Data.Either.$fReadEither_$creadListPrec
                      $dRead_s5ezY $dRead1_s5ezZ; } in
        let {
          sat_s5eA2 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_X5dXZ b_X5dY1)
          [LclId] =
              [$dRead_s5ezY $dRead1_s5ezZ] \r [eta_B2 eta_B1]
                  Data.Either.$fReadEither1
                      $dRead_s5ezY $dRead1_s5ezZ eta_B2 eta_B1; } in
        let {
          sat_s5eA1 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Either.Either a_X5dXZ b_X5dY1]
          [LclId] =
              [$dRead_s5ezY $dRead1_s5ezZ] \u []
                  Data.Either.$fReadEither_$creadList
                      $dRead_s5ezY $dRead1_s5ezZ; } in
        let {
          sat_s5eA0 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Either.Either a_X5dXZ b_X5dY1)
          [LclId] =
              [$dRead_s5ezY $dRead1_s5ezZ] \r [eta_B1]
                  Data.Either.$fReadEither_$creadsPrec
                      $dRead_s5ezY $dRead1_s5ezZ eta_B1;
        } in  GHC.Read.C:Read [sat_s5eA0 sat_s5eA1 sat_s5eA2 sat_s5eA3];

Data.Either.$fOrdEither_$c<
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eA4 $dOrd1_s5eA5 a1_s5eA6 b1_s5eA7]
        case a1_s5eA6 of {
          Data.Either.Left a2_s5eA9 [Occ=Once] ->
              case b1_s5eA7 of {
                Data.Either.Left b2_s5eAb [Occ=Once] ->
                    GHC.Classes.< $dOrd_s5eA4 a2_s5eA9 b2_s5eAb;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Either.Right a2_s5eAd [Occ=Once] ->
              case b1_s5eA7 of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right b2_s5eAg [Occ=Once] ->
                    GHC.Classes.< $dOrd1_s5eA5 a2_s5eAd b2_s5eAg;
              };
        };

Data.Either.$fOrdEither_$ccompare
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b
     -> Data.Either.Either a b -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eAh $dOrd1_s5eAi a1_s5eAj b1_s5eAk]
        case a1_s5eAj of {
          Data.Either.Left a2_s5eAm [Occ=Once] ->
              case b1_s5eAk of {
                Data.Either.Left b2_s5eAo [Occ=Once] ->
                    GHC.Classes.compare $dOrd_s5eAh a2_s5eAm b2_s5eAo;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Either.Right a2_s5eAq [Occ=Once] ->
              case b1_s5eAk of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Either.Right b2_s5eAt [Occ=Once] ->
                    GHC.Classes.compare $dOrd1_s5eAi a2_s5eAq b2_s5eAt;
              };
        };

Data.Either.$fEqEither_$c==
  :: forall a b.
     (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s5eAu $dEq1_s5eAv ds_s5eAw ds1_s5eAx]
        case ds_s5eAw of {
          Data.Either.Left a1_s5eAz [Occ=Once] ->
              case ds1_s5eAx of {
                Data.Either.Left b1_s5eAB [Occ=Once] ->
                    GHC.Classes.== $dEq_s5eAu a1_s5eAz b1_s5eAB;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right a1_s5eAD [Occ=Once] ->
              case ds1_s5eAx of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right b1_s5eAG [Occ=Once] ->
                    GHC.Classes.== $dEq1_s5eAv a1_s5eAD b1_s5eAG;
              };
        };

Data.Either.$fEqEither_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s5eAH $dEq1_s5eAI eta_s5eAJ eta1_s5eAK]
        case eta_s5eAJ of {
          Data.Either.Left a1_s5eAM [Occ=Once] ->
              case eta1_s5eAK of {
                Data.Either.Left b1_s5eAO [Occ=Once] ->
                    case GHC.Classes.== $dEq_s5eAH a1_s5eAM b1_s5eAO of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Either.Right a1_s5eAR [Occ=Once] ->
              case eta1_s5eAK of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
                Data.Either.Right b1_s5eAU [Occ=Once] ->
                    case GHC.Classes.== $dEq1_s5eAI a1_s5eAR b1_s5eAU of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Either.$fEqEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     GHC.Classes.Eq (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s5eAW $dEq1_s5eAX]
        let {
          sat_s5eAZ [Occ=Once]
            :: Data.Either.Either a_a5dVh b_a5dVi
               -> Data.Either.Either a_a5dVh b_a5dVi -> GHC.Types.Bool
          [LclId] =
              [$dEq_s5eAW $dEq1_s5eAX] \r [eta_B2 eta_B1]
                  Data.Either.$fEqEither_$c/=
                      $dEq_s5eAW $dEq1_s5eAX eta_B2 eta_B1; } in
        let {
          sat_s5eAY [Occ=Once]
            :: Data.Either.Either a_a5dVh b_a5dVi
               -> Data.Either.Either a_a5dVh b_a5dVi -> GHC.Types.Bool
          [LclId] =
              [$dEq_s5eAW $dEq1_s5eAX] \r [eta_B2 eta_B1]
                  Data.Either.$fEqEither_$c== $dEq_s5eAW $dEq1_s5eAX eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s5eAY sat_s5eAZ];

Data.Either.$fOrdEither_$cp1Ord
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     GHC.Classes.Eq (Data.Either.Either a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eB0 $dOrd1_s5eB1]
        let {
          sat_s5eB3 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq b_a5dVB
          [LclId] =
              [$dOrd1_s5eB1] \u [] GHC.Classes.$p1Ord $dOrd1_s5eB1; } in
        let {
          sat_s5eB2 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_a5dVA
          [LclId] =
              [$dOrd_s5eB0] \u [] GHC.Classes.$p1Ord $dOrd_s5eB0;
        } in  Data.Either.$fEqEither sat_s5eB2 sat_s5eB3;

Data.Either.$fOrdEither_$c<=
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eB4 $dOrd1_s5eB5 a1_s5eB6 b1_s5eB7]
        case b1_s5eB7 of {
          Data.Either.Left a2_s5eB9 [Occ=Once] ->
              case a1_s5eB6 of {
                Data.Either.Left b2_s5eBb [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5eB4 a2_s5eB9 b2_s5eBb of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right a2_s5eBe [Occ=Once] ->
              case a1_s5eB6 of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
                Data.Either.Right b2_s5eBh [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5eB5 a2_s5eBe b2_s5eBh of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Either.$fOrdEither_$cmax
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b
     -> Data.Either.Either a b -> Data.Either.Either a b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eBj $dOrd1_s5eBk x_s5eBl y_s5eBm]
        case y_s5eBm of wild_s5eBn {
          Data.Either.Left a1_s5eBo [Occ=Once] ->
              case x_s5eBl of wild1_s5eBp {
                Data.Either.Left b1_s5eBq [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5eBj a1_s5eBo b1_s5eBq of {
                      GHC.Types.False -> wild_s5eBn;
                      GHC.Types.True -> wild1_s5eBp;
                    };
                Data.Either.Right _ [Occ=Dead] -> wild1_s5eBp;
              };
          Data.Either.Right a1_s5eBt [Occ=Once] ->
              case x_s5eBl of wild1_s5eBu {
                Data.Either.Left _ [Occ=Dead] -> wild_s5eBn;
                Data.Either.Right b1_s5eBw [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5eBk a1_s5eBt b1_s5eBw of {
                      GHC.Types.False -> wild_s5eBn;
                      GHC.Types.True -> wild1_s5eBu;
                    };
              };
        };

Data.Either.$fOrdEither_$c>=
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eBy $dOrd1_s5eBz a1_s5eBA b1_s5eBB]
        case a1_s5eBA of {
          Data.Either.Left a2_s5eBD [Occ=Once] ->
              case b1_s5eBB of {
                Data.Either.Left b2_s5eBF [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5eBy a2_s5eBD b2_s5eBF of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right a2_s5eBI [Occ=Once] ->
              case b1_s5eBB of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
                Data.Either.Right b2_s5eBL [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5eBz a2_s5eBI b2_s5eBL of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Either.$fOrdEither_$cmin
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b
     -> Data.Either.Either a b -> Data.Either.Either a b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5eBN $dOrd1_s5eBO x_s5eBP y_s5eBQ]
        case y_s5eBQ of wild_s5eBR {
          Data.Either.Left a1_s5eBS [Occ=Once] ->
              case x_s5eBP of wild1_s5eBT {
                Data.Either.Left b1_s5eBU [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5eBN a1_s5eBS b1_s5eBU of {
                      GHC.Types.False -> wild1_s5eBT;
                      GHC.Types.True -> wild_s5eBR;
                    };
                Data.Either.Right _ [Occ=Dead] -> wild_s5eBR;
              };
          Data.Either.Right a1_s5eBX [Occ=Once] ->
              case x_s5eBP of wild1_s5eBY {
                Data.Either.Left _ [Occ=Dead] -> wild1_s5eBY;
                Data.Either.Right b1_s5eC0 [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5eBO a1_s5eBX b1_s5eC0 of {
                      GHC.Types.False -> wild1_s5eBY;
                      GHC.Types.True -> wild_s5eBR;
                    };
              };
        };

Data.Either.$fOrdEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     GHC.Classes.Ord (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s5eC2 $dOrd1_s5eC3]
        let {
          sat_s5eCd [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$cmin
                      $dOrd_s5eC2 $dOrd1_s5eC3 eta_B2 eta_B1; } in
        let {
          sat_s5eCc [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$cmax
                      $dOrd_s5eC2 $dOrd1_s5eC3 eta_B2 eta_B1; } in
        let {
          sat_s5eCb [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$c>=
                      $dOrd_s5eC2 $dOrd1_s5eC3 eta_B2 eta_B1; } in
        let {
          sat_s5eCa [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [a1_s5eC8 b1_s5eC9]
                  Data.Either.$fOrdEither_$c<
                      $dOrd_s5eC2 $dOrd1_s5eC3 b1_s5eC9 a1_s5eC8; } in
        let {
          sat_s5eC7 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$c<=
                      $dOrd_s5eC2 $dOrd1_s5eC3 eta_B2 eta_B1; } in
        let {
          sat_s5eC6 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$c<
                      $dOrd_s5eC2 $dOrd1_s5eC3 eta_B2 eta_B1; } in
        let {
          sat_s5eC5 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$ccompare
                      $dOrd_s5eC2 $dOrd1_s5eC3 eta_B2 eta_B1; } in
        let {
          sat_s5eC4 [Occ=Once]
            :: GHC.Classes.Eq (Data.Either.Either a_a5dVA b_a5dVB)
          [LclId] =
              [$dOrd_s5eC2 $dOrd1_s5eC3] \u []
                  Data.Either.$fOrdEither_$cp1Ord $dOrd_s5eC2 $dOrd1_s5eC3;
        } in 
          GHC.Classes.C:Ord [sat_s5eC4
                             sat_s5eC5
                             sat_s5eC6
                             sat_s5eC7
                             sat_s5eCa
                             sat_s5eCb
                             sat_s5eCc
                             sat_s5eCd];

Data.Either.either
  :: forall a c b.
     (a -> c) -> (b -> c) -> Data.Either.Either a b -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s5eCe ds_s5eCf ds1_s5eCg]
        case ds1_s5eCg of {
          Data.Either.Left x_s5eCi [Occ=Once] -> f_s5eCe x_s5eCi;
          Data.Either.Right y_s5eCj [Occ=Once] -> ds_s5eCf y_s5eCj;
        };

Data.Either.$wpartitionEithers [InlPrag=NOUSERINLINE[0],
                                Occ=LoopBreaker]
  :: forall a b. [Data.Either.Either a b] -> (# [a], [b] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [w_s5eCk]
        case w_s5eCk of {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : y_s5eCm [Occ=Once!] ys_s5eCn [Occ=Once] ->
              let {
                eta_s5eCo [Dmd=<L,U(1*U,1*U)>] :: ([a_s5enu], [b_s5env])
                [LclId] =
                    [ys_s5eCn] \u []
                        case Data.Either.$wpartitionEithers ys_s5eCn of {
                          (#,#) ww1_s5eCq [Occ=Once] ww2_s5eCr [Occ=Once] ->
                              (,) [ww1_s5eCq ww2_s5eCr];
                        };
              } in 
                case y_s5eCm of {
                  Data.Either.Left x_s5eCt [Occ=Once] ->
                      let {
                        sat_s5eCC [Occ=Once] :: [b_s5env]
                        [LclId] =
                            [eta_s5eCo] \u []
                                case eta_s5eCo of {
                                  (,) _ [Occ=Dead] r_s5eCB [Occ=Once] -> r_s5eCB;
                                }; } in
                      let {
                        sat_s5eCx [Occ=Once] :: [a_s5enu]
                        [LclId] =
                            [eta_s5eCo] \u []
                                case eta_s5eCo of {
                                  (,) l_s5eCv [Occ=Once] _ [Occ=Dead] -> l_s5eCv;
                                }; } in
                      let {
                        sat_s5eCy [Occ=Once] :: [a_s5enu]
                        [LclId] =
                            CCCS :! [x_s5eCt sat_s5eCx];
                      } in  (#,#) [sat_s5eCy sat_s5eCC];
                  Data.Either.Right y1_s5eCD [Occ=Once] ->
                      let {
                        sat_s5eCL [Occ=Once] :: [b_s5env]
                        [LclId] =
                            [eta_s5eCo] \u []
                                case eta_s5eCo of {
                                  (,) _ [Occ=Dead] r_s5eCK [Occ=Once] -> r_s5eCK;
                                }; } in
                      let {
                        sat_s5eCM [Occ=Once] :: [b_s5env]
                        [LclId] =
                            CCCS :! [y1_s5eCD sat_s5eCL]; } in
                      let {
                        sat_s5eCH [Occ=Once] :: [a_s5enu]
                        [LclId] =
                            [eta_s5eCo] \u []
                                case eta_s5eCo of {
                                  (,) l_s5eCF [Occ=Once] _ [Occ=Dead] -> l_s5eCF;
                                };
                      } in  (#,#) [sat_s5eCH sat_s5eCM];
                };
        };

Data.Either.partitionEithers [InlPrag=NOUSERINLINE[0]]
  :: forall a b. [Data.Either.Either a b] -> ([a], [b])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_s5eCN]
        case Data.Either.$wpartitionEithers w_s5eCN of {
          (#,#) ww1_s5eCP [Occ=Once] ww2_s5eCQ [Occ=Once] ->
              (,) [ww1_s5eCP ww2_s5eCQ];
        };

poly_go_r5exd :: forall a b. [Data.Either.Either a b] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds_s5eCR]
        case ds_s5eCR of {
          [] -> [] [];
          : y_s5eCT [Occ=Once!] ys_s5eCU [Occ=Once*] ->
              case y_s5eCT of {
                Data.Either.Left a1_s5eCW [Occ=Once] ->
                    let {
                      sat_s5eCX [Occ=Once] :: [a_a5dTY]
                      [LclId] =
                          [ys_s5eCU] \u [] poly_go_r5exd ys_s5eCU;
                    } in  : [a1_s5eCW sat_s5eCX];
                Data.Either.Right _ [Occ=Dead] -> poly_go_r5exd ys_s5eCU;
              };
        };

Data.Either.lefts [InlPrag=INLINABLE]
  :: forall a b. [Data.Either.Either a b] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s5eCZ] poly_go_r5exd x_s5eCZ;

poly_go1_r5exe :: forall a b. [Data.Either.Either a b] -> [b]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds_s5eD0]
        case ds_s5eD0 of {
          [] -> [] [];
          : y_s5eD2 [Occ=Once!] ys_s5eD3 [Occ=Once*] ->
              case y_s5eD2 of {
                Data.Either.Left _ [Occ=Dead] -> poly_go1_r5exe ys_s5eD3;
                Data.Either.Right a1_s5eD6 [Occ=Once] ->
                    let {
                      sat_s5eD7 [Occ=Once] :: [b_a5dTV]
                      [LclId] =
                          [ys_s5eD3] \u [] poly_go1_r5exe ys_s5eD3;
                    } in  : [a1_s5eD6 sat_s5eD7];
              };
        };

Data.Either.rights [InlPrag=INLINABLE]
  :: forall a b. [Data.Either.Either a b] -> [b]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s5eD8] poly_go1_r5exe x_s5eD8;

Data.Either.isLeft
  :: forall a b. Data.Either.Either a b -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5eD9]
        case ds_s5eD9 of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
          Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Either.isRight
  :: forall a b. Data.Either.Either a b -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5eDd]
        case ds_s5eDd of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
          Data.Either.Right _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Either.fromLeft
  :: forall a b. a -> Data.Either.Either a b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5eDh ds1_s5eDi]
        case ds1_s5eDi of {
          Data.Either.Left a1_s5eDk [Occ=Once] -> a1_s5eDk;
          Data.Either.Right _ [Occ=Dead] -> ds_s5eDh;
        };

Data.Either.fromRight
  :: forall b a. b -> Data.Either.Either a b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5eDm ds1_s5eDn]
        case ds1_s5eDn of {
          Data.Either.Left _ [Occ=Dead] -> ds_s5eDm;
          Data.Either.Right b1_s5eDq [Occ=Once] -> b1_s5eDq;
        };

Data.Either.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Either.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$trModule4];

Data.Either.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Either"#;

Data.Either.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$trModule2];

Data.Either.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Either.$trModule3
                                     Data.Either.$trModule1];

$krep_r5exf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_r5exg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Either.$tcEither2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Either"#;

Data.Either.$tcEither1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$tcEither2];

Data.Either.$tcEither :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16074290893719807138##
                                    14958199358864670905##
                                    Data.Either.$trModule
                                    Data.Either.$tcEither1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep2_r5exh :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r5exf GHC.Types.[]];

$krep3_r5exi :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r5exg $krep2_r5exh];

$krep4_r5exj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Either.$tcEither
                                              $krep3_r5exi];

Data.Either.$tc'Left1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r5exg $krep4_r5exj];

Data.Either.$tc'Left3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Left"#;

Data.Either.$tc'Left2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$tc'Left3];

Data.Either.$tc'Left :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14915236324383360020##
                                    11027491440201056612##
                                    Data.Either.$trModule
                                    Data.Either.$tc'Left2
                                    2#
                                    Data.Either.$tc'Left1];

Data.Either.$tc'Right1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r5exf $krep4_r5exj];

Data.Either.$tc'Right3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Right"#;

Data.Either.$tc'Right2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$tc'Right3];

Data.Either.$tc'Right :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10395468319011834275##
                                    16371021254350888909##
                                    Data.Either.$trModule
                                    Data.Either.$tc'Right2
                                    2#
                                    Data.Either.$tc'Right1];

Data.Either.Left :: forall a b. a -> Data.Either.Either a b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Either.Left [eta_B1];

Data.Either.Right :: forall a b. b -> Data.Either.Either a b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Either.Right [eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:00:15.970579921 UTC

Data.Either.$fApplicativeEither_$cfmap
  :: forall a1 a2 b.
     (a2 -> b) -> Data.Either.Either a1 a2 -> Data.Either.Either a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5gmh ds1_s5gmi]
        case ds1_s5gmi of {
          Data.Either.Left x_s5gmk [Occ=Once] -> wild_s5gmj;
          Data.Either.Right y_s5gml [Occ=Once] ->
              let {
                sat_s5gmm [Occ=Once] :: b_a5e0k
                [LclId] =
                    [ds_s5gmh y_s5gml] \u [] ds_s5gmh y_s5gml;
              } in  Data.Either.Right [sat_s5gmm];
        };

Data.Either.$fFunctorEither_$c<$
  :: forall a1 a2 b.
     a2 -> Data.Either.Either a1 b -> Data.Either.Either a1 a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_s5gmn ds_s5gmo]
        case ds_s5gmo of {
          Data.Either.Left x1_s5gmq [Occ=Once] -> wild_s5gmp;
          Data.Either.Right _ [Occ=Dead] -> Data.Either.Right [x_s5gmn];
        };

Data.Either.$fFunctorEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Functor (Data.Either.Either a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Either.$fApplicativeEither_$cfmap
                                       Data.Either.$fFunctorEither_$c<$];

lvl_r5exb :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: positive multiplier expected"#;

Data.Either.$fSemigroupEither1
  :: forall a b. Data.Either.Either a b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r5exb of sat_s5gms {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s5gms;
        };

Data.Either.$fSemigroupEither2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Either.$fSemigroupEither_$cstimes
  :: forall a b1 b2.
     GHC.Real.Integral b2 =>
     b2 -> Data.Either.Either a b1 -> Data.Either.Either a b1
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s5gmt eta_s5gmu eta1_s5gmv]
        case
            GHC.Real.$p1Integral $dIntegral_s5gmt
        of
        $dReal_s5gmw [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s5gmz [Occ=Once] :: b1_a5e03
                [LclId] =
                    [$dReal_s5gmw] \u []
                        case GHC.Real.$p1Real $dReal_s5gmw of sat_s5gmy {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s5gmy Data.Either.$fSemigroupEither2;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s5gmw of sat_s5gmx {
                  __DEFAULT ->
                      case GHC.Classes.<= sat_s5gmx eta_s5gmu sat_s5gmz of {
                        GHC.Types.False -> eta1_s5gmv;
                        GHC.Types.True -> Data.Either.$fSemigroupEither1;
                      };
                };
        };

Data.Either.$fSemigroupEither_$c<>
  :: forall a b.
     Data.Either.Either a b
     -> Data.Either.Either a b -> Data.Either.Either a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5gmB b1_s5gmC]
        case ds_s5gmB of wild_s5gmD {
          Data.Either.Left _ [Occ=Dead] -> b1_s5gmC;
          Data.Either.Right _ [Occ=Dead] -> wild_s5gmD;
        };

Data.Either.$fSemigroupEither3 [Occ=LoopBreaker]
  :: forall a b.
     Data.Either.Either a b
     -> [Data.Either.Either a b] -> Data.Either.Either a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b1_s5gmG ds1_s5gmH]
        case ds1_s5gmH of {
          [] -> b1_s5gmG;
          : c_s5gmJ [Occ=Once] cs_s5gmK [Occ=Once] ->
              case b1_s5gmG of wild_s5gmL {
                Data.Either.Left _ [Occ=Dead] ->
                    Data.Either.$fSemigroupEither3 c_s5gmJ cs_s5gmK;
                Data.Either.Right _ [Occ=Dead] -> wild_s5gmL;
              };
        };

Data.Either.$fSemigroupEither_$csconcat
  :: forall a b.
     GHC.Base.NonEmpty (Data.Either.Either a b)
     -> Data.Either.Either a b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s5gmO]
        case ds_s5gmO of {
          GHC.Base.:| a1_s5gmQ [Occ=Once] as_s5gmR [Occ=Once] ->
              Data.Either.$fSemigroupEither3 a1_s5gmQ as_s5gmR;
        };

Data.Either.$fSemigroupEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. GHC.Base.Semigroup (Data.Either.Either a b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Either.$fSemigroupEither_$c<>
                                         Data.Either.$fSemigroupEither_$csconcat
                                         Data.Either.$fSemigroupEither_$cstimes];

Data.Either.$fApplicativeEither_$c<*>
  :: forall e a b.
     Data.Either.Either e (a -> b)
     -> Data.Either.Either e a -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5gmS ds1_s5gmT]
        case ds_s5gmS of {
          Data.Either.Left e1_s5gmV [Occ=Once] -> wild_s5gmU;
          Data.Either.Right f_s5gmW [Occ=Once] ->
              Data.Either.$fApplicativeEither_$cfmap f_s5gmW ds1_s5gmT;
        };

Data.Either.$fApplicativeEither_$cliftA2
  :: forall e a b c.
     (a -> b -> c)
     -> Data.Either.Either e a
     -> Data.Either.Either e b
     -> Data.Either.Either e c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f1_s5gmX x_s5gmY]
        let {
          ds_s5gmZ [Occ=OnceL!]
            :: Data.Either.Either e_a5dYS (b_a5dZl -> c_a5dZm)
          [LclId] =
              [f1_s5gmX x_s5gmY] \u []
                  case x_s5gmY of {
                    Data.Either.Left x1_s5gn1 [Occ=Once] -> wild_s5gn0;
                    Data.Either.Right y_s5gn2 [Occ=Once] ->
                        let {
                          sat_s5gn3 [Occ=Once] :: b_a5dZl -> c_a5dZm
                          [LclId] =
                              [f1_s5gmX y_s5gn2] \u [] f1_s5gmX y_s5gn2;
                        } in  Data.Either.Right [sat_s5gn3];
                  }; } in
        let {
          sat_s5gn8 [Occ=OnceT[0]]
            :: Data.Either.Either e_a5dYS b_a5dZl
               -> Data.Either.Either e_a5dYS c_a5dZm
          [LclId] =
              [ds_s5gmZ] \r [ds1_s5gn4]
                  case ds_s5gmZ of {
                    Data.Either.Left e1_s5gn6 [Occ=Once] -> wild_s5gn5;
                    Data.Either.Right f_s5gn7 [Occ=Once] ->
                        Data.Either.$fApplicativeEither_$cfmap f_s5gn7 ds1_s5gn4;
                  };
        } in  sat_s5gn8;

Data.Either.$fApplicativeEither_$c*>
  :: forall e a b.
     Data.Either.Either e a
     -> Data.Either.Either e b -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s5gn9 a2_s5gna]
        case a1_s5gn9 of {
          Data.Either.Left x_s5gnc [Occ=Once] -> wild_s5gnb;
          Data.Either.Right _ [Occ=Dead] -> a2_s5gna;
        };

Data.Either.$fApplicativeEither_$c<*
  :: forall e a b.
     Data.Either.Either e a
     -> Data.Either.Either e b -> Data.Either.Either e a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [x_s5gne ds_s5gnf]
        case x_s5gne of wild_s5gng {
          Data.Either.Left _ [Occ=Dead] -> wild_s5gng;
          Data.Either.Right _ [Occ=Dead] ->
              case ds_s5gnf of {
                Data.Either.Left x1_s5gnk [Occ=Once] -> wild1_s5gnj;
                Data.Either.Right _ [Occ=Dead] -> wild_s5gng;
              };
        };

Data.Either.$fApplicativeEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall e. GHC.Base.Applicative (Data.Either.Either e)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Either.$fFunctorEither
                                           Data.Either.Right
                                           Data.Either.$fApplicativeEither_$c<*>
                                           Data.Either.$fApplicativeEither_$cliftA2
                                           Data.Either.$fApplicativeEither_$c*>
                                           Data.Either.$fApplicativeEither_$c<*];

Data.Either.$fMonadEither_$c>>=
  :: forall e a b.
     Data.Either.Either e a
     -> (a -> Data.Either.Either e b) -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s5gnm ds1_s5gnn]
        case ds_s5gnm of {
          Data.Either.Left l_s5gnp [Occ=Once] -> wild_s5gno;
          Data.Either.Right r_s5gnq [Occ=Once] -> ds1_s5gnn r_s5gnq;
        };

Data.Either.$fMonadEither_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall e a b.
     Data.Either.Either e a
     -> Data.Either.Either e b -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Either.$fApplicativeEither_$c*> eta_B2 eta_B1;

lvl1_r5exc
  :: forall e a. [GHC.Types.Char] -> Data.Either.Either e a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s5gnr] GHC.Err.errorWithoutStackTrace eta_s5gnr;

Data.Either.$fMonadEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall e. GHC.Base.Monad (Data.Either.Either e)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Either.$fApplicativeEither
                                     Data.Either.$fMonadEither_$c>>=
                                     Data.Either.$fMonadEither_$c>>
                                     Data.Either.Right
                                     lvl1_r5exc];

Data.Either.$fShowEither5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Left "#;

Data.Either.$fShowEither4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fShowEither5;

Data.Either.$fReadEither4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Either.$fShowEither3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Right "#;

Data.Either.$fShowEither2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fShowEither3;

Data.Either.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Prim.Int# -> Data.Either.Either a b -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s5gns w1_s5gnt ww_s5gnu w2_s5gnv]
        case w2_s5gnv of {
          Data.Either.Left b1_s5gnx [Occ=Once] ->
              let {
                g_s5gny [Occ=OnceL*!, Dmd=<L,C(U)>]
                  :: GHC.Base.String -> GHC.Base.String
                [LclId] =
                    [w_s5gns b1_s5gnx] \u []
                        GHC.Show.showsPrec w_s5gns Data.Either.$fReadEither4 b1_s5gnx;
              } in 
                case >=# [ww_s5gnu 11#] of {
                  __DEFAULT ->
                      let {
                        sat_s5gnC [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5gny] \r [x_s5gnA]
                                let {
                                  sat_s5gnB [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5gny x_s5gnA] \s [] g_s5gny x_s5gnA;
                                } in  GHC.Base.++ Data.Either.$fShowEither4 sat_s5gnB;
                      } in  sat_s5gnC;
                  1# ->
                      let {
                        sat_s5gnH [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5gny] \r [x_s5gnD]
                                let {
                                  sat_s5gnG [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5gny x_s5gnD] \u []
                                          let {
                                            sat_s5gnF [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                            [LclId] =
                                                [g_s5gny x_s5gnD] \s []
                                                    let {
                                                      sat_s5gnE [Occ=Once] :: GHC.Base.String
                                                      [LclId] =
                                                          CCCS :! [GHC.Show.$fShow(,)2 x_s5gnD];
                                                    } in  g_s5gny sat_s5gnE;
                                          } in  GHC.Base.++ Data.Either.$fShowEither4 sat_s5gnF;
                                } in  : [GHC.Show.$fShow(,)4 sat_s5gnG];
                      } in  sat_s5gnH;
                };
          Data.Either.Right b1_s5gnI [Occ=Once] ->
              let {
                g_s5gnJ [Occ=OnceL*!, Dmd=<L,C(U)>]
                  :: GHC.Base.String -> GHC.Base.String
                [LclId] =
                    [w1_s5gnt b1_s5gnI] \u []
                        GHC.Show.showsPrec w1_s5gnt Data.Either.$fReadEither4 b1_s5gnI;
              } in 
                case >=# [ww_s5gnu 11#] of {
                  __DEFAULT ->
                      let {
                        sat_s5gnN [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5gnJ] \r [x_s5gnL]
                                let {
                                  sat_s5gnM [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5gnJ x_s5gnL] \s [] g_s5gnJ x_s5gnL;
                                } in  GHC.Base.++ Data.Either.$fShowEither2 sat_s5gnM;
                      } in  sat_s5gnN;
                  1# ->
                      let {
                        sat_s5gnS [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5gnJ] \r [x_s5gnO]
                                let {
                                  sat_s5gnR [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5gnJ x_s5gnO] \u []
                                          let {
                                            sat_s5gnQ [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                            [LclId] =
                                                [g_s5gnJ x_s5gnO] \s []
                                                    let {
                                                      sat_s5gnP [Occ=Once] :: GHC.Base.String
                                                      [LclId] =
                                                          CCCS :! [GHC.Show.$fShow(,)2 x_s5gnO];
                                                    } in  g_s5gnJ sat_s5gnP;
                                          } in  GHC.Base.++ Data.Either.$fShowEither2 sat_s5gnQ;
                                } in  : [GHC.Show.$fShow(,)4 sat_s5gnR];
                      } in  sat_s5gnS;
                };
        };

Data.Either.$fShowEither_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Types.Int -> Data.Either.Either a b -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s5gnT w1_s5gnU w2_s5gnV w3_s5gnW]
        case w2_s5gnV of {
          GHC.Types.I# ww1_s5gnY [Occ=Once] ->
              Data.Either.$w$cshowsPrec w_s5gnT w1_s5gnU ww1_s5gnY w3_s5gnW;
        };

Data.Either.$fShowEither_$cshow
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     Data.Either.Either a b -> GHC.Base.String
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s5gnZ $dShow1_s5go0 x_s5go1]
        case x_s5go1 of {
          Data.Either.Left b1_s5go3 [Occ=Once] ->
              let {
                sat_s5go4 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow_s5gnZ b1_s5go3] \s []
                        GHC.Show.showsPrec
                            $dShow_s5gnZ Data.Either.$fReadEither4 b1_s5go3 GHC.Types.[];
              } in  GHC.Base.++ Data.Either.$fShowEither4 sat_s5go4;
          Data.Either.Right b1_s5go5 [Occ=Once] ->
              let {
                sat_s5go6 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow1_s5go0 b1_s5go5] \s []
                        GHC.Show.showsPrec
                            $dShow1_s5go0 Data.Either.$fReadEither4 b1_s5go5 GHC.Types.[];
              } in  GHC.Base.++ Data.Either.$fShowEither2 sat_s5go6;
        };

Data.Either.$fShowEither1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Either.$fShowEither_$cshowList
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     [Data.Either.Either a b] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s5go7 $dShow1_s5go8 ls_s5go9 s_s5goa]
        let {
          sat_s5goc [Occ=Once]
            :: Data.Either.Either a_a5dXF b_a5dXG -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s5go7 $dShow1_s5go8] \r [w_s5gob]
                  Data.Either.$w$cshowsPrec $dShow_s5go7 $dShow1_s5go8 0# w_s5gob;
        } in  GHC.Show.showList__ sat_s5goc ls_s5go9 s_s5goa;

Data.Either.$fShowEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Show.Show (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s5god $dShow1_s5goe]
        let {
          sat_s5goh [Occ=Once]
            :: [Data.Either.Either a_a5dXF b_a5dXG] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s5god $dShow1_s5goe] \r [eta_B2 eta_B1]
                  Data.Either.$fShowEither_$cshowList
                      $dShow_s5god $dShow1_s5goe eta_B2 eta_B1; } in
        let {
          sat_s5gog [Occ=Once]
            :: Data.Either.Either a_a5dXF b_a5dXG -> GHC.Base.String
          [LclId] =
              [$dShow_s5god $dShow1_s5goe] \r [eta_B1]
                  Data.Either.$fShowEither_$cshow
                      $dShow_s5god $dShow1_s5goe eta_B1; } in
        let {
          sat_s5gof [Occ=Once]
            :: GHC.Types.Int
               -> Data.Either.Either a_a5dXF b_a5dXG -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s5god $dShow1_s5goe] \r [eta_B2 eta_B1]
                  Data.Either.$fShowEither_$cshowsPrec
                      $dShow_s5god $dShow1_s5goe eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s5gof sat_s5gog sat_s5goh];

Data.Either.$fReadEither3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Left"#;

Data.Either.$fReadEither2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fReadEither3;

Data.Either.$fReadEither_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Either.$fReadEither2];

Data.Either.$fReadEither6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Right"#;

Data.Either.$fReadEither5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fReadEither6;

Data.Either.$fReadEither_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Either.$fReadEither5];

Data.Either.$fReadEither1
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Either.Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5goi $dRead1_s5goj eta_s5gok eta1_s5gol]
        let {
          sat_s5goI [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_a5dWE b_a5dWF)
          [LclId] =
              [$dRead_s5goi $dRead1_s5goj] \r [n_s5gom eta2_s5gon]
                  case n_s5gom of {
                    GHC.Types.I# x_s5gop ->
                        let {
                          karg_s5goq [Occ=Once*] :: Text.ParserCombinators.ReadP.P b2_X3ngu
                          [LclId] =
                              [$dRead1_s5goj eta2_s5gon x_s5gop] \u []
                                  case <=# [x_s5gop 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_s5gow [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                          [LclId] =
                                              [$dRead1_s5goj eta2_s5gon] \r [a1_s5gos]
                                                  let {
                                                    sat_s5gov [Occ=Once]
                                                      :: b_a5dWF
                                                         -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                                    [LclId] =
                                                        [eta2_s5gon] \r [a2_s5got]
                                                            let {
                                                              sat_s5gou [Occ=Once]
                                                                :: Data.Either.Either
                                                                     a_a5dWE b_a5dWF
                                                              [LclId] =
                                                                  CCCS Data.Either.Right! [a2_s5got];
                                                            } in  eta2_s5gon sat_s5gou;
                                                  } in 
                                                    GHC.Read.readPrec
                                                        $dRead1_s5goj
                                                        Data.Either.$fReadEither4
                                                        sat_s5gov;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Either.$fReadEither_lexeme1 sat_s5gow
                                          of
                                          { Unit# ww1_s5goy [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s5goy];
                                          };
                                  };
                        } in 
                          case <=# [x_s5gop 10#] of {
                            __DEFAULT ->
                                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                    Text.ParserCombinators.ReadP.Fail karg_s5goq;
                            1# ->
                                let {
                                  sat_s5goE [Occ=Once]
                                    :: () -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                  [LclId] =
                                      [$dRead_s5goi eta2_s5gon] \r [a1_s5goA]
                                          let {
                                            sat_s5goD [Occ=Once]
                                              :: a_a5dWE -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                            [LclId] =
                                                [eta2_s5gon] \r [a2_s5goB]
                                                    let {
                                                      sat_s5goC [Occ=Once]
                                                        :: Data.Either.Either a_a5dWE b_a5dWF
                                                      [LclId] =
                                                          CCCS Data.Either.Left! [a2_s5goB];
                                                    } in  eta2_s5gon sat_s5goC;
                                          } in 
                                            GHC.Read.readPrec
                                                $dRead_s5goi Data.Either.$fReadEither4 sat_s5goD;
                                } in 
                                  case
                                      Text.Read.Lex.$wexpect
                                          Data.Either.$fReadEither_lexeme sat_s5goE
                                  of
                                  { Unit# ww1_s5goG [Occ=Once] ->
                                        let {
                                          sat_s5goH [Occ=Once]
                                            :: Text.ParserCombinators.ReadP.P b2_X3ngu
                                          [LclId] =
                                              CCCS Text.ParserCombinators.ReadP.Look! [ww1_s5goG];
                                        } in 
                                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                              sat_s5goH karg_s5goq;
                                  };
                          };
                  };
        } in  GHC.Read.list3 sat_s5goI eta_s5gok eta1_s5gol;

Data.Either.$fReadEither_$creadsPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a b)
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5goJ $dRead1_s5goK n_s5goL]
        let {
          sat_s5goM [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Either.Either a_X5dY2 b_X5dY4)
          [LclId] =
              [$dRead_s5goJ $dRead1_s5goK n_s5goL] \u []
                  Data.Either.$fReadEither1
                      $dRead_s5goJ
                      $dRead1_s5goK
                      n_s5goL
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s5goM;

Data.Either.$fReadEither_$creadListPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Either.Either a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5goN $dRead1_s5goO]
        let {
          sat_s5goP [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_X5dY0 b_X5dY2)
          [LclId] =
              [$dRead_s5goN $dRead1_s5goO] \r [eta_B2 eta_B1]
                  Data.Either.$fReadEither1 $dRead_s5goN $dRead1_s5goO eta_B2 eta_B1;
        } in  GHC.Read.list sat_s5goP;

Data.Either.$fReadEither_$creadList
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadP.ReadS [Data.Either.Either a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5goQ $dRead1_s5goR]
        let {
          sat_s5goT [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Either.Either a_X5dY1 b_X5dY3]
          [LclId] =
              [$dRead_s5goQ $dRead1_s5goR] \u []
                  let {
                    sat_s5goS [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Either.Either a_X5dY1 b_X5dY3)
                    [LclId] =
                        [$dRead_s5goQ $dRead1_s5goR] \r [eta_B2 eta_B1]
                            Data.Either.$fReadEither1 $dRead_s5goQ $dRead1_s5goR eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s5goS
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s5goT;

Data.Either.$fReadEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Read.Read (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_s5goU $dRead1_s5goV]
        let {
          sat_s5goZ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Either.Either a_X5dXZ b_X5dY1]
          [LclId] =
              [$dRead_s5goU $dRead1_s5goV] \u []
                  Data.Either.$fReadEither_$creadListPrec
                      $dRead_s5goU $dRead1_s5goV; } in
        let {
          sat_s5goY [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_X5dXZ b_X5dY1)
          [LclId] =
              [$dRead_s5goU $dRead1_s5goV] \r [eta_B2 eta_B1]
                  Data.Either.$fReadEither1
                      $dRead_s5goU $dRead1_s5goV eta_B2 eta_B1; } in
        let {
          sat_s5goX [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Either.Either a_X5dXZ b_X5dY1]
          [LclId] =
              [$dRead_s5goU $dRead1_s5goV] \u []
                  Data.Either.$fReadEither_$creadList
                      $dRead_s5goU $dRead1_s5goV; } in
        let {
          sat_s5goW [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Either.Either a_X5dXZ b_X5dY1)
          [LclId] =
              [$dRead_s5goU $dRead1_s5goV] \r [eta_B1]
                  Data.Either.$fReadEither_$creadsPrec
                      $dRead_s5goU $dRead1_s5goV eta_B1;
        } in  GHC.Read.C:Read [sat_s5goW sat_s5goX sat_s5goY sat_s5goZ];

Data.Either.$fOrdEither_$c<
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gp0 $dOrd1_s5gp1 a1_s5gp2 b1_s5gp3]
        case a1_s5gp2 of {
          Data.Either.Left a2_s5gp5 [Occ=Once] ->
              case b1_s5gp3 of {
                Data.Either.Left b2_s5gp7 [Occ=Once] ->
                    GHC.Classes.< $dOrd_s5gp0 a2_s5gp5 b2_s5gp7;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Either.Right a2_s5gp9 [Occ=Once] ->
              case b1_s5gp3 of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right b2_s5gpc [Occ=Once] ->
                    GHC.Classes.< $dOrd1_s5gp1 a2_s5gp9 b2_s5gpc;
              };
        };

Data.Either.$fOrdEither_$ccompare
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b
     -> Data.Either.Either a b -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gpd $dOrd1_s5gpe a1_s5gpf b1_s5gpg]
        case a1_s5gpf of {
          Data.Either.Left a2_s5gpi [Occ=Once] ->
              case b1_s5gpg of {
                Data.Either.Left b2_s5gpk [Occ=Once] ->
                    GHC.Classes.compare $dOrd_s5gpd a2_s5gpi b2_s5gpk;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Either.Right a2_s5gpm [Occ=Once] ->
              case b1_s5gpg of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Either.Right b2_s5gpp [Occ=Once] ->
                    GHC.Classes.compare $dOrd1_s5gpe a2_s5gpm b2_s5gpp;
              };
        };

Data.Either.$fEqEither_$c==
  :: forall a b.
     (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s5gpq $dEq1_s5gpr ds_s5gps ds1_s5gpt]
        case ds_s5gps of {
          Data.Either.Left a1_s5gpv [Occ=Once] ->
              case ds1_s5gpt of {
                Data.Either.Left b1_s5gpx [Occ=Once] ->
                    GHC.Classes.== $dEq_s5gpq a1_s5gpv b1_s5gpx;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right a1_s5gpz [Occ=Once] ->
              case ds1_s5gpt of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right b1_s5gpC [Occ=Once] ->
                    GHC.Classes.== $dEq1_s5gpr a1_s5gpz b1_s5gpC;
              };
        };

Data.Either.$fEqEither_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s5gpD $dEq1_s5gpE eta_s5gpF eta1_s5gpG]
        case eta_s5gpF of {
          Data.Either.Left a1_s5gpI [Occ=Once] ->
              case eta1_s5gpG of {
                Data.Either.Left b1_s5gpK [Occ=Once] ->
                    case GHC.Classes.== $dEq_s5gpD a1_s5gpI b1_s5gpK of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Either.Right a1_s5gpN [Occ=Once] ->
              case eta1_s5gpG of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
                Data.Either.Right b1_s5gpQ [Occ=Once] ->
                    case GHC.Classes.== $dEq1_s5gpE a1_s5gpN b1_s5gpQ of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Either.$fEqEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     GHC.Classes.Eq (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s5gpS $dEq1_s5gpT]
        let {
          sat_s5gpV [Occ=Once]
            :: Data.Either.Either a_a5dVh b_a5dVi
               -> Data.Either.Either a_a5dVh b_a5dVi -> GHC.Types.Bool
          [LclId] =
              [$dEq_s5gpS $dEq1_s5gpT] \r [eta_B2 eta_B1]
                  Data.Either.$fEqEither_$c/=
                      $dEq_s5gpS $dEq1_s5gpT eta_B2 eta_B1; } in
        let {
          sat_s5gpU [Occ=Once]
            :: Data.Either.Either a_a5dVh b_a5dVi
               -> Data.Either.Either a_a5dVh b_a5dVi -> GHC.Types.Bool
          [LclId] =
              [$dEq_s5gpS $dEq1_s5gpT] \r [eta_B2 eta_B1]
                  Data.Either.$fEqEither_$c== $dEq_s5gpS $dEq1_s5gpT eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s5gpU sat_s5gpV];

Data.Either.$fOrdEither_$cp1Ord
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     GHC.Classes.Eq (Data.Either.Either a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gpW $dOrd1_s5gpX]
        let {
          sat_s5gpZ [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq b_a5dVB
          [LclId] =
              [$dOrd1_s5gpX] \u [] GHC.Classes.$p1Ord $dOrd1_s5gpX; } in
        let {
          sat_s5gpY [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_a5dVA
          [LclId] =
              [$dOrd_s5gpW] \u [] GHC.Classes.$p1Ord $dOrd_s5gpW;
        } in  Data.Either.$fEqEither sat_s5gpY sat_s5gpZ;

Data.Either.$fOrdEither_$c<=
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gq0 $dOrd1_s5gq1 a1_s5gq2 b1_s5gq3]
        case b1_s5gq3 of {
          Data.Either.Left a2_s5gq5 [Occ=Once] ->
              case a1_s5gq2 of {
                Data.Either.Left b2_s5gq7 [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5gq0 a2_s5gq5 b2_s5gq7 of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right a2_s5gqa [Occ=Once] ->
              case a1_s5gq2 of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
                Data.Either.Right b2_s5gqd [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5gq1 a2_s5gqa b2_s5gqd of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Either.$fOrdEither_$cmax
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b
     -> Data.Either.Either a b -> Data.Either.Either a b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gqf $dOrd1_s5gqg x_s5gqh y_s5gqi]
        case y_s5gqi of wild_s5gqj {
          Data.Either.Left a1_s5gqk [Occ=Once] ->
              case x_s5gqh of wild1_s5gql {
                Data.Either.Left b1_s5gqm [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5gqf a1_s5gqk b1_s5gqm of {
                      GHC.Types.False -> wild_s5gqj;
                      GHC.Types.True -> wild1_s5gql;
                    };
                Data.Either.Right _ [Occ=Dead] -> wild1_s5gql;
              };
          Data.Either.Right a1_s5gqp [Occ=Once] ->
              case x_s5gqh of wild1_s5gqq {
                Data.Either.Left _ [Occ=Dead] -> wild_s5gqj;
                Data.Either.Right b1_s5gqs [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5gqg a1_s5gqp b1_s5gqs of {
                      GHC.Types.False -> wild_s5gqj;
                      GHC.Types.True -> wild1_s5gqq;
                    };
              };
        };

Data.Either.$fOrdEither_$c>=
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gqu $dOrd1_s5gqv a1_s5gqw b1_s5gqx]
        case a1_s5gqw of {
          Data.Either.Left a2_s5gqz [Occ=Once] ->
              case b1_s5gqx of {
                Data.Either.Left b2_s5gqB [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5gqu a2_s5gqz b2_s5gqB of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right a2_s5gqE [Occ=Once] ->
              case b1_s5gqx of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
                Data.Either.Right b2_s5gqH [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5gqv a2_s5gqE b2_s5gqH of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Either.$fOrdEither_$cmin
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b
     -> Data.Either.Either a b -> Data.Either.Either a b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gqJ $dOrd1_s5gqK x_s5gqL y_s5gqM]
        case y_s5gqM of wild_s5gqN {
          Data.Either.Left a1_s5gqO [Occ=Once] ->
              case x_s5gqL of wild1_s5gqP {
                Data.Either.Left b1_s5gqQ [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5gqJ a1_s5gqO b1_s5gqQ of {
                      GHC.Types.False -> wild1_s5gqP;
                      GHC.Types.True -> wild_s5gqN;
                    };
                Data.Either.Right _ [Occ=Dead] -> wild_s5gqN;
              };
          Data.Either.Right a1_s5gqT [Occ=Once] ->
              case x_s5gqL of wild1_s5gqU {
                Data.Either.Left _ [Occ=Dead] -> wild1_s5gqU;
                Data.Either.Right b1_s5gqW [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5gqK a1_s5gqT b1_s5gqW of {
                      GHC.Types.False -> wild1_s5gqU;
                      GHC.Types.True -> wild_s5gqN;
                    };
              };
        };

Data.Either.$fOrdEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     GHC.Classes.Ord (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s5gqY $dOrd1_s5gqZ]
        let {
          sat_s5gr9 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$cmin
                      $dOrd_s5gqY $dOrd1_s5gqZ eta_B2 eta_B1; } in
        let {
          sat_s5gr8 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$cmax
                      $dOrd_s5gqY $dOrd1_s5gqZ eta_B2 eta_B1; } in
        let {
          sat_s5gr7 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$c>=
                      $dOrd_s5gqY $dOrd1_s5gqZ eta_B2 eta_B1; } in
        let {
          sat_s5gr6 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [a1_s5gr4 b1_s5gr5]
                  Data.Either.$fOrdEither_$c<
                      $dOrd_s5gqY $dOrd1_s5gqZ b1_s5gr5 a1_s5gr4; } in
        let {
          sat_s5gr3 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$c<=
                      $dOrd_s5gqY $dOrd1_s5gqZ eta_B2 eta_B1; } in
        let {
          sat_s5gr2 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$c<
                      $dOrd_s5gqY $dOrd1_s5gqZ eta_B2 eta_B1; } in
        let {
          sat_s5gr1 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$ccompare
                      $dOrd_s5gqY $dOrd1_s5gqZ eta_B2 eta_B1; } in
        let {
          sat_s5gr0 [Occ=Once]
            :: GHC.Classes.Eq (Data.Either.Either a_a5dVA b_a5dVB)
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \u []
                  Data.Either.$fOrdEither_$cp1Ord $dOrd_s5gqY $dOrd1_s5gqZ;
        } in 
          GHC.Classes.C:Ord [sat_s5gr0
                             sat_s5gr1
                             sat_s5gr2
                             sat_s5gr3
                             sat_s5gr6
                             sat_s5gr7
                             sat_s5gr8
                             sat_s5gr9];

Data.Either.either
  :: forall a c b.
     (a -> c) -> (b -> c) -> Data.Either.Either a b -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s5gra ds_s5grb ds1_s5grc]
        case ds1_s5grc of {
          Data.Either.Left x_s5gre [Occ=Once] -> f_s5gra x_s5gre;
          Data.Either.Right y_s5grf [Occ=Once] -> ds_s5grb y_s5grf;
        };

Data.Either.$wpartitionEithers [InlPrag=NOUSERINLINE[0],
                                Occ=LoopBreaker]
  :: forall a b. [Data.Either.Either a b] -> (# [a], [b] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [w_s5grg]
        case w_s5grg of {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : y_s5gri [Occ=Once!] ys_s5grj [Occ=Once] ->
              let {
                eta_s5grk [Dmd=<L,U(1*U,1*U)>] :: ([a_s5enu], [b_s5env])
                [LclId] =
                    [ys_s5grj] \u []
                        case Data.Either.$wpartitionEithers ys_s5grj of {
                          (#,#) ww1_s5grm [Occ=Once] ww2_s5grn [Occ=Once] ->
                              (,) [ww1_s5grm ww2_s5grn];
                        };
              } in 
                case y_s5gri of {
                  Data.Either.Left x_s5grp [Occ=Once] ->
                      let {
                        sat_s5gry [Occ=Once] :: [b_s5env]
                        [LclId] =
                            [eta_s5grk] \u []
                                case eta_s5grk of {
                                  (,) _ [Occ=Dead] r_s5grx [Occ=Once] -> r_s5grx;
                                }; } in
                      let {
                        sat_s5grt [Occ=Once] :: [a_s5enu]
                        [LclId] =
                            [eta_s5grk] \u []
                                case eta_s5grk of {
                                  (,) l_s5grr [Occ=Once] _ [Occ=Dead] -> l_s5grr;
                                }; } in
                      let {
                        sat_s5gru [Occ=Once] :: [a_s5enu]
                        [LclId] =
                            CCCS :! [x_s5grp sat_s5grt];
                      } in  (#,#) [sat_s5gru sat_s5gry];
                  Data.Either.Right y1_s5grz [Occ=Once] ->
                      let {
                        sat_s5grH [Occ=Once] :: [b_s5env]
                        [LclId] =
                            [eta_s5grk] \u []
                                case eta_s5grk of {
                                  (,) _ [Occ=Dead] r_s5grG [Occ=Once] -> r_s5grG;
                                }; } in
                      let {
                        sat_s5grI [Occ=Once] :: [b_s5env]
                        [LclId] =
                            CCCS :! [y1_s5grz sat_s5grH]; } in
                      let {
                        sat_s5grD [Occ=Once] :: [a_s5enu]
                        [LclId] =
                            [eta_s5grk] \u []
                                case eta_s5grk of {
                                  (,) l_s5grB [Occ=Once] _ [Occ=Dead] -> l_s5grB;
                                };
                      } in  (#,#) [sat_s5grD sat_s5grI];
                };
        };

Data.Either.partitionEithers [InlPrag=NOUSERINLINE[0]]
  :: forall a b. [Data.Either.Either a b] -> ([a], [b])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_s5grJ]
        case Data.Either.$wpartitionEithers w_s5grJ of {
          (#,#) ww1_s5grL [Occ=Once] ww2_s5grM [Occ=Once] ->
              (,) [ww1_s5grL ww2_s5grM];
        };

poly_go_r5exd :: forall a b. [Data.Either.Either a b] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds_s5grN]
        case ds_s5grN of {
          [] -> [] [];
          : y_s5grP [Occ=Once!] ys_s5grQ [Occ=Once*] ->
              case y_s5grP of {
                Data.Either.Left a1_s5grS [Occ=Once] ->
                    let {
                      sat_s5grT [Occ=Once] :: [a_a5dTY]
                      [LclId] =
                          [ys_s5grQ] \u [] poly_go_r5exd ys_s5grQ;
                    } in  : [a1_s5grS sat_s5grT];
                Data.Either.Right _ [Occ=Dead] -> poly_go_r5exd ys_s5grQ;
              };
        };

Data.Either.lefts [InlPrag=INLINABLE]
  :: forall a b. [Data.Either.Either a b] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s5grV] poly_go_r5exd x_s5grV;

poly_go1_r5exe :: forall a b. [Data.Either.Either a b] -> [b]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds_s5grW]
        case ds_s5grW of {
          [] -> [] [];
          : y_s5grY [Occ=Once!] ys_s5grZ [Occ=Once*] ->
              case y_s5grY of {
                Data.Either.Left _ [Occ=Dead] -> poly_go1_r5exe ys_s5grZ;
                Data.Either.Right a1_s5gs2 [Occ=Once] ->
                    let {
                      sat_s5gs3 [Occ=Once] :: [b_a5dTV]
                      [LclId] =
                          [ys_s5grZ] \u [] poly_go1_r5exe ys_s5grZ;
                    } in  : [a1_s5gs2 sat_s5gs3];
              };
        };

Data.Either.rights [InlPrag=INLINABLE]
  :: forall a b. [Data.Either.Either a b] -> [b]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s5gs4] poly_go1_r5exe x_s5gs4;

Data.Either.isLeft
  :: forall a b. Data.Either.Either a b -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5gs5]
        case ds_s5gs5 of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
          Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Either.isRight
  :: forall a b. Data.Either.Either a b -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5gs9]
        case ds_s5gs9 of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
          Data.Either.Right _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Either.fromLeft
  :: forall a b. a -> Data.Either.Either a b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5gsd ds1_s5gse]
        case ds1_s5gse of {
          Data.Either.Left a1_s5gsg [Occ=Once] -> a1_s5gsg;
          Data.Either.Right _ [Occ=Dead] -> ds_s5gsd;
        };

Data.Either.fromRight
  :: forall b a. b -> Data.Either.Either a b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5gsi ds1_s5gsj]
        case ds1_s5gsj of {
          Data.Either.Left _ [Occ=Dead] -> ds_s5gsi;
          Data.Either.Right b1_s5gsm [Occ=Once] -> b1_s5gsm;
        };

Data.Either.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Either.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$trModule4];

Data.Either.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Either"#;

Data.Either.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$trModule2];

Data.Either.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Either.$trModule3
                                     Data.Either.$trModule1];

$krep_r5exf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_r5exg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Either.$tcEither2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Either"#;

Data.Either.$tcEither1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$tcEither2];

Data.Either.$tcEither :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16074290893719807138##
                                    14958199358864670905##
                                    Data.Either.$trModule
                                    Data.Either.$tcEither1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep2_r5exh :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r5exf GHC.Types.[]];

$krep3_r5exi :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r5exg $krep2_r5exh];

$krep4_r5exj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Either.$tcEither
                                              $krep3_r5exi];

Data.Either.$tc'Left1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r5exg $krep4_r5exj];

Data.Either.$tc'Left3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Left"#;

Data.Either.$tc'Left2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$tc'Left3];

Data.Either.$tc'Left :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14915236324383360020##
                                    11027491440201056612##
                                    Data.Either.$trModule
                                    Data.Either.$tc'Left2
                                    2#
                                    Data.Either.$tc'Left1];

Data.Either.$tc'Right1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r5exf $krep4_r5exj];

Data.Either.$tc'Right3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Right"#;

Data.Either.$tc'Right2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$tc'Right3];

Data.Either.$tc'Right :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10395468319011834275##
                                    16371021254350888909##
                                    Data.Either.$trModule
                                    Data.Either.$tc'Right2
                                    2#
                                    Data.Either.$tc'Right1];

Data.Either.Left :: forall a b. a -> Data.Either.Either a b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Either.Left [eta_B1];

Data.Either.Right :: forall a b. b -> Data.Either.Either a b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Either.Right [eta_B1];


==================== STG syntax: ====================
2018-03-16 16:00:16.009722098 UTC

Data.Either.$fApplicativeEither_$cfmap
  :: forall a1 a2 b.
     (a2 -> b) -> Data.Either.Either a1 a2 -> Data.Either.Either a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5gmh ds1_s5gmi]
        case ds1_s5gmi of {
          Data.Either.Left x_s5gmk [Occ=Once] -> wild_s5gmj;
          Data.Either.Right y_s5gml [Occ=Once] ->
              let {
                sat_s5gmm [Occ=Once] :: b_a5e0k
                [LclId] =
                    [ds_s5gmh y_s5gml] \u [] ds_s5gmh y_s5gml;
              } in  Data.Either.Right [sat_s5gmm];
        };

Data.Either.$fFunctorEither_$c<$
  :: forall a1 a2 b.
     a2 -> Data.Either.Either a1 b -> Data.Either.Either a1 a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_s5gmn ds_s5gmo]
        case ds_s5gmo of {
          Data.Either.Left x1_s5gmq [Occ=Once] -> wild_s5gmp;
          Data.Either.Right _ [Occ=Dead] -> Data.Either.Right [x_s5gmn];
        };

Data.Either.$fFunctorEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Functor (Data.Either.Either a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Either.$fApplicativeEither_$cfmap
                                       Data.Either.$fFunctorEither_$c<$];

lvl_r5exb :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: positive multiplier expected"#;

Data.Either.$fSemigroupEither1
  :: forall a b. Data.Either.Either a b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r5exb of sat_s5gms {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s5gms;
        };

Data.Either.$fSemigroupEither2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Either.$fSemigroupEither_$cstimes
  :: forall a b1 b2.
     GHC.Real.Integral b2 =>
     b2 -> Data.Either.Either a b1 -> Data.Either.Either a b1
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s5gmt eta_s5gmu eta1_s5gmv]
        case
            GHC.Real.$p1Integral $dIntegral_s5gmt
        of
        $dReal_s5gmw [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s5gmz [Occ=Once] :: b1_a5e03
                [LclId] =
                    [$dReal_s5gmw] \u []
                        case GHC.Real.$p1Real $dReal_s5gmw of sat_s5gmy {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s5gmy Data.Either.$fSemigroupEither2;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s5gmw of sat_s5gmx {
                  __DEFAULT ->
                      case GHC.Classes.<= sat_s5gmx eta_s5gmu sat_s5gmz of {
                        GHC.Types.False -> eta1_s5gmv;
                        GHC.Types.True -> Data.Either.$fSemigroupEither1;
                      };
                };
        };

Data.Either.$fSemigroupEither_$c<>
  :: forall a b.
     Data.Either.Either a b
     -> Data.Either.Either a b -> Data.Either.Either a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5gmB b1_s5gmC]
        case ds_s5gmB of wild_s5gmD {
          Data.Either.Left _ [Occ=Dead] -> b1_s5gmC;
          Data.Either.Right _ [Occ=Dead] -> wild_s5gmD;
        };

Data.Either.$fSemigroupEither3 [Occ=LoopBreaker]
  :: forall a b.
     Data.Either.Either a b
     -> [Data.Either.Either a b] -> Data.Either.Either a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b1_s5gmG ds1_s5gmH]
        case ds1_s5gmH of {
          [] -> b1_s5gmG;
          : c_s5gmJ [Occ=Once] cs_s5gmK [Occ=Once] ->
              case b1_s5gmG of wild_s5gmL {
                Data.Either.Left _ [Occ=Dead] ->
                    Data.Either.$fSemigroupEither3 c_s5gmJ cs_s5gmK;
                Data.Either.Right _ [Occ=Dead] -> wild_s5gmL;
              };
        };

Data.Either.$fSemigroupEither_$csconcat
  :: forall a b.
     GHC.Base.NonEmpty (Data.Either.Either a b)
     -> Data.Either.Either a b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s5gmO]
        case ds_s5gmO of {
          GHC.Base.:| a1_s5gmQ [Occ=Once] as_s5gmR [Occ=Once] ->
              Data.Either.$fSemigroupEither3 a1_s5gmQ as_s5gmR;
        };

Data.Either.$fSemigroupEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. GHC.Base.Semigroup (Data.Either.Either a b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Either.$fSemigroupEither_$c<>
                                         Data.Either.$fSemigroupEither_$csconcat
                                         Data.Either.$fSemigroupEither_$cstimes];

Data.Either.$fApplicativeEither_$c<*>
  :: forall e a b.
     Data.Either.Either e (a -> b)
     -> Data.Either.Either e a -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5gmS ds1_s5gmT]
        case ds_s5gmS of {
          Data.Either.Left e1_s5gmV [Occ=Once] -> wild_s5gmU;
          Data.Either.Right f_s5gmW [Occ=Once] ->
              Data.Either.$fApplicativeEither_$cfmap f_s5gmW ds1_s5gmT;
        };

Data.Either.$fApplicativeEither_$cliftA2
  :: forall e a b c.
     (a -> b -> c)
     -> Data.Either.Either e a
     -> Data.Either.Either e b
     -> Data.Either.Either e c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f1_s5gmX x_s5gmY]
        let {
          ds_s5gmZ [Occ=OnceL!]
            :: Data.Either.Either e_a5dYS (b_a5dZl -> c_a5dZm)
          [LclId] =
              [f1_s5gmX x_s5gmY] \u []
                  case x_s5gmY of {
                    Data.Either.Left x1_s5gn1 [Occ=Once] -> wild_s5gn0;
                    Data.Either.Right y_s5gn2 [Occ=Once] ->
                        let {
                          sat_s5gn3 [Occ=Once] :: b_a5dZl -> c_a5dZm
                          [LclId] =
                              [f1_s5gmX y_s5gn2] \u [] f1_s5gmX y_s5gn2;
                        } in  Data.Either.Right [sat_s5gn3];
                  }; } in
        let {
          sat_s5gn8 [Occ=OnceT[0]]
            :: Data.Either.Either e_a5dYS b_a5dZl
               -> Data.Either.Either e_a5dYS c_a5dZm
          [LclId] =
              [ds_s5gmZ] \r [ds1_s5gn4]
                  case ds_s5gmZ of {
                    Data.Either.Left e1_s5gn6 [Occ=Once] -> wild_s5gn5;
                    Data.Either.Right f_s5gn7 [Occ=Once] ->
                        Data.Either.$fApplicativeEither_$cfmap f_s5gn7 ds1_s5gn4;
                  };
        } in  sat_s5gn8;

Data.Either.$fApplicativeEither_$c*>
  :: forall e a b.
     Data.Either.Either e a
     -> Data.Either.Either e b -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s5gn9 a2_s5gna]
        case a1_s5gn9 of {
          Data.Either.Left x_s5gnc [Occ=Once] -> wild_s5gnb;
          Data.Either.Right _ [Occ=Dead] -> a2_s5gna;
        };

Data.Either.$fApplicativeEither_$c<*
  :: forall e a b.
     Data.Either.Either e a
     -> Data.Either.Either e b -> Data.Either.Either e a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [x_s5gne ds_s5gnf]
        case x_s5gne of wild_s5gng {
          Data.Either.Left _ [Occ=Dead] -> wild_s5gng;
          Data.Either.Right _ [Occ=Dead] ->
              case ds_s5gnf of {
                Data.Either.Left x1_s5gnk [Occ=Once] -> wild1_s5gnj;
                Data.Either.Right _ [Occ=Dead] -> wild_s5gng;
              };
        };

Data.Either.$fApplicativeEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall e. GHC.Base.Applicative (Data.Either.Either e)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Either.$fFunctorEither
                                           Data.Either.Right
                                           Data.Either.$fApplicativeEither_$c<*>
                                           Data.Either.$fApplicativeEither_$cliftA2
                                           Data.Either.$fApplicativeEither_$c*>
                                           Data.Either.$fApplicativeEither_$c<*];

Data.Either.$fMonadEither_$c>>=
  :: forall e a b.
     Data.Either.Either e a
     -> (a -> Data.Either.Either e b) -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s5gnm ds1_s5gnn]
        case ds_s5gnm of {
          Data.Either.Left l_s5gnp [Occ=Once] -> wild_s5gno;
          Data.Either.Right r_s5gnq [Occ=Once] -> ds1_s5gnn r_s5gnq;
        };

Data.Either.$fMonadEither_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall e a b.
     Data.Either.Either e a
     -> Data.Either.Either e b -> Data.Either.Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Either.$fApplicativeEither_$c*> eta_B2 eta_B1;

lvl1_r5exc
  :: forall e a. [GHC.Types.Char] -> Data.Either.Either e a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s5gnr] GHC.Err.errorWithoutStackTrace eta_s5gnr;

Data.Either.$fMonadEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall e. GHC.Base.Monad (Data.Either.Either e)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Either.$fApplicativeEither
                                     Data.Either.$fMonadEither_$c>>=
                                     Data.Either.$fMonadEither_$c>>
                                     Data.Either.Right
                                     lvl1_r5exc];

Data.Either.$fShowEither5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Left "#;

Data.Either.$fShowEither4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fShowEither5;

Data.Either.$fReadEither4 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Either.$fShowEither3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Right "#;

Data.Either.$fShowEither2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fShowEither3;

Data.Either.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Prim.Int# -> Data.Either.Either a b -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s5gns w1_s5gnt ww_s5gnu w2_s5gnv]
        case w2_s5gnv of {
          Data.Either.Left b1_s5gnx [Occ=Once] ->
              let {
                g_s5gny [Occ=OnceL*!, Dmd=<L,C(U)>]
                  :: GHC.Base.String -> GHC.Base.String
                [LclId] =
                    [w_s5gns b1_s5gnx] \u []
                        GHC.Show.showsPrec w_s5gns Data.Either.$fReadEither4 b1_s5gnx;
              } in 
                case >=# [ww_s5gnu 11#] of {
                  __DEFAULT ->
                      let {
                        sat_s5gnC [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5gny] \r [x_s5gnA]
                                let {
                                  sat_s5gnB [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5gny x_s5gnA] \s [] g_s5gny x_s5gnA;
                                } in  GHC.Base.++ Data.Either.$fShowEither4 sat_s5gnB;
                      } in  sat_s5gnC;
                  1# ->
                      let {
                        sat_s5gnH [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5gny] \r [x_s5gnD]
                                let {
                                  sat_s5gnG [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5gny x_s5gnD] \u []
                                          let {
                                            sat_s5gnF [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                            [LclId] =
                                                [g_s5gny x_s5gnD] \s []
                                                    let {
                                                      sat_s5gnE [Occ=Once] :: GHC.Base.String
                                                      [LclId] =
                                                          CCCS :! [GHC.Show.$fShow(,)2 x_s5gnD];
                                                    } in  g_s5gny sat_s5gnE;
                                          } in  GHC.Base.++ Data.Either.$fShowEither4 sat_s5gnF;
                                } in  : [GHC.Show.$fShow(,)4 sat_s5gnG];
                      } in  sat_s5gnH;
                };
          Data.Either.Right b1_s5gnI [Occ=Once] ->
              let {
                g_s5gnJ [Occ=OnceL*!, Dmd=<L,C(U)>]
                  :: GHC.Base.String -> GHC.Base.String
                [LclId] =
                    [w1_s5gnt b1_s5gnI] \u []
                        GHC.Show.showsPrec w1_s5gnt Data.Either.$fReadEither4 b1_s5gnI;
              } in 
                case >=# [ww_s5gnu 11#] of {
                  __DEFAULT ->
                      let {
                        sat_s5gnN [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5gnJ] \r [x_s5gnL]
                                let {
                                  sat_s5gnM [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5gnJ x_s5gnL] \s [] g_s5gnJ x_s5gnL;
                                } in  GHC.Base.++ Data.Either.$fShowEither2 sat_s5gnM;
                      } in  sat_s5gnN;
                  1# ->
                      let {
                        sat_s5gnS [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                        [LclId] =
                            [g_s5gnJ] \r [x_s5gnO]
                                let {
                                  sat_s5gnR [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      [g_s5gnJ x_s5gnO] \u []
                                          let {
                                            sat_s5gnQ [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                            [LclId] =
                                                [g_s5gnJ x_s5gnO] \s []
                                                    let {
                                                      sat_s5gnP [Occ=Once] :: GHC.Base.String
                                                      [LclId] =
                                                          CCCS :! [GHC.Show.$fShow(,)2 x_s5gnO];
                                                    } in  g_s5gnJ sat_s5gnP;
                                          } in  GHC.Base.++ Data.Either.$fShowEither2 sat_s5gnQ;
                                } in  : [GHC.Show.$fShow(,)4 sat_s5gnR];
                      } in  sat_s5gnS;
                };
        };

Data.Either.$fShowEither_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Types.Int -> Data.Either.Either a b -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s5gnT w1_s5gnU w2_s5gnV w3_s5gnW]
        case w2_s5gnV of {
          GHC.Types.I# ww1_s5gnY [Occ=Once] ->
              Data.Either.$w$cshowsPrec w_s5gnT w1_s5gnU ww1_s5gnY w3_s5gnW;
        };

Data.Either.$fShowEither_$cshow
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     Data.Either.Either a b -> GHC.Base.String
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s5gnZ $dShow1_s5go0 x_s5go1]
        case x_s5go1 of {
          Data.Either.Left b1_s5go3 [Occ=Once] ->
              let {
                sat_s5go4 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow_s5gnZ b1_s5go3] \s []
                        GHC.Show.showsPrec
                            $dShow_s5gnZ Data.Either.$fReadEither4 b1_s5go3 GHC.Types.[];
              } in  GHC.Base.++ Data.Either.$fShowEither4 sat_s5go4;
          Data.Either.Right b1_s5go5 [Occ=Once] ->
              let {
                sat_s5go6 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [$dShow1_s5go0 b1_s5go5] \s []
                        GHC.Show.showsPrec
                            $dShow1_s5go0 Data.Either.$fReadEither4 b1_s5go5 GHC.Types.[];
              } in  GHC.Base.++ Data.Either.$fShowEither2 sat_s5go6;
        };

Data.Either.$fShowEither1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Either.$fShowEither_$cshowList
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     [Data.Either.Either a b] -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s5go7 $dShow1_s5go8 ls_s5go9 s_s5goa]
        let {
          sat_s5goc [Occ=Once]
            :: Data.Either.Either a_a5dXF b_a5dXG -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s5go7 $dShow1_s5go8] \r [w_s5gob]
                  Data.Either.$w$cshowsPrec $dShow_s5go7 $dShow1_s5go8 0# w_s5gob;
        } in  GHC.Show.showList__ sat_s5goc ls_s5go9 s_s5goa;

Data.Either.$fShowEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Show.Show a, GHC.Show.Show b) =>
     GHC.Show.Show (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s5god $dShow1_s5goe]
        let {
          sat_s5goh [Occ=Once]
            :: [Data.Either.Either a_a5dXF b_a5dXG] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s5god $dShow1_s5goe] \r [eta_B2 eta_B1]
                  Data.Either.$fShowEither_$cshowList
                      $dShow_s5god $dShow1_s5goe eta_B2 eta_B1; } in
        let {
          sat_s5gog [Occ=Once]
            :: Data.Either.Either a_a5dXF b_a5dXG -> GHC.Base.String
          [LclId] =
              [$dShow_s5god $dShow1_s5goe] \r [eta_B1]
                  Data.Either.$fShowEither_$cshow
                      $dShow_s5god $dShow1_s5goe eta_B1; } in
        let {
          sat_s5gof [Occ=Once]
            :: GHC.Types.Int
               -> Data.Either.Either a_a5dXF b_a5dXG -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s5god $dShow1_s5goe] \r [eta_B2 eta_B1]
                  Data.Either.$fShowEither_$cshowsPrec
                      $dShow_s5god $dShow1_s5goe eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s5gof sat_s5gog sat_s5goh];

Data.Either.$fReadEither3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Left"#;

Data.Either.$fReadEither2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fReadEither3;

Data.Either.$fReadEither_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Either.$fReadEither2];

Data.Either.$fReadEither6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Right"#;

Data.Either.$fReadEither5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Either.$fReadEither6;

Data.Either.$fReadEither_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Either.$fReadEither5];

Data.Either.$fReadEither1
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Either.Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5goi $dRead1_s5goj eta_s5gok eta1_s5gol]
        let {
          sat_s5goI [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_a5dWE b_a5dWF)
          [LclId] =
              [$dRead_s5goi $dRead1_s5goj] \r [n_s5gom eta2_s5gon]
                  case n_s5gom of {
                    GHC.Types.I# x_s5gop ->
                        let {
                          karg_s5goq [Occ=Once*] :: Text.ParserCombinators.ReadP.P b2_X3ngu
                          [LclId] =
                              [$dRead1_s5goj eta2_s5gon x_s5gop] \u []
                                  case <=# [x_s5gop 10#] of {
                                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                    1# ->
                                        let {
                                          sat_s5gow [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                          [LclId] =
                                              [$dRead1_s5goj eta2_s5gon] \r [a1_s5gos]
                                                  let {
                                                    sat_s5gov [Occ=Once]
                                                      :: b_a5dWF
                                                         -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                                    [LclId] =
                                                        [eta2_s5gon] \r [a2_s5got]
                                                            let {
                                                              sat_s5gou [Occ=Once]
                                                                :: Data.Either.Either
                                                                     a_a5dWE b_a5dWF
                                                              [LclId] =
                                                                  CCCS Data.Either.Right! [a2_s5got];
                                                            } in  eta2_s5gon sat_s5gou;
                                                  } in 
                                                    GHC.Read.readPrec
                                                        $dRead1_s5goj
                                                        Data.Either.$fReadEither4
                                                        sat_s5gov;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Either.$fReadEither_lexeme1 sat_s5gow
                                          of
                                          { Unit# ww1_s5goy [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s5goy];
                                          };
                                  };
                        } in 
                          case <=# [x_s5gop 10#] of {
                            __DEFAULT ->
                                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                    Text.ParserCombinators.ReadP.Fail karg_s5goq;
                            1# ->
                                let {
                                  sat_s5goE [Occ=Once]
                                    :: () -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                  [LclId] =
                                      [$dRead_s5goi eta2_s5gon] \r [a1_s5goA]
                                          let {
                                            sat_s5goD [Occ=Once]
                                              :: a_a5dWE -> Text.ParserCombinators.ReadP.P b2_X3ngu
                                            [LclId] =
                                                [eta2_s5gon] \r [a2_s5goB]
                                                    let {
                                                      sat_s5goC [Occ=Once]
                                                        :: Data.Either.Either a_a5dWE b_a5dWF
                                                      [LclId] =
                                                          CCCS Data.Either.Left! [a2_s5goB];
                                                    } in  eta2_s5gon sat_s5goC;
                                          } in 
                                            GHC.Read.readPrec
                                                $dRead_s5goi Data.Either.$fReadEither4 sat_s5goD;
                                } in 
                                  case
                                      Text.Read.Lex.$wexpect
                                          Data.Either.$fReadEither_lexeme sat_s5goE
                                  of
                                  { Unit# ww1_s5goG [Occ=Once] ->
                                        let {
                                          sat_s5goH [Occ=Once]
                                            :: Text.ParserCombinators.ReadP.P b2_X3ngu
                                          [LclId] =
                                              CCCS Text.ParserCombinators.ReadP.Look! [ww1_s5goG];
                                        } in 
                                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                              sat_s5goH karg_s5goq;
                                  };
                          };
                  };
        } in  GHC.Read.list3 sat_s5goI eta_s5gok eta1_s5gol;

Data.Either.$fReadEither_$creadsPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Either.Either a b)
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5goJ $dRead1_s5goK n_s5goL]
        let {
          sat_s5goM [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Either.Either a_X5dY2 b_X5dY4)
          [LclId] =
              [$dRead_s5goJ $dRead1_s5goK n_s5goL] \u []
                  Data.Either.$fReadEither1
                      $dRead_s5goJ
                      $dRead1_s5goK
                      n_s5goL
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s5goM;

Data.Either.$fReadEither_$creadListPrec
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Either.Either a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5goN $dRead1_s5goO]
        let {
          sat_s5goP [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_X5dY0 b_X5dY2)
          [LclId] =
              [$dRead_s5goN $dRead1_s5goO] \r [eta_B2 eta_B1]
                  Data.Either.$fReadEither1 $dRead_s5goN $dRead1_s5goO eta_B2 eta_B1;
        } in  GHC.Read.list sat_s5goP;

Data.Either.$fReadEither_$creadList
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     Text.ParserCombinators.ReadP.ReadS [Data.Either.Either a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=OtherCon []] =
    [] \r [$dRead_s5goQ $dRead1_s5goR]
        let {
          sat_s5goT [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Either.Either a_X5dY1 b_X5dY3]
          [LclId] =
              [$dRead_s5goQ $dRead1_s5goR] \u []
                  let {
                    sat_s5goS [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Either.Either a_X5dY1 b_X5dY3)
                    [LclId] =
                        [$dRead_s5goQ $dRead1_s5goR] \r [eta_B2 eta_B1]
                            Data.Either.$fReadEither1 $dRead_s5goQ $dRead1_s5goR eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s5goS
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s5goT;

Data.Either.$fReadEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Read.Read a, GHC.Read.Read b) =>
     GHC.Read.Read (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_s5goU $dRead1_s5goV]
        let {
          sat_s5goZ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Either.Either a_X5dXZ b_X5dY1]
          [LclId] =
              [$dRead_s5goU $dRead1_s5goV] \u []
                  Data.Either.$fReadEither_$creadListPrec
                      $dRead_s5goU $dRead1_s5goV; } in
        let {
          sat_s5goY [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Either.Either a_X5dXZ b_X5dY1)
          [LclId] =
              [$dRead_s5goU $dRead1_s5goV] \r [eta_B2 eta_B1]
                  Data.Either.$fReadEither1
                      $dRead_s5goU $dRead1_s5goV eta_B2 eta_B1; } in
        let {
          sat_s5goX [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Either.Either a_X5dXZ b_X5dY1]
          [LclId] =
              [$dRead_s5goU $dRead1_s5goV] \u []
                  Data.Either.$fReadEither_$creadList
                      $dRead_s5goU $dRead1_s5goV; } in
        let {
          sat_s5goW [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Either.Either a_X5dXZ b_X5dY1)
          [LclId] =
              [$dRead_s5goU $dRead1_s5goV] \r [eta_B1]
                  Data.Either.$fReadEither_$creadsPrec
                      $dRead_s5goU $dRead1_s5goV eta_B1;
        } in  GHC.Read.C:Read [sat_s5goW sat_s5goX sat_s5goY sat_s5goZ];

Data.Either.$fOrdEither_$c<
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gp0 $dOrd1_s5gp1 a1_s5gp2 b1_s5gp3]
        case a1_s5gp2 of {
          Data.Either.Left a2_s5gp5 [Occ=Once] ->
              case b1_s5gp3 of {
                Data.Either.Left b2_s5gp7 [Occ=Once] ->
                    GHC.Classes.< $dOrd_s5gp0 a2_s5gp5 b2_s5gp7;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Either.Right a2_s5gp9 [Occ=Once] ->
              case b1_s5gp3 of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right b2_s5gpc [Occ=Once] ->
                    GHC.Classes.< $dOrd1_s5gp1 a2_s5gp9 b2_s5gpc;
              };
        };

Data.Either.$fOrdEither_$ccompare
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b
     -> Data.Either.Either a b -> GHC.Types.Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gpd $dOrd1_s5gpe a1_s5gpf b1_s5gpg]
        case a1_s5gpf of {
          Data.Either.Left a2_s5gpi [Occ=Once] ->
              case b1_s5gpg of {
                Data.Either.Left b2_s5gpk [Occ=Once] ->
                    GHC.Classes.compare $dOrd_s5gpd a2_s5gpi b2_s5gpk;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.LT [];
              };
          Data.Either.Right a2_s5gpm [Occ=Once] ->
              case b1_s5gpg of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.GT [];
                Data.Either.Right b2_s5gpp [Occ=Once] ->
                    GHC.Classes.compare $dOrd1_s5gpe a2_s5gpm b2_s5gpp;
              };
        };

Data.Either.$fEqEither_$c==
  :: forall a b.
     (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s5gpq $dEq1_s5gpr ds_s5gps ds1_s5gpt]
        case ds_s5gps of {
          Data.Either.Left a1_s5gpv [Occ=Once] ->
              case ds1_s5gpt of {
                Data.Either.Left b1_s5gpx [Occ=Once] ->
                    GHC.Classes.== $dEq_s5gpq a1_s5gpv b1_s5gpx;
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right a1_s5gpz [Occ=Once] ->
              case ds1_s5gpt of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
                Data.Either.Right b1_s5gpC [Occ=Once] ->
                    GHC.Classes.== $dEq1_s5gpr a1_s5gpz b1_s5gpC;
              };
        };

Data.Either.$fEqEither_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s5gpD $dEq1_s5gpE eta_s5gpF eta1_s5gpG]
        case eta_s5gpF of {
          Data.Either.Left a1_s5gpI [Occ=Once] ->
              case eta1_s5gpG of {
                Data.Either.Left b1_s5gpK [Occ=Once] ->
                    case GHC.Classes.== $dEq_s5gpD a1_s5gpI b1_s5gpK of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.True [];
              };
          Data.Either.Right a1_s5gpN [Occ=Once] ->
              case eta1_s5gpG of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
                Data.Either.Right b1_s5gpQ [Occ=Once] ->
                    case GHC.Classes.== $dEq1_s5gpE a1_s5gpN b1_s5gpQ of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Either.$fEqEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
     GHC.Classes.Eq (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s5gpS $dEq1_s5gpT]
        let {
          sat_s5gpV [Occ=Once]
            :: Data.Either.Either a_a5dVh b_a5dVi
               -> Data.Either.Either a_a5dVh b_a5dVi -> GHC.Types.Bool
          [LclId] =
              [$dEq_s5gpS $dEq1_s5gpT] \r [eta_B2 eta_B1]
                  Data.Either.$fEqEither_$c/=
                      $dEq_s5gpS $dEq1_s5gpT eta_B2 eta_B1; } in
        let {
          sat_s5gpU [Occ=Once]
            :: Data.Either.Either a_a5dVh b_a5dVi
               -> Data.Either.Either a_a5dVh b_a5dVi -> GHC.Types.Bool
          [LclId] =
              [$dEq_s5gpS $dEq1_s5gpT] \r [eta_B2 eta_B1]
                  Data.Either.$fEqEither_$c== $dEq_s5gpS $dEq1_s5gpT eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s5gpU sat_s5gpV];

Data.Either.$fOrdEither_$cp1Ord
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     GHC.Classes.Eq (Data.Either.Either a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gpW $dOrd1_s5gpX]
        let {
          sat_s5gpZ [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq b_a5dVB
          [LclId] =
              [$dOrd1_s5gpX] \u [] GHC.Classes.$p1Ord $dOrd1_s5gpX; } in
        let {
          sat_s5gpY [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_a5dVA
          [LclId] =
              [$dOrd_s5gpW] \u [] GHC.Classes.$p1Ord $dOrd_s5gpW;
        } in  Data.Either.$fEqEither sat_s5gpY sat_s5gpZ;

Data.Either.$fOrdEither_$c<=
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gq0 $dOrd1_s5gq1 a1_s5gq2 b1_s5gq3]
        case b1_s5gq3 of {
          Data.Either.Left a2_s5gq5 [Occ=Once] ->
              case a1_s5gq2 of {
                Data.Either.Left b2_s5gq7 [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5gq0 a2_s5gq5 b2_s5gq7 of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right a2_s5gqa [Occ=Once] ->
              case a1_s5gq2 of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
                Data.Either.Right b2_s5gqd [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5gq1 a2_s5gqa b2_s5gqd of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Either.$fOrdEither_$cmax
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b
     -> Data.Either.Either a b -> Data.Either.Either a b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gqf $dOrd1_s5gqg x_s5gqh y_s5gqi]
        case y_s5gqi of wild_s5gqj {
          Data.Either.Left a1_s5gqk [Occ=Once] ->
              case x_s5gqh of wild1_s5gql {
                Data.Either.Left b1_s5gqm [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5gqf a1_s5gqk b1_s5gqm of {
                      GHC.Types.False -> wild_s5gqj;
                      GHC.Types.True -> wild1_s5gql;
                    };
                Data.Either.Right _ [Occ=Dead] -> wild1_s5gql;
              };
          Data.Either.Right a1_s5gqp [Occ=Once] ->
              case x_s5gqh of wild1_s5gqq {
                Data.Either.Left _ [Occ=Dead] -> wild_s5gqj;
                Data.Either.Right b1_s5gqs [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5gqg a1_s5gqp b1_s5gqs of {
                      GHC.Types.False -> wild_s5gqj;
                      GHC.Types.True -> wild1_s5gqq;
                    };
              };
        };

Data.Either.$fOrdEither_$c>=
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b -> Data.Either.Either a b -> GHC.Types.Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gqu $dOrd1_s5gqv a1_s5gqw b1_s5gqx]
        case a1_s5gqw of {
          Data.Either.Left a2_s5gqz [Occ=Once] ->
              case b1_s5gqx of {
                Data.Either.Left b2_s5gqB [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5gqu a2_s5gqz b2_s5gqB of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
                Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
              };
          Data.Either.Right a2_s5gqE [Occ=Once] ->
              case b1_s5gqx of {
                Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
                Data.Either.Right b2_s5gqH [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5gqv a2_s5gqE b2_s5gqH of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

Data.Either.$fOrdEither_$cmin
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     Data.Either.Either a b
     -> Data.Either.Either a b -> Data.Either.Either a b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s5gqJ $dOrd1_s5gqK x_s5gqL y_s5gqM]
        case y_s5gqM of wild_s5gqN {
          Data.Either.Left a1_s5gqO [Occ=Once] ->
              case x_s5gqL of wild1_s5gqP {
                Data.Either.Left b1_s5gqQ [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s5gqJ a1_s5gqO b1_s5gqQ of {
                      GHC.Types.False -> wild1_s5gqP;
                      GHC.Types.True -> wild_s5gqN;
                    };
                Data.Either.Right _ [Occ=Dead] -> wild_s5gqN;
              };
          Data.Either.Right a1_s5gqT [Occ=Once] ->
              case x_s5gqL of wild1_s5gqU {
                Data.Either.Left _ [Occ=Dead] -> wild1_s5gqU;
                Data.Either.Right b1_s5gqW [Occ=Once] ->
                    case GHC.Classes.< $dOrd1_s5gqK a1_s5gqT b1_s5gqW of {
                      GHC.Types.False -> wild1_s5gqU;
                      GHC.Types.True -> wild_s5gqN;
                    };
              };
        };

Data.Either.$fOrdEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Classes.Ord a, GHC.Classes.Ord b) =>
     GHC.Classes.Ord (Data.Either.Either a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s5gqY $dOrd1_s5gqZ]
        let {
          sat_s5gr9 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$cmin
                      $dOrd_s5gqY $dOrd1_s5gqZ eta_B2 eta_B1; } in
        let {
          sat_s5gr8 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$cmax
                      $dOrd_s5gqY $dOrd1_s5gqZ eta_B2 eta_B1; } in
        let {
          sat_s5gr7 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$c>=
                      $dOrd_s5gqY $dOrd1_s5gqZ eta_B2 eta_B1; } in
        let {
          sat_s5gr6 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [a1_s5gr4 b1_s5gr5]
                  Data.Either.$fOrdEither_$c<
                      $dOrd_s5gqY $dOrd1_s5gqZ b1_s5gr5 a1_s5gr4; } in
        let {
          sat_s5gr3 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$c<=
                      $dOrd_s5gqY $dOrd1_s5gqZ eta_B2 eta_B1; } in
        let {
          sat_s5gr2 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$c<
                      $dOrd_s5gqY $dOrd1_s5gqZ eta_B2 eta_B1; } in
        let {
          sat_s5gr1 [Occ=Once]
            :: Data.Either.Either a_a5dVA b_a5dVB
               -> Data.Either.Either a_a5dVA b_a5dVB -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \r [eta_B2 eta_B1]
                  Data.Either.$fOrdEither_$ccompare
                      $dOrd_s5gqY $dOrd1_s5gqZ eta_B2 eta_B1; } in
        let {
          sat_s5gr0 [Occ=Once]
            :: GHC.Classes.Eq (Data.Either.Either a_a5dVA b_a5dVB)
          [LclId] =
              [$dOrd_s5gqY $dOrd1_s5gqZ] \u []
                  Data.Either.$fOrdEither_$cp1Ord $dOrd_s5gqY $dOrd1_s5gqZ;
        } in 
          GHC.Classes.C:Ord [sat_s5gr0
                             sat_s5gr1
                             sat_s5gr2
                             sat_s5gr3
                             sat_s5gr6
                             sat_s5gr7
                             sat_s5gr8
                             sat_s5gr9];

Data.Either.either
  :: forall a c b.
     (a -> c) -> (b -> c) -> Data.Either.Either a b -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s5gra ds_s5grb ds1_s5grc]
        case ds1_s5grc of {
          Data.Either.Left x_s5gre [Occ=Once] -> f_s5gra x_s5gre;
          Data.Either.Right y_s5grf [Occ=Once] -> ds_s5grb y_s5grf;
        };

Data.Either.$wpartitionEithers [InlPrag=NOUSERINLINE[0],
                                Occ=LoopBreaker]
  :: forall a b. [Data.Either.Either a b] -> (# [a], [b] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [w_s5grg]
        case w_s5grg of {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : y_s5gri [Occ=Once!] ys_s5grj [Occ=Once] ->
              let {
                eta_s5grk [Dmd=<L,U(1*U,1*U)>] :: ([a_s5enu], [b_s5env])
                [LclId] =
                    [ys_s5grj] \u []
                        case Data.Either.$wpartitionEithers ys_s5grj of {
                          (#,#) ww1_s5grm [Occ=Once] ww2_s5grn [Occ=Once] ->
                              (,) [ww1_s5grm ww2_s5grn];
                        };
              } in 
                case y_s5gri of {
                  Data.Either.Left x_s5grp [Occ=Once] ->
                      let {
                        sat_s5gry [Occ=Once] :: [b_s5env]
                        [LclId] =
                            [eta_s5grk] \u []
                                case eta_s5grk of {
                                  (,) _ [Occ=Dead] r_s5grx [Occ=Once] -> r_s5grx;
                                }; } in
                      let {
                        sat_s5grt [Occ=Once] :: [a_s5enu]
                        [LclId] =
                            [eta_s5grk] \u []
                                case eta_s5grk of {
                                  (,) l_s5grr [Occ=Once] _ [Occ=Dead] -> l_s5grr;
                                }; } in
                      let {
                        sat_s5gru [Occ=Once] :: [a_s5enu]
                        [LclId] =
                            CCCS :! [x_s5grp sat_s5grt];
                      } in  (#,#) [sat_s5gru sat_s5gry];
                  Data.Either.Right y1_s5grz [Occ=Once] ->
                      let {
                        sat_s5grH [Occ=Once] :: [b_s5env]
                        [LclId] =
                            [eta_s5grk] \u []
                                case eta_s5grk of {
                                  (,) _ [Occ=Dead] r_s5grG [Occ=Once] -> r_s5grG;
                                }; } in
                      let {
                        sat_s5grI [Occ=Once] :: [b_s5env]
                        [LclId] =
                            CCCS :! [y1_s5grz sat_s5grH]; } in
                      let {
                        sat_s5grD [Occ=Once] :: [a_s5enu]
                        [LclId] =
                            [eta_s5grk] \u []
                                case eta_s5grk of {
                                  (,) l_s5grB [Occ=Once] _ [Occ=Dead] -> l_s5grB;
                                };
                      } in  (#,#) [sat_s5grD sat_s5grI];
                };
        };

Data.Either.partitionEithers [InlPrag=NOUSERINLINE[0]]
  :: forall a b. [Data.Either.Either a b] -> ([a], [b])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_s5grJ]
        case Data.Either.$wpartitionEithers w_s5grJ of {
          (#,#) ww1_s5grL [Occ=Once] ww2_s5grM [Occ=Once] ->
              (,) [ww1_s5grL ww2_s5grM];
        };

poly_go_r5exd :: forall a b. [Data.Either.Either a b] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds_s5grN]
        case ds_s5grN of {
          [] -> [] [];
          : y_s5grP [Occ=Once!] ys_s5grQ [Occ=Once*] ->
              case y_s5grP of {
                Data.Either.Left a1_s5grS [Occ=Once] ->
                    let {
                      sat_s5grT [Occ=Once] :: [a_a5dTY]
                      [LclId] =
                          [ys_s5grQ] \u [] poly_go_r5exd ys_s5grQ;
                    } in  : [a1_s5grS sat_s5grT];
                Data.Either.Right _ [Occ=Dead] -> poly_go_r5exd ys_s5grQ;
              };
        };

Data.Either.lefts [InlPrag=INLINABLE]
  :: forall a b. [Data.Either.Either a b] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s5grV] poly_go_r5exd x_s5grV;

poly_go1_r5exe :: forall a b. [Data.Either.Either a b] -> [b]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds_s5grW]
        case ds_s5grW of {
          [] -> [] [];
          : y_s5grY [Occ=Once!] ys_s5grZ [Occ=Once*] ->
              case y_s5grY of {
                Data.Either.Left _ [Occ=Dead] -> poly_go1_r5exe ys_s5grZ;
                Data.Either.Right a1_s5gs2 [Occ=Once] ->
                    let {
                      sat_s5gs3 [Occ=Once] :: [b_a5dTV]
                      [LclId] =
                          [ys_s5grZ] \u [] poly_go1_r5exe ys_s5grZ;
                    } in  : [a1_s5gs2 sat_s5gs3];
              };
        };

Data.Either.rights [InlPrag=INLINABLE]
  :: forall a b. [Data.Either.Either a b] -> [b]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s5gs4] poly_go1_r5exe x_s5gs4;

Data.Either.isLeft
  :: forall a b. Data.Either.Either a b -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5gs5]
        case ds_s5gs5 of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Types.True [];
          Data.Either.Right _ [Occ=Dead] -> GHC.Types.False [];
        };

Data.Either.isRight
  :: forall a b. Data.Either.Either a b -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5gs9]
        case ds_s5gs9 of {
          Data.Either.Left _ [Occ=Dead] -> GHC.Types.False [];
          Data.Either.Right _ [Occ=Dead] -> GHC.Types.True [];
        };

Data.Either.fromLeft
  :: forall a b. a -> Data.Either.Either a b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5gsd ds1_s5gse]
        case ds1_s5gse of {
          Data.Either.Left a1_s5gsg [Occ=Once] -> a1_s5gsg;
          Data.Either.Right _ [Occ=Dead] -> ds_s5gsd;
        };

Data.Either.fromRight
  :: forall b a. b -> Data.Either.Either a b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5gsi ds1_s5gsj]
        case ds1_s5gsj of {
          Data.Either.Left _ [Occ=Dead] -> ds_s5gsi;
          Data.Either.Right b1_s5gsm [Occ=Once] -> b1_s5gsm;
        };

Data.Either.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Either.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$trModule4];

Data.Either.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Either"#;

Data.Either.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$trModule2];

Data.Either.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Either.$trModule3
                                     Data.Either.$trModule1];

$krep_r5exf :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep1_r5exg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Either.$tcEither2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Either"#;

Data.Either.$tcEither1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$tcEither2];

Data.Either.$tcEither :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16074290893719807138##
                                    14958199358864670905##
                                    Data.Either.$trModule
                                    Data.Either.$tcEither1
                                    0#
                                    GHC.Types.krep$*->*->*];

$krep2_r5exh :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r5exf GHC.Types.[]];

$krep3_r5exi :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r5exg $krep2_r5exh];

$krep4_r5exj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Either.$tcEither
                                              $krep3_r5exi];

Data.Either.$tc'Left1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r5exg $krep4_r5exj];

Data.Either.$tc'Left3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Left"#;

Data.Either.$tc'Left2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$tc'Left3];

Data.Either.$tc'Left :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14915236324383360020##
                                    11027491440201056612##
                                    Data.Either.$trModule
                                    Data.Either.$tc'Left2
                                    2#
                                    Data.Either.$tc'Left1];

Data.Either.$tc'Right1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r5exf $krep4_r5exj];

Data.Either.$tc'Right3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Right"#;

Data.Either.$tc'Right2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Either.$tc'Right3];

Data.Either.$tc'Right :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10395468319011834275##
                                    16371021254350888909##
                                    Data.Either.$trModule
                                    Data.Either.$tc'Right2
                                    2#
                                    Data.Either.$tc'Right1];

Data.Either.Left :: forall a b. a -> Data.Either.Either a b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m1,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Either.Left [eta_B1];

Data.Either.Right :: forall a b. b -> Data.Either.Either a b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Either.Right [eta_B1];

