
==================== Raw Cmm ====================
2018-03-16 16:07:30.849637533 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:07:30.851343881 UTC

[section ""data" . lvl_rcBZq_closure" {
     lvl_rcBZq_closure:
         const lvl_rcBZq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rcBZq_entry() //  [R1]
         { []
         }
     {offset
       ccC9g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccC9h; else goto ccC9i;
       ccC9h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccC9i: // global
           (_ccC9d::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccC9d::I64 == 0) goto ccC9f; else goto ccC9e;
       ccC9f: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccC9e: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccC9d::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_rcBZq_info" {
     lvl_rcBZq_info:
         const lvl_rcBZq_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.855216937 UTC

[section ""data" . sat_scBZu_closure" {
     sat_scBZu_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.858364834 UTC

[section ""data" . sat_scBZv_closure" {
     sat_scBZv_closure:
         const :_con_info;
         const sat_scBZu_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.86057017 UTC

[section ""data" . lvl1_rcBZr_closure" {
     lvl1_rcBZr_closure:
         const lvl1_rcBZr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rcBZr_entry() //  [R1]
         { []
         }
     {offset
       ccC9y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccC9z; else goto ccC9A;
       ccC9z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccC9A: // global
           (_ccC9v::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccC9v::I64 == 0) goto ccC9x; else goto ccC9w;
       ccC9x: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccC9w: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccC9v::I64;
           R3 = sat_scBZv_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_rcBZr_info" {
     lvl1_rcBZr_info:
         const lvl1_rcBZr_entry;
         const 0;
         const 4294967317;
         const ScC0R_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.871985278 UTC

[section ""data" . $wsimplest'_rcBZs_closure" {
     $wsimplest'_rcBZs_closure:
         const $wsimplest'_rcBZs_info;
         const 0;
 },
 $wsimplest'_rcBZs_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ccC9R: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccC9S; else goto ccC9T;
       ccC9S: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wsimplest'_rcBZs_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccC9T: // global
           I64[Sp - 40] = block_ccC9M_info;
           _scBZx::P64 = R3;
           R3 = lvl_rcBZq_closure;
           _scBZw::P64 = R2;
           R2 = _scBZx::P64;
           P64[Sp - 32] = _scBZw::P64;
           P64[Sp - 24] = _scBZx::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wsimplest'_rcBZs_info" {
     $wsimplest'_rcBZs_info:
         const $wsimplest'_rcBZs_entry;
         const 0;
         const 270582939662;
         const 17179869208;
         const ScC0R_srt+8;
 },
 _ccC9M() //  [R1]
         { []
         }
     {offset
       ccC9M: // global
           if (R1 == 1) goto ucCb1; else goto ccC9P;
       ucCb1: // global
           Sp = Sp + 40;
           call _ccC9Q() args: 0, res: 0, upd: 0;
       ccC9P: // global
           _scBZw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccC9W_info;
           R3 = P64[Sp + 16];
           R2 = _scBZw::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccC9M_info" {
     block_ccC9M_info:
         const _ccC9M;
         const 4;
         const 270582939678;
         const ScC0R_srt+8;
 },
 _ccC9W() //  [R1, R2]
         { []
         }
     {offset
       ccC9W: // global
           I64[Sp - 16] = block_ccC9Y_info;
           R3 = lvl_rcBZq_closure;
           _scBZD::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _scBZD::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccC9W_info" {
     block_ccC9W_info:
         const _ccC9W;
         const 3;
         const 270582939678;
         const ScC0R_srt+8;
 },
 _ccC9Y() //  [R1]
         { []
         }
     {offset
       ccC9Y: // global
           if (R1 == 1) goto ccCaS; else goto ccCa7;
       ccCaS: // global
           I64[Sp + 40] = block_ccCaQ_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ucCb4; else goto ccCaT;
       ucCb4: // global
           call _ccCaQ(R1) args: 0, res: 0, upd: 0;
       ccCaT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccCa7: // global
           I64[Sp] = block_ccCa4_info;
           R3 = lvl_rcBZq_closure;
           R2 = P64[Sp + 40];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccC9Y_info" {
     block_ccC9Y_info:
         const _ccC9Y;
         const 5;
         const 270582939678;
         const ScC0R_srt+8;
 },
 _ccCaQ() //  [R1]
         { []
         }
     {offset
       ccCaQ: // global
           R2 = lvl1_rcBZr_closure;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCaQ_info" {
     block_ccCaQ_info:
         const _ccCaQ;
         const 0;
         const 4294967326;
         const ScC0R_srt+40;
 },
 _ccCa4() //  [R1]
         { []
         }
     {offset
       ccCa4: // global
           if (R1 == 1) goto ucCb2; else goto ccCag;
       ucCb2: // global
           Sp = Sp + 48;
           call _ccC9Q() args: 0, res: 0, upd: 0;
       ccCag: // global
           I64[Sp] = block_ccCab_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCa4_info" {
     block_ccCa4_info:
         const _ccCa4;
         const 5;
         const 236223201310;
         const ScC0R_srt+8;
 },
 _ccC9Q() //  []
         { []
         }
     {offset
       ccC9Q: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccCab() //  [R1, R2]
         { []
         }
     {offset
       ccCab: // global
           I64[Sp] = block_ccCad_info;
           R3 = R1;
           _scBZI::P64 = R2;
           R2 = P64[Sp + 16];
           P64[Sp + 32] = _scBZI::P64;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCab_info" {
     block_ccCab_info:
         const _ccCab;
         const 517;
         const 219043332126;
         const ScC0R_srt+8;
 },
 _ccCad() //  [R1]
         { []
         }
     {offset
       ccCad: // global
           if (R1 == 1) goto ccCaF; else goto ccCau;
       ccCaF: // global
           I64[Sp + 40] = block_ccCaD_info;
           R3 = lvl1_rcBZr_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 40;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       ccCau: // global
           _scBZD::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCal_info;
           R5 = _scBZD::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCad_info" {
     block_ccCad_info:
         const _ccCad;
         const 5;
         const 219043332126;
         const ScC0R_srt+8;
 },
 _ccCaD() //  [R1]
         { []
         }
     {offset
       ccCaD: // global
           R2 = lvl1_rcBZr_closure;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCaD_info" {
     block_ccCaD_info:
         const _ccCaD;
         const 0;
         const 4294967326;
         const ScC0R_srt+40;
 },
 _ccCal() //  [R1, R2]
         { []
         }
     {offset
       ccCal: // global
           I64[Sp + 16] = block_ccCan_info;
           R3 = R1;
           _scBZM::P64 = R2;
           R2 = P64[Sp + 8];
           P64[Sp + 24] = _scBZM::P64;
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCal_info" {
     block_ccCal_info:
         const _ccCal;
         const 900;
         const 12884901918;
         const ScC0R_srt+8;
 },
 _ccCan() //  [R1]
         { []
         }
     {offset
       ccCan: // global
           _scBZM::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCar_info;
           R3 = _scBZM::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCan_info" {
     block_ccCan_info:
         const _ccCan;
         const 2;
         const 4294967326;
         const ScC0R_srt+8;
 },
 _ccCar() //  [R1]
         { []
         }
     {offset
       ccCar: // global
           R2 = P64[Sp + 8];
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCar_info" {
     block_ccCar_info:
         const _ccCar;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.903876285 UTC

[section ""data" . Data.Ratio.$wsimplest_closure" {
     Data.Ratio.$wsimplest_closure:
         const Data.Ratio.$wsimplest_info;
         const 0;
 },
 sat_scC06_entry() //  [R1]
         { []
         }
     {offset
       ccCcu: // global
           R2 = P64[R1 + 16];
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_scC06_info" {
     sat_scC06_info:
         const sat_scC06_entry;
         const 1;
         const 16;
 },
 Data.Ratio.$wsimplest_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ccCcx: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccCcy; else goto ucCdD;
       ccCcy: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.$wsimplest_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ucCdD: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _ccCbP() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . Data.Ratio.$wsimplest_info" {
     Data.Ratio.$wsimplest_info:
         const Data.Ratio.$wsimplest_entry;
         const 0;
         const 1086626725902;
         const 17179869208;
         const ScC0R_srt+16;
 },
 _ccCbP() //  []
         { []
         }
     {offset
       ccCbP: // global
           I64[Sp - 8] = block_ccCbS_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCbS() //  [R1]
         { []
         }
     {offset
       ccCbS: // global
           I64[Sp - 8] = block_ccCbW_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCbS_info" {
     block_ccCbS_info:
         const _ccCbS;
         const 4;
         const 536870912030;
         const ScC0R_srt+16;
 },
 _ccCbW() //  [R1]
         { []
         }
     {offset
       ccCbW: // global
           _scBZY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCc0_info;
           R3 = _scBZY::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCbW_info" {
     block_ccCbW_info:
         const _ccCbW;
         const 5;
         const 536870912030;
         const ScC0R_srt+16;
 },
 _ccCc0() //  [R1]
         { []
         }
     {offset
       ccCc0: // global
           _scBZT::P64 = P64[Sp + 8];
           _scBZV::P64 = P64[Sp + 24];
           if (R1 == 1) goto ccCdz; else goto ccCda;
       ccCdz: // global
           _ccCdB::P64 = _scBZV::P64;
           P64[Sp + 8] = _ccCdB::P64;
           _scBZW::P64 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 32];
           P64[Sp + 24] = _scBZT::P64;
           P64[Sp + 32] = _scBZW::P64;
           Sp = Sp + 8;
           call _ccCbP() args: 0, res: 0, upd: 0;
       ccCda: // global
           I64[Sp] = block_ccCcC_info;
           R3 = _scBZV::P64;
           R2 = _scBZT::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCc0_info" {
     block_ccCc0_info:
         const _ccCc0;
         const 4;
         const 536870912030;
         const ScC0R_srt+16;
 },
 _ccCcC() //  [R1]
         { []
         }
     {offset
       ccCcC: // global
           if (R1 == 1) goto ccCdl; else goto ucCdE;
       ccCdl: // global
           I64[Sp] = block_ccCdj_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ucCdE: // global
           Sp = Sp + 8;
           call _scC00() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ccCcC_info" {
     block_ccCcC_info:
         const _ccCcC;
         const 4;
         const 536870912030;
         const ScC0R_srt+16;
 },
 _ccCdj() //  [R1]
         { []
         }
     {offset
       ccCdj: // global
           if (R1 == 1) goto ccCdv; else goto ucCdF;
       ccCdv: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ucCdF: // global
           Sp = Sp + 8;
           call _scC00() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ccCdj_info" {
     block_ccCdj_info:
         const _ccCdj;
         const 4;
         const 536870912030;
         const ScC0R_srt+16;
 },
 _scC00() //  []
         { []
         }
     {offset
       scC00: // global
           I64[Sp - 8] = block_ccCc9_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = lvl_rcBZq_closure;
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCc9() //  [R1]
         { []
         }
     {offset
       ccCc9: // global
           _scBZW::P64 = P64[Sp + 32];
           if (R1 & 7 == 3) goto ccCd8; else goto ccCcH;
       ccCd8: // global
           R5 = _scBZW::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
       ccCcH: // global
           I64[Sp] = block_ccCcd_info;
           R3 = _scBZW::P64;
           R2 = lvl_rcBZq_closure;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCc9_info" {
     block_ccCc9_info:
         const _ccCc9;
         const 4;
         const 399431958558;
         const ScC0R_srt+16;
 },
 _ccCcd() //  [R1]
         { []
         }
     {offset
       ccCcd: // global
           I64[Sp - 8] = block_ccCch_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCcd_info" {
     block_ccCcd_info:
         const _ccCcd;
         const 4;
         const 399431958558;
         const ScC0R_srt+16;
 },
 _ccCch() //  [R1]
         { []
         }
     {offset
       ccCch: // global
           _scC03::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCcl_info;
           R3 = _scC03::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCch_info" {
     block_ccCch_info:
         const _ccCch;
         const 5;
         const 30064771102;
         const ScC0R_srt+32;
 },
 _ccCcl() //  [R1]
         { []
         }
     {offset
       ccCcl: // global
           if (R1 == 1) goto ccCcV; else goto ccCcN;
       ccCcV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccCcY; else goto ccCcX;
       ccCcY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccCcX: // global
           I64[Hp - 16] = sat_scC06_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccCcO_info;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       ccCcN: // global
           R2 = lvl1_rcBZr_closure;
           R1 = lvl_rcBZq_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCcl_info" {
     block_ccCcl_info:
         const _ccCcl;
         const 4;
         const 30064771102;
         const ScC0R_srt+32;
 },
 _ccCcO() //  [R1]
         { []
         }
     {offset
       ccCcO: // global
           _scBZW::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccCcS_info;
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 16];
           R3 = _scBZW::P64;
           R2 = R1;
           Sp = Sp + 24;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCcO_info" {
     block_ccCcO_info:
         const _ccCcO;
         const 3;
         const 4294967326;
         const ScC0R_srt+48;
 },
 _ccCcS() //  [R1, R2]
         { []
         }
     {offset
       ccCcS: // global
           I64[Sp - 8] = block_ccCcU_info;
           _scC09::P64 = R2;
           R2 = R1;
           P64[Sp] = _scC09::P64;
           Sp = Sp - 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCcS_info" {
     block_ccCcS_info:
         const _ccCcS;
         const 0;
         const 30;
 },
 _ccCcU() //  [R1]
         { []
         }
     {offset
       ccCcU: // global
           R2 = P64[Sp + 8];
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCcU_info" {
     block_ccCcU_info:
         const _ccCcU;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.93385123 UTC

[section ""data" . Data.Ratio.$wapproxRational_closure" {
     Data.Ratio.$wapproxRational_closure:
         const Data.Ratio.$wapproxRational_info;
         const 0;
 },
 Data.Ratio.$wapproxRational_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccCeL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccCeZ; else goto ccCf0;
       ccCeZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.$wapproxRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccCf0: // global
           I64[Sp - 24] = block_ccCeJ_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Data.Ratio.$wapproxRational_info" {
     Data.Ratio.$wapproxRational_info:
         const Data.Ratio.$wapproxRational_entry;
         const 0;
         const 64424509454;
         const 12884901911;
         const ScC0R_srt+72;
 },
 _ccCeJ() //  [R1]
         { []
         }
     {offset
       ccCeJ: // global
           I64[Sp] = block_ccCeO_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCeJ_info" {
     block_ccCeJ_info:
         const _ccCeJ;
         const 2;
         const 30064771102;
         const ScC0R_srt+72;
 },
 _ccCeO() //  [R1]
         { []
         }
     {offset
       ccCeO: // global
           I64[Sp] = block_ccCeS_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCeO_info" {
     block_ccCeO_info:
         const _ccCeO;
         const 2;
         const 30064771102;
         const ScC0R_srt+72;
 },
 _ccCeS() //  [R1]
         { []
         }
     {offset
       ccCeS: // global
           I64[Sp - 16] = block_ccCeW_info;
           _scC0m::P64 = P64[R1 + 15];
           R5 = _scC0m::P64;
           _scC0l::P64 = P64[R1 + 7];
           R4 = _scC0l::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp - 8] = _scC0m::P64;
           P64[Sp] = _scC0l::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCeS_info" {
     block_ccCeS_info:
         const _ccCeS;
         const 2;
         const 30064771102;
         const ScC0R_srt+72;
 },
 _ccCeW() //  [R1, R2]
         { []
         }
     {offset
       ccCeW: // global
           _scC0l::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccCeY_info;
           R5 = P64[Sp + 8];
           R4 = _scC0l::P64;
           R3 = P64[Sp + 24];
           _scC0p::P64 = R2;
           R2 = P64[Sp + 32];
           P64[Sp + 24] = _scC0p::P64;
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCeW_info" {
     block_ccCeW_info:
         const _ccCeW;
         const 4;
         const 12884901918;
         const ScC0R_srt+72;
 },
 _ccCeY() //  [R1, R2]
         { []
         }
     {offset
       ccCeY: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Ratio.$wsimplest_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCeY_info" {
     block_ccCeY_info:
         const _ccCeY;
         const 2;
         const 4294967326;
         const ScC0R_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.946202981 UTC

[section ""data" . Data.Ratio.approxRational_closure" {
     Data.Ratio.approxRational_closure:
         const Data.Ratio.approxRational_info;
         const 0;
 },
 Data.Ratio.approxRational_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccCfC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccCfD; else goto ccCfE;
       ccCfD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.approxRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccCfE: // global
           I64[Sp - 8] = block_ccCfz_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Ratio.$wapproxRational_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Data.Ratio.approxRational_info" {
     Data.Ratio.approxRational_info:
         const Data.Ratio.approxRational_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const ScC0R_srt+96;
 },
 _ccCfz() //  [R1, R2]
         { []
         }
     {offset
       ccCfz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccCfH; else goto ccCfG;
       ccCfH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccCfG: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCfz_info" {
     block_ccCfz_info:
         const _ccCfz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.951516709 UTC

[section ""cstring" . Data.Ratio.$trModule4_bytes" {
     Data.Ratio.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.953199421 UTC

[section ""data" . Data.Ratio.$trModule3_closure" {
     Data.Ratio.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Ratio.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.954904468 UTC

[section ""cstring" . Data.Ratio.$trModule2_bytes" {
     Data.Ratio.$trModule2_bytes:
         I8[] [68,97,116,97,46,82,97,116,105,111]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.956536942 UTC

[section ""data" . Data.Ratio.$trModule1_closure" {
     Data.Ratio.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Ratio.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.958251381 UTC

[section ""data" . Data.Ratio.$trModule_closure" {
     Data.Ratio.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Ratio.$trModule3_closure+1;
         const Data.Ratio.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.960081133 UTC

[section ""relreadonly" . ScC0R_srt" {
     ScC0R_srt:
         const sat_scBZv_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.divZeroError_closure;
         const lvl_rcBZq_closure;
         const lvl1_rcBZr_closure;
         const $wsimplest'_rcBZs_closure;
         const GHC.Real.$w$s$ccompare_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const Data.Ratio.$wsimplest_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$w$s$c-_closure;
         const Data.Ratio.$wapproxRational_closure;
         const Data.Ratio.approxRational_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.130562687 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:07:31.132476863 UTC

[section ""data" . lvl_rcBZq_closure" {
     lvl_rcBZq_closure:
         const lvl_rcBZq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rcBZq_entry() //  [R1]
         { []
         }
     {offset
       ccCh8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCh9; else goto ccCha;
       ccCh9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCha: // global
           (_ccCh5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCh5::I64 == 0) goto ccCh7; else goto ccCh6;
       ccCh7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCh6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCh5::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_rcBZq_info" {
     lvl_rcBZq_info:
         const lvl_rcBZq_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.136453485 UTC

[section ""data" . sat_scCfX_closure" {
     sat_scCfX_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.138264728 UTC

[section ""data" . sat_scCfY_closure" {
     sat_scCfY_closure:
         const :_con_info;
         const sat_scCfX_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.140743466 UTC

[section ""data" . lvl1_rcBZr_closure" {
     lvl1_rcBZr_closure:
         const lvl1_rcBZr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rcBZr_entry() //  [R1]
         { []
         }
     {offset
       ccCht: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccChu; else goto ccChv;
       ccChu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccChv: // global
           (_ccChq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccChq::I64 == 0) goto ccChs; else goto ccChr;
       ccChs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccChr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccChq::I64;
           R3 = sat_scCfY_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_rcBZr_info" {
     lvl1_rcBZr_info:
         const lvl1_rcBZr_entry;
         const 0;
         const 4294967317;
         const ScChw_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.149705641 UTC

[section ""data" . $wsimplest'_rcBZs_closure" {
     $wsimplest'_rcBZs_closure:
         const $wsimplest'_rcBZs_info;
         const 0;
 },
 $wsimplest'_rcBZs_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ccChP: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccChQ; else goto ccChR;
       ccChQ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wsimplest'_rcBZs_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccChR: // global
           I64[Sp - 40] = block_ccChK_info;
           _scCg0::P64 = R3;
           R3 = lvl_rcBZq_closure;
           _scCfZ::P64 = R2;
           R2 = _scCg0::P64;
           P64[Sp - 32] = _scCfZ::P64;
           P64[Sp - 24] = _scCg0::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wsimplest'_rcBZs_info" {
     $wsimplest'_rcBZs_info:
         const $wsimplest'_rcBZs_entry;
         const 0;
         const 270582939662;
         const 17179869208;
         const ScChw_srt+8;
 },
 _ccChK() //  [R1]
         { []
         }
     {offset
       ccChK: // global
           if (R1 == 1) goto ucCiZ; else goto ccChN;
       ucCiZ: // global
           Sp = Sp + 40;
           call _ccChO() args: 0, res: 0, upd: 0;
       ccChN: // global
           _scCfZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccChU_info;
           R3 = P64[Sp + 16];
           R2 = _scCfZ::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccChK_info" {
     block_ccChK_info:
         const _ccChK;
         const 4;
         const 270582939678;
         const ScChw_srt+8;
 },
 _ccChU() //  [R1, R2]
         { []
         }
     {offset
       ccChU: // global
           I64[Sp - 16] = block_ccChW_info;
           R3 = lvl_rcBZq_closure;
           _scCg6::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _scCg6::P64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccChU_info" {
     block_ccChU_info:
         const _ccChU;
         const 3;
         const 270582939678;
         const ScChw_srt+8;
 },
 _ccChW() //  [R1]
         { []
         }
     {offset
       ccChW: // global
           if (R1 == 1) goto ccCiQ; else goto ccCi5;
       ccCiQ: // global
           I64[Sp + 40] = block_ccCiO_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           if (R1 & 7 != 0) goto ucCj2; else goto ccCiR;
       ucCj2: // global
           call _ccCiO(R1) args: 0, res: 0, upd: 0;
       ccCiR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccCi5: // global
           I64[Sp] = block_ccCi2_info;
           R3 = lvl_rcBZq_closure;
           R2 = P64[Sp + 40];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccChW_info" {
     block_ccChW_info:
         const _ccChW;
         const 5;
         const 270582939678;
         const ScChw_srt+8;
 },
 _ccCiO() //  [R1]
         { []
         }
     {offset
       ccCiO: // global
           R2 = lvl1_rcBZr_closure;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCiO_info" {
     block_ccCiO_info:
         const _ccCiO;
         const 0;
         const 4294967326;
         const ScChw_srt+40;
 },
 _ccCi2() //  [R1]
         { []
         }
     {offset
       ccCi2: // global
           if (R1 == 1) goto ucCj0; else goto ccCie;
       ucCj0: // global
           Sp = Sp + 48;
           call _ccChO() args: 0, res: 0, upd: 0;
       ccCie: // global
           I64[Sp] = block_ccCi9_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 32];
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCi2_info" {
     block_ccCi2_info:
         const _ccCi2;
         const 5;
         const 236223201310;
         const ScChw_srt+8;
 },
 _ccChO() //  []
         { []
         }
     {offset
       ccChO: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccCi9() //  [R1, R2]
         { []
         }
     {offset
       ccCi9: // global
           I64[Sp] = block_ccCib_info;
           R3 = R1;
           _scCgb::P64 = R2;
           R2 = P64[Sp + 16];
           P64[Sp + 32] = _scCgb::P64;
           call GHC.Integer.Type.neqInteger#_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCi9_info" {
     block_ccCi9_info:
         const _ccCi9;
         const 517;
         const 219043332126;
         const ScChw_srt+8;
 },
 _ccCib() //  [R1]
         { []
         }
     {offset
       ccCib: // global
           if (R1 == 1) goto ccCiD; else goto ccCis;
       ccCiD: // global
           I64[Sp + 40] = block_ccCiB_info;
           R3 = lvl1_rcBZr_closure;
           R2 = P64[Sp + 16];
           Sp = Sp + 40;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
       ccCis: // global
           _scCg6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCij_info;
           R5 = _scCg6::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           Sp = Sp + 8;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCib_info" {
     block_ccCib_info:
         const _ccCib;
         const 5;
         const 219043332126;
         const ScChw_srt+8;
 },
 _ccCiB() //  [R1]
         { []
         }
     {offset
       ccCiB: // global
           R2 = lvl1_rcBZr_closure;
           R1 = R1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCiB_info" {
     block_ccCiB_info:
         const _ccCiB;
         const 0;
         const 4294967326;
         const ScChw_srt+40;
 },
 _ccCij() //  [R1, R2]
         { []
         }
     {offset
       ccCij: // global
           I64[Sp + 16] = block_ccCil_info;
           R3 = R1;
           _scCgf::P64 = R2;
           R2 = P64[Sp + 8];
           P64[Sp + 24] = _scCgf::P64;
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCij_info" {
     block_ccCij_info:
         const _ccCij;
         const 900;
         const 12884901918;
         const ScChw_srt+8;
 },
 _ccCil() //  [R1]
         { []
         }
     {offset
       ccCil: // global
           _scCgf::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCip_info;
           R3 = _scCgf::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCil_info" {
     block_ccCil_info:
         const _ccCil;
         const 2;
         const 4294967326;
         const ScChw_srt+8;
 },
 _ccCip() //  [R1]
         { []
         }
     {offset
       ccCip: // global
           R2 = P64[Sp + 8];
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCip_info" {
     block_ccCip_info:
         const _ccCip;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.178491688 UTC

[section ""data" . Data.Ratio.$wsimplest_closure" {
     Data.Ratio.$wsimplest_closure:
         const Data.Ratio.$wsimplest_info;
         const 0;
 },
 sat_scCgz_entry() //  [R1]
         { []
         }
     {offset
       ccCkD: // global
           R2 = P64[R1 + 16];
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_scCgz_info" {
     sat_scCgz_info:
         const sat_scCgz_entry;
         const 1;
         const 16;
 },
 Data.Ratio.$wsimplest_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ccCkG: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccCkH; else goto ucClM;
       ccCkH: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.$wsimplest_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ucClM: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call _ccCjY() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . Data.Ratio.$wsimplest_info" {
     Data.Ratio.$wsimplest_info:
         const Data.Ratio.$wsimplest_entry;
         const 0;
         const 1086626725902;
         const 17179869208;
         const ScChw_srt+16;
 },
 _ccCjY() //  []
         { []
         }
     {offset
       ccCjY: // global
           I64[Sp - 8] = block_ccCk1_info;
           R3 = P64[Sp + 24];
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCk1() //  [R1]
         { []
         }
     {offset
       ccCk1: // global
           I64[Sp - 8] = block_ccCk5_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCk1_info" {
     block_ccCk1_info:
         const _ccCk1;
         const 4;
         const 536870912030;
         const ScChw_srt+16;
 },
 _ccCk5() //  [R1]
         { []
         }
     {offset
       ccCk5: // global
           _scCgr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCk9_info;
           R3 = _scCgr::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCk5_info" {
     block_ccCk5_info:
         const _ccCk5;
         const 5;
         const 536870912030;
         const ScChw_srt+16;
 },
 _ccCk9() //  [R1]
         { []
         }
     {offset
       ccCk9: // global
           _scCgm::P64 = P64[Sp + 8];
           _scCgo::P64 = P64[Sp + 24];
           if (R1 == 1) goto ccClI; else goto ccClj;
       ccClI: // global
           _ccClK::P64 = _scCgo::P64;
           P64[Sp + 8] = _ccClK::P64;
           _scCgp::P64 = P64[Sp + 16];
           P64[Sp + 16] = P64[Sp + 32];
           P64[Sp + 24] = _scCgm::P64;
           P64[Sp + 32] = _scCgp::P64;
           Sp = Sp + 8;
           call _ccCjY() args: 0, res: 0, upd: 0;
       ccClj: // global
           I64[Sp] = block_ccCkL_info;
           R3 = _scCgo::P64;
           R2 = _scCgm::P64;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCk9_info" {
     block_ccCk9_info:
         const _ccCk9;
         const 4;
         const 536870912030;
         const ScChw_srt+16;
 },
 _ccCkL() //  [R1]
         { []
         }
     {offset
       ccCkL: // global
           if (R1 == 1) goto ccClu; else goto ucClN;
       ccClu: // global
           I64[Sp] = block_ccCls_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       ucClN: // global
           Sp = Sp + 8;
           call _scCgt() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ccCkL_info" {
     block_ccCkL_info:
         const _ccCkL;
         const 4;
         const 536870912030;
         const ScChw_srt+16;
 },
 _ccCls() //  [R1]
         { []
         }
     {offset
       ccCls: // global
           if (R1 == 1) goto ccClE; else goto ucClO;
       ccClE: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ucClO: // global
           Sp = Sp + 8;
           call _scCgt() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ccCls_info" {
     block_ccCls_info:
         const _ccCls;
         const 4;
         const 536870912030;
         const ScChw_srt+16;
 },
 _scCgt() //  []
         { []
         }
     {offset
       scCgt: // global
           I64[Sp - 8] = block_ccCki_info;
           R5 = GHC.Real.$fEnumRatio1_closure;
           R4 = lvl_rcBZq_closure;
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           Sp = Sp - 8;
           call GHC.Real.$w$s$ccompare_entry(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccCki() //  [R1]
         { []
         }
     {offset
       ccCki: // global
           _scCgp::P64 = P64[Sp + 32];
           if (R1 & 7 == 3) goto ccClh; else goto ccCkQ;
       ccClh: // global
           R5 = _scCgp::P64;
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
       ccCkQ: // global
           I64[Sp] = block_ccCkm_info;
           R3 = _scCgp::P64;
           R2 = lvl_rcBZq_closure;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCki_info" {
     block_ccCki_info:
         const _ccCki;
         const 4;
         const 399431958558;
         const ScChw_srt+16;
 },
 _ccCkm() //  [R1]
         { []
         }
     {offset
       ccCkm: // global
           I64[Sp - 8] = block_ccCkq_info;
           R3 = GHC.Real.$fEnumRatio1_closure;
           R2 = P64[Sp + 24];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCkm_info" {
     block_ccCkm_info:
         const _ccCkm;
         const 4;
         const 399431958558;
         const ScChw_srt+16;
 },
 _ccCkq() //  [R1]
         { []
         }
     {offset
       ccCkq: // global
           _scCgw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCku_info;
           R3 = _scCgw::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCkq_info" {
     block_ccCkq_info:
         const _ccCkq;
         const 5;
         const 30064771102;
         const ScChw_srt+32;
 },
 _ccCku() //  [R1]
         { []
         }
     {offset
       ccCku: // global
           if (R1 == 1) goto ccCl4; else goto ccCkW;
       ccCl4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccCl7; else goto ccCl6;
       ccCl7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccCl6: // global
           I64[Hp - 16] = sat_scCgz_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccCkX_info;
           R2 = P64[Sp + 24];
           P64[Sp + 24] = Hp - 16;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       ccCkW: // global
           R2 = lvl1_rcBZr_closure;
           R1 = lvl_rcBZq_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCku_info" {
     block_ccCku_info:
         const _ccCku;
         const 4;
         const 30064771102;
         const ScChw_srt+32;
 },
 _ccCkX() //  [R1]
         { []
         }
     {offset
       ccCkX: // global
           _scCgp::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ccCl1_info;
           R5 = P64[Sp + 8];
           R4 = P64[Sp + 16];
           R3 = _scCgp::P64;
           R2 = R1;
           Sp = Sp + 24;
           call $wsimplest'_rcBZs_entry(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCkX_info" {
     block_ccCkX_info:
         const _ccCkX;
         const 3;
         const 4294967326;
         const ScChw_srt+48;
 },
 _ccCl1() //  [R1, R2]
         { []
         }
     {offset
       ccCl1: // global
           I64[Sp - 8] = block_ccCl3_info;
           _scCgC::P64 = R2;
           R2 = R1;
           P64[Sp] = _scCgC::P64;
           Sp = Sp - 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCl1_info" {
     block_ccCl1_info:
         const _ccCl1;
         const 0;
         const 30;
 },
 _ccCl3() //  [R1]
         { []
         }
     {offset
       ccCl3: // global
           R2 = P64[Sp + 8];
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCl3_info" {
     block_ccCl3_info:
         const _ccCl3;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.220015908 UTC

[section ""data" . Data.Ratio.$wapproxRational_closure" {
     Data.Ratio.$wapproxRational_closure:
         const Data.Ratio.$wapproxRational_info;
         const 0;
 },
 Data.Ratio.$wapproxRational_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccCn7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccCnl; else goto ccCnm;
       ccCnl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.$wapproxRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccCnm: // global
           I64[Sp - 24] = block_ccCn5_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1RealFrac_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Data.Ratio.$wapproxRational_info" {
     Data.Ratio.$wapproxRational_info:
         const Data.Ratio.$wapproxRational_entry;
         const 0;
         const 64424509454;
         const 12884901911;
         const ScChw_srt+72;
 },
 _ccCn5() //  [R1]
         { []
         }
     {offset
       ccCn5: // global
           I64[Sp] = block_ccCna_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCn5_info" {
     block_ccCn5_info:
         const _ccCn5;
         const 2;
         const 30064771102;
         const ScChw_srt+72;
 },
 _ccCna() //  [R1]
         { []
         }
     {offset
       ccCna: // global
           I64[Sp] = block_ccCne_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 7];
           Sp = Sp - 16;
           call GHC.Real.toRational_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCna_info" {
     block_ccCna_info:
         const _ccCna;
         const 2;
         const 30064771102;
         const ScChw_srt+72;
 },
 _ccCne() //  [R1]
         { []
         }
     {offset
       ccCne: // global
           I64[Sp - 16] = block_ccCni_info;
           _scCgP::P64 = P64[R1 + 15];
           R5 = _scCgP::P64;
           _scCgO::P64 = P64[R1 + 7];
           R4 = _scCgO::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           P64[Sp - 8] = _scCgP::P64;
           P64[Sp] = _scCgO::P64;
           Sp = Sp - 16;
           call GHC.Real.$w$s$c-_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCne_info" {
     block_ccCne_info:
         const _ccCne;
         const 2;
         const 30064771102;
         const ScChw_srt+72;
 },
 _ccCni() //  [R1, R2]
         { []
         }
     {offset
       ccCni: // global
           _scCgO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ccCnk_info;
           R5 = P64[Sp + 8];
           R4 = _scCgO::P64;
           R3 = P64[Sp + 24];
           _scCgS::P64 = R2;
           R2 = P64[Sp + 32];
           P64[Sp + 24] = _scCgS::P64;
           P64[Sp + 32] = R1;
           Sp = Sp + 16;
           call GHC.Real.$w$s$c+_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCni_info" {
     block_ccCni_info:
         const _ccCni;
         const 4;
         const 12884901918;
         const ScChw_srt+72;
 },
 _ccCnk() //  [R1, R2]
         { []
         }
     {offset
       ccCnk: // global
           R5 = R2;
           R4 = R1;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Ratio.$wsimplest_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCnk_info" {
     block_ccCnk_info:
         const _ccCnk;
         const 2;
         const 4294967326;
         const ScChw_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.232567358 UTC

[section ""data" . Data.Ratio.approxRational_closure" {
     Data.Ratio.approxRational_closure:
         const Data.Ratio.approxRational_info;
         const 0;
 },
 Data.Ratio.approxRational_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccCo5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccCo6; else goto ccCo7;
       ccCo6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Ratio.approxRational_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccCo7: // global
           I64[Sp - 8] = block_ccCo2_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Ratio.$wapproxRational_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Data.Ratio.approxRational_info" {
     Data.Ratio.approxRational_info:
         const Data.Ratio.approxRational_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const ScChw_srt+96;
 },
 _ccCo2() //  [R1, R2]
         { []
         }
     {offset
       ccCo2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccCoa; else goto ccCo9;
       ccCoa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ccCo9: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccCo2_info" {
     block_ccCo2_info:
         const _ccCo2;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.237692639 UTC

[section ""cstring" . Data.Ratio.$trModule4_bytes" {
     Data.Ratio.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.239930269 UTC

[section ""data" . Data.Ratio.$trModule3_closure" {
     Data.Ratio.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Ratio.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.241602012 UTC

[section ""cstring" . Data.Ratio.$trModule2_bytes" {
     Data.Ratio.$trModule2_bytes:
         I8[] [68,97,116,97,46,82,97,116,105,111]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.243329906 UTC

[section ""data" . Data.Ratio.$trModule1_closure" {
     Data.Ratio.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Ratio.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.244981324 UTC

[section ""data" . Data.Ratio.$trModule_closure" {
     Data.Ratio.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Ratio.$trModule3_closure+1;
         const Data.Ratio.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:31.246787527 UTC

[section ""relreadonly" . ScChw_srt" {
     ScChw_srt:
         const sat_scCfY_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.divZeroError_closure;
         const lvl_rcBZq_closure;
         const lvl1_rcBZr_closure;
         const $wsimplest'_rcBZs_closure;
         const GHC.Real.$w$s$ccompare_closure;
         const GHC.Real.$fEnumRatio1_closure;
         const Data.Ratio.$wsimplest_closure;
         const GHC.Real.$w$s$c+_closure;
         const GHC.Real.$w$s$c-_closure;
         const Data.Ratio.$wapproxRational_closure;
         const Data.Ratio.approxRational_closure;
 }]

